"Section"	"section_id"	"req_id"	"full_key"	"key_as_number"	"requirement"	"Test Availability"	"search_roots"	"search_terms"	"manual_search_terms"	"not_search_terms"	"not_files"	"max_matches"	"class_defs"	"methods"	"modules"	"protected"	"class_def"	"method"	"module"	"file_name"	"matched_files"	"methods_string"	"urls"	"method_text"	"matched_terms"	"qualified_method"	"Annotation?"	"New Req for S?"	"New CTS for S?"	"Comment(internal) e.g. why a test is not possible"	"CTS Bug Id"	"CDD Bug Id"	"Area"	"Shortened"	"Test Level"
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.app.cts.TaskDescriptionTest"	"testEmptyConstructor"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/TaskDescriptionTest.java"	""	"public void testEmptyConstructor() throws Exception {
        final Activity activity = mTaskDescriptionActivity.launchActivity(null);
        activity.setTaskDescription(new TaskDescription());
        assertTaskDescription(activity, null, TEST_NO_DATA, null);
    }

    private void assertTaskDescription(Activity activity, String label, int resId, Bitmap bitmap) {
        final ActivityManager am = (ActivityManager) activity.getSystemService(ACTIVITY_SERVICE);
        List<RecentTaskInfo> recentsTasks = am.getRecentTasks(1 /* maxNum */, 0 /* flags */);
        if (!recentsTasks.isEmpty()) {
            final RecentTaskInfo info = recentsTasks.get(0);
            if (activity.getTaskId() == info.id) {
                final TaskDescription td = info.taskDescription;
                assertNotNull(td);
                if (bitmap != null) {
                    // TaskPersister at the worst case scenario waits 3 secs (PRE_TASK_DELAY_MS) to
                    // write the image to disk if its write time has ended
                    waitFor(""TaskDescription's icon is null"", () -> td.getIcon() != null);
                    waitFor(""TaskDescription's icon filename is null"",
                            () -> td.getIconFilename() != null);
                } else {
                    waitFor(""TaskDescription's icon is not null"", () -> td.getIcon() == null);
                    waitFor(""TaskDescription's icon filename is not null"",
                            () -> td.getIconFilename() == null);
                }

                assertEquals(resId, td.getIconResource());
                assertEquals(label, td.getLabel());
                return;
            }
        }
        fail(""Did not find activity (id="" + activity.getTaskId() + "") in recent tasks list"");
    }

    private void waitFor(String message, BooleanSupplier waitCondition) {
        for (int retry = 0; retry < WAIT_RETRIES; retry++) {
            if (waitCondition.getAsBoolean()) {
                return;
            }
            SystemClock.sleep(WAIT_TIMEOUT_MS);
        }
        fail(message);
    }
}"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.host.ScopedStorageInstantAppHostTest"	"isTrue"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/ScopedStorageInstantAppHostTest.java"	""	"/*
 *.
 */

package android.scopedstorage.cts.host;

import static com.google.common.truth.Truth.assertThat;

import android.platform.test.annotations.AppModeInstant;

import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;

import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Runs the ScopedStorageTest tests for an instant app.
 */
@RunWith(DeviceJUnit4ClassRunner.class)
public class ScopedStorageInstantAppHostTest extends BaseHostTestCase {
    /**
     * Runs the given phase of Test by calling into the device.
     * Throws an exception if the test phase fails.
     */
    protected void runDeviceTest(String phase) throws Exception {
        assertThat(runDeviceTests(""android.scopedstorage.cts"",
                ""android.scopedstorage.cts.ScopedStorageTest"", phase)).isTrue();
    }"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.host.ScopedStorageInstantAppHostTest"	"testInstantAppsCantAccessExternalStorage"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/ScopedStorageInstantAppHostTest.java"	""	"@AppModeInstant
    public void testInstantAppsCantAccessExternalStorage() throws Exception {
        runDeviceTest(""testInstantAppsCantAccessExternalStorage"");
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.deviceconfig.cts.DeviceConfigApiTests"	"isInstantApp"	"CtsDeviceConfigTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/deviceconfig/src/android/deviceconfig/cts/DeviceConfigApiTests.java"	""	"/*
 *
 */

package android.deviceconfig.cts;

import static android.provider.Settings.RESET_MODE_PACKAGE_DEFAULTS;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;
import static org.junit.Assume.assumeTrue;
import static org.junit.Assert.fail;

import android.content.Context;
import android.os.SystemClock;
import android.os.UserHandle;
import android.provider.DeviceConfig;
import android.provider.DeviceConfig.OnPropertiesChangedListener;
import android.provider.DeviceConfig.Properties;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;

@RunWith(AndroidJUnit4.class)
public final class DeviceConfigApiTests {
    private static final String NAMESPACE1 = ""namespace1"";
    private static final String NAMESPACE2 = ""namespace2"";
    private static final String EMPTY_NAMESPACE = ""empty_namespace"";
    private static final String KEY1 = ""key1"";
    private static final String KEY2 = ""key2"";
    private static final String VALUE1 = ""value1"";
    private static final String VALUE2 = ""value2"";
    private static final String DEFAULT_VALUE = ""default_value"";

    private static final boolean DEFAULT_BOOLEAN_TRUE = true;
    private static final boolean DEFAULT_BOOLEAN_FALSE = false;
    private static final boolean BOOLEAN_TRUE = true;
    private static final boolean BOOLEAN_FALSE = false;
    private static final String INVALID_BOOLEAN = ""TR_UE"";

    private static final int DEFAULT_INT = 999;
    private static final int VALID_INT = 123;
    private static final String INVALID_INT = ""12E"";

    private static final long DEFAULT_LONG = 123456;
    private static final long VALID_LONG = 278724287;
    private static final String INVALID_LONG = ""23232R42"";

    private static final float DEFAULT_FLOAT = 123.456f;
    private static final float VALID_FLOAT = 456.789f;
    private static final String INVALID_FLOAT = ""34343et"";

    private static final Context CONTEXT = InstrumentationRegistry.getContext();

    private static final Executor EXECUTOR = CONTEXT.getMainExecutor();


    private static final long WAIT_FOR_PROPERTY_CHANGE_TIMEOUT_MILLIS = 2000; // 2 sec
    private final Object mLock = new Object();


    private static final String WRITE_DEVICE_CONFIG_PERMISSION =
            ""android.permission.WRITE_DEVICE_CONFIG"";

    private static final String READ_DEVICE_CONFIG_PERMISSION =
            ""android.permission.READ_DEVICE_CONFIG"";

    // String used to skip tests if not support.
    // TODO: ideally it would be simpler to just use assumeTrue() in the @BeforeClass method, but
    // then the test would crash - it might be an issue on atest / AndroidJUnit4
    private static String sUnsupportedReason;

    /**
     * Get necessary permissions to access and modify properties through DeviceConfig API.
     */
    @BeforeClass
    public static void setUp() throws Exception {
        if (CONTEXT.getUserId() != UserHandle.USER_SYSTEM
                && CONTEXT.getPackageManager().isInstantApp()) {
            sUnsupportedReason = ""cannot run test as instant app on secondary user ""
                    + CONTEXT.getUserId();
            return;
        }

        InstrumentationRegistry.getInstrumentation().getUiAutomation().adoptShellPermissionIdentity(
                WRITE_DEVICE_CONFIG_PERMISSION, READ_DEVICE_CONFIG_PERMISSION);
    }

    @Before
    public void assumeSupported() {
        assumeTrue(sUnsupportedReason, isSupported());
    }

    /**
     * Nullify properties in DeviceConfig API after completion of every test.
     */
    @After
    public void cleanUp() throws Exception {
        if (!isSupported()) return;

        // first wait to make sure callbacks for SetProperties/SetProperty
        // invoked in the test methods got emitted. So that the callbacks
        // won't interfere with setPropertiesAndAssertSuccessfulChange invoked
        // in nullifyProperty.
        TimeUnit.MILLISECONDS.sleep(WAIT_FOR_PROPERTY_CHANGE_TIMEOUT_MILLIS);
        nullifyProperty(NAMESPACE1, KEY1);
        nullifyProperty(NAMESPACE2, KEY1);
        nullifyProperty(NAMESPACE1, KEY2);
        nullifyProperty(NAMESPACE2, KEY2);
    }

    /**
     * Delete properties in DeviceConfig API after completion of all tests and drop shell
     * permissions.
     */
    @AfterClass
    public static void cleanUpAfterAllTests() {
        if (!isSupported()) return;

        deletePropertyThrowShell(NAMESPACE1, KEY1);
        deletePropertyThrowShell(NAMESPACE2, KEY1);
        deletePropertyThrowShell(NAMESPACE1, KEY2);
        deletePropertyThrowShell(NAMESPACE2, KEY2);
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .dropShellPermissionIdentity();
    }

    /**
     * Checks that getting property which does not exist returns null.
     */"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.managedprovisioning.LockTaskUiTestActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/LockTaskUiTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.managedprovisioning;

import static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_GLOBAL_ACTIONS;
import static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_HOME;
import static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_KEYGUARD;
import static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_NONE;
import static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_NOTIFICATIONS;
import static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_OVERVIEW;
import static android.app.admin.DevicePolicyManager.LOCK_TASK_FEATURE_SYSTEM_INFO;

import static com.android.cts.verifier.managedprovisioning.Utils.createInteractiveTestItem;

import android.app.ActivityManager;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.admin.DevicePolicyManager;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.database.DataSetObserver;
import android.os.AsyncTask;
import android.os.Bundle;
import androidx.localbroadcastmanager.content.LocalBroadcastManager;
import android.util.Log;
import android.widget.Button;
import android.widget.Toast;

import com.android.cts.verifier.ArrayTestListAdapter;
import com.android.cts.verifier.IntentDrivenTestActivity.ButtonInfo;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.TestListAdapter.TestListItem;
import com.android.cts.verifier.TestResult;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * Tests for {@link DevicePolicyManager#setLockTaskFeatures(ComponentName, int)}.
 */
public class LockTaskUiTestActivity extends PassFailButtons.TestListActivity {

    private static final String TAG = LockTaskUiTestActivity.class.getSimpleName();

    public static final String EXTRA_TEST_ID =
            ""com.android.cts.verifier.managedprovisioning.extra.TEST_ID"";

    /** Broadcast action sent by {@link DeviceAdminTestReceiver} when LockTask starts. */
    static final String ACTION_LOCK_TASK_STARTED =
            ""com.android.cts.verifier.managedprovisioning.action.LOCK_TASK_STARTED"";
    /** Broadcast action sent by {@link DeviceAdminTestReceiver} when LockTask stops. */
    static final String ACTION_LOCK_TASK_STOPPED =
            ""com.android.cts.verifier.managedprovisioning.action.LOCK_TASK_STOPPED"";

    private static final ComponentName ADMIN_RECEIVER =
            DeviceAdminTestReceiver.getReceiverComponentName();
    private static final String TEST_PACKAGE_NAME = ""com.android.cts.verifier"";
    private static final String ACTION_STOP_LOCK_TASK =
            ""com.android.cts.verifier.managedprovisioning.action.STOP_LOCK_TASK"";

    private static final String TEST_ID_DEFAULT = ""lock-task-ui-default"";
    private static final String TEST_ID_SYSTEM_INFO = ""lock-task-ui-system-info"";
    private static final String TEST_ID_NOTIFICATIONS = ""lock-task-ui-notifications"";
    private static final String TEST_ID_HOME = ""lock-task-ui-home"";
    private static final String TEST_ID_RECENTS = ""lock-task-ui-recents"";
    private static final String TEST_ID_GLOBAL_ACTIONS = ""lock-task-ui-global-actions"";
    private static final String TEST_ID_KEYGUARD = ""lock-task-ui-keyguard"";
    private static final String TEST_ID_STOP_LOCK_TASK = ""lock-task-ui-stop-lock-task"";

    private DevicePolicyManager mDpm;
    private ActivityManager mAm;
    private NotificationManager mNotifyMgr;

    private LockTaskStateChangedReceiver mStateChangedReceiver;
    private CountDownLatch mLockTaskStartedLatch;
    private CountDownLatch mLockTaskStoppedLatch;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.device_owner_lock_task_ui);
        setPassFailButtonClickListeners();

        mDpm = getSystemService(DevicePolicyManager.class);
        mAm = getSystemService(ActivityManager.class);
        mNotifyMgr = getSystemService(NotificationManager.class);

        final ArrayTestListAdapter adapter = new ArrayTestListAdapter(this);
        addTestsToAdapter(adapter);
        adapter.registerDataSetObserver(new DataSetObserver() {
            @Override
            public void onChanged() {
                updatePassButton();
            }
        });
        setTestListAdapter(adapter);

        Button startLockTaskButton = findViewById(R.id.start_lock_task_button);
        startLockTaskButton.setOnClickListener((view) -> startLockTaskMode());

        if (ACTION_STOP_LOCK_TASK.equals(getIntent().getAction())) {
            // This means we're started by the ""stop LockTask mode"" test activity (the last one in
            // the list) in order to stop LockTask.
            stopLockTaskMode();
        }
    }

    private void addTestsToAdapter(final ArrayTestListAdapter adapter) {
        if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
            adapter.add(createSetLockTaskFeaturesTest(
                    TEST_ID_DEFAULT,
                    LOCK_TASK_FEATURE_NONE,
                    R.string.device_owner_lock_task_ui_default_test,
                    R.string.device_owner_lock_task_ui_default_test_info));

            adapter.add(createSetLockTaskFeaturesTest(
                    TEST_ID_SYSTEM_INFO,
                    LOCK_TASK_FEATURE_SYSTEM_INFO,
                    R.string.device_owner_lock_task_ui_system_info_test,
                    R.string.device_owner_lock_task_ui_system_info_test_info));
        }

        if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
            adapter.add(createSetLockTaskFeaturesTest(
                    TEST_ID_NOTIFICATIONS,
                    LOCK_TASK_FEATURE_HOME | LOCK_TASK_FEATURE_NOTIFICATIONS,
                    R.string.device_owner_lock_task_ui_notifications_test,
                    R.string.device_owner_lock_task_ui_notifications_test_info));
        }

        if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
            adapter.add(createSetLockTaskFeaturesTest(
                    TEST_ID_HOME,
                    LOCK_TASK_FEATURE_HOME,
                    R.string.device_owner_lock_task_ui_home_test,
                    R.string.device_owner_lock_task_ui_home_test_info));
        }

        if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
            adapter.add(createSetLockTaskFeaturesTest(
                    TEST_ID_RECENTS,
                    LOCK_TASK_FEATURE_HOME | LOCK_TASK_FEATURE_OVERVIEW,
                    R.string.device_owner_lock_task_ui_recents_test,
                    R.string.device_owner_lock_task_ui_recents_test_info));
        }

        if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
            adapter.add(createSetLockTaskFeaturesTest(
                    TEST_ID_GLOBAL_ACTIONS,
                    LOCK_TASK_FEATURE_GLOBAL_ACTIONS,
                    R.string.device_owner_lock_task_ui_global_actions_test,
                    R.string.device_owner_lock_task_ui_global_actions_test_info));
        }

        if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)
                && getPackageManager().hasSystemFeature(
                PackageManager.FEATURE_SECURE_LOCK_SCREEN)) {
            adapter.add(createSetLockTaskFeaturesTest(
                    TEST_ID_KEYGUARD,
                    LOCK_TASK_FEATURE_KEYGUARD,
                    R.string.device_owner_lock_task_ui_keyguard_test,
                    R.string.device_owner_lock_task_ui_keyguard_test_info));
        }

        final Intent stopLockTaskIntent = new Intent(this, LockTaskUiTestActivity.class);
        stopLockTaskIntent.setAction(ACTION_STOP_LOCK_TASK);
        adapter.add(createInteractiveTestItem(this,
                TEST_ID_STOP_LOCK_TASK,
                R.string.device_owner_lock_task_ui_stop_lock_task_test,
                R.string.device_owner_lock_task_ui_stop_lock_task_test_info,
                new ButtonInfo(
                        R.string.device_owner_lock_task_ui_stop_lock_task_test,
                        stopLockTaskIntent
                )));
    }

    /** Receives LockTask start/stop callbacks forwarded by {@link DeviceAdminTestReceiver}. */
    private final class LockTaskStateChangedReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            switch (action) {
                case ACTION_LOCK_TASK_STARTED:
                    if (mLockTaskStartedLatch != null) {
                        mLockTaskStartedLatch.countDown();
                    }
                    break;
                case ACTION_LOCK_TASK_STOPPED:
                    if (mLockTaskStoppedLatch != null) {
                        mLockTaskStoppedLatch.countDown();
                    }
                    break;
            }
        }
    }

    @Override
    protected void onResume() {
        super.onResume();
        mStateChangedReceiver = new LockTaskStateChangedReceiver();
        final IntentFilter filter = new IntentFilter();
        filter.addAction(ACTION_LOCK_TASK_STARTED);
        filter.addAction(ACTION_LOCK_TASK_STOPPED);
        LocalBroadcastManager.getInstance(this).registerReceiver(mStateChangedReceiver, filter);
    }

    @Override
    protected void onPause() {
        if (mStateChangedReceiver != null) {
            LocalBroadcastManager.getInstance(this).unregisterReceiver(mStateChangedReceiver);
            mStateChangedReceiver = null;
        }
        super.onPause();
    }

    /**
     * Starts LockTask mode and waits for callback from {@link DeviceAdminTestReceiver} to confirm
     * LockTask has started successfully. If the callback isn't received, the entire test will be
     * marked as failed.
     *
     * @see LockTaskStateChangedReceiver
     */
    private void startLockTaskMode() {
        if (mAm.getLockTaskModeState() == ActivityManager.LOCK_TASK_MODE_LOCKED) {
            return;
        }

        mLockTaskStartedLatch = new CountDownLatch(1);
        try {
            mDpm.setLockTaskPackages(ADMIN_RECEIVER, new String[] {TEST_PACKAGE_NAME});
            mDpm.setLockTaskFeatures(ADMIN_RECEIVER, LOCK_TASK_FEATURE_NONE);
            startLockTask();

            new CheckLockTaskStateTask() {
                @Override
                protected void onPostExecute(Boolean success) {
                    if (success) {
                        issueTestNotification();
                    } else {
                        notifyFailure(getTestId(), ""Failed to start LockTask mode"");
                    }
                }
            }.execute(mLockTaskStartedLatch);
        } catch (SecurityException e) {
            Log.e(TAG, e.getMessage(), e);
            Toast.makeText(this, ""Failed to run test. Did you set up device owner correctly?"",
                    Toast.LENGTH_SHORT).show();
        }
    }

    /**
     * Stops LockTask mode and waits for callback from {@link DeviceAdminTestReceiver} to confirm
     * LockTask has stopped successfully. If the callback isn't received, the ""Stop LockTask mode""
     * test case will be marked as failed.
     *
     * Note that we {@link #finish()} this activity here, since it's started by the ""Stop LockTask
     * mode"" test activity, and shouldn't be exposed to the tester once its job is done.
     *
     * @see LockTaskStateChangedReceiver
     */
    private void stopLockTaskMode() {
        if (mAm.getLockTaskModeState() == ActivityManager.LOCK_TASK_MODE_NONE) {
            finish();
            return;
        }

        mLockTaskStoppedLatch = new CountDownLatch(1);
        try {
            stopLockTask();

            new CheckLockTaskStateTask() {
                @Override
                protected void onPostExecute(Boolean success) {
                    if (!success) {
                        notifyFailure(TEST_ID_STOP_LOCK_TASK, ""Failed to stop LockTask mode"");
                    }
                    cancelTestNotification();
                    mDpm.setLockTaskFeatures(ADMIN_RECEIVER, LOCK_TASK_FEATURE_NONE);
                    mDpm.setLockTaskPackages(ADMIN_RECEIVER, new String[] {});
                    LockTaskUiTestActivity.this.finish();
                }
            }.execute(mLockTaskStoppedLatch);
        } catch (SecurityException e) {
            Log.e(TAG, e.getMessage(), e);
            Toast.makeText(this, ""Failed to finish test. Did you set up device owner correctly?"",
                    Toast.LENGTH_SHORT).show();
        }
    }

    private abstract class CheckLockTaskStateTask extends AsyncTask<CountDownLatch, Void, Boolean> {
        @Override
        protected Boolean doInBackground(CountDownLatch... latches) {
            if (latches.length > 0 && latches[0] != null) {
                try {
                    return latches[0].await(1, TimeUnit.SECONDS);
                } catch (InterruptedException e) {
                    // Fall through
                }
            }
            return false;
        }

        @Override
        protected abstract void onPostExecute(Boolean success);
    }

    private void notifyFailure(String testId, String message) {
        Log.e(TAG, message);
        Toast.makeText(this, message, Toast.LENGTH_SHORT).show();
        TestResult.setFailedResult(this, testId, message);
    }

    private void issueTestNotification() {
        String channelId = getTestId();
        if (mNotifyMgr.getNotificationChannel(channelId) == null) {
            NotificationChannel channel = new NotificationChannel(
                    channelId, getTestId(), NotificationManager.IMPORTANCE_HIGH);
            mNotifyMgr.createNotificationChannel(channel);
        }

        Notification note = new Notification.Builder(this, channelId)
                .setContentTitle(getString(R.string.device_owner_lock_task_ui_test))
                .setSmallIcon(android.R.drawable.sym_def_app_icon)
                .setOngoing(true)
                .extend(new Notification.TvExtender())
                .build();

        mNotifyMgr.notify(0, note);
    }

    private void cancelTestNotification() {
        mNotifyMgr.cancelAll();
    }

    private TestListItem createSetLockTaskFeaturesTest(String testId, int featureFlags,
            int titleResId, int detailResId) {
        final Intent commandIntent = new Intent(CommandReceiverActivity.ACTION_EXECUTE_COMMAND);
        commandIntent.putExtra(CommandReceiverActivity.EXTRA_COMMAND,
                CommandReceiverActivity.COMMAND_SET_LOCK_TASK_FEATURES);
        commandIntent.putExtra(CommandReceiverActivity.EXTRA_VALUE, featureFlags);

        return createInteractiveTestItem(this, testId, titleResId, detailResId,
                new ButtonInfo(titleResId, commandIntent));
    }

    @Override
    public String getTestId() {
        return getIntent().getStringExtra(EXTRA_TEST_ID);
    }
}"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.server.wm.MultiWindowTests"	"isHomeRecentsComponent"	"CtsWindowManagerDeviceTestCases"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiWindowTests.java"	""	"/*
 *.
 */

package android.server.wm;

import static android.app.ActivityManager.LOCK_TASK_MODE_NONE;
import static android.app.WindowConfiguration.ACTIVITY_TYPE_STANDARD;
import static android.app.WindowConfiguration.WINDOWING_MODE_FULLSCREEN;
import static android.app.WindowConfiguration.WINDOWING_MODE_MULTI_WINDOW;
import static android.server.wm.TestTaskOrganizer.INVALID_TASK_ID;
import static android.server.wm.WindowManagerState.STATE_RESUMED;
import static android.server.wm.WindowManagerState.STATE_STOPPED;
import static android.server.wm.app.Components.LAUNCHING_ACTIVITY;
import static android.server.wm.app.Components.NON_RESIZEABLE_ACTIVITY;
import static android.server.wm.app.Components.NO_RELAUNCH_ACTIVITY;
import static android.server.wm.app.Components.SINGLE_INSTANCE_ACTIVITY;
import static android.server.wm.app.Components.SINGLE_TASK_ACTIVITY;
import static android.server.wm.app.Components.TEST_ACTIVITY;
import static android.server.wm.app.Components.TEST_ACTIVITY_WITH_SAME_AFFINITY;
import static android.server.wm.app.Components.TRANSLUCENT_TEST_ACTIVITY;
import static android.server.wm.app.Components.TestActivity.TEST_ACTIVITY_ACTION_FINISH_SELF;
import static android.server.wm.app27.Components.SDK_27_LAUNCHING_ACTIVITY;
import static android.server.wm.app27.Components.SDK_27_SEPARATE_PROCESS_ACTIVITY;
import static android.server.wm.app27.Components.SDK_27_TEST_ACTIVITY;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import android.content.ComponentName;
import android.content.res.Resources;
import android.platform.test.annotations.Presubmit;
import android.server.wm.CommandSession.ActivityCallback;
import android.window.WindowContainerToken;
import android.window.WindowContainerTransaction;

import org.junit.Before;
import org.junit.Test;

/**
 * Build/Install/Run:
 *     atest CtsWindowManagerDeviceTestCases:MultiWindowTests
 */
@Presubmit
@android.server.wm.annotation.Group2
public class MultiWindowTests extends ActivityManagerTestBase {

    private boolean mIsHomeRecentsComponent;

    @Before
    @Override
    public void setUp() throws Exception {
        super.setUp();

        mIsHomeRecentsComponent = mWmState.isHomeRecentsComponent();

        assumeTrue(""Skipping test: no split multi-window support"",
                supportsSplitScreenMultiWindow());
    }"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.hardware.cts.SensorTest"	"NullTriggerEventListener"	"CtsSensorTestCases"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void test/*
 *.
 */

package android.hardware.cts;

import android.content.Context;
import android.content.pm.PackageManager;
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorEventListener2;
import android.hardware.SensorManager;
import android.hardware.TriggerEvent;
import android.hardware.TriggerEventListener;
import android.hardware.cts.helpers.SensorCtsHelper;
import android.hardware.cts.helpers.SensorNotSupportedException;
import android.hardware.cts.helpers.SensorTestStateNotSupportedException;
import android.hardware.cts.helpers.TestSensorEnvironment;
import android.hardware.cts.helpers.TestSensorEventListener;
import android.hardware.cts.helpers.TestSensorManager;
import android.hardware.cts.helpers.sensoroperations.ParallelSensorOperation;
import android.hardware.cts.helpers.sensoroperations.TestSensorOperation;
import android.hardware.cts.helpers.sensorverification.ContinuousEventSanitizedVerification;
import android.hardware.cts.helpers.sensorverification.EventGapVerification;
import android.hardware.cts.helpers.sensorverification.EventOrderingVerification;
import android.hardware.cts.helpers.sensorverification.EventTimestampSynchronizationVerification;
import android.os.Build.VERSION_CODES;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.PowerManager;
import android.os.SystemClock;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.Presubmit;
import android.util.Log;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.Multimap;
import com.android.compatibility.common.util.PropertyUtil;

import junit.framework.Assert;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

public class SensorTest extends SensorTestCase {
    private static final String TAG = ""SensorTest"";

    // Test only SDK defined sensors. Any sensors with type > 100 are ignored.
    private static final int MAX_OFFICIAL_ANDROID_SENSOR_TYPE = 100;

    private PowerManager.WakeLock mWakeLock;
    private SensorManager mSensorManager;
    private TestSensorManager mTestSensorManager;
    private NullTriggerEventListener mNullTriggerEventListener;
    private NullSensorEventListener mNullSensorEventListener;
    private Sensor mTriggerSensor;
    private List<Sensor> mSensorList;
    private List<Sensor> mAndroidSensorList;

    @Override
    protected void setUp() throws Exception {
        Context context = getContext();
        PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
        mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG);

        mSensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);
        mNullTriggerEventListener = new NullTriggerEventListener();
        mNullSensorEventListener = new NullSensorEventListener();

        mSensorList = mSensorManager.getSensorList(Sensor.TYPE_ALL);
        assertNotNull(""SensorList was null."", mSensorList);
        if (mSensorList.isEmpty()) {
            // several devices will not have sensors, so we need to skip the tests in those cases
            throw new SensorTestStateNotSupportedException(
                    ""Sensors are not available in the system."");
        }

        mAndroidSensorList = new ArrayList<>();
        for (Sensor s : mSensorList) {
            if (s.getType() < Sensor.TYPE_DEVICE_PRIVATE_BASE &&
                    (!context.getPackageManager().isInstantApp() || s.getType() != Sensor.TYPE_HEART_RATE)) {
                mAndroidSensorList.add(s);
            }
        }

        mWakeLock.acquire();
    }

    @Override
    protected void tearDown() {
        if (mSensorManager != null) {
            // SensorManager will check listener and status, so just unregister listener
            mSensorManager.unregisterListener(mNullSensorEventListener);
            if (mTriggerSensor != null) {
                mSensorManager.cancelTriggerSensor(mNullTriggerEventListener, mTriggerSensor);
                mTriggerSensor = null;
            }
        }

        if (mTestSensorManager != null) {
            mTestSensorManager.unregisterListener();
            mTestSensorManager = null;
        }

        if (mWakeLock != null && mWakeLock.isHeld()) {
            mWakeLock.release();
        }
    }

    @SuppressWarnings(""deprecation"")"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.server.wm.ActivityManagerTestBase"	"PostAssertionRule"	""	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/util/src/android/server/wm/ActivityManagerTestBase.java"	""	"public void test/*
 *
 */

package android.server.wm;

import static android.app.AppOpsManager.MODE_ALLOWED;
import static android.app.AppOpsManager.OPSTR_SYSTEM_ALERT_WINDOW;
import static android.app.Instrumentation.ActivityMonitor;
import static android.app.WindowConfiguration.ACTIVITY_TYPE_ASSISTANT;
import static android.app.WindowConfiguration.ACTIVITY_TYPE_RECENTS;
import static android.app.WindowConfiguration.ACTIVITY_TYPE_STANDARD;
import static android.app.WindowConfiguration.ACTIVITY_TYPE_UNDEFINED;
import static android.app.WindowConfiguration.WINDOWING_MODE_UNDEFINED;
import static android.content.Intent.ACTION_MAIN;
import static android.content.Intent.CATEGORY_HOME;
import static android.content.Intent.FLAG_ACTIVITY_MULTIPLE_TASK;
import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DISABLED;
import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_ENABLED;
import static android.content.pm.PackageManager.DONT_KILL_APP;
import static android.content.pm.PackageManager.FEATURE_ACTIVITIES_ON_SECONDARY_DISPLAYS;
import static android.content.pm.PackageManager.FEATURE_AUTOMOTIVE;
import static android.content.pm.PackageManager.FEATURE_EMBEDDED;
import static android.content.pm.PackageManager.FEATURE_FREEFORM_WINDOW_MANAGEMENT;
import static android.content.pm.PackageManager.FEATURE_INPUT_METHODS;
import static android.content.pm.PackageManager.FEATURE_LEANBACK;
import static android.content.pm.PackageManager.FEATURE_PICTURE_IN_PICTURE;
import static android.content.pm.PackageManager.FEATURE_SCREEN_LANDSCAPE;
import static android.content.pm.PackageManager.FEATURE_SCREEN_PORTRAIT;
import static android.content.pm.PackageManager.FEATURE_SECURE_LOCK_SCREEN;
import static android.content.pm.PackageManager.FEATURE_TELEVISION;
import static android.content.pm.PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE;
import static android.content.pm.PackageManager.FEATURE_WATCH;
import static android.content.pm.PackageManager.MATCH_DEFAULT_ONLY;
import static android.server.wm.ActivityLauncher.KEY_ACTIVITY_TYPE;
import static android.server.wm.ActivityLauncher.KEY_DISPLAY_ID;
import static android.server.wm.ActivityLauncher.KEY_INTENT_EXTRAS;
import static android.server.wm.ActivityLauncher.KEY_INTENT_FLAGS;
import static android.server.wm.ActivityLauncher.KEY_LAUNCH_ACTIVITY;
import static android.server.wm.ActivityLauncher.KEY_LAUNCH_TASK_BEHIND;
import static android.server.wm.ActivityLauncher.KEY_LAUNCH_TO_SIDE;
import static android.server.wm.ActivityLauncher.KEY_MULTIPLE_INSTANCES;
import static android.server.wm.ActivityLauncher.KEY_MULTIPLE_TASK;
import static android.server.wm.ActivityLauncher.KEY_NEW_TASK;
import static android.server.wm.ActivityLauncher.KEY_RANDOM_DATA;
import static android.server.wm.ActivityLauncher.KEY_REORDER_TO_FRONT;
import static android.server.wm.ActivityLauncher.KEY_SUPPRESS_EXCEPTIONS;
import static android.server.wm.ActivityLauncher.KEY_TARGET_COMPONENT;
import static android.server.wm.ActivityLauncher.KEY_USE_APPLICATION_CONTEXT;
import static android.server.wm.ActivityLauncher.KEY_WINDOWING_MODE;
import static android.server.wm.ActivityLauncher.launchActivityFromExtras;
import static android.server.wm.CommandSession.KEY_FORWARD;
import static android.server.wm.ComponentNameUtils.getActivityName;
import static android.server.wm.ComponentNameUtils.getLogTag;
import static android.server.wm.StateLogger.log;
import static android.server.wm.StateLogger.logE;
import static android.server.wm.UiDeviceUtils.pressBackButton;
import static android.server.wm.UiDeviceUtils.pressEnterButton;
import static android.server.wm.UiDeviceUtils.pressHomeButton;
import static android.server.wm.UiDeviceUtils.pressSleepButton;
import static android.server.wm.UiDeviceUtils.pressUnlockButton;
import static android.server.wm.UiDeviceUtils.pressWakeupButton;
import static android.server.wm.UiDeviceUtils.waitForDeviceIdle;
import static android.server.wm.WindowManagerState.STATE_RESUMED;
import static android.server.wm.app.Components.BROADCAST_RECEIVER_ACTIVITY;
import static android.server.wm.app.Components.BroadcastReceiverActivity.ACTION_TRIGGER_BROADCAST;
import static android.server.wm.app.Components.BroadcastReceiverActivity.EXTRA_BROADCAST_ORIENTATION;
import static android.server.wm.app.Components.BroadcastReceiverActivity.EXTRA_CUTOUT_EXISTS;
import static android.server.wm.app.Components.BroadcastReceiverActivity.EXTRA_DISMISS_KEYGUARD;
import static android.server.wm.app.Components.BroadcastReceiverActivity.EXTRA_DISMISS_KEYGUARD_METHOD;
import static android.server.wm.app.Components.BroadcastReceiverActivity.EXTRA_FINISH_BROADCAST;
import static android.server.wm.app.Components.BroadcastReceiverActivity.EXTRA_MOVE_BROADCAST_TO_BACK;
import static android.server.wm.app.Components.LAUNCHING_ACTIVITY;
import static android.server.wm.app.Components.LaunchingActivity.KEY_FINISH_BEFORE_LAUNCH;
import static android.server.wm.app.Components.PipActivity.ACTION_EXPAND_PIP;
import static android.server.wm.app.Components.PipActivity.ACTION_SET_REQUESTED_ORIENTATION;
import static android.server.wm.app.Components.PipActivity.ACTION_UPDATE_PIP_STATE;
import static android.server.wm.app.Components.PipActivity.EXTRA_PIP_ORIENTATION;
import static android.server.wm.app.Components.PipActivity.EXTRA_SET_ASPECT_RATIO_WITH_DELAY_DENOMINATOR;
import static android.server.wm.app.Components.PipActivity.EXTRA_SET_ASPECT_RATIO_WITH_DELAY_NUMERATOR;
import static android.server.wm.app.Components.PipActivity.EXTRA_SET_PIP_CALLBACK;
import static android.server.wm.app.Components.PipActivity.EXTRA_SET_PIP_STASHED;
import static android.server.wm.app.Components.TEST_ACTIVITY;
import static android.server.wm.second.Components.SECOND_ACTIVITY;
import static android.server.wm.third.Components.THIRD_ACTIVITY;
import static android.view.Display.DEFAULT_DISPLAY;
import static android.view.Display.INVALID_DISPLAY;
import static android.view.Surface.ROTATION_0;
import static android.view.WindowManager.LayoutParams.TYPE_BASE_APPLICATION;

import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import static java.lang.Integer.toHexString;

import android.accessibilityservice.AccessibilityService;
import android.app.Activity;
import android.app.ActivityManager;
import android.app.ActivityOptions;
import android.app.ActivityTaskManager;
import android.app.Instrumentation;
import android.app.KeyguardManager;
import android.app.WindowConfiguration;
import android.content.ComponentName;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.content.res.Resources;
import android.database.ContentObserver;
import android.graphics.Bitmap;
import android.graphics.Rect;
import android.hardware.display.AmbientDisplayConfiguration;
import android.hardware.display.DisplayManager;
import android.os.Bundle;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.PowerManager;
import android.os.RemoteCallback;
import android.os.SystemClock;
import android.os.SystemProperties;
import android.provider.Settings;
import android.server.wm.CommandSession.ActivityCallback;
import android.server.wm.CommandSession.ActivitySession;
import android.server.wm.CommandSession.ActivitySessionClient;
import android.server.wm.CommandSession.ConfigInfo;
import android.server.wm.CommandSession.LaunchInjector;
import android.server.wm.CommandSession.LaunchProxy;
import android.server.wm.CommandSession.SizeInfo;
import android.server.wm.TestJournalProvider.TestJournalContainer;
import android.server.wm.WindowManagerState.WindowState;
import android.server.wm.settings.SettingsSession;
import android.util.DisplayMetrics;
import android.util.EventLog;
import android.util.EventLog.Event;
import android.view.Display;
import android.view.View;
import android.view.WindowManager;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.test.ext.junit.rules.ActivityScenarioRule;

import com.android.compatibility.common.util.AppOpsUtils;
import com.android.compatibility.common.util.SystemUtil;

import org.junit.Before;
import org.junit.Rule;
import org.junit.rules.ErrorCollector;
import org.junit.rules.RuleChain;
import org.junit.rules.TestRule;
import org.junit.runner.Description;
import org.junit.runners.model.Statement;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.BooleanSupplier;
import java.util.function.Consumer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public abstract class ActivityManagerTestBase {
    private static final boolean PRETEND_DEVICE_SUPPORTS_PIP = false;
    private static final boolean PRETEND_DEVICE_SUPPORTS_FREEFORM = false;
    private static final String LOG_SEPARATOR = ""LOG_SEPARATOR"";
    // Use one of the test tags as a separator
    private static final int EVENT_LOG_SEPARATOR_TAG = 42;

    protected static final int[] ALL_ACTIVITY_TYPE_BUT_HOME = {
            ACTIVITY_TYPE_STANDARD, ACTIVITY_TYPE_ASSISTANT, ACTIVITY_TYPE_RECENTS,
            ACTIVITY_TYPE_UNDEFINED
    };

    private static final String TEST_PACKAGE = TEST_ACTIVITY.getPackageName();
    private static final String SECOND_TEST_PACKAGE = SECOND_ACTIVITY.getPackageName();
    private static final String THIRD_TEST_PACKAGE = THIRD_ACTIVITY.getPackageName();
    private static final List<String> TEST_PACKAGES;

    static {
        final List<String> testPackages = new ArrayList<>();
        testPackages.add(TEST_PACKAGE);
        testPackages.add(SECOND_TEST_PACKAGE);
        testPackages.add(THIRD_TEST_PACKAGE);
        testPackages.add(""android.server.wm.cts"");
        testPackages.add(""android.server.wm.jetpack"");
        TEST_PACKAGES = Collections.unmodifiableList(testPackages);
    }

    protected static final String AM_START_HOME_ACTIVITY_COMMAND =
            ""am start -a android.intent.action.MAIN -c android.intent.category.HOME"";

    protected static final String MSG_NO_MOCK_IME =
            ""MockIme cannot be used for devices that do not support installable IMEs"";

    private static final String AM_BROADCAST_CLOSE_SYSTEM_DIALOGS =
            ""am broadcast -a android.intent.action.CLOSE_SYSTEM_DIALOGS"";

    protected static final String LOCK_CREDENTIAL = ""1234"";

    private static final int UI_MODE_TYPE_MASK = 0x0f;
    private static final int UI_MODE_TYPE_VR_HEADSET = 0x07;

    private static Boolean sHasHomeScreen = null;
    private static Boolean sSupportsSystemDecorsOnSecondaryDisplays = null;
    private static Boolean sSupportsInsecureLockScreen = null;
    private static Boolean sIsAssistantOnTop = null;
    private static boolean sIllegalTaskStateFound;

    protected static final int INVALID_DEVICE_ROTATION = -1;

    protected final Instrumentation mInstrumentation = getInstrumentation();
    protected final Context mContext = getInstrumentation().getContext();
    protected final ActivityManager mAm = mContext.getSystemService(ActivityManager.class);
    protected final ActivityTaskManager mAtm = mContext.getSystemService(ActivityTaskManager.class);
    protected final DisplayManager mDm = mContext.getSystemService(DisplayManager.class);
    protected final WindowManager mWm = mContext.getSystemService(WindowManager.class);
    protected final KeyguardManager mKm = mContext.getSystemService(KeyguardManager.class);

    /** The tracker to manage objects (especially {@link AutoCloseable}) in a test method. */
    protected final ObjectTracker mObjectTracker = new ObjectTracker();

    /** The last rule to handle all errors. */
    private final ErrorCollector mPostAssertionRule = new PostAssertionRule();

    /** The necessary procedures of set up and tear down. */
    @Rule
    public final TestRule mBaseRule = RuleChain.outerRule(mPostAssertionRule)
            .around(new WrapperRule(null /* before */, this::tearDownBase));

    /**
     * @return the am command to start the given activity with the following extra key/value pairs.
     * {@param extras} a list of {@link CliIntentExtra} representing a generic intent extra
     */
    // TODO: Make this more generic, for instance accepting flags or extras of other types.
    protected static String getAmStartCmd(final ComponentName activityName,
            final CliIntentExtra... extras) {
        return getAmStartCmdInternal(getActivityName(activityName), extras);
    }

    private static String getAmStartCmdInternal(final String activityName,
            final CliIntentExtra... extras) {
        return appendKeyValuePairs(
                new StringBuilder(""am start -n "").append(activityName),
                extras);
    }

    private static String appendKeyValuePairs(
            final StringBuilder cmd, final CliIntentExtra... extras) {
        for (int i = 0; i < extras.length; i++) {
            extras[i].appendTo(cmd);
        }
        return cmd.toString();
    }

    protected static String getAmStartCmd(final ComponentName activityName, final int displayId,
            final CliIntentExtra... extras) {
        return getAmStartCmdInternal(getActivityName(activityName), displayId, extras);
    }

    private static String getAmStartCmdInternal(final String activityName, final int displayId,
            final CliIntentExtra... extras) {
        return appendKeyValuePairs(
                new StringBuilder(""am start -n "")
                        .append(activityName)
                        .append("" -f 0x"")
                        .append(toHexString(FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_MULTIPLE_TASK))
                        .append("" --display "")
                        .append(displayId),
                extras);
    }

    protected static String getAmStartCmdInNewTask(final ComponentName activityName) {
        return ""am start -n "" + getActivityName(activityName) + "" -f 0x18000000"";
    }

    protected static String getAmStartCmdWithData(final ComponentName activityName, String data) {
        return ""am start -n "" + getActivityName(activityName) + "" -d "" + data;
    }

    protected static String getAmStartCmdOverHome(final ComponentName activityName) {
        return ""am start --activity-task-on-home -n "" + getActivityName(activityName);
    }

    protected WindowManagerStateHelper mWmState = new WindowManagerStateHelper();
    protected TouchHelper mTouchHelper = new TouchHelper(mInstrumentation, mWmState);
    // Initialized in setUp to execute with proper permission, such as MANAGE_ACTIVITY_TASKS
    public TestTaskOrganizer mTaskOrganizer;

    public WindowManagerStateHelper getWmState() {
        return mWmState;
    }

    protected BroadcastActionTrigger mBroadcastActionTrigger = new BroadcastActionTrigger();

    /** Runs a runnable with shell permissions. These can be nested. */
    protected void runWithShellPermission(Runnable runnable) {
        NestedShellPermission.run(runnable);
    }
    /**
     * Returns true if the activity is shown before timeout.
     */
    protected boolean waitForActivityFocused(int timeoutMs, ComponentName componentName) {
        long endTime = System.currentTimeMillis() + timeoutMs;
        while (endTime > System.currentTimeMillis()) {
            mWmState.computeState();
            if (mWmState.hasActivityState(componentName, STATE_RESUMED)) {
                SystemClock.sleep(200);
                mWmState.computeState();
                break;
            }
            SystemClock.sleep(200);
            mWmState.computeState();
        }
        return getActivityName(componentName).equals(mWmState.getFocusedActivity());
    }

    /**
     * Helper class to process test actions by broadcast.
     */
    protected class BroadcastActionTrigger {

        private Intent createIntentWithAction(String broadcastAction) {
            return new Intent(broadcastAction)
                    .setFlags(Intent.FLAG_RECEIVER_FOREGROUND);
        }

        void doAction(String broadcastAction) {
            mContext.sendBroadcast(createIntentWithAction(broadcastAction));
        }

        void finishBroadcastReceiverActivity() {
            mContext.sendBroadcast(createIntentWithAction(ACTION_TRIGGER_BROADCAST)
                    .putExtra(EXTRA_FINISH_BROADCAST, true));
        }

        void launchActivityNewTask(String launchComponent) {
            mContext.sendBroadcast(createIntentWithAction(ACTION_TRIGGER_BROADCAST)
                    .putExtra(KEY_LAUNCH_ACTIVITY, true)
                    .putExtra(KEY_NEW_TASK, true)
                    .putExtra(KEY_TARGET_COMPONENT, launchComponent));
        }

        void moveTopTaskToBack() {
            mContext.sendBroadcast(createIntentWithAction(ACTION_TRIGGER_BROADCAST)
                    .putExtra(EXTRA_MOVE_BROADCAST_TO_BACK, true));
        }

        void requestOrientation(int orientation) {
            mContext.sendBroadcast(createIntentWithAction(ACTION_TRIGGER_BROADCAST)
                    .putExtra(EXTRA_BROADCAST_ORIENTATION, orientation));
        }

        void dismissKeyguardByFlag() {
            mContext.sendBroadcast(createIntentWithAction(ACTION_TRIGGER_BROADCAST)
                    .putExtra(EXTRA_DISMISS_KEYGUARD, true));
        }

        void dismissKeyguardByMethod() {
            mContext.sendBroadcast(createIntentWithAction(ACTION_TRIGGER_BROADCAST)
                    .putExtra(EXTRA_DISMISS_KEYGUARD_METHOD, true));
        }

        void expandPip() {
            mContext.sendBroadcast(createIntentWithAction(ACTION_EXPAND_PIP));
        }

        void expandPipWithAspectRatio(String extraNum, String extraDenom) {
            mContext.sendBroadcast(createIntentWithAction(ACTION_EXPAND_PIP)
                    .putExtra(EXTRA_SET_ASPECT_RATIO_WITH_DELAY_NUMERATOR, extraNum)
                    .putExtra(EXTRA_SET_ASPECT_RATIO_WITH_DELAY_DENOMINATOR, extraDenom));
        }

        void sendPipStateUpdate(RemoteCallback callback, boolean stashed) {
            mContext.sendBroadcast(createIntentWithAction(ACTION_UPDATE_PIP_STATE)
                    .putExtra(EXTRA_SET_PIP_CALLBACK, callback)
                    .putExtra(EXTRA_SET_PIP_STASHED, stashed));
        }

        void requestOrientationForPip(int orientation) {
            mContext.sendBroadcast(createIntentWithAction(ACTION_SET_REQUESTED_ORIENTATION)
                    .putExtra(EXTRA_PIP_ORIENTATION, String.valueOf(orientation)));
        }
    }

    /**
     * Helper class to launch / close test activity by instrumentation way.
     */
    protected class TestActivitySession<T extends Activity> implements AutoCloseable {
        private T mTestActivity;
        boolean mFinishAfterClose;
        private static final int ACTIVITY_LAUNCH_TIMEOUT = 10000;
        private static final int WAIT_SLICE = 50;

        /**
         * Launches an {@link Activity} on a target display synchronously.
         * @param activityClass The {@link Activity} class to be launched
         * @param displayId ID of the target display
         */
        void launchTestActivityOnDisplaySync(Class<T> activityClass, int displayId) {
            launchTestActivityOnDisplaySync(activityClass, displayId, WINDOWING_MODE_UNDEFINED);
        }

        /**
         * Launches an {@link Activity} on a target display synchronously.
         *
         * @param activityClass The {@link Activity} class to be launched
         * @param displayId ID of the target display
         * @param windowingMode Windowing mode at launch
         */
        void launchTestActivityOnDisplaySync(
                Class<T> activityClass, int displayId, int windowingMode) {
            final Intent intent = new Intent(mContext, activityClass)
                    .addFlags(FLAG_ACTIVITY_NEW_TASK);
            final String className = intent.getComponent().getClassName();
            launchTestActivityOnDisplaySync(className, intent, displayId, windowingMode);
        }

        /**
         * Launches an {@link Activity} synchronously on a target display. The class name needs to
         * be provided either implicitly through the {@link Intent} or explicitly as a parameter
         *
         * @param className Optional class name of expected activity
         * @param intent Intent to launch an activity
         * @param displayId ID for the target display
         */
        void launchTestActivityOnDisplaySync(@Nullable String className, Intent intent,
                int displayId) {
            launchTestActivityOnDisplaySync(className, intent, displayId, WINDOWING_MODE_UNDEFINED);
        }

        /**
         * Launches an {@link Activity} synchronously on a target display. The class name needs to
         * be provided either implicitly through the {@link Intent} or explicitly as a parameter
         *
         * @param className Optional class name of expected activity
         * @param intent Intent to launch an activity
         * @param displayId ID for the target display
         * @param windowingMode Windowing mode at launch
         */
        void launchTestActivityOnDisplaySync(
                @Nullable String className, Intent intent, int displayId, int windowingMode) {
            runWithShellPermission(
                    () -> {
                        mTestActivity =
                                launchActivityOnDisplay(
                                        className, intent, displayId, windowingMode);
                        // Check activity is launched and resumed.
                        final ComponentName testActivityName = mTestActivity.getComponentName();
                        waitAndAssertTopResumedActivity(
                                testActivityName, displayId, ""Activity must be resumed"");
                    });
        }

        /**
         * Launches an {@link Activity} on a target display asynchronously.
         * @param activityClass The {@link Activity} class to be launched
         * @param displayId ID of the target display
         */
        void launchTestActivityOnDisplay(Class<T> activityClass, int displayId) {
            final Intent intent = new Intent(mContext, activityClass)
                    .addFlags(FLAG_ACTIVITY_NEW_TASK);
            final String className = intent.getComponent().getClassName();
            runWithShellPermission(
                    () -> {
                        mTestActivity =
                                launchActivityOnDisplay(
                                        className, intent, displayId, WINDOWING_MODE_UNDEFINED);
                        assertNotNull(mTestActivity);
                    });
        }

        /**
         * Launches an {@link Activity} on a target display. In order to return the correct activity
         * the class name or an explicit {@link Intent} must be provided.
         *
         * @param className Optional class name of expected activity
         * @param intent {@link Intent} to launch an activity
         * @param displayId ID for the target display
         * @param windowingMode Windowing mode at launch
         * @return The {@link Activity} that was launched
         */
        private T launchActivityOnDisplay(
                @Nullable String className, Intent intent, int displayId, int windowingMode) {
            final String localClassName = className != null ? className :
              (intent.getComponent() != null ? intent.getComponent().getClassName() : null);
            if (localClassName == null || localClassName.isEmpty()) {
                fail(""Must provide either a class name or an intent with a component"");
            }
            final ActivityOptions launchOptions = ActivityOptions.makeBasic();
            launchOptions.setLaunchDisplayId(displayId);
            launchOptions.setLaunchWindowingMode(windowingMode);
            final Bundle bundle = launchOptions.toBundle();
            final ActivityMonitor monitor = mInstrumentation.addMonitor(localClassName, null,
                    false);
            mContext.startActivity(intent.addFlags(FLAG_ACTIVITY_NEW_TASK), bundle);
            // Wait for activity launch with timeout.
            mTestActivity = (T) mInstrumentation.waitForMonitorWithTimeout(monitor,
                    ACTIVITY_LAUNCH_TIMEOUT);
            assertNotNull(mTestActivity);
            return mTestActivity;
        }

        void finishCurrentActivityNoWait() {
            if (mTestActivity != null) {
                mTestActivity.finishAndRemoveTask();
                mTestActivity = null;
            }
        }

        void runOnMainSyncAndWait(Runnable runnable) {
            mInstrumentation.runOnMainSync(runnable);
            mInstrumentation.waitForIdleSync();
        }

        void runOnMainAndAssertWithTimeout(@NonNull BooleanSupplier condition, long timeoutMs,
                String message) {
            final AtomicBoolean result = new AtomicBoolean();
            final long expiredTime = System.currentTimeMillis() + timeoutMs;
            while (!result.get()) {
                if (System.currentTimeMillis() >= expiredTime) {
                    fail(message);
                }
                runOnMainSyncAndWait(() -> {
                    if (condition.getAsBoolean()) {
                        result.set(true);
                    }
                });
                SystemClock.sleep(WAIT_SLICE);
            }
        }

        T getActivity() {
            return mTestActivity;
        }

        @Override
        public void close() {
            if (mTestActivity != null && mFinishAfterClose) {
                mTestActivity.finishAndRemoveTask();
            }
        }
    }

    @Before
    public void setUp() throws Exception {
        if (isKeyguardLocked() || !Objects.requireNonNull(
                mContext.getSystemService(PowerManager.class)).isInteractive()) {
            pressWakeupButton();
            pressUnlockButton();
        }
        launchHomeActivityNoWait();
        removeRootTasksWithActivityTypes(ALL_ACTIVITY_TYPE_BUT_HOME);

        runWithShellPermission(() -> {
            // TaskOrganizer ctor requires MANAGE_ACTIVITY_TASKS permission
            mTaskOrganizer = new TestTaskOrganizer(mContext);
            // Clear launch params for all test packages to make sure each test is run in a clean
            // state.
            mAtm.clearLaunchParamsForPackages(TEST_PACKAGES);
        });
    }

    /** It always executes after {@link org.junit.After}. */
    private void tearDownBase() {
        mObjectTracker.tearDown(mPostAssertionRule::addError);

        if (mTaskOrganizer != null) {
            mTaskOrganizer.unregisterOrganizerIfNeeded();
        }
        // Synchronous execution of removeRootTasksWithActivityTypes() ensures that all
        // activities but home are cleaned up from the root task at the end of each test. Am force
        // stop shell commands might be asynchronous and could interrupt the task cleanup
        // process if executed first.
        removeRootTasksWithActivityTypes(ALL_ACTIVITY_TYPE_BUT_HOME);
        stopTestPackage(TEST_PACKAGE);
        stopTestPackage(SECOND_TEST_PACKAGE);
        stopTestPackage(THIRD_TEST_PACKAGE);
        launchHomeActivityNoWait();
    }

    /**
     * After home key is pressed ({@link #pressHomeButton} is called), the later launch may be
     * deferred if the calling uid doesn't have android.permission.STOP_APP_SWITCHES. This method
     * will resume the temporary stopped state, so the launch won't be affected.
     */
    protected void resumeAppSwitches() {
        SystemUtil.runWithShellPermissionIdentity(ActivityManager::resumeAppSwitches);
    }

    protected void startActivityOnDisplay(int displayId, ComponentName component) {
        final ActivityOptions options = ActivityOptions.makeBasic();
        options.setLaunchDisplayId(displayId);

        mContext.startActivity(new Intent().addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                .setComponent(component), options.toBundle());
    }

    protected boolean noHomeScreen() {
        try {
            return mContext.getResources().getBoolean(
                    Resources.getSystem().getIdentifier(""config_noHomeScreen"", ""bool"",
                            ""android""));
        } catch (Resources.NotFoundException e) {
            // Assume there's a home screen.
            return false;
        }
    }

    private boolean getSupportsSystemDecorsOnSecondaryDisplays() {
        try {
            return mContext.getResources().getBoolean(
                    Resources.getSystem().getIdentifier(
                            ""config_supportsSystemDecorsOnSecondaryDisplays"", ""bool"", ""android""));
        } catch (Resources.NotFoundException e) {
            // Assume this device support system decorations.
            return true;
        }
    }

    protected ComponentName getDefaultSecondaryHomeComponent() {
        assumeTrue(supportsMultiDisplay());
        int resId = Resources.getSystem().getIdentifier(
                ""config_secondaryHomePackage"", ""string"", ""android"");
        final Intent intent = new Intent(Intent.ACTION_MAIN);
        intent.addCategory(Intent.CATEGORY_SECONDARY_HOME);
        intent.setPackage(mContext.getResources().getString(resId));
        final ResolveInfo resolveInfo =
                mContext.getPackageManager().resolveActivity(intent, MATCH_DEFAULT_ONLY);
        assertNotNull(""Should have default secondary home activity"", resolveInfo);

        return new ComponentName(resolveInfo.activityInfo.packageName,
                resolveInfo.activityInfo.name);
    }

    /**
     * Insert an input event (ACTION_DOWN -> ACTION_CANCEL) to ensures the display to be focused
     * without triggering potential clicked to impact the test environment.
     * (e.g: Keyguard credential activated unexpectedly.)
     *
     * @param displayId the display ID to gain focused by inject swipe action
     */
    protected void touchAndCancelOnDisplayCenterSync(int displayId) {
        mTouchHelper.touchAndCancelOnDisplayCenterSync(displayId);
    }

    protected void tapOnDisplaySync(int x, int y, int displayId) {
        mTouchHelper.tapOnDisplaySync(x, y, displayId);
    }

    private void tapOnDisplay(int x, int y, int displayId, boolean sync) {
        mTouchHelper.tapOnDisplay(x, y, displayId, sync);
    }

    protected void tapOnCenter(Rect bounds, int displayId) {
        mTouchHelper.tapOnCenter(bounds, displayId);
    }

    protected void tapOnViewCenter(View view) {
        mTouchHelper.tapOnViewCenter(view);
    }

    protected void tapOnCenterAsync(Rect bounds, int displayId) {
        final int tapX = bounds.left + bounds.width() / 2;
        final int tapY = bounds.top + bounds.height() / 2;
        tapOnDisplay(tapX, tapY, displayId, false /* sync*/);
    }

    protected void tapOnStackCenter(WindowManagerState.ActivityTask stack) {
        mTouchHelper.tapOnStackCenter(stack);
    }

    protected  void tapOnStackCenterAsync(WindowManagerState.ActivityTask stack) {
        tapOnCenterAsync(stack.getBounds(), stack.mDisplayId);
    }

    protected void tapOnDisplayCenter(int displayId) {
        mTouchHelper.tapOnDisplayCenter(displayId);
    }

    protected void tapOnDisplayCenterAsync(int displayId) {
        mTouchHelper.tapOnDisplayCenterAsync(displayId);
    }

    public static void injectKey(int keyCode, boolean longPress, boolean sync) {
        TouchHelper.injectKey(keyCode, longPress, sync);
    }

    protected void removeRootTasksWithActivityTypes(int... activityTypes) {
        runWithShellPermission(() -> mAtm.removeRootTasksWithActivityTypes(activityTypes));
        waitForIdle();
    }

    protected void removeRootTasksInWindowingModes(int... windowingModes) {
        runWithShellPermission(() -> mAtm.removeRootTasksInWindowingModes(windowingModes));
        waitForIdle();
    }

    protected void removeRootTask(int taskId) {
        runWithShellPermission(() -> mAtm.removeTask(taskId));
        waitForIdle();
    }

    public static String executeShellCommand(String command) {
        log(""Shell command: "" + command);
        try {
            return SystemUtil.runShellCommand(getInstrumentation(), command);
        } catch (IOException e) {
            //bubble it up
            logE(""Error running shell command: "" + command);
            throw new RuntimeException(e);
        }
    }

    protected Bitmap takeScreenshot() {
        return mInstrumentation.getUiAutomation().takeScreenshot();
    }

    protected void launchActivity(final ComponentName activityName,
            final CliIntentExtra... extras) {
        launchActivityNoWait(activityName, extras);
        mWmState.waitForValidState(activityName);
    }

    protected void launchActivityNoWait(final ComponentName activityName,
            final CliIntentExtra... extras) {
        executeShellCommand(getAmStartCmd(activityName, extras));
    }

    protected void launchActivityInNewTask(final ComponentName activityName) {
        executeShellCommand(getAmStartCmdInNewTask(activityName));
        mWmState.waitForValidState(activityName);
    }

    protected void launchActivityWithData(final ComponentName activityName, String data) {
        executeShellCommand(getAmStartCmdWithData(activityName, data));
        mWmState.waitForValidState(activityName);
    }

    protected static void waitForIdle() {
        getInstrumentation().waitForIdleSync();
    }

    static void waitForOrFail(String message, BooleanSupplier condition) {
        Condition.waitFor(new Condition<>(message, condition)
                .setRetryIntervalMs(500)
                .setRetryLimit(20)
                .setOnFailure(unusedResult -> fail(""FAILED because unsatisfied: "" + message)));
    }

    /** Returns the stack that contains the provided task. */
    protected WindowManagerState.ActivityTask getStackForTaskId(int taskId) {
        mWmState.computeState();
        final List<WindowManagerState.ActivityTask> stacks = mWmState.getRootTasks();
        for (WindowManagerState.ActivityTask stack : stacks) {
            if (stack.getTask(taskId) != null) {
                return stack;
            }
        }
        return null;
    }

    protected WindowManagerState.ActivityTask getRootTask(int taskId) {
        mWmState.computeState();
        final List<WindowManagerState.ActivityTask> rootTasks = mWmState.getRootTasks();
        for (WindowManagerState.ActivityTask rootTask : rootTasks) {
            if (rootTask.getTaskId() == taskId) {
                return rootTask;
            }
        }
        return null;
    }

    protected int getDisplayWindowingModeByActivity(ComponentName activity) {
        return mWmState.getDisplay(mWmState.getDisplayByActivity(activity)).getWindowingMode();
    }

    /**
     * Launches the home activity directly. If there is no specific reason to simulate a home key
     * (which will trigger stop-app-switches), it is the recommended method to go home.
     */
    protected static void launchHomeActivityNoWait() {
        // dismiss all system dialogs before launch home.
        executeShellCommand(AM_BROADCAST_CLOSE_SYSTEM_DIALOGS);
        executeShellCommand(AM_START_HOME_ACTIVITY_COMMAND);
    }

    /** Launches the home activity directly with waiting for it to be visible. */
    protected void launchHomeActivity() {
        launchHomeActivityNoWait();
        mWmState.waitForHomeActivityVisible();
    }

    protected void launchActivityNoWait(ComponentName activityName, int windowingMode,
            final CliIntentExtra... extras) {
        executeShellCommand(getAmStartCmd(activityName, extras)
                + "" --windowingMode "" + windowingMode);
    }

    protected void launchActivity(ComponentName activityName, int windowingMode,
            final CliIntentExtra... keyValuePairs) {
        launchActivityNoWait(activityName, windowingMode, keyValuePairs);
        mWmState.waitForValidState(new WaitForValidActivityState.Builder(activityName)
                .setWindowingMode(windowingMode)
                .build());
    }

    protected void launchActivityOnDisplay(ComponentName activityName, int windowingMode,
            int displayId, final CliIntentExtra... extras) {
        executeShellCommand(getAmStartCmd(activityName, displayId, extras)
                + "" --windowingMode "" + windowingMode);
        mWmState.waitForValidState(new WaitForValidActivityState.Builder(activityName)
                .setWindowingMode(windowingMode)
                .build());
    }

    protected void launchActivityOnDisplay(ComponentName activityName, int displayId,
            CliIntentExtra... extras) {
        launchActivityOnDisplayNoWait(activityName, displayId, extras);
        mWmState.waitForValidState(activityName);
    }

    protected void launchActivityOnDisplayNoWait(ComponentName activityName, int displayId,
            CliIntentExtra... extras) {
        executeShellCommand(getAmStartCmd(activityName, displayId, extras));
    }

    protected void launchActivityInPrimarySplit(ComponentName activityName) {
        runWithShellPermission(() -> {
            launchActivity(activityName);
            final int taskId = mWmState.getTaskByActivity(activityName).mTaskId;
            mTaskOrganizer.putTaskInSplitPrimary(taskId);
            mWmState.waitForValidState(activityName);
        });
    }

    protected void launchActivityInSecondarySplit(ComponentName activityName) {
        runWithShellPermission(() -> {
            launchActivity(activityName);
            final int taskId = mWmState.getTaskByActivity(activityName).mTaskId;
            mTaskOrganizer.putTaskInSplitSecondary(taskId);
            mWmState.waitForValidState(activityName);
        });
    }

    protected void putActivityInPrimarySplit(ComponentName activityName) {
        final int taskId = mWmState.getTaskByActivity(activityName).mTaskId;
        mTaskOrganizer.putTaskInSplitPrimary(taskId);
        mWmState.waitForValidState(activityName);
    }

    protected void putActivityInSecondarySplit(ComponentName activityName) {
        final int taskId = mWmState.getTaskByActivity(activityName).mTaskId;
        mTaskOrganizer.putTaskInSplitSecondary(taskId);
        mWmState.waitForValidState(activityName);
    }

    /**
     * Launches {@param primaryActivity} into split-screen primary windowing mode
     * and {@param secondaryActivity} to the side in split-screen secondary windowing mode.
     */
    protected void launchActivitiesInSplitScreen(LaunchActivityBuilder primaryActivity,
            LaunchActivityBuilder secondaryActivity) {
        // Launch split-screen primary.
        primaryActivity
                .setUseInstrumentation()
                .setWaitForLaunched(true)
                .execute();

        final int primaryTaskId = mWmState.getTaskByActivity(
                primaryActivity.mTargetActivity).mTaskId;
        mTaskOrganizer.putTaskInSplitPrimary(primaryTaskId);

        // Launch split-screen secondary
        secondaryActivity
                .setUseInstrumentation()
                .setWaitForLaunched(true)
                .setNewTask(true)
                .setMultipleTask(true)
                .execute();

        final int secondaryTaskId = mWmState.getTaskByActivity(
                secondaryActivity.mTargetActivity).mTaskId;
        mTaskOrganizer.putTaskInSplitSecondary(secondaryTaskId);
        mWmState.computeState(primaryActivity.getTargetActivity(),
                secondaryActivity.getTargetActivity());
        log(""launchActivitiesInSplitScreen(), primaryTaskId="" + primaryTaskId +
                "", secondaryTaskId="" + secondaryTaskId);
    }

    /**
     * Move the task of {@param primaryActivity} into split-screen primary and the task of
     * {@param secondaryActivity} to the side in split-screen secondary.
     */
    protected void moveActivitiesToSplitScreen(ComponentName primaryActivity,
            ComponentName secondaryActivity) {
        final int primaryTaskId = mWmState.getTaskByActivity(primaryActivity).mTaskId;
        mTaskOrganizer.putTaskInSplitPrimary(primaryTaskId);

        final int secondaryTaskId = mWmState.getTaskByActivity(secondaryActivity).mTaskId;
        mTaskOrganizer.putTaskInSplitSecondary(secondaryTaskId);

        mWmState.computeState(primaryActivity, secondaryActivity);
        log(""moveActivitiesToSplitScreen(), primaryTaskId="" + primaryTaskId +
                "", secondaryTaskId="" + secondaryTaskId);
    }

    protected void dismissSplitScreen(boolean primaryOnTop) {
        if (mTaskOrganizer != null) {
            mTaskOrganizer.dismissSplitScreen(primaryOnTop);
        }
    }

    /**
     * Move activity to root task or on top of the given root task when the root task is also a leaf
     * task.
     */
    protected void moveActivityToRootTaskOrOnTop(ComponentName activityName, int rootTaskId) {
        mWmState.computeState(activityName);
        WindowManagerState.ActivityTask rootTask = getRootTask(rootTaskId);
        if (rootTask.getActivities().size() != 0) {
            // If the root task is a 1-level task, start the activity on top of given task.
            getLaunchActivityBuilder()
                    .setDisplayId(rootTask.mDisplayId)
                    .setWindowingMode(rootTask.getWindowingMode())
                    .setActivityType(rootTask.getActivityType())
                    .setTargetActivity(activityName)
                    .allowMultipleInstances(false)
                    .setUseInstrumentation()
                    .execute();
        } else {
            final int taskId = mWmState.getTaskByActivity(activityName).mTaskId;
            runWithShellPermission(() -> mAtm.moveTaskToRootTask(taskId, rootTaskId, true));
        }
        mWmState.waitForValidState(new WaitForValidActivityState.Builder(activityName)
                .setStackId(rootTaskId)
                .build());
    }

    protected void resizeActivityTask(
            ComponentName activityName, int left, int top, int right, int bottom) {
        mWmState.computeState(activityName);
        final int taskId = mWmState.getTaskByActivity(activityName).mTaskId;
        runWithShellPermission(() -> mAtm.resizeTask(taskId, new Rect(left, top, right, bottom)));
    }

    protected boolean supportsVrMode() {
        return hasDeviceFeature(FEATURE_VR_MODE_HIGH_PERFORMANCE);
    }

    protected boolean supportsPip() {
        return hasDeviceFeature(FEATURE_PICTURE_IN_PICTURE)
                || PRETEND_DEVICE_SUPPORTS_PIP;
    }

    protected boolean supportsFreeform() {
        return hasDeviceFeature(FEATURE_FREEFORM_WINDOW_MANAGEMENT)
                || PRETEND_DEVICE_SUPPORTS_FREEFORM;
    }

    /** Whether or not the device supports lock screen. */
    protected boolean supportsLockScreen() {
        return supportsInsecureLock() || supportsSecureLock();
    }

    /** Whether or not the device supports pin/pattern/password lock. */
    protected boolean supportsSecureLock() {
        return hasDeviceFeature(FEATURE_SECURE_LOCK_SCREEN);
    }

    /** Whether or not the device supports ""swipe"" lock. */
    protected boolean supportsInsecureLock() {
        return !hasDeviceFeature(FEATURE_LEANBACK)
                && !hasDeviceFeature(FEATURE_WATCH)
                && !hasDeviceFeature(FEATURE_EMBEDDED)
                && !hasDeviceFeature(FEATURE_AUTOMOTIVE)
                && getSupportsInsecureLockScreen();
    }

    protected boolean supportsBlur() {
        return SystemProperties.get(""ro.surface_flinger.supports_background_blur"", ""default"")
                .equals(""1"");
    }

    protected boolean isWatch() {
        return hasDeviceFeature(FEATURE_WATCH);
    }

    protected boolean isCar() {
        return hasDeviceFeature(FEATURE_AUTOMOTIVE);
    }

    protected boolean isLeanBack() {
        return hasDeviceFeature(FEATURE_TELEVISION);
    }

    protected boolean isTablet() {
        // Larger than approx 7"" tablets
        return mContext.getResources().getConfiguration().smallestScreenWidthDp >= 600;
    }

    protected boolean isOperatorTierDevice() {
        return hasDeviceFeature(""com.google.android.tv.operator_tier"");
    }

    protected void waitAndAssertActivityState(ComponentName activityName,
            String state, String message) {
        mWmState.waitForActivityState(activityName, state);

        assertTrue(message, mWmState.hasActivityState(activityName, state));
    }

    protected boolean isKeyguardLocked() {
        return mKm != null && mKm.isKeyguardLocked();
    }

    protected void waitAndAssertActivityStateOnDisplay(ComponentName activityName, String state,
            int displayId, String message) {
        waitAndAssertActivityState(activityName, state, message);
        assertEquals(message, mWmState.getDisplayByActivity(activityName),
                displayId);
    }

    public void waitAndAssertTopResumedActivity(ComponentName activityName, int displayId,
            String message) {
        final String activityClassName = getActivityName(activityName);
        mWmState.waitForWithAmState(state -> activityClassName.equals(state.getFocusedActivity()),
                ""activity to be on top"");
        waitAndAssertResumedActivity(activityName, ""Activity must be resumed"");
        mWmState.assertFocusedActivity(message, activityName);

        final int frontRootTaskId = mWmState.getFrontRootTaskId(displayId);
        WindowManagerState.ActivityTask frontRootTaskOnDisplay =
                mWmState.getRootTask(frontRootTaskId);
        assertEquals(
                ""Resumed activity of front root task of the target display must match. "" + message,
                activityClassName,
                frontRootTaskOnDisplay.isLeafTask() ? frontRootTaskOnDisplay.mResumedActivity
                        : frontRootTaskOnDisplay.getTopTask().mResumedActivity);
        mWmState.assertFocusedStack(""Top activity's rootTask must also be on top"", frontRootTaskId);
    }

    /**
     * Waits and asserts that the activity represented by the given activity name is resumed and
     * visible, but is not necessarily the top activity.
     *
     * @param activityName the activity name
     * @param message the error message
     */
    public void waitAndAssertResumedActivity(ComponentName activityName, String message) {
        mWmState.waitForValidState(activityName);
        mWmState.waitForActivityState(activityName, STATE_RESUMED);
        mWmState.assertValidity();
        assertTrue(message, mWmState.hasActivityState(activityName, STATE_RESUMED));
        mWmState.assertVisibility(activityName, true /* visible */);
    }

    // TODO: Switch to using a feature flag, when available.
    protected static boolean isUiModeLockedToVrHeadset() {
        final String output = runCommandAndPrintOutput(""dumpsys uimode"");

        Integer curUiMode = null;
        Boolean uiModeLocked = null;
        for (String line : output.split(""\\n"")) {
            line = line.trim();
            Matcher matcher = sCurrentUiModePattern.matcher(line);
            if (matcher.find()) {
                curUiMode = Integer.parseInt(matcher.group(1), 16);
            }
            matcher = sUiModeLockedPattern.matcher(line);
            if (matcher.find()) {
                uiModeLocked = matcher.group(1).equals(""true"");
            }
        }

        boolean uiModeLockedToVrHeadset = (curUiMode != null) && (uiModeLocked != null)
                && ((curUiMode & UI_MODE_TYPE_MASK) == UI_MODE_TYPE_VR_HEADSET) && uiModeLocked;

        if (uiModeLockedToVrHeadset) {
            log(""UI mode is locked to VR headset"");
        }

        return uiModeLockedToVrHeadset;
    }

    protected boolean supportsMultiWindow() {
        Display defaultDisplay = mDm.getDisplay(DEFAULT_DISPLAY);
        return ActivityTaskManager.supportsSplitScreenMultiWindow(
                mContext.createDisplayContext(defaultDisplay));
    }

    /** Returns true if the default display supports split screen multi-window. */
    protected boolean supportsSplitScreenMultiWindow() {
        Display defaultDisplay = mDm.getDisplay(DEFAULT_DISPLAY);
        return supportsSplitScreenMultiWindow(mContext.createDisplayContext(defaultDisplay));
    }

    /**
     * Returns true if the display associated with the supplied {@code context} supports split
     * screen multi-window.
     */
    protected boolean supportsSplitScreenMultiWindow(Context context) {
        return ActivityTaskManager.supportsSplitScreenMultiWindow(context);
    }

    protected boolean hasHomeScreen() {
        if (sHasHomeScreen == null) {
            sHasHomeScreen = !noHomeScreen();
        }
        return sHasHomeScreen;
    }

    protected boolean supportsSystemDecorsOnSecondaryDisplays() {
        if (sSupportsSystemDecorsOnSecondaryDisplays == null) {
            sSupportsSystemDecorsOnSecondaryDisplays = getSupportsSystemDecorsOnSecondaryDisplays();
        }
        return sSupportsSystemDecorsOnSecondaryDisplays;
    }

    protected boolean getSupportsInsecureLockScreen() {
        if (sSupportsInsecureLockScreen == null) {
            try {
                sSupportsInsecureLockScreen = mContext.getResources().getBoolean(
                        Resources.getSystem().getIdentifier(
                                ""config_supportsInsecureLockScreen"", ""bool"", ""android""));
            } catch (Resources.NotFoundException e) {
                sSupportsInsecureLockScreen = true;
            }
        }
        return sSupportsInsecureLockScreen;
    }

    protected boolean isAssistantOnTopOfDream() {
        if (sIsAssistantOnTop == null) {
            sIsAssistantOnTop = mContext.getResources().getBoolean(
                    android.R.bool.config_assistantOnTopOfDream);
        }
        return sIsAssistantOnTop;
    }

    /**
     * Rotation support is indicated by explicitly having both landscape and portrait
     * features or not listing either at all.
     */
    protected boolean supportsRotation() {
        final boolean supportsLandscape = hasDeviceFeature(FEATURE_SCREEN_LANDSCAPE);
        final boolean supportsPortrait = hasDeviceFeature(FEATURE_SCREEN_PORTRAIT);
        return (supportsLandscape && supportsPortrait)
                || (!supportsLandscape && !supportsPortrait);
    }

    /**
     * The device should support orientation request from apps if it supports rotation and the
     * display is not close to square.
     */
    protected boolean supportsOrientationRequest() {
        return supportsRotation() && !isCloseToSquareDisplay();
    }

    /** Checks whether the display dimension is close to square. */
    protected boolean isCloseToSquareDisplay() {
        final Resources resources = mContext.getResources();
        final float closeToSquareMaxAspectRatio;
        try {
            closeToSquareMaxAspectRatio = resources.getFloat(resources.getIdentifier(
                    ""config_closeToSquareDisplayMaxAspectRatio"", ""dimen"", ""android""));
        } catch (Resources.NotFoundException e) {
            // Assume device is not close to square.
            return false;
        }
        final DisplayMetrics displayMetrics = new DisplayMetrics();
        mDm.getDisplay(DEFAULT_DISPLAY).getRealMetrics(displayMetrics);
        final int w = displayMetrics.widthPixels;
        final int h = displayMetrics.heightPixels;
        final float aspectRatio = Math.max(w, h) / (float) Math.min(w, h);
        return aspectRatio <= closeToSquareMaxAspectRatio;
    }

    protected boolean hasDeviceFeature(final String requiredFeature) {
        return mContext.getPackageManager()
                .hasSystemFeature(requiredFeature);
    }

    protected static boolean isDisplayPortrait() {
        final DisplayManager displayManager = getInstrumentation()
                .getContext().getSystemService(DisplayManager.class);
        final Display display = displayManager.getDisplay(DEFAULT_DISPLAY);
        final DisplayMetrics displayMetrics = new DisplayMetrics();
        display.getRealMetrics(displayMetrics);
        return displayMetrics.widthPixels < displayMetrics.heightPixels;
    }

    protected static boolean isDisplayOn(int displayId) {
        final DisplayManager displayManager = getInstrumentation()
                .getContext().getSystemService(DisplayManager.class);
        final Display display = displayManager.getDisplay(displayId);
        return display != null && display.getState() == Display.STATE_ON;
    }

    protected static boolean perDisplayFocusEnabled() {
        return getInstrumentation().getTargetContext().getResources()
                .getBoolean(android.R.bool.config_perDisplayFocusEnabled);
    }

    protected static void removeLockCredential() {
        runCommandAndPrintOutput(""locksettings clear --old "" + LOCK_CREDENTIAL);
    }

    protected static boolean remoteInsetsControllerControlsSystemBars() {
        return getInstrumentation().getTargetContext().getResources()
                .getBoolean(android.R.bool.config_remoteInsetsControllerControlsSystemBars);
    }

    /** @see ObjectTracker#manage(AutoCloseable) */
    protected HomeActivitySession createManagedHomeActivitySession(ComponentName homeActivity) {
        return mObjectTracker.manage(new HomeActivitySession(homeActivity));
    }

    /** @see ObjectTracker#manage(AutoCloseable) */
    protected ActivitySessionClient createManagedActivityClientSession() {
        return mObjectTracker.manage(new ActivitySessionClient(mContext));
    }

    /** @see ObjectTracker#manage(AutoCloseable) */
    protected LockScreenSession createManagedLockScreenSession() {
        return mObjectTracker.manage(new LockScreenSession());
    }

    /** @see ObjectTracker#manage(AutoCloseable) */
    protected RotationSession createManagedRotationSession() {
        return mObjectTracker.manage(new RotationSession());
    }

    /** @see ObjectTracker#manage(AutoCloseable) */
    protected AodSession createManagedAodSession() {
        return mObjectTracker.manage(new AodSession());
    }

    /** @see ObjectTracker#manage(AutoCloseable) */
    protected DevEnableNonResizableMultiWindowSession
    createManagedDevEnableNonResizableMultiWindowSession() {
        return mObjectTracker.manage(new DevEnableNonResizableMultiWindowSession());
    }

    /** @see ObjectTracker#manage(AutoCloseable) */
    protected <T extends Activity> TestActivitySession<T> createManagedTestActivitySession() {
        return new TestActivitySession<T>();
    }

    /** @see ObjectTracker#manage(AutoCloseable) */
    protected SystemAlertWindowAppOpSession createAllowSystemAlertWindowAppOpSession() {
        return mObjectTracker.manage(
                new SystemAlertWindowAppOpSession(mContext.getOpPackageName(), MODE_ALLOWED));
    }

    /** @see ObjectTracker#manage(AutoCloseable) */
    protected FontScaleSession createManagedFontScaleSession() {
        return mObjectTracker.manage(new FontScaleSession());
    }

    /**
     * Test @Rule class that disables screen doze settings before each test method running and
     * restoring to initial values after test method finished.
     */
    protected static class DisableScreenDozeRule implements TestRule {

        /** Copied from android.provider.Settings.Secure since these keys are hiden. */
        private static final String[] DOZE_SETTINGS = {
                ""doze_enabled"",
                ""doze_always_on"",
                ""doze_pulse_on_pick_up"",
                ""doze_pulse_on_long_press"",
                ""doze_pulse_on_double_tap"",
                ""doze_wake_screen_gesture"",
                ""doze_wake_display_gesture"",
                ""doze_tap_gesture""
        };

        private String get(String key) {
            return executeShellCommand(""settings get secure "" + key).trim();
        }

        private void put(String key, String value) {
            executeShellCommand(""settings put secure "" + key + "" "" + value);
        }

        @Override
        public Statement apply(final Statement base, final Description description) {
            return new Statement() {
                @Override
                public void evaluate() throws Throwable {
                    final Map<String, String> initialValues = new HashMap<>();
                    Arrays.stream(DOZE_SETTINGS).forEach(k -> initialValues.put(k, get(k)));
                    try {
                        Arrays.stream(DOZE_SETTINGS).forEach(k -> put(k, ""0""));
                        base.evaluate();
                    } finally {
                        Arrays.stream(DOZE_SETTINGS).forEach(k -> put(k, initialValues.get(k)));
                    }
                }
            };
        }
    }

    ComponentName getDefaultHomeComponent() {
        final Intent intent = new Intent(ACTION_MAIN);
        intent.addCategory(CATEGORY_HOME);
        intent.addFlags(FLAG_ACTIVITY_NEW_TASK);
        final ResolveInfo resolveInfo =
                mContext.getPackageManager().resolveActivity(intent, MATCH_DEFAULT_ONLY);
        if (resolveInfo == null) {
            throw new AssertionError(""Home activity not found"");
        }
        return new ComponentName(resolveInfo.activityInfo.packageName,
                resolveInfo.activityInfo.name);
    }

    /**
     * HomeActivitySession is used to replace the default home component, so that you can use
     * your preferred home for testing within the session. The original default home will be
     * restored automatically afterward.
     */
    protected class HomeActivitySession implements AutoCloseable {
        private PackageManager mPackageManager;
        private ComponentName mOrigHome;
        private ComponentName mSessionHome;

        HomeActivitySession(ComponentName sessionHome) {
            mSessionHome = sessionHome;
            mPackageManager = mContext.getPackageManager();
            mOrigHome = getDefaultHomeComponent();

            runWithShellPermission(
                    () -> mPackageManager.setComponentEnabledSetting(mSessionHome,
                            COMPONENT_ENABLED_STATE_ENABLED, DONT_KILL_APP));
            setDefaultHome(mSessionHome);
        }

        @Override
        public void close() {
            runWithShellPermission(
                    () -> mPackageManager.setComponentEnabledSetting(mSessionHome,
                            COMPONENT_ENABLED_STATE_DISABLED, DONT_KILL_APP));
            if (mOrigHome != null) {
                setDefaultHome(mOrigHome);
            }
        }

        private void setDefaultHome(ComponentName componentName) {
            executeShellCommand(""cmd package set-home-activity --user ""
                    + android.os.Process.myUserHandle().getIdentifier() + "" ""
                    + componentName.flattenToString());
        }
    }

    public class LockScreenSession implements AutoCloseable {
        private static final boolean DEBUG = false;

        private final boolean mIsLockDisabled;
        private boolean mLockCredentialSet;
        private boolean mRemoveActivitiesOnClose;
        private AmbientDisplayConfiguration mAmbientDisplayConfiguration;

        public static final int FLAG_REMOVE_ACTIVITIES_ON_CLOSE = 1;

        public LockScreenSession() {
            this(0 /* flags */);
        }

        public LockScreenSession(int flags) {
            mIsLockDisabled = isLockDisabled();
            // Enable lock screen (swipe) by default.
            setLockDisabled(false);
            if ((flags & FLAG_REMOVE_ACTIVITIES_ON_CLOSE) != 0) {
                mRemoveActivitiesOnClose = true;
            }
            mAmbientDisplayConfiguration = new AmbientDisplayConfiguration(mContext);
        }

        public LockScreenSession setLockCredential() {
            mLockCredentialSet = true;
            runCommandAndPrintOutput(""locksettings set-pin "" + LOCK_CREDENTIAL);
            return this;
        }

        public LockScreenSession enterAndConfirmLockCredential() {
            // Ensure focus will switch to default display. Meanwhile we cannot tap on center area,
            // which may tap on input credential area.
            touchAndCancelOnDisplayCenterSync(DEFAULT_DISPLAY);

            waitForDeviceIdle(3000);
            SystemUtil.runWithShellPermissionIdentity(() ->
                    mInstrumentation.sendStringSync(LOCK_CREDENTIAL));
            pressEnterButton();
            return this;
        }

        LockScreenSession disableLockScreen() {
            setLockDisabled(true);
            return this;
        }

        public LockScreenSession sleepDevice() {
            pressSleepButton();
            // Not all device variants lock when we go to sleep, so we need to explicitly lock the
            // device. Note that pressSleepButton() above is redundant because the action also
            // puts the device to sleep, but kept around for clarity.
            if (isWatch()) {
                mInstrumentation.getUiAutomation().performGlobalAction(
                        AccessibilityService.GLOBAL_ACTION_LOCK_SCREEN);
            }
            if (mAmbientDisplayConfiguration.alwaysOnEnabled(
                    android.os.Process.myUserHandle().getIdentifier())) {
                mWmState.waitForAodShowing();
            } else {
                Condition.waitFor(""display to turn off"", () -> !isDisplayOn(DEFAULT_DISPLAY));
            }
            if(!isLockDisabled()) {
                mWmState.waitFor(state -> state.getKeyguardControllerState().keyguardShowing,
                        ""Keyguard showing"");
            }
            return this;
        }

        LockScreenSession wakeUpDevice() {
            pressWakeupButton();
            return this;
        }

        LockScreenSession unlockDevice() {
            // Make sure the unlock button event is send to the default display.
            touchAndCancelOnDisplayCenterSync(DEFAULT_DISPLAY);

            pressUnlockButton();
            return this;
        }

        public LockScreenSession gotoKeyguard(ComponentName... showWhenLockedActivities) {
            if (DEBUG && isLockDisabled()) {
                logE(""LockScreenSession.gotoKeyguard() is called without lock enabled."");
            }
            sleepDevice();
            wakeUpDevice();
            if (showWhenLockedActivities.length == 0) {
                mWmState.waitForKeyguardShowingAndNotOccluded();
            } else {
                mWmState.waitForValidState(showWhenLockedActivities);
            }
            return this;
        }

        @Override
        public void close() {
            if (mRemoveActivitiesOnClose) {
                removeRootTasksWithActivityTypes(ALL_ACTIVITY_TYPE_BUT_HOME);
            }

            setLockDisabled(mIsLockDisabled);
            final boolean wasCredentialSet = mLockCredentialSet;
            boolean wasDeviceLocked = false;
            if (mLockCredentialSet) {
                wasDeviceLocked = mKm != null && mKm.isDeviceLocked();
                removeLockCredential();
                mLockCredentialSet = false;
            }

            // Dismiss active keyguard after credential is cleared, so keyguard doesn't ask for
            // the stale credential.
            // TODO (b/112015010) If keyguard is occluded, credential cannot be removed as expected.
            // LockScreenSession#close is always called before stopping all test activities,
            // which could cause the keyguard to stay occluded after wakeup.
            // If Keyguard is occluded, pressing the back key can hide the ShowWhenLocked activity.
            pressBackButton();

            // If the credential wasn't set, the steps for restoring can be simpler.
            if (!wasCredentialSet) {
                mWmState.computeState();
                if (WindowManagerStateHelper.isKeyguardShowingAndNotOccluded(mWmState)) {
                    // Keyguard is showing and not occluded so only need to unlock.
                    unlockDevice();
                    return;
                }

                final ComponentName home = mWmState.getHomeActivityName();
                if (home != null && mWmState.hasActivityState(home, STATE_RESUMED)) {
                    // Home is resumed so nothing to do (e.g. after finishing show-when-locked app).
                    return;
                }
            }

            // If device is unlocked, there might have ShowWhenLocked activity runs on,
            // use home key to clear all activity at foreground.
            pressHomeButton();
            if (wasDeviceLocked) {
                // The removal of credential needs an extra cycle to take effect.
                sleepDevice();
                wakeUpDevice();
            }
            if (isKeyguardLocked()) {
                unlockDevice();
            }
        }

        /**
         * Returns whether the lock screen is disabled.
         *
         * @return true if the lock screen is disabled, false otherwise.
         */
        private boolean isLockDisabled() {
            final String isLockDisabled = runCommandAndPrintOutput(
                    ""locksettings get-disabled"").trim();
            return !""null"".equals(isLockDisabled) && Boolean.parseBoolean(isLockDisabled);
        }

        /**
         * Disable the lock screen.
         *
         * @param lockDisabled true if should disable, false otherwise.
         */
        protected void setLockDisabled(boolean lockDisabled) {
            runCommandAndPrintOutput(""locksettings set-disabled "" + lockDisabled);
        }
    }

    /** Helper class to set and restore appop mode ""android:system_alert_window"". */
    protected static class SystemAlertWindowAppOpSession implements AutoCloseable {
        private final String mPackageName;
        private final int mPreviousOpMode;

        SystemAlertWindowAppOpSession(String packageName, int mode) {
            mPackageName = packageName;
            try {
                mPreviousOpMode = AppOpsUtils.getOpMode(mPackageName, OPSTR_SYSTEM_ALERT_WINDOW);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            setOpMode(mode);
        }

        @Override
        public void close() {
            setOpMode(mPreviousOpMode);
        }

        void setOpMode(int mode) {
            try {
                AppOpsUtils.setOpMode(mPackageName, OPSTR_SYSTEM_ALERT_WINDOW, mode);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }

    protected class AodSession extends SettingsSession<Integer> {
        private AmbientDisplayConfiguration mConfig;

        AodSession() {
            super(Settings.Secure.getUriFor(Settings.Secure.DOZE_ALWAYS_ON),
                    Settings.Secure::getInt,
                    Settings.Secure::putInt);
            mConfig = new AmbientDisplayConfiguration(mContext);
        }

        boolean isAodAvailable() {
            return mConfig.alwaysOnAvailable();
        }

        void setAodEnabled(boolean enabled) {
            set(enabled ? 1 : 0);
        }
    }

    protected class DevEnableNonResizableMultiWindowSession extends SettingsSession<Integer> {
        DevEnableNonResizableMultiWindowSession() {
            super(Settings.Global.getUriFor(
                    Settings.Global.DEVELOPMENT_ENABLE_NON_RESIZABLE_MULTI_WINDOW),
                    (cr, name) -> Settings.Global.getInt(cr, name, 0 /* def */),
                    Settings.Global::putInt);
        }
    }

    /** Helper class to save, set & wait, and restore rotation related preferences. */
    protected class RotationSession extends SettingsSession<Integer> {
        private final String FIXED_TO_USER_ROTATION_COMMAND =
                ""cmd window fixed-to-user-rotation "";
        private final SettingsSession<Integer> mAccelerometerRotation;
        private final HandlerThread mThread;
        private final Handler mRunnableHandler;
        private final SettingsObserver mRotationObserver;
        private int mPreviousDegree;
        private String mPreviousFixedToUserRotationMode;

        public RotationSession() {
            // Save user_rotation and accelerometer_rotation preferences.
            super(Settings.System.getUriFor(Settings.System.USER_ROTATION),
                    Settings.System::getInt, Settings.System::putInt);
            mAccelerometerRotation = new SettingsSession<>(
                    Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION),
                    Settings.System::getInt, Settings.System::putInt);

            mThread = new HandlerThread(""Observer_Thread"");
            mThread.start();
            mRunnableHandler = new Handler(mThread.getLooper());
            mRotationObserver = new SettingsObserver(mRunnableHandler);

            // Disable fixed to user rotation
            mPreviousFixedToUserRotationMode = executeShellCommand(FIXED_TO_USER_ROTATION_COMMAND);
            executeShellCommand(FIXED_TO_USER_ROTATION_COMMAND + ""disabled"");

            mPreviousDegree = get();
            // Disable accelerometer_rotation.
            mAccelerometerRotation.set(0);
        }

        @Override
        public void set(@NonNull Integer value) {
            set(value, true /* waitDeviceRotation */);
        }

        /**
         * Sets the rotation preference.
         *
         * @param value The rotation between {@link android.view.Surface#ROTATION_0} ~
         *              {@link android.view.Surface#ROTATION_270}
         * @param waitDeviceRotation If {@code true}, it will wait until the display has applied the
         *                           rotation. Otherwise it only waits for the settings value has
         *                           been changed.
         */
        public void set(@NonNull Integer value, boolean waitDeviceRotation) {
            // When the rotation is locked and the SystemUI receives the rotation becoming 0deg, it
            // will call freezeRotation to WMS, which will cause USER_ROTATION be set to zero again.
            // In order to prevent our test target from being overwritten by SystemUI during
            // rotation test, wait for the USER_ROTATION changed then continue testing.
            final boolean waitSystemUI = value == ROTATION_0 && mPreviousDegree != ROTATION_0;
            final boolean observeRotationSettings = waitSystemUI || !waitDeviceRotation;
            if (observeRotationSettings) {
                mRotationObserver.observe();
            }
            super.set(value);
            mPreviousDegree = value;

            if (waitSystemUI) {
                Condition.waitFor(new Condition<>(""rotation notified"",
                        // There will receive USER_ROTATION changed twice because when the device
                        // rotates to 0deg, RotationContextButton will also set ROTATION_0 again.
                        () -> mRotationObserver.count == 2).setRetryIntervalMs(500));
            }

            if (waitDeviceRotation) {
                // Wait for the display to apply the rotation.
                mWmState.waitForRotation(value);
            } else {
                // Wait for the settings have been changed.
                Condition.waitFor(new Condition<>(""rotation setting changed"",
                        () -> mRotationObserver.count > 0).setRetryIntervalMs(100));
            }

            if (observeRotationSettings) {
                mRotationObserver.stopObserver();
            }
        }

        @Override
        public void close() {
            // Restore fixed to user rotation to default
            executeShellCommand(FIXED_TO_USER_ROTATION_COMMAND + mPreviousFixedToUserRotationMode);
            mThread.quitSafely();
            super.close();
            // Restore accelerometer_rotation preference.
            mAccelerometerRotation.close();
        }

        private class SettingsObserver extends ContentObserver {
            int count;

            SettingsObserver(Handler handler) { super(handler); }

            void observe() {
                count = 0;
                final ContentResolver resolver = mContext.getContentResolver();
                resolver.registerContentObserver(Settings.System.getUriFor(
                        Settings.System.USER_ROTATION), false, this);
            }

            void stopObserver() {
                count = 0;
                final ContentResolver resolver = mContext.getContentResolver();
                resolver.unregisterContentObserver(this);
            }

            @Override
            public void onChange(boolean selfChange) {
                count++;
            }
        }
    }

    /** Helper class to save, set, and restore font_scale preferences. */
    protected static class FontScaleSession extends SettingsSession<Float> {
        FontScaleSession() {
            super(Settings.System.getUriFor(Settings.System.FONT_SCALE),
                    Settings.System::getFloat,
                    Settings.System::putFloat);
        }

        @Override
        public Float get() {
            Float value = super.get();
            return value == null ? 1f : value;
        }
    }

    /**
     * Returns whether the test device respects settings of locked user rotation mode.
     *
     * The method sets the locked user rotation settings to the rotation that rotates the display by
     * 180 degrees and checks if the actual display rotation changes after that.
     *
     * This is a necessary assumption check before leveraging user rotation mode to force display
     * rotation, because there is no requirement that an Android device that supports both
     * orientations needs to support user rotation mode.
     *
     * @param session   the rotation session used to set user rotation
     * @param displayId the display ID to check rotation against
     * @return {@code true} if test device respects settings of locked user rotation mode;
     * {@code false} if not.
     */
    protected boolean supportsLockedUserRotation(RotationSession session, int displayId) {
        final int origRotation = getDeviceRotation(displayId);
        // Use the same orientation as target rotation to avoid affect of app-requested orientation.
        final int targetRotation = (origRotation + 2) % 4;
        session.set(targetRotation);
        final boolean result = (getDeviceRotation(displayId) == targetRotation);
        session.set(origRotation);
        return result;
    }

    protected int getDeviceRotation(int displayId) {
        final String displays = runCommandAndPrintOutput(""dumpsys display displays"").trim();
        Pattern pattern = Pattern.compile(
                ""(mDisplayId="" + displayId + "")([\\s\\S]*?)(mOverrideDisplayInfo)(.*)""
                        + ""(rotation)(\\s+)(\\d+)"");
        Matcher matcher = pattern.matcher(displays);
        if (matcher.find()) {
            final String match = matcher.group(7);
            return Integer.parseInt(match);
        }

        return INVALID_DEVICE_ROTATION;
    }

    /**
     * Creates a {#link ActivitySessionClient} instance with instrumentation context. It is used
     * when the caller doen't need try-with-resource.
     */
    public static ActivitySessionClient createActivitySessionClient() {
        return new ActivitySessionClient(getInstrumentation().getContext());
    }

    /** Empties the test journal so the following events won't be mixed-up with previous records. */
    protected void separateTestJournal() {
        TestJournalContainer.start();
    }

    protected static String runCommandAndPrintOutput(String command) {
        final String output = executeShellCommand(command);
        log(output);
        return output;
    }

    protected static class LogSeparator {
        private final String mUniqueString;

        private LogSeparator() {
            mUniqueString = UUID.randomUUID().toString();
        }

        @Override
        public String toString() {
            return mUniqueString;
        }
    }

    /**
     * Inserts a log separator so we can always find the starting point from where to evaluate
     * following logs.
     *
     * @return Unique log separator.
     */
    protected LogSeparator separateLogs() {
        final LogSeparator logSeparator = new LogSeparator();
        executeShellCommand(""log -t "" + LOG_SEPARATOR + "" "" + logSeparator);
        EventLog.writeEvent(EVENT_LOG_SEPARATOR_TAG, logSeparator.mUniqueString);
        return logSeparator;
    }

    protected static String[] getDeviceLogsForComponents(
            LogSeparator logSeparator, String... logTags) {
        String filters = LOG_SEPARATOR + "":I "";
        for (String component : logTags) {
            filters += component + "":I "";
        }
        final String[] result = executeShellCommand(""logcat -v brief -d "" + filters + "" *:S"")
                .split(""\\n"");
        if (logSeparator == null) {
            return result;
        }

        // Make sure that we only check logs after the separator.
        int i = 0;
        boolean lookingForSeparator = true;
        while (i < result.length && lookingForSeparator) {
            if (result[i].contains(logSeparator.toString())) {
                lookingForSeparator = false;
            }
            i++;
        }
        final String[] filteredResult = new String[result.length - i];
        for (int curPos = 0; i < result.length; curPos++, i++) {
            filteredResult[curPos] = result[i];
        }
        return filteredResult;
    }

    protected static List<Event> getEventLogsForComponents(LogSeparator logSeparator, int... tags) {
        List<Event> events = new ArrayList<>();

        int[] searchTags = Arrays.copyOf(tags, tags.length + 1);
        searchTags[searchTags.length - 1] = EVENT_LOG_SEPARATOR_TAG;

        try {
            EventLog.readEvents(searchTags, events);
        } catch (IOException e) {
            fail(""Could not read from event log."" + e);
        }

        for (Iterator<Event> itr = events.iterator(); itr.hasNext(); ) {
            Event event = itr.next();
            itr.remove();
            if (event.getTag() == EVENT_LOG_SEPARATOR_TAG &&
                    logSeparator.mUniqueString.equals(event.getData())) {
                break;
            }
        }
        return events;
    }

    protected boolean supportsMultiDisplay() {
        return mContext.getPackageManager().hasSystemFeature(
                FEATURE_ACTIVITIES_ON_SECONDARY_DISPLAYS);
    }

    protected boolean supportsInstallableIme() {
        return mContext.getPackageManager().hasSystemFeature(FEATURE_INPUT_METHODS);
    }

    static class CountSpec<T> {
        static final int DONT_CARE = Integer.MIN_VALUE;
        static final int EQUALS = 1;
        static final int GREATER_THAN = 2;
        static final int LESS_THAN = 3;

        final T mEvent;
        final int mRule;
        final int mCount;
        final String mMessage;

        CountSpec(T event, int rule, int count, String message) {
            mEvent = event;
            mRule = count == DONT_CARE ? DONT_CARE : rule;
            mCount = count;
            if (message != null) {
                mMessage = message;
            } else {
                switch (rule) {
                    case EQUALS:
                        mMessage = event + "" must equal to "" + count;
                        break;
                    case GREATER_THAN:
                        mMessage = event + "" must be greater than "" + count;
                        break;
                    case LESS_THAN:
                        mMessage = event + "" must be less than "" + count;
                        break;
                    default:
                        mMessage = ""Don't care"";
                }
            }
        }

        /** @return {@code true} if the given value is satisfied the condition. */
        boolean validate(int value) {
            switch (mRule) {
                case DONT_CARE:
                    return true;
                case EQUALS:
                    return value == mCount;
                case GREATER_THAN:
                    return value > mCount;
                case LESS_THAN:
                    return value < mCount;
                default:
            }
            throw new RuntimeException(""Unknown CountSpec rule"");
        }
    }

    static <T> CountSpec<T> countSpec(T event, int rule, int count, String message) {
        return new CountSpec<>(event, rule, count, message);
    }

    static <T> CountSpec<T> countSpec(T event, int rule, int count) {
        return new CountSpec<>(event, rule, count, null /* message */);
    }

    static void assertLifecycleCounts(ComponentName activityName, String message,
            int createCount, int startCount, int resumeCount, int pauseCount, int stopCount,
            int destroyCount, int configChangeCount) {
        new ActivityLifecycleCounts(activityName).assertCountWithRetry(
                message,
                countSpec(ActivityCallback.ON_CREATE, CountSpec.EQUALS, createCount),
                countSpec(ActivityCallback.ON_START, CountSpec.EQUALS, startCount),
                countSpec(ActivityCallback.ON_RESUME, CountSpec.EQUALS, resumeCount),
                countSpec(ActivityCallback.ON_PAUSE, CountSpec.EQUALS, pauseCount),
                countSpec(ActivityCallback.ON_STOP, CountSpec.EQUALS, stopCount),
                countSpec(ActivityCallback.ON_DESTROY, CountSpec.EQUALS, destroyCount),
                countSpec(ActivityCallback.ON_CONFIGURATION_CHANGED, CountSpec.EQUALS,
                        configChangeCount));
    }

    static void assertLifecycleCounts(ComponentName activityName,
            int createCount, int startCount, int resumeCount, int pauseCount, int stopCount,
            int destroyCount, int configChangeCount) {
        assertLifecycleCounts(activityName, ""Assert lifecycle of "" + getLogTag(activityName),
                createCount, startCount, resumeCount, pauseCount, stopCount,
                destroyCount, configChangeCount);
    }

    static void assertSingleLaunch(ComponentName activityName) {
        assertLifecycleCounts(activityName,
                ""activity create, start, and resume"",
                1 /* createCount */, 1 /* startCount */, 1 /* resumeCount */,
                0 /* pauseCount */, 0 /* stopCount */, 0 /* destroyCount */,
                CountSpec.DONT_CARE /* configChangeCount */);
    }

    static void assertSingleLaunchAndStop(ComponentName activityName) {
        assertLifecycleCounts(activityName,
                ""activity create, start, resume, pause, and stop"",
                1 /* createCount */, 1 /* startCount */, 1 /* resumeCount */,
                1 /* pauseCount */, 1 /* stopCount */, 0 /* destroyCount */,
                CountSpec.DONT_CARE /* configChangeCount */);
    }

    static void assertSingleStartAndStop(ComponentName activityName) {
        assertLifecycleCounts(activityName,
                ""activity start, resume, pause, and stop"",
                0 /* createCount */, 1 /* startCount */, 1 /* resumeCount */,
                1 /* pauseCount */, 1 /* stopCount */, 0 /* destroyCount */,
                CountSpec.DONT_CARE /* configChangeCount */);
    }

    static void assertSingleStart(ComponentName activityName) {
        assertLifecycleCounts(activityName,
                ""activity start and resume"",
                0 /* createCount */, 1 /* startCount */, 1 /* resumeCount */,
                0 /* pauseCount */, 0 /* stopCount */, 0 /* destroyCount */,
                CountSpec.DONT_CARE /* configChangeCount */);
    }

    /** Assert the activity is either relaunched or received configuration changed. */
    static void assertActivityLifecycle(ComponentName activityName, boolean relaunched) {
        Condition.<String>waitForResult(
                activityName + (relaunched ? "" relaunched"" : "" config changed""),
                condition -> condition
                .setResultSupplier(() -> checkActivityIsRelaunchedOrConfigurationChanged(
                        getActivityName(activityName),
                        TestJournalContainer.get(activityName).callbacks, relaunched))
                .setResultValidator(failedReasons -> failedReasons == null)
                .setOnFailure(failedReasons -> fail(failedReasons)));
    }

    /** Assert the activity is either relaunched or received configuration changed. */
    static List<ActivityCallback> assertActivityLifecycle(ActivitySession activitySession,
            boolean relaunched) {
        final String name = activitySession.getName().flattenToShortString();
        final List<ActivityCallback> callbackHistory = activitySession.takeCallbackHistory();
        String failedReason = checkActivityIsRelaunchedOrConfigurationChanged(
                name, callbackHistory, relaunched);
        if (failedReason != null) {
            fail(failedReason);
        }
        return callbackHistory;
    }

    private static String checkActivityIsRelaunchedOrConfigurationChanged(String name,
            List<ActivityCallback> callbackHistory, boolean relaunched) {
        final ActivityLifecycleCounts lifecycles = new ActivityLifecycleCounts(callbackHistory);
        if (relaunched) {
            return lifecycles.validateCount(
                    countSpec(ActivityCallback.ON_DESTROY, CountSpec.GREATER_THAN, 0,
                            name + "" must have been destroyed.""),
                    countSpec(ActivityCallback.ON_CREATE, CountSpec.GREATER_THAN, 0,
                            name + "" must have been (re)created.""));
        }
        return lifecycles.validateCount(
                countSpec(ActivityCallback.ON_DESTROY, CountSpec.LESS_THAN, 1,
                        name + "" must *NOT* have been destroyed.""),
                countSpec(ActivityCallback.ON_CREATE, CountSpec.LESS_THAN, 1,
                        name + "" must *NOT* have been (re)created.""),
                countSpec(ActivityCallback.ON_CONFIGURATION_CHANGED, CountSpec.GREATER_THAN, 0,
                                name + "" must have received configuration changed.""));
    }

    static void assertRelaunchOrConfigChanged(ComponentName activityName, int numRelaunch,
            int numConfigChange) {
        new ActivityLifecycleCounts(activityName).assertCountWithRetry(""relaunch or config changed"",
                countSpec(ActivityCallback.ON_DESTROY, CountSpec.EQUALS, numRelaunch),
                countSpec(ActivityCallback.ON_CREATE, CountSpec.EQUALS, numRelaunch),
                countSpec(ActivityCallback.ON_CONFIGURATION_CHANGED, CountSpec.EQUALS,
                        numConfigChange));
    }

    static void assertActivityDestroyed(ComponentName activityName) {
        new ActivityLifecycleCounts(activityName).assertCountWithRetry(""activity destroyed"",
                countSpec(ActivityCallback.ON_DESTROY, CountSpec.EQUALS, 1),
                countSpec(ActivityCallback.ON_CREATE, CountSpec.EQUALS, 0),
                countSpec(ActivityCallback.ON_CONFIGURATION_CHANGED, CountSpec.EQUALS, 0));
    }

    static void assertSecurityExceptionFromActivityLauncher() {
        waitForOrFail(""SecurityException from "" + ActivityLauncher.TAG,
                ActivityLauncher::hasCaughtSecurityException);
    }

    private static final Pattern sCurrentUiModePattern = Pattern.compile(""mCurUiMode=0x(\\d+)"");
    private static final Pattern sUiModeLockedPattern =
            Pattern.compile(""mUiModeLocked=(true|false)"");

    @NonNull
    SizeInfo getLastReportedSizesForActivity(ComponentName activityName) {
        return Condition.waitForResult(""sizes of "" + activityName + "" to be reported"",
                condition -> condition.setResultSupplier(() -> {
                    final ConfigInfo info = TestJournalContainer.get(activityName).lastConfigInfo;
                    return info != null ? info.sizeInfo : null;
                }).setResultValidator(Objects::nonNull).setOnFailure(unusedResult ->
                        fail(""No config reported from "" + activityName)));
    }

    /** Check if a device has display cutout. */
    boolean hasDisplayCutout() {
        // Launch an activity to report cutout state
        separateTestJournal();
        launchActivity(BROADCAST_RECEIVER_ACTIVITY);

        // Read the logs to check if cutout is present
        final Boolean displayCutoutPresent = getCutoutStateForActivity(BROADCAST_RECEIVER_ACTIVITY);
        assertNotNull(""The activity should report cutout state"", displayCutoutPresent);

        // Finish activity
        mBroadcastActionTrigger.finishBroadcastReceiverActivity();
        mWmState.waitForWithAmState(
                (state) -> !state.containsActivity(BROADCAST_RECEIVER_ACTIVITY),
                ""activity to be removed"");

        return displayCutoutPresent;
    }

    /**
     * Wait for activity to report cutout state in logs and return it. Will return {@code null}
     * after timeout.
     */
    @Nullable
    private Boolean getCutoutStateForActivity(ComponentName activityName) {
        return Condition.waitForResult(""cutout state to be reported"", condition -> condition
                .setResultSupplier(() -> {
                    final Bundle extras = TestJournalContainer.get(activityName).extras;
                    return extras.containsKey(EXTRA_CUTOUT_EXISTS)
                            ? extras.getBoolean(EXTRA_CUTOUT_EXISTS)
                            : null;
                }).setResultValidator(cutoutExists -> cutoutExists != null));
    }

    /** Waits for at least one onMultiWindowModeChanged event. */
    ActivityLifecycleCounts waitForOnMultiWindowModeChanged(ComponentName activityName) {
        final ActivityLifecycleCounts counts = new ActivityLifecycleCounts(activityName);
        Condition.waitFor(counts.countWithRetry(""waitForOnMultiWindowModeChanged"", countSpec(
                ActivityCallback.ON_MULTI_WINDOW_MODE_CHANGED, CountSpec.GREATER_THAN, 0)));
        return counts;
    }

    WindowState getPackageWindowState(String packageName) {
        final WindowManagerState.WindowState window =
                mWmState.getWindowByPackageName(packageName, TYPE_BASE_APPLICATION);
        assertNotNull(window);
        return window;
    }

    static class ActivityLifecycleCounts {
        private final int[] mCounts = new int[ActivityCallback.SIZE];
        private final int[] mFirstIndexes = new int[ActivityCallback.SIZE];
        private final int[] mLastIndexes = new int[ActivityCallback.SIZE];
        private ComponentName mActivityName;

        ActivityLifecycleCounts(ComponentName componentName) {
            mActivityName = componentName;
            updateCount(TestJournalContainer.get(componentName).callbacks);
        }

        ActivityLifecycleCounts(List<ActivityCallback> callbacks) {
            updateCount(callbacks);
        }

        private void updateCount(List<ActivityCallback> callbacks) {
            // The callback list could be from the reference of TestJournal. If we are counting for
            // retrying, there may be new data added to the list from other threads.
            TestJournalContainer.withThreadSafeAccess(() -> {
                Arrays.fill(mFirstIndexes, -1);
                for (int i = 0; i < callbacks.size(); i++) {
                    final ActivityCallback callback = callbacks.get(i);
                    final int ordinal = callback.ordinal();
                    mCounts[ordinal]++;
                    mLastIndexes[ordinal] = i;
                    if (mFirstIndexes[ordinal] == -1) {
                        mFirstIndexes[ordinal] = i;
                    }
                }
            });
        }

        int getCount(ActivityCallback callback) {
            return mCounts[callback.ordinal()];
        }

        int getFirstIndex(ActivityCallback callback) {
            return mFirstIndexes[callback.ordinal()];
        }

        int getLastIndex(ActivityCallback callback) {
            return mLastIndexes[callback.ordinal()];
        }

        @SafeVarargs
        final Condition<String> countWithRetry(String message,
                CountSpec<ActivityCallback>... countSpecs) {
            if (mActivityName == null) {
                throw new IllegalStateException(
                        ""It is meaningless to retry without specified activity"");
            }
            return new Condition<String>(message)
                    .setOnRetry(() -> {
                        Arrays.fill(mCounts, 0);
                        Arrays.fill(mLastIndexes, 0);
                        updateCount(TestJournalContainer.get(mActivityName).callbacks);
                    })
                    .setResultSupplier(() -> validateCount(countSpecs))
                    .setResultValidator(failedReasons -> failedReasons == null);
        }

        @SafeVarargs
        final void assertCountWithRetry(String message, CountSpec<ActivityCallback>... countSpecs) {
            if (mActivityName == null) {
                throw new IllegalStateException(
                        ""It is meaningless to retry without specified activity"");
            }
            Condition.<String>waitForResult(countWithRetry(message, countSpecs)
                    .setOnFailure(failedReasons -> fail(message + "": "" + failedReasons)));
        }

        @SafeVarargs
        final String validateCount(CountSpec<ActivityCallback>... countSpecs) {
            ArrayList<String> failedReasons = null;
            for (CountSpec<ActivityCallback> spec : countSpecs) {
                final int realCount = mCounts[spec.mEvent.ordinal()];
                if (!spec.validate(realCount)) {
                    if (failedReasons == null) {
                        failedReasons = new ArrayList<>();
                    }
                    failedReasons.add(spec.mMessage + "" (got "" + realCount + "")"");
                }
            }
            return failedReasons == null ? null : String.join(""\n"", failedReasons);
        }
    }

    protected void stopTestPackage(final String packageName) {
        runWithShellPermission(() -> mAm.forceStopPackage(packageName));
    }

    protected LaunchActivityBuilder getLaunchActivityBuilder() {
        return new LaunchActivityBuilder(mWmState);
    }

    public static <T extends Activity>
    ActivityScenarioRule<T> createFullscreenActivityScenarioRule(Class<T> clazz) {
        final ActivityOptions options = ActivityOptions.makeBasic();
        options.setLaunchWindowingMode(WindowConfiguration.WINDOWING_MODE_FULLSCREEN);
        return new ActivityScenarioRule<>(clazz, options.toBundle());
    }

    protected static class LaunchActivityBuilder implements LaunchProxy {
        private final WindowManagerStateHelper mAmWmState;

        // The activity to be launched
        private ComponentName mTargetActivity = TEST_ACTIVITY;
        private boolean mUseApplicationContext;
        private boolean mToSide;
        private boolean mRandomData;
        private boolean mNewTask;
        private boolean mMultipleTask;
        private boolean mAllowMultipleInstances = true;
        private boolean mLaunchTaskBehind;
        private boolean mFinishBeforeLaunch;
        private int mDisplayId = INVALID_DISPLAY;
        private int mWindowingMode = -1;
        private int mActivityType = ACTIVITY_TYPE_UNDEFINED;
        // A proxy activity that launches other activities including mTargetActivityName
        private ComponentName mLaunchingActivity = LAUNCHING_ACTIVITY;
        private boolean mReorderToFront;
        private boolean mWaitForLaunched;
        private boolean mSuppressExceptions;
        private boolean mWithShellPermission;
        // Use of the following variables indicates that a broadcast receiver should be used instead
        // of a launching activity;
        private ComponentName mBroadcastReceiver;
        private String mBroadcastReceiverAction;
        private int mIntentFlags;
        private Bundle mExtras;
        private LaunchInjector mLaunchInjector;
        private ActivitySessionClient mActivitySessionClient;

        private enum LauncherType {
            INSTRUMENTATION, LAUNCHING_ACTIVITY, BROADCAST_RECEIVER
        }

        private LauncherType mLauncherType = LauncherType.LAUNCHING_ACTIVITY;

        public LaunchActivityBuilder(WindowManagerStateHelper amWmState) {
            mAmWmState = amWmState;
            mWaitForLaunched = true;
            mWithShellPermission = true;
        }

        public LaunchActivityBuilder setToSide(boolean toSide) {
            mToSide = toSide;
            return this;
        }

        public LaunchActivityBuilder setRandomData(boolean randomData) {
            mRandomData = randomData;
            return this;
        }

        public LaunchActivityBuilder setNewTask(boolean newTask) {
            mNewTask = newTask;
            return this;
        }

        public LaunchActivityBuilder setMultipleTask(boolean multipleTask) {
            mMultipleTask = multipleTask;
            return this;
        }

        public LaunchActivityBuilder allowMultipleInstances(boolean allowMultipleInstances) {
            mAllowMultipleInstances = allowMultipleInstances;
            return this;
        }

        public LaunchActivityBuilder setLaunchTaskBehind(boolean launchTaskBehind) {
            mLaunchTaskBehind = launchTaskBehind;
            return this;
        }

        public LaunchActivityBuilder setReorderToFront(boolean reorderToFront) {
            mReorderToFront = reorderToFront;
            return this;
        }

        public LaunchActivityBuilder setUseApplicationContext(boolean useApplicationContext) {
            mUseApplicationContext = useApplicationContext;
            return this;
        }

        public LaunchActivityBuilder setFinishBeforeLaunch(boolean finishBeforeLaunch) {
            mFinishBeforeLaunch = finishBeforeLaunch;
            return this;
        }

        public ComponentName getTargetActivity() {
            return mTargetActivity;
        }

        public boolean isTargetActivityTranslucent() {
            return mAmWmState.isActivityTranslucent(mTargetActivity);
        }

        public LaunchActivityBuilder setTargetActivity(ComponentName targetActivity) {
            mTargetActivity = targetActivity;
            return this;
        }

        public LaunchActivityBuilder setDisplayId(int id) {
            mDisplayId = id;
            return this;
        }

        public LaunchActivityBuilder setWindowingMode(int windowingMode) {
            mWindowingMode = windowingMode;
            return this;
        }

        public LaunchActivityBuilder setActivityType(int type) {
            mActivityType = type;
            return this;
        }

        public LaunchActivityBuilder setLaunchingActivity(ComponentName launchingActivity) {
            mLaunchingActivity = launchingActivity;
            mLauncherType = LauncherType.LAUNCHING_ACTIVITY;
            return this;
        }

        public LaunchActivityBuilder setWaitForLaunched(boolean shouldWait) {
            mWaitForLaunched = shouldWait;
            return this;
        }

        /** Use broadcast receiver as a launchpad for activities. */
        public LaunchActivityBuilder setUseBroadcastReceiver(final ComponentName broadcastReceiver,
                final String broadcastAction) {
            mBroadcastReceiver = broadcastReceiver;
            mBroadcastReceiverAction = broadcastAction;
            mLauncherType = LauncherType.BROADCAST_RECEIVER;
            return this;
        }

        /** Use {@link android.app.Instrumentation} as a launchpad for activities. */
        public LaunchActivityBuilder setUseInstrumentation() {
            mLauncherType = LauncherType.INSTRUMENTATION;
            // Calling startActivity() from outside of an Activity context requires the
            // FLAG_ACTIVITY_NEW_TASK flag.
            setNewTask(true);
            return this;
        }

        public LaunchActivityBuilder setSuppressExceptions(boolean suppress) {
            mSuppressExceptions = suppress;
            return this;
        }

        public LaunchActivityBuilder setWithShellPermission(boolean withShellPermission) {
            mWithShellPermission = withShellPermission;
            return this;
        }

        public LaunchActivityBuilder setActivitySessionClient(ActivitySessionClient sessionClient) {
            mActivitySessionClient = sessionClient;
            return this;
        }

        @Override
        public boolean shouldWaitForLaunched() {
            return mWaitForLaunched;
        }

        public LaunchActivityBuilder setIntentFlags(int flags) {
            mIntentFlags = flags;
            return this;
        }

        public LaunchActivityBuilder setIntentExtra(Consumer<Bundle> extrasConsumer) {
            if (extrasConsumer != null) {
                mExtras = new Bundle();
                extrasConsumer.accept(mExtras);
            }
            return this;
        }

        @Override
        public Bundle getExtras() {
            return mExtras;
        }

        @Override
        public void setLaunchInjector(LaunchInjector injector) {
            mLaunchInjector = injector;
        }

        @Override
        public void execute() {
            if (mActivitySessionClient != null) {
                final ActivitySessionClient client = mActivitySessionClient;
                // Clear the session client so its startActivity can call the real execute().
                mActivitySessionClient = null;
                client.startActivity(this);
                return;
            }
            switch (mLauncherType) {
                case INSTRUMENTATION:
                    if (mWithShellPermission) {
                        NestedShellPermission.run(this::launchUsingInstrumentation);
                    } else {
                        launchUsingInstrumentation();
                    }
                    break;
                case LAUNCHING_ACTIVITY:
                case BROADCAST_RECEIVER:
                    launchUsingShellCommand();
            }

            if (mWaitForLaunched) {
                mAmWmState.waitForValidState(mTargetActivity);
            }
        }

        /** Launch an activity using instrumentation. */
        private void launchUsingInstrumentation() {
            final Bundle b = new Bundle();
            b.putBoolean(KEY_LAUNCH_ACTIVITY, true);
            b.putBoolean(KEY_LAUNCH_TO_SIDE, mToSide);
            b.putBoolean(KEY_RANDOM_DATA, mRandomData);
            b.putBoolean(KEY_NEW_TASK, mNewTask);
            b.putBoolean(KEY_MULTIPLE_TASK, mMultipleTask);
            b.putBoolean(KEY_MULTIPLE_INSTANCES, mAllowMultipleInstances);
            b.putBoolean(KEY_LAUNCH_TASK_BEHIND, mLaunchTaskBehind);
            b.putBoolean(KEY_REORDER_TO_FRONT, mReorderToFront);
            b.putInt(KEY_DISPLAY_ID, mDisplayId);
            b.putInt(KEY_WINDOWING_MODE, mWindowingMode);
            b.putInt(KEY_ACTIVITY_TYPE, mActivityType);
            b.putBoolean(KEY_USE_APPLICATION_CONTEXT, mUseApplicationContext);
            b.putString(KEY_TARGET_COMPONENT, getActivityName(mTargetActivity));
            b.putBoolean(KEY_SUPPRESS_EXCEPTIONS, mSuppressExceptions);
            b.putInt(KEY_INTENT_FLAGS, mIntentFlags);
            b.putBundle(KEY_INTENT_EXTRAS, getExtras());
            final Context context = getInstrumentation().getContext();
            launchActivityFromExtras(context, b, mLaunchInjector);
        }

        /** Build and execute a shell command to launch an activity. */
        private void launchUsingShellCommand() {
            StringBuilder commandBuilder = new StringBuilder();
            if (mBroadcastReceiver != null && mBroadcastReceiverAction != null) {
                // Use broadcast receiver to launch the target.
                commandBuilder.append(""am broadcast -a "").append(mBroadcastReceiverAction)
                        .append("" -p "").append(mBroadcastReceiver.getPackageName())
                        // Include stopped packages
                        .append("" -f 0x00000020"");
            } else {
                // If new task flag isn't set the windowing mode of launcher activity will be the
                // windowing mode of the target activity, so we need to launch launcher activity in
                // it.
                String amStartCmd =
                        (mWindowingMode == -1 || mNewTask)
                                ? getAmStartCmd(mLaunchingActivity)
                                : getAmStartCmd(mLaunchingActivity, mWindowingMode);
                // Use launching activity to launch the target.
                commandBuilder.append(amStartCmd)
                        .append("" -f 0x20000020"");
            }

            // Add a flag to ensure we actually mean to launch an activity.
            commandBuilder.append("" --ez "" + KEY_LAUNCH_ACTIVITY + "" true"");

            if (mToSide) {
                commandBuilder.append("" --ez "" + KEY_LAUNCH_TO_SIDE + "" true"");
            }
            if (mRandomData) {
                commandBuilder.append("" --ez "" + KEY_RANDOM_DATA + "" true"");
            }
            if (mNewTask) {
                commandBuilder.append("" --ez "" + KEY_NEW_TASK + "" true"");
            }
            if (mMultipleTask) {
                commandBuilder.append("" --ez "" + KEY_MULTIPLE_TASK + "" true"");
            }
            if (mAllowMultipleInstances) {
                commandBuilder.append("" --ez "" + KEY_MULTIPLE_INSTANCES + "" true"");
            }
            if (mReorderToFront) {
                commandBuilder.append("" --ez "" + KEY_REORDER_TO_FRONT + "" true"");
            }
            if (mFinishBeforeLaunch) {
                commandBuilder.append("" --ez "" + KEY_FINISH_BEFORE_LAUNCH + "" true"");
            }
            if (mDisplayId != INVALID_DISPLAY) {
                commandBuilder.append("" --ei "" + KEY_DISPLAY_ID + "" "").append(mDisplayId);
            }
            if (mWindowingMode != -1) {
                commandBuilder.append("" --ei "" + KEY_WINDOWING_MODE + "" "").append(mWindowingMode);
            }
            if (mActivityType != ACTIVITY_TYPE_UNDEFINED) {
                commandBuilder.append("" --ei "" + KEY_ACTIVITY_TYPE + "" "").append(mActivityType);
            }

            if (mUseApplicationContext) {
                commandBuilder.append("" --ez "" + KEY_USE_APPLICATION_CONTEXT + "" true"");
            }

            if (mTargetActivity != null) {
                // {@link ActivityLauncher} parses this extra string by
                // {@link ComponentName#unflattenFromString(String)}.
                commandBuilder.append("" --es "" + KEY_TARGET_COMPONENT + "" "")
                        .append(getActivityName(mTargetActivity));
            }

            if (mSuppressExceptions) {
                commandBuilder.append("" --ez "" + KEY_SUPPRESS_EXCEPTIONS + "" true"");
            }

            if (mIntentFlags != 0) {
                commandBuilder.append("" --ei "" + KEY_INTENT_FLAGS + "" "").append(mIntentFlags);
            }

            if (mLaunchInjector != null) {
                commandBuilder.append("" --ez "" + KEY_FORWARD + "" true"");
                mLaunchInjector.setupShellCommand(commandBuilder);
            }
            executeShellCommand(commandBuilder.toString());
        }
    }

    /**
     * The actions which wraps a test method. It is used to set necessary rules that cannot be
     * overridden by subclasses. It executes in the outer scope of {@link Before} and {@link After}.
     */
    protected class WrapperRule implements TestRule {
        private final Runnable mBefore;
        private final Runnable mAfter;

        protected WrapperRule(Runnable before, Runnable after) {
            mBefore = before;
            mAfter = after;
        }

        @Override
        public Statement apply(final Statement base, final Description description) {
            return new Statement() {
                @Override
                public void evaluate()  {
                    if (mBefore != null) {
                        mBefore.run();
                    }
                    try {
                        base.evaluate();
                    } catch (Throwable e) {
                        mPostAssertionRule.addError(e);
                    } finally {
                        if (mAfter != null) {
                            mAfter.run();
                        }
                    }
                }
            };
        }
    }

    /**
     * The post assertion to ensure all test methods don't violate the generic rule. It is also used
     * to collect multiple errors.
     */
    private class PostAssertionRule extends ErrorCollector {
        private Throwable mLastError;

        @Override
        protected void verify() throws Throwable {
            if (mLastError != null) {
                // Try to recover the bad state of device to avoid subsequent test failures.
                if (isKeyguardLocked()) {
                    mLastError.addSuppressed(new IllegalStateException(""Keyguard is locked""));
                    // To clear the credential immediately, the screen need to be turned on.
                    pressWakeupButton();
                    removeLockCredential();
                    // Off/on to refresh the keyguard state.
                    pressSleepButton();
                    pressWakeupButton();
                    pressUnlockButton();
                }
                final String overlayDisplaySettings = Settings.Global.getString(
                        mContext.getContentResolver(), Settings.Global.OVERLAY_DISPLAY_DEVICES);
                if (overlayDisplaySettings != null && overlayDisplaySettings.length() > 0) {
                    mLastError.addSuppressed(new IllegalStateException(
                            ""Overlay display is found: "" + overlayDisplaySettings));
                    // Remove the overlay display because it may obscure the screen and causes the
                    // next tests to fail.
                    SettingsSession.delete(Settings.Global.getUriFor(
                            Settings.Global.OVERLAY_DISPLAY_DEVICES));
                }
            }
            if (!sIllegalTaskStateFound) {
                // Skip if a illegal task state was already found in previous test, or all tests
                // afterward could also fail and fire unnecessary false alarms.
                try {
                    mWmState.assertIllegalTaskState();
                } catch (Throwable t) {
                    sIllegalTaskStateFound = true;
                    addError(t);
                }
            }
            super.verify();
        }

        @Override
        public void addError(Throwable error) {
            super.addError(error);
            logE(""addError: "" + error);
            mLastError = error;
        }
    }

    /** Activity that can handle all config changes. */
    public static class ConfigChangeHandlingActivity extends CommandSession.BasicTestActivity {
    }
}"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.packagemanager.stats.host.IncrementalAppErrorStatsTests"	"testAppCrashOnIncremental"	"CtsPackageManagerStatsHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/packagemanager/stats/src/com/android/cts/packagemanager/stats/host/IncrementalAppErrorStatsTests.java"	""	"public void testAppCrashOnIncremental() throws Exception {
        if (!getDevice().hasFeature(FEATURE_INCREMENTAL_DELIVERY)) {
            return;
        }
        final int atomTag = AtomsProto.Atom.APP_CRASH_OCCURRED_FIELD_NUMBER;
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag,  /*uidInAttributionChain=*/false);

        DeviceUtils.runActivity(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                ""StatsdCtsForegroundActivity"", ""action"", ""action.crash"");
        Thread.sleep(METRICS_WAIT_MILLISECONDS);
        // Sorted list of events in order in which they occurred.
        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        assertThat(data).hasSize(1);
        AtomsProto.AppCrashOccurred atom = data.get(0).getAtom().getAppCrashOccurred();
        // UID should belong to the run activity, not any system service.
        assertThat(atom.getUid()).isGreaterThan(10000);
        assertThat(atom.getEventType()).isEqualTo(""crash"");
        assertThat(atom.getIsInstantApp().getNumber())
                .isEqualTo(AtomsProto.AppCrashOccurred.InstantApp.FALSE_VALUE);
        assertThat(atom.getForegroundState().getNumber())
                .isEqualTo(AtomsProto.AppCrashOccurred.ForegroundState.FOREGROUND_VALUE);
        assertThat(atom.getPackageName()).isEqualTo(DeviceUtils.STATSD_ATOM_TEST_PKG);
        assertThat(atom.getErrorSource()).isEqualTo(ErrorSource.DATA_APP);
        assertTrue(atom.getIsIncremental());
        assertFalse((1.0f - atom.getLoadingProgress()) < 0.0000001f);
        assertTrue(atom.getMillisSinceOldestPendingRead() > 0);
        assertEquals(3 /* HEALTH_STATUS_UNHEALTHY */, atom.getStorageHealthCode());
        assertEquals(6 /* DATA_LOADER_IMAGE_READY */, atom.getDataLoaderStatusCode());
        assertFalse(atom.getReadLogsEnabled());
        assertTrue(atom.getMillisSinceLastDataLoaderBind() > 0);
        assertEquals(0, atom.getDataLoaderBindDelayMillis());
        if (!hasIncrementalDeliveryV2Feature()) {
            // Skip kernel stats check if it's not supported
            return;
        }
        assertTrue(atom.getTotalDelayedReads() > 0);
        assertTrue(atom.getTotalFailedReads() > 0);
        assertTrue(atom.getLastReadErrorMillisSince() > 0);
        assertEquals(-62 /* -ETIME */, atom.getLastReadErrorCode());
        assertTrue(atom.getTotalDelayedReadsDurationMillis() > 0);
    }"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.packagemanager.stats.host.IncrementalAppErrorStatsTests"	"testAppAnrIncremental"	"CtsPackageManagerStatsHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/packagemanager/stats/src/com/android/cts/packagemanager/stats/host/IncrementalAppErrorStatsTests.java"	""	"public void testAppAnrIncremental() throws Exception {
        if (!getDevice().hasFeature(FEATURE_INCREMENTAL_DELIVERY)) {
            return;
        }
        final int atomTag = AtomsProto.Atom.ANR_OCCURRED_FIELD_NUMBER;
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag, /*useUidAttributionChain=*/false);
        final int ANR_WAIT_MILLS = 15_000;

        try (AutoCloseable a = DeviceUtils.withActivity(getDevice(),
                DeviceUtils.STATSD_ATOM_TEST_PKG, ""ANRActivity"", null, null)) {
            Thread.sleep(AtomTestUtils.WAIT_TIME_LONG);
            getDevice().executeShellCommand(
                    ""am broadcast -a action_anr -p "" + DeviceUtils.STATSD_ATOM_TEST_PKG);
            Thread.sleep(ANR_WAIT_MILLS);
        }

        // Sorted list of events in order in which they occurred.
        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        assertThat(data).hasSize(1);
        assertThat(data.get(0).getAtom().hasAnrOccurred()).isTrue();
        AtomsProto.ANROccurred atom = data.get(0).getAtom().getAnrOccurred();
        assertThat(atom.getIsInstantApp().getNumber())
                .isEqualTo(AtomsProto.ANROccurred.InstantApp.FALSE_VALUE);
        assertThat(atom.getForegroundState().getNumber())
                .isEqualTo(AtomsProto.ANROccurred.ForegroundState.FOREGROUND_VALUE);
        assertThat(atom.getErrorSource()).isEqualTo(ErrorSource.DATA_APP);
        assertThat(atom.getPackageName()).isEqualTo(DeviceUtils.STATSD_ATOM_TEST_PKG);
        assertTrue(atom.getIsIncremental());
        assertFalse((1.0f - atom.getLoadingProgress()) < 0.0000001f);
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.app.cts.StatusBarManagerTest"	"testDisableForSetup_setDisabledTrue"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/StatusBarManagerTest.java"	""	"public void testDisableForSetup_setDisabledTrue() throws Exception {
        mStatusBarManager.setDisabledForSetup(true);

        // Check for the default set of disable flags
        assertDefaultFlagsArePresent(mStatusBarManager.getDisableInfo());
    }

    private void assertDefaultFlagsArePresent(DisableInfo info) {
        assertTrue(info.isNotificationPeekingDisabled());
        assertTrue(info.isNavigateToHomeDisabled());
        assertTrue(info.isStatusBarExpansionDisabled());
        assertTrue(info.isRecentsDisabled());
        assertTrue(info.isSearchDisabled());
    }

    /**
     * Test StatusBarManager.setDisabledForSetup(false)
     * @throws Exception
     */"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.appsearch.cts.AppSearchInstantAppTest"	"isTrue"	"CtsAppSearchHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsearch/src/android/appsearch/cts/AppSearchInstantAppTest.java"	""	"/*
 *.
 */

package android.appsearch.cts;

import static com.google.common.truth.Truth.assertWithMessage;

import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;
import com.android.tradefed.testtype.junit4.BaseHostJUnit4Test;
import com.android.tradefed.testtype.junit4.DeviceTestRunOptions;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.Map;

import javax.annotation.Nonnull;

/**
 * Test to cover instant app behavior with AppSearch.
 *
 * <p>This test is split into two distinct parts: The first part is the test-apps that runs on the
 * device and interactive with AppSearch. This class is the second part that runs on the host and
 * triggers tests in the first part for different users.
 *
 * <p>To trigger a device test, call runDeviceTestAsUser with a specific the test name and specific
 * user.
 *
 * <p>Unlock your device when testing locally.
 */
@RunWith(DeviceJUnit4ClassRunner.class)
public class AppSearchInstantAppTest extends BaseHostJUnit4Test {
    private static final String TARGET_APK_A = ""CtsAppSearchHostTestHelperA.apk"";
    private static final String TARGET_PKG_A = ""android.appsearch.app.a"";
    private static final String TEST_CLASS_A = TARGET_PKG_A + "".AppSearchInstantAppTest"";
    private static final long DEFAULT_INSTRUMENTATION_TIMEOUT_MS = 600_000; // 10min

    private int mPrimaryUserId;

    private void runDeviceTestAsUserInPkgA(@Nonnull String testMethod, int userId)
            throws Exception {
        assertWithMessage(testMethod + "" failed"").that(
                runDeviceTests(getDevice(), TARGET_PKG_A, TEST_CLASS_A, testMethod, userId,
                        DEFAULT_INSTRUMENTATION_TIMEOUT_MS)).isTrue();
    }

    @Before
    public void setUp() throws Exception {
        mPrimaryUserId = getDevice().getPrimaryUserId();
        uninstallPackage(TARGET_PKG_A);
        installPackageAsUser(TARGET_APK_A, /* grantPermission= */true, mPrimaryUserId, ""--instant"");
    }

    @After
    public void tearDown() throws Exception {
        uninstallPackage(TARGET_PKG_A);
    }"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.appsearch.cts.AppSearchInstantAppTest"	"testInstantAppDoesntHaveAccess"	"CtsAppSearchHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsearch/src/android/appsearch/cts/AppSearchInstantAppTest.java"	""	"public void testInstantAppDoesntHaveAccess() throws Exception {
        runDeviceTestAsUserInPkgA(""testInstantAppDoesntHaveAccess"", mPrimaryUserId);
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.managedprovisioning.DeviceAdminTestReceiver"	"isHeadlessSystemUserMode"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/DeviceAdminTestReceiver.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.managedprovisioning;

import static android.app.admin.DevicePolicyManager.EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE;

import android.app.Service;
import android.app.admin.DeviceAdminReceiver;
import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.ServiceConnection;
import android.content.pm.PackageManager;
import android.os.IBinder;
import android.os.PersistableBundle;
import android.os.Process;
import android.os.RemoteException;
import android.os.UserHandle;
import android.os.UserManager;
import android.util.Log;

import androidx.localbroadcastmanager.content.LocalBroadcastManager;

import com.android.bedstead.dpmwrapper.DeviceOwnerHelper;
import com.android.compatibility.common.util.enterprise.DeviceAdminReceiverUtils;
import com.android.cts.verifier.R;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
import java.util.function.Consumer;

/**
 * Profile owner receiver for BYOD flow test.
 * Setup cross-profile intent filter after successful provisioning.
 */
public class DeviceAdminTestReceiver extends DeviceAdminReceiver {
    public static final String KEY_BUNDLE_WIPE_IMMEDIATELY = ""wipe_immediately"";
    private static final String TAG = ""DeviceAdminTestReceiver"";
    private static final String DEVICE_OWNER_PKG =
            ""com.android.cts.verifier"";
    private static final String ADMIN_RECEIVER_TEST_CLASS =
            DEVICE_OWNER_PKG + "".managedprovisioning.DeviceAdminTestReceiver"";
    private static final ComponentName RECEIVER_COMPONENT_NAME = new ComponentName(
            DEVICE_OWNER_PKG, ADMIN_RECEIVER_TEST_CLASS);
    public static final String EXTRA_MANAGED_USER_TEST =
            ""com.android.cts.verifier.managedprovisioning.extra.MANAGED_USER_TEST"";
    public static final String EXTRA_LOGOUT_ON_START =
            ""com.android.cts.verifier.managedprovisioning.extra.LOGOUT_ON_START"";
    public static final String AFFILIATION_ID = ""affiliationId"";

    public static ComponentName getReceiverComponentName() {
        return RECEIVER_COMPONENT_NAME;
    }

    @Override
    public void onReceive(Context context, Intent intent) {
        if (DeviceAdminReceiverUtils.disableSelf(context, intent)) return;
        if (DeviceOwnerHelper.runManagerMethod(this, context, intent)) return;

        String action = intent.getAction();
        Log.d(TAG, ""onReceive(): user="" + UserHandle.myUserId() + "", action="" + action);

        // Must set affiliation on headless system user, otherwise some operations in the current
        // user (which is PO) won't be allowed (like uininstalling a package)
        if (ACTION_DEVICE_ADMIN_ENABLED.equals(action) && UserManager.isHeadlessSystemUserMode()) {
            Set<String> ids = new HashSet<>();
            ids.add(""affh!"");
            Log.i(TAG, ""Setting affiliation ids to "" + ids);
            getManager(context).setAffiliationIds(getWho(context), ids);
        }

        super.onReceive(context, intent);
    }

    @Override
    public void onProfileProvisioningComplete(Context context, Intent intent) {
        Log.d(TAG, ""Provisioning complete intent received"");
        setupProfile(context);
        wipeIfNecessary(context, intent);
    }

    @Override
    public void onBugreportSharingDeclined(Context context, Intent intent) {
        Log.i(TAG, ""Bugreport sharing declined"");
        Utils.showBugreportNotification(context, context.getString(
                R.string.bugreport_sharing_declined), Utils.BUGREPORT_NOTIFICATION_ID);
    }

    @Override
    public void onBugreportShared(Context context, Intent intent, String bugreportFileHash) {
        Log.i(TAG, ""Bugreport shared"");
        Utils.showBugreportNotification(context, context.getString(
                R.string.bugreport_shared_successfully), Utils.BUGREPORT_NOTIFICATION_ID);
    }

    @Override
    public void onBugreportFailed(Context context, Intent intent, int failureCode) {
        Log.i(TAG, ""Bugreport collection operation failed, code: "" + failureCode);
        Utils.showBugreportNotification(context, context.getString(
                R.string.bugreport_failed_completing), Utils.BUGREPORT_NOTIFICATION_ID);
    }

    @Override
    public void onLockTaskModeEntering(Context context, Intent intent, String pkg) {
        Log.i(TAG, ""Entering LockTask mode: "" + pkg);
        LocalBroadcastManager.getInstance(context)
                .sendBroadcast(new Intent(LockTaskUiTestActivity.ACTION_LOCK_TASK_STARTED));
    }

    @Override
    public void onLockTaskModeExiting(Context context, Intent intent) {
        Log.i(TAG, ""Exiting LockTask mode"");
        LocalBroadcastManager.getInstance(context)
                .sendBroadcast(new Intent(LockTaskUiTestActivity.ACTION_LOCK_TASK_STOPPED));
    }

    @Override
    public void onEnabled(Context context, Intent intent) {
        Log.i(TAG, ""Device admin enabled"");
        if (intent.getBooleanExtra(EXTRA_MANAGED_USER_TEST, false)) {
            DevicePolicyManager dpm = context.getSystemService(DevicePolicyManager.class);
            ComponentName admin = getReceiverComponentName();
            dpm.setAffiliationIds(admin,
                    Collections.singleton(DeviceAdminTestReceiver.AFFILIATION_ID));
            context.startActivity(
                    new Intent(context, ManagedUserPositiveTestActivity.class).setFlags(
                            Intent.FLAG_ACTIVITY_NEW_TASK));

            bindPrimaryUserService(context, iCrossUserService -> {
                try {
                    UserHandle userHandle = Process.myUserHandle();
                    Log.d(TAG, ""calling switchUser("" + userHandle + "")"");
                    iCrossUserService.switchUser(userHandle);
                } catch (RemoteException re) {
                    Log.e(TAG, ""Error when calling primary user"", re);
                }
            });
        } else if (intent.getBooleanExtra(EXTRA_LOGOUT_ON_START, false)) {
            DevicePolicyManager dpm = context.getSystemService(DevicePolicyManager.class);
            ComponentName admin = getReceiverComponentName();
            dpm.setAffiliationIds(admin,
                    Collections.singleton(DeviceAdminTestReceiver.AFFILIATION_ID));
            dpm.logoutUser(admin);
        }
    }

    private void setupProfile(Context context) {
        DevicePolicyManager dpm = (DevicePolicyManager) context.getSystemService(Context.DEVICE_POLICY_SERVICE);
        dpm.setProfileEnabled(new ComponentName(context.getApplicationContext(), getClass()));

        // Setup cross-profile intent filter to allow communications between the two versions of CtsVerifier
        // Primary -> work direction
        IntentFilter filter = new IntentFilter();
        filter.addAction(ByodHelperActivity.ACTION_QUERY_PROFILE_OWNER);
        filter.addAction(ByodHelperActivity.ACTION_REMOVE_MANAGED_PROFILE);
        filter.addAction(ByodHelperActivity.ACTION_CHECK_DISK_ENCRYPTION);
        filter.addAction(ByodHelperActivity.ACTION_INSTALL_APK);
        filter.addAction(ByodHelperActivity.ACTION_INSTALL_APK_WORK_PROFILE_GLOBAL_RESTRICTION);
        filter.addAction(ByodHelperActivity.ACTION_INSTALL_APK_PRIMARY_PROFILE_GLOBAL_RESTRICTION);
        filter.addAction(ByodHelperActivity.ACTION_CHECK_INTENT_FILTERS);
        filter.addAction(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_IMAGE);
        filter.addAction(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_VIDEO_WITH_EXTRA_OUTPUT);
        filter.addAction(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_VIDEO_WITHOUT_EXTRA_OUTPUT);
        filter.addAction(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_AUDIO);
        filter.addAction(ByodHelperActivity.ACTION_KEYGUARD_DISABLED_FEATURES);
        filter.addAction(ByodHelperActivity.ACTION_LOCKNOW);
        filter.addAction(ByodHelperActivity.ACTION_TEST_NFC_BEAM);
        filter.addAction(ByodHelperActivity.ACTION_TEST_CROSS_PROFILE_INTENTS_DIALOG);
        filter.addAction(ByodHelperActivity.ACTION_TEST_APP_LINKING_DIALOG);
        filter.addAction(ByodHelperActivity.ACTION_NOTIFICATION);
        filter.addAction(ByodHelperActivity.ACTION_NOTIFICATION_ON_LOCKSCREEN);
        filter.addAction(ByodHelperActivity.ACTION_CLEAR_NOTIFICATION);
        filter.addAction(ByodHelperActivity.ACTION_SET_USER_RESTRICTION);
        filter.addAction(ByodHelperActivity.ACTION_CLEAR_USER_RESTRICTION);
        filter.addAction(CrossProfileTestActivity.ACTION_CROSS_PROFILE_TO_WORK);
        filter.addAction(WorkStatusTestActivity.ACTION_WORK_STATUS_TOAST);
        filter.addAction(WorkStatusTestActivity.ACTION_WORK_STATUS_ICON);
        filter.addAction(
                PermissionLockdownTestActivity.ACTION_MANAGED_PROFILE_CHECK_PERMISSION_LOCKDOWN);
        filter.addAction(AuthenticationBoundKeyTestActivity.ACTION_AUTH_BOUND_KEY_TEST);
        filter.addAction(VpnTestActivity.ACTION_VPN);
        filter.addAction(AlwaysOnVpnSettingsTestActivity.ACTION_ALWAYS_ON_VPN_SETTINGS_TEST);
        filter.addAction(RecentsRedactionActivity.ACTION_RECENTS);
        filter.addAction(ByodHelperActivity.ACTION_TEST_SELECT_WORK_CHALLENGE);
        filter.addAction(ByodHelperActivity.ACTION_TEST_PATTERN_WORK_CHALLENGE);
        filter.addAction(ByodHelperActivity.ACTION_LAUNCH_CONFIRM_WORK_CREDENTIALS);
        filter.addAction(ByodHelperActivity.ACTION_SET_ORGANIZATION_INFO);
        filter.addAction(ByodHelperActivity.ACTION_TEST_PARENT_PROFILE_PASSWORD);
        filter.addAction(SetSupportMessageActivity.ACTION_SET_SUPPORT_MSG);
        filter.addAction(KeyChainTestActivity.ACTION_KEYCHAIN);
        filter.addAction(CommandReceiverActivity.ACTION_EXECUTE_COMMAND);
        filter.addAction(WorkProfileWidgetActivity.ACTION_TEST_WORK_PROFILE_WIDGET);
        filter.addAction(
                CrossProfilePermissionControlActivity.ACTION_CROSS_PROFILE_PERMISSION_CONTROL);
        filter.addAction(LocationCheckerActivity.ACTION_CHECK_LOCATION_WORK);
        dpm.addCrossProfileIntentFilter(getWho(context), filter,
                DevicePolicyManager.FLAG_MANAGED_CAN_ACCESS_PARENT);

        // Work -> primary direction
        filter = new IntentFilter();
        filter.addAction(ByodHelperActivity.ACTION_PROFILE_OWNER_STATUS);
        filter.addAction(ByodHelperActivity.ACTION_DISK_ENCRYPTION_STATUS);
        filter.addAction(ByodHelperActivity.ACTION_INSTALL_APK_IN_PRIMARY);
        filter.addAction(ByodFlowTestActivity.ACTION_TEST_RESULT);
        filter.addAction(CrossProfileTestActivity.ACTION_CROSS_PROFILE_TO_PERSONAL);

        dpm.addCrossProfileIntentFilter(getWho(context), filter,
                DevicePolicyManager.FLAG_PARENT_CAN_ACCESS_MANAGED);

        // Disable the work profile instance of this activity, because it is a helper activity for
        // the work -> primary direction.
        context.getPackageManager().setComponentEnabledSetting(
                new ComponentName(context, ByodPrimaryHelperActivity.class.getName()),
                PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP);

        // Disable the work profile instance of ByodFlowTestActivity
        context.getPackageManager().setComponentEnabledSetting(
                new ComponentName(context, ByodFlowTestActivity.class),
                PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP);
    }

    private void wipeIfNecessary(Context context, Intent intent) {
        PersistableBundle bundle = intent.getParcelableExtra(
                EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE);
        if (bundle != null && bundle.getBoolean(KEY_BUNDLE_WIPE_IMMEDIATELY, false)) {
            getManager(context).wipeData(0);
        }
    }

    private void bindPrimaryUserService(Context context, Consumer<ICrossUserService> consumer) {
        DevicePolicyManager devicePolicyManager = context.getSystemService(
                DevicePolicyManager.class);
        UserHandle primaryUser = devicePolicyManager.getBindDeviceAdminTargetUsers(
                getReceiverComponentName()).get(0);

        Log.d(TAG, ""Calling primary user: "" + primaryUser);
        final ServiceConnection serviceConnection = new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                Log.d(TAG, ""onServiceConnected is called"");
                consumer.accept(ICrossUserService.Stub.asInterface(service));
            }

            @Override
            public void onServiceDisconnected(ComponentName name) {
                Log.d(TAG, ""onServiceDisconnected is called"");
            }
        };
        final Intent serviceIntent = new Intent(context, PrimaryUserService.class);
        devicePolicyManager.bindDeviceAdminServiceAsUser(getReceiverComponentName(), serviceIntent,
                serviceConnection, Context.BIND_AUTO_CREATE, primaryUser);
    }

    public static final class PrimaryUserService extends Service {
        private final ICrossUserService.Stub mBinder = new ICrossUserService.Stub() {
            public void switchUser(UserHandle userHandle) {
                Log.d(TAG, ""switchUser: "" + userHandle);
                getSystemService(DevicePolicyManager.class).switchUser(getReceiverComponentName(),
                        userHandle);
            }
        };

        @Override
        public IBinder onBind(Intent intent) {
            return mBinder;
        }
    }
}"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.appwidget.cts.AppWidgetTest"	"testInstantAppsCannotProvideAppWidgets"	"CtsAppWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/appwidget/src/android/appwidget/cts/AppWidgetTest.java"	""	"public void testInstantAppsCannotProvideAppWidgets() {
        Assume.assumeTrue(getInstrumentation().getTargetContext()
                .getPackageManager().isInstantApp());
        assertNull(getFirstAppWidgetProviderInfo());
    }

    @AppModeInstant(reason = ""Instant apps cannot provide or host app widgets"")"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.appwidget.cts.AppWidgetTest"	"testInstantAppsCannotHostAppWidgets"	"CtsAppWidgetTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/appwidget/src/android/appwidget/cts/AppWidgetTest.java"	""	"public void testInstantAppsCannotHostAppWidgets() {
        Assume.assumeTrue(getInstrumentation().getTargetContext()
                .getPackageManager().isInstantApp());
        // Create a host and start listening.
        AppWidgetHost host = new AppWidgetHost(getInstrumentation().getTargetContext(), 0);
        // Allocate an app widget id to bind.
        assertSame(AppWidgetManager.INVALID_APPWIDGET_ID, host.allocateAppWidgetId());
    }

    @AppModeFull(reason = ""Instant apps cannot provide or host app widgets"")"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.server.wm.WindowManagerStateHelper"	"computeState"	""	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/util/src/android/server/wm/WindowManagerStateHelper.java"	""	"public void test/*
 *
 */

package android.server.wm;

import static android.app.ActivityTaskManager.INVALID_STACK_ID;
import static android.app.WindowConfiguration.ACTIVITY_TYPE_UNDEFINED;
import static android.app.WindowConfiguration.WINDOWING_MODE_UNDEFINED;
import static android.server.wm.ComponentNameUtils.getActivityName;
import static android.server.wm.ComponentNameUtils.getWindowName;
import static android.server.wm.StateLogger.logAlways;
import static android.server.wm.StateLogger.logE;
import static android.view.Display.DEFAULT_DISPLAY;
import static android.view.WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG;

import static com.google.common.truth.Truth.assertWithMessage;

import static org.hamcrest.Matchers.greaterThan;
import static org.hamcrest.Matchers.greaterThanOrEqualTo;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import android.content.ComponentName;
import android.graphics.Rect;
import android.util.SparseArray;

import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;

/** Window Manager State helper class with assert and wait functions. */
public class WindowManagerStateHelper extends WindowManagerState {

    /**
     * Compute AM and WM state of device, check validity and bounds.
     * WM state will include only visible windows, stack and task bounds will be compared.
     *
     * @param componentNames array of activity names to wait for.
     */
    public void computeState(ComponentName... componentNames) {
        waitForValidState(Arrays.stream(componentNames)
                .map(WaitForValidActivityState::new)
                .toArray(WaitForValidActivityState[]::new));
    }

    /**
     * Compute AM and WM state of device, check validity and bounds.
     * WM state will include only visible windows, stack and task bounds will be compared.
     *
     * @param waitForActivitiesVisible array of activity names to wait for.
     */
    public void computeState(WaitForValidActivityState... waitForActivitiesVisible) {
        waitForValidState(waitForActivitiesVisible);
    }

    /**
     * Wait for the activities to appear and for valid state in AM and WM.
     *
     * @param activityNames name list of activities to wait for.
     */
    public void waitForValidState(ComponentName... activityNames) {
        waitForValidState(Arrays.stream(activityNames)
                .map(WaitForValidActivityState::new)
                .toArray(WaitForValidActivityState[]::new));

    }

    /**
     * Wait for the activities to appear in proper stacks and for valid state in AM and WM.
     * @param waitForActivitiesVisible  array of activity states to wait for.
     */
    public void waitForValidState(WaitForValidActivityState... waitForActivitiesVisible) {
        if (!Condition.waitFor(""valid stacks and activities states"", () -> {
            // TODO: Get state of AM and WM at the same time to avoid mismatches caused by
            // requesting dump in some intermediate state.
            computeState();
            return !(shouldWaitForValidityCheck()
                    || shouldWaitForValidStacks()
                    || shouldWaitForActivities(waitForActivitiesVisible)
                    || shouldWaitForWindows());
        })) {
            logE(""***Waiting for states failed: "" + Arrays.toString(waitForActivitiesVisible));
        }
    }

    public void waitForAllStoppedActivities() {
        if (!Condition.waitFor(""all started activities have been removed"", () -> {
            computeState();
            return !containsStartedActivities();
        })) {
            fail(""All started activities have been removed"");
        }
    }

    /**
     * Compute AM and WM state of device, wait for the activity records to be added, and
     * wait for debugger window to show up.
     *
     * This should only be used when starting with -D (debugger) option, where we pop up the
     * waiting-for-debugger window, but real activity window won't show up since we're waiting
     * for debugger.
     */
    public void waitForDebuggerWindowVisible(ComponentName activityName) {
        Condition.waitFor(""debugger window"", () -> {
            computeState();
            return !shouldWaitForDebuggerWindow(activityName)
                    && !shouldWaitForActivityRecords(activityName);
        });
    }

    public void waitForHomeActivityVisible() {
        ComponentName homeActivity = getHomeActivityName();
        // Sometimes this function is called before we know what Home Activity is
        if (homeActivity == null) {
            logAlways(""Computing state to determine Home Activity"");
            computeState();
            homeActivity = getHomeActivityName();
        }
        assertNotNull(""homeActivity should not be null"", homeActivity);
        waitForValidState(homeActivity);
    }

    /** @return {@code true} if the recents is visible; {@code false} if timeout occurs. */
    public boolean waitForRecentsActivityVisible() {
        if (isHomeRecentsComponent()) {
            waitForHomeActivityVisible();
            return true;
        } else {
            return waitForWithAmState(WindowManagerState::isRecentsActivityVisible,
                    ""recents activity to be visible"");
        }
    }

    public void waitForDreamGone() {
        assertTrue(""Dream must be gone"",
                waitForWithAmState(state -> state.getDreamTask() == null, ""DreamActivity gone""));
    }

    public static boolean isKeyguardShowingAndNotOccluded(WindowManagerState state) {
        return state.getKeyguardControllerState().keyguardShowing
                && !state.getKeyguardControllerState().aodShowing
                && !state.getKeyguardControllerState().isKeyguardOccluded(DEFAULT_DISPLAY);
    }

    public void waitForKeyguardShowingAndNotOccluded() {
        waitForWithAmState(WindowManagerStateHelper::isKeyguardShowingAndNotOccluded,
                ""Keyguard showing"");
    }

    public void waitForKeyguardShowingAndOccluded() {
        waitForWithAmState(state -> state.getKeyguardControllerState().keyguardShowing
                        && state.getKeyguardControllerState().isKeyguardOccluded(DEFAULT_DISPLAY),
                ""Keyguard showing and occluded"");
    }

    public void waitForAodShowing() {
        waitForWithAmState(state -> state.getKeyguardControllerState().aodShowing, ""AOD showing"");
    }

    public void waitForKeyguardGone() {
        waitForWithAmState(state -> !state.getKeyguardControllerState().keyguardShowing,
                ""Keyguard gone"");
    }

    public void waitAndAssertKeyguardGone() {
        assertTrue(""Keyguard must be gone"",
                waitForWithAmState(
                        state -> !state.getKeyguardControllerState().keyguardShowing,
                        ""Keyguard gone""));
    }

    /** Wait for specific rotation for the default display. Values are Surface#Rotation */
    public void waitForRotation(int rotation) {
        waitForWithAmState(state -> state.getRotation() == rotation, ""Rotation: "" + rotation);
    }

    /**
     * Wait for specific orientation for the default display.
     * Values are ActivityInfo.ScreenOrientation
     */
    public void waitForLastOrientation(int orientation) {
        waitForWithAmState(state -> state.getLastOrientation() == orientation,
                ""LastOrientation: "" + orientation);
    }

    public void waitAndAssertLastOrientation(String message, int screenOrientation) {
        if (screenOrientation != getLastOrientation()) {
            waitForLastOrientation(screenOrientation);
        }
        assertEquals(message, screenOrientation, getLastOrientation());
    }

    /**
     * Wait for orientation for the Activity
     */
    public void waitForActivityOrientation(ComponentName activityName, int orientation) {
        waitForWithAmState(amState -> {
            final ActivityTask task = amState.getTaskByActivity(activityName);
            if (task == null) {
                return false;
            }
            return task.mFullConfiguration.orientation == orientation;
        }, ""orientation of "" + getActivityName(activityName) + "" to be "" + orientation);
    }

    public void waitForDisplayUnfrozen() {
        waitForWithAmState(state -> !state.isDisplayFrozen(), ""Display unfrozen"");
    }

    public void waitForActivityState(ComponentName activityName, String activityState) {
        waitForWithAmState(state -> state.hasActivityState(activityName, activityState),
                ""state of "" + getActivityName(activityName) + "" to be "" + activityState);
    }

    public void waitForActivityRemoved(ComponentName activityName) {
        waitFor((amState) -> !amState.containsActivity(activityName)
                && !amState.containsWindow(getWindowName(activityName)),
                getActivityName(activityName) + "" to be removed"");
    }

    public void waitAndAssertActivityRemoved(ComponentName activityName) {
        waitForActivityRemoved(activityName);
        assertNotExist(activityName);
    }

    public void waitForFocusedStack(int windowingMode, int activityType) {
        waitForWithAmState(state ->
                        (activityType == ACTIVITY_TYPE_UNDEFINED
                                || state.getFocusedStackActivityType() == activityType)
                        && (windowingMode == WINDOWING_MODE_UNDEFINED
                                || state.getFocusedStackWindowingMode() == windowingMode),
                ""focused stack"");
    }

    public void waitForPendingActivityContain(ComponentName activity) {
        waitForWithAmState(state -> state.pendingActivityContain(activity),
                getActivityName(activity) + "" in pending list"");
    }

    public boolean waitForAppTransitionRunningOnDisplay(int displayId) {
        return waitForWithAmState(
                state -> WindowManagerState.APP_STATE_RUNNING.equals(
                        state.getDisplay(displayId).getAppTransitionState()),
                ""app transition running on Display "" + displayId);
    }

    public boolean waitForAppTransitionIdleOnDisplay(int displayId) {
        return waitForWithAmState(
                state -> WindowManagerState.APP_STATE_IDLE.equals(
                        state.getDisplay(displayId).getAppTransitionState()),
                ""app transition idle on Display "" + displayId);
    }

    public void waitAndAssertNavBarShownOnDisplay(int displayId) {
        assertTrue(waitForWithAmState(
                state -> state.getAndAssertSingleNavBarWindowOnDisplay(displayId) != null,
                ""navigation bar #"" + displayId + "" show""));
    }

    public void waitAndAssertKeyguardShownOnSecondaryDisplay(int displayId) {
        assertTrue(""KeyguardDialog must be shown on secondary display "" + displayId,
                waitForWithAmState(
                        state -> isKeyguardOnSecondaryDisplay(state, displayId),
                        ""keyguard window to show""));
    }

    public void waitAndAssertKeyguardGoneOnSecondaryDisplay(int displayId) {
        assertTrue(""KeyguardDialog must be gone on secondary display "" + displayId,
                waitForWithAmState(
                        state -> !isKeyguardOnSecondaryDisplay(state, displayId),
                        ""keyguard window to dismiss""));
    }

    void waitForWindowSurfaceDisappeared(String windowName) {
        waitForWithAmState(state -> {
            return !state.isWindowSurfaceShown(windowName);
        }, windowName + ""'s surface is disappeared"");
    }

    void waitAndAssertWindowSurfaceShown(String windowName, boolean shown) {
        assertTrue(
                waitForWithAmState(state -> state.isWindowSurfaceShown(windowName) == shown,
                        windowName + ""'s  isWindowSurfaceShown to return "" + shown));
    }

    /** A variant of waitForWithAmState with different parameter order for better Kotlin interop. */
    public boolean waitForWithAmState(String message, Predicate<WindowManagerState> waitCondition) {
        return waitForWithAmState(waitCondition, message);
    }

    public boolean waitForWithAmState(Predicate<WindowManagerState> waitCondition,
            String message) {
        return waitFor((amState) -> waitCondition.test(amState), message);
    }

    public void waitWindowingModeTopFocus(int windowingMode, boolean topFocus, String message) {
        waitForWithAmState(amState -> {
            final ActivityTask stack = amState.getStandardStackByWindowingMode(windowingMode);
            return stack != null
                    && topFocus == (amState.getFocusedStackId() == stack.getRootTaskId());
        }, message);
    }

    public void waitForFocusedActivity(final String msg, final ComponentName activityName) {
        final String activityComponentName = getActivityName(activityName);
        waitFor(msg, wmState -> Objects.equals(activityComponentName, wmState.getFocusedActivity())
                && Objects.equals(activityComponentName, wmState.getFocusedApp()));
    }

    /** A variant of waitFor with different parameter order for better Kotlin interop. */
    public boolean waitFor(String message, Predicate<WindowManagerState> waitCondition) {
        return waitFor(waitCondition, message);
    }

    /** @return {@code true} if the wait is successful; {@code false} if timeout occurs. */
    public boolean waitFor(Predicate<WindowManagerState> waitCondition, String message) {
        return Condition.waitFor(message, () -> {
            computeState();
            return waitCondition.test(this);
        });
    }

    /** Waits for non-null result from {@code function} and returns it. */
    public <T> T waitForResult(String message, Function<WindowManagerState, T> function) {
        return waitForResult(message, function, Objects::nonNull);
    }

    public <T> T waitForResult(String message, Function<WindowManagerState, T> function,
            Predicate<T> validator) {
        return Condition.waitForResult(new Condition<T>(message)
                .setResultSupplier(() -> {
                    computeState();
                    return function.apply(this);
                })
                .setResultValidator(validator));
    }

    /**
     * @return true if should wait for valid stacks state.
     */
    private boolean shouldWaitForValidStacks() {
        final int stackCount = getStackCount();
        if (stackCount == 0) {
            logAlways(""***stackCount="" + stackCount);
            return true;
        }
        final int resumedActivitiesCount = getResumedActivitiesCount();
        if (!getKeyguardControllerState().keyguardShowing && resumedActivitiesCount < 1) {
            logAlways(""***resumedActivitiesCount="" + resumedActivitiesCount);
            return true;
        }
        if (getFocusedActivity() == null) {
            logAlways(""***focusedActivity=null"");
            return true;
        }
        return false;
    }

    public void waitAndAssertAppFocus(String appPackageName, long waitTime) {
        final Condition<String> condition = new Condition<>(appPackageName + "" to be focused"");
        Condition.waitFor(condition.setResultSupplier(() -> {
            computeState();
            return getFocusedApp();
        }).setResultValidator(focusedAppName -> {
            return focusedAppName != null && appPackageName.equals(
                    ComponentName.unflattenFromString(focusedAppName).getPackageName());
        }).setOnFailure(focusedAppName -> {
            fail(""Timed out waiting for focus on app ""
                    + appPackageName + "", last was "" + focusedAppName);
        }).setRetryIntervalMs(100).setRetryLimit((int) waitTime / 100));
    }

    /**
     * @return true if should wait for some activities to become visible.
     */
    private boolean shouldWaitForActivities(WaitForValidActivityState... waitForActivitiesVisible) {
        if (waitForActivitiesVisible == null || waitForActivitiesVisible.length == 0) {
            return false;
        }
        // If the caller is interested in us waiting for some particular activity windows to be
        // visible before compute the state. Check for the visibility of those activity windows
        // and for placing them in correct stacks (if requested).
        boolean allActivityWindowsVisible = true;
        boolean tasksInCorrectStacks = true;
        for (final WaitForValidActivityState state : waitForActivitiesVisible) {
            final ComponentName activityName = state.activityName;
            final String windowName = state.windowName;
            final int stackId = state.stackId;
            final int windowingMode = state.windowingMode;
            final int activityType = state.activityType;

            final List<WindowState> matchingWindowStates =
                    getMatchingVisibleWindowState(windowName);
            boolean activityWindowVisible = !matchingWindowStates.isEmpty();
            if (!activityWindowVisible) {
                logAlways(""Activity window not visible: "" + windowName);
                allActivityWindowsVisible = false;
            } else if (activityName != null
                    && !isActivityVisible(activityName)) {
                logAlways(""Activity not visible: "" + getActivityName(activityName));
                allActivityWindowsVisible = false;
            } else {
                // Check if window is already the correct state requested by test.
                boolean windowInCorrectState = false;
                for (WindowState ws : matchingWindowStates) {
                    if (stackId != INVALID_STACK_ID && ws.getStackId() != stackId) {
                        continue;
                    }
                    if (!ws.isWindowingModeCompatible(windowingMode)) {
                        continue;
                    }
                    if (activityType != ACTIVITY_TYPE_UNDEFINED
                            && ws.getActivityType() != activityType) {
                        continue;
                    }
                    windowInCorrectState = true;
                    break;
                }

                if (!windowInCorrectState) {
                    logAlways(""Window in incorrect stack: "" + state);
                    tasksInCorrectStacks = false;
                }
            }
        }
        return !allActivityWindowsVisible || !tasksInCorrectStacks;
    }

    /**
     * @return true if should wait valid windows state.
     */
    private boolean shouldWaitForWindows() {
        if (getFrontWindow() == null) {
            logAlways(""***frontWindow=null"");
            return true;
        }
        if (getFocusedWindow() == null) {
            logAlways(""***focusedWindow=null"");
            return true;
        }
        if (getFocusedApp() == null) {
            logAlways(""***focusedApp=null"");
            return true;
        }

        return false;
    }

    private boolean shouldWaitForDebuggerWindow(ComponentName activityName) {
        List<WindowState> matchingWindowStates =
                getMatchingVisibleWindowState(activityName.getPackageName());
        for (WindowState ws : matchingWindowStates) {
            if (ws.isDebuggerWindow()) {
                return false;
            }
        }
        logAlways(""Debugger window not available yet"");
        return true;
    }

    private boolean shouldWaitForActivityRecords(ComponentName... activityNames) {
        // Check if the activity records we're looking for is already added.
        for (final ComponentName activityName : activityNames) {
            if (!isActivityVisible(activityName)) {
                logAlways(""ActivityRecord "" + getActivityName(activityName) + "" not visible yet"");
                return true;
            }
        }
        return false;
    }

    private boolean shouldWaitForValidityCheck() {
        try {
            assertValidity();
        } catch (Throwable t) {
            logAlways(""Waiting for validity check: "" + t.toString());
            return true;
        }
        return false;
    }

    void assertValidity() {
        assertThat(""Must have stacks"", getStackCount(), greaterThan(0));
        // TODO: Update when keyguard will be shown on multiple displays
        if (!getKeyguardControllerState().keyguardShowing) {
            assertThat(""There should be at least one resumed activity in the system."",
                    getResumedActivitiesCount(), greaterThanOrEqualTo(1));
        }
        assertNotNull(""Must have focus activity."", getFocusedActivity());

        for (ActivityTask aStack : getRootTasks()) {
            final int stackId = aStack.mRootTaskId;
            for (ActivityTask aTask : aStack.getTasks()) {
                assertEquals(""Stack can only contain its own tasks"", stackId, aTask.mRootTaskId);
            }
        }

        assertNotNull(""Must have front window."", getFrontWindow());
        assertNotNull(""Must have focused window."", getFocusedWindow());
        assertNotNull(""Must have app."", getFocusedApp());
    }

    public void assertContainsStack(String msg, int windowingMode, int activityType) {
        assertTrue(msg, containsStack(windowingMode, activityType));
    }

    public void assertDoesNotContainStack(String msg, int windowingMode, int activityType) {
        assertFalse(msg, containsStack(windowingMode, activityType));
    }

    public void assertFrontStack(String msg, int windowingMode, int activityType) {
        assertFrontStackOnDisplay(msg, windowingMode, activityType, DEFAULT_DISPLAY);
    }

    public void assertFrontStackOnDisplay(String msg, int windowingMode, int activityType,
            int displayId) {
        if (windowingMode != WINDOWING_MODE_UNDEFINED) {
            assertEquals(msg, windowingMode,
                    getFrontStackWindowingMode(displayId));
        }
        if (activityType != ACTIVITY_TYPE_UNDEFINED) {
            assertEquals(msg, activityType, getFrontStackActivityType(displayId));
        }
    }

    public void assertFrontStackActivityType(String msg, int activityType) {
        assertEquals(msg, activityType, getFrontStackActivityType(DEFAULT_DISPLAY));
    }

    void assertFocusedStack(String msg, int stackId) {
        assertEquals(msg, stackId, getFocusedStackId());
    }

    void assertFocusedStack(String msg, int windowingMode, int activityType) {
        if (windowingMode != WINDOWING_MODE_UNDEFINED) {
            assertEquals(msg, windowingMode, getFocusedStackWindowingMode());
        }
        if (activityType != ACTIVITY_TYPE_UNDEFINED) {
            assertEquals(msg, activityType, getFocusedStackActivityType());
        }
    }

    public void assertFocusedActivity(final String msg, final ComponentName activityName) {
        final String activityComponentName = getActivityName(activityName);
        assertEquals(msg, activityComponentName, getFocusedActivity());
        assertEquals(msg, activityComponentName, getFocusedApp());
    }

    public void assertFocusedAppOnDisplay(final String msg, final ComponentName activityName,
            final int displayId) {
        final String activityComponentName = getActivityName(activityName);
        assertEquals(msg, activityComponentName, getDisplay(displayId).getFocusedApp());
    }

    public void assertNotFocusedActivity(String msg, ComponentName activityName) {
        assertNotEquals(msg, getFocusedActivity(), getActivityName(activityName));
        assertNotEquals(msg, getFocusedApp(), getActivityName(activityName));
    }

    public void assertResumedActivity(final String msg, final ComponentName activityName) {
        assertEquals(msg, getActivityName(activityName),
                getFocusedActivity());
    }

    /** Asserts that each display has correct resumed activity. */
    public void assertResumedActivities(final String msg,
            Consumer<SparseArray<ComponentName>> resumedActivitiesMapping) {
        final SparseArray<ComponentName> resumedActivities = new SparseArray<>();
        resumedActivitiesMapping.accept(resumedActivities);
        for (int i = 0; i < resumedActivities.size(); i++) {
            final int displayId = resumedActivities.keyAt(i);
            final ComponentName activityComponent = resumedActivities.valueAt(i);
            assertEquals(""Error asserting resumed activity on display "" + displayId + "": "" + msg,
                    activityComponent != null ? getActivityName(activityComponent) : null,
                    getResumedActivityOnDisplay(displayId));
        }
    }

    public void assertNotResumedActivity(String msg, ComponentName activityName) {
        assertNotEquals(msg, getFocusedActivity(), getActivityName(activityName));
    }

    public void assertFocusedWindow(String msg, String windowName) {
        assertEquals(msg, windowName, getFocusedWindow());
    }

    public void assertNotFocusedWindow(String msg, String windowName) {
        assertNotEquals(msg, getFocusedWindow(), windowName);
    }

    public void assertNotExist(final ComponentName activityName) {
        final String windowName = getWindowName(activityName);
        assertFalse(""Activity="" + getActivityName(activityName) + "" must NOT exist."",
                containsActivity(activityName));
        assertFalse(""Window="" + windowName + "" must NOT exits."",
                containsWindow(windowName));
    }

    public void waitAndAssertVisibilityGone(final ComponentName activityName) {
        // Sometimes the surface can be shown due to the late animation.
        // Wait for the animation is done.
        waitForWindowSurfaceDisappeared(getWindowName(activityName));
        assertVisibility(activityName, false);
    }

    public void assertVisibility(final ComponentName activityName, final boolean visible) {
        final String windowName = getWindowName(activityName);
        // Check existence of activity and window.
        assertTrue(""Activity="" + getActivityName(activityName) + "" must exist."",
                containsActivity(activityName));
        assertTrue(""Window="" + windowName + "" must exist."", containsWindow(windowName));

        // Check visibility of activity and window.
        assertEquals(""Activity="" + getActivityName(activityName) + "" must"" + (visible ? """" : "" NOT"")
                + "" be visible."", visible, isActivityVisible(activityName));
        assertEquals(""Window="" + windowName + "" must"" + (visible ? """" : "" NOT"")
                        + "" have shown surface."",
                visible, isWindowSurfaceShown(windowName));
    }

    public void assertHomeActivityVisible(boolean visible) {
        final ComponentName homeActivity = getHomeActivityName();
        assertNotNull(homeActivity);
        assertVisibility(homeActivity, visible);
    }

    /**
     * Asserts that the device default display minimim width is larger than the minimum task width.
     */
    void assertDeviceDefaultDisplaySizeForMultiWindow(String errorMessage) {
        computeState();
        final int minTaskSizePx = defaultMinimalTaskSize(DEFAULT_DISPLAY);
        final WindowManagerState.DisplayContent display = getDisplay(DEFAULT_DISPLAY);
        final Rect displayRect = display.getDisplayRect();
        if (Math.min(displayRect.width(), displayRect.height()) < minTaskSizePx) {
            fail(errorMessage);
        }
    }

    /**
     * Asserts that the device default display minimum width is not smaller than the minimum width
     * for split-screen required by CDD.
     */
    void assertDeviceDefaultDisplaySizeForSplitScreen(String errorMessage) {
        computeState();
        final int minDisplaySizePx = defaultMinimalDisplaySizeForSplitScreen(DEFAULT_DISPLAY);
        final WindowManagerState.DisplayContent display = getDisplay(DEFAULT_DISPLAY);
        final Rect displayRect = display.getDisplayRect();
        if (Math.max(displayRect.width(), displayRect.height()) < minDisplaySizePx) {
            fail(errorMessage);
        }
    }

    public void assertKeyguardShowingAndOccluded() {
        assertTrue(""Keyguard is showing"",
                getKeyguardControllerState().keyguardShowing);
        assertTrue(""Keyguard is occluded"",
                getKeyguardControllerState().isKeyguardOccluded(DEFAULT_DISPLAY));
    }

    public void assertKeyguardShowingAndNotOccluded() {
        assertTrue(""Keyguard is showing"",
                getKeyguardControllerState().keyguardShowing);
        assertFalse(""Keyguard is not occluded"",
                getKeyguardControllerState().isKeyguardOccluded(DEFAULT_DISPLAY));
    }

    public void assertKeyguardGone() {
        assertFalse(""Keyguard is not shown"",
                getKeyguardControllerState().keyguardShowing);
    }

    void assertKeyguardShownOnSecondaryDisplay(int displayId) {
        assertTrue(""KeyguardDialog must be shown on display "" + displayId,
                isKeyguardOnSecondaryDisplay(this, displayId));
    }

    void assertKeyguardGoneOnSecondaryDisplay(int displayId) {
        assertFalse(""KeyguardDialog must be gone on display "" + displayId,
                isKeyguardOnSecondaryDisplay(this, displayId));
    }

    public void assertAodShowing() {
        assertTrue(""AOD is showing"",
                getKeyguardControllerState().aodShowing);
    }

    public void assertAodNotShowing() {
        assertFalse(""AOD is not showing"",
                getKeyguardControllerState().aodShowing);
    }

    public void assertIllegalTaskState() {
        computeState();
        final List<ActivityTask> tasks = getRootTasks();
        for (ActivityTask task : tasks) {
            task.forAllTasks((t) -> assertWithMessage(""Empty task was found, id = "" + t.mTaskId)
                    .that(t.mTasks.size() + t.mActivities.size()).isGreaterThan(0));
            if (task.isLeafTask()) {
                continue;
            }
            assertWithMessage(""Non-leaf task cannot have affinity set, id = "" + task.mTaskId)
                    .that(task.mAffinity).isEmpty();
        }
    }

    public void assumePendingActivityContain(ComponentName activity) {
        assumeTrue(pendingActivityContain(activity));
    }

    public void assertActivityDisplayed(final ComponentName activityName) {
        assertWindowDisplayed(getWindowName(activityName));
    }

    public void assertWindowDisplayed(final String windowName) {
        waitForValidState(WaitForValidActivityState.forWindow(windowName));
        assertTrue(windowName + "" is visible"", isWindowSurfaceShown(windowName));
    }

    void waitAndAssertImeWindowShownOnDisplay(int displayId) {
        final WindowState imeWinState = Condition.waitForResult(""IME window"",
                condition -> condition
                        .setResultSupplier(this::getImeWindowState)
                        .setResultValidator(
                                w -> w != null && w.isSurfaceShown()
                                        && w.getDisplayId() == displayId));

        assertNotNull(""IME window must exist"", imeWinState);
        assertTrue(""IME window must be shown"", imeWinState.isSurfaceShown());
        assertEquals(""IME window must be on the given display"", displayId,
                imeWinState.getDisplayId());
    }

    WindowState getImeWindowState() {
        computeState();
        return getInputMethodWindowState();
    }

    boolean isScreenPortrait(int displayId) {
        final Rect displayRect = getDisplay(displayId).getDisplayRect();
        return displayRect.height() > displayRect.width();
    }

    private static boolean isKeyguardOnSecondaryDisplay(
            WindowManagerState windowManagerState, int displayId) {
        final List<WindowManagerState.WindowState> states =
                windowManagerState.getMatchingWindowType(TYPE_KEYGUARD_DIALOG);
        for (WindowManagerState.WindowState ws : states) {
            if (ws.getDisplayId() == displayId) return true;
        }
        return false;
    }
}"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.content.cts.MockSRSProvider"	"isOnCreateCalled"	"CtsContentTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/MockSRSProvider.java"	""	"public void test/*
 *.
 */
package android.content.cts;

import android.content.SearchRecentSuggestionsProvider;

public class MockSRSProvider extends SearchRecentSuggestionsProvider {
    final static String AUTHORITY = ""android.content.cts.MockSRSProvider"";
    final static int MODE = DATABASE_MODE_QUERIES + DATABASE_MODE_2LINES;

    public static boolean setupSuggestCalled;
    private boolean mOnCreateCalled;

    public MockSRSProvider() {
        super();
        setupSuggestions(AUTHORITY, MODE);
    }

    public MockSRSProvider(String tag) {
        super();
    }

    @Override
    public void setupSuggestions(String authority, int mode) {
        setupSuggestCalled = true;
        super.setupSuggestions(authority, mode);
    }

    @Override
    public boolean onCreate() {
        mOnCreateCalled = true;
        return super.onCreate();
    }

    public boolean isOnCreateCalled() {
        return mOnCreateCalled;
    }
}"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.normalapp.NormalActivity"	"finish"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/NormalApp/src/com/android/cts/normalapp/NormalActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.normalapp;

import android.app.Activity;
import android.app.SearchManager;
import android.content.Intent;
import android.content.pm.PackageInfo;
import android.content.pm.ResolveInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.net.Uri;
import android.os.Bundle;
import android.provider.SearchRecentSuggestions;
import android.util.Log;

import com.android.cts.util.TestResult;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.List;

public class NormalActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        final Intent intent  = getIntent();
        if (Intent.ACTION_SEARCH.equals(intent.getAction())) {
            final String query = intent.getStringExtra(SearchManager.QUERY);
            final SearchRecentSuggestions suggestions = new SearchRecentSuggestions(this,
                    SearchSuggestionProvider.AUTHORITY, SearchSuggestionProvider.MODE);
            suggestions.saveRecentQuery(query, null);
        }

        boolean canAccessInstantApp = false;
        String exception = null;
        try {
            canAccessInstantApp = tryAccessingInstantApp();
        } catch (Throwable t) {
            exception = t.getClass().getName();
        }

        TestResult.getBuilder()
                .setPackageName(""com.android.cts.normalapp"")
                .setComponentName(""NormalActivity"")
                .setStatus(""PASS"")
                .setException(exception)
                .setEphemeralPackageInfoExposed(canAccessInstantApp)
                .build()
                .broadcast(this);
        finish();
    }

    private boolean tryAccessingInstantApp() throws NameNotFoundException {
        final PackageInfo info = getPackageManager()
                .getPackageInfo(""com.android.cts.ephemeralapp1"", 0 /*flags*/);
        return (info != null);
    }
}"	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.os.cts.FileObserverTest"	"isInstantApp"	""	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/FileObserverTest.java"	""	"public void test/*
 *.
 */

package android.os.cts;

import android.os.Environment;
import android.os.FileObserver;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.AppModeInstant;
import android.test.AndroidTestCase;
import android.util.Pair;

import androidx.test.InstrumentationRegistry;

import java.io.File;
import java.io.FileOutputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class FileObserverTest extends AndroidTestCase {
    private static final String PATH = ""/PATH"";
    private static final String TEST_FILE = ""file_observer_test.txt"";
    private static final String TEST_DIR = ""fileobserver_dir"";
    private static final File EXT_STORAGE_DIR = new File(Environment.getExternalStorageDirectory(), ""fileobserver_toplevel_dir"");
    private static final int FILE_DATA = 0x20;
    private static final int UNDEFINED = 0x8000;
    private static final long DELAY_MSECOND = 2000;

    private void helpSetUp(File dir) throws Exception {
        File testFile = new File(dir, TEST_FILE);
        testFile.createNewFile();
        File testDir = new File(dir, TEST_DIR);
        testDir.mkdirs();
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        File dir = getContext().getFilesDir();
        helpSetUp(dir);

        dir = getContext().getCacheDir();
        helpSetUp(dir);

        // Instant apps cannot access external storage
        if (!InstrumentationRegistry.getTargetContext().getPackageManager().isInstantApp()) {
            dir = getContext().getExternalFilesDir(null);
            helpSetUp(dir);

            dir = EXT_STORAGE_DIR;
            dir.mkdirs();
            helpSetUp(dir);
        }

        // Let the setup settles
        Thread.sleep(DELAY_MSECOND);
    }

    private void helpTearDown(File dir) throws Exception {
        File testFile = new File(dir, TEST_FILE);
        File testDir = new File(dir, TEST_DIR);
        File moveDestFile = new File(testDir, TEST_FILE);

        if (testFile.exists()) {
            testFile.delete();
        }

        if (moveDestFile.exists()) {
            moveDestFile.delete();
        }

        if (testDir.exists()) {
            testDir.delete();
        }
    }

    @Override
    protected void tearDown() throws Exception {
        super.tearDown();

        File dir = getContext().getFilesDir();
        helpTearDown(dir);

        dir = getContext().getCacheDir();
        helpTearDown(dir);

        dir = getContext().getExternalFilesDir(null);
        helpTearDown(dir);

        dir = EXT_STORAGE_DIR;
        helpTearDown(dir);
        if (dir.exists()) {
            dir.delete();
        }
    }"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.hardware.camera2.cts.testcases.Camera2ConcurrentAndroidTestCase"	"isInstantApp"	"CtsCameraTestCases"	"/home/gpoor/cts-12-source/cts/tests/camera/src/android/hardware/camera2/cts/testcases/Camera2ConcurrentAndroidTestCase.java"	""	"public void test/*
 *.
 */

package android.hardware.camera2.cts.testcases;

import static android.hardware.camera2.cts.CameraTestUtils.*;
import static com.android.ex.camera2.blocking.BlockingStateCallback.*;

import android.content.Context;
import android.graphics.ImageFormat;
import android.graphics.Rect;
import android.hardware.camera2.CameraCaptureSession;
import android.hardware.camera2.CameraCaptureSession.CaptureCallback;
import android.hardware.camera2.CameraCharacteristics;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CameraManager;
import android.hardware.camera2.CaptureRequest;
import android.hardware.camera2.params.MandatoryStreamCombination;
import android.hardware.camera2.params.MandatoryStreamCombination.MandatoryStreamInformation;
import android.hardware.camera2.params.OutputConfiguration;
import android.hardware.camera2.cts.Camera2ParameterizedTestCase;
import android.hardware.camera2.cts.CameraTestUtils;
import android.hardware.camera2.cts.helpers.CameraErrorCollector;
import android.hardware.camera2.cts.helpers.StaticMetadata;
import android.hardware.camera2.cts.helpers.StaticMetadata.CheckLevel;
import android.os.Handler;
import android.os.HandlerThread;
import android.test.AndroidTestCase;
import android.util.Log;
import android.view.Surface;
import android.view.WindowManager;

import com.android.ex.camera2.blocking.BlockingSessionCallback;
import com.android.ex.camera2.blocking.BlockingStateCallback;

import java.io.File;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Set;

public class Camera2ConcurrentAndroidTestCase extends Camera2ParameterizedTestCase {
    private static final String TAG = ""Camera2ConcurrentAndroidTestCase"";
    private static final boolean VERBOSE = Log.isLoggable(TAG, Log.VERBOSE);
    public static class CameraTestInfo {
        public String mCameraId;
        public CameraDevice mCamera;
        public StaticMetadata mStaticInfo;
        public MandatoryStreamCombination[] mMandatoryStreamCombinations;
        public CameraCaptureSession mCameraSession;
        public BlockingSessionCallback mCameraSessionListener;
        public BlockingStateCallback mCameraListener;
        public CameraTestInfo(String cameraId, StaticMetadata staticInfo,
                MandatoryStreamCombination[] mandatoryStreamCombinations,
                BlockingStateCallback cameraListener) {
            mCameraId = cameraId;
            mStaticInfo = staticInfo;
            mMandatoryStreamCombinations = mandatoryStreamCombinations;
            mCameraListener = cameraListener;
        }
    };
    protected Set<Set<String>> mConcurrentCameraIdCombinations;
    protected HashMap<String, CameraTestInfo> mCameraTestInfos;
    // include both standalone camera IDs and ""hidden"" physical camera IDs
    protected String[] mAllCameraIds;
    protected HashMap<String, StaticMetadata> mAllStaticInfo;
    protected Handler mHandler;
    protected HandlerThread mHandlerThread;
    protected CameraErrorCollector mCollector;
    protected String mDebugFileNameBase;

    protected WindowManager mWindowManager;

    /**
     * Set up the camera2 test case required environments, including CameraManager,
     * HandlerThread, Camera IDs, and CameraStateCallback etc.
     */
    @Override
    public void setUp() throws Exception {
        super.setUp();
        mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
        mHandlerThread = new HandlerThread(TAG);
        mHandlerThread.start();
        mHandler = new Handler(mHandlerThread.getLooper());
        mCollector = new CameraErrorCollector();

        File filesDir = mContext.getPackageManager().isInstantApp()
                ? mContext.getFilesDir()
                : mContext.getExternalFilesDir(null);

        mDebugFileNameBase = filesDir.getPath();
        mAllStaticInfo = new HashMap<String, StaticMetadata>();
        List<String> hiddenPhysicalIds = new ArrayList<>();
        for (String cameraId : mCameraIdsUnderTest) {
            CameraCharacteristics props = mCameraManager.getCameraCharacteristics(cameraId);
            StaticMetadata staticMetadata = new StaticMetadata(props,
                    CheckLevel.ASSERT, /*collector*/null);
            mAllStaticInfo.put(cameraId, staticMetadata);
            for (String physicalId : props.getPhysicalCameraIds()) {
                if (!Arrays.asList(mCameraIdsUnderTest).contains(physicalId) &&
                        !hiddenPhysicalIds.contains(physicalId)) {
                    hiddenPhysicalIds.add(physicalId);
                    props = mCameraManager.getCameraCharacteristics(physicalId);
                    staticMetadata = new StaticMetadata(
                            mCameraManager.getCameraCharacteristics(physicalId),
                            CheckLevel.ASSERT, /*collector*/null);
                    mAllStaticInfo.put(physicalId, staticMetadata);
                }
            }
        }
        mConcurrentCameraIdCombinations =
                CameraTestUtils.getConcurrentCameraIds(mCameraManager, mAdoptShellPerm);
        assertNotNull(""Unable to get concurrent camera combinations"",
                mConcurrentCameraIdCombinations);
        mCameraTestInfos = new HashMap<String, CameraTestInfo>();
        for (Set<String> cameraIdComb : mConcurrentCameraIdCombinations) {
            for (String cameraId : cameraIdComb) {
                if (!mCameraTestInfos.containsKey(cameraId)) {
                    StaticMetadata staticMetadata = mAllStaticInfo.get(cameraId);
                    assertTrue(""camera id"" + cameraId + ""'s metadata not found in mAllStaticInfo"",
                            staticMetadata != null);
                    CameraCharacteristics.Key<MandatoryStreamCombination[]> mandatoryStreamsKey =
                            CameraCharacteristics.SCALER_MANDATORY_CONCURRENT_STREAM_COMBINATIONS;
                    MandatoryStreamCombination[] combinations =
                            staticMetadata.getCharacteristics().get(mandatoryStreamsKey);
                    assertTrue(""Concurrent streaming camera id "" + cameraId +
                            ""  MUST have mandatory stream combinations"",
                            (combinations != null) && (combinations.length > 0));
                    mCameraTestInfos.put(cameraId,
                            new CameraTestInfo(cameraId, staticMetadata, combinations,
                                  new BlockingStateCallback()));
                }
            }
        }

        mAllCameraIds = new String[mCameraIdsUnderTest.length + hiddenPhysicalIds.size()];
        System.arraycopy(mCameraIdsUnderTest, 0, mAllCameraIds, 0, mCameraIdsUnderTest.length);
        for (int i = 0; i < hiddenPhysicalIds.size(); i++) {
            mAllCameraIds[mCameraIdsUnderTest.length + i] = hiddenPhysicalIds.get(i);
        }
    }

    @Override
    public void tearDown() throws Exception {
        try {
            if (mHandlerThread != null) {
                mHandlerThread.quitSafely();
            }
            mHandler = null;

            if (mCollector != null) {
                mCollector.verify();
            }
        } catch (Throwable e) {
            // When new Exception(e) is used, exception info will be printed twice.
            throw new Exception(e.getMessage());
        } finally {
            super.tearDown();
        }
    }

    /**
     * Start capture with given {@link #CaptureRequest}.
     *
     * @param request The {@link #CaptureRequest} to be captured.
     * @param repeating If the capture is single capture or repeating.
     * @param listener The {@link #CaptureCallback} camera device used to notify callbacks.
     * @param handler The handler camera device used to post callbacks.
     */
    protected void startCapture(String cameraId, CaptureRequest request, boolean repeating,
            CaptureCallback listener, Handler handler) throws Exception {
        if (VERBOSE) Log.v(TAG, ""Starting capture from device"");
        CameraTestInfo info = mCameraTestInfos.get(cameraId);
        assertTrue(""CameraTestInfo not found for camera id "" + cameraId, info != null);
        if (repeating) {
            info.mCameraSession.setRepeatingRequest(request, listener, handler);
        } else {
            info.mCameraSession.capture(request, listener, handler);
        }
    }

    /**
     * Stop the current active capture.
     *
     * @param fast When it is true, {@link CameraDevice#flush} is called, the stop capture
     * could be faster.
     */
    protected void stopCapture(String cameraId, boolean fast) throws Exception {
        if (VERBOSE) Log.v(TAG, ""Stopping capture"");

        CameraTestInfo info = mCameraTestInfos.get(cameraId);
        assertTrue(""CameraTest info not found for camera id "" + cameraId, info != null);
        if (fast) {
            /**
             * Flush is useful for canceling long exposure single capture, it also could help
             * to make the streaming capture stop sooner.
             */
            info.mCameraSession.abortCaptures();
            info.mCameraSessionListener.getStateWaiter().
                    waitForState(BlockingSessionCallback.SESSION_READY, CAMERA_IDLE_TIMEOUT_MS);
        } else {
            info.mCameraSession.close();
            info.mCameraSessionListener.getStateWaiter().
                    waitForState(BlockingSessionCallback.SESSION_CLOSED, CAMERA_IDLE_TIMEOUT_MS);
        }
    }

    /**
     * Open a {@link #CameraDevice camera device} and get the StaticMetadata for a given camera id.
     * The default mCameraListener is used to wait for states.
     *
     * @param cameraId The id of the camera device to be opened.
     */
    protected void openDevice(String cameraId) throws Exception {
        CameraTestInfo info = mCameraTestInfos.get(cameraId);
        assertTrue(""CameraTest info not found for camera id "" + cameraId, info != null);
        openDevice(cameraId, info.mCameraListener);
    }

    /**
     * Open a {@link #CameraDevice} and get the StaticMetadata for a given camera id and listener.
     *
     * @param cameraId The id of the camera device to be opened.
     * @param listener The {@link #BlockingStateCallback} used to wait for states.
     */
    protected void openDevice(String cameraId, BlockingStateCallback listener) throws Exception {
        CameraTestInfo info = mCameraTestInfos.get(cameraId);
        assertTrue(""CameraTest info not found for camera id "" + cameraId, info != null);

        info.mCamera = CameraTestUtils.openCamera(
                mCameraManager, cameraId, listener, mHandler);
        mCollector.setCameraId(cameraId);
        if (VERBOSE) {
            Log.v(TAG, ""Camera "" + cameraId + "" is opened"");
        }
    }

    /**
     * Create a {@link #CameraCaptureSession} using the currently open camera with
     * OutputConfigurations.
     *
     * @param outputSurfaces The set of output surfaces to configure for this session
     */
    protected void createSessionByConfigs(String cameraId,
            List<OutputConfiguration> outputConfigs) throws Exception {
        CameraTestInfo info = mCameraTestInfos.get(cameraId);
        assertTrue(""CameraTest info not found for camera id "" + cameraId, info != null);

        info.mCameraSessionListener = new BlockingSessionCallback();
        info.mCameraSession = CameraTestUtils.configureCameraSessionWithConfig(info.mCamera,
                outputConfigs, info.mCameraSessionListener, mHandler);
    }

    /**
     * Close a {@link #CameraDevice camera device} and clear the associated StaticInfo field for a
     * given camera id. The default mCameraListener is used to wait for states.
     * <p>
     * This function must be used along with the {@link #openDevice} for the
     * same camera id.
     * </p>
     *
     * @param cameraId The id of the {@link #CameraDevice camera device} to be closed.
     */
    protected void closeDevice(String cameraId) {
        CameraTestInfo info = mCameraTestInfos.get(cameraId);
        assertTrue(""CameraTest info not found for camera id "" + cameraId, info != null);
        closeDevice(cameraId, info.mCameraListener);
    }

    /**
     * Close a {@link #CameraDevice camera device} and clear the associated StaticInfo field for a
     * given camera id and listener.
     * <p>
     * This function must be used along with the {@link #openDevice} for the
     * same camera id.
     * </p>
     *
     * @param cameraId The id of the camera device to be closed.
     * @param listener The BlockingStateCallback used to wait for states.
     */
    protected void closeDevice(String cameraId, BlockingStateCallback listener) {
        CameraTestInfo info = mCameraTestInfos.get(cameraId);
        assertTrue(""CameraTest info not found for camera id "" + cameraId, info != null);

        if (info.mCamera != null) {
            info.mCamera.close();
            listener.waitForState(STATE_CLOSED, CAMERA_CLOSE_TIMEOUT_MS);
            info.mCamera = null;
            info.mCameraSession = null;
            info.mCameraSessionListener = null;
            if (VERBOSE) {
                Log.v(TAG, ""Camera "" + cameraId + "" is closed"");
            }
        }
    }

}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.server.wm.MultiDisplayActivityLaunchTests"	"supportsMultiDisplay"	"CtsWindowManagerDeviceTestCases"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplayActivityLaunchTests.java"	""	"/*
 *
 */

package android.server.wm;

import static android.app.WindowConfiguration.ACTIVITY_TYPE_ASSISTANT;
import static android.app.WindowConfiguration.ACTIVITY_TYPE_RECENTS;
import static android.app.WindowConfiguration.ACTIVITY_TYPE_STANDARD;
import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TASK;
import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TOP;
import static android.content.Intent.FLAG_ACTIVITY_MULTIPLE_TASK;
import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
import static android.content.Intent.FLAG_ACTIVITY_SINGLE_TOP;
import static android.server.wm.ActivityLauncher.KEY_ACTION;
import static android.server.wm.ActivityLauncher.KEY_LAUNCH_ACTIVITY;
import static android.server.wm.ActivityLauncher.KEY_LAUNCH_IMPLICIT;
import static android.server.wm.ActivityLauncher.KEY_LAUNCH_PENDING;
import static android.server.wm.ActivityLauncher.KEY_NEW_TASK;
import static android.server.wm.ActivityLauncher.KEY_USE_APPLICATION_CONTEXT;
import static android.server.wm.CliIntentExtra.extraBool;
import static android.server.wm.CliIntentExtra.extraString;
import static android.server.wm.ComponentNameUtils.getActivityName;
import static android.server.wm.UiDeviceUtils.pressHomeButton;
import static android.server.wm.WindowManagerState.STATE_DESTROYED;
import static android.server.wm.WindowManagerState.STATE_RESUMED;
import static android.server.wm.WindowManagerState.STATE_STOPPED;
import static android.server.wm.app.Components.ALT_LAUNCHING_ACTIVITY;
import static android.server.wm.app.Components.BROADCAST_RECEIVER_ACTIVITY;
import static android.server.wm.app.Components.LAUNCHING_ACTIVITY;
import static android.server.wm.app.Components.NON_RESIZEABLE_ACTIVITY;
import static android.server.wm.app.Components.NO_HISTORY_ACTIVITY;
import static android.server.wm.app.Components.NO_HISTORY_ACTIVITY2;
import static android.server.wm.app.Components.RESIZEABLE_ACTIVITY;
import static android.server.wm.app.Components.SHOW_WHEN_LOCKED_ACTIVITY;
import static android.server.wm.app.Components.SINGLE_TOP_ACTIVITY;
import static android.server.wm.app.Components.TEST_ACTIVITY;
import static android.server.wm.app.Components.TOP_ACTIVITY;
import static android.server.wm.app.Components.VIRTUAL_DISPLAY_ACTIVITY;
import static android.server.wm.second.Components.IMPLICIT_TARGET_SECOND_ACTIVITY;
import static android.server.wm.second.Components.IMPLICIT_TARGET_SECOND_TEST_ACTION;
import static android.server.wm.second.Components.SECOND_ACTIVITY;
import static android.server.wm.second.Components.SECOND_LAUNCH_BROADCAST_ACTION;
import static android.server.wm.second.Components.SECOND_LAUNCH_BROADCAST_RECEIVER;
import static android.server.wm.third.Components.THIRD_ACTIVITY;
import static android.view.Display.DEFAULT_DISPLAY;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assume.assumeTrue;

import android.app.Activity;
import android.app.ActivityOptions;
import android.app.PendingIntent;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.res.Configuration;
import android.hardware.display.DisplayManager;
import android.hardware.display.VirtualDisplay;
import android.os.Bundle;
import android.platform.test.annotations.Presubmit;
import android.server.wm.CommandSession.ActivitySession;
import android.server.wm.CommandSession.SizeInfo;
import android.server.wm.WindowManagerState.ActivityTask;
import android.server.wm.WindowManagerState.DisplayContent;
import android.view.SurfaceView;

import org.junit.Before;
import org.junit.Test;

/**
 * Build/Install/Run:
 *     atest CtsWindowManagerDeviceTestCases:MultiDisplayActivityLaunchTests
 *
 *  Tests activity launching behavior on multi-display environment.
 */
@Presubmit
@android.server.wm.annotation.Group3
public class MultiDisplayActivityLaunchTests extends MultiDisplayTestBase {

    @Before
    @Override
    public void setUp() throws Exception {
        super.setUp();
        assumeTrue(supportsMultiDisplay());
    }

    /**
     * Tests launching an activity on virtual display.
     */"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.server.wm.MultiDisplayActivityLaunchTests"	"testLaunchRecentActivityOnSecondaryDisplay"	"CtsWindowManagerDeviceTestCases"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplayActivityLaunchTests.java"	""	"public void testLaunchRecentActivityOnSecondaryDisplay() throws Exception {
        validateActivityLaunchOnNewDisplay(ACTIVITY_TYPE_RECENTS);
    }

    /**
     * Tests launching an assistant activity on virtual display.
     */"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.view.inputmethod.cts.util.EndToEndImeTestBase"	"TestName"	"CtsInputMethodTestCases"	"/home/gpoor/cts-12-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/util/EndToEndImeTestBase.java"	""	"public void test/*
 *.
 */

package android.view.inputmethod.cts.util;

import static org.junit.Assert.fail;
import static org.junit.Assume.assumeFalse;
import static org.junit.Assume.assumeTrue;

import android.content.Intent;
import android.content.pm.PackageManager;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.AppModeInstant;

import androidx.test.platform.app.InstrumentationRegistry;

import org.junit.Before;
import org.junit.Rule;
import org.junit.rules.TestName;

import java.lang.reflect.Method;

public class EndToEndImeTestBase {
    @Rule
    public TestName mTestName = new TestName();

    /**
     * Our own safeguard in case ""atest"" command is regressed and start running tests with
     * {@link AppModeInstant} even when {@code --instant} option is not specified.
     *
     * <p>Unfortunately this scenario had regressed at least 3 times.  That's why we also check
     * this in our side.  See Bug 158617529, Bug 187211725 and Bug 187222205 for examples.</p>
     */
    @Before
    public void verifyAppModeConsistency() {
        final Class<?> thisClass = this.getClass();
        final String testMethodName = mTestName.getMethodName();
        final String fullTestMethodName = thisClass.getSimpleName() + ""#"" + testMethodName;

        final Method testMethod;
        try {
            testMethod = thisClass.getMethod(testMethodName);
        } catch (NoSuchMethodException e) {
            throw new IllegalStateException(""Failed to find "" + fullTestMethodName, e);
        }

        final boolean hasAppModeFull = testMethod.getAnnotation(AppModeFull.class) != null;
        final boolean hasAppModeInstant = testMethod.getAnnotation(AppModeInstant.class) != null;

        if (hasAppModeFull && hasAppModeInstant) {
            fail(""Both @AppModeFull and @AppModeInstant are found in "" + fullTestMethodName
                    + "", which does not make sense. ""
                    + ""Remove both to make it clear that this test is app-mode agnostic, ""
                    + ""or specify one of them otherwise."");
        }

        // We want to explicitly check this condition in case tests are executed with atest
        // command.  See Bug 158617529 for details.
        if (hasAppModeFull) {
            assumeFalse(""This test should run under and only under the full app mode."",
                    InstrumentationRegistry.getInstrumentation().getTargetContext()
                            .getPackageManager().isInstantApp());
        }
        if (hasAppModeInstant) {
            assumeTrue(""This test should run under and only under the instant app mode."",
                    InstrumentationRegistry.getInstrumentation().getTargetContext()
                            .getPackageManager().isInstantApp());
        }
    }

    @Before
    public void showStateInitializeActivity() {
        // TODO(b/37502066): Move this back to @BeforeClass once b/37502066 is fixed.
        assumeTrue(""MockIme cannot be used for devices that do not support installable IMEs"",
                InstrumentationRegistry.getInstrumentation().getContext().getPackageManager()
                        .hasSystemFeature(PackageManager.FEATURE_INPUT_METHODS));

        final Intent intent = new Intent()
                .setAction(Intent.ACTION_MAIN)
                .setClass(InstrumentationRegistry.getInstrumentation().getTargetContext(),
                        StateInitializeActivity.class)
                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                .addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION)
                .addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);
        InstrumentationRegistry.getInstrumentation().startActivitySync(intent);
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.hardware.camera2.cts.testcases.Camera2AndroidTestRule"	"getCameraIdsUnderTest"	"CtsCameraTestCases"	"/home/gpoor/cts-12-source/cts/tests/camera/src/android/hardware/camera2/cts/testcases/Camera2AndroidTestRule.java"	""	"public void test/*
 *.
 */

package android.hardware.camera2.cts.testcases;

import static android.hardware.camera2.cts.CameraTestUtils.*;
import static com.android.ex.camera2.blocking.BlockingStateCallback.*;

import android.content.Context;
import android.graphics.Rect;

import android.hardware.camera2.cts.CameraTestUtils;
import android.hardware.camera2.CameraCaptureSession;
import android.hardware.camera2.CameraCaptureSession.CaptureCallback;
import android.hardware.camera2.CameraCharacteristics;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CameraManager;
import android.hardware.camera2.CaptureRequest;
import android.hardware.camera2.params.OutputConfiguration;
import android.hardware.camera2.params.SessionConfiguration;
import android.util.Size;
import android.hardware.camera2.cts.helpers.CameraErrorCollector;
import android.hardware.camera2.cts.helpers.StaticMetadata;
import android.hardware.camera2.cts.helpers.StaticMetadata.CheckLevel;
import android.media.Image;
import android.media.Image.Plane;
import android.media.ImageReader;
import android.os.Bundle;
import android.os.Handler;
import android.os.HandlerThread;
import android.util.Log;
import android.view.Surface;
import android.view.WindowManager;

import androidx.test.InstrumentationRegistry;

import com.android.ex.camera2.blocking.BlockingSessionCallback;
import com.android.ex.camera2.blocking.BlockingStateCallback;

import org.junit.rules.ExternalResource;

import java.io.File;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;

public class Camera2AndroidTestRule extends ExternalResource {
    private static final String TAG = ""Camera2AndroidBasicTestCase"";
    private static final boolean VERBOSE = Log.isLoggable(TAG, Log.VERBOSE);

    // Default capture size: VGA size is required by CDD.
    protected static final Size DEFAULT_CAPTURE_SIZE = new Size(640, 480);
    protected static final int CAPTURE_WAIT_TIMEOUT_MS = 5000;

    private CameraManager mCameraManager;
    private CameraDevice mCamera;
    private CameraCaptureSession mCameraSession;
    private BlockingSessionCallback mCameraSessionListener;
    private BlockingStateCallback mCameraListener;
    private String[] mCameraIdsUnderTest;
    // include both standalone camera IDs and ""hidden"" physical camera IDs
    private String[] mAllCameraIds;
    private HashMap<String, StaticMetadata> mAllStaticInfo;
    private ImageReader mReader;
    private Surface mReaderSurface;
    private Handler mHandler;
    private HandlerThread mHandlerThread;
    private StaticMetadata mStaticInfo;
    private CameraErrorCollector mCollector;
    private List<Size> mOrderedPreviewSizes; // In descending order.
    private List<Size> mOrderedVideoSizes; // In descending order.
    private List<Size> mOrderedStillSizes; // In descending order.
    private String mDebugFileNameBase;

    private WindowManager mWindowManager;
    private Context mContext;

    private static final String CAMERA_ID_INSTR_ARG_KEY = ""camera-id"";
    private static final String CAMERA_PERF_MEASURE = ""perf-measure"";
    private static final String CAMERA_PERF_CLASS_TEST = ""perf-class-test"";
    private static final Bundle mBundle = InstrumentationRegistry.getArguments();
    private static final String mOverrideCameraId = mBundle.getString(CAMERA_ID_INSTR_ARG_KEY);
    private static final String mPerfMeasure = mBundle.getString(CAMERA_PERF_MEASURE);
    private static final String mPerfClassTest = mBundle.getString(CAMERA_PERF_CLASS_TEST);

    public Camera2AndroidTestRule(Context context) {
        mContext = context;
    }

    public String getDebugFileNameBase() {
        return mDebugFileNameBase;
    }

    public Context getContext() {
        return mContext;
    }

    public String[] getCameraIdsUnderTest() {
        return mCameraIdsUnderTest;
    }

    public StaticMetadata getStaticInfo() {
        return mStaticInfo;
    }

    public CameraManager getCameraManager() {
        return mCameraManager;
    }

    public void setStaticInfo(StaticMetadata staticInfo) {
        mStaticInfo = staticInfo;
    }

    public CameraCaptureSession getCameraSession() {
        return mCameraSession;
    }

    public CameraDevice getCamera() {
        return mCamera;
    }

    public void setCamera(CameraDevice camera) {
        mCamera = camera;
    }

    public void setCameraSession(CameraCaptureSession session) {
        mCameraSession = session;
    }

    public BlockingStateCallback getCameraListener() {
        return mCameraListener;
    }

    public BlockingSessionCallback getCameraSessionListener() {
        return mCameraSessionListener;
    }

    public Handler getHandler() {
        return mHandler;
    }

    public void setCameraSessionListener(BlockingSessionCallback listener) {
        mCameraSessionListener = listener;
    }

    public ImageReader getReader() {
        return mReader;
    }

    public HashMap<String, StaticMetadata> getAllStaticInfo() {
        return mAllStaticInfo;
    }

    public List<Size> getOrderedPreviewSizes() {
        return mOrderedPreviewSizes;
    }

    public List<Size> getOrderedStillSizes() {
        return mOrderedStillSizes;
    }

    public Surface getReaderSurface() {
        return mReaderSurface;
    }

    public void setOrderedPreviewSizes(List<Size> sizes) {
        mOrderedPreviewSizes = sizes;
    }

    public WindowManager getWindowManager() {
        return mWindowManager;
    }

    public CameraErrorCollector getCollector() {
        return mCollector;
    }

    public boolean isPerfMeasure() {
        return mPerfMeasure != null && mPerfMeasure.equals(""on"");
    }

    public boolean isPerfClassTest() {
        return mPerfClassTest != null && mPerfClassTest.equals(""on"");
    }

    private String[] deriveCameraIdsUnderTest() throws Exception {
        String[] idsUnderTest = mCameraManager.getCameraIdList();
        assertNotNull(""Camera ids shouldn't be null"", idsUnderTest);
        if (mOverrideCameraId != null) {
            if (Arrays.asList(idsUnderTest).contains(mOverrideCameraId)) {
                idsUnderTest = new String[]{mOverrideCameraId};
            } else {
                idsUnderTest = new String[]{};
            }
        }

        return idsUnderTest;
    }

    /**
     * Set up the camera2 test case required environments, including CameraManager,
     * HandlerThread, Camera IDs, and CameraStateCallback etc.
     */
    @Override
    public void before() throws Exception {
        Log.v(TAG, ""Set up..."");
        mCameraManager = (CameraManager) mContext.getSystemService(Context.CAMERA_SERVICE);
        assertNotNull(""Can't connect to camera manager!"", mCameraManager);
        mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
        /**
         * Workaround for mockito and JB-MR2 incompatibility
         *
         * Avoid java.lang.IllegalArgumentException: dexcache == null
         * https://code.google.com/p/dexmaker/issues/detail?id=2
         */
        System.setProperty(""dexmaker.dexcache"", getContext().getCacheDir().toString());

        mCameraIdsUnderTest = deriveCameraIdsUnderTest();
        mHandlerThread = new HandlerThread(TAG);
        mHandlerThread.start();
        mHandler = new Handler(mHandlerThread.getLooper());
        mCameraListener = new BlockingStateCallback();
        mCollector = new CameraErrorCollector();

        File filesDir = mContext.getPackageManager().isInstantApp()
                ? mContext.getFilesDir()
                : mContext.getExternalFilesDir(null);

        mDebugFileNameBase = filesDir.getPath();

        mAllStaticInfo = new HashMap<String, StaticMetadata>();
        List<String> hiddenPhysicalIds = new ArrayList<>();
        for (String cameraId : mCameraIdsUnderTest) {
            CameraCharacteristics props = mCameraManager.getCameraCharacteristics(cameraId);
            StaticMetadata staticMetadata = new StaticMetadata(props,
                    CheckLevel.ASSERT, /*collector*/null);
            mAllStaticInfo.put(cameraId, staticMetadata);

            for (String physicalId : props.getPhysicalCameraIds()) {
                if (!Arrays.asList(mCameraIdsUnderTest).contains(physicalId) &&
                        !hiddenPhysicalIds.contains(physicalId)) {
                    hiddenPhysicalIds.add(physicalId);
                    props = mCameraManager.getCameraCharacteristics(physicalId);
                    staticMetadata = new StaticMetadata(
                            mCameraManager.getCameraCharacteristics(physicalId),
                            CheckLevel.ASSERT, /*collector*/null);
                    mAllStaticInfo.put(physicalId, staticMetadata);
                }
            }
        }
        mAllCameraIds = new String[mCameraIdsUnderTest.length + hiddenPhysicalIds.size()];
        System.arraycopy(mCameraIdsUnderTest, 0, mAllCameraIds, 0, mCameraIdsUnderTest.length);
        for (int i = 0; i < hiddenPhysicalIds.size(); i++) {
            mAllCameraIds[mCameraIdsUnderTest.length + i] = hiddenPhysicalIds.get(i);
        }
    }

    @Override
    public void after() {
        Log.v(TAG, ""Tear down..."");
        if (mCameraManager != null) {
            try {
                String[] cameraIdsPostTest = deriveCameraIdsUnderTest();
                Log.i(TAG, ""Camera ids in setup:"" + Arrays.toString(mCameraIdsUnderTest));
                Log.i(TAG, ""Camera ids in tearDown:"" + Arrays.toString(cameraIdsPostTest));
                assertTrue(
                        ""Number of cameras changed from "" + mCameraIdsUnderTest.length + "" to "" +
                                cameraIdsPostTest.length,
                        mCameraIdsUnderTest.length == cameraIdsPostTest.length);
                mHandlerThread.quitSafely();
                mHandler = null;
                closeDefaultImageReader();
                mCollector.verify();
            } catch (Throwable e) {
                // When new Exception(e) is used, exception info will be printed twice.
                throw new RuntimeException(e.getMessage());
            }
        }
    }

    /**
     * Start capture with given {@link #CaptureRequest}.
     *
     * @param request The {@link #CaptureRequest} to be captured.
     * @param repeating If the capture is single capture or repeating.
     * @param listener The {@link #CaptureCallback} camera device used to notify callbacks.
     * @param handler The handler camera device used to post callbacks.
     */
    public void startCapture(CaptureRequest request, boolean repeating,
            CaptureCallback listener, Handler handler) throws Exception {
        if (VERBOSE) Log.v(TAG, ""Starting capture from device"");

        if (repeating) {
            mCameraSession.setRepeatingRequest(request, listener, handler);
        } else {
            mCameraSession.capture(request, listener, handler);
        }
    }

    /**
     * Stop the current active capture.
     *
     * @param fast When it is true, {@link CameraDevice#flush} is called, the stop capture
     * could be faster.
     */
    public void stopCapture(boolean fast) throws Exception {
        if (VERBOSE) Log.v(TAG, ""Stopping capture"");

        if (fast) {
            /**
             * Flush is useful for canceling long exposure single capture, it also could help
             * to make the streaming capture stop sooner.
             */
            mCameraSession.abortCaptures();
            mCameraSessionListener.getStateWaiter().
                    waitForState(BlockingSessionCallback.SESSION_READY, CAMERA_IDLE_TIMEOUT_MS);
        } else {
            mCameraSession.close();
            mCameraSessionListener.getStateWaiter().
                    waitForState(BlockingSessionCallback.SESSION_CLOSED, CAMERA_IDLE_TIMEOUT_MS);
        }
    }

    /**
     * Open a {@link #CameraDevice camera device} and get the StaticMetadata for a given camera id.
     * The default mCameraListener is used to wait for states.
     *
     * @param cameraId The id of the camera device to be opened.
     */
    public void openDevice(String cameraId) throws Exception {
        openDevice(cameraId, mCameraListener);
    }

    /**
     * Open a {@link #CameraDevice} and get the StaticMetadata for a given camera id and listener.
     *
     * @param cameraId The id of the camera device to be opened.
     * @param listener The {@link #BlockingStateCallback} used to wait for states.
     */
    public void openDevice(String cameraId, BlockingStateCallback listener) throws Exception {
        mCamera = CameraTestUtils.openCamera(
                mCameraManager, cameraId, listener, mHandler);
        mCollector.setCameraId(cameraId);
        mStaticInfo = mAllStaticInfo.get(cameraId);
        if (mStaticInfo.isColorOutputSupported()) {
            mOrderedPreviewSizes = getSupportedPreviewSizes(
                    cameraId, mCameraManager,
                    getPreviewSizeBound(mWindowManager, PREVIEW_SIZE_BOUND));
            mOrderedVideoSizes = getSupportedVideoSizes(cameraId, mCameraManager, PREVIEW_SIZE_BOUND);
            mOrderedStillSizes = getSupportedStillSizes(cameraId, mCameraManager, null);
        }

        if (VERBOSE) {
            Log.v(TAG, ""Camera "" + cameraId + "" is opened"");
        }
    }

    /**
     * Create a {@link #CameraCaptureSession} using the currently open camera.
     *
     * @param outputSurfaces The set of output surfaces to configure for this session
     */
    public void createSession(List<Surface> outputSurfaces) throws Exception {
        mCameraSessionListener = new BlockingSessionCallback();
        mCameraSession = CameraTestUtils.configureCameraSession(mCamera, outputSurfaces,
                mCameraSessionListener, mHandler);
    }

    /**
     * Create a {@link #CameraCaptureSession} using the currently open camera with
     * OutputConfigurations.
     *
     * @param outputSurfaces The set of output surfaces to configure for this session
     */
    public void createSessionByConfigs(List<OutputConfiguration> outputConfigs) throws Exception {
        mCameraSessionListener = new BlockingSessionCallback();
        mCameraSession = CameraTestUtils.configureCameraSessionWithConfig(mCamera, outputConfigs,
                mCameraSessionListener, mHandler);
    }

    /**
     * Close a {@link #CameraDevice camera device} and clear the associated StaticInfo field for a
     * given camera id. The default mCameraListener is used to wait for states.
     * <p>
     * This function must be used along with the {@link #openDevice} for the
     * same camera id.
     * </p>
     *
     * @param cameraId The id of the {@link #CameraDevice camera device} to be closed.
     */
    public void closeDevice(String cameraId) {
        closeDevice(cameraId, mCameraListener);
    }

    /**
     * Close a {@link #CameraDevice camera device} and clear the associated StaticInfo field for a
     * given camera id and listener.
     * <p>
     * This function must be used along with the {@link #openDevice} for the
     * same camera id.
     * </p>
     *
     * @param cameraId The id of the camera device to be closed.
     * @param listener The BlockingStateCallback used to wait for states.
     */
    public void closeDevice(String cameraId, BlockingStateCallback listener) {
        if (mCamera != null) {
            if (!cameraId.equals(mCamera.getId())) {
                throw new IllegalStateException(""Try to close a device that is not opened yet"");
            }
            mCamera.close();
            listener.waitForState(STATE_CLOSED, CAMERA_CLOSE_TIMEOUT_MS);
            mCamera = null;
            mCameraSession = null;
            mCameraSessionListener = null;
            mStaticInfo = null;
            mOrderedPreviewSizes = null;
            mOrderedVideoSizes = null;
            mOrderedStillSizes = null;

            if (VERBOSE) {
                Log.v(TAG, ""Camera "" + cameraId + "" is closed"");
            }
        }
    }

    /**
     * Create an {@link ImageReader} object and get the surface.
     * <p>
     * This function creates {@link ImageReader} object and surface, then assign
     * to the default {@link mReader} and {@link mReaderSurface}. It closes the
     * current default active {@link ImageReader} if it exists.
     * </p>
     *
     * @param size The size of this ImageReader to be created.
     * @param format The format of this ImageReader to be created
     * @param maxNumImages The max number of images that can be acquired
     *            simultaneously.
     * @param listener The listener used by this ImageReader to notify
     *            callbacks.
     */
    public void createDefaultImageReader(Size size, int format, int maxNumImages,
            ImageReader.OnImageAvailableListener listener) throws Exception {
        closeDefaultImageReader();

        mReader = createImageReader(size, format, maxNumImages, listener);
        mReaderSurface = mReader.getSurface();
        if (VERBOSE) Log.v(TAG, ""Created ImageReader size "" + size.toString());
    }

    /**
     * Create an {@link ImageReader} object and get the surface.
     * <p>
     * This function creates {@link ImageReader} object and surface, then assign
     * to the default {@link mReader} and {@link mReaderSurface}. It closes the
     * current default active {@link ImageReader} if it exists.
     * </p>
     *
     * @param size The size of this ImageReader to be created.
     * @param format The format of this ImageReader to be created
     * @param maxNumImages The max number of images that can be acquired
     *            simultaneously.
     * @param usage The usage flag of the ImageReader
     * @param listener The listener used by this ImageReader to notify
     *            callbacks.
     */
    public void createDefaultImageReader(Size size, int format, int maxNumImages, long usage,
            ImageReader.OnImageAvailableListener listener) throws Exception {
        closeDefaultImageReader();

        mReader = createImageReader(size, format, maxNumImages, usage, listener);
        mReaderSurface = mReader.getSurface();
        if (VERBOSE) Log.v(TAG, ""Created ImageReader size "" + size.toString());
    }

    /**
     * Create an {@link ImageReader} object.
     *
     * <p>This function creates image reader object for given format, maxImages, and size.</p>
     *
     * @param size The size of this ImageReader to be created.
     * @param format The format of this ImageReader to be created
     * @param maxNumImages The max number of images that can be acquired simultaneously.
     * @param listener The listener used by this ImageReader to notify callbacks.
     */

    public ImageReader createImageReader(Size size, int format, int maxNumImages,
            ImageReader.OnImageAvailableListener listener) throws Exception {

        ImageReader reader = null;
        reader = ImageReader.newInstance(size.getWidth(), size.getHeight(),
                format, maxNumImages);

        reader.setOnImageAvailableListener(listener, mHandler);
        if (VERBOSE) Log.v(TAG, ""Created ImageReader size "" + size.toString());
        return reader;
    }

    /**
     * Create an {@link ImageReader} object.
     *
     * <p>This function creates image reader object for given format, maxImages, usage and size.</p>
     *
     * @param size The size of this ImageReader to be created.
     * @param format The format of this ImageReader to be created
     * @param maxNumImages The max number of images that can be acquired simultaneously.
     * @param usage The usage flag of the ImageReader
     * @param listener The listener used by this ImageReader to notify callbacks.
     */

    public ImageReader createImageReader(Size size, int format, int maxNumImages, long usage,
            ImageReader.OnImageAvailableListener listener) throws Exception {
        ImageReader reader = null;
        reader = ImageReader.newInstance(size.getWidth(), size.getHeight(),
                format, maxNumImages, usage);

        reader.setOnImageAvailableListener(listener, mHandler);
        if (VERBOSE) Log.v(TAG, ""Created ImageReader size "" + size.toString());
        return reader;
    }

    /**
     * Close the pending images then close current default {@link ImageReader} object.
     */
    public void closeDefaultImageReader() {
        closeImageReader(mReader);
        mReader = null;
        mReaderSurface = null;
    }

    /**
     * Close an image reader instance.
     *
     * @param reader
     */
    public void closeImageReader(ImageReader reader) {
        if (reader != null) {
            try {
                // Close all possible pending images first.
                Image image = reader.acquireLatestImage();
                if (image != null) {
                    image.close();
                }
            } finally {
                reader.close();
                reader = null;
            }
        }
    }

    public void checkImageReaderSessionConfiguration(String msg) throws Exception {
        List<OutputConfiguration> outputConfigs = new ArrayList<OutputConfiguration>();
        outputConfigs.add(new OutputConfiguration(mReaderSurface));

        checkSessionConfigurationSupported(mCamera, mHandler, outputConfigs, /*inputConfig*/ null,
                SessionConfiguration.SESSION_REGULAR, /*expectedResult*/ true, msg);
    }

    public CaptureRequest prepareCaptureRequest() throws Exception {
        return prepareCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
    }

    public CaptureRequest prepareCaptureRequest(int template) throws Exception {
        List<Surface> outputSurfaces = new ArrayList<Surface>();
        Surface surface = mReader.getSurface();
        assertNotNull(""Fail to get surface from ImageReader"", surface);
        outputSurfaces.add(surface);
        return prepareCaptureRequestForSurfaces(outputSurfaces, template)
                .build();
    }

    public CaptureRequest.Builder prepareCaptureRequestForSurfaces(List<Surface> surfaces,
            int template)
            throws Exception {
        createSession(surfaces);

        CaptureRequest.Builder captureBuilder =
                mCamera.createCaptureRequest(template);
        assertNotNull(""Fail to get captureRequest"", captureBuilder);
        for (Surface surface : surfaces) {
            captureBuilder.addTarget(surface);
        }

        return captureBuilder;
    }

    public CaptureRequest.Builder prepareCaptureRequestForConfigs(
            List<OutputConfiguration> outputConfigs, int template) throws Exception {
        createSessionByConfigs(outputConfigs);

        CaptureRequest.Builder captureBuilder =
                mCamera.createCaptureRequest(template);
        assertNotNull(""Fail to get captureRequest"", captureBuilder);
        for (OutputConfiguration config : outputConfigs) {
            for (Surface s : config.getSurfaces()) {
                captureBuilder.addTarget(s);
            }
        }

        return captureBuilder;
    }

    /**
     * Test the invalid Image access: accessing a closed image must result in
     * {@link IllegalStateException}.
     *
     * @param closedImage The closed image.
     * @param closedBuffer The ByteBuffer from a closed Image. buffer invalid
     *            access will be skipped if it is null.
     */
    public void imageInvalidAccessTestAfterClose(Image closedImage,
            Plane closedPlane, ByteBuffer closedBuffer) {
        if (closedImage == null) {
            throw new IllegalArgumentException("" closedImage must be non-null"");
        }
        if (closedBuffer != null && !closedBuffer.isDirect()) {
            throw new IllegalArgumentException(""The input ByteBuffer should be direct ByteBuffer"");
        }

        if (closedPlane != null) {
            // Plane#getBuffer test
            try {
                closedPlane.getBuffer(); // An ISE should be thrown here.
                fail(""Image should throw IllegalStateException when calling getBuffer""
                        + "" after the image is closed"");
            } catch (IllegalStateException e) {
                // Expected.
            }

            // Plane#getPixelStride test
            try {
                closedPlane.getPixelStride(); // An ISE should be thrown here.
                fail(""Image should throw IllegalStateException when calling getPixelStride""
                        + "" after the image is closed"");
            } catch (IllegalStateException e) {
                // Expected.
            }

            // Plane#getRowStride test
            try {
                closedPlane.getRowStride(); // An ISE should be thrown here.
                fail(""Image should throw IllegalStateException when calling getRowStride""
                        + "" after the image is closed"");
            } catch (IllegalStateException e) {
                // Expected.
            }
        }

        // ByteBuffer access test
        if (closedBuffer != null) {
            try {
                closedBuffer.get(); // An ISE should be thrown here.
                fail(""Image should throw IllegalStateException when accessing a byte buffer""
                        + "" after the image is closed"");
            } catch (IllegalStateException e) {
                // Expected.
            }
        }

        // Image#getFormat test
        try {
            closedImage.getFormat();
            fail(""Image should throw IllegalStateException when calling getFormat""
                    + "" after the image is closed"");
        } catch (IllegalStateException e) {
            // Expected.
        }

        // Image#getWidth test
        try {
            closedImage.getWidth();
            fail(""Image should throw IllegalStateException when calling getWidth""
                    + "" after the image is closed"");
        } catch (IllegalStateException e) {
            // Expected.
        }

        // Image#getHeight test
        try {
            closedImage.getHeight();
            fail(""Image should throw IllegalStateException when calling getHeight""
                    + "" after the image is closed"");
        } catch (IllegalStateException e) {
            // Expected.
        }

        // Image#getTimestamp test
        try {
            closedImage.getTimestamp();
            fail(""Image should throw IllegalStateException when calling getTimestamp""
                    + "" after the image is closed"");
        } catch (IllegalStateException e) {
            // Expected.
        }

        // Image#getTimestamp test
        try {
            closedImage.getTimestamp();
            fail(""Image should throw IllegalStateException when calling getTimestamp""
                    + "" after the image is closed"");
        } catch (IllegalStateException e) {
            // Expected.
        }

        // Image#getCropRect test
        try {
            closedImage.getCropRect();
            fail(""Image should throw IllegalStateException when calling getCropRect""
                    + "" after the image is closed"");
        } catch (IllegalStateException e) {
            // Expected.
        }

        // Image#setCropRect test
        try {
            Rect rect = new Rect();
            closedImage.setCropRect(rect);
            fail(""Image should throw IllegalStateException when calling setCropRect""
                    + "" after the image is closed"");
        } catch (IllegalStateException e) {
            // Expected.
        }

        // Image#getPlanes test
        try {
            closedImage.getPlanes();
            fail(""Image should throw IllegalStateException when calling getPlanes""
                    + "" after the image is closed"");
        } catch (IllegalStateException e) {
            // Expected.
        }
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.accessibilityservice.cts.utils.ActivityLaunchUtils"	"adoptShellPermissionIdentity"	"CtsAccessibilityServiceTestCases"	"/home/gpoor/cts-12-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/utils/ActivityLaunchUtils.java"	""	"public void test/**
 *.
 */

package android.accessibilityservice.cts.utils;

import static android.accessibility.cts.common.ShellCommandBuilder.execShellCommand;
import static android.accessibilityservice.cts.utils.AsyncUtils.DEFAULT_TIMEOUT_MS;
import static android.content.pm.PackageManager.FEATURE_ACTIVITIES_ON_SECONDARY_DISPLAYS;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.fail;

import android.accessibilityservice.AccessibilityServiceInfo;
import android.app.Activity;
import android.app.ActivityOptions;
import android.app.Instrumentation;
import android.app.UiAutomation;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.graphics.Rect;
import android.os.PowerManager;
import android.os.SystemClock;
import android.text.TextUtils;
import android.util.Log;
import android.util.SparseArray;
import android.view.Display;
import android.view.InputDevice;
import android.view.KeyCharacterMap;
import android.view.KeyEvent;
import android.view.accessibility.AccessibilityEvent;
import android.view.accessibility.AccessibilityNodeInfo;
import android.view.accessibility.AccessibilityWindowInfo;

import androidx.test.rule.ActivityTestRule;

import com.android.compatibility.common.util.TestUtils;

import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.TimeoutException;
import java.util.function.BooleanSupplier;
import java.util.stream.Collectors;

/**
 * Utilities useful when launching an activity to make sure it's all the way on the screen
 * before we start testing it.
 */
public class ActivityLaunchUtils {
    private static final String LOG_TAG = ""ActivityLaunchUtils"";
    private static final String AM_START_HOME_ACTIVITY_COMMAND =
            ""am start -a android.intent.action.MAIN -c android.intent.category.HOME"";
    public static final String AM_BROADCAST_CLOSE_SYSTEM_DIALOG_COMMAND =
            ""am broadcast -a android.intent.action.CLOSE_SYSTEM_DIALOGS"";

    // Using a static variable so it can be used in lambdas. Not preserving state in it.
    private static Activity mTempActivity;

    public static <T extends Activity> T launchActivityAndWaitForItToBeOnscreen(
            Instrumentation instrumentation, UiAutomation uiAutomation,
            ActivityTestRule<T> rule) throws Exception {
        ActivityLauncher activityLauncher = new ActivityLauncher() {
            @Override
            Activity launchActivity() {
                return rule.launchActivity(null);
            }
        };
        return launchActivityOnSpecifiedDisplayAndWaitForItToBeOnscreen(instrumentation,
                uiAutomation, activityLauncher, Display.DEFAULT_DISPLAY);
    }

    /**
     * If this activity would be launched at virtual display, please finishes this activity before
     * this test ended. Otherwise it will be displayed on default display and impacts the next test.
     */
    public static <T extends Activity> T launchActivityOnSpecifiedDisplayAndWaitForItToBeOnscreen(
            Instrumentation instrumentation, UiAutomation uiAutomation, Class<T> clazz,
            int displayId) throws Exception {
        final ActivityOptions options = ActivityOptions.makeBasic();
        options.setLaunchDisplayId(displayId);
        final Intent intent = new Intent(instrumentation.getTargetContext(), clazz);
        // Add clear task because this activity may on other display.
        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK|Intent.FLAG_ACTIVITY_NEW_TASK);

        ActivityLauncher activityLauncher = new ActivityLauncher() {
            @Override
            Activity launchActivity() {
                uiAutomation.adoptShellPermissionIdentity();
                try {
                    return instrumentation.startActivitySync(intent, options.toBundle());
                } finally {
                    uiAutomation.dropShellPermissionIdentity();
                }
            }
        };
        return launchActivityOnSpecifiedDisplayAndWaitForItToBeOnscreen(instrumentation,
                uiAutomation, activityLauncher, displayId);
    }

    public static CharSequence getActivityTitle(
            Instrumentation instrumentation, Activity activity) {
        final StringBuilder titleBuilder = new StringBuilder();
        instrumentation.runOnMainSync(() -> titleBuilder.append(activity.getTitle()));
        return titleBuilder;
    }

    public static AccessibilityWindowInfo findWindowByTitle(
            UiAutomation uiAutomation, CharSequence title) {
        final List<AccessibilityWindowInfo> windows = uiAutomation.getWindows();
        return findWindowByTitleWithList(title, windows);
    }

    public static AccessibilityWindowInfo findWindowByTitleAndDisplay(
            UiAutomation uiAutomation, CharSequence title, int displayId) {
        final SparseArray<List<AccessibilityWindowInfo>> allWindows =
                uiAutomation.getWindowsOnAllDisplays();
        final List<AccessibilityWindowInfo> windowsOfDisplay = allWindows.get(displayId);
        return findWindowByTitleWithList(title, windowsOfDisplay);
    }

    public static void homeScreenOrBust(Context context, UiAutomation uiAutomation) {
        wakeUpOrBust(context, uiAutomation);
        if (context.getPackageManager().isInstantApp()) return;
        if (isHomeScreenShowing(context, uiAutomation)) return;
        try {
            executeAndWaitOn(
                    uiAutomation,
                    () -> {
                        execShellCommand(uiAutomation, AM_START_HOME_ACTIVITY_COMMAND);
                        execShellCommand(uiAutomation, AM_BROADCAST_CLOSE_SYSTEM_DIALOG_COMMAND);
                    },
                    () -> isHomeScreenShowing(context, uiAutomation),
                    DEFAULT_TIMEOUT_MS,
                    ""home screen"");
        } catch (AssertionError error) {
            Log.e(LOG_TAG, ""Timed out looking for home screen. Dumping window list"");
            final List<AccessibilityWindowInfo> windows = uiAutomation.getWindows();
            if (windows == null) {
                Log.e(LOG_TAG, ""Window list is null"");
            } else if (windows.isEmpty()) {
                Log.e(LOG_TAG, ""Window list is empty"");
            } else {
                for (AccessibilityWindowInfo window : windows) {
                    Log.e(LOG_TAG, window.toString());
                }
            }

            fail(""Unable to reach home screen"");
        }
    }

    public static boolean supportsMultiDisplay(Context context) {
        return context.getPackageManager().hasSystemFeature(
                FEATURE_ACTIVITIES_ON_SECONDARY_DISPLAYS);
    }

    private static boolean isHomeScreenShowing(Context context, UiAutomation uiAutomation) {
        final List<AccessibilityWindowInfo> windows = uiAutomation.getWindows();
        final PackageManager packageManager = context.getPackageManager();
        final List<ResolveInfo> resolveInfos = packageManager.queryIntentActivities(
                new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME),
                PackageManager.MATCH_DEFAULT_ONLY);

        // Look for a window with a package name that matches the default home screen
        for (AccessibilityWindowInfo window : windows) {
            final AccessibilityNodeInfo root = window.getRoot();
            if (root != null) {
                final CharSequence packageName = root.getPackageName();
                if (packageName != null) {
                    for (ResolveInfo resolveInfo : resolveInfos) {
                        if ((resolveInfo.activityInfo != null)
                                && packageName.equals(resolveInfo.activityInfo.packageName)) {
                            return true;
                        }
                    }
                }
            }
        }
        // List unexpected package names of default home screen that invoking ResolverActivity
        final CharSequence homePackageNames = resolveInfos.stream()
                .map(r -> r.activityInfo).filter(Objects::nonNull)
                .map(a -> a.packageName).collect(Collectors.joining("", ""));
        Log.v(LOG_TAG, ""No window matched with package names of home screen: "" + homePackageNames);
        return false;
    }

    private static void wakeUpOrBust(Context context, UiAutomation uiAutomation) {
        final long deadlineUptimeMillis = SystemClock.uptimeMillis() + DEFAULT_TIMEOUT_MS;
        final PowerManager powerManager = context.getSystemService(PowerManager.class);
        do {
            if (powerManager.isInteractive()) {
                Log.d(LOG_TAG, ""Device is interactive"");
                return;
            }

            Log.d(LOG_TAG, ""Sending wakeup keycode"");
            final long eventTime = SystemClock.uptimeMillis();
            uiAutomation.injectInputEvent(
                    new KeyEvent(eventTime, eventTime, KeyEvent.ACTION_DOWN,
                            KeyEvent.KEYCODE_WAKEUP, 0 /* repeat */, 0 /* metastate */,
                            KeyCharacterMap.VIRTUAL_KEYBOARD, 0 /* scancode */, 0 /* flags */,
                            InputDevice.SOURCE_KEYBOARD), true /* sync */);
            uiAutomation.injectInputEvent(
                    new KeyEvent(eventTime, eventTime, KeyEvent.ACTION_UP,
                            KeyEvent.KEYCODE_WAKEUP, 0 /* repeat */, 0 /* metastate */,
                            KeyCharacterMap.VIRTUAL_KEYBOARD, 0 /* scancode */, 0 /* flags */,
                            InputDevice.SOURCE_KEYBOARD), true /* sync */);
            try {
                Thread.sleep(50);
            } catch (InterruptedException e) {}
        } while (SystemClock.uptimeMillis() < deadlineUptimeMillis);
        fail(""Unable to wake up screen"");
    }

    /**
     * Executes a command and waits for a specified condition up to a given wait timeout. It checks
     * condition result each time when events delivered, and throws exception if the condition
     * result is not {@code true} within the given timeout.
     */
    private static void executeAndWaitOn(UiAutomation uiAutomation, Runnable command,
            BooleanSupplier condition, long timeoutMillis, String conditionName) {
        final Object waitObject = new Object();
        final long executionStartTimeMillis = SystemClock.uptimeMillis();
        try {
            uiAutomation.setOnAccessibilityEventListener((event) -> {
                if (event.getEventTime() < executionStartTimeMillis) {
                    return;
                }
                synchronized (waitObject) {
                    waitObject.notifyAll();
                }
            });
            command.run();
            TestUtils.waitOn(waitObject, condition, timeoutMillis, conditionName);
        } finally {
            uiAutomation.setOnAccessibilityEventListener(null);
        }
    }

    private static <T extends Activity> T launchActivityOnSpecifiedDisplayAndWaitForItToBeOnscreen(
            Instrumentation instrumentation, UiAutomation uiAutomation,
            ActivityLauncher activityLauncher, int displayId) throws Exception {
        final int[] location = new int[2];
        final StringBuilder activityPackage = new StringBuilder();
        final Rect bounds = new Rect();
        final StringBuilder activityTitle = new StringBuilder();
        final StringBuilder timeoutExceptionRecords = new StringBuilder();
        // Make sure we get window events, so we'll know when the window appears
        AccessibilityServiceInfo info = uiAutomation.getServiceInfo();
        info.flags |= AccessibilityServiceInfo.FLAG_RETRIEVE_INTERACTIVE_WINDOWS;
        uiAutomation.setServiceInfo(info);
        // There is no any window on virtual display even doing GLOBAL_ACTION_HOME, so only
        // checking the home screen for default display.
        if (displayId == Display.DEFAULT_DISPLAY) {
            homeScreenOrBust(instrumentation.getContext(), uiAutomation);
        }

        try {
            final AccessibilityEvent awaitedEvent = uiAutomation.executeAndWaitForEvent(
                    () -> {
                        mTempActivity = activityLauncher.launchActivity();
                        instrumentation.runOnMainSync(() -> {
                            mTempActivity.getWindow().getDecorView().getLocationOnScreen(location);
                            activityPackage.append(mTempActivity.getPackageName());
                        });
                        instrumentation.waitForIdleSync();
                        activityTitle.append(getActivityTitle(instrumentation, mTempActivity));
                    },
                    (event) -> {
                        final AccessibilityWindowInfo window =
                                findWindowByTitleAndDisplay(uiAutomation, activityTitle, displayId);
                        if (window == null) return false;
                        if (window.getRoot() == null) return false;

                        window.getBoundsInScreen(bounds);
                        mTempActivity.getWindow().getDecorView().getLocationOnScreen(location);

                        // Stores the related information including event, location and window
                        // as a timeout exception record.
                        timeoutExceptionRecords.append(String.format(""{Received event: %s \n""
                                + ""Window location: %s \nA11y window: %s}\n"",
                                event, Arrays.toString(location), window));

                        return (!bounds.isEmpty())
                                && (bounds.left == location[0]) && (bounds.top == location[1]);
                    }, DEFAULT_TIMEOUT_MS);
            assertNotNull(awaitedEvent);
        } catch (TimeoutException timeout) {
            throw new TimeoutException(timeout.getMessage() + ""\n\nTimeout exception records : \n""
                    + timeoutExceptionRecords);
        }
        return (T) mTempActivity;
    }

    private static AccessibilityWindowInfo findWindowByTitleWithList(CharSequence title,
            List<AccessibilityWindowInfo> windows) {
        AccessibilityWindowInfo returnValue = null;
        if (windows != null && windows.size() > 0) {
            for (int i = 0; i < windows.size(); i++) {
                final AccessibilityWindowInfo window = windows.get(i);
                if (TextUtils.equals(title, window.getTitle())) {
                    returnValue = window;
                } else {
                    window.recycle();
                }
            }
        }
        return returnValue;
    }

    private static abstract class ActivityLauncher {
        abstract Activity launchActivity();
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.provider.cts.SearchRecentSuggestionsTest"	"SearchRecentSuggestionsTest"	"CtsProviderTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/SearchRecentSuggestionsTest.java"	""	"public void test/*
 *.
 */

package android.provider.cts;

import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.net.Uri;
import android.provider.SearchRecentSuggestions;
import android.test.ProviderTestCase2;

import com.android.compatibility.common.util.PollingCheck;

public class SearchRecentSuggestionsTest extends
        ProviderTestCase2<TestSearchRecentSuggestionsProvider> {
    private final static String AUTHORITY_HEAD = ""content://""
            + TestSearchRecentSuggestionsProvider.AUTHORITY;

    private Uri mTestUri;
    private TestSearchRecentSuggestionsProvider mTestSRSProvider;
    private Context mProviderContext;

    @Override
    public void setUp() throws Exception {
        super.setUp();
        mTestUri = Uri.parse(AUTHORITY_HEAD + ""/suggestions"");
        mTestSRSProvider = getProvider();
        mProviderContext = mTestSRSProvider.getContext();
    }

    public SearchRecentSuggestionsTest() {
        super(TestSearchRecentSuggestionsProvider.class,
                TestSearchRecentSuggestionsProvider.AUTHORITY);
    }"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.provider.cts.SearchRecentSuggestionsTest"	"testConstructor"	"CtsProviderTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/SearchRecentSuggestionsTest.java"	""	"public void testConstructor() {
        new SearchRecentSuggestions(mProviderContext, TestSearchRecentSuggestionsProvider.AUTHORITY,
                TestSearchRecentSuggestionsProvider.MODE);
    }"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.provider.cts.SearchRecentSuggestionsTest"	"testSearchRecentSuggestions"	"CtsProviderTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/SearchRecentSuggestionsTest.java"	""	"public void testSearchRecentSuggestions() {
        SearchRecentSuggestions srs = new MySearchRecentSuggestions(mProviderContext,
                TestSearchRecentSuggestionsProvider.AUTHORITY,
                TestSearchRecentSuggestionsProvider.MODE);
        Cursor c = mTestSRSProvider.query(mTestUri, null, null, null, null);

        try {
            assertNotNull(c);
            assertEquals(0, c.getCount());
            c.close();

            // insert three rows
            String query1 = ""query1"";
            String line1 = ""line1"";
            srs.saveRecentQuery(query1, line1);

            waitForCursorCount(mTestUri, SearchRecentSuggestions.QUERIES_PROJECTION_2LINE, 1);

            c = mTestSRSProvider.query(mTestUri, SearchRecentSuggestions.QUERIES_PROJECTION_2LINE,
                    null, null, null);
            c.moveToFirst();
            assertEquals(query1, c
                    .getString(SearchRecentSuggestions.QUERIES_PROJECTION_QUERY_INDEX));
            assertEquals(line1, c
                    .getString(SearchRecentSuggestions.QUERIES_PROJECTION_DISPLAY2_INDEX));
            c.close();

            String query2 = ""query2"";
            String line2 = ""line2"";
            srs.saveRecentQuery(query2, line2);
            waitForCursorCount(mTestUri, null, 2);

            String query3 = ""query3"";
            String line3 = ""line3"";
            srs.saveRecentQuery(query3, line3);
            waitForCursorCount(mTestUri, null, 3);

            // truncateHistory will delete the oldest one record
            ContentResolver cr = mProviderContext.getContentResolver();
            ((MySearchRecentSuggestions) srs).truncateHistory(cr, 2);

            waitForCursorCount(mTestUri, SearchRecentSuggestions.QUERIES_PROJECTION_2LINE, 2);

            c = mTestSRSProvider.query(mTestUri, SearchRecentSuggestions.QUERIES_PROJECTION_2LINE,
                    null, null, null);

            // and the left two should be: test2 and test3, test1 should be delete
            c.moveToFirst();
            assertEquals(query2, c
                    .getString(SearchRecentSuggestions.QUERIES_PROJECTION_QUERY_INDEX));
            assertEquals(line2, c
                    .getString(SearchRecentSuggestions.QUERIES_PROJECTION_DISPLAY2_INDEX));
            c.moveToNext();
            assertEquals(query3, c
                    .getString(SearchRecentSuggestions.QUERIES_PROJECTION_QUERY_INDEX));
            assertEquals(line3, c
                    .getString(SearchRecentSuggestions.QUERIES_PROJECTION_DISPLAY2_INDEX));
            c.close();

            // clear all history
            srs.clearHistory();
            waitForCursorCount(mTestUri, null, 0);
        } finally {
            c.close();
        }
    }"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.provider.cts.SearchRecentSuggestionsTest"	"testSuggestionsTable"	"CtsProviderTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/SearchRecentSuggestionsTest.java"	""	"public void testSuggestionsTable() {
        String insertDisplay1 = ""display1_insert"";
        String insertDisplay2 = ""display2_insert"";
        String insertQuery = ""query_insert"";

        String updateDisplay1 = ""display1_update"";
        String updateDisplay2 = ""display2_update"";
        String updateQuery = ""query_update"";

        // Test: insert
        ContentValues value = new ContentValues();
        value.put(""display1"", insertDisplay1);
        value.put(""display2"", insertDisplay2);
        value.put(""query"", insertQuery);
        value.put(""date"", 1);

        mTestSRSProvider.insert(mTestUri, value);

        Cursor cursor = mTestSRSProvider.query(mTestUri,
                SearchRecentSuggestions.QUERIES_PROJECTION_2LINE,
                ""display1=\"""" + insertDisplay1 + ""\"""", null, null);
        try {
            assertNotNull(cursor);
            assertEquals(1, cursor.getCount());
            assertTrue(cursor.moveToFirst());
            assertEquals(insertDisplay2, cursor
                    .getString(SearchRecentSuggestions.QUERIES_PROJECTION_DISPLAY2_INDEX));
            assertEquals(insertQuery, cursor
                    .getString(SearchRecentSuggestions.QUERIES_PROJECTION_QUERY_INDEX));
            assertEquals(1, cursor.getInt(SearchRecentSuggestions.QUERIES_PROJECTION_DATE_INDEX));
            cursor.close();

            // Test: update
            /**
             * SearchRecentSuggestionsProvider.update is not implement, always
             * throw an UnsupportedOperationException.
             */
            value.clear();
            value.put(""display1"", updateDisplay1);
            value.put(""display2"", updateDisplay2);
            value.put(""query"", updateQuery);
            value.put(""date"", 2);

            try {
                mTestSRSProvider.update(mTestUri, value, ""display1=\"""" + insertDisplay1 + ""\"""",
                        null);
                fail(""There should be an UnsupportedOperationException thrown out."");
            } catch (UnsupportedOperationException e) {
                // expected, test success.
            }

            // Test: delete
            mTestSRSProvider.delete(mTestUri, ""display1=\"""" + insertDisplay1 + ""\"""", null);
            cursor = mTestSRSProvider.query(mTestUri,
                    SearchRecentSuggestions.QUERIES_PROJECTION_2LINE, ""display1=\""""
                            + insertDisplay1 + ""\"""", null, null);
            assertNotNull(cursor);
            assertEquals(0, cursor.getCount());
        } finally {
            cursor.close();
        }
    }

    private class MySearchRecentSuggestions extends SearchRecentSuggestions {
        public MySearchRecentSuggestions(Context context, String authority, int mode) {
            super(context, authority, mode);
        }

        @Override
        protected void truncateHistory(ContentResolver cr, int maxEntries) {
            super.truncateHistory(cr, maxEntries);
        }
    }

    private void waitForCursorCount(final Uri uri, final String[] projection,
            final int expectedCount) {
        new PollingCheck() {
            @Override
            protected boolean check() {
                Cursor cursor = null;
                try {
                    cursor = mTestSRSProvider.query(uri, projection, null, null, null);
                    return cursor != null && cursor.getCount() == expectedCount;
                } finally {
                    if (cursor != null) {
                        cursor.close();
                    }
                }
            }
        }.run();
    }
}"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.device.ScopedStorageBaseDeviceTest"	"isNotNull"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageBaseDeviceTest.java"	""	"public void test/*
 *.
 */

package android.scopedstorage.cts.device;

import static android.scopedstorage.cts.lib.TestUtils.getExternalFilesDir;
import static android.scopedstorage.cts.lib.TestUtils.pollForExternalStorageState;
import static android.scopedstorage.cts.lib.TestUtils.resetDefaultExternalStorageVolume;
import static android.scopedstorage.cts.lib.TestUtils.setExternalStorageVolume;
import static android.scopedstorage.cts.lib.TestUtils.setupDefaultDirectories;

import static androidx.test.InstrumentationRegistry.getContext;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import android.provider.MediaStore;
import android.scopedstorage.cts.lib.TestUtils;

import org.junit.BeforeClass;

import java.util.Arrays;
import java.util.List;

class ScopedStorageBaseDeviceTest {
    private static final String VOLUME_PUBLIC = ""volume_public"";

    @BeforeClass
    public static void setup() throws Exception {
        createPublicVolume();
        setupStorage();
    }

    private static void createPublicVolume() throws Exception {
        if (TestUtils.getCurrentPublicVolumeName() == null) {
            TestUtils.createNewPublicVolume();
            assertWithMessage(""Expected newly created public volume name to be not null"")
                    .that(TestUtils.getCurrentPublicVolumeName())
                    .isNotNull();
        }
    }
    private static void setupStorage() throws Exception {
        if (!getContext().getPackageManager().isInstantApp()) {
            pollForExternalStorageState();
            getExternalFilesDir().mkdirs();
        }
    }

    void setupExternalStorage(String volumeName) {
        assertThat(volumeName).isNotNull();
        if (volumeName.equals(MediaStore.VOLUME_EXTERNAL)) {
            resetDefaultExternalStorageVolume();
            TestUtils.assertDefaultVolumeIsPrimary();
        } else {
            final String publicVolumeName = TestUtils.getCurrentPublicVolumeName();
            assertWithMessage(""Expected public volume name to be not null"")
                    .that(publicVolumeName)
                    .isNotNull();
            setExternalStorageVolume(publicVolumeName);
            TestUtils.assertDefaultVolumeIsPublic();
        }
        setupDefaultDirectories();
    }

    static List<String> getTestParameters() {
        return Arrays.asList(
                MediaStore.VOLUME_EXTERNAL,
                VOLUME_PUBLIC
        );
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.ephemeralapp1.EphemeralActivity"	"finish"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/EphemeralApp1/src/com/android/cts/ephemeralapp1/EphemeralActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.ephemeralapp1;

import android.app.Activity;
import android.app.SearchManager;
import android.content.Intent;
import android.content.pm.PackageInfo;
import android.content.pm.ResolveInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.net.Uri;
import android.os.Bundle;
import android.provider.SearchRecentSuggestions;
import android.util.Log;

import com.android.cts.util.TestResult;

import java.util.List;

public class EphemeralActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        final Intent intent  = getIntent();
        if (Intent.ACTION_SEARCH.equals(intent.getAction())) {
            final String query = intent.getStringExtra(SearchManager.QUERY);
            final SearchRecentSuggestions suggestions = new SearchRecentSuggestions(this,
                    SearchSuggestionProvider.AUTHORITY, SearchSuggestionProvider.MODE);
            suggestions.saveRecentQuery(query, null);
        }

        TestResult.getBuilder()
                .setPackageName(""com.android.cts.ephemeralapp1"")
                .setComponentName(""EphemeralActivity"")
                .setIntent(getIntent())
                .setStatus(""PASS"")
                .build()
                .broadcast(this);
        finish();
    }
}"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.InstantAppUserTest"	"uninstallTestPackages"	"CtsAppSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/InstantAppUserTest.java"	""	"/*
 *
 */

package android.appsecurity.cts;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;

import android.platform.test.annotations.AppModeFull;

import com.android.compatibility.common.tradefed.build.CompatibilityBuildHelper;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;
import com.android.tradefed.testtype.junit4.BaseHostJUnit4Test;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Tests for ephemeral packages.
 */
@RunWith(DeviceJUnit4ClassRunner.class)
@AppModeFull(reason = ""Already handles instant installs when needed"")
public class InstantAppUserTest extends BaseHostJUnit4Test {

    // a normally installed application
    private static final String NORMAL_APK = ""CtsEphemeralTestsNormalApp.apk"";
    private static final String NORMAL_PKG = ""com.android.cts.normalapp"";

    // a normally installed application with implicitly exposed components
    private static final String IMPLICIT_APK = ""CtsEphemeralTestsImplicitApp.apk"";
    private static final String IMPLICIT_PKG = ""com.android.cts.implicitapp"";

    // the first ephemerally installed application
    private static final String EPHEMERAL_1_APK = ""CtsEphemeralTestsEphemeralApp1.apk"";
    private static final String EPHEMERAL_1_PKG = ""com.android.cts.ephemeralapp1"";

    // an application to verify instant/full app per user
    private static final String USER_APK = ""CtsEphemeralTestsUserApp.apk"";
    private static final String USER_PKG = ""com.android.cts.userapp"";

    private static final String USER_TEST_APK = ""CtsEphemeralTestsUserAppTest.apk"";
    private static final String USER_TEST_PKG = ""com.android.cts.userapptest"";

    private static final String TEST_CLASS = "".ClientTest"";

    private boolean mSupportsMultiUser;
    private int mPrimaryUserId;
    private int mSecondaryUserId;
    private int mStartingUserId;

    @Before
    public void setUp() throws Exception {
        // This test only runs when we have at least 2 users to work with
        final int[] users = Utils.prepareMultipleUsers(getDevice(), 2);
        mSupportsMultiUser = (users.length == 2);
        if (!mSupportsMultiUser) {
            return;
        }
        mPrimaryUserId = getDevice().getPrimaryUserId();
        mStartingUserId = getDevice().getCurrentUser();
        mSecondaryUserId = users[1];
        getDevice().switchUser(mSecondaryUserId);
        uninstallTestPackages();
        installTestPackages();
    }

    @After
    public void tearDown() throws Exception {
        if (!mSupportsMultiUser) {
            return;
        }
        uninstallTestPackages();
        getDevice().switchUser(mStartingUserId);
    }

    // each connection to an exposed component needs to run in its own test to
    // avoid sharing state. once an instant app is exposed to a component, it's
    // exposed until the device restarts or the instant app is removed."	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.InstantAppUserTest"	"testInstallInstant"	"CtsAppSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/InstantAppUserTest.java"	""	"public void testInstallInstant() throws Exception {
        if (!mSupportsMultiUser) {
            return;
        }
        installInstantApp(USER_APK);
        runDeviceTestsAsUser(USER_TEST_PKG, TEST_CLASS, ""testQueryInstant"", mPrimaryUserId);
        runDeviceTestsAsUser(USER_TEST_PKG, TEST_CLASS, ""testQueryInstant"", mSecondaryUserId);
    }"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.InstantAppUserTest"	"testInstallMultiple"	"CtsAppSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/InstantAppUserTest.java"	""	"public void testInstallMultiple() throws Exception {
        if (!mSupportsMultiUser) {
            return;
        }
        installAppAsUser(USER_APK, mPrimaryUserId);
        installExistingInstantAppAsUser(USER_PKG, mSecondaryUserId);
        runDeviceTestsAsUser(USER_TEST_PKG, TEST_CLASS, ""testQueryFull"", mPrimaryUserId);
        runDeviceTestsAsUser(USER_TEST_PKG, TEST_CLASS, ""testQueryInstant"", mSecondaryUserId);
    }"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.InstantAppUserTest"	"testUpgradeExisting"	"CtsAppSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/InstantAppUserTest.java"	""	"public void testUpgradeExisting() throws Exception {
        if (!mSupportsMultiUser) {
            return;
        }
        installInstantApp(USER_APK);
        runDeviceTestsAsUser(USER_TEST_PKG, TEST_CLASS, ""testQueryInstant"", mPrimaryUserId);
        runDeviceTestsAsUser(USER_TEST_PKG, TEST_CLASS, ""testQueryInstant"", mSecondaryUserId);

        installExistingFullAppAsUser(USER_PKG, mSecondaryUserId);
        runDeviceTestsAsUser(USER_TEST_PKG, TEST_CLASS, ""testQueryInstant"", mPrimaryUserId);
        runDeviceTestsAsUser(USER_TEST_PKG, TEST_CLASS, ""testQueryFull"", mSecondaryUserId);
    }"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.InstantAppUserTest"	"testReplaceExisting"	"CtsAppSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/InstantAppUserTest.java"	""	"public void testReplaceExisting() throws Exception {
        if (!mSupportsMultiUser) {
            return;
        }
        installInstantApp(USER_APK);
        runDeviceTestsAsUser(USER_TEST_PKG, TEST_CLASS, ""testQueryInstant"", mPrimaryUserId);
        runDeviceTestsAsUser(USER_TEST_PKG, TEST_CLASS, ""testQueryInstant"", mSecondaryUserId);

        replaceFullAppAsUser(USER_APK, mSecondaryUserId);
        runDeviceTestsAsUser(USER_TEST_PKG, TEST_CLASS, ""testQueryInstant"", mPrimaryUserId);
        runDeviceTestsAsUser(USER_TEST_PKG, TEST_CLASS, ""testQueryFull"", mSecondaryUserId);
    }

    private void installTestPackages() throws Exception {
        installApp(NORMAL_APK);
        installApp(IMPLICIT_APK);
        installInstantApp(EPHEMERAL_1_APK);
        installApp(USER_TEST_APK);
    }

    private void uninstallTestPackages() throws Exception {
        getDevice().uninstallPackage(NORMAL_PKG);
        getDevice().uninstallPackage(IMPLICIT_PKG);
        getDevice().uninstallPackage(EPHEMERAL_1_PKG);
        getDevice().uninstallPackage(USER_TEST_PKG);
        getDevice().uninstallPackage(USER_PKG);
    }

    private void runDeviceTestsAsUser(String packageName, String testClassName,
            String testMethodName, int userId)
            throws DeviceNotAvailableException {
        Utils.runDeviceTests(getDevice(), packageName, testClassName, testMethodName, userId);
    }

    private void installApp(String apk) throws Exception {
        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(getBuild());
        assertNull(getDevice().installPackage(buildHelper.getTestFile(apk), false));
    }

    private void installInstantApp(String apk) throws Exception {
        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(getBuild());
        assertNull(getDevice().installPackage(buildHelper.getTestFile(apk), false, ""--instant""));
    }

    private void installAppAsUser(String apk, int userId) throws Exception {
        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(getBuild());
        assertNull(getDevice().installPackageForUser(buildHelper.getTestFile(apk), false, userId));
    }

    private void replaceFullAppAsUser(String apk, int userId) throws Exception {
        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(getBuild());
        assertNull(getDevice().installPackageForUser(
                buildHelper.getTestFile(apk), true, userId, ""--full""));
    }

    private void installExistingInstantAppAsUser(String packageName, int userId) throws Exception {
        final String installString =
                ""Package "" + packageName + "" installed for user: "" + userId + ""\n"";
        assertEquals(installString, getDevice().executeShellCommand(
                ""cmd package install-existing --instant""
                        + "" --user "" + Integer.toString(userId)
                        + "" "" + packageName));
    }

    private void installExistingFullAppAsUser(String packageName, int userId) throws Exception {
        final String installString =
                ""Package "" + packageName + "" installed for user: "" + userId + ""\n"";
        assertEquals(installString, getDevice().executeShellCommand(
                ""cmd package install-existing --full""
                        + "" --user "" + Integer.toString(userId)
                        + "" "" + packageName));
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"test.instant.cookie.CookieTest"	"testCookiePersistedAcrossInstantInstalls2"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/InstantCookieApp/src/test/instant/cookie/CookieTest.java"	""	"public void testCookiePersistedAcrossInstantInstalls2() throws Exception {
        PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();

        // After the upgrade the cookie should be the same
        assertEquals(""2"", new String(pm.getInstantAppCookie()));
    }"	""	""	"instantapp instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.usb.TestUsbTest"	"CollectingTestListener"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/usb/src/com/android/cts/usb/TestUsbTest.java"	""	"public void test/*
 *.
 */
package com.android.cts.usb;

import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.AppModeInstant;

import com.android.compatibility.common.tradefed.build.CompatibilityBuildHelper;
import com.android.ddmlib.testrunner.RemoteAndroidTestRunner;
import com.android.ddmlib.testrunner.TestResult.TestStatus;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.result.CollectingTestListener;
import com.android.tradefed.result.TestResult;
import com.android.tradefed.result.TestRunResult;
import com.android.tradefed.testtype.DeviceTestCase;
import com.android.tradefed.testtype.IAbi;
import com.android.tradefed.testtype.IAbiReceiver;
import com.android.tradefed.testtype.IBuildReceiver;
import com.android.tradefed.util.AbiUtils;
import com.android.tradefed.util.CommandResult;
import com.android.tradefed.util.CommandStatus;
import com.android.tradefed.util.RunUtil;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Functional tests for usb connection
 */
public class TestUsbTest extends DeviceTestCase implements IAbiReceiver, IBuildReceiver {

    private static final String CTS_RUNNER = ""androidx.test.runner.AndroidJUnitRunner"";
    private static final String PACKAGE_NAME = ""com.android.cts.usb.serialtest"";
    private static final String TEST_CLASS_NAME = PACKAGE_NAME + "".UsbSerialTest"";
    private static final String APK_NAME=""CtsUsbSerialTestApp.apk"";
    private ITestDevice mDevice;
    private IAbi mAbi;
    private IBuildInfo mBuild;

    @Override
    public void setAbi(IAbi abi) {
        mAbi = abi;
    }

    @Override
    public void setBuild(IBuildInfo buildInfo) {
        mBuild = buildInfo;
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mDevice = getDevice();
        mDevice.uninstallPackage(PACKAGE_NAME);
    }

    private void installApp(boolean installAsInstantApp)
            throws FileNotFoundException, DeviceNotAvailableException {
        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mBuild);
        File app = buildHelper.getTestFile(APK_NAME);
        String[] options;

        if (installAsInstantApp) {
            options = new String[]{AbiUtils.createAbiFlag(mAbi.getName()), ""--instant""};
        } else {
            options = new String[]{AbiUtils.createAbiFlag(mAbi.getName())};
        }
        mDevice.installPackage(app, false, true, options);
    }

    @Override
    protected void tearDown() throws Exception {
        super.tearDown();
        mDevice.uninstallPackage(PACKAGE_NAME);
    }

    private void runTestOnDevice(String testMethod) throws DeviceNotAvailableException {
        CollectingTestListener listener = new CollectingTestListener();
        RemoteAndroidTestRunner testRunner = new RemoteAndroidTestRunner(PACKAGE_NAME, CTS_RUNNER,
                mDevice.getIDevice());
        testRunner.setMethodName(TEST_CLASS_NAME, testMethod);
        mDevice.runInstrumentationTests(testRunner, listener);

        while (!listener.getCurrentRunResults().isRunComplete()) {
            // wait
        }

        TestRunResult runResult = listener.getCurrentRunResults();
        if (runResult.isRunFailure()) {
            fail(runResult.getRunFailureMessage());
        }

        for (TestResult result : runResult.getTestResults().values()) {
            if (!result.getStatus().equals(TestStatus.PASSED)) {
                fail(result.getStackTrace());
            }
        }
    }

    /**
     * Check if adb serial number, USB serial number, ro.serialno, and android.os.Build.SERIAL
     * all matches and meets the format requirement [a-zA-Z0-9]{6,20}
     */
    @AppModeInstant(reason = ""only instant apps fail when reading serial"")"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.usb.TestUsbTest"	"testInstantAppsCannotReadSerial"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/usb/src/com/android/cts/usb/TestUsbTest.java"	""	"public void testInstantAppsCannotReadSerial() throws Exception {
        installApp(true);

        runTestOnDevice(""verifySerialCannotBeRead"");
    }

    /**
     * Check if adb serial number, USB serial number, ro.serialno, and android.os.Build.SERIAL
     * all matches and meets the format requirement [a-zA-Z0-9]{6,20}
     */
    @AppModeFull(reason = ""serial can not be read by instant apps"")"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.ephemeralapp1.EphemeralResult"	"finish"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/EphemeralApp1/src/com/android/cts/ephemeralapp1/EphemeralResult.java"	""	"public void test/*
 *.
 */

package com.android.cts.ephemeralapp1;

import android.app.Activity;
import android.app.SearchManager;
import android.content.Intent;
import android.content.pm.PackageInfo;
import android.content.pm.ResolveInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.net.Uri;
import android.os.Bundle;
import android.provider.SearchRecentSuggestions;
import android.util.Log;

import com.android.cts.util.TestResult;

import java.util.List;

public class EphemeralResult extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        final Intent intent  = getIntent();
        if (Intent.ACTION_VIEW.equals(intent.getAction())
                && intent.hasExtra(TestResult.EXTRA_TEST_RESULT)) {
            ((TestResult) intent.getParcelableExtra(TestResult.EXTRA_TEST_RESULT)).broadcast(this);
        }
        finish();
    }
}"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.device.blob.InstantAppAccessTest"	"testInstantAppAccess"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/blobstore/test-apps/BlobStoreHostTestHelper/src/com/android/cts/device/blob/InstantAppAccessTest.java"	""	"public void testInstantAppAccess() {
        assertThat(mContext.getPackageManager().isInstantApp()).isTrue();
        assertThat(mContext.getSystemService(Context.BLOB_STORE_SERVICE)).isNull();
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.normalapp.NormalWebActivity"	"finish"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/NormalApp/src/com/android/cts/normalapp/NormalWebActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.normalapp;

import android.app.Activity;
import android.content.Intent;
import android.content.pm.PackageInfo;
import android.content.pm.ResolveInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.net.Uri;
import android.os.Bundle;
import android.util.Log;

import com.android.cts.util.TestResult;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.List;

public class NormalWebActivity extends Activity {
    private static final String ACTION_START_ACTIVITY =
            ""com.android.cts.ephemeraltest.START_ACTIVITY"";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        boolean canAccessInstantApp = false;
        String exception = null;
        try {
            canAccessInstantApp = tryAccessingInstantApp();
        } catch (Throwable t) {
            exception = t.getClass().getName();
        }

        TestResult.getBuilder()
                .setPackageName(""com.android.cts.normalapp"")
                .setComponentName(""NormalWebActivity"")
                .setStatus(""PASS"")
                .setException(exception)
                .setEphemeralPackageInfoExposed(canAccessInstantApp)
                .build()
                .broadcast(this);
        finish();
    }

    private boolean tryAccessingInstantApp() {
        try {
            final PackageInfo info = getPackageManager()
                    .getPackageInfo(""com.android.cts.ephemeralapp1"", 0 /*flags*/);
            return (info != null);
        } catch (Throwable t) {
            return false;
        }
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.permission2.cts.PermissionPolicyTest"	"platformPermissionPolicyIsUnaltered"	"CtsPermission2TestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/PermissionPolicyTest.java"	""	"public void platformPermissionPolicyIsUnaltered() throws Exception {
        Map<String, PermissionInfo> declaredPermissionsMap =
                getPermissionsForPackage(sContext, PLATFORM_PACKAGE_NAME);

        List<String> offendingList = new ArrayList<>();

        List<PermissionGroupInfo> declaredGroups = sContext.getPackageManager()
                .getAllPermissionGroups(0);
        Set<String> declaredGroupsSet = new ArraySet<>();
        for (PermissionGroupInfo declaredGroup : declaredGroups) {
            declaredGroupsSet.add(declaredGroup.name);
        }

        Set<String> expectedPermissionGroups = loadExpectedPermissionGroupNames(
                R.raw.android_manifest);
        List<ExpectedPermissionInfo> expectedPermissions = loadExpectedPermissions(
                R.raw.android_manifest);

        if (sContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
            expectedPermissions.addAll(loadExpectedPermissions(R.raw.automotive_android_manifest));
            declaredPermissionsMap.putAll(
                    getPermissionsForPackage(sContext, AUTOMOTIVE_SERVICE_PACKAGE_NAME));
        }

        for (ExpectedPermissionInfo expectedPermission : expectedPermissions) {
            String expectedPermissionName = expectedPermission.name;
            if (shouldSkipPermission(expectedPermissionName)) {
                // This permission doesn't need to exist yet, but will exist in
                // a future SPL. It is acceptable to declare the permission
                // even in an earlier SPL, so we remove it here so it doesn't
                // trigger a failure after the loop.
                declaredPermissionsMap.remove(expectedPermissionName);
                continue;
            }

            // OEMs cannot remove permissions
            PermissionInfo declaredPermission = declaredPermissionsMap.get(expectedPermissionName);
            if (declaredPermission == null) {
                offendingList.add(""Permission "" + expectedPermissionName + "" must be declared"");
                continue;
            }

            // We want to end up with OEM defined permissions and groups to check their namespace
            declaredPermissionsMap.remove(expectedPermissionName);

            // OEMs cannot change permission protection
            final int expectedProtection = expectedPermission.protectionLevel
                    & PROTECTION_MASK_BASE;
            final int declaredProtection = declaredPermission.protectionLevel
                    & PROTECTION_MASK_BASE;
            if (expectedProtection != declaredProtection) {
                offendingList.add(
                        String.format(
                                ""Permission %s invalid protection level %x, expected %x"",
                                expectedPermissionName, declaredProtection, expectedProtection));
            }

            // OEMs cannot change permission flags
            final int expectedFlags = expectedPermission.flags;
            final int declaredFlags = (declaredPermission.flags & ~FLAG_INSTALLED);
            if (expectedFlags != declaredFlags) {
                offendingList.add(
                        String.format(
                                ""Permission %s invalid flags %x, expected %x"",
                                expectedPermissionName,
                                declaredFlags,
                                expectedFlags));
            }

            // OEMs cannot change permission protection flags
            final int expectedProtectionFlags =
                    expectedPermission.protectionLevel & ~PROTECTION_MASK_BASE;
            final int declaredProtectionFlags = declaredPermission.getProtectionFlags();
            if (expectedProtectionFlags != declaredProtectionFlags) {
                offendingList.add(
                        String.format(
                                ""Permission %s invalid enforced protection %x, expected %x"",
                                expectedPermissionName,
                                declaredProtectionFlags,
                                expectedProtectionFlags));
            }

            // OEMs cannot change permission grouping
            if ((declaredPermission.protectionLevel & PermissionInfo.PROTECTION_DANGEROUS) != 0) {
                if (!Objects.equals(expectedPermission.group, declaredPermission.group)) {
                    offendingList.add(
                            ""Permission "" + expectedPermissionName + "" not in correct group ""
                            + ""(expected="" + expectedPermission.group + "" actual=""
                                    + declaredPermission.group);
                }

                if (declaredPermission.group != null
                        && !declaredGroupsSet.contains(declaredPermission.group)) {
                    offendingList.add(
                            ""Permission group "" + expectedPermission.group + "" must be defined"");
                }
            }

            // OEMs cannot change background permission mapping
            if (!Objects.equals(expectedPermission.backgroundPermission,
                    declaredPermission.backgroundPermission)) {
                offendingList.add(
                        String.format(
                                ""Permission %s invalid background permission %s, expected %s"",
                                expectedPermissionName,
                                declaredPermission.backgroundPermission,
                                expectedPermission.backgroundPermission));
            }
        }

        // OEMs cannot define permissions in the platform namespace
        for (String permission : declaredPermissionsMap.keySet()) {
            if (permission.startsWith(PLATFORM_ROOT_NAMESPACE)) {
                final PermissionInfo permInfo = declaredPermissionsMap.get(permission);
                offendingList.add(
                        ""Cannot define permission "" + permission
                        + "", package "" + permInfo.packageName
                        + "" in android namespace"");
            }
        }

        // OEMs cannot define groups in the platform namespace
        for (PermissionGroupInfo declaredGroup : declaredGroups) {
            if (!expectedPermissionGroups.contains(declaredGroup.name)) {
                if (declaredGroup.name != null) {
                    if (declaredGroup.packageName.equals(PLATFORM_PACKAGE_NAME)
                            && declaredGroup.name.startsWith(PLATFORM_ROOT_NAMESPACE)) {
                        offendingList.add(
                                ""Cannot define group "" + declaredGroup.name
                                + "", package "" + declaredGroup.packageName
                                + "" in android namespace"");
                    }
                }
            }
        }

        // OEMs cannot define new ephemeral permissions
        for (String permission : declaredPermissionsMap.keySet()) {
            PermissionInfo info = declaredPermissionsMap.get(permission);
            if ((info.protectionLevel & PermissionInfo.PROTECTION_FLAG_INSTANT) != 0) {
                offendingList.add(""Cannot define new instant permission "" + permission);
            }
        }

        // Fail on any offending item
        assertWithMessage(""list of offending permissions"").that(offendingList).isEmpty();
    }

    private List<ExpectedPermissionInfo> loadExpectedPermissions(int resourceId) throws Exception {
        List<ExpectedPermissionInfo> permissions = new ArrayList<>();
        try (InputStream in = sContext.getResources().openRawResource(resourceId)) {
            XmlPullParser parser = Xml.newPullParser();
            parser.setInput(in, null);

            final int outerDepth = parser.getDepth();
            int type;
            while ((type = parser.next()) != XmlPullParser.END_DOCUMENT
                    && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
                if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
                    continue;
                }
                if (TAG_PERMISSION.equals(parser.getName())) {
                    ExpectedPermissionInfo permissionInfo = new ExpectedPermissionInfo(
                            parser.getAttributeValue(null, ATTR_NAME),
                            parser.getAttributeValue(null, ATTR_PERMISSION_GROUP),
                            parser.getAttributeValue(null, ATTR_BACKGROUND_PERMISSION),
                            parsePermissionFlags(
                                    parser.getAttributeValue(null, ATTR_PERMISSION_FLAGS)),
                            parseProtectionLevel(
                                    parser.getAttributeValue(null, ATTR_PROTECTION_LEVEL)));
                    permissions.add(permissionInfo);
                } else {
                    Log.e(LOG_TAG, ""Unknown tag "" + parser.getName());
                }
            }
        }

        return permissions;
    }

    private Set<String> loadExpectedPermissionGroupNames(int resourceId) throws Exception {
        ArraySet<String> permissionGroups = new ArraySet<>();
        try (InputStream in = sContext.getResources().openRawResource(resourceId)) {
            XmlPullParser parser = Xml.newPullParser();
            parser.setInput(in, null);

            final int outerDepth = parser.getDepth();
            int type;
            while ((type = parser.next()) != XmlPullParser.END_DOCUMENT
                    && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
                if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
                    continue;
                }
                if (TAG_PERMISSION_GROUP.equals(parser.getName())) {
                    permissionGroups.add(parser.getAttributeValue(null, ATTR_NAME));
                } else {
                    Log.e(LOG_TAG, ""Unknown tag "" + parser.getName());
                }
            }
        }
        return permissionGroups;
    }

    private static int parsePermissionFlags(@Nullable String permissionFlagsString) {
        if (permissionFlagsString == null) {
            return 0;
        }

        int protectionFlags = 0;
        String[] fragments = permissionFlagsString.split(""\\|"");
        for (String fragment : fragments) {
            switch (fragment.trim()) {
                case ""removed"": {
                    protectionFlags |= PermissionInfo.FLAG_REMOVED;
                } break;
                case ""costsMoney"": {
                    protectionFlags |= PermissionInfo.FLAG_COSTS_MONEY;
                } break;
                case ""hardRestricted"": {
                    protectionFlags |= PermissionInfo.FLAG_HARD_RESTRICTED;
                } break;
                case ""immutablyRestricted"": {
                    protectionFlags |= PermissionInfo.FLAG_IMMUTABLY_RESTRICTED;
                } break;
                case ""softRestricted"": {
                    protectionFlags |= PermissionInfo.FLAG_SOFT_RESTRICTED;
                } break;
            }
        }
        return protectionFlags;
    }

    private static int parseProtectionLevel(String protectionLevelString) {
        int protectionLevel = 0;
        String[] fragments = protectionLevelString.split(""\\|"");
        for (String fragment : fragments) {
            switch (fragment.trim()) {
                case ""normal"": {
                    protectionLevel |= PermissionInfo.PROTECTION_NORMAL;
                } break;
                case ""dangerous"": {
                    protectionLevel |= PermissionInfo.PROTECTION_DANGEROUS;
                } break;
                case ""signature"": {
                    protectionLevel |= PermissionInfo.PROTECTION_SIGNATURE;
                } break;
                case ""signatureOrSystem"": {
                    protectionLevel |= PermissionInfo.PROTECTION_SIGNATURE;
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_SYSTEM;
                } break;
                case ""internal"": {
                    protectionLevel |= PermissionInfo.PROTECTION_INTERNAL;
                } break;
                case ""system"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_SYSTEM;
                } break;
                case ""installer"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_INSTALLER;
                } break;
                case ""verifier"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_VERIFIER;
                } break;
                case ""preinstalled"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_PREINSTALLED;
                } break;
                case ""pre23"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_PRE23;
                } break;
                case ""appop"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_APPOP;
                } break;
                case ""development"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_DEVELOPMENT;
                } break;
                case ""privileged"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_PRIVILEGED;
                } break;
                case ""oem"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_OEM;
                } break;
                case ""vendorPrivileged"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_VENDOR_PRIVILEGED;
                } break;
                case ""setup"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_SETUP;
                } break;
                case ""textClassifier"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_SYSTEM_TEXT_CLASSIFIER;
                } break;
                case ""configurator"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_CONFIGURATOR;
                } break;
                case ""incidentReportApprover"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_INCIDENT_REPORT_APPROVER;
                } break;
                case ""documenter"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_DOCUMENTER;
                } break;
                case ""appPredictor"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_APP_PREDICTOR;
                } break;
                case ""instant"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_INSTANT;
                } break;
                case ""runtime"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_RUNTIME_ONLY;
                } break;
                case ""companion"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_COMPANION;
                } break;
                case ""retailDemo"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_RETAIL_DEMO;
                } break;
                case ""recents"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_RECENTS;
                } break;
                case ""role"": {
                    protectionLevel |= PermissionInfo.PROTECTION_FLAG_ROLE;
                } break;
            }
        }
        return protectionLevel;
    }

    private static Map<String, PermissionInfo> getPermissionsForPackage(Context context, String pkg)
            throws NameNotFoundException {
        PackageInfo packageInfo = context.getPackageManager()
                .getPackageInfo(pkg, PackageManager.GET_PERMISSIONS);
        Map<String, PermissionInfo> declaredPermissionsMap = new ArrayMap<>();

        for (PermissionInfo declaredPermission : packageInfo.permissions) {
            declaredPermissionsMap.put(declaredPermission.name, declaredPermission);
        }
        return declaredPermissionsMap;
    }

    private static Date parseDate(String date) {
        Date patchDate = new Date();
        try {
            SimpleDateFormat template = new SimpleDateFormat(""yyyy-MM-dd"");
            patchDate = template.parse(date);
        } catch (ParseException e) {
        }

        return patchDate;
    }

    private boolean shouldSkipPermission(String permissionName) {
        switch (permissionName) {
            case HIDE_NON_SYSTEM_OVERLAY_WINDOWS_PERMISSION:
                return parseDate(SECURITY_PATCH).before(HIDE_NON_SYSTEM_OVERLAY_WINDOWS_PATCH_DATE);
            case MANAGE_COMPANION_DEVICES_PERMISSION:
                return parseDate(SECURITY_PATCH).before(MANAGE_COMPANION_DEVICES_PATCH_DATE);
            default:
                return false;
        }
    }

    private class ExpectedPermissionInfo {
        final @NonNull String name;
        final @Nullable String group;
        final @Nullable String backgroundPermission;
        final int flags;
        final int protectionLevel;

        private ExpectedPermissionInfo(@NonNull String name, @Nullable String group,
                @Nullable String backgroundPermission, int flags, int protectionLevel) {
            this.name = name;
            this.group = group;
            this.backgroundPermission = backgroundPermission;
            this.flags = flags;
            this.protectionLevel = protectionLevel;
        }
    }
}"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.EphemeralTest"	"testInstantAppUpgrade"	"CtsAppSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/EphemeralTest.java"	""	"public void testInstantAppUpgrade() throws Throwable {
        if (mIsUnsupportedDevice) {
            return;
        }
        installEphemeralApp(UPGRADED_APK);
        Utils.runDeviceTestsAsCurrentUser(getDevice(), UPGRADED_PKG, TEST_CLASS,
                ""testInstantApplicationWritePreferences"");
        Utils.runDeviceTestsAsCurrentUser(getDevice(), UPGRADED_PKG, TEST_CLASS,
                ""testInstantApplicationWriteFile"");
        installFullApp(UPGRADED_APK);
        Utils.runDeviceTestsAsCurrentUser(getDevice(), UPGRADED_PKG, TEST_CLASS,
                ""testFullApplicationReadPreferences"");
        Utils.runDeviceTestsAsCurrentUser(getDevice(), UPGRADED_PKG, TEST_CLASS,
                ""testFullApplicationReadFile"");
    }"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.appsecurity.cts.EphemeralTest"	"isDeviceUnsupported"	"CtsAppSecurityHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/EphemeralTest.java"	""	"public void uninstall_pruneInstantApp_shouldNotBeUserInitiated()
            throws Throwable {
        assumeFalse(""Device does not support instant app"", mIsUnsupportedDevice);

        Utils.runDeviceTestsAsCurrentUser(getDevice(), NORMAL_PKG, TEST_CLASS,
                ""uninstall_pruneInstantApp_shouldNotBeUserInitiated"");
    }

    private static final HashMap<String, String> makeArgs(
            String action, String category, String mimeType) {
        if (action == null || action.length() == 0) {
            fail(""action not specified"");
        }
        final HashMap<String, String> testArgs = new HashMap<>();
        testArgs.put(""action"", action);
        if (category != null && category.length() > 0) {
            testArgs.put(""category"", category);
        }
        if (mimeType != null && mimeType.length() > 0) {
            testArgs.put(""mime_type"", mimeType);
        }
        return testArgs;
    }

    private static final String[] sUnsupportedFeatures = {
            ""feature:android.hardware.type.watch"",
            ""android.hardware.type.embedded"",
    };
    private boolean isDeviceUnsupported() throws Exception {
        for (String unsupportedFeature : sUnsupportedFeatures) {
            if (getDevice().hasFeature(unsupportedFeature)) {
                return true;
            }
        }
        return false;
    }

    private boolean isIntentExposed(Map<String, String> testArgs)
            throws Exception {
        final StringBuffer command = new StringBuffer();
        command.append(""cmd package query-activities"");
        command.append("" -a "").append(testArgs.get(""action""));
        if (testArgs.get(""category"") != null) {
            command.append("" -c "").append(testArgs.get(""category""));
        }
        if (testArgs.get(""mime_type"") != null) {
            command.append("" -t "").append(testArgs.get(""mime_type""));
        }
        final String output = getDevice().executeShellCommand(command.toString()).trim();
        return !""No activities found"".equals(output);
    }

    private static final String dumpArgs(Map<String, String> testArgs) {
        final StringBuffer dump = new StringBuffer();
        dump.append(""action: "").append(testArgs.get(""action""));
        if (testArgs.get(""category"") != null) {
            dump.append("", category: "").append(testArgs.get(""category""));
        }
        if (testArgs.get(""mime_type"") != null) {
            dump.append("", type: "").append(testArgs.get(""mime_type""));
        }
        return dump.toString();
    }

    private void installApp(String apk) throws Exception {
        new InstallMultiple(false /* instant */)
                .addFile(apk)
                .run();
    }

    private void installApp(String apk, String installer) throws Exception {
        new InstallMultiple(false /* instant */)
                .addFile(apk)
                .addArg(""-i "" + installer)
                .run();
    }

    private void installEphemeralApp(String apk) throws Exception {
        new InstallMultiple(true /* instant */)
                .addFile(apk)
                .run();
    }

    private void installEphemeralApp(String apk, String installer) throws Exception {
        new InstallMultiple(true /* instant */)
                .addFile(apk)
                .addArg(""-i "" + installer)
                .run();
    }

    private void installFullApp(String apk) throws Exception {
        new InstallMultiple(false /* instant */)
                .addFile(apk)
                .addArg(""--full"")
                .run();
    }

    private void installTestPackages() throws Exception {
        installApp(NORMAL_APK);
        installApp(UNEXPOSED_APK);
        installApp(IMPLICIT_APK);

        installEphemeralApp(EPHEMERAL_1_APK);
        installEphemeralApp(EPHEMERAL_2_APK);
    }

    private void uninstallTestPackages() throws Exception {
        uninstallPackage(NORMAL_PKG);
        uninstallPackage(UNEXPOSED_PKG);
        uninstallPackage(IMPLICIT_PKG);
        uninstallPackage(EPHEMERAL_1_PKG);
        uninstallPackage(EPHEMERAL_2_PKG);
        uninstallPackage(UPGRADED_PKG);
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.app.cts.ActivityManagerTest"	"testServiceDoneLRUPosition"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerTest.java"	""	"public void testServiceDoneLRUPosition() throws Exception {
        ApplicationInfo ai = mTargetContext.getPackageManager()
                .getApplicationInfo(PACKAGE_NAME_APP1, 0);
        final WatchUidRunner watcher1 = new WatchUidRunner(mInstrumentation, ai.uid, WAITFOR_MSEC);
        ai = mTargetContext.getPackageManager().getApplicationInfo(PACKAGE_NAME_APP2, 0);
        final WatchUidRunner watcher2 = new WatchUidRunner(mInstrumentation, ai.uid, WAITFOR_MSEC);
        ai = mTargetContext.getPackageManager().getApplicationInfo(PACKAGE_NAME_APP3, 0);
        final WatchUidRunner watcher3 = new WatchUidRunner(mInstrumentation, ai.uid, WAITFOR_MSEC);
        final HandlerThread handlerThread = new HandlerThread(""worker"");
        final Messenger[] controllerHolder = new Messenger[1];
        final CountDownLatch[] countDownLatchHolder = new CountDownLatch[1];
        handlerThread.start();
        final Messenger messenger = new Messenger(new Handler(handlerThread.getLooper(), msg -> {
            final Bundle bundle = (Bundle) msg.obj;
            final IBinder binder = bundle.getBinder(CommandReceiver.EXTRA_MESSENGER);
            if (binder != null) {
                controllerHolder[0] = new Messenger(binder);
                countDownLatchHolder[0].countDown();
            }
            return true;
        }));

        try {
            // Make sure we could start activity from background
            SystemUtil.runShellCommand(mInstrumentation,
                    ""cmd deviceidle whitelist +"" + PACKAGE_NAME_APP1);
            SystemUtil.runShellCommand(mInstrumentation,
                    ""cmd deviceidle whitelist +"" + PACKAGE_NAME_APP2);
            SystemUtil.runShellCommand(mInstrumentation,
                    ""cmd deviceidle whitelist +"" + PACKAGE_NAME_APP3);

            // Keep the device awake
            toggleScreenOn(true);

            // Start a FGS in app1
            final Bundle extras = new Bundle();
            countDownLatchHolder[0] = new CountDownLatch(1);
            extras.putBinder(CommandReceiver.EXTRA_MESSENGER, messenger.getBinder());
            CommandReceiver.sendCommand(mTargetContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, extras);

            watcher1.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE, null);

            assertTrue(""Failed to get the controller interface"",
                    countDownLatchHolder[0].await(WAITFOR_MSEC, TimeUnit.MILLISECONDS));

            // Start an activity in another package
            CommandReceiver.sendCommand(mTargetContext, CommandReceiver.COMMAND_START_ACTIVITY,
                    PACKAGE_NAME_APP2, PACKAGE_NAME_APP2, 0, null);

            watcher2.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_TOP, null);

            // Start another activity in another package
            CommandReceiver.sendCommand(mTargetContext, CommandReceiver.COMMAND_START_ACTIVITY,
                    PACKAGE_NAME_APP3, PACKAGE_NAME_APP3, 0, null);

            watcher3.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_TOP, null);

            // Stop both of these activities
            CommandReceiver.sendCommand(mTargetContext, CommandReceiver.COMMAND_STOP_ACTIVITY,
                    PACKAGE_NAME_APP2, PACKAGE_NAME_APP2, 0, null);
            watcher2.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY, null);
            CommandReceiver.sendCommand(mTargetContext, CommandReceiver.COMMAND_STOP_ACTIVITY,
                    PACKAGE_NAME_APP3, PACKAGE_NAME_APP3, 0, null);
            watcher3.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY, null);

            // Launch home so we'd have cleared these the above test activities from recents.
            launchHome();

            // Now stop the foreground service, we'd have to do via the controller interface
            final Message msg = Message.obtain();
            try {
                msg.what = LocalForegroundService.COMMAND_STOP_SELF;
                controllerHolder[0].send(msg);
            } catch (RemoteException e) {
                fail(""Unable to stop test package"");
            }
            msg.recycle();
            watcher1.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY, null);

            final List<String> lru = getCachedAppsLru();

            assertTrue(""Failed to get cached app list"", lru.size() > 0);
            final int app1LruPos = lru.indexOf(PACKAGE_NAME_APP1);
            final int app2LruPos = lru.indexOf(PACKAGE_NAME_APP2);
            final int app3LruPos = lru.indexOf(PACKAGE_NAME_APP3);
            if (app1LruPos != -1) {
                assertTrue(PACKAGE_NAME_APP1 + "" should be newer than "" + PACKAGE_NAME_APP2,
                        app1LruPos > app2LruPos);
                assertTrue(PACKAGE_NAME_APP1 + "" should be newer than "" + PACKAGE_NAME_APP3,
                        app1LruPos > app3LruPos);
            } else {
                assertEquals(PACKAGE_NAME_APP2 + "" should have gone"", -1, app2LruPos);
                assertEquals(PACKAGE_NAME_APP3 + "" should have gone"", -1, app3LruPos);
            }
        } finally {
            handlerThread.quitSafely();

            SystemUtil.runShellCommand(mInstrumentation,
                    ""cmd deviceidle whitelist -"" + PACKAGE_NAME_APP1);
            SystemUtil.runShellCommand(mInstrumentation,
                    ""cmd deviceidle whitelist -"" + PACKAGE_NAME_APP2);
            SystemUtil.runShellCommand(mInstrumentation,
                    ""cmd deviceidle whitelist -"" + PACKAGE_NAME_APP3);

            SystemUtil.runWithShellPermissionIdentity(() -> {
                // force stop test package, where the whole test process group will be killed.
                mActivityManager.forceStopPackage(PACKAGE_NAME_APP1);
                mActivityManager.forceStopPackage(PACKAGE_NAME_APP2);
                mActivityManager.forceStopPackage(PACKAGE_NAME_APP3);
            });

            watcher1.finish();
            watcher2.finish();
            watcher3.finish();
        }
    }

    private List<String> getCachedAppsLru() throws Exception {
        final List<String> lru = new ArrayList<>();
        final String output = SystemUtil.runShellCommand(mInstrumentation, ""dumpsys activity lru"");
        final String[] lines = output.split(""\n"");
        for (String line: lines) {
            if (line == null || line.indexOf("" cch"") == -1) {
                continue;
            }
            final int slash = line.lastIndexOf('/');
            if (slash == -1) {
                continue;
            }
            line = line.substring(0, slash);
            final int space = line.lastIndexOf(' ');
            if (space == -1) {
                continue;
            }
            line = line.substring(space + 1);
            final int colon = line.indexOf(':');
            if (colon == -1) {
                continue;
            }
            lru.add(0, line.substring(colon + 1));
        }
        return lru;
    }

    private Bundle initWaitingForTrimLevel(
            final CountDownLatch[] latchHolder, final int[] levelHolder) {
        final IBinder binder = new Binder() {
            @Override
            protected boolean onTransact(int code, Parcel data, Parcel reply, int flags)
                    throws RemoteException {
                switch (code) {
                    case IBinder.FIRST_CALL_TRANSACTION:
                        levelHolder[0] = data.readInt();
                        latchHolder[0].countDown();
                        return true;
                    default:
                        return false;
                }
            }
        };
        final Bundle extras = new Bundle();
        extras.putBinder(CommandReceiver.EXTRA_CALLBACK, binder);
        return extras;
    }

    private RunningAppProcessInfo getRunningAppProcessInfo(String processName) {
        try {
            return SystemUtil.callWithShellPermissionIdentity(()-> {
                return mActivityManager.getRunningAppProcesses().stream().filter(
                        (ra) -> processName.equals(ra.processName)).findFirst().orElse(null);
            });
        } catch (Exception e) {
        }
        return null;
    }

    private boolean isProcessGone(int pid, String processName) {
        RunningAppProcessInfo info = getRunningAppProcessInfo(processName);
        return info == null || info.pid != pid;
    }

    // Copied from DeviceStatesTest
    /**
     * Make sure the screen state.
     */
    private void toggleScreenOn(final boolean screenon) throws Exception {
        if (screenon) {
            executeAndLogShellCommand(""input keyevent KEYCODE_WAKEUP"");
            executeAndLogShellCommand(""wm dismiss-keyguard"");
        } else {
            executeAndLogShellCommand(""input keyevent KEYCODE_SLEEP"");
        }
        // Since the screen on/off intent is ordered, they will not be sent right now.
        SystemClock.sleep(2_000);
    }

    /**
     * Simulated for idle, and then perform idle maintenance now.
     */
    private void triggerIdle(boolean idle) throws Exception {
        if (idle) {
            executeAndLogShellCommand(""cmd deviceidle force-idle light"");
        } else {
            executeAndLogShellCommand(""cmd deviceidle unforce"");
        }
        // Wait a moment to let that happen before proceeding.
        SystemClock.sleep(2_000);
    }

    /**
     * Return true if the given supplier says it's true
     */
    private boolean waitUntilTrue(long maxWait, Supplier<Boolean> supplier) throws Exception {
        final long deadLine = SystemClock.uptimeMillis() + maxWait;
        boolean result = false;
        do {
            Thread.sleep(500);
        } while (!(result = supplier.get()) && SystemClock.uptimeMillis() < deadLine);
        return result;
    }
}"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.hardware.cts.helpers.SensorStats"	"isExternalStorageWritable"	"CtsSensorTestCases"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/helpers/SensorStats.java"	""	"public void test/*
 *.
 */

package android.hardware.cts.helpers;

import android.content.Context;
import android.hardware.Sensor;
import android.hardware.cts.helpers.sensoroperations.SensorOperation;
import android.os.Environment;
import android.util.Log;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

/**
 * Class used to store stats related to {@link SensorOperation}s. Sensor stats may be linked
 * together so that they form a tree.
 */
public class SensorStats {
    private static final String TAG = ""SensorStats"";
    public static final String DELIMITER = ""__"";

    public static final String ERROR = ""error"";
    public static final String EVENT_FIFO_LENGTH = ""event_fifo_length_observed"";
    public static final String EVENT_GAP_COUNT_KEY = ""event_gap_count"";
    public static final String EVENT_GAP_POSITIONS_KEY = ""event_gap_positions"";
    public static final String EVENT_OUT_OF_ORDER_COUNT_KEY = ""event_out_of_order_count"";
    public static final String EVENT_OUT_OF_ORDER_POSITIONS_KEY = ""event_out_of_order_positions"";
    public static final String EVENT_TIME_SYNCHRONIZATION_COUNT_KEY =
            ""event_time_synchronization_count"";
    public static final String EVENT_TIME_SYNCHRONIZATION_POSITIONS_KEY =
            ""event_time_synchronization_positions"";
    public static final String EVENT_TIME_WRONG_CLOCKSOURCE_COUNT_KEY =
            ""event_time_wrong_clocksource_count"";
    public static final String EVENT_TIME_WRONG_CLOCKSOURCE_POSITIONS_KEY =
            ""event_time_wrong_clocksource_positions"";
    public static final String EVENT_COUNT_KEY = ""event_count"";
    public static final String EVENT_COUNT_EXPECTED_KEY = ""event_count_expected"";
    public static final String EVENT_NOT_SANITIZED_KEY = ""event_not_sanitized"";
    public static final String EVENT_LOG_FILENAME = ""event_log_filename"";
    public static final String WRONG_SENSOR_KEY = ""wrong_sensor_observed"";
    public static final String FREQUENCY_KEY = ""frequency"";
    public static final String JITTER_95_PERCENTILE_PERCENT_KEY = ""jitter_95_percentile_percent"";
    public static final String MEAN_KEY = ""mean"";
    public static final String STANDARD_DEVIATION_KEY = ""standard_deviation"";
    public static final String MAGNITUDE_KEY = ""magnitude"";
    public static final String DELAYED_BATCH_DELIVERY = ""delayed_batch_delivery"";
    public static final String INITIAL_MEAN_KEY = ""initial_mean"";
    public static final String LATER_MEAN_KEY = ""later_mean"";

    private final Map<String, Object> mValues = new HashMap<>();
    private final Map<String, SensorStats> mSensorStats = new HashMap<>();

    /**
     * Add a value.
     *
     * @param key the key.
     * @param value the value as an {@link Object}.
     */
    public synchronized void addValue(String key, Object value) {
        if (value == null) {
            return;
        }
        mValues.put(key, value);
    }

    /**
     * Add a nested {@link SensorStats}. This is useful for keeping track of stats in a
     * {@link SensorOperation} tree.
     *
     * @param key the key
     * @param stats the sub {@link SensorStats} object.
     */
    public synchronized void addSensorStats(String key, SensorStats stats) {
        if (stats == null) {
            return;
        }
        mSensorStats.put(key, stats);
    }

    /**
     * Get the keys from the values table. Will not get the keys from the nested
     * {@link SensorStats}.
     */
    public synchronized Set<String> getKeys() {
        return mValues.keySet();
    }

    /**
     * Get a value from the values table. Will not attempt to get values from nested
     * {@link SensorStats}.
     */
    public synchronized Object getValue(String key) {
        return mValues.get(key);
    }

    /**
     * Flattens the map and all sub {@link SensorStats} objects. Keys will be flattened using
     * {@value #DELIMITER}. For example, if a sub {@link SensorStats} is added with key
     * {@code ""key1""} containing the key value pair {@code \(""key2"", ""value""\)}, the flattened map
     * will contain the entry {@code \(""key1__key2"", ""value""\)}.
     *
     * @return a {@link Map} containing all stats from the value and sub {@link SensorStats}.
     */
    public synchronized Map<String, Object> flatten() {
        final Map<String, Object> flattenedMap = new HashMap<>(mValues);
        for (Entry<String, SensorStats> statsEntry : mSensorStats.entrySet()) {
            for (Entry<String, Object> valueEntry : statsEntry.getValue().flatten().entrySet()) {
                String key = statsEntry.getKey() + DELIMITER + valueEntry.getKey();
                flattenedMap.put(key, valueEntry.getValue());
            }
        }
        return flattenedMap;
    }

    /**
     * Utility method to log the stats to the logcat.
     */
    public void log(String tag) {
        final Map<String, Object> flattened = flatten();
        for (String key : getSortedKeys(flattened)) {
            Object value = flattened.get(key);
            Log.v(tag, String.format(""%s: %s"", key, getValueString(value)));
        }
    }

    /* Checks if external storage is available for read and write */
    private boolean isExternalStorageWritable() {
        String state = Environment.getExternalStorageState();
        return Environment.MEDIA_MOUNTED.equals(state);
    }

    /**
     * Utility method to log the stats to a file. Will overwrite the file if it already exists.
     */
    public void logToFile(Context context, String fileName) throws IOException {
        if (!isExternalStorageWritable()) {
            Log.w(TAG,
                ""External storage unavailable, skipping log to file: "" + fileName);
            return;
        }

        try {
            // Only log to file if currently not an Instant App since Instant Apps do not have access to
            // external storage.
            if (!context.getPackageManager().isInstantApp()) {
                File statsDirectory = SensorCtsHelper.getSensorTestDataDirectory(""stats/"");
                File logFile = new File(statsDirectory, fileName);
                final Map<String, Object> flattened = flatten();
                FileWriter fileWriter = new FileWriter(logFile, false /* append */);
                try (BufferedWriter writer = new BufferedWriter(fileWriter)) {
                    for (String key : getSortedKeys(flattened)) {
                        Object value = flattened.get(key);
                        writer.write(String.format(""%s: %s\n"", key, getValueString(value)));
                    }
                }
            }
        } catch(IOException e) {
            Log.w(TAG, ""Unable to write to file: "" + fileName, e);
        }
    }

    /**
     * Provides a sanitized sensor name, that can be used in file names.
     * See {@link #logToFile(String)}.
     */
    public static String getSanitizedSensorName(Sensor sensor) throws SensorTestPlatformException {
        return SensorCtsHelper.sanitizeStringForFileName(sensor.getStringType());
    }

    private static List<String> getSortedKeys(Map<String, Object> flattenedStats) {
        List<String> keys = new ArrayList<>(flattenedStats.keySet());
        Collections.sort(keys);
        return keys;
    }

    private static String getValueString(Object value) {
        if (value == null) {
            return """";
        } else if (value instanceof boolean[]) {
            return Arrays.toString((boolean[]) value);
        } else if (value instanceof byte[]) {
            return Arrays.toString((byte[]) value);
        } else if (value instanceof char[]) {
            return Arrays.toString((char[]) value);
        } else if (value instanceof double[]) {
            return Arrays.toString((double[]) value);
        } else if (value instanceof float[]) {
            return Arrays.toString((float[]) value);
        } else if (value instanceof int[]) {
            return Arrays.toString((int[]) value);
        } else if (value instanceof long[]) {
            return Arrays.toString((long[]) value);
        } else if (value instanceof short[]) {
            return Arrays.toString((short[]) value);
        } else if (value instanceof Object[]) {
            return Arrays.toString((Object[]) value);
        } else {
            return value.toString();
        }
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.forcestop.RecentTaskRemovalTestActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/forcestop/RecentTaskRemovalTestActivity.java"	""	"public void test/*
 *.
 *
 */

package com.android.cts.verifier.forcestop;

import android.app.PendingIntent;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.view.View;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.TextView;

import com.android.cts.forcestophelper.Constants;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

/**
 * Tests that an app is not killed when it is swiped away from recents.
 * Requires CtsForceStopHelper.apk to be installed.
 */
public class RecentTaskRemovalTestActivity extends PassFailButtons.Activity implements
        View.OnClickListener {
    private static final String HELPER_APP_NAME = Constants.PACKAGE_NAME;
    private static final String HELPER_ACTIVITY_NAME = Constants.ACTIVITY_CLASS_NAME;

    private static final String HELPER_APP_INSTALLED_KEY = ""helper_installed"";

    private static final String ACTION_REPORT_TASK_REMOVED = ""report_task_removed"";
    private static final String ACTION_REPORT_ALARM = ""report_alarm"";

    private static final long EXTRA_WAIT_FOR_ALARM = 2_000;

    private ImageView mInstallStatus;
    private TextView mInstallTestAppText;

    private ImageView mLaunchStatus;
    private Button mLaunchTestAppButton;

    private ImageView mRemoveFromRecentsStatus;
    private TextView mRemoveFromRecentsInstructions;

    private ImageView mForceStopStatus;
    private TextView mForceStopVerificationResult;

    private volatile boolean mTestAppInstalled;
    private volatile boolean mTestTaskLaunched;
    private volatile boolean mTestTaskRemoved;
    private volatile boolean mTestAppForceStopped;
    private volatile boolean mTestAlarmReceived;
    private volatile boolean mWaitingForAlarm;

    private final PackageStateReceiver mPackageChangesListener = new PackageStateReceiver();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.force_stop_recents_main);
        setInfoResources(R.string.remove_from_recents_test, R.string.remove_from_recents_test_info,
                -1);
        setPassFailButtonClickListeners();

        if (savedInstanceState != null) {
            mTestAppInstalled = savedInstanceState.getBoolean(HELPER_APP_INSTALLED_KEY, false);
        } else {
            mTestAppInstalled = isPackageInstalled();
        }
        mInstallStatus = findViewById(R.id.fs_test_app_install_status);
        mInstallTestAppText = findViewById(R.id.fs_test_app_install_instructions);

        mRemoveFromRecentsStatus = findViewById(R.id.fs_test_app_recents_status);
        mRemoveFromRecentsInstructions = findViewById(R.id.fs_test_app_recents_instructions);

        mLaunchStatus = findViewById(R.id.fs_test_app_launch_status);
        mLaunchTestAppButton = findViewById(R.id.fs_launch_test_app_button);
        mLaunchTestAppButton.setOnClickListener(this);

        mForceStopStatus = findViewById(R.id.fs_force_stop_status);
        mForceStopVerificationResult = findViewById(R.id.fs_force_stop_verification);

        mPackageChangesListener.register(mForceStopStatus.getHandler());
    }

    private boolean isPackageInstalled() {
        PackageInfo packageInfo = null;
        try {
            packageInfo = getPackageManager().getPackageInfo(HELPER_APP_NAME, 0);
        } catch (PackageManager.NameNotFoundException exc) {
            // fall through
        }
        return packageInfo != null;
    }

    @Override
    public void onClick(View v) {
        if (v == mLaunchTestAppButton) {
            mTestTaskLaunched = true;

            final Intent reportTaskRemovedIntent = new Intent(ACTION_REPORT_TASK_REMOVED)
                    .setPackage(getPackageName())
                    .addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
            final PendingIntent onTaskRemoved = PendingIntent.getBroadcast(this, 0,
                    reportTaskRemovedIntent, PendingIntent.FLAG_MUTABLE_UNAUDITED);

            final Intent reportAlarmIntent = new Intent(ACTION_REPORT_ALARM)
                    .setPackage(getPackageName())
                    .addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
            final PendingIntent onAlarm = PendingIntent.getBroadcast(this, 0, reportAlarmIntent, PendingIntent.FLAG_MUTABLE_UNAUDITED);

            final Intent testActivity = new Intent()
                    .setClassName(HELPER_APP_NAME, HELPER_ACTIVITY_NAME)
                    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    .putExtra(Constants.EXTRA_ON_TASK_REMOVED, onTaskRemoved)
                    .putExtra(Constants.EXTRA_ON_ALARM, onAlarm);
            startActivity(testActivity);
        }
    }

    @Override
    public void onResume() {
        super.onResume();
        updateWidgets();
    }

    @Override
    public void onSaveInstanceState(Bundle icicle) {
        icicle.putBoolean(HELPER_APP_INSTALLED_KEY, mTestAppInstalled);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        mPackageChangesListener.unregister();
    }

    private void updateWidgets() {
        mInstallStatus.setImageResource(
                mTestAppInstalled ? R.drawable.fs_good : R.drawable.fs_indeterminate);
        mInstallTestAppText.setText(mTestAppInstalled ? R.string.fs_test_app_installed_text
                : R.string.fs_test_app_install_instructions);
        mInstallStatus.invalidate();

        mLaunchStatus.setImageResource(
                mTestTaskLaunched ? R.drawable.fs_good : R.drawable.fs_indeterminate);
        mLaunchTestAppButton.setEnabled(mTestAppInstalled && !mTestTaskLaunched);
        mLaunchStatus.invalidate();

        mRemoveFromRecentsStatus.setImageResource(
                mTestTaskRemoved ? R.drawable.fs_good : R.drawable.fs_indeterminate);
        mRemoveFromRecentsInstructions.setText(R.string.fs_test_app_recents_instructions);
        mRemoveFromRecentsStatus.invalidate();

        if (mTestTaskRemoved) {
            if (mWaitingForAlarm) {
                mForceStopStatus.setImageResource(R.drawable.fs_clock);
                mForceStopVerificationResult.setText(R.string.fs_force_stop_verification_pending);
            } else {
                mForceStopStatus.setImageResource(
                        (mTestAppForceStopped || !mTestAlarmReceived) ? R.drawable.fs_error
                                : R.drawable.fs_good);
                mForceStopVerificationResult.setText((mTestAppForceStopped || !mTestAlarmReceived)
                        ? R.string.result_failure
                        : R.string.result_success);
            }
            mForceStopStatus.invalidate();
            mForceStopStatus.setVisibility(View.VISIBLE);
            mForceStopVerificationResult.setVisibility(View.VISIBLE);
        } else {
            mForceStopStatus.setVisibility(View.GONE);
            mForceStopVerificationResult.setVisibility(View.GONE);
        }

        getPassButton().setEnabled(mTestAlarmReceived && !mTestAppForceStopped);
    }

    private final class PackageStateReceiver extends BroadcastReceiver {

        void register(Handler handler) {
            final IntentFilter packageFilter = new IntentFilter();
            packageFilter.addAction(Intent.ACTION_PACKAGE_RESTARTED);
            packageFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
            packageFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
            packageFilter.addDataScheme(""package"");
            registerReceiver(this, packageFilter);

            final IntentFilter commsFilter = new IntentFilter();
            commsFilter.addAction(ACTION_REPORT_TASK_REMOVED);
            commsFilter.addAction(ACTION_REPORT_ALARM);
            registerReceiver(this, commsFilter, null, handler);
        }

        void unregister() {
            unregisterReceiver(this);
        }

        @Override
        public void onReceive(Context context, Intent intent) {
            final Uri uri = intent.getData();
            boolean testPackageAffected = (uri != null && HELPER_APP_NAME.equals(
                    uri.getSchemeSpecificPart()));
            switch (intent.getAction()) {
                case Intent.ACTION_PACKAGE_ADDED:
                case Intent.ACTION_PACKAGE_REMOVED:
                    if (testPackageAffected) {
                        mTestAppInstalled = Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction());
                    }
                    break;
                case Intent.ACTION_PACKAGE_RESTARTED:
                    if (testPackageAffected) {
                        mTestAppForceStopped = true;
                    }
                    break;
                case ACTION_REPORT_TASK_REMOVED:
                    mTestTaskRemoved = true;
                    mWaitingForAlarm = true;
                    mForceStopStatus.postDelayed(() -> {
                        mWaitingForAlarm = false;
                        updateWidgets();
                    }, Constants.ALARM_DELAY + EXTRA_WAIT_FOR_ALARM);
                    break;
                case ACTION_REPORT_ALARM:
                    mTestAlarmReceived = true;
                    mWaitingForAlarm = false;
                    break;
            }
            updateWidgets();
        }
    }
}"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.security.SELinuxTargetSdkTest"	"isInstantApp"	"CtsSelinuxEphemeralTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/selinux/selinuxEphemeral/src/android/security/SELinuxTargetSdkTest.java"	""	"public void test/*
 *.
 */

package android.security;

import android.platform.test.annotations.AppModeInstant;
import android.test.AndroidTestCase;
import com.android.compatibility.common.util.PropertyUtil;
import java.io.IOException;


/**
 * Verify the selinux domain for apps running in instant mode
 */
@AppModeInstant
public class SELinuxTargetSdkTest extends SELinuxTargetSdkTestBase
{

    @Override
    public void setUp() throws Exception {
        super.setUp();
        assertTrue(""This class is annotated with @AppModeInstant and must never ""
                   + ""be run as a normal CTS test"",
            getContext().getPackageManager().isInstantApp());
    }"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.server.wm.WindowManagerState"	"computeState"	""	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/util/src/android/server/wm/WindowManagerState.java"	""	"public void test/*
 *
 */

package android.server.wm;

import static android.app.ActivityTaskManager.INVALID_STACK_ID;
import static android.app.WindowConfiguration.ACTIVITY_TYPE_DREAM;
import static android.app.WindowConfiguration.ACTIVITY_TYPE_HOME;
import static android.app.WindowConfiguration.ACTIVITY_TYPE_RECENTS;
import static android.app.WindowConfiguration.ACTIVITY_TYPE_STANDARD;
import static android.app.WindowConfiguration.ACTIVITY_TYPE_UNDEFINED;
import static android.app.WindowConfiguration.WINDOWING_MODE_UNDEFINED;
import static android.server.wm.ComponentNameUtils.getActivityName;
import static android.server.wm.ProtoExtractors.extract;
import static android.server.wm.StateLogger.log;
import static android.server.wm.StateLogger.logE;
import static android.server.wm.TestTaskOrganizer.INVALID_TASK_ID;
import static android.util.DisplayMetrics.DENSITY_DEFAULT;
import static android.view.Display.DEFAULT_DISPLAY;

import static androidx.test.InstrumentationRegistry.getInstrumentation;

import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import android.app.ActivityTaskManager;
import android.content.ComponentName;
import android.content.res.Configuration;
import android.graphics.Point;
import android.graphics.Rect;
import android.os.ParcelFileDescriptor;
import android.os.SystemClock;
import android.util.SparseArray;
import android.view.WindowManager;
import android.view.nano.DisplayInfoProto;
import android.view.nano.ViewProtoEnums;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.android.server.wm.nano.ActivityRecordProto;
import com.android.server.wm.nano.AppTransitionProto;
import com.android.server.wm.nano.ConfigurationContainerProto;
import com.android.server.wm.nano.DisplayAreaProto;
import com.android.server.wm.nano.DisplayContentProto;
import com.android.server.wm.nano.DisplayFramesProto;
import com.android.server.wm.nano.DisplayRotationProto;
import com.android.server.wm.nano.IdentifierProto;
import com.android.server.wm.nano.KeyguardControllerProto;
import com.android.server.wm.nano.PinnedTaskControllerProto;
import com.android.server.wm.nano.RootWindowContainerProto;
import com.android.server.wm.nano.TaskProto;
import com.android.server.wm.nano.WindowContainerChildProto;
import com.android.server.wm.nano.WindowContainerProto;
import com.android.server.wm.nano.WindowFramesProto;
import com.android.server.wm.nano.WindowManagerServiceDumpProto;
import com.android.server.wm.nano.WindowStateAnimatorProto;
import com.android.server.wm.nano.WindowStateProto;
import com.android.server.wm.nano.WindowSurfaceControllerProto;
import com.android.server.wm.nano.WindowTokenProto;

import com.google.protobuf.nano.InvalidProtocolBufferNanoException;

import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class WindowManagerState {

    public static final String STATE_INITIALIZING = ""INITIALIZING"";
    public static final String STATE_RESUMED = ""RESUMED"";
    public static final String STATE_PAUSED = ""PAUSED"";
    public static final String STATE_STOPPED = ""STOPPED"";
    public static final String STATE_DESTROYED = ""DESTROYED"";
    public static final String TRANSIT_ACTIVITY_OPEN = ""TRANSIT_ACTIVITY_OPEN"";
    public static final String TRANSIT_ACTIVITY_CLOSE = ""TRANSIT_ACTIVITY_CLOSE"";
    public static final String TRANSIT_TASK_OPEN = ""TRANSIT_TASK_OPEN"";
    public static final String TRANSIT_TASK_CLOSE = ""TRANSIT_TASK_CLOSE"";
    public static final String TRANSIT_WALLPAPER_OPEN = ""TRANSIT_WALLPAPER_OPEN"";
    public static final String TRANSIT_WALLPAPER_CLOSE = ""TRANSIT_WALLPAPER_CLOSE"";
    public static final String TRANSIT_WALLPAPER_INTRA_OPEN = ""TRANSIT_WALLPAPER_INTRA_OPEN"";
    public static final String TRANSIT_WALLPAPER_INTRA_CLOSE = ""TRANSIT_WALLPAPER_INTRA_CLOSE"";
    public static final String TRANSIT_KEYGUARD_GOING_AWAY = ""TRANSIT_KEYGUARD_GOING_AWAY"";
    public static final String TRANSIT_KEYGUARD_GOING_AWAY_ON_WALLPAPER =
            ""TRANSIT_KEYGUARD_GOING_AWAY_ON_WALLPAPER"";
    public static final String TRANSIT_KEYGUARD_OCCLUDE = ""TRANSIT_KEYGUARD_OCCLUDE"";
    public static final String TRANSIT_KEYGUARD_UNOCCLUDE = ""TRANSIT_KEYGUARD_UNOCCLUDE"";
    public static final String TRANSIT_TRANSLUCENT_ACTIVITY_OPEN =
            ""TRANSIT_TRANSLUCENT_ACTIVITY_OPEN"";
    public static final String TRANSIT_TRANSLUCENT_ACTIVITY_CLOSE =
            ""TRANSIT_TRANSLUCENT_ACTIVITY_CLOSE"";
    public static final String APP_STATE_IDLE = ""APP_STATE_IDLE"";
    public static final String APP_STATE_RUNNING = ""APP_STATE_RUNNING"";

    private static final String DUMPSYS_WINDOW = ""dumpsys window -a --proto"";
    private static final String STARTING_WINDOW_PREFIX = ""Starting "";
    private static final String DEBUGGER_WINDOW_PREFIX = ""Waiting For Debugger: "";
    /** @see WindowManager.LayoutParams */
    private static final int TYPE_NAVIGATION_BAR = 2019;
    /** @see WindowManager.LayoutParams */
    private static final int TYPE_NAVIGATION_BAR_PANEL = 2024;
    /** @see WindowManager.LayoutParams */
    private static final int TYPE_NOTIFICATION_SHADE = 2040;

    // Default minimal size of resizable task, used if none is set explicitly.
    // Must be kept in sync with 'default_minimal_size_resizable_task' dimen from frameworks/base.
    private static final int DEFAULT_RESIZABLE_TASK_SIZE_DP = 220;

    private RootWindowContainer mRoot = null;
    // Displays in z-order with the top most at the front of the list, starting with primary.
    private final List<DisplayContent> mDisplays = new ArrayList<>();
    // Stacks in z-order with the top most at the front of the list, starting with primary display.
    private final List<ActivityTask> mRootTasks = new ArrayList<>();
    // Windows in z-order with the top most at the front of the list.
    private final List<WindowState> mWindowStates = new ArrayList<>();
    private KeyguardControllerState mKeyguardControllerState;
    private final List<String> mPendingActivities = new ArrayList<>();
    private int mTopFocusedTaskId = -1;
    private int mFocusedDisplayId = DEFAULT_DISPLAY;
    private String mFocusedWindow = null;
    private String mFocusedApp = null;
    private Boolean mIsHomeRecentsComponent;
    private String mTopResumedActivityRecord = null;
    final List<String> mResumedActivitiesInStacks = new ArrayList<>();
    final List<String> mResumedActivitiesInDisplays = new ArrayList<>();
    private Rect mDefaultPinnedStackBounds = new Rect();
    private Rect mPinnedStackMovementBounds = new Rect();
    private String mInputMethodWindowAppToken = null;
    private boolean mDisplayFrozen;
    private boolean mSanityCheckFocusedWindow = true;

    static String appStateToString(int appState) {
        switch (appState) {
            case AppTransitionProto.APP_STATE_IDLE:
                return ""APP_STATE_IDLE"";
            case AppTransitionProto.APP_STATE_READY:
                return ""APP_STATE_READY"";
            case AppTransitionProto.APP_STATE_RUNNING:
                return ""APP_STATE_RUNNING"";
            case AppTransitionProto.APP_STATE_TIMEOUT:
                return ""APP_STATE_TIMEOUT"";
            default:
                fail(""Invalid AppTransitionState"");
                return null;
        }
    }

    static String appTransitionToString(int transition) {
        switch (transition) {
            case ViewProtoEnums.TRANSIT_UNSET: {
                return ""TRANSIT_UNSET"";
            }
            case ViewProtoEnums.TRANSIT_NONE: {
                return ""TRANSIT_NONE"";
            }
            case ViewProtoEnums.TRANSIT_ACTIVITY_OPEN: {
                return TRANSIT_ACTIVITY_OPEN;
            }
            case ViewProtoEnums.TRANSIT_ACTIVITY_CLOSE: {
                return TRANSIT_ACTIVITY_CLOSE;
            }
            case ViewProtoEnums.TRANSIT_TASK_OPEN: {
                return TRANSIT_TASK_OPEN;
            }
            case ViewProtoEnums.TRANSIT_TASK_CLOSE: {
                return TRANSIT_TASK_CLOSE;
            }
            case ViewProtoEnums.TRANSIT_TASK_TO_FRONT: {
                return ""TRANSIT_TASK_TO_FRONT"";
            }
            case ViewProtoEnums.TRANSIT_TASK_TO_BACK: {
                return ""TRANSIT_TASK_TO_BACK"";
            }
            case ViewProtoEnums.TRANSIT_WALLPAPER_CLOSE: {
                return TRANSIT_WALLPAPER_CLOSE;
            }
            case ViewProtoEnums.TRANSIT_WALLPAPER_OPEN: {
                return TRANSIT_WALLPAPER_OPEN;
            }
            case ViewProtoEnums.TRANSIT_WALLPAPER_INTRA_OPEN: {
                return TRANSIT_WALLPAPER_INTRA_OPEN;
            }
            case ViewProtoEnums.TRANSIT_WALLPAPER_INTRA_CLOSE: {
                return TRANSIT_WALLPAPER_INTRA_CLOSE;
            }
            case ViewProtoEnums.TRANSIT_TASK_OPEN_BEHIND: {
                return ""TRANSIT_TASK_OPEN_BEHIND"";
            }
            case ViewProtoEnums.TRANSIT_ACTIVITY_RELAUNCH: {
                return ""TRANSIT_ACTIVITY_RELAUNCH"";
            }
            case ViewProtoEnums.TRANSIT_DOCK_TASK_FROM_RECENTS: {
                return ""TRANSIT_DOCK_TASK_FROM_RECENTS"";
            }
            case ViewProtoEnums.TRANSIT_KEYGUARD_GOING_AWAY: {
                return TRANSIT_KEYGUARD_GOING_AWAY;
            }
            case ViewProtoEnums.TRANSIT_KEYGUARD_GOING_AWAY_ON_WALLPAPER: {
                return TRANSIT_KEYGUARD_GOING_AWAY_ON_WALLPAPER;
            }
            case ViewProtoEnums.TRANSIT_KEYGUARD_OCCLUDE: {
                return TRANSIT_KEYGUARD_OCCLUDE;
            }
            case ViewProtoEnums.TRANSIT_KEYGUARD_UNOCCLUDE: {
                return TRANSIT_KEYGUARD_UNOCCLUDE;
            }
            case ViewProtoEnums.TRANSIT_TRANSLUCENT_ACTIVITY_OPEN: {
                return TRANSIT_TRANSLUCENT_ACTIVITY_OPEN;
            }
            case ViewProtoEnums.TRANSIT_TRANSLUCENT_ACTIVITY_CLOSE: {
                return TRANSIT_TRANSLUCENT_ACTIVITY_CLOSE;
            }
            case ViewProtoEnums.TRANSIT_CRASHING_ACTIVITY_CLOSE: {
                return ""TRANSIT_CRASHING_ACTIVITY_CLOSE"";
            }
            default: {
                fail(""Invalid lastUsedAppTransition"");
                return null;
            }
        }
    }

    static boolean isValidNavBarType(WindowState navState) {
        return TYPE_NAVIGATION_BAR == navState.getType();
    }

    /**
     * For a given WindowContainer, traverse down the hierarchy and add all children of type
     * {@code T} to {@code outChildren}.
     */
    private static <T extends WindowContainer> void collectDescendantsOfType(Class<T> clazz,
            WindowContainer root, List<T> outChildren) {
        collectDescendantsOfTypeIf(clazz, t -> true, root, outChildren);
    }

    /**
     * For a given WindowContainer, traverse down the hierarchy and add all children of type
     * {@code T} to {@code outChildren} if the child passes the test {@code predicate}.
     */
    private static <T extends WindowContainer> void collectDescendantsOfTypeIf(Class<T> clazz,
            Predicate<T> predicate, WindowContainer root, List<T> outChildren) {
        // Traverse top to bottom
        for (int i = root.mChildren.size()-1; i >= 0; i--) {
            final WindowContainer child = root.mChildren.get(i);
            if (clazz.isInstance(child)) {
                if(predicate.test(clazz.cast(child))) {
                    outChildren.add(clazz.cast(child));
                }
            }
            collectDescendantsOfTypeIf(clazz, predicate, child, outChildren);
        }
    }

    /**
     * For a given WindowContainer, traverse down the hierarchy and add all immediate children of
     * type {@code T} to {@code outChildren}.
     */
    private static <T extends WindowContainer> void collectChildrenOfType(Class<T> clazz,
            WindowContainer root, List<T> outChildren) {
        for (int i = root.mChildren.size()-1; i >= 0; i--) {
            final WindowContainer child = root.mChildren.get(i);
            if (clazz.isInstance(child)) {
                outChildren.add(clazz.cast(child));
            }
        }
    }

    /** Enable/disable the mFocusedWindow check during the computeState.*/
    void setSanityCheckWithFocusedWindow(boolean sanityCheckFocusedWindow) {
        mSanityCheckFocusedWindow = sanityCheckFocusedWindow;
    }

    public void computeState() {
        // It is possible the system is in the middle of transition to the right state when we get
        // the dump. We try a few times to get the information we need before giving up.
        int retriesLeft = 3;
        boolean retry = false;
        byte[] dump = null;

        log(""=============================="");
        log(""     WindowManagerState     "");
        log(""=============================="");

        do {
            if (retry) {
                log(""***Incomplete AM state. Retrying..."");
                // Wait half a second between retries for activity manager to finish transitioning.
                SystemClock.sleep(500);
            }

            dump = executeShellCommand(DUMPSYS_WINDOW);
            try {
                parseSysDumpProto(dump);
            } catch (InvalidProtocolBufferNanoException ex) {
                throw new RuntimeException(""Failed to parse dumpsys:\n""
                        + new String(dump, StandardCharsets.UTF_8), ex);
            }

            retry = mRootTasks.isEmpty() || mTopFocusedTaskId == -1 || mWindowStates.isEmpty()
                    || mFocusedApp == null || (mSanityCheckFocusedWindow && mFocusedWindow == null)
                    || (mTopResumedActivityRecord == null || mResumedActivitiesInStacks.isEmpty())
                    && !mKeyguardControllerState.keyguardShowing;
        } while (retry && retriesLeft-- > 0);

        if (mRootTasks.isEmpty()) {
            logE(""No stacks found..."");
        }
        if (mTopFocusedTaskId == -1) {
            logE(""No focused stack found..."");
        }
        if (mTopResumedActivityRecord == null) {
            logE(""No focused activity found..."");
        }
        if (mResumedActivitiesInStacks.isEmpty()) {
            logE(""No resumed activities found..."");
        }
        if (mWindowStates.isEmpty()) {
            logE(""No Windows found..."");
        }
        if (mFocusedWindow == null) {
            logE(""No Focused Window..."");
        }
        if (mFocusedApp == null) {
            logE(""No Focused App..."");
        }
    }

    private byte[] executeShellCommand(String cmd) {
        try {
            ParcelFileDescriptor pfd = getInstrumentation().getUiAutomation()
                    .executeShellCommand(cmd);
            byte[] buf = new byte[512];
            int bytesRead;
            FileInputStream fis = new ParcelFileDescriptor.AutoCloseInputStream(pfd);
            ByteArrayOutputStream stdout = new ByteArrayOutputStream();
            while ((bytesRead = fis.read(buf)) != -1) {
                stdout.write(buf, 0, bytesRead);
            }
            fis.close();
            return stdout.toByteArray();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    /** Update WindowManagerState state for a newly added DisplayContent. */
    private void updateForDisplayContent(DisplayContent display) {
        if (display.mResumedActivity != null) {
            mResumedActivitiesInDisplays.add(display.mResumedActivity);
        }

        for (int i = 0; i < display.mRootTasks.size(); i++) {
            ActivityTask task = display.mRootTasks.get(i);
            mRootTasks.add(task);
            addResumedActivity(task);
        }

        if (display.mDefaultPinnedStackBounds != null) {
            mDefaultPinnedStackBounds = display.mDefaultPinnedStackBounds;
            mPinnedStackMovementBounds = display.mPinnedStackMovementBounds;
        }
    }

    private void addResumedActivity(ActivityTask task) {
        final int numChildTasks = task.mTasks.size();
        if (numChildTasks > 0) {
            for (int i = numChildTasks - 1; i >=0; i--) {
                addResumedActivity(task.mTasks.get(i));
            }
        } else if (task.mResumedActivity != null) {
            mResumedActivitiesInStacks.add(task.mResumedActivity);
        }
    }

    private void parseSysDumpProto(byte[] sysDump) throws InvalidProtocolBufferNanoException {
        reset();

        WindowManagerServiceDumpProto state = WindowManagerServiceDumpProto.parseFrom(sysDump);
        final RootWindowContainerProto root = state.rootWindowContainer;
        if (state.focusedWindow != null) {
            mFocusedWindow = state.focusedWindow.title;
        }
        mRoot = new RootWindowContainer(root);
        collectDescendantsOfType(DisplayContent.class, mRoot, mDisplays);
        for (int i = 0; i < mDisplays.size(); i++) {
            DisplayContent display = mDisplays.get(i);
            updateForDisplayContent(display);
        }
        mKeyguardControllerState = new KeyguardControllerState(root.keyguardController);
        mFocusedApp = state.focusedApp;
        mFocusedDisplayId = state.focusedDisplayId;
        final DisplayContent focusedDisplay = getDisplay(mFocusedDisplayId);
        if (focusedDisplay != null) {
            mTopFocusedTaskId = focusedDisplay.mFocusedRootTaskId;
            mTopResumedActivityRecord = focusedDisplay.mResumedActivity;
        }
        mIsHomeRecentsComponent = new Boolean(root.isHomeRecentsComponent);

        for (int i = 0; i < root.pendingActivities.length; i++) {
            mPendingActivities.add(root.pendingActivities[i].title);
        }

        collectDescendantsOfType(WindowState.class, mRoot, mWindowStates);

        if (state.inputMethodWindow != null) {
            mInputMethodWindowAppToken = Integer.toHexString(state.inputMethodWindow.hashCode);
        }
        mDisplayFrozen = state.displayFrozen;
    }

    private void reset() {
        mRoot = null;
        mDisplays.clear();
        mRootTasks.clear();
        mWindowStates.clear();
        mTopFocusedTaskId = -1;
        mFocusedDisplayId = DEFAULT_DISPLAY;
        mFocusedWindow = null;
        mFocusedApp = null;
        mTopResumedActivityRecord = null;
        mResumedActivitiesInStacks.clear();
        mResumedActivitiesInDisplays.clear();
        mKeyguardControllerState = null;
        mIsHomeRecentsComponent = null;
        mPendingActivities.clear();
        mDefaultPinnedStackBounds.setEmpty();
        mPinnedStackMovementBounds.setEmpty();
        mInputMethodWindowAppToken = null;
        mDisplayFrozen = false;
    }

    public String getFocusedApp() {
        return mFocusedApp;
    }

    public String getFocusedWindow() {
        return mFocusedWindow;
    }

    /** @return Whether the home activity is the recents component. */
    boolean isHomeRecentsComponent() {
        if (mIsHomeRecentsComponent == null) {
            computeState();
        }
        return mIsHomeRecentsComponent;
    }

    DisplayContent getDisplay(int displayId) {
        for (DisplayContent display : mDisplays) {
            if (display.mId == displayId) {
                return display;
            }
        }
        return null;
    }

    @Nullable
    DisplayArea getTaskDisplayArea(ComponentName activityName) {
        final List<DisplayArea> result = new ArrayList<>();
        for (DisplayContent display : mDisplays) {
            final DisplayArea tda = display.getTaskDisplayArea(activityName);
            if (tda != null) {
                result.add(tda);
            }
        }
        assertWithMessage(""There must be exactly one activity among all TaskDisplayAreas."")
                .that(result.size()).isAtMost(1);

        return result.stream().findFirst().orElse(null);
    }

    @Nullable
    DisplayArea getDisplayArea(String windowName) {
        final List<DisplayArea> result = new ArrayList<>();
        for (DisplayContent display : mDisplays) {
            final DisplayArea da = display.getDisplayArea(windowName);
            if (da != null) {
                result.add(da);
            }
        }
        assertWithMessage(""There must be exactly one window among all DisplayAreas."")
                .that(result.size()).isAtMost(1);

        return result.stream().findFirst().orElse(null);
    }

    int getFrontRootTaskId(int displayId) {
        return getDisplay(displayId).mRootTasks.get(0).mRootTaskId;
    }

    public int getFrontStackActivityType(int displayId) {
        return getDisplay(displayId).mRootTasks.get(0).getActivityType();
    }

    public int getFrontStackWindowingMode(int displayId) {
        return getDisplay(displayId).mRootTasks.get(0).getWindowingMode();
    }

    public String getTopActivityName(int displayId) {
        if (!getDisplay(displayId).mRootTasks.isEmpty()) {
            final ActivityTask topStack = getDisplay(displayId).mRootTasks.get(0);
            final ActivityTask topTask = topStack.getTopTask();
            if (!topTask.mActivities.isEmpty()) {
                return topTask.mActivities.get(0).name;
            }
        }
        return null;
    }

    int getFocusedStackId() {
        return mTopFocusedTaskId;
    }

    public int getFocusedStackActivityType() {
        final ActivityTask stack = getRootTask(mTopFocusedTaskId);
        return stack != null ? stack.getActivityType() : ACTIVITY_TYPE_UNDEFINED;
    }

    public int getFocusedStackWindowingMode() {
        final ActivityTask stack = getRootTask(mTopFocusedTaskId);
        return stack != null ? stack.getWindowingMode() : WINDOWING_MODE_UNDEFINED;
    }

    public String getFocusedActivity() {
        return mTopResumedActivityRecord;
    }

    public int getResumedActivitiesCount() {
        return mResumedActivitiesInStacks.size();
    }

    public int getResumedActivitiesCountInPackage(String packageName) {
        final String componentPrefix = packageName + ""/"";
        int count = 0;
        for (int i = mDisplays.size() - 1; i >= 0; --i) {
            final ArrayList<ActivityTask> mStacks = mDisplays.get(i).getRootTasks();
            for (int j = mStacks.size() - 1; j >= 0; --j) {
                final String resumedActivity = mStacks.get(j).mResumedActivity;
                if (resumedActivity != null && resumedActivity.startsWith(componentPrefix)) {
                    count++;
                }
            }
        }
        return count;
    }

    public String getResumedActivityOnDisplay(int displayId) {
        return getDisplay(displayId).mResumedActivity;
    }

    public KeyguardControllerState getKeyguardControllerState() {
        return mKeyguardControllerState;
    }

    public boolean containsStack(int windowingMode, int activityType) {
        return countStacks(windowingMode, activityType) > 0;
    }

    public int countStacks(int windowingMode, int activityType) {
        int count = 0;
        for (ActivityTask stack : mRootTasks) {
            if (activityType != ACTIVITY_TYPE_UNDEFINED
                    && activityType != stack.getActivityType()) {
                continue;
            }
            if (windowingMode != WINDOWING_MODE_UNDEFINED
                    && windowingMode != stack.getWindowingMode()) {
                continue;
            }
            ++count;
        }
        return count;
    }

    public ActivityTask getRootTask(int taskId) {
        for (ActivityTask stack : mRootTasks) {
            if (taskId == stack.mRootTaskId) {
                return stack;
            }
        }
        return null;
    }

    public ActivityTask getStackByActivityType(int activityType) {
        for (ActivityTask stack : mRootTasks) {
            if (activityType == stack.getActivityType()) {
                return stack;
            }
        }
        return null;
    }

    public ActivityTask getStandardStackByWindowingMode(int windowingMode) {
        for (ActivityTask stack : mRootTasks) {
            if (stack.getActivityType() != ACTIVITY_TYPE_STANDARD) {
                continue;
            }
            if (stack.getWindowingMode() == windowingMode) {
                return stack;
            }
        }
        return null;
    }

    public int getStandardTaskCountByWindowingMode(int windowingMode) {
        int count = 0;
        for (ActivityTask stack : mRootTasks) {
            if (stack.getActivityType() != ACTIVITY_TYPE_STANDARD) {
                continue;
            }
            if (stack.getWindowingMode() == windowingMode) {
                count += stack.mTasks.isEmpty() ? 1 : stack.mTasks.size();
            }
        }
        return count;
    }

    /** Get the stack position on its display. */
    int getStackIndexByActivityType(int activityType) {
        for (DisplayContent display : mDisplays) {
            for (int i = 0; i < display.mRootTasks.size(); i++) {
                if (activityType == display.mRootTasks.get(i).getActivityType()) {
                    return i;
                }
            }
        }
        return -1;
    }

    /** Get the stack on its display. */
    ActivityTask getStackByActivity(ComponentName activityName) {
        for (DisplayContent display : mDisplays) {
            for (int i = display.mRootTasks.size() - 1; i >= 0; --i) {
                final ActivityTask stack = display.mRootTasks.get(i);
                if (stack.containsActivity(activityName)) return stack;
            }
        }
        return null;
    }

    /** Get display id by activity on it. */
    public int getDisplayByActivity(ComponentName activityComponent) {
        final ActivityTask task = getTaskByActivity(activityComponent);
        if (task == null) {
            return -1;
        }
        return getRootTask(task.mRootTaskId).mDisplayId;
    }

    List<DisplayContent> getDisplays() {
        return new ArrayList<>(mDisplays);
    }

    public List<ActivityTask> getRootTasks() {
        return new ArrayList<>(mRootTasks);
    }

    public int getStackCount() {
        return mRootTasks.size();
    }

    public int getDisplayCount() {
        return mDisplays.size();
    }

    public boolean containsActivity(ComponentName activityName) {
        for (ActivityTask stack : mRootTasks) {
            if (stack.containsActivity(activityName)) return true;
        }
        return false;
    }

    public boolean containsNoneOf(Iterable<ComponentName> activityNames) {
        for (ComponentName activityName : activityNames) {
            for (ActivityTask stack : mRootTasks) {
                if (stack.containsActivity(activityName)) return false;
            }
        }
        return true;
    }

    public boolean containsActivityInWindowingMode(ComponentName activityName, int windowingMode) {
        for (ActivityTask stack : mRootTasks) {
            final Activity activity = stack.getActivity(activityName);
            if (activity != null && activity.getWindowingMode() == windowingMode) {
                return true;
            }
        }
        return false;
    }

    public boolean isActivityVisible(ComponentName activityName) {
        for (ActivityTask stack : mRootTasks) {
            final Activity activity = stack.getActivity(activityName);
            if (activity != null) return activity.visible;
        }
        return false;
    }

    public boolean isActivityTranslucent(ComponentName activityName) {
        for (ActivityTask stack : mRootTasks) {
            final Activity activity = stack.getActivity(activityName);
            if (activity != null) return activity.translucent;
        }
        return false;
    }

    public boolean isBehindOpaqueActivities(ComponentName activityName) {
        final String fullName = getActivityName(activityName);
        for (ActivityTask stack : mRootTasks) {
            final Activity activity =
                    stack.getActivity((a) -> a.name.equals(fullName) || !a.translucent);
            if (activity != null) {
                if (activity.name.equals(fullName)) {
                    return false;
                }
                if (!activity.translucent) {
                    return true;
                }
            }
        }

        return false;
    }

    public boolean containsStartedActivities() {
        for (ActivityTask stack : mRootTasks) {
            final Activity activity = stack.getActivity(
                    (a) -> !a.state.equals(STATE_STOPPED) && !a.state.equals(STATE_DESTROYED));
            if (activity != null) return true;
        }
        return false;
    }

    boolean hasActivityState(ComponentName activityName, String activityState) {
        for (ActivityTask stack : mRootTasks) {
            final Activity activity = stack.getActivity(activityName);
            if (activity != null) return activity.state.equals(activityState);
        }
        return false;
    }

    int getActivityProcId(ComponentName activityName) {
        for (ActivityTask stack : mRootTasks) {
            final Activity activity = stack.getActivity(activityName);
            if (activity != null) return activity.procId;
        }
        return -1;
    }

    boolean isRecentsActivityVisible() {
        final Activity recentsActivity = getRecentsActivity();
        return recentsActivity != null && recentsActivity.visible;
    }

    ComponentName getHomeActivityName() {
        Activity activity = getHomeActivity();
        if (activity == null) {
            return null;
        }
        return ComponentName.unflattenFromString(activity.name);
    }

    ActivityTask getDreamTask() {
        final ActivityTask dreamStack = getStackByActivityType(ACTIVITY_TYPE_DREAM);
        if (dreamStack != null) {
            return dreamStack.getTopTask();
        }
        return null;
    }

    ActivityTask getHomeTask() {
        final ActivityTask homeStack = getStackByActivityType(ACTIVITY_TYPE_HOME);
        if (homeStack != null) {
            return homeStack.getTopTask();
        }
        return null;
    }

    private ActivityTask getRecentsTask() {
        final ActivityTask recentsStack = getStackByActivityType(ACTIVITY_TYPE_RECENTS);
        if (recentsStack != null) {
            return recentsStack.getTopTask();
        }
        return null;
    }

    private Activity getHomeActivity() {
        final ActivityTask homeTask = getHomeTask();
        return homeTask != null ? homeTask.mActivities.get(homeTask.mActivities.size() - 1) : null;
    }

    private Activity getRecentsActivity() {
        final ActivityTask recentsTask = getRecentsTask();
        return recentsTask != null ? recentsTask.mActivities.get(recentsTask.mActivities.size() - 1)
                : null;
    }

    public int getRootTaskIdByActivity(ComponentName activityName) {
        final ActivityTask task = getTaskByActivity(activityName);
        return  (task == null) ? INVALID_STACK_ID : task.mRootTaskId;
    }

    public ActivityTask getTaskByActivity(ComponentName activityName) {
        return getTaskByActivity(
                activityName, WINDOWING_MODE_UNDEFINED, new int[]{ INVALID_TASK_ID });
    }

    public ActivityTask getTaskByActivity(ComponentName activityName, int[] excludeTaskIds) {
        return getTaskByActivity(activityName, WINDOWING_MODE_UNDEFINED, excludeTaskIds);
    }

    private ActivityTask getTaskByActivity(ComponentName activityName, int windowingMode,
            int[] excludeTaskIds) {
        Activity activity = getActivity(activityName, windowingMode, excludeTaskIds);
        return activity == null ? null : activity.task;
    }

    public Activity getActivity(ComponentName activityName) {
        return getActivity(activityName, WINDOWING_MODE_UNDEFINED, new int[]{ INVALID_TASK_ID });
    }

    private Activity getActivity(ComponentName activityName, int windowingMode,
            int[] excludeTaskIds) {
        for (ActivityTask stack : mRootTasks) {
            if (windowingMode == WINDOWING_MODE_UNDEFINED
                    || windowingMode == stack.getWindowingMode()) {
                Activity activity = stack.getActivity(activityName, excludeTaskIds);
                if (activity != null) return activity;
            }
        }
        return null;
    }

    /**
     * Get the number of activities in the task, with the option to count only activities with
     * specific name.
     * @param taskId Id of the task where we're looking for the number of activities.
     * @param activityName Optional name of the activity we're interested in.
     * @return Number of all activities in the task if activityName is {@code null}, otherwise will
     *         report number of activities that have specified name.
     */
    public int getActivityCountInTask(int taskId, @Nullable ComponentName activityName) {
        // If activityName is null, count all activities in the task.
        // Otherwise count activities that have specified name.
        for (ActivityTask stack : mRootTasks) {
            final ActivityTask task = stack.getTask(taskId);
            if (task == null) continue;

            if (activityName == null) {
                return task.mActivities.size();
            }
            final String fullName = getActivityName(activityName);
            int count = 0;
            for (Activity activity : task.mActivities) {
                if (activity.name.equals(fullName)) {
                    count++;
                }
            }
            return count;
        }
        return 0;
    }

    public int getRootTasksCount() {
        return mRootTasks.size();
    }

    public int getRootTasksCount(int displayId) {
        return getRootTasksCount(t -> t.mDisplayId == displayId);
    }

    /**
     * Count root tasks filtered by the predicate passed as argument.
     */
    public int getRootTasksCount(Predicate<? super ActivityTask> predicate) {
        return (int) mRootTasks.stream().filter(predicate).count();
    }

    boolean pendingActivityContain(ComponentName activityName) {
        return mPendingActivities.contains(getActivityName(activityName));
    }

    // Get the logical display size of the default display.
    public static Point getLogicalDisplaySize() {
        WindowManagerState mWmState = new WindowManagerState();
        mWmState.computeState();
        Rect size = mWmState.getDisplay(DEFAULT_DISPLAY).getDisplayRect();
        return new Point(size.width(), size.height());
    }

    String getDefaultDisplayLastTransition() {
        return getDisplay(DEFAULT_DISPLAY).getLastTransition();
    }

    String getDefaultDisplayAppTransitionState() {
        return getDisplay(DEFAULT_DISPLAY).getAppTransitionState();
    }

    public List<WindowState> getMatchingVisibleWindowState(final String windowName) {
        return getMatchingWindows(ws -> ws.isSurfaceShown() && windowName.equals(ws.getName()))
                .collect(Collectors.toList());
    }

    private Stream<WindowState> getMatchingWindows(Predicate<WindowState> condition) {
        return mWindowStates.stream().filter(condition);
    }

    @Nullable
    public WindowState getWindowByPackageName(String packageName, int windowType) {
        final List<WindowState> windowList = getWindowsByPackageName(packageName, windowType);
        return windowList.isEmpty() ? null : windowList.get(0);
    }

    public List<WindowState> getWindowsByPackageName(String packageName, int... restrictToTypes) {
        return getMatchingWindows(ws ->
                (ws.getName().equals(packageName) || ws.getName().startsWith(packageName + ""/""))
                        && Arrays.stream(restrictToTypes).anyMatch(type -> type == ws.getType()))
                .collect(Collectors.toList());
    }

    public boolean hasNotificationShade() {
        computeState();
        return !getMatchingWindowType(TYPE_NOTIFICATION_SHADE).isEmpty();
    }

    List<WindowState> getWindows() {
        return new ArrayList<>(mWindowStates);
    }

    List<WindowState> getMatchingWindowType(int type) {
        return getMatchingWindows(ws -> type == ws.mType).collect(Collectors.toList());
    }

    List<String> getMatchingWindowTokens(final String windowName) {
        return getMatchingWindows(ws -> windowName.equals(ws.getName()))
                .map(WindowState::getToken)
                .collect(Collectors.toList());
    }

    List<WindowState> getAllNavigationBarStates() {
        return getMatchingWindows(WindowManagerState::isValidNavBarType)
                .collect(Collectors.toList());
    }

    WindowState getAndAssertSingleNavBarWindowOnDisplay(int displayId) {
        List<WindowState> navWindow = getMatchingWindows(ws ->
                WindowManagerState.isValidNavBarType(ws) && ws.getDisplayId() == displayId)
                .collect(Collectors.toList());

        // We may need some time to wait for nav bar showing.
        // It's Ok to get 0 nav bar here.
        assertTrue(""There should be at most one navigation bar on a display"",
                navWindow.size() <= 1);

        return navWindow.isEmpty() ? null : navWindow.get(0);
    }

    WindowState getWindowStateForAppToken(String appToken) {
        return getMatchingWindows(ws -> ws.getToken().equals(appToken))
                .findFirst()
                .orElse(null);
    }

    String getFrontWindow() {
        if (mWindowStates == null || mWindowStates.isEmpty()) {
            return null;
        }
        return mWindowStates.get(0).getName();
    }

    /** Check if there exists a window record with matching windowName. */
    public boolean containsWindow(String windowName) {
        for (WindowState window : mWindowStates) {
            if (window.getName().equals(windowName)) {
                return true;
            }
        }
        return false;
    }

    /** Check if at least one window which matches the specified name has shown it's surface. */
    public boolean isWindowSurfaceShown(String windowName) {
        for (WindowState window : mWindowStates) {
            if (window.getName().equals(windowName)) {
                if (window.isSurfaceShown()) {
                    return true;
                }
            }
        }
        return false;
    }

    /** Check if at least one window which matches provided window name is visible. */
    public boolean isWindowVisible(String windowName) {
        for (WindowState window : mWindowStates) {
            if (window.getName().equals(windowName)) {
                if (window.isVisible()) {
                    return true;
                }
            }
        }
        return false;
    }

    public boolean allWindowSurfacesShown(String windowName) {
        boolean allShown = false;
        for (WindowState window : mWindowStates) {
            if (window.getName().equals(windowName)) {
                if (!window.isSurfaceShown()) {
                    log(""[VISIBLE] not visible"" + windowName);
                    return false;
                }
                log(""[VISIBLE] visible"" + windowName);
                allShown = true;
            }
        }
        return allShown;
    }

    /** Checks whether the display contains the given activity. */
    boolean hasActivityInDisplay(int displayId, ComponentName activityName) {
        for (WindowManagerState.ActivityTask stack : getDisplay(displayId).getRootTasks()) {
            if (stack.containsActivity(activityName)) {
                return true;
            }
        }
        return false;
    }

    WindowState findFirstWindowWithType(int type) {
        for (WindowState window : mWindowStates) {
            if (window.getType() == type) {
                return window;
            }
        }
        return null;
    }

    public int getZOrder(WindowState w) {
        return mWindowStates.size() - mWindowStates.indexOf(w);
    }

    ActivityTask getStandardRootTaskByWindowingMode(int windowingMode) {
        for (ActivityTask task : mRootTasks) {
            if (task.getActivityType() != ACTIVITY_TYPE_STANDARD) {
                continue;
            }
            if (task.getWindowingMode() == windowingMode) {
                return task;
            }
        }
        return null;
    }

    WindowManagerState.WindowState getInputMethodWindowState() {
        return getWindowStateForAppToken(mInputMethodWindowAppToken);
    }

    public boolean isDisplayFrozen() {
        return mDisplayFrozen;
    }

    public int getRotation() {
        return getDisplay(DEFAULT_DISPLAY).mRotation;
    }

    public int getLastOrientation() {
        return getDisplay(DEFAULT_DISPLAY).mLastOrientation;
    }

    public int getFocusedDisplayId() {
        return mFocusedDisplayId;
    }

    public static class DisplayContent extends DisplayArea {
        public int mId;
        ArrayList<ActivityTask> mRootTasks = new ArrayList<>();
        int mFocusedRootTaskId;
        String mResumedActivity;
        boolean mSingleTaskInstance;
        Rect mDefaultPinnedStackBounds = null;
        Rect mPinnedStackMovementBounds = null;

        private Rect mDisplayRect = new Rect();
        private Rect mAppRect = new Rect();
        private int mDpi;
        private int mFlags;
        private String mName;
        private int mSurfaceSize;
        private String mFocusedApp;
        private String mLastTransition;
        private String mAppTransitionState;
        private int mRotation;
        private boolean mFrozenToUserRotation;
        private int mUserRotation;
        private int mFixedToUserRotationMode;
        private int mLastOrientation;

        DisplayContent(DisplayContentProto proto) {
            super(proto.rootDisplayArea);
            mId = proto.id;
            mFocusedRootTaskId = proto.focusedRootTaskId;
            mSingleTaskInstance = proto.singleTaskInstance;
            if (proto.resumedActivity != null) {
                mResumedActivity = proto.resumedActivity.title;
            }
            addRootTasks();

            mDpi = proto.dpi;
            DisplayInfoProto infoProto = proto.displayInfo;
            if (infoProto != null) {
                mDisplayRect.set(0, 0, infoProto.logicalWidth, infoProto.logicalHeight);
                mAppRect.set(0, 0, infoProto.appWidth, infoProto.appHeight);
                mName = infoProto.name;
                mFlags = infoProto.flags;
            }
            final DisplayFramesProto displayFramesProto = proto.displayFrames;
            mSurfaceSize = proto.surfaceSize;
            mFocusedApp = proto.focusedApp;

            final AppTransitionProto appTransitionProto = proto.appTransition;
            int appState = 0;
            int lastTransition = 0;
            if (appTransitionProto != null) {
                appState = appTransitionProto.appTransitionState;
                lastTransition = appTransitionProto.lastUsedAppTransition;
            }
            mAppTransitionState = appStateToString(appState);
            mLastTransition = appTransitionToString(lastTransition);

            PinnedTaskControllerProto pinnedTaskProto = proto.pinnedTaskController;
            if (pinnedTaskProto != null) {
                mDefaultPinnedStackBounds = extract(pinnedTaskProto.defaultBounds);
                mPinnedStackMovementBounds = extract(pinnedTaskProto.movementBounds);
            }

            final DisplayRotationProto rotationProto = proto.displayRotation;
            if (rotationProto != null) {
                mRotation = rotationProto.rotation;
                mFrozenToUserRotation = rotationProto.frozenToUserRotation;
                mUserRotation = rotationProto.userRotation;
                mFixedToUserRotationMode = rotationProto.fixedToUserRotationMode;
                mLastOrientation = rotationProto.lastOrientation;
            }
        }

        public String getName() {
            return mName;
        }

        private void addRootTasks() {
            // TODO(b/149338177): figure out how CTS tests deal with organizer. For now,
            //                    don't treat them as regular stacks
            collectDescendantsOfTypeIf(ActivityTask.class, t -> t.isRootTask(), this,
                    mRootTasks);
            ArrayList<ActivityTask> rootOrganizedTasks = new ArrayList<>();
            for (int i = mRootTasks.size() -1; i >= 0; --i) {
                final ActivityTask task = mRootTasks.get(i);
                // Skip tasks created by an organizer
                if (task.mCreatedByOrganizer) {
                    mRootTasks.remove(task);
                    rootOrganizedTasks.add(task);
                }
            }
            // Add root tasks controlled by an organizer
            while (rootOrganizedTasks.size() > 0) {
                final ActivityTask task = rootOrganizedTasks.remove(0);
                for (int i = task.mChildren.size() - 1; i >= 0; i--) {
                    final ActivityTask child = (ActivityTask) task.mChildren.get(i);
                    if (!child.mCreatedByOrganizer) {
                        mRootTasks.add(child);
                    } else {
                        rootOrganizedTasks.add(child);
                    }
                }
            }
        }

        boolean containsActivity(ComponentName activityName) {
            for (ActivityTask task : mRootTasks) {
                if (task.containsActivity(activityName)) return true;
            }
            return false;
        }

        List<DisplayArea> getAllTaskDisplayAreas() {
            final List<DisplayArea> taskDisplayAreas = new ArrayList<>();
            collectDescendantsOfTypeIf(DisplayArea.class, DisplayArea::isTaskDisplayArea, this,
                    taskDisplayAreas);
            return taskDisplayAreas;
        }

        @Nullable
        DisplayArea getTaskDisplayArea(ComponentName activityName) {
            final List<DisplayArea> taskDisplayAreas = getAllTaskDisplayAreas();
            List<DisplayArea> result = taskDisplayAreas.stream().filter(
                    tda -> tda.containsActivity(activityName))
                    .collect(Collectors.toList());

            assertWithMessage(""There must be exactly one activity among all TaskDisplayAreas."")
                    .that(result.size()).isAtMost(1);

            return result.stream().findFirst().orElse(null);
        }

        List<DisplayArea> getAllChildDisplayAreas() {
            final List<DisplayArea> displayAreas = new ArrayList<>();
            collectDescendantsOfType(DisplayArea.class,this, displayAreas);
            return displayAreas;
        }

        @Nullable
        DisplayArea getDisplayArea(String windowName) {
            List<DisplayArea> displayAreas = new ArrayList<>();
            final Predicate<DisplayArea> p = da -> {
                final boolean containsChildWindowToken = !da.mChildren.isEmpty()
                        && da.mChildren.get(0) instanceof WindowToken;
                return !da.isTaskDisplayArea() && containsChildWindowToken;
            };
            collectDescendantsOfTypeIf(DisplayArea.class, p, this, displayAreas);
            List<DisplayArea> result = displayAreas.stream().filter(
                    da -> da.containsWindow(windowName))
                    .collect(Collectors.toList());

            assertWithMessage(""There must be exactly one window among all DisplayAreas."")
                    .that(result.size()).isAtMost(1);

            return result.stream().findFirst().orElse(null);
        }

        ArrayList<ActivityTask> getRootTasks() {
            return mRootTasks;
        }

        int getDpi() {
            return mDpi;
        }

        Rect getDisplayRect() {
            return mDisplayRect;
        }

        int getFlags() {
            return mFlags;
        }

        int getSurfaceSize() {
            return mSurfaceSize;
        }

        String getFocusedApp() {
            return mFocusedApp;
        }

        String getLastTransition() { return mLastTransition; }

        String getAppTransitionState() { return mAppTransitionState; }

        @Override
        public String toString() {
            return ""Display #"" + mId + "": name="" + mName + "" mDisplayRect="" + mDisplayRect
                    + "" mAppRect="" + mAppRect + "" mFlags="" + mFlags;
        }
    }

    public static class ActivityTask extends ActivityContainer {

        int mTaskId;
        int mRootTaskId;
        public int mDisplayId;
        Rect mLastNonFullscreenBounds;
        String mRealActivity;
        String mOrigActivity;
        ArrayList<ActivityTask> mTasks = new ArrayList<>();
        ArrayList<Activity> mActivities = new ArrayList<>();
        int mTaskType;
        private int mResizeMode;
        String mResumedActivity;
        boolean mAnimatingBounds;
        private int mSurfaceWidth;
        private int mSurfaceHeight;
        boolean mCreatedByOrganizer;
        String mAffinity;
        boolean mHasChildPipActivity;

        ActivityTask(TaskProto proto) {
            super(proto.windowContainer);
            mTaskId = proto.id;
            mRootTaskId = proto.rootTaskId;
            mDisplayId = proto.displayId;
            mLastNonFullscreenBounds = extract(proto.lastNonFullscreenBounds);
            mRealActivity = proto.realActivity;
            mOrigActivity = proto.origActivity;
            mTaskType = proto.activityType;
            mResizeMode = proto.resizeMode;
            mFullscreen = proto.fillsParent;
            mBounds = extract(proto.bounds);
            mMinWidth = proto.minWidth;
            mMinHeight = proto.minHeight;
            mAnimatingBounds = proto.animatingBounds;
            mSurfaceWidth = proto.surfaceWidth;
            mSurfaceHeight = proto.surfaceHeight;
            mCreatedByOrganizer = proto.createdByOrganizer;
            mAffinity = proto.affinity;
            mHasChildPipActivity = proto.hasChildPipActivity;

            if (proto.resumedActivity != null) {
                mResumedActivity = proto.resumedActivity.title;
            }

            collectChildrenOfType(ActivityTask.class, this, mTasks);
            collectChildrenOfType(Activity.class, this, mActivities);
        }

        boolean isEmpty() {
            return mTasks.isEmpty() && mActivities.isEmpty();
        }

        public int getResizeMode() {
            return mResizeMode;
        }

        public int getTaskId() {
            return mTaskId;
        }
        boolean isRootTask() {
            return mTaskId == mRootTaskId;
        }

        boolean isLeafTask() {
            return mTasks.size() == 0;
        }

        public int getRootTaskId() {
            return mRootTaskId;
        }

        int getSurfaceWidth() {
            return mSurfaceWidth;
        }

        int getSurfaceHeight() {
            return mSurfaceHeight;
        }

        public ArrayList<Activity> getActivities() {
            return mActivities;
        }

        /** @return the top task in the stack. */
        ActivityTask getTopTask() {
            // NOTE: Unlike the WindowManager internals, we dump the state from top to bottom,
            //       so the indices are inverted
            return getTask((t) -> true);
        }

        public String getResumedActivity() {
            return mResumedActivity;
        }

        public List<ActivityTask> getTasks() {
            return new ArrayList<>(mTasks);
        }

        ActivityTask getTask(Predicate<ActivityTask> predicate) {
            for (ActivityTask task : mTasks) {
                if (predicate.test(task)) return task;
            }
            return predicate.test(this) ? this : null;
        }

        ActivityTask getTask(int taskId) {
            return getTask((t) -> t.mTaskId == taskId);
        }

        void forAllTasks(Consumer<ActivityTask> consumer) {
            for (ActivityTask task : mTasks) {
                consumer.accept(task);
            }
            consumer.accept(this);
        }

        Activity getActivity(Predicate<Activity> predicate) {
            for (Activity activity : mActivities) {
                if (predicate.test(activity)) return activity;
            }
            for (ActivityTask task : mTasks) {
                final Activity activity = task.getActivity(predicate);
                if (activity != null) return activity;
            }
            return null;
        }

        public Activity getActivity(ComponentName activityName) {
            final String fullName = getActivityName(activityName);
            return getActivity((activity) -> activity.name.equals(fullName));
        }

        public Activity getActivity(ComponentName activityName, int[] excludeTaskIds) {
            final String fullName = getActivityName(activityName);
            return getActivity((activity) -> {
                if (!activity.name.equals(fullName)) {
                    return false;
                }
                for (int excludeTaskId : excludeTaskIds) {
                    if (activity.task.mTaskId == excludeTaskId) {
                        return false;
                    }
                }
                return true;
            });
        }

        boolean containsActivity(ComponentName activityName) {
            return getActivity(activityName) != null;
        }

        @Override
        int getActivityType() {
            return mTaskType;
        }
    }

    public static class Activity extends ActivityContainer {

        String name;
        String state;
        boolean visible;
        boolean frontOfTask;
        boolean inSizeCompatMode;
        float minAspectRatio;
        int procId = -1;
        public boolean translucent;
        ActivityTask task;

        Activity(ActivityRecordProto proto, WindowContainer parent) {
            super(proto.windowToken.windowContainer);
            task = (ActivityTask) parent;
            name = proto.name;
            state = proto.state;
            visible = proto.visible;
            frontOfTask = proto.frontOfTask;
            inSizeCompatMode = proto.inSizeCompatMode;
            minAspectRatio = proto.minAspectRatio;
            if (proto.procId != 0) {
                procId = proto.procId;
            }
            translucent = proto.translucent;
        }

        public String getName() {
            return name;
        }

        public String getState() {
            return state;
        }

        public boolean inSizeCompatMode() {
            return inSizeCompatMode;
        }

        public float getMinAspectRatio() {
            return minAspectRatio;
        }

        @Override
        public Rect getBounds() {
            if (mBounds == null) {
                return mFullConfiguration.windowConfiguration.getBounds();
            }
            return mBounds;
        }

        public Rect getMaxBounds() {
            return mFullConfiguration.windowConfiguration.getMaxBounds();
        }

        public Rect getAppBounds() {
            return mFullConfiguration.windowConfiguration.getAppBounds();
        }
    }

    static abstract class ActivityContainer extends WindowContainer {
        protected boolean mFullscreen;
        protected Rect mBounds;
        protected int mMinWidth = -1;
        protected int mMinHeight = -1;

        ActivityContainer(WindowContainerProto proto) {
            super(proto);
        }

        public Rect getBounds() {
            return mBounds;
        }

        boolean isFullscreen() {
            return mFullscreen;
        }

        int getMinWidth() {
            return mMinWidth;
        }

        int getMinHeight() {
            return mMinHeight;
        }
    }

    static class KeyguardControllerState {

        boolean aodShowing = false;
        boolean keyguardShowing = false;
        SparseArray<Boolean> mKeyguardOccludedStates = new SparseArray<>();

        KeyguardControllerState(KeyguardControllerProto proto) {
            if (proto != null) {
                aodShowing = proto.aodShowing;
                keyguardShowing = proto.keyguardShowing;
                for (int i = 0;  i < proto.keyguardOccludedStates.length; i++) {
                    mKeyguardOccludedStates.append(proto.keyguardOccludedStates[i].displayId,
                            proto.keyguardOccludedStates[i].keyguardOccluded);
                }
            }
        }

        boolean isKeyguardOccluded(int displayId) {
            if (mKeyguardOccludedStates.get(displayId) != null) {
                return mKeyguardOccludedStates.get(displayId);
            }
            return false;
        }
    }

    static class ConfigurationContainer {
        final Configuration mOverrideConfiguration = new Configuration();
        final Configuration mFullConfiguration = new Configuration();
        final Configuration mMergedOverrideConfiguration = new Configuration();

        ConfigurationContainer(ConfigurationContainerProto proto) {
            if (proto == null) {
                return;
            }
            mOverrideConfiguration.setTo(extract(proto.overrideConfiguration));
            mFullConfiguration.setTo(extract(proto.fullConfiguration));
            mMergedOverrideConfiguration.setTo(extract(proto.mergedOverrideConfiguration));
        }

        boolean isWindowingModeCompatible(int requestedWindowingMode) {
            if (requestedWindowingMode == WINDOWING_MODE_UNDEFINED) {
                return true;
            }
            return getWindowingMode() == requestedWindowingMode;
        }

        public int getWindowingMode() {
            if (mFullConfiguration == null) {
                return WINDOWING_MODE_UNDEFINED;
            }
            return mFullConfiguration.windowConfiguration.getWindowingMode();
        }

        int getActivityType() {
            if (mFullConfiguration == null) {
                return ACTIVITY_TYPE_UNDEFINED;
            }
            return mFullConfiguration.windowConfiguration.getActivityType();
        }
    }

    public static class RootWindowContainer extends WindowContainer {
        RootWindowContainer(RootWindowContainerProto proto) {
            super(proto.windowContainer);
        }
    }
    public static class DisplayArea extends WindowContainer {
        private final boolean mIsTaskDisplayArea;
        private final boolean mIsRootDisplayArea;
        private final int mFeatureId;
        private final boolean mIsOrganized;
        private ArrayList<Activity> mActivities;
        private final ArrayList<WindowState> mWindows = new ArrayList<>();

        DisplayArea(DisplayAreaProto proto) {
            super(proto.windowContainer);
            mIsTaskDisplayArea = proto.isTaskDisplayArea;
            mIsRootDisplayArea = proto.isRootDisplayArea;
            mFeatureId = proto.featureId;
            mIsOrganized = proto.isOrganized;
            if (mIsTaskDisplayArea) {
                mActivities = new ArrayList<>();
                collectDescendantsOfType(Activity.class, this, mActivities);
            }
            collectDescendantsOfType(WindowState.class, this, mWindows);
        }

        boolean isTaskDisplayArea() {
            return mIsTaskDisplayArea;
        }

        boolean isRootDisplayArea() {
            return mIsRootDisplayArea;
        }

        int getFeatureId() {
            return mFeatureId;
        }

        boolean isOrganized() {
            return mIsOrganized;
        }

        @Override
        public Rect getBounds() {
            if (mBounds == null) {
                return mFullConfiguration.windowConfiguration.getBounds();
            }
            return mBounds;
        }

        boolean containsActivity(ComponentName activityName) {
            if (!mIsTaskDisplayArea) {
                return false;
            }

            final String fullName = getActivityName(activityName);
            for (Activity a : mActivities) {
                if (a.name.equals(fullName)) {
                    return true;
                }
            }
            return false;
        }

        boolean containsWindow(String windowName) {
            for (WindowState w : mWindows) {
                if (w.mName.equals(windowName)) {
                    return true;
                }
            }
            return false;
        }
    }
    public static class WindowToken extends WindowContainer {
        WindowToken(WindowTokenProto proto) {
            super(proto.windowContainer);
        }
    }

    /**
     * Represents WindowContainer classes such as DisplayContent.WindowContainers and
     * DisplayContent.NonAppWindowContainers. This can be expanded into a specific class
     * if we need track and assert some state in the future.
     */
    public static class GenericWindowContainer extends WindowContainer {
        GenericWindowContainer(WindowContainerProto proto) {
            super(proto);
        }
    }

    static WindowContainer getWindowContainer(WindowContainerChildProto proto,
            WindowContainer parent) {
        if (proto.displayContent != null) {
            return new DisplayContent(proto.displayContent);
        }

        if (proto.displayArea != null) {
            return new DisplayArea(proto.displayArea);
        }

        if (proto.task != null) {
            return new ActivityTask(proto.task);
        }

        if (proto.activity != null) {
            return new Activity(proto.activity, parent);
        }

        if (proto.windowToken != null) {
            return new WindowToken(proto.windowToken);
        }

        if (proto.window != null) {
            return new WindowState(proto.window);
        }

        if (proto.windowContainer != null) {
            return new GenericWindowContainer(proto.windowContainer);
        }
        return null;
    }

    static abstract class WindowContainer extends ConfigurationContainer {

        protected String mName;
        protected final String mAppToken;
        protected boolean mFullscreen;
        protected Rect mBounds;
        protected int mOrientation;
        protected boolean mVisible;
        protected List<WindowState> mSubWindows = new ArrayList<>();
        protected List<WindowContainer> mChildren = new ArrayList<>();

        WindowContainer(WindowContainerProto proto) {
            super(proto.configurationContainer);
            IdentifierProto identifierProto = proto.identifier;
            mName = identifierProto.title;
            mAppToken = Integer.toHexString(identifierProto.hashCode);
            mOrientation = proto.orientation;
            for (int i = 0; i < proto.children.length; i++) {
                final WindowContainer child = getWindowContainer(proto.children[i], this);
                if (child != null) {
                    mChildren.add(child);
                }
            }
            mVisible = proto.visible;
        }

        @NonNull
        public String getName() {
            return mName;
        }

        @NonNull
        public String getPackageName() {
            int sep = mName.indexOf('/');
            return sep == -1 ? mName : mName.substring(0, sep);
        }

        String getToken() {
            return mAppToken;
        }

        Rect getBounds() {
            return mBounds;
        }

        boolean isFullscreen() {
            return mFullscreen;
        }

        boolean isVisible() {
            return mVisible;
        }

        List<WindowState> getWindows() {
            return mSubWindows;
        }
    }

    public static class WindowState extends WindowContainer {

        private static final int WINDOW_TYPE_NORMAL = 0;
        public static final int WINDOW_TYPE_STARTING = 1;
        private static final int WINDOW_TYPE_EXITING = 2;
        private static final int WINDOW_TYPE_DEBUGGER = 3;

        private final int mWindowType;
        private int mType = 0;
        private int mDisplayId;
        private int mStackId;
        private int mLayer;
        private boolean mShown;
        private Rect mContainingFrame;
        private Rect mParentFrame;
        private Rect mFrame;
        private Rect mCompatFrame;
        private Rect mSurfaceInsets = new Rect();
        private Rect mGivenContentInsets = new Rect();
        private Rect mCrop = new Rect();
        private boolean mHasCompatScale;
        private float mGlobalScale;
        private int mRequestedWidth;
        private int mRequestedHeight;

        WindowState(WindowStateProto proto) {
            super(proto.windowContainer);
            mDisplayId = proto.displayId;
            mStackId = proto.stackId;
            if (proto.attributes != null) {
                mType = proto.attributes.type;
            }
            WindowStateAnimatorProto animatorProto = proto.animator;
            if (animatorProto != null) {
                if (animatorProto.surface != null) {
                    WindowSurfaceControllerProto surfaceProto = animatorProto.surface;
                    mShown = surfaceProto.shown;
                    mLayer = surfaceProto.layer;
                }
                mCrop = extract(animatorProto.lastClipRect);
            }
            mGivenContentInsets = extract(proto.givenContentInsets);
            WindowFramesProto windowFramesProto = proto.windowFrames;
            if (windowFramesProto != null) {
                mFrame = extract(windowFramesProto.frame);
                mContainingFrame = extract(windowFramesProto.containingFrame);
                mParentFrame = extract(windowFramesProto.parentFrame);
                mCompatFrame = extract(windowFramesProto.compatFrame);
            }
            mSurfaceInsets = extract(proto.surfaceInsets);
            if (mName.startsWith(STARTING_WINDOW_PREFIX)) {
                mWindowType = WINDOW_TYPE_STARTING;
                // Existing code depends on the prefix being removed
                mName = mName.substring(STARTING_WINDOW_PREFIX.length());
            } else if (proto.animatingExit) {
                mWindowType = WINDOW_TYPE_EXITING;
            } else if (mName.startsWith(DEBUGGER_WINDOW_PREFIX)) {
                mWindowType = WINDOW_TYPE_STARTING;
                mName = mName.substring(DEBUGGER_WINDOW_PREFIX.length());
            } else {
                mWindowType = 0;
            }
            collectDescendantsOfType(WindowState.class, this, mSubWindows);
            mHasCompatScale = proto.hasCompatScale;
            mGlobalScale = proto.globalScale;
            mRequestedWidth = proto.requestedWidth;
            mRequestedHeight = proto.requestedHeight;
        }

        boolean isStartingWindow() {
            return mWindowType == WINDOW_TYPE_STARTING;
        }

        boolean isExitingWindow() {
            return mWindowType == WINDOW_TYPE_EXITING;
        }

        boolean isDebuggerWindow() {
            return mWindowType == WINDOW_TYPE_DEBUGGER;
        }

        int getDisplayId() {
            return mDisplayId;
        }

        int getStackId() {
            return mStackId;
        }

        Rect getContainingFrame() {
            return mContainingFrame;
        }

        public Rect getFrame() {
            return mFrame;
        }

        Rect getSurfaceInsets() {
            return mSurfaceInsets;
        }

        Rect getGivenContentInsets() {
            return mGivenContentInsets;
        }

        Rect getParentFrame() {
            return mParentFrame;
        }

        public Rect getCompatFrame() {
            return mCompatFrame;
        }

        Rect getCrop() {
            return mCrop;
        }

        public boolean isSurfaceShown() {
            return mShown;
        }

        public int getType() {
            return mType;
        }

        public boolean hasCompatScale() {
            return mHasCompatScale;
        }

        public float getGlobalScale() {
            return mGlobalScale;
        }

        public int getRequestedWidth() {
            return mRequestedWidth;
        }

        public int getRequestedHeight() {
            return mRequestedHeight;
        }

        private String getWindowTypeSuffix(int windowType) {
            switch (windowType) {
                case WINDOW_TYPE_STARTING:
                    return "" STARTING"";
                case WINDOW_TYPE_EXITING:
                    return "" EXITING"";
                case WINDOW_TYPE_DEBUGGER:
                    return "" DEBUGGER"";
                default:
                    break;
            }
            return """";
        }

        @Override
        public String toString() {
            return ""WindowState: {"" + mAppToken + "" "" + mName
                    + getWindowTypeSuffix(mWindowType) + ""}"" + "" type="" + mType
                    + "" cf="" + mContainingFrame + "" pf="" + mParentFrame;
        }

        public String toLongString() {
            return toString() + "" f="" + mFrame + "" crop="" + mCrop + "" isSurfaceShown=""
                    + isSurfaceShown();
        }
    }

    static int dpToPx(float dp, int densityDpi) {
        return (int) (dp * densityDpi / DENSITY_DEFAULT + 0.5f);
    }

    int defaultMinimalTaskSize(int displayId) {
        return dpToPx(DEFAULT_RESIZABLE_TASK_SIZE_DP, getDisplay(displayId).getDpi());
    }

    int defaultMinimalDisplaySizeForSplitScreen(int displayId) {
        return dpToPx(ActivityTaskManager.DEFAULT_MINIMAL_SPLIT_SCREEN_DISPLAY_SIZE_DP,
                getDisplay(displayId).getDpi());
    }
}"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.content.cts.SearchRecentSuggestionsProviderTest"	"testSearchRecentSuggestionsProvider"	"CtsContentTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/SearchRecentSuggestionsProviderTest.java"	""	"public void testSearchRecentSuggestionsProvider() {
        final MockSRSProvider s = new MockSRSProvider();
        assertTrue(MockSRSProvider.setupSuggestCalled);

        assertFalse(s.isOnCreateCalled());
        s.attachInfo(mProviderContext, null);
        assertTrue(s.isOnCreateCalled());

        assertNotNull(s.getType(TEST_URI));

        final String uriStr = AUTHORITY_HEAD + '/' + SearchManager.SUGGEST_URI_PATH_QUERY;
        final Uri contentUri = Uri.parse(uriStr);
        String[] selArgs = new String[] { null };

        Cursor c = s.query(contentUri, null, null, selArgs, null);
        assertEquals(0, c.getCount());

        s.insert(TEST_URI, new ContentValues());
        c = s.query(contentUri, null, null, selArgs, null);
        assertEquals(1, c.getCount());

        s.insert(TEST_URI, new ContentValues());
        c = s.query(contentUri, null, null, selArgs, null);
        assertEquals(2, c.getCount());

        s.delete(TEST_URI, null, null);
        c = s.query(contentUri, null, null, selArgs, null);
        assertEquals(0, c.getCount());

        try {
            s.update(TEST_URI, null, null, null);
            fail(""testUpdate failed"");
        } catch (UnsupportedOperationException e) {
            // expected
        }
    }
}"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.permission.cts.NoActivityRelatedPermissionTest"	"testGetTask"	"CtsPermissionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoActivityRelatedPermissionTest.java"	""	"public void testGetTask() {
        ActivityManager manager = (ActivityManager) getActivity()
                .getSystemService(Context.ACTIVITY_SERVICE);
        List<ActivityManager.RunningTaskInfo> runningTasks =  manager.getRunningTasks(10);
        // Current implementation should only return tasks for home and the caller. Since there can
        // be multiple home tasks, we remove them from the list and then check that there is one or
        // less task left in the list.
        removeHomeRunningTasks(runningTasks);
        assertTrue(""Found tasks: "" + runningTasks,
                runningTasks == null || runningTasks.size() <= 1);

        List<ActivityManager.RecentTaskInfo> recentTasks = manager.getRecentTasks(10,
                ActivityManager.RECENT_WITH_EXCLUDED);
        // Current implementation should only return tasks for home and the caller. Since there can
        // be multiple home tasks, we remove them from the list and then check that there is one or
        // less task left in the list.
        removeHomeRecentsTasks(recentTasks);
        assertTrue(""Found tasks: "" + recentTasks, recentTasks == null || recentTasks.size() <= 1);
    }

    private void removeHomeRecentsTasks(List<ActivityManager.RecentTaskInfo> tasks) {
        for (int i = tasks.size() -1; i >= 0; i--) {
            ActivityManager.RecentTaskInfo task = tasks.get(i);
            if (task.baseIntent != null && isHomeIntent(task.baseIntent)) {
                tasks.remove(i);
            }
        }
    }

    private void removeHomeRunningTasks(List<ActivityManager.RunningTaskInfo> tasks) {
        for (int i = tasks.size() -1; i >= 0; i--) {
            ActivityManager.RunningTaskInfo task = tasks.get(i);
            if (task.baseIntent != null && isHomeIntent(task.baseIntent)) {
                tasks.remove(i);
            }
        }
    }

    private boolean isHomeIntent(Intent intent) {
        return Intent.ACTION_MAIN.equals(intent.getAction())
                && (intent.hasCategory(Intent.CATEGORY_HOME)
                || intent.hasCategory(Intent.CATEGORY_SECONDARY_HOME))
                && intent.getCategories().size() == 1
                && intent.getData() == null
                && intent.getType() == null;
    }
}"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.view.inputmethod.ctstestapp.MainActivity"	"isInstantApp"	""	"/home/gpoor/cts-12-source/cts/tests/inputmethod/testapp/src/android/view/inputmethod/ctstestapp/MainActivity.java"	""	"public void test/*
 *.
 */
package android.view.inputmethod.ctstestapp;

import static android.view.WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
import static android.view.WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;
import static android.view.WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;

import android.app.Activity;
import android.app.AlertDialog;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.view.Gravity;
import android.view.inputmethod.InputMethodManager;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.TextView;

import androidx.annotation.Nullable;

/**
 * A test {@link Activity} that automatically shows the input method.
 */
public final class MainActivity extends Activity {

    private static final String EXTRA_KEY_PRIVATE_IME_OPTIONS =
            ""android.view.inputmethod.ctstestapp.EXTRA_KEY_PRIVATE_IME_OPTIONS"";
    private static final String EXTRA_KEY_SHOW_DIALOG =
            ""android.view.inputmethod.ctstestapp.EXTRA_KEY_SHOW_DIALOG"";

    private static final String EXTRA_DISMISS_DIALOG = ""extra_dismiss_dialog"";
    private static final String EXTRA_SHOW_SOFT_INPUT = ""extra_show_soft_input"";

    private static final String ACTION_TRIGGER = ""broadcast_action_trigger"";
    private AlertDialog mDialog;
    private EditText mEditor;
    private final Handler mHandler = new Handler(Looper.myLooper());

    private BroadcastReceiver mBroadcastReceiver;

    @Nullable
    private String getStringIntentExtra(String key) {
        if (getPackageManager().isInstantApp()) {
            final Uri uri = getIntent().getData();
            if (uri == null || !uri.isHierarchical()) {
                return null;
            }
            return uri.getQueryParameter(key);
        }
        return getIntent().getStringExtra(key);
    }

    private boolean getBooleanIntentExtra(String key) {
        if (getPackageManager().isInstantApp()) {
            final Uri uri = getIntent().getData();
            if (uri == null || !uri.isHierarchical()) {
                return false;
            }
            return uri.getBooleanQueryParameter(key, false);
        }
        return getIntent().getBooleanExtra(key, false);
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        final LinearLayout layout = new LinearLayout(this);
        layout.setOrientation(LinearLayout.VERTICAL);
        final boolean needShowDialog = getBooleanIntentExtra(EXTRA_KEY_SHOW_DIALOG);

        if (needShowDialog) {
            layout.setOrientation(LinearLayout.VERTICAL);
            layout.setGravity(Gravity.BOTTOM);
            getWindow().setSoftInputMode(SOFT_INPUT_ADJUST_RESIZE);

            final TextView textView = new TextView(this);
            textView.setText(""This is DialogActivity"");
            layout.addView(textView);

            mDialog = new AlertDialog.Builder(this)
                    .setView(new LinearLayout(this))
                    .create();
            mDialog.getWindow().addFlags(FLAG_ALT_FOCUSABLE_IM);
            mDialog.getWindow().setSoftInputMode(SOFT_INPUT_ADJUST_PAN);
            mDialog.show();
        } else {
            mEditor = new EditText(this);
            mEditor.setHint(""editText"");
            final String privateImeOptions = getStringIntentExtra(EXTRA_KEY_PRIVATE_IME_OPTIONS);
            if (privateImeOptions != null) {
                mEditor.setPrivateImeOptions(privateImeOptions);
            }
            mEditor.requestFocus();
            layout.addView(mEditor);
        }

        setContentView(layout);
    }

    @Override
    protected void onStart() {
        super.onStart();
        mBroadcastReceiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                final Bundle extras = intent.getExtras();
                if (extras == null) {
                    return;
                }

                if (extras.containsKey(EXTRA_SHOW_SOFT_INPUT)) {
                    getSystemService(InputMethodManager.class).showSoftInput(mEditor, 0);
                }

                if (extras.getBoolean(EXTRA_DISMISS_DIALOG, false)) {
                    if (mDialog != null) {
                        mDialog.dismiss();
                        mDialog = null;
                    }
                    mHandler.postDelayed(() -> finish(), 100);
                }
            }
        };
        registerReceiver(mBroadcastReceiver, new IntentFilter(ACTION_TRIGGER));
    }

    @Override
    protected void onStop() {
        super.onStop();
        if (mBroadcastReceiver != null) {
            unregisterReceiver(mBroadcastReceiver);
            mBroadcastReceiver = null;
        }
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.statsd.UidAtomTests"	"testAppCrashOccurred"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/UidAtomTests.java"	""	"public void testAppCrashOccurred() throws Exception {
        final int atomTag = Atom.APP_CRASH_OCCURRED_FIELD_NUMBER;
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag,  /*uidInAttributionChain=*/false);

        DeviceUtils.runActivity(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                ""StatsdCtsForegroundActivity"", ""action"", ""action.crash"");

        // Sorted list of events in order in which they occurred.
        List<EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        assertThat(data).hasSize(1);
        AppCrashOccurred atom = data.get(0).getAtom().getAppCrashOccurred();
        // UID should belong to the run activity, not any system service.
        assertThat(atom.getUid()).isGreaterThan(10000);
        assertThat(atom.getEventType()).isEqualTo(""crash"");
        assertThat(atom.getIsInstantApp().getNumber())
                .isEqualTo(AppCrashOccurred.InstantApp.FALSE_VALUE);
        assertThat(atom.getForegroundState().getNumber())
                .isEqualTo(AppCrashOccurred.ForegroundState.FOREGROUND_VALUE);
        assertThat(atom.getPackageName()).isEqualTo(DeviceUtils.STATSD_ATOM_TEST_PKG);
        assertThat(atom.getErrorSource()).isEqualTo(ErrorSource.DATA_APP);
        assertFalse(atom.getIsIncremental());
        assertTrue((1 - atom.getLoadingProgress()) < 0.001);
        assertEquals(-1, atom.getMillisSinceOldestPendingRead());
    }"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.statsd.UidAtomTests"	"testAppCrashOccurredNative"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/UidAtomTests.java"	""	"public void testAppCrashOccurredNative() throws Exception {
        if (DeviceUtils.hasFeature(getDevice(), FEATURE_TV)
                && DeviceUtils.isDebuggable(getDevice())) {
            // Skip TVs that are debuggable because ActivityManager does not properly terminate
            // the activity in the event of a native crash.
            return;
        }
        final int atomTag = Atom.APP_CRASH_OCCURRED_FIELD_NUMBER;
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag,  /*uidInAttributionChain=*/false);

        DeviceUtils.runActivity(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                ""StatsdCtsForegroundActivity"", ""action"", ""action.native_crash"");

        // Sorted list of events in order in which they occurred.
        List<EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        assertThat(data).hasSize(1);
        AppCrashOccurred atom = data.get(0).getAtom().getAppCrashOccurred();
        // UID should belong to the run activity, not any system service.
        assertThat(atom.getUid()).isGreaterThan(10000);
        assertThat(atom.getEventType()).isEqualTo(""native_crash"");
        assertThat(atom.getIsInstantApp().getNumber())
                .isEqualTo(AppCrashOccurred.InstantApp.FALSE_VALUE);
        assertThat(atom.getForegroundState().getNumber())
                .isEqualTo(AppCrashOccurred.ForegroundState.FOREGROUND_VALUE);
        assertThat(atom.getPackageName()).isEqualTo(DeviceUtils.STATSD_ATOM_TEST_PKG);
        assertThat(atom.getErrorSource()).isEqualTo(ErrorSource.DATA_APP);
        // TODO(b/172866626): add tests for incremental packages that crashed during loading
        assertFalse(atom.getIsIncremental());
        assertTrue((1 - atom.getLoadingProgress()) < 0.001);
        assertEquals(-1, atom.getMillisSinceOldestPendingRead());
    }"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.statsd.UidAtomTests"	"testANROccurred"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/statsd/UidAtomTests.java"	""	"public void testANROccurred() throws Exception {
        final int atomTag = Atom.ANR_OCCURRED_FIELD_NUMBER;
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag, /*useUidAttributionChain=*/false);

        try (AutoCloseable a = DeviceUtils.withActivity(getDevice(),
                DeviceUtils.STATSD_ATOM_TEST_PKG, ""ANRActivity"", null, null)) {
            Thread.sleep(AtomTestUtils.WAIT_TIME_LONG * 2);
            getDevice().executeShellCommand(
                    ""am broadcast -a action_anr -p "" + DeviceUtils.STATSD_ATOM_TEST_PKG);
            Thread.sleep(20_000);
        }

        // Sorted list of events in order in which they occurred.
        List<EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        assertThat(data).hasSize(1);
        assertThat(data.get(0).getAtom().hasAnrOccurred()).isTrue();
        ANROccurred atom = data.get(0).getAtom().getAnrOccurred();
        assertThat(atom.getIsInstantApp().getNumber())
                .isEqualTo(ANROccurred.InstantApp.FALSE_VALUE);
        assertThat(atom.getForegroundState().getNumber())
                .isEqualTo(ANROccurred.ForegroundState.FOREGROUND_VALUE);
        assertThat(atom.getErrorSource()).isEqualTo(ErrorSource.DATA_APP);
        assertThat(atom.getPackageName()).isEqualTo(DeviceUtils.STATSD_ATOM_TEST_PKG);
        assertFalse(atom.getIsIncremental());
        assertTrue((1 - atom.getLoadingProgress()) < 0.001);
        assertEquals(-1, atom.getMillisSinceOldestPendingRead());
    }"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.ephemeralapp1.ClientTest"	"testQuery"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/EphemeralApp1/src/com/android/cts/ephemeralapp1/ClientTest.java"	""	"public void testQuery() throws Exception {
        // query normal activities
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            final List<ResolveInfo> resolveInfo = InstrumentationRegistry.getContext()
                    .getPackageManager().queryIntentActivities(queryIntent, 0 /*flags*/);
            if (resolveInfo == null || resolveInfo.size() == 0) {
                fail(""didn't resolve any intents"");
            }
            assertThat(resolveInfo.size(), is(2));
            assertThat(resolveInfo.get(0).activityInfo.packageName,
                    is(""com.android.cts.ephemeralapp1""));
            assertThat(resolveInfo.get(0).activityInfo.name,
                    is(""com.android.cts.ephemeralapp1.EphemeralActivity""));
            assertThat(resolveInfo.get(0).isInstantAppAvailable,
                    is(true));
            assertThat(resolveInfo.get(1).activityInfo.packageName,
                    is(""com.android.cts.normalapp""));
            assertThat(resolveInfo.get(1).activityInfo.name,
                    is(""com.android.cts.normalapp.ExposedActivity""));
            assertThat(resolveInfo.get(1).isInstantAppAvailable,
                    is(false));
        }

        // query normal activities; directed package
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            final List<ResolveInfo> resolveInfo = InstrumentationRegistry.getContext()
                    .getPackageManager().queryIntentActivities(queryIntent, 0 /*flags*/);
            if (resolveInfo == null || resolveInfo.size() == 0) {
                fail(""didn't resolve any intents"");
            }
            assertThat(resolveInfo.size(), is(2));
            assertThat(resolveInfo.get(0).activityInfo.packageName,
                    is(""com.android.cts.ephemeralapp1""));
            assertThat(resolveInfo.get(0).activityInfo.name,
                    is(""com.android.cts.ephemeralapp1.EphemeralActivity""));
            assertThat(resolveInfo.get(0).isInstantAppAvailable,
                    is(true));
            assertThat(resolveInfo.get(1).activityInfo.packageName,
                    is(""com.android.cts.normalapp""));
            assertThat(resolveInfo.get(1).activityInfo.name,
                    is(""com.android.cts.normalapp.ExposedActivity""));
            assertThat(resolveInfo.get(1).isInstantAppAvailable,
                    is(false));
        }

        // query normal activities; directed component
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            final List<ResolveInfo> resolveInfo = InstrumentationRegistry.getContext()
                    .getPackageManager().queryIntentActivities(queryIntent, 0 /*flags*/);
            if (resolveInfo == null || resolveInfo.size() == 0) {
                fail(""didn't resolve any intents"");
            }
            assertThat(resolveInfo.size(), is(2));
            assertThat(resolveInfo.get(0).activityInfo.packageName,
                    is(""com.android.cts.ephemeralapp1""));
            assertThat(resolveInfo.get(0).activityInfo.name,
                    is(""com.android.cts.ephemeralapp1.EphemeralActivity""));
            assertThat(resolveInfo.get(0).isInstantAppAvailable,
                    is(true));
            assertThat(resolveInfo.get(1).activityInfo.packageName,
                    is(""com.android.cts.normalapp""));
            assertThat(resolveInfo.get(1).activityInfo.name,
                    is(""com.android.cts.normalapp.ExposedActivity""));
            assertThat(resolveInfo.get(1).isInstantAppAvailable,
                    is(false));
        }

        // query own ephemeral application activities with a web URI
        {
            final Intent queryIntent = new Intent(Intent.ACTION_VIEW);
            queryIntent.addCategory(Intent.CATEGORY_BROWSABLE);
            queryIntent.setData(Uri.parse(""https://cts.google.com/ephemeral""));
            final List<ResolveInfo> resolveInfo = InstrumentationRegistry.getContext()
                    .getPackageManager().queryIntentActivities(
                            queryIntent, PackageManager.GET_RESOLVED_FILTER);
            if (resolveInfo == null || resolveInfo.size() == 0) {
                fail(""didn't resolve any intents"");
            }
            for (ResolveInfo info: resolveInfo) {
                assertThat(info.filter, is(notNullValue()));
                if (handlesAllWebData(info.filter)) {
                    continue;
                }
                assertThat(info.activityInfo.packageName,
                        is(""com.android.cts.ephemeralapp1""));
                assertThat(info.activityInfo.name,
                        is(""com.android.cts.ephemeralapp1.EphemeralActivity""));
                assertThat(info.isInstantAppAvailable,
                        is(true));
            }
        }

        // query other ephemeral application activities with a web URI
        {
            final Intent queryIntent = new Intent(Intent.ACTION_VIEW);
            queryIntent.addCategory(Intent.CATEGORY_BROWSABLE);
            queryIntent.setData(Uri.parse(""https://cts.google.com/other""));
            final List<ResolveInfo> resolveInfo = InstrumentationRegistry.getContext()
                    .getPackageManager().queryIntentActivities(
                            queryIntent, PackageManager.GET_RESOLVED_FILTER);
            if (resolveInfo == null || resolveInfo.size() == 0) {
                fail(""didn't resolve any intents"");
            }
            for (ResolveInfo info: resolveInfo) {
                assertThat(info.filter, is(notNullValue()));
                if (handlesAllWebData(info.filter)) {
                    continue;
                }
                fail(""resolution should have only matched browsers"");
            }
        }

        // query services
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            final List<ResolveInfo> resolveInfo = InstrumentationRegistry
                    .getContext().getPackageManager().queryIntentServices(queryIntent, 0 /*flags*/);
            if (resolveInfo == null || resolveInfo.size() == 0) {
                fail(""didn't resolve any intents"");
            }
            assertThat(resolveInfo.size(), is(2));
            assertThat(resolveInfo.get(0).serviceInfo.packageName,
                    is(""com.android.cts.ephemeralapp1""));
            assertThat(resolveInfo.get(0).serviceInfo.name,
                    is(""com.android.cts.ephemeralapp1.EphemeralService""));
            assertThat(resolveInfo.get(1).serviceInfo.packageName,
                    is(""com.android.cts.normalapp""));
            assertThat(resolveInfo.get(1).serviceInfo.name,
                    is(""com.android.cts.normalapp.ExposedService""));
            assertThat(resolveInfo.get(1).isInstantAppAvailable,
                    is(false));
        }

        // query services; directed package
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            queryIntent.setPackage(""com.android.cts.ephemeralapp1"");
            final List<ResolveInfo> resolveInfo = InstrumentationRegistry
                    .getContext().getPackageManager().queryIntentServices(queryIntent, 0 /*flags*/);
            if (resolveInfo == null || resolveInfo.size() == 0) {
                fail(""didn't resolve any intents"");
            }
            assertThat(resolveInfo.size(), is(1));
            assertThat(resolveInfo.get(0).serviceInfo.packageName,
                    is(""com.android.cts.ephemeralapp1""));
            assertThat(resolveInfo.get(0).serviceInfo.name,
                    is(""com.android.cts.ephemeralapp1.EphemeralService""));
        }

        // query services; directed component
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            queryIntent.setComponent(
                    new ComponentName(""com.android.cts.ephemeralapp1"",
                            ""com.android.cts.ephemeralapp1.EphemeralService""));
            final List<ResolveInfo> resolveInfo = InstrumentationRegistry
                    .getContext().getPackageManager().queryIntentServices(queryIntent, 0 /*flags*/);
            if (resolveInfo == null || resolveInfo.size() == 0) {
                fail(""didn't resolve any intents"");
            }
            assertThat(resolveInfo.size(), is(1));
            assertThat(resolveInfo.get(0).serviceInfo.packageName,
                    is(""com.android.cts.ephemeralapp1""));
            assertThat(resolveInfo.get(0).serviceInfo.name,
                    is(""com.android.cts.ephemeralapp1.EphemeralService""));
        }

        // query instant application provider
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            final List<ResolveInfo> resolveInfo = InstrumentationRegistry
                    .getContext().getPackageManager().queryIntentContentProviders(
                            queryIntent, 0 /*flags*/);
            if (resolveInfo == null || resolveInfo.size() == 0) {
                fail(""didn't resolve any intents"");
            }
            assertThat(resolveInfo.size(), is(2));
            assertThat(resolveInfo.get(0).providerInfo.packageName,
                    is(""com.android.cts.ephemeralapp1""));
            assertThat(resolveInfo.get(0).providerInfo.name,
                    is(""com.android.cts.ephemeralapp1.EphemeralProvider""));
            assertThat(resolveInfo.get(1).providerInfo.packageName,
                    is(""com.android.cts.normalapp""));
            assertThat(resolveInfo.get(1).providerInfo.name,
                    is(""com.android.cts.normalapp.ExposedProvider""));
            assertThat(resolveInfo.get(1).isInstantAppAvailable,
                    is(false));
        }

        // query instant application provider ; directed package
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            queryIntent.setPackage(""com.android.cts.ephemeralapp1"");
            final List<ResolveInfo> resolveInfo = InstrumentationRegistry
                    .getContext().getPackageManager().queryIntentContentProviders(
                            queryIntent, 0 /*flags*/);
            if (resolveInfo == null || resolveInfo.size() == 0) {
                fail(""didn't resolve any intents"");
            }
            assertThat(resolveInfo.size(), is(1));
            assertThat(resolveInfo.get(0).providerInfo.packageName,
                    is(""com.android.cts.ephemeralapp1""));
            assertThat(resolveInfo.get(0).providerInfo.name,
                    is(""com.android.cts.ephemeralapp1.EphemeralProvider""));
        }

        // query instant application provider ; directed component
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            queryIntent.setComponent(
                    new ComponentName(""com.android.cts.ephemeralapp1"",
                            ""com.android.cts.ephemeralapp1.EphemeralProvider""));
            final List<ResolveInfo> resolveInfo = InstrumentationRegistry
                    .getContext().getPackageManager().queryIntentContentProviders(
                            queryIntent, 0 /*flags*/);
            if (resolveInfo == null || resolveInfo.size() == 0) {
                fail(""didn't resolve any intents"");
            }
            assertThat(resolveInfo.size(), is(1));
            assertThat(resolveInfo.get(0).providerInfo.packageName,
                    is(""com.android.cts.ephemeralapp1""));
            assertThat(resolveInfo.get(0).providerInfo.name,
                    is(""com.android.cts.ephemeralapp1.EphemeralProvider""));
        }

        // resolve normal provider
        {
            final ProviderInfo providerInfo = InstrumentationRegistry
                    .getContext().getPackageManager().resolveContentProvider(
                            ""com.android.cts.normalapp.provider"", 0 /*flags*/);
            assertThat(providerInfo, is(nullValue()));
        }

        // resolve exposed provider
        {
            final ProviderInfo providerInfo = InstrumentationRegistry
                    .getContext().getPackageManager().resolveContentProvider(
                            ""com.android.cts.normalapp.exposed.provider"", 0 /*flags*/);
            assertThat(providerInfo, is(notNullValue()));
            assertThat(providerInfo.packageName,
                    is(""com.android.cts.normalapp""));
            assertThat(providerInfo.name,
                    is(""com.android.cts.normalapp.ExposedProvider""));
        }

        // resolve instant application provider
        {
            final ProviderInfo providerInfo = InstrumentationRegistry
                    .getContext().getPackageManager().resolveContentProvider(
                            ""com.android.cts.ephemeralapp1.provider"", 0 /*flags*/);
            assertThat(providerInfo, is(notNullValue()));
            assertThat(providerInfo.packageName,
                    is(""com.android.cts.ephemeralapp1""));
            assertThat(providerInfo.name,
                    is(""com.android.cts.ephemeralapp1.EphemeralProvider""));
        }
    }"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.ephemeralapp1.ClientTest"	"testStartEphemeral"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/EphemeralApp1/src/com/android/cts/ephemeralapp1/ClientTest.java"	""	"public void testStartEphemeral() throws Exception {
        // start the ephemeral activity
        {
            final Intent startEphemeralIntent = new Intent(ACTION_START_EPHEMERAL)
                    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            InstrumentationRegistry
                    .getContext().startActivity(startEphemeralIntent, null /*options*/);
            final TestResult testResult = getResult();
            assertThat(testResult.getPackageName(),
                    is(""com.android.cts.ephemeralapp1""));
            assertThat(testResult.getComponentName(),
                    is(""EphemeralActivity""));
            assertThat(testResult.getStatus(),
                    is(""PASS""));
            assertThat(testResult.getException(),
                    is(nullValue()));
        }

        // start the ephemeral activity; directed package
        {
            final Intent startEphemeralIntent = new Intent(ACTION_START_EPHEMERAL)
                    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            startEphemeralIntent.setPackage(""com.android.cts.ephemeralapp1"");
            InstrumentationRegistry
                    .getContext().startActivity(startEphemeralIntent, null /*options*/);
            final TestResult testResult = getResult();
            assertThat(testResult.getPackageName(),
                    is(""com.android.cts.ephemeralapp1""));
            assertThat(testResult.getComponentName(),
                    is(""EphemeralActivity""));
            assertThat(testResult.getStatus(),
                    is(""PASS""));
            assertThat(testResult.getException(),
                    is(nullValue()));
        }

        // start the ephemeral activity; directed component
        {
            final Intent startEphemeralIntent = new Intent(ACTION_START_EPHEMERAL)
                    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            startEphemeralIntent.setComponent(
                    new ComponentName(""com.android.cts.ephemeralapp1"",
                            ""com.android.cts.ephemeralapp1.EphemeralActivity""));
            InstrumentationRegistry
                    .getContext().startActivity(startEphemeralIntent, null /*options*/);
            final TestResult testResult = getResult();
            assertThat(testResult.getPackageName(),
                    is(""com.android.cts.ephemeralapp1""));
            assertThat(testResult.getComponentName(),
                    is(""EphemeralActivity""));
            assertThat(testResult.getStatus(),
                    is(""PASS""));
            assertThat(testResult.getException(),
                    is(nullValue()));
        }

        // start a private ephemeral activity
        {
            final Intent startEphemeralIntent = new Intent(ACTION_START_EPHEMERAL_PRIVATE)
                    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            InstrumentationRegistry
                    .getContext().startActivity(startEphemeralIntent, null /*options*/);
            final TestResult testResult = getResult();
            assertThat(testResult.getPackageName(),
                    is(""com.android.cts.ephemeralapp1""));
            assertThat(testResult.getComponentName(),
                    is(""EphemeralActivity2""));
            assertThat(testResult.getStatus(),
                    is(""PASS""));
            assertThat(testResult.getException(),
                    is(nullValue()));
        }

        // start a private ephemeral activity; directed package
        {
            final Intent startEphemeralIntent = new Intent(ACTION_START_EPHEMERAL_PRIVATE)
                    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            startEphemeralIntent.setPackage(""com.android.cts.ephemeralapp1"");
            InstrumentationRegistry
                    .getContext().startActivity(startEphemeralIntent, null /*options*/);
            final TestResult testResult = getResult();
            assertThat(testResult.getPackageName(),
                    is(""com.android.cts.ephemeralapp1""));
            assertThat(testResult.getComponentName(),
                    is(""EphemeralActivity2""));
            assertThat(testResult.getStatus(),
                    is(""PASS""));
            assertThat(testResult.getException(),
                    is(nullValue()));
        }

        // start a private ephemeral activity; directed component
        {
            final Intent startEphemeralIntent = new Intent(ACTION_START_EPHEMERAL_PRIVATE)
                    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            startEphemeralIntent.setComponent(
                    new ComponentName(""com.android.cts.ephemeralapp1"",
                            ""com.android.cts.ephemeralapp1.EphemeralActivity2""));
            InstrumentationRegistry
                    .getContext().startActivity(startEphemeralIntent, null /*options*/);
            final TestResult testResult = getResult();
            assertThat(testResult.getPackageName(),
                    is(""com.android.cts.ephemeralapp1""));
            assertThat(testResult.getComponentName(),
                    is(""EphemeralActivity2""));
            assertThat(testResult.getStatus(),
                    is(""PASS""));
            assertThat(testResult.getException(),
                    is(nullValue()));
        }

        // start a private ephemeral activity; directed component
        {
            final Intent startEphemeralIntent = new Intent()
                    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            startEphemeralIntent.setComponent(
                    new ComponentName(""com.android.cts.ephemeralapp1"",
                            ""com.android.cts.ephemeralapp1.EphemeralActivity3""));
            InstrumentationRegistry
                    .getContext().startActivity(startEphemeralIntent, null /*options*/);
            final TestResult testResult = getResult();
            assertThat(testResult.getPackageName(),
                    is(""com.android.cts.ephemeralapp1""));
            assertThat(testResult.getComponentName(),
                    is(""EphemeralActivity3""));
            assertThat(testResult.getStatus(),
                    is(""PASS""));
            assertThat(testResult.getException(),
                    is(nullValue()));
        }

        // start an ephemeral activity; VIEW / BROWSABLE intent
        {
            final Intent startEphemeralIntent = new Intent(Intent.ACTION_VIEW)
                    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            startEphemeralIntent.addCategory(Intent.CATEGORY_BROWSABLE);
            startEphemeralIntent.setData(Uri.parse(""https://cts.google.com/other""));
            InstrumentationRegistry
                    .getContext().startActivity(startEphemeralIntent, null /*options*/);
            final TestResult testResult = getResult();
            assertThat(testResult.getPackageName(),
                    is(""com.android.cts.ephemeralapp2""));
            assertThat(testResult.getComponentName(),
                    is(""EphemeralActivity""));
            assertThat(testResult.getIntent().getAction(),
                    is(Intent.ACTION_VIEW));
            assertThat(testResult.getIntent().getCategories(),
                    hasItems(Intent.CATEGORY_BROWSABLE));
            assertThat(testResult.getIntent().getData().toString(),
                    is(""https://cts.google.com/other""));
            assertThat(testResult.getStatus(),
                    is(""PASS""));
            assertThat(testResult.getException(),
                    is(nullValue()));
        }

        // start an ephemeral activity; EXTERNAL flag
        {
            final Intent startEphemeralIntent = new Intent(ACTION_START_EPHEMERAL_ACTIVITY)
                    .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_MATCH_EXTERNAL);
            InstrumentationRegistry.getContext().startActivity(
                    startEphemeralIntent, null /*options*/);
            final TestResult testResult = getResult();
            assertThat(testResult.getPackageName(),
                    is(""com.android.cts.ephemeralapp2""));
            assertThat(testResult.getComponentName(),
                    is(""EphemeralActivity""));
            assertThat(testResult.getIntent().getAction(),
                    is(ACTION_START_EPHEMERAL_ACTIVITY));
            assertThat(testResult.getIntent().getData(),
                    is(nullValue()));
            assertThat(testResult.getStatus(),
                    is(""PASS""));
            assertThat(testResult.getException(),
                    is(nullValue()));
        }

        // start the ephemeral service; directed package
        {
            final Intent startEphemeralIntent = new Intent(ACTION_START_EPHEMERAL);
            startEphemeralIntent.setPackage(""com.android.cts.ephemeralapp1"");
            try {
                InstrumentationRegistry.getContext().startService(startEphemeralIntent);
                final TestResult testResult = getResult();
                assertThat(testResult.getPackageName(),
                        is(""com.android.cts.ephemeralapp1""));
                assertThat(testResult.getComponentName(),
                        is(""EphemeralService""));
                assertThat(testResult.getMethodName(),
                        is(""onStartCommand""));
                assertThat(testResult.getStatus(),
                        is(""PASS""));
                assertThat(testResult.getException(),
                        is(nullValue()));
            } finally {
                InstrumentationRegistry.getContext().stopService(startEphemeralIntent);
            }
        }

        // start the ephemeral service; directed component
        {
            final Intent startEphemeralIntent = new Intent(ACTION_START_EPHEMERAL);
            startEphemeralIntent.setComponent(
                    new ComponentName(""com.android.cts.ephemeralapp1"",
                            ""com.android.cts.ephemeralapp1.EphemeralService""));
            try {
                assertThat(InstrumentationRegistry.getContext().startService(startEphemeralIntent),
                        is(notNullValue()));
                final TestResult testResult = getResult();
                assertThat(testResult.getPackageName(),
                        is(""com.android.cts.ephemeralapp1""));
                assertThat(testResult.getComponentName(),
                        is(""EphemeralService""));
                assertThat(testResult.getMethodName(),
                        is(""onStartCommand""));
                assertThat(testResult.getStatus(),
                        is(""PASS""));
                assertThat(testResult.getException(),
                        is(nullValue()));
            } finally {
                InstrumentationRegistry.getContext().stopService(startEphemeralIntent);
            }
        }

        // bind to the ephemeral service; directed package
        {
            final Intent startEphemeralIntent = new Intent(ACTION_START_EPHEMERAL);
            startEphemeralIntent.setPackage(""com.android.cts.ephemeralapp1"");
            final TestServiceConnection connection = new TestServiceConnection();
            try {
                assertThat(InstrumentationRegistry.getContext().bindService(
                        startEphemeralIntent, connection, Context.BIND_AUTO_CREATE /*flags*/),
                        is(true));
                final TestResult testResult = getResult();
                assertThat(testResult.getPackageName(),
                        is(""com.android.cts.ephemeralapp1""));
                assertThat(testResult.getComponentName(),
                        is(""EphemeralService""));
                assertThat(testResult.getMethodName(),
                        is(""onBind""));
                assertThat(testResult.getStatus(),
                        is(""PASS""));
                assertThat(testResult.getException(),
                        is(nullValue()));
            } finally {
                InstrumentationRegistry.getContext().unbindService(connection);
            }
        }

        // bind to the ephemeral service; directed component
        {
            final Intent startEphemeralIntent = new Intent(ACTION_START_EPHEMERAL);
            startEphemeralIntent.setComponent(
                    new ComponentName(""com.android.cts.ephemeralapp1"",
                            ""com.android.cts.ephemeralapp1.EphemeralService""));
            final TestServiceConnection connection = new TestServiceConnection();
            try {
                assertThat(InstrumentationRegistry.getContext().bindService(
                        startEphemeralIntent, connection, Context.BIND_AUTO_CREATE /*flags*/),
                        is(true));
                final TestResult testResult = getResult();
                assertThat(testResult.getPackageName(),
                        is(""com.android.cts.ephemeralapp1""));
                assertThat(testResult.getComponentName(),
                        is(""EphemeralService""));
                assertThat(testResult.getMethodName(),
                        is(""onBind""));
                assertThat(testResult.getStatus(),
                        is(""PASS""));
                assertThat(testResult.getException(),
                        is(nullValue()));
            } finally {
                InstrumentationRegistry.getContext().unbindService(connection);
            }
        }

        // connect to the instant app provider
        {
            final String provider = ""content://com.android.cts.ephemeralapp1.provider/table"";
            final Cursor testCursor = InstrumentationRegistry
                    .getContext().getContentResolver().query(
                            Uri.parse(provider),
                            null /*projection*/,
                            null /*selection*/,
                            null /*selectionArgs*/,
                            null /*sortOrder*/);
            assertThat(testCursor, is(notNullValue()));
            assertThat(testCursor.getCount(), is(1));
            assertThat(testCursor.getColumnCount(), is(2));
            assertThat(testCursor.moveToFirst(), is(true));
            assertThat(testCursor.getInt(0), is(1));
            assertThat(testCursor.getString(1), is(""InstantAppProvider""));
        }
    }"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.ephemeralapp1.ClientTest"	"testPackageInfo"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/EphemeralApp1/src/com/android/cts/ephemeralapp1/ClientTest.java"	""	"public void testPackageInfo() throws Exception {
        PackageInfo info;
        // own package info
        info = InstrumentationRegistry.getContext().getPackageManager()
                .getPackageInfo(""com.android.cts.ephemeralapp1"", 0);
        assertThat(info.packageName,
                is(""com.android.cts.ephemeralapp1""));

        // exposed application package info
        info = InstrumentationRegistry.getContext().getPackageManager()
                .getPackageInfo(""com.android.cts.normalapp"", 0);
        assertThat(info.packageName,
                is(""com.android.cts.normalapp""));

        // implicitly exposed application package info not accessible
        try {
            info = InstrumentationRegistry.getContext().getPackageManager()
                    .getPackageInfo(""com.android.cts.implicitapp"", 0);
            fail(""Instant apps should not be able to access PackageInfo for an app that does not"" +
                    "" expose itself to Instant Apps."");
        } catch (PackageManager.NameNotFoundException expected) {
        }

        // unexposed application package info not accessible
        try {
            info = InstrumentationRegistry.getContext().getPackageManager()
                    .getPackageInfo(""com.android.cts.unexposedapp"", 0);
            fail(""Instant apps should not be able to access PackageInfo for an app that does not"" +
                    "" expose itself to Instant Apps."");
        } catch (PackageManager.NameNotFoundException expected) {
        }

        // instant application (with visibleToInstantApp component) package info not accessible
        try {
            info = InstrumentationRegistry.getContext().getPackageManager()
                    .getPackageInfo(""com.android.cts.ephemeralapp2"", 0);
            fail(""Instant apps should not be able to access PackageInfo for another Instant App."");
        } catch (PackageManager.NameNotFoundException expected) {
        }
    }"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.ephemeralapp1.ClientTest"	"testActivityInfo"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/EphemeralApp1/src/com/android/cts/ephemeralapp1/ClientTest.java"	""	"public void testActivityInfo() throws Exception {
        // own package info
        {
            final ComponentName component = new ComponentName(
                    ""com.android.cts.ephemeralapp1"",
                    ""com.android.cts.ephemeralapp1.EphemeralActivity"");
            final ActivityInfo info = InstrumentationRegistry.getContext().getPackageManager()
                .getActivityInfo(component, 0);
            assertThat(info.packageName,
                    is(""com.android.cts.ephemeralapp1""));
        }

        // exposed application package info
        {
            final ComponentName component = new ComponentName(
                    ""com.android.cts.normalapp"",
                    ""com.android.cts.normalapp.ExposedActivity"");
            final ActivityInfo info = InstrumentationRegistry.getContext().getPackageManager()
                .getActivityInfo(component, 0);
            assertThat(info.packageName,
                    is(""com.android.cts.normalapp""));
        }

        // implicitly exposed application package info not accessible
        {
            try {
                final ComponentName component = new ComponentName(
                        ""com.android.cts.normalapp"",
                        ""com.android.cts.normalapp.NormalWebActivity"");
                final ActivityInfo info = InstrumentationRegistry.getContext().getPackageManager()
                        .getActivityInfo(component, 0);
                fail(""Instant apps should not be able to access ActivityInfo for""
                        + "" an activity that implicitly exposes itself to Instant Apps."");
            } catch (PackageManager.NameNotFoundException expected) {
            }
        }

        // unexposed application package info not accessible
        {
            try {
                final ComponentName component = new ComponentName(
                        ""com.android.cts.normalapp"",
                        ""com.android.cts.normalapp.NormalActivity"");
                final ActivityInfo info = InstrumentationRegistry.getContext().getPackageManager()
                        .getActivityInfo(component, 0);
                fail(""Instant apps should not be able to access ActivityInfo for""
                        + "" an activity that does not expose itself to Instant Apps."");
            } catch (PackageManager.NameNotFoundException expected) {
            }
        }

        // instant application (with visibleToInstantApp component) package info not accessible
        {
            try {
                final ComponentName component = new ComponentName(
                        ""com.android.cts.ephemeralapp2"",
                        ""com.android.cts.ephemeralapp2.ExposedActivity"");
                final ActivityInfo info = InstrumentationRegistry.getContext().getPackageManager()
                        .getActivityInfo(component, 0);
                fail(""Instant apps should not be able to access ActivityInfo for""
                        + "" another Instant App."");
            } catch (PackageManager.NameNotFoundException expected) {
            }
        }
    }"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.ephemeralapp1.ClientTest"	"testStartForegroundService"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/EphemeralApp1/src/com/android/cts/ephemeralapp1/ClientTest.java"	""	"public void testStartForegroundService() throws Exception {
        final Context context = InstrumentationRegistry.getContext();
        final Intent intent = new Intent(context, SomeService.class);

        // Create a notification channel for the foreground notification
        final NotificationChannel channel = new NotificationChannel(""foo"", ""foo"",
                NotificationManager.IMPORTANCE_DEFAULT);
        final NotificationManager notificationManager = context.getSystemService(
                NotificationManager.class);
        notificationManager.createNotificationChannel(channel);

        // Shouldn't be able to start without a permission
        final CountDownLatch latch1 = new CountDownLatch(1);
        SomeService.setOnStartCommandCallback((int result) -> {
            assertSame(""Shouldn't be able to start without ""
                    + "" INSTANT_APP_FOREGROUND_SERVICE permission"", 0, result);
            latch1.countDown();
        });
        context.startForegroundService(intent);
        latch1.await(5, TimeUnit.SECONDS);

        // Now grant ourselves INSTANT_APP_FOREGROUND_SERVICE
        grantInstantAppForegroundServicePermission();

        // Should be able to start with a permission
        final CountDownLatch latch2 = new CountDownLatch(1);
        SomeService.setOnStartCommandCallback((int result) -> {
            assertSame(""Should be able to start with ""
                    + "" INSTANT_APP_FOREGROUND_SERVICE permission"", 1, result);
            latch2.countDown();
        });
        context.startForegroundService(intent);
        latch2.await(5, TimeUnit.SECONDS);
    }"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.ephemeralapp1.ClientTest"	"testGetChangedPackages"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/EphemeralApp1/src/com/android/cts/ephemeralapp1/ClientTest.java"	""	"public void testGetChangedPackages() {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();

        // Instant apps can't get changed packages.
        final ChangedPackages changedPackages = pm.getChangedPackages(0);
        assertNull(changedPackages);
    }

    /** Returns {@code true} if the given filter handles all web URLs, regardless of host. */
    private boolean handlesAllWebData(IntentFilter filter) {
        return filter.hasCategory(Intent.CATEGORY_APP_BROWSER) ||
                (handlesWebUris(filter) && filter.countDataAuthorities() == 0);
    }

    /** Returns {@code true} if the given filter handles at least one web URL. */
    private boolean handlesWebUris(IntentFilter filter) {
        // Require ACTION_VIEW, CATEGORY_BROWSEABLE, and at least one scheme
        if (!filter.hasAction(Intent.ACTION_VIEW)
            || !filter.hasCategory(Intent.CATEGORY_BROWSABLE)
            || filter.countDataSchemes() == 0) {
            return false;
        }
        // Now allow only the schemes ""http"" and ""https""
        final Iterator<String> schemesIterator = filter.schemesIterator();
        while (schemesIterator.hasNext()) {
            final String scheme = schemesIterator.next();
            final boolean isWebScheme = ""http"".equals(scheme) || ""https"".equals(scheme);
            if (isWebScheme) {
                return true;
            }
        }
        return false;
    }

    private TestResult getResult() {
        final TestResult result;
        try {
            result = mResultQueue.poll(5, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        if (result == null) {
            throw new IllegalStateException(""Activity didn't receive a Result in 5 seconds"");
        }
        return result;
    }

    private static void grantInstantAppForegroundServicePermission() throws IOException {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                InstrumentationRegistry.getContext().getPackageName(),
                android.Manifest.permission.INSTANT_APP_FOREGROUND_SERVICE);
    }

    private static Intent makeIntent(String action, String category, String mimeType) {
        Intent intent = new Intent(action);
        if (category != null) {
            intent.addCategory(category);
        }
        if (mimeType != null) {
            intent.setType(mimeType);
        }
        return intent;
    }

    private static class ActivityBroadcastReceiver extends BroadcastReceiver {
        private final SynchronousQueue<TestResult> mQueue;
        public ActivityBroadcastReceiver(SynchronousQueue<TestResult> queue) {
            mQueue = queue;
        }

        @Override
        public void onReceive(Context context, Intent intent) {
            try {
                mQueue.offer(intent.getParcelableExtra(TestResult.EXTRA_TEST_RESULT),
                        5, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }

    private static class TestServiceConnection implements ServiceConnection {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
        }
        @Override
        public void onServiceDisconnected(ComponentName name) {
        }
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.managedprovisioning.ByodFlowTestActivity"	"ByodFlowTestActivity"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/ByodFlowTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.managedprovisioning;

import android.app.KeyguardManager;
import android.app.admin.DevicePolicyManager;
import android.content.ActivityNotFoundException;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.pm.PackageManager;
import android.net.ConnectivityManager;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.provider.Settings;
import android.util.Log;
import android.widget.Toast;

import com.android.cts.verifier.ArrayTestListAdapter;
import com.android.cts.verifier.DialogTestListActivity;
import com.android.cts.verifier.R;
import com.android.cts.verifier.TestListActivity;
import com.android.cts.verifier.TestListAdapter.TestListItem;
import com.android.cts.verifier.TestResult;

/**
 * CTS verifier test for BYOD managed provisioning flow
 *
 * This activity is responsible for starting the managed provisioning flow and verify the outcome of
 * provisioning. It performs the following verifications:
 *   Full disk encryption is enabled.
 *   Profile owner is correctly installed.
 *   Profile owner shows up in the Settings app.
 *   Badged work apps show up in launcher.
 * The first two verifications are performed automatically, by interacting with profile owner using
 * cross-profile intents, while the last two are carried out manually by the user.
 */
public class ByodFlowTestActivity extends DialogTestListActivity {

    // Action for delivering sub-test result from the profile.
    public static final String ACTION_TEST_RESULT =
            ""com.android.cts.verifier.managedprovisioning.BYOD_TEST_RESULT"";
    // Extra for ACTION_TEST_RESULT containing test result.
    public static final String EXTRA_RESULT = ""extra-result"";
    protected static final String HELPER_APP_PATH = ""/data/local/tmp/NotificationBot.apk"";

    private static final String TAG = ""ByodFlowTestActivity"";
    private static final int PROVISIONING_CHECK_PERIOD_MS = 3000;
    private static ConnectivityManager mCm;
    private static final int REQUEST_MANAGED_PROVISIONING = 0;
    private static final int REQUEST_PROFILE_OWNER_STATUS = 1;
    private static final int REQUEST_INTENT_FILTERS_STATUS = 2;
    private static final int REQUEST_CHECK_DISK_ENCRYPTION = 3;
    private static final int REQUEST_SET_LOCK_FOR_ENCRYPTION = 4;

    private static final String PROVISIONING_PREFERENCES = ""provisioning_preferences"";
    private static final String PREFERENCE_PROVISIONING_COMPLETE_STATUS =
            ""provisioning_complete_status"";
    private static final int PREFERENCE_PROVISIONING_COMPLETE_STATUS_NOT_RECEIVED = 0;
    private static final int PREFERENCE_PROVISIONING_COMPLETE_STATUS_RECEIVED = 1;
    private static final int PREFERENCE_PROVISIONING_COMPLETE_STATUS_PROCESSED = 2;

    private ComponentName mAdminReceiverComponent;
    private KeyguardManager mKeyguardManager;
    private ByodFlowTestHelper mByodFlowTestHelper;

    private DialogTestListItem mProfileOwnerInstalled;
    private DialogTestListItem mDiskEncryptionTest;
    private DialogTestListItem mProfileAccountVisibleTest;
    private DialogTestListItem mDeviceAdminVisibleTest;
    private DialogTestListItem mWorkAppVisibleTest;
    private DialogTestListItem mCrossProfileIntentFiltersTestFromPersonal;
    private DialogTestListItem mCrossProfileIntentFiltersTestFromWork;
    private TestListItem mCrossProfilePermissionControl;
    private DialogTestListItem mAppLinkingTest;
    private TestListItem mNonMarketAppsTest;
    private DialogTestListItem mWorkNotificationBadgedTest;
    private DialogTestListItem mWorkStatusBarIconTest;
    private DialogTestListItem mWorkStatusBarToastTest;
    private DialogTestListItem mUserSettingsVisibleTest;
    private DialogTestListItem mAppSettingsVisibleTest;
    private DialogTestListItem mLocationSettingsVisibleTest;
    private DialogTestListItem mWiFiDataUsageSettingsVisibleTest;
    private DialogTestListItem mCellularDataUsageSettingsVisibleTest;
    private DialogTestListItem mCredSettingsVisibleTest;
    private DialogTestListItem mPrintSettingsVisibleTest;
    private DialogTestListItem mIntentFiltersTest;
    private DialogTestListItem mPermissionLockdownTest;
    private DialogTestListItem mCrossProfileImageCaptureSupportTest;
    private DialogTestListItem mCrossProfileVideoCaptureWithExtraOutputSupportTest;
    private DialogTestListItem mCrossProfileVideoCaptureWithoutExtraOutputSupportTest;
    private DialogTestListItem mCrossProfileAudioCaptureSupportTest;
    private TestListItem mKeyguardDisabledFeaturesTest;
    private DialogTestListItem mDisableNfcBeamTest;
    private TestListItem mAuthenticationBoundKeyTest;
    private TestListItem mEnableLocationModeTest;
    private TestListItem mDisableLocationModeThroughMainSwitchTest;
    private TestListItem mDisableLocationModeThroughWorkSwitchTest;
    private TestListItem mPrimaryLocationWhenWorkDisabledTest;
    private DialogTestListItem mSelectWorkChallenge;
    private DialogTestListItem mConfirmWorkCredentials;
    private DialogTestListItem mPatternWorkChallenge;
    private DialogTestListItem mParentProfilePassword;
    private DialogTestListItem mPersonalRingtonesTest;
    private TestListItem mVpnTest;
    private TestListItem mKeyChainTest;
    private TestListItem mAlwaysOnVpnSettingsTest;
    private TestListItem mRecentsTest;
    private TestListItem mDisallowAppsControlTest;
    private TestListItem mOrganizationInfoTest;
    private TestListItem mPolicyTransparencyTest;
    private TestListItem mTurnOffWorkFeaturesTest;
    private TestListItem mWidgetTest;
    private final Handler mHandler = new Handler(Looper.myLooper());

    private final Runnable mPeriodicProvisioningCheckRunnable = new Runnable() {
        @Override
        public void run() {
            if (isProvisioningCompleteBroadcastReceived(getApplicationContext())) {
                markProvisioningCompleteBroadcastProcessed(getApplicationContext());
                queryProfileOwner(true);
            } else {
                mHandler.postDelayed(this, PROVISIONING_CHECK_PERIOD_MS);
            }
        }
    };

    public static class ProvisioningCompleteReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            markProvisioningCompleteBroadcastReceived(context);
        }
    }

    public ByodFlowTestActivity() {
        super(R.layout.provisioning_byod,
                R.string.provisioning_byod, R.string.provisioning_byod_info,
                R.string.provisioning_byod_instructions);
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        mByodFlowTestHelper = new ByodFlowTestHelper(this);
        mAdminReceiverComponent = new ComponentName(this, DeviceAdminTestReceiver.class.getName());
        mKeyguardManager = (KeyguardManager) getSystemService(KEYGUARD_SERVICE);

        mByodFlowTestHelper.setup();

        mPrepareTestButton.setText(R.string.provisioning_byod_start);
        mPrepareTestButton.setOnClickListener(v -> Utils.provisionManagedProfile(
                ByodFlowTestActivity.this, mAdminReceiverComponent,
                REQUEST_MANAGED_PROVISIONING));

        // If we are started by managed provisioning (fresh managed provisioning after encryption
        // reboot), redirect the user back to the main test list. This is because the test result
        // is only saved by the parent TestListActivity, and if we did allow the user to proceed
        // here, the test result would be lost when this activity finishes.
        if (ByodHelperActivity.ACTION_PROFILE_OWNER_STATUS.equals(getIntent().getAction())) {
            startActivity(new Intent(this, TestListActivity.class));
            // Calling super.finish() because we delete managed profile in our overridden of finish(),
            // which is not what we want to do here.
            super.finish();
        } else {
            queryProfileOwner(false);
        }
    }

    @Override
    protected void onStart() {
        super.onStart();
        startPeriodicProvisioningCheckIfNecessary();
    }

    private void startPeriodicProvisioningCheckIfNecessary() {
        if (mHandler.hasCallbacks(mPeriodicProvisioningCheckRunnable)) {
            return;
        }
        if (!isProvisioningCompleteBroadcastProcessed(this)) {
            mHandler.post(mPeriodicProvisioningCheckRunnable);
        }
    }

    @Override
    protected void onStop() {
        super.onStop();
        mHandler.removeCallbacks(mPeriodicProvisioningCheckRunnable);
    }

    @Override
    protected void onNewIntent(Intent intent) {
        super.onNewIntent(intent);
        if (ByodHelperActivity.ACTION_PROFILE_OWNER_STATUS.equals(intent.getAction())) {
            // This is called when managed provisioning completes successfully without reboot.
            handleStatusUpdate(RESULT_OK, intent);
        } else if (ACTION_TEST_RESULT.equals(intent.getAction())) {
            // Called when subtest cannot communicate test result from the profile via setResult().
            handleLaunchTestResult(RESULT_OK, intent.getParcelableExtra(EXTRA_RESULT));
        }
    }

    @Override
    protected void handleActivityResult(int requestCode, int resultCode, Intent data) {
        switch (requestCode) {
            case REQUEST_MANAGED_PROVISIONING:
                return;
            case REQUEST_PROFILE_OWNER_STATUS:
                // Called after queryProfileOwner()
                handleStatusUpdate(resultCode, data);
                break;
            case REQUEST_CHECK_DISK_ENCRYPTION:
                // Called after checkDiskEncryption()
                handleDiskEncryptionStatus(resultCode, data);
                break;
            case REQUEST_SET_LOCK_FOR_ENCRYPTION:
                // Called after handleDiskEncryptionStatus() to set screen lock if necessary
                handleSetLockForEncryption();
                break;
            case REQUEST_INTENT_FILTERS_STATUS:
                // Called after checkIntentFilters()
                handleIntentFiltersStatus(resultCode);
                break;
            default:
                super.handleActivityResult(requestCode, resultCode, data);
        }
    }

    private void handleStatusUpdate(int resultCode, Intent data) {
        boolean provisioned = data != null &&
                data.getBooleanExtra(ByodHelperActivity.EXTRA_PROVISIONED, false);
        setProfileOwnerTestResult((provisioned && resultCode == RESULT_OK) ?
                TestResult.TEST_RESULT_PASSED : TestResult.TEST_RESULT_FAILED);
    }

    @Override
    public void finish() {
        // Pass and fail buttons are known to call finish() when clicked, and this is when we want to
        // clean up the provisioned profile.
        mByodFlowTestHelper.tearDown();
        super.finish();
    }

    @Override
    protected void setupTests(ArrayTestListAdapter adapter) {
        mProfileOwnerInstalled = new DialogTestListItem(this,
                R.string.provisioning_byod_profileowner,
                ""BYOD_ProfileOwnerInstalled"") {
            @Override
            public void performTest(DialogTestListActivity activity) {
                queryProfileOwner(true);
            }
        };

        mDiskEncryptionTest = new DialogTestListItem(this,
                R.string.provisioning_byod_disk_encryption,
                ""BYOD_DiskEncryptionTest"") {
            @Override
            public void performTest(DialogTestListActivity activity) {
                checkDiskEncryption();
            }
        };

        /*
         * To keep the image in this test up to date, use the instructions in
         * {@link ByodIconSamplerActivity}.
         */

        if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
            mWorkAppVisibleTest = new DialogTestListItemWithIcon(this,
                    R.string.provisioning_byod_workapps_visible,
                    ""BYOD_WorkAppVisibleTest"",
                    R.string.provisioning_byod_workapps_visible_instruction,
                    new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME),
                    R.drawable.badged_icon);

            mConfirmWorkCredentials = new DialogTestListItem(this,
                    R.string.provisioning_byod_confirm_work_credentials,
                    ""BYOD_ConfirmWorkCredentials"",
                    R.string.provisioning_byod_confirm_work_credentials_description,
                    new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME));

            mPatternWorkChallenge = new DialogTestListItem(this,
                    R.string.provisioning_byod_pattern_work_challenge,
                    ""BYOD_PatternWorkChallenge"",
                    R.string.provisioning_byod_pattern_work_challenge_description,
                    new Intent(ByodHelperActivity.ACTION_TEST_PATTERN_WORK_CHALLENGE));

            mWiFiDataUsageSettingsVisibleTest = new DialogTestListItem(this,
                    R.string.provisioning_byod_wifi_data_usage_settings,
                    ""BYOD_WiFiDataUsageSettingsVisibleTest"",
                    R.string.provisioning_byod_wifi_data_usage_settings_instruction,
                    new Intent(Settings.ACTION_SETTINGS));
        }

        mWorkNotificationBadgedTest = new DialogTestListItemWithIcon(this,
                R.string.provisioning_byod_work_notification,
                ""BYOD_WorkNotificationBadgedTest"",
                R.string.provisioning_byod_work_notification_instruction,
                new Intent(ByodHelperActivity.ACTION_NOTIFICATION),
                R.drawable.ic_corp_icon);

        Intent workStatusIcon = new Intent(WorkStatusTestActivity.ACTION_WORK_STATUS_ICON);
        workStatusIcon.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mWorkStatusBarIconTest = new DialogTestListItemWithIcon(this,
                R.string.provisioning_byod_work_status_icon,
                ""BYOD_WorkStatusBarIconTest"",
                R.string.provisioning_byod_work_status_icon_instruction,
                workStatusIcon,
                R.drawable.stat_sys_managed_profile_status);

        /* Disable due to b/111734436.
        Intent workStatusToast = new Intent(WorkStatusTestActivity.ACTION_WORK_STATUS_TOAST);
        workStatusToast.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mWorkStatusBarToastTest = new DialogTestListItem(this,
                R.string.provisioning_byod_work_status_toast,
                ""BYOD_WorkStatusBarToastTest"",
                R.string.provisioning_byod_work_status_toast_instruction,
                workStatusToast);
        */

        mNonMarketAppsTest = TestListItem.newTest(this,
                R.string.provisioning_byod_non_market_apps,
                NonMarketAppsActivity.class.getName(),
                new Intent(this, NonMarketAppsActivity.class), null);

        mProfileAccountVisibleTest = new DialogTestListItem(this,
                R.string.provisioning_byod_profile_visible,
                ""BYOD_ProfileAccountVisibleTest"",
                R.string.provisioning_byod_profile_visible_instruction,
                new Intent(Settings.ACTION_SETTINGS));

        mUserSettingsVisibleTest = new DialogTestListItem(this,
            R.string.provisioning_byod_user_settings,
            ""BYOD_UserSettingsVisibleTest"",
            R.string.provisioning_byod_user_settings_instruction,
            new Intent(Settings.ACTION_SETTINGS));

        mAppSettingsVisibleTest = new DialogTestListItem(this,
                R.string.provisioning_byod_app_settings,
                ""BYOD_AppSettingsVisibleTest"",
                R.string.provisioning_byod_app_settings_instruction,
                new Intent(Settings.ACTION_APPLICATION_SETTINGS));

        mDeviceAdminVisibleTest = new DialogTestListItem(this,
                R.string.provisioning_byod_admin_visible,
                ""BYOD_DeviceAdminVisibleTest"",
                R.string.provisioning_byod_admin_visible_instruction,
                new Intent(Settings.ACTION_SECURITY_SETTINGS));

        mCredSettingsVisibleTest = new DialogTestListItem(this,
                R.string.provisioning_byod_cred_settings,
                ""BYOD_CredSettingsVisibleTest"",
                R.string.provisioning_byod_cred_settings_instruction,
                new Intent(Settings.ACTION_SECURITY_SETTINGS));

        mLocationSettingsVisibleTest = new DialogTestListItem(this,
                R.string.provisioning_byod_location_settings,
                ""BYOD_LocationSettingsVisibleTest"",
                R.string.provisioning_byod_location_settings_instruction,
                new Intent(Settings.ACTION_LOCATION_SOURCE_SETTINGS));

        mCellularDataUsageSettingsVisibleTest = new DialogTestListItem(this,
                R.string.provisioning_byod_cellular_data_usage_settings,
                ""BYOD_CellularDataUsageSettingsVisibleTest"",
                R.string.provisioning_byod_cellular_data_usage_settings_instruction,
                new Intent(Settings.ACTION_SETTINGS));

        mPrintSettingsVisibleTest = new DialogTestListItem(this,
                R.string.provisioning_byod_print_settings,
                ""BYOD_PrintSettingsVisibleTest"",
                R.string.provisioning_byod_print_settings_instruction,
                new Intent(Settings.ACTION_PRINT_SETTINGS));

        Intent intent = new Intent(CrossProfileTestActivity.ACTION_CROSS_PROFILE_TO_WORK);
        intent.putExtra(CrossProfileTestActivity.EXTRA_STARTED_FROM_WORK, false);
        Intent chooser = Intent.createChooser(intent,
                getResources().getString(R.string.provisioning_cross_profile_chooser));
        mCrossProfileIntentFiltersTestFromPersonal = new DialogTestListItem(this,
                R.string.provisioning_byod_cross_profile_from_personal,
                ""BYOD_CrossProfileIntentFiltersTestFromPersonal"",
                R.string.provisioning_byod_cross_profile_from_personal_instruction,
                chooser);

        mCrossProfileIntentFiltersTestFromWork = new DialogTestListItem(this,
                R.string.provisioning_byod_cross_profile_from_work,
                ""BYOD_CrossProfileIntentFiltersTestFromWork"",
                R.string.provisioning_byod_cross_profile_from_work_instruction,
                new Intent(ByodHelperActivity.ACTION_TEST_CROSS_PROFILE_INTENTS_DIALOG));

        /* Disable due to b/33571176
        mAppLinkingTest = new DialogTestListItem(this,
                R.string.provisioning_app_linking,
                ""BYOD_AppLinking"",
                R.string.provisioning_byod_app_linking_instruction,
                new Intent(ByodHelperActivity.ACTION_TEST_APP_LINKING_DIALOG));
        */

        mKeyguardDisabledFeaturesTest = TestListItem.newTest(this,
                R.string.provisioning_byod_keyguard_disabled_features,
                KeyguardDisabledFeaturesActivity.class.getName(),
                new Intent(this, KeyguardDisabledFeaturesActivity.class), null);

        mAuthenticationBoundKeyTest = TestListItem.newTest(this,
                R.string.provisioning_byod_auth_bound_key,
                AuthenticationBoundKeyTestActivity.class.getName(),
                new Intent(AuthenticationBoundKeyTestActivity.ACTION_AUTH_BOUND_KEY_TEST),
                null);

        mVpnTest = TestListItem.newTest(this,
                R.string.provisioning_byod_vpn,
                VpnTestActivity.class.getName(),
                new Intent(VpnTestActivity.ACTION_VPN),
                null);

        mAlwaysOnVpnSettingsTest = TestListItem.newTest(this,
                R.string.provisioning_byod_always_on_vpn,
                AlwaysOnVpnSettingsTestActivity.class.getName(),
                new Intent(AlwaysOnVpnSettingsTestActivity.ACTION_ALWAYS_ON_VPN_SETTINGS_TEST),
                null);

        mDisallowAppsControlTest = TestListItem.newTest(this,
                R.string.provisioning_byod_disallow_apps_control,
                DisallowAppsControlActivity.class.getName(),
                new Intent(this, DisallowAppsControlActivity.class), null);

        // Test for checking if the required intent filters are set during managed provisioning.
        mIntentFiltersTest = new DialogTestListItem(this,
                R.string.provisioning_byod_cross_profile_intent_filters,
                ""BYOD_IntentFiltersTest"") {
            @Override
            public void performTest(DialogTestListActivity activity) {
                checkIntentFilters();
            }
        };

        mCrossProfilePermissionControl = TestListItem.newTest(this,
                R.string.provisioning_byod_cross_profile_permission_control,
                CrossProfilePermissionControlActivity.class.getName(),
                new Intent(
                        CrossProfilePermissionControlActivity.ACTION_CROSS_PROFILE_PERMISSION_CONTROL),
                        null);

        mTurnOffWorkFeaturesTest = TestListItem.newTest(this,
                R.string.provisioning_byod_turn_off_work,
                TurnOffWorkActivity.class.getName(),
                new Intent(this, TurnOffWorkActivity.class), null);

        Intent permissionCheckIntent = new Intent(
                PermissionLockdownTestActivity.ACTION_MANAGED_PROFILE_CHECK_PERMISSION_LOCKDOWN);
        mPermissionLockdownTest = new DialogTestListItem(this,
                R.string.device_profile_owner_permission_lockdown_test,
                ""BYOD_PermissionLockdownTest"",
                R.string.profile_owner_permission_lockdown_test_info,
                permissionCheckIntent);

        mSelectWorkChallenge = new DialogTestListItem(this,
                R.string.provisioning_byod_select_work_challenge,
                ""BYOD_SelectWorkChallenge"",
                R.string.provisioning_byod_select_work_challenge_description,
                new Intent(ByodHelperActivity.ACTION_TEST_SELECT_WORK_CHALLENGE));

        mRecentsTest = TestListItem.newTest(this,
                R.string.provisioning_byod_recents,
                RecentsRedactionActivity.class.getName(),
                new Intent(RecentsRedactionActivity.ACTION_RECENTS).setFlags(
                        Intent.FLAG_ACTIVITY_NEW_TASK),
                null);

        mOrganizationInfoTest = TestListItem.newTest(this,
                R.string.provisioning_byod_organization_info,
                OrganizationInfoTestActivity.class.getName(),
                new Intent(this, OrganizationInfoTestActivity.class),
                null);

        mKeyChainTest = TestListItem.newTest(this,
                R.string.provisioning_byod_keychain,
                KeyChainTestActivity.class.getName(),
                new Intent(KeyChainTestActivity.ACTION_KEYCHAIN),
                null);

        mParentProfilePassword = new DialogTestListItem(this,
                R.string.provisioning_byod_parent_profile_password,
                ""BYOD_ParentProfilePasswordTest"",
                R.string.provisioning_byod_parent_profile_password_description,
                new Intent(ByodHelperActivity.ACTION_TEST_PARENT_PROFILE_PASSWORD));

        mPersonalRingtonesTest = new DialogTestListItem(this,
                R.string.provisioning_byod_personal_ringtones,
                ""BYOD_PersonalRingtones"",
                R.string.provisioning_byod_personal_ringtones_instruction,
                new Intent(Settings.ACTION_SOUND_SETTINGS));

        final Intent policyTransparencyTestIntent = new Intent(this,
                PolicyTransparencyTestListActivity.class);
        policyTransparencyTestIntent.putExtra(
                PolicyTransparencyTestListActivity.EXTRA_MODE,
                PolicyTransparencyTestListActivity.MODE_MANAGED_PROFILE);
        policyTransparencyTestIntent.putExtra(
                PolicyTransparencyTestActivity.EXTRA_TEST_ID, ""BYOD_PolicyTransparency"");
        mPolicyTransparencyTest = TestListItem.newTest(this,
                R.string.device_profile_owner_policy_transparency_test,
                ""BYOD_PolicyTransparency"",
                policyTransparencyTestIntent, null);

        adapter.add(mProfileOwnerInstalled);
        adapter.add(mDiskEncryptionTest);

        // Badge related tests
        if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
            adapter.add(mWorkAppVisibleTest);
        }

        adapter.add(mWorkNotificationBadgedTest);
        adapter.add(mWorkStatusBarIconTest);

        /* Disable due to b/111734436.
        adapter.add(mWorkStatusBarToastTest);
        */

        // Settings related tests.
        adapter.add(mProfileAccountVisibleTest);
        adapter.add(mDeviceAdminVisibleTest);
        adapter.add(mCredSettingsVisibleTest);
        adapter.add(mUserSettingsVisibleTest);
        adapter.add(mAppSettingsVisibleTest);
        adapter.add(mLocationSettingsVisibleTest);
        adapter.add(mPrintSettingsVisibleTest);
        adapter.add(mPersonalRingtonesTest);

        adapter.add(mCrossProfileIntentFiltersTestFromPersonal);
        adapter.add(mCrossProfileIntentFiltersTestFromWork);
        /* Disable due to b/33571176
        adapter.add(mAppLinkingTest);
        */
        adapter.add(mIntentFiltersTest);
        adapter.add(mCrossProfilePermissionControl);
        adapter.add(mNonMarketAppsTest);
        adapter.add(mPermissionLockdownTest);
        adapter.add(mKeyguardDisabledFeaturesTest);
        adapter.add(mAuthenticationBoundKeyTest);
        adapter.add(mVpnTest);
        adapter.add(mAlwaysOnVpnSettingsTest);
        adapter.add(mTurnOffWorkFeaturesTest);
        adapter.add(mSelectWorkChallenge);
        if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
            adapter.add(mConfirmWorkCredentials);
            adapter.add(mPatternWorkChallenge);
        }
        adapter.add(mRecentsTest);
        adapter.add(mOrganizationInfoTest);
        adapter.add(mParentProfilePassword);
        adapter.add(mPolicyTransparencyTest);

        if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)) {
            if (getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI)) {
                adapter.add(mWiFiDataUsageSettingsVisibleTest);
            }
        }

        mCm = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);
        if(mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) != null) {
            adapter.add(mCellularDataUsageSettingsVisibleTest);
        }

        if (canResolveIntent(new Intent(Settings.ACTION_APPLICATION_SETTINGS))) {
            adapter.add(mDisallowAppsControlTest);
        }

        /* If there is an application that handles ACTION_IMAGE_CAPTURE, test that it handles it
         * well.
         */
        if (canResolveIntent(ByodHelperActivity.getCaptureImageIntent())) {
            // Capture image intent can be resolved in primary profile, so test.
            mCrossProfileImageCaptureSupportTest = new DialogTestListItem(this,
                    R.string.provisioning_byod_capture_image_support,
                    ""BYOD_CrossProfileImageCaptureSupportTest"",
                    R.string.provisioning_byod_capture_image_support_info,
                    new Intent(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_IMAGE));
            adapter.add(mCrossProfileImageCaptureSupportTest);
        } else {
            // Capture image intent cannot be resolved in primary profile, so skip test.
            Toast.makeText(ByodFlowTestActivity.this,
                    R.string.provisioning_byod_no_image_capture_resolver, Toast.LENGTH_SHORT)
                    .show();
        }

        /* If there is an application that handles ACTION_VIDEO_CAPTURE, test that it handles it
         * well.
         */
        if (canResolveIntent(ByodHelperActivity.getCaptureVideoIntent())) {
            // Capture video intent can be resolved in primary profile, so test.
            mCrossProfileVideoCaptureWithExtraOutputSupportTest = new DialogTestListItem(this,
                    R.string.provisioning_byod_capture_video_support_with_extra_output,
                    ""BYOD_CrossProfileVideoCaptureWithExtraOutputSupportTest"",
                    R.string.provisioning_byod_capture_video_support_info,
                    new Intent(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_VIDEO_WITH_EXTRA_OUTPUT));
            adapter.add(mCrossProfileVideoCaptureWithExtraOutputSupportTest);
            mCrossProfileVideoCaptureWithoutExtraOutputSupportTest = new DialogTestListItem(this,
                    R.string.provisioning_byod_capture_video_support_without_extra_output,
                    ""BYOD_CrossProfileVideoCaptureWithoutExtraOutputSupportTest"",
                    R.string.provisioning_byod_capture_video_support_info,
                    new Intent(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_VIDEO_WITHOUT_EXTRA_OUTPUT));
            adapter.add(mCrossProfileVideoCaptureWithoutExtraOutputSupportTest);
        } else {
            // Capture video intent cannot be resolved in primary profile, so skip test.
            Toast.makeText(ByodFlowTestActivity.this,
                    R.string.provisioning_byod_no_video_capture_resolver, Toast.LENGTH_SHORT)
                    .show();
        }

        if (getPackageManager().hasSystemFeature(PackageManager.FEATURE_NFC)
                && getPackageManager().hasSystemFeature(PackageManager.FEATURE_NFC_BEAM)) {
            mDisableNfcBeamTest = new DialogTestListItem(this, R.string.provisioning_byod_nfc_beam,
                    ""BYOD_DisableNfcBeamTest"",
                    R.string.provisioning_byod_nfc_beam_allowed_instruction,
                    new Intent(ByodHelperActivity.ACTION_TEST_NFC_BEAM)) {
                @Override
                public void performTest(final DialogTestListActivity activity) {
                    activity.showManualTestDialog(mDisableNfcBeamTest,
                            new DefaultTestCallback(mDisableNfcBeamTest) {
                        @Override
                        public void onPass() {
                            // Start a second test with beam disallowed by policy.
                            Intent testNfcBeamIntent = new Intent(
                                    ByodHelperActivity.ACTION_TEST_NFC_BEAM);
                            testNfcBeamIntent.putExtra(NfcTestActivity.EXTRA_DISALLOW_BY_POLICY,
                                    true);
                            DialogTestListItem disableNfcBeamTest2 =
                                    new DialogTestListItem(activity,
                                    R.string.provisioning_byod_nfc_beam,
                                    ""BYOD_DisableNfcBeamTest"",
                                    R.string.provisioning_byod_nfc_beam_disallowed_instruction,
                                    testNfcBeamIntent);
                            // The result should be reflected on the original test.
                            activity.showManualTestDialog(disableNfcBeamTest2,
                                    new DefaultTestCallback(mDisableNfcBeamTest));
                        }
                    });
                }
            };
            adapter.add(mDisableNfcBeamTest);
        }

        adapter.add(mKeyChainTest);

        /* If there is an application that handles RECORD_SOUND_ACTION, test that it handles it
         * well.
         */
        if (canResolveIntent(ByodHelperActivity.getCaptureAudioIntent())) {
            // Capture audio intent can be resolved in primary profile, so test.
            mCrossProfileAudioCaptureSupportTest = new DialogTestListItem(this,
                    R.string.provisioning_byod_capture_audio_support,
                    ""BYOD_CrossProfileAudioCaptureSupportTest"",
                    R.string.provisioning_byod_capture_audio_support_info,
                    new Intent(ByodHelperActivity.ACTION_CAPTURE_AND_CHECK_AUDIO));
            adapter.add(mCrossProfileAudioCaptureSupportTest);
        } else {
            // Capture audio intent cannot be resolved in primary profile, so skip test.
            Toast.makeText(ByodFlowTestActivity.this,
                    R.string.provisioning_byod_no_audio_capture_resolver, Toast.LENGTH_SHORT)
                    .show();
        }

        if (getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOCATION_GPS)) {
            mEnableLocationModeTest = TestListItem.newTest(this,
                    R.string.provisioning_byod_location_mode_enable,
                    LocationTestActivity.TEST_ID_LOCATION_ENABLED,
                    new Intent(LocationTestActivity.ACTION_TEST_LOCATION_ENABLED),
                    null);
            mDisableLocationModeThroughMainSwitchTest = TestListItem.newTest(this,
                    R.string.provisioning_byod_location_mode_disable,
                    LocationTestActivity.TEST_ID_LOCATION_DISABLED,
                    new Intent(LocationTestActivity.ACTION_TEST_LOCATION_DISABLED),
                    null);
            mDisableLocationModeThroughWorkSwitchTest = TestListItem.newTest(this,
                    R.string.provisioning_byod_work_location_mode_disable,
                    LocationTestActivity.TEST_ID_WORK_LOCATION_DISABLED,
                    new Intent(LocationTestActivity.ACTION_TEST_WORK_LOCATION_DISABLED),
                    null);
            mPrimaryLocationWhenWorkDisabledTest = TestListItem.newTest(this,
                    R.string.provisioning_byod_primary_location_when_work_disabled,
                    LocationTestActivity.TEST_ID_WORK_LOCATION_DISABLED_PRIMARY,
                    new Intent(LocationTestActivity.ACTION_TEST_WORK_LOCATION_DISABLED_PRIMARY),
                    null);
            adapter.add(mEnableLocationModeTest);
            adapter.add(mDisableLocationModeThroughMainSwitchTest);
            adapter.add(mDisableLocationModeThroughWorkSwitchTest);
            adapter.add(mPrimaryLocationWhenWorkDisabledTest);
        } else {
            // The system does not support GPS feature, so skip test.
            Toast.makeText(ByodFlowTestActivity.this,
                    R.string.provisioning_byod_no_gps_location_feature, Toast.LENGTH_SHORT)
                    .show();
        }

        if (getPackageManager().hasSystemFeature(PackageManager.FEATURE_APP_WIDGETS)) {
            mWidgetTest = TestListItem.newTest(this,
                    R.string.provisioning_byod_work_profile_widget,
                    WorkProfileWidgetActivity.class.getName(),
                    new Intent(WorkProfileWidgetActivity.ACTION_TEST_WORK_PROFILE_WIDGET),
                    new String[]{PackageManager.FEATURE_APP_WIDGETS});
            adapter.add(mWidgetTest);
        }

        adapter.add(new DialogTestListItem(this,
                R.string.provisioning_byod_uninstall_work_app,
                ""BYOD_UninstallWorkApp"",
                R.string.provisioning_byod_uninstall_work_app_instruction,
                createInstallWorkProfileAppIntent()));
    }

    private Intent createInstallWorkProfileAppIntent() {
        // We place the APK file in /data/local/tmp to make it visible from the work profile.
        return new Intent(ByodHelperActivity.ACTION_INSTALL_APK)
                .putExtra(ByodHelperActivity.EXTRA_ALLOW_NON_MARKET_APPS, true)
                .putExtra(ByodHelperActivity.EXTRA_PARAMETER_1, HELPER_APP_PATH);
    }

    // Return whether the intent can be resolved in the current profile
    private boolean canResolveIntent(Intent intent) {
        return intent.resolveActivity(getPackageManager()) != null;
    }

    @Override
    protected void clearRemainingState(final DialogTestListItem test) {
        super.clearRemainingState(test);
        if (ByodHelperActivity.ACTION_NOTIFICATION.equals(
                test.getManualTestIntent().getAction())) {
            try {
                startActivity(new Intent(
                        ByodHelperActivity.ACTION_CLEAR_NOTIFICATION));
            } catch (ActivityNotFoundException e) {
                // User shouldn't run this test before work profile is set up.
            }
        }
    }

    private void queryProfileOwner(boolean showToast) {
        try {
            // Set execution start time for counting test execution time.
            mStartTime = System.currentTimeMillis();
            Intent intent = new Intent(ByodHelperActivity.ACTION_QUERY_PROFILE_OWNER);
            startActivityForResult(intent, REQUEST_PROFILE_OWNER_STATUS);
        }
        catch (ActivityNotFoundException e) {
            Log.d(TAG, ""queryProfileOwner: ActivityNotFoundException"", e);
            setProfileOwnerTestResult(TestResult.TEST_RESULT_FAILED);
            if (showToast) {
                Utils.showToast(this, R.string.provisioning_byod_no_activity);
            }
        }
    }

    private void setProfileOwnerTestResult(int result) {
        setTestResult(mProfileOwnerInstalled, result);
        if (result == TestResult.TEST_RESULT_FAILED) {
            clearProvisioningCompleteBroadcastStatus(this);
            startPeriodicProvisioningCheckIfNecessary();
        }
    }

    private void checkDiskEncryption() {
        try {
            Intent intent = new Intent(ByodHelperActivity.ACTION_CHECK_DISK_ENCRYPTION);
            startActivityForResult(intent, REQUEST_CHECK_DISK_ENCRYPTION);
        } catch (ActivityNotFoundException e) {
            Log.d(TAG, ""checkDiskEncryption: ActivityNotFoundException"", e);
            setTestResult(mDiskEncryptionTest, TestResult.TEST_RESULT_FAILED);
            Utils.showToast(this, R.string.provisioning_byod_no_activity);
        }
    }

    private void handleDiskEncryptionStatus(int resultCode, Intent data) {
        if (resultCode != RESULT_OK || data == null) {
            Log.e(TAG, ""Failed to get result for disk encryption, result code: "" + resultCode);
            setTestResult(mDiskEncryptionTest, TestResult.TEST_RESULT_FAILED);
            return;
        }

        final int status = data.getIntExtra(ByodHelperActivity.EXTRA_ENCRYPTION_STATUS,
                DevicePolicyManager.ENCRYPTION_STATUS_UNSUPPORTED);
        switch (status) {
            case DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE:
            case DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE_PER_USER:
                setTestResult(mDiskEncryptionTest, TestResult.TEST_RESULT_PASSED);
                break;
            case DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE_DEFAULT_KEY:
                if (!mKeyguardManager.isDeviceSecure()) {
                    Utils.setScreenLock(this, REQUEST_SET_LOCK_FOR_ENCRYPTION);
                    return;
                }
                Log.e(TAG, ""Disk encryption key is not entangled with lock screen credentials"");
                Toast.makeText(this, R.string.provisioning_byod_disk_encryption_default_key_toast,
                        Toast.LENGTH_LONG).show();
                // fall through
            default:
                setTestResult(mDiskEncryptionTest, TestResult.TEST_RESULT_FAILED);
        }

        if (mKeyguardManager.isDeviceSecure()) {
            Utils.removeScreenLock(this);
        }
    }

    private void handleSetLockForEncryption() {
        if (mKeyguardManager.isDeviceSecure()) {
            checkDiskEncryption();
        } else {
            setTestResult(mDiskEncryptionTest, TestResult.TEST_RESULT_FAILED);
            Toast.makeText(this, R.string.provisioning_byod_disk_encryption_no_pin_toast,
                    Toast.LENGTH_LONG).show();
        }
    }

    private void checkIntentFilters() {
        try {
            // Enable component HandleIntentActivity before intent filters are checked.
            setHandleIntentActivityEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_ENABLED);
            // We disable the ByodHelperActivity in the primary profile. So, this intent
            // will be handled by the ByodHelperActivity in the managed profile.
            Intent intent = new Intent(ByodHelperActivity.ACTION_CHECK_INTENT_FILTERS);
            startActivityForResult(intent, REQUEST_INTENT_FILTERS_STATUS);
        } catch (ActivityNotFoundException e) {
            // Disable component HandleIntentActivity if intent filters check fails.
            setHandleIntentActivityEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED);
            Log.d(TAG, ""checkIntentFilters: ActivityNotFoundException"", e);
            setTestResult(mIntentFiltersTest, TestResult.TEST_RESULT_FAILED);
            Utils.showToast(this, R.string.provisioning_byod_no_activity);
        }
    }

    private void handleIntentFiltersStatus(int resultCode) {
        // Disable component HandleIntentActivity after intent filters are checked.
        setHandleIntentActivityEnabledSetting(PackageManager.COMPONENT_ENABLED_STATE_DISABLED);
        // we use the resultCode from ByodHelperActivity in the managed profile to know if certain
        // intents fired from the managed profile are forwarded.
        final boolean intentFiltersSetForManagedIntents = (resultCode == RESULT_OK);
        // Since the ByodFlowTestActivity is running in the primary profile, we directly use
        // the IntentFiltersTestHelper to know if certain intents fired from the primary profile
        // are forwarded.
        final boolean intentFiltersSetForPrimaryIntents =
                new IntentFiltersTestHelper(this).checkCrossProfileIntentFilters(
                        IntentFiltersTestHelper.FLAG_INTENTS_FROM_PRIMARY);
        final boolean intentFiltersSet =
                intentFiltersSetForPrimaryIntents & intentFiltersSetForManagedIntents;
        setTestResult(mIntentFiltersTest,
                intentFiltersSet ? TestResult.TEST_RESULT_PASSED : TestResult.TEST_RESULT_FAILED);
    }

    private void setHandleIntentActivityEnabledSetting(final int enableState) {
        getPackageManager().setComponentEnabledSetting(
            new ComponentName(ByodFlowTestActivity.this, HandleIntentActivity.class.getName()),
            enableState, PackageManager.DONT_KILL_APP);
    }

    private static void markProvisioningCompleteBroadcastReceived(Context context) {
        markProvisioningCompleteBroadcastWithStatus(context,
                PREFERENCE_PROVISIONING_COMPLETE_STATUS_RECEIVED);
    }

    private static void markProvisioningCompleteBroadcastProcessed(Context context) {
        markProvisioningCompleteBroadcastWithStatus(context,
                PREFERENCE_PROVISIONING_COMPLETE_STATUS_PROCESSED);
    }

    private static void clearProvisioningCompleteBroadcastStatus(Context context) {
        markProvisioningCompleteBroadcastWithStatus(context,
                PREFERENCE_PROVISIONING_COMPLETE_STATUS_NOT_RECEIVED);
    }

    private static void markProvisioningCompleteBroadcastWithStatus(Context context, int status) {
        final SharedPreferences prefs = getProvisioningPreferences(context);
        final SharedPreferences.Editor editor = prefs.edit();
        editor.putInt(PREFERENCE_PROVISIONING_COMPLETE_STATUS, status);
        editor.commit();
    }

    private static boolean isProvisioningCompleteBroadcastReceived(Context context) {
        return getProvisioningPreferences(context)
                .getInt(PREFERENCE_PROVISIONING_COMPLETE_STATUS, 0) ==
                PREFERENCE_PROVISIONING_COMPLETE_STATUS_RECEIVED;
    }

    private static boolean isProvisioningCompleteBroadcastProcessed(Context context) {
        return getProvisioningPreferences(context)
                .getInt(PREFERENCE_PROVISIONING_COMPLETE_STATUS, 0) ==
                PREFERENCE_PROVISIONING_COMPLETE_STATUS_PROCESSED;
    }

    private static SharedPreferences getProvisioningPreferences(Context context) {
        return context.getSharedPreferences(PROVISIONING_PREFERENCES, MODE_PRIVATE);
    }
}"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.normalapp.ClientTest"	"testQuery"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/NormalApp/src/com/android/cts/normalapp/ClientTest.java"	""	"public void testQuery() throws Exception {
        // query activities without flags
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            final List<ResolveInfo> resolveInfo = InstrumentationRegistry.getContext()
                    .getPackageManager().queryIntentActivities(queryIntent, 0 /*flags*/);
            if (resolveInfo == null || resolveInfo.size() == 0) {
                fail(""didn't resolve any intents"");
            }
            assertThat(resolveInfo.size(), is(2));
            assertThat(resolveInfo.get(0).activityInfo.packageName,
                    is(""com.android.cts.normalapp""));
            assertThat(resolveInfo.get(0).activityInfo.name,
                    is(""com.android.cts.normalapp.ExposedActivity""));
            assertThat(resolveInfo.get(0).isInstantAppAvailable,
                    is(false));
            assertThat(resolveInfo.get(1).activityInfo.packageName,
                    is(""com.android.cts.normalapp""));
            assertThat(resolveInfo.get(1).activityInfo.name,
                    is(""com.android.cts.normalapp.NormalActivity""));
            assertThat(resolveInfo.get(1).isInstantAppAvailable,
                    is(false));
        }

        // query activities asking for ephemeral apps [we should only get normal apps]
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            final int MATCH_EPHEMERAL = 0x00800000;

            final List<ResolveInfo> resolveInfo = InstrumentationRegistry.getContext()
                    .getPackageManager().queryIntentActivities(queryIntent, MATCH_EPHEMERAL);
            if (resolveInfo == null || resolveInfo.size() == 0) {
                fail(""didn't resolve any intents"");
            }
            assertThat(resolveInfo.size(), is(2));
            assertThat(resolveInfo.get(0).activityInfo.packageName,
                    is(""com.android.cts.normalapp""));
            assertThat(resolveInfo.get(0).activityInfo.name,
                    is(""com.android.cts.normalapp.ExposedActivity""));
            assertThat(resolveInfo.get(0).isInstantAppAvailable,
                    is(false));
            assertThat(resolveInfo.get(1).activityInfo.packageName,
                    is(""com.android.cts.normalapp""));
            assertThat(resolveInfo.get(1).activityInfo.name,
                    is(""com.android.cts.normalapp.NormalActivity""));
            assertThat(resolveInfo.get(1).isInstantAppAvailable,
                    is(false));
        }

        // query activities; directed package
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            queryIntent.setPackage(EPHEMERAL_1_PKG);
            final List<ResolveInfo> resolveInfo = InstrumentationRegistry.getContext()
                    .getPackageManager().queryIntentActivities(queryIntent, 0 /*flags*/);
            assertThat(resolveInfo.size(), is(0));
        }

        // query activities; directed component
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            queryIntent.setComponent(
                    new ComponentName(EPHEMERAL_1_PKG,
                            ""com.android.cts.ephemeralapp1.EphemeralActivity""));
            final List<ResolveInfo> resolveInfo = InstrumentationRegistry.getContext()
                    .getPackageManager().queryIntentActivities(queryIntent, 0 /*flags*/);
            assertThat(resolveInfo.size(), is(0));
        }

        // query services without flags
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            final List<ResolveInfo> resolveInfo = InstrumentationRegistry.getContext()
                    .getPackageManager().queryIntentServices(queryIntent, 0 /*flags*/);
            if (resolveInfo == null || resolveInfo.size() == 0) {
                fail(""didn't resolve any intents"");
            }
            assertThat(resolveInfo.size(), is(2));
            assertThat(resolveInfo.get(0).serviceInfo.packageName,
                    is(""com.android.cts.normalapp""));
            assertThat(resolveInfo.get(0).serviceInfo.name,
                    is(""com.android.cts.normalapp.ExposedService""));
            assertThat(resolveInfo.get(0).isInstantAppAvailable,
                    is(false));
            assertThat(resolveInfo.get(1).serviceInfo.packageName,
                    is(""com.android.cts.normalapp""));
            assertThat(resolveInfo.get(1).serviceInfo.name,
                    is(""com.android.cts.normalapp.NormalService""));
            assertThat(resolveInfo.get(1).isInstantAppAvailable,
                    is(false));
        }

        // query services asking for ephemeral apps [we should only get normal apps]
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            final int MATCH_EPHEMERAL = 0x00800000;

            final List<ResolveInfo> resolveInfo = InstrumentationRegistry.getContext()
                    .getPackageManager().queryIntentServices(queryIntent, MATCH_EPHEMERAL);
            if (resolveInfo == null || resolveInfo.size() == 0) {
                fail(""didn't resolve any intents"");
            }
            assertThat(resolveInfo.size(), is(2));
            assertThat(resolveInfo.get(0).serviceInfo.packageName,
                    is(""com.android.cts.normalapp""));
            assertThat(resolveInfo.get(0).serviceInfo.name,
                    is(""com.android.cts.normalapp.ExposedService""));
            assertThat(resolveInfo.get(0).isInstantAppAvailable,
                    is(false));
            assertThat(resolveInfo.get(1).serviceInfo.packageName,
                    is(""com.android.cts.normalapp""));
            assertThat(resolveInfo.get(1).serviceInfo.name,
                    is(""com.android.cts.normalapp.NormalService""));
            assertThat(resolveInfo.get(1).isInstantAppAvailable,
                    is(false));
        }

        // query services; directed package
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            queryIntent.setPackage(EPHEMERAL_1_PKG);
            final List<ResolveInfo> resolveInfo = InstrumentationRegistry.getContext()
                    .getPackageManager().queryIntentServices(queryIntent, 0 /*flags*/);
            assertThat(resolveInfo.size(), is(0));
        }

        // query services; directed component
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            queryIntent.setComponent(
                    new ComponentName(EPHEMERAL_1_PKG,
                            ""com.android.cts.ephemeralapp1.EphemeralService""));
            final List<ResolveInfo> resolveInfo = InstrumentationRegistry.getContext()
                    .getPackageManager().queryIntentServices(queryIntent, 0 /*flags*/);
            assertThat(resolveInfo.size(), is(0));
        }

        // query content providers without flags
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            final List<ResolveInfo> resolveInfo = InstrumentationRegistry
                    .getContext().getPackageManager().queryIntentContentProviders(
                            queryIntent, 0 /*flags*/);
            if (resolveInfo == null || resolveInfo.size() == 0) {
                fail(""didn't resolve any intents"");
            }
            assertThat(resolveInfo.size(), is(2));
            assertThat(resolveInfo.get(0).providerInfo.packageName,
                    is(""com.android.cts.normalapp""));
            assertThat(resolveInfo.get(0).providerInfo.name,
                    is(""com.android.cts.normalapp.ExposedProvider""));
            assertThat(resolveInfo.get(1).providerInfo.packageName,
                    is(""com.android.cts.normalapp""));
            assertThat(resolveInfo.get(1).providerInfo.name,
                    is(""com.android.cts.normalapp.NormalProvider""));
            assertThat(resolveInfo.get(1).isInstantAppAvailable,
                    is(false));
        }

        // query content providers asking for ephemeral apps [we should only get normal apps]
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            final int MATCH_EPHEMERAL = 0x00800000;

            final List<ResolveInfo> resolveInfo = InstrumentationRegistry.getContext()
                    .getPackageManager().queryIntentContentProviders(
                            queryIntent, MATCH_EPHEMERAL);
            if (resolveInfo == null || resolveInfo.size() == 0) {
                fail(""didn't resolve any intents"");
            }
            assertThat(resolveInfo.size(), is(2));
            assertThat(resolveInfo.get(0).providerInfo.packageName,
                    is(""com.android.cts.normalapp""));
            assertThat(resolveInfo.get(0).providerInfo.name,
                    is(""com.android.cts.normalapp.ExposedProvider""));
            assertThat(resolveInfo.get(1).providerInfo.packageName,
                    is(""com.android.cts.normalapp""));
            assertThat(resolveInfo.get(1).providerInfo.name,
                    is(""com.android.cts.normalapp.NormalProvider""));
            assertThat(resolveInfo.get(1).isInstantAppAvailable,
                    is(false));
        }

        // query content providers; directed package
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            queryIntent.setPackage(EPHEMERAL_1_PKG);
            final List<ResolveInfo> resolveInfo = InstrumentationRegistry.getContext()
                    .getPackageManager().queryIntentContentProviders(queryIntent, 0 /*flags*/);
            assertThat(resolveInfo.size(), is(0));
        }

        // query content providers; directed component
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            queryIntent.setComponent(
                    new ComponentName(EPHEMERAL_1_PKG,
                            ""com.android.cts.ephemeralapp1.EphemeralProvider""));
            final List<ResolveInfo> resolveInfo = InstrumentationRegistry.getContext()
                    .getPackageManager().queryIntentContentProviders(queryIntent, 0 /*flags*/);
            assertThat(resolveInfo.size(), is(0));
        }
    }"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.normalapp.ClientTest"	"testGetChangedPackages"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/NormalApp/src/com/android/cts/normalapp/ClientTest.java"	""	"public void testGetChangedPackages() {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();

        // Query changed packages without permission, and we should only get normal apps.
        final ChangedPackages changedPackages = pm.getChangedPackages(0);
        assertThat(changedPackages.getPackageNames()).doesNotContain(EPHEMERAL_1_PKG);

        // Query changed packages with permission, and we should be able to get ephemeral apps.
        runWithShellPermissionIdentity(() -> {
            final ChangedPackages changesInstantApp = pm.getChangedPackages(0);
            assertThat(changesInstantApp.getPackageNames()).contains(EPHEMERAL_1_PKG);
        }, Manifest.permission.ACCESS_INSTANT_APPS);
    }"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.normalapp.ClientTest"	"isFalse"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/NormalApp/src/com/android/cts/normalapp/ClientTest.java"	""	"public void uninstall_pruneInstantApp_shouldNotBeUserInitiated() {
        runWithShellPermissionIdentity(() -> {
            final boolean userInitiated = pruneInstantAppAndWaitForExtraUserInitiated(
                    InstrumentationRegistry.getContext(), EPHEMERAL_1_PKG);

            assertThat(userInitiated).isFalse();
        }, Manifest.permission.WRITE_SECURE_SETTINGS, Manifest.permission.ACCESS_INSTANT_APPS);
    }

    /**
     * Uninstall the package and wait for the package removed intent.
     *
     * @return The value of {@link Intent#EXTRA_USER_INITIATED} associated with the intent.
     */
    private boolean uninstallAndWaitForExtraUserInitiated(Context context, String packageName) {
        final Runnable uninstall = () -> {
            final PackageInstaller packageInstaller = context.getPackageManager()
                    .getPackageInstaller();
            packageInstaller.uninstall(packageName, null);
        };

        final Intent packageRemoved = executeAndWaitForPackageRemoved(
                context, packageName, uninstall);
        return packageRemoved.getBooleanExtra(Intent.EXTRA_USER_INITIATED, false);
    }

    /**
     * Runs the shell command {@code pm trim-caches} to invoke system to prune instant applications.
     * Waits for the package removed intent and returns the extra filed.
     *
     * @return The value of {@link Intent#EXTRA_USER_INITIATED} associated with the intent.
     */
    private boolean pruneInstantAppAndWaitForExtraUserInitiated(Context context,
            String packageName) {
        final String defaultPeriod = Settings.Global.getString(context.getContentResolver(),
                INSTALLED_INSTANT_APP_MIN_CACHE_PERIOD);
        final Runnable trimCaches = () -> {
            // Updates installed instant app minimum cache period to zero to ensure that system
            // could uninstall instant apps when trim-caches is invoked.
            Settings.Global.putInt(context.getContentResolver(),
                    INSTALLED_INSTANT_APP_MIN_CACHE_PERIOD, 0);
            SystemUtil.runShellCommand(""pm trim-caches "" + Long.MAX_VALUE + "" internal"");
        };

        try {
            final Intent packageRemoved = executeAndWaitForPackageRemoved(
                    context, packageName, trimCaches);
            return packageRemoved.getBooleanExtra(Intent.EXTRA_USER_INITIATED, false);
        } finally {
            Settings.Global.putString(context.getContentResolver(),
                    INSTALLED_INSTANT_APP_MIN_CACHE_PERIOD, defaultPeriod);
        }
    }

    /**
     * Executes a command and waits for the package removed intent.
     *
     * @return The {@link Intent#ACTION_PACKAGE_REMOVED} associated with the given package name.
     */
    private Intent executeAndWaitForPackageRemoved(Context context, String packageName,
            Runnable command) {
        final IntentFilter filter = new IntentFilter(Intent.ACTION_PACKAGE_REMOVED);
        filter.addDataScheme(""package"");
        filter.addDataSchemeSpecificPart(packageName, PatternMatcher.PATTERN_LITERAL);
        final BlockingQueue<Intent> intentQueue = new LinkedBlockingQueue<>();
        final BroadcastReceiver removedReceiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                try {
                    intentQueue.put(intent);
                } catch (InterruptedException e) {
                    fail(""Cannot add intent to intent blocking queue!"");
                }
            }
        };
        context.registerReceiver(removedReceiver, filter);
        try {
            command.run();
            final Intent intent = intentQueue.poll(60 /* timeout */, TimeUnit.SECONDS);
            assertNotNull(""Timed out to wait for package removed intent"", intent);
            return intent;
        } catch (InterruptedException e) {
            fail(""Failed to get package removed intent: "" + e.getMessage());
        } finally {
            context.unregisterReceiver(removedReceiver);
        }
        return null;
    }

    private TestResult getResult() {
        final TestResult result;
        try {
            result = mResultQueue.poll(5, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        if (result == null) {
            throw new TestResultNotFoundException(
                    ""Activity didn't receive a Result in 5 seconds"");
        }
        return result;
    }

    private static class TestResultNotFoundException extends IllegalStateException {
        public TestResultNotFoundException(String description) {
            super(description);
        }
    }

    private static class ActivityBroadcastReceiver extends BroadcastReceiver {
        private final SynchronousQueue<TestResult> mQueue;
        public ActivityBroadcastReceiver(SynchronousQueue<TestResult> queue) {
            mQueue = queue;
        }

        @Override
        public void onReceive(Context context, Intent intent) {
            try {
                mQueue.offer(intent.getParcelableExtra(TestResult.EXTRA_TEST_RESULT),
                        5, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.useprocess.BaseNetworkService"	"isInstantApp"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/UseProcessSuccess/src/com/android/cts/useprocess/BaseNetworkService.java"	""	"public void test/*
 *.
 */

package com.android.cts.useprocess;

import android.app.Service;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.Binder;
import android.os.IBinder;
import android.os.Parcel;
import android.os.Process;
import android.os.RemoteException;
import android.os.StrictMode;
import android.util.Log;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketException;

public class BaseNetworkService extends Service {
    private static final String LOG_TAG = ""ServiceWithInternet"";

    public static final int TRANSACT_TEST = IBinder.FIRST_CALL_TRANSACTION;

    final boolean mNetworkAllowed;
    final String mExpectedProcessName;

    public static final String readResult(Parcel in) {
        if (in.readInt() != 0) {
            return in.readString();
        } else {
            return null;
        }
    }

    public static final String readResultCallstack(Parcel in) {
        return in.readString();
    }

    static final void writeResult(Parcel out, String errorMsg, Throwable where) {
        if (errorMsg != null) {
            out.writeInt(1);
            out.writeString(errorMsg);
            if (where == null) {
                where = new Exception();
                where.fillInStackTrace();
            }
            StringWriter sw = new StringWriter();
            PrintWriter pw = new PrintWriter(sw, false);
            where.printStackTrace(pw);
            pw.flush();
            out.writeString(sw.toString());
        } else {
            out.writeInt(0);
        }
    }

    private final IBinder mBinder = new Binder() {
        @Override
        protected boolean onTransact(int code, Parcel data, Parcel reply, int flags)
                throws RemoteException {
            if (code == TRANSACT_TEST) {
                try {
                    StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
                            .permitNetwork().build());
                    doTest(reply);
                } catch (Throwable e) {
                    writeResult(reply, ""Unexpected exception: "" + e, e);
                }
                return true;
            } else {
                return super.onTransact(code, data, reply, flags);
            }
        }

        private void doTest(Parcel reply) {
            if (!mExpectedProcessName.equals(getApplication().getProcessName())) {
                writeResult(reply,
                        ""Not running in correct process, expected "" + mExpectedProcessName
                        + "" but got "" + getApplication().getProcessName(),null);
                return;
            }

            try {
                Socket socket = new Socket(""example.com"", 80);
                socket.close();
                if (!mNetworkAllowed) {
                    writeResult(reply,
                            ""Create inet socket did not throw SecurityException as expected"",
                            null);
                    return;
                }
            } catch (SecurityException e) {
                if (mNetworkAllowed) {
                    writeResult(reply,
                            ""Create inet socket should be allowed but: "" + e, e);
                    return;
                }
            } catch (IOException e) {
                if (!mNetworkAllowed) {
                    writeResult(reply,
                            ""Create inet socket did not throw SecurityException as expected"", e);
                    return;
                }
            }

            int hasPerm = checkPermission(android.Manifest.permission.INTERNET,
                    Process.myPid(), Process.myUid());
            if (mNetworkAllowed) {
                if (hasPerm != PackageManager.PERMISSION_GRANTED) {
                    writeResult(reply, ""Should have INTERNET permission, but got: "" + hasPerm,
                            null);
                    return;
                }
            } else {
                if (hasPerm != PackageManager.PERMISSION_DENIED) {
                    writeResult(reply, ""Shouldn't have INTERNET permission, but got: "" + hasPerm,
                            null);
                    return;
                }
            }

            // A local socket binding is not allowed if you don't have network access, and
            // also not allowed for instant aps.
            final boolean allowLocalSocket = mNetworkAllowed
                    && !getPackageManager().isInstantApp();

            try {
                // Transfer 128K of data across an explicitly localhost socket.
                final int byteCount = 1024;
                final int packetCount = 128;
                final ServerSocket server;
                try {
                    server = new ServerSocket(0);
                    if (!allowLocalSocket) {
                        server.close();
                        writeResult(reply,
                                ""Create local socket did not throw SecurityException as expected"",
                                null);
                        return;
                    }
                } catch (SocketException e) {
                    if (allowLocalSocket) {
                        writeResult(reply,
                                ""Create local socket should be allowed but: "" + e, null);
                    }
                    return;
                }
                new Thread(""TrafficStatsTest.testTrafficStatsForLocalhost"") {
                    @Override
                    public void run() {
                        try {
                            Socket socket = new Socket(""localhost"", server.getLocalPort());
                            OutputStream out = socket.getOutputStream();
                            byte[] buf = new byte[byteCount];
                            for (int i = 0; i < packetCount; i++) {
                                out.write(buf);
                                out.flush();
                            }
                            out.close();
                            socket.close();
                        } catch (IOException e) {
                            writeResult(reply, ""Badness during writes to socket: "" + e, e);
                            return;
                        }
                    }
                }.start();

                int read = 0;
                try {
                    Socket socket = server.accept();
                    InputStream in = socket.getInputStream();
                    byte[] buf = new byte[byteCount];
                    while (read < byteCount * packetCount) {
                        int n = in.read(buf);
                        if (n <= 0) {
                            writeResult(reply, ""Unexpected EOF @ "" + read,null);
                            return;
                        }
                        read += n;
                    }
                } finally {
                    server.close();
                }
                if (read != (byteCount * packetCount)) {
                    writeResult(reply, ""Not all data read back: expected ""
                            + (byteCount * packetCount) + "", received"" + read, null);
                    return;

                }
            } catch (IOException e) {
                writeResult(reply, e.toString(), e);
                return;
            }

            writeResult(reply, null, null);
        }
    };

    public BaseNetworkService(boolean networkAllowed, String expectedProcessName) {
        mNetworkAllowed = networkAllowed;
        mExpectedProcessName = expectedProcessName;
    }

    @Override
    public IBinder onBind(Intent intent) {
        return mBinder;
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.compatibility.common.util.BatteryUtils"	"isInstantApp"	""	"/home/gpoor/cts-12-source/cts/common/device-side/util-axt/src/com/android/compatibility/common/util/BatteryUtils.java"	""	"public void test/*
 *.
 */
package com.android.compatibility.common.util;

import static com.android.compatibility.common.util.SettingsUtils.putGlobalSetting;
import static com.android.compatibility.common.util.TestUtils.waitUntil;

import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.os.BatteryManager;
import android.os.PowerManager;
import android.provider.Settings.Global;
import android.util.Log;

import androidx.test.InstrumentationRegistry;

import org.junit.Assume;

public class BatteryUtils {
    private static final String TAG = ""CtsBatteryUtils"";

    private BatteryUtils() {
    }

    public static BatteryManager getBatteryManager() {
        return InstrumentationRegistry.getContext().getSystemService(BatteryManager.class);
    }

    public static PowerManager getPowerManager() {
        return InstrumentationRegistry.getContext().getSystemService(PowerManager.class);
    }

    public static boolean hasBattery() {
        final Intent batteryInfo = InstrumentationRegistry.getContext()
                .registerReceiver(null, new IntentFilter(Intent.ACTION_BATTERY_CHANGED));
        return batteryInfo.getBooleanExtra(BatteryManager.EXTRA_PRESENT, true);
    }

    /** Make the target device think it's off charger. */
    public static void runDumpsysBatteryUnplug() throws Exception {
        SystemUtil.runShellCommandForNoOutput(""cmd battery unplug"");

        waitForPlugStatus(false);

        Log.d(TAG, ""Battery UNPLUGGED"");
    }

    /**
     * Set the battery level to {@code level} percent. The valid range is [0, 100].
     */
    public static void runDumpsysBatterySetLevel(int level) throws Exception {
        SystemUtil.runShellCommandForNoOutput((""cmd battery set level "" + level));

        Log.d(TAG, ""Battery level set to "" + level);
    }

    /**
     * Set whether the device is plugged in to a charger or not.
     */
    public static void runDumpsysBatterySetPluggedIn(boolean pluggedIn) throws Exception {
        SystemUtil.runShellCommandForNoOutput((""cmd battery set ac "" + (pluggedIn ? ""1"" : ""0"")));

        waitForPlugStatus(pluggedIn);

        Log.d(TAG, ""Battery AC set to "" + pluggedIn);
    }

    private static void waitForPlugStatus(boolean pluggedIn) throws Exception {
        if (InstrumentationRegistry.getContext().getPackageManager().isInstantApp()) {
            // Instant apps are not allowed to query ACTION_BATTERY_CHANGED. Add short sleep as
            // best-effort wait for status.
            Thread.sleep(2000);
            return;
        }
        IntentFilter ifilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED);
        waitUntil(""Device still "" + (pluggedIn ? "" not plugged"" : "" plugged""),
                () -> {
                    Intent batteryStatus =
                            InstrumentationRegistry.getContext().registerReceiver(null, ifilter);
                    int chargePlug = batteryStatus.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);
                    return pluggedIn == (chargePlug != 0);
                });
    }

    /** Reset the effect of all the previous {@code runDumpsysBattery*} call */
    public static void runDumpsysBatteryReset() {
        SystemUtil.runShellCommandForNoOutput((""cmd battery reset""));

        Log.d(TAG, ""Battery RESET"");
    }

    public static void enableAdaptiveBatterySaver(boolean enabled) {
        final String setting = enabled ? ""true"" : ""false"";
        SystemUtil.runShellCommandForNoOutput(
                ""cmd power set-adaptive-power-saver-enabled "" + setting);
    }

    /**
     * Enable / disable battery saver. Note {@link #runDumpsysBatteryUnplug} must have been
     * executed before enabling BS.
     */
    public static void enableBatterySaver(boolean enabled) throws Exception {
        if (enabled) {
            SystemUtil.runShellCommandForNoOutput(""cmd power set-mode 1"");
            putGlobalSetting(Global.LOW_POWER_MODE, ""1"");
            waitUntil(""Battery saver still off"", () -> getPowerManager().isPowerSaveMode());
        } else {
            SystemUtil.runShellCommandForNoOutput(""cmd power set-mode 0"");
            putGlobalSetting(Global.LOW_POWER_MODE, ""0"");
            putGlobalSetting(Global.LOW_POWER_MODE_STICKY, ""0"");
            waitUntil(""Battery saver still on"", () -> !getPowerManager().isPowerSaveMode());
        }

        AmUtils.waitForBroadcastIdle();
        Log.d(TAG, ""Battery saver turned "" + (enabled ? ""ON"" : ""OFF""));
    }

    /**
     * Turn on/off screen.
     */
    public static void turnOnScreen(boolean on) throws Exception {
        if (on) {
            SystemUtil.runShellCommandForNoOutput(""input keyevent KEYCODE_WAKEUP"");
            waitUntil(""Device still not interactive"", () -> getPowerManager().isInteractive());

        } else {
            SystemUtil.runShellCommandForNoOutput(""input keyevent KEYCODE_SLEEP"");
            waitUntil(""Device still interactive"", () -> !getPowerManager().isInteractive());
        }
        AmUtils.waitForBroadcastIdle();
        Log.d(TAG, ""Screen turned "" + (on ? ""ON"" : ""OFF""));
    }

    /** @return true if the device supports battery saver. */
    public static boolean isBatterySaverSupported() {
        if (!hasBattery()) {
            // Devices without a battery don't support battery saver.
            return false;
        }

        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
        return !(pm.hasSystemFeature(PackageManager.FEATURE_WATCH) ||
            pm.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE));
    }

    /** ""Assume"" the current device supports battery saver. */
    public static void assumeBatterySaverFeature() {
        Assume.assumeTrue(""Device doesn't support battery saver"", isBatterySaverSupported());
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.uidisolation.cts.PermissionTestService"	"startTests"	"CtsUidIsolationTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/uidisolation/src/android/uidisolation/cts/PermissionTestService.java"	""	"public void test/*
 *.
 */

package android.uidisolation.cts;

import android.app.Service;
import android.content.Intent;
import android.os.AsyncTask;
import android.os.Handler;
import android.os.IBinder;
import android.os.Message;
import android.os.Messenger;
import android.os.RemoteException;
import android.util.Log;
import android.webkit.cts.CtsTestServer;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;

public class PermissionTestService extends Service {
    private static String TAG = PermissionTestService.class.getName();

    static final String FILE_NAME = ""test_file"";

    // Message receieved from the client.
    static final int MSG_START_TEST = 1;

    // Messages sent to the client.
    static final int MSG_NOTIFY_TEST_SUCCESS = 2;
    static final int MSG_NOTIFY_TEST_FAILURE = 3;

    // The different tests types we run.
    static final int FILE_READ_TEST = 1;
    static final int FILE_WRITE_TEST = 2;
    static final int NETWORK_ACCESS_TEST = 3;

    private Messenger mClient;

    // Whether we expect to have permissions to access files, network...
    boolean mExpectPermissionsAllowed = true;

    class IncomingHandler extends Handler {
        private PermissionTestService mService;

        IncomingHandler(PermissionTestService service) {
            mService = service;
        }

        @Override
        public void handleMessage(Message msg) {
            if (msg.what != MSG_START_TEST) {
                Log.e(TAG, ""PermissionTestService received bad message: "" + msg.what);
                super.handleMessage(msg);
                return;
            }
            mService.mClient = msg.replyTo;
            mService.startTests();
        }
    }

    final Messenger mMessenger = new Messenger(new IncomingHandler(this));

    class NetworkTestAsyncTask extends AsyncTask<Void, Void, Boolean> {
        protected Boolean doInBackground(Void... nothing) {
            // Instant apps cannot open TCP sockets
            return getPackageManager().isInstantApp() || testNetworkAccess();
        }

        protected void onPostExecute(Boolean success) {
            testNetworkAccessDone(success);
        }
    }

    public PermissionTestService() {
        this(true);
    }

    protected PermissionTestService(boolean expectPermissionsAllowed) {
        mExpectPermissionsAllowed = expectPermissionsAllowed;
    }

    @Override
    public IBinder onBind(Intent intent) {
        return mMessenger.getBinder();
    }

    private void notifyClientOfFailure(int failingTest) {
        try {
            mClient.send(Message.obtain(null, MSG_NOTIFY_TEST_FAILURE, failingTest, 0, null));
        } catch (RemoteException e) {
            Log.e(TAG, ""Failed to send message back to client."");
        }
    }

    private void notifyClientOfSuccess() {
        try {
            mClient.send(Message.obtain(null, MSG_NOTIFY_TEST_SUCCESS));
        } catch (RemoteException e) {
            Log.e(TAG, ""Failed to send message back to client."");
        }
    }

    private void startTests() {
        if (testFileReadAccess() != mExpectPermissionsAllowed) {
            notifyClientOfFailure(FILE_READ_TEST);
            return;
        }
        if (testFileWriteAccess() != mExpectPermissionsAllowed) {
            notifyClientOfFailure(FILE_WRITE_TEST);
            return;
        }

        // testNetworkAccess is performed asynchronously and calls testNetworkAccessDone.
        new NetworkTestAsyncTask().execute();
    }

    private void testNetworkAccessDone(boolean success) {
        // Instant apps cannot open TCP sockets.
        if (!getPackageManager().isInstantApp() && success != mExpectPermissionsAllowed) {
            notifyClientOfFailure(NETWORK_ACCESS_TEST);
            return;
        }
        notifyClientOfSuccess();
    }

    private boolean testFileReadAccess() {
        File f = getApplication().getFileStreamPath(FILE_NAME);
        if (!f.exists()) {
            Log.e(TAG, ""testFileReadAccess: test file does not exists."");
            return false;
        }
        if (!f.canRead()) {
            Log.e(TAG, ""testFileReadAccess: no permission to read test file."");
            return false;
        }

        FileInputStream fis = null;
        try {
            fis = new FileInputStream(f);
            for (int i = 0; i < 10; i++) {
                int value;
                try {
                    value = fis.read();
                } catch (IOException ioe) {
                    Log.e(TAG, ""testFileReadAccess: failed to read test file, IOException."");
                    return false;
                }
                if (value == -1) {
                    Log.e(TAG, ""testFileReadAccess: failed to read test file."");
                    return false;
                }
                if (value != i) {
                    Log.e(TAG, ""testFileReadAccess: wrong data read from test file."");
                    return false;
                }
            }
        } catch (FileNotFoundException fnfe) {
            Log.e(TAG, ""testFileReadAccess: failed to read test file, FileNotFoundException."");
            return false;
        } finally {
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException ioe) {
                }
            }
        }
    return true;
}

    private boolean testFileWriteAccess() {
        FileOutputStream fos = null;
        try {
            fos = getApplication().openFileOutput(""writeable_file"", 0);
            byte[] content = new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
            fos.write(content, 0, content.length);
        } catch (FileNotFoundException fnfe) {
            Log.e(TAG, ""Failed to open writable file."");
            return false;
        } catch (IOException ioe) {
            Log.e(TAG, ""Failed to write to writable file."");
            return false;
        } finally {
            if (fos != null) {
                try {
                    fos.close();
                } catch (IOException ioe) {
                }
            }
        }
        return true;
    }

    private boolean testNetworkAccess() {
        CtsTestServer webServer = null;
        try {
            try {
                webServer = new CtsTestServer(getApplication(),
                        CtsTestServer.SslMode.TRUST_ANY_CLIENT);
            } catch (Exception e) {
                Log.e(TAG, ""Failed to create CtsTestServer."");
                return false;
            }

            URL url;
            try {
                url = new URL(webServer.getAssetUrl(""hello.html""));
            } catch (MalformedURLException mue) {
                Log.e(TAG, ""Test is bad, could not create the URL in ""
                        + ""PermissionTestService.testNetworkAccess()."");
                return false;
            }
            InputStream is = null;
            try {
                is = url.openStream();
                // Attempt to read some bytes.
                for (int i = 0; i < 10; i++) {
                    int value = is.read();
                    if (value == -1) {
                        Log.e(TAG, ""Failed to read byte "" + i + "" from network connection"");
                        return false;
                    }
                }
            } catch (IOException ioe) {
                Log.e(TAG, ""Failed to read from network connection: "" + ioe);
                return false;
            } catch (SecurityException se) {
                Log.e(TAG, ""Failed to read from network connection: "" + se);
                return false;
            } finally {
                if (is != null) {
                    try {
                        is.close();
                    } catch (IOException ioe) {
                    }
                }
            }
            Log.i(TAG, ""Successfully accessed network."");
            return true;
        } finally {
            if (webServer != null) {
                webServer.shutdown();
            }
        }
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.server.wm.PinnedStackTests"	"testWindowButtonEntersPip"	"CtsWindowManagerDeviceTestCases"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/PinnedStackTests.java"	""	"public void testWindowButtonEntersPip() {
        assumeTrue(!mWmState.isHomeRecentsComponent());

        // Launch the PiP activity trigger the window button, ensure that we have entered PiP
        launchActivity(PIP_ACTIVITY);
        pressWindowButton();
        waitForEnterPip(PIP_ACTIVITY);
        assertPinnedStackExists();
    }"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.app.cts.AppTaskTests"	"testStartActivityInTask_NewTask"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/AppTaskTests.java"	""	"public void testStartActivityInTask_NewTask() throws Exception {
        final Activity a1 = mActivityRule.launchActivity(null);
        final ActivityManager.AppTask task = getAppTask(a1);
        final Intent intent = new Intent();
        intent.setComponent(new ComponentName(mTargetContext, MockActivity.class));
        intent.setFlags(FLAG_ACTIVITY_NEW_TASK);
        task.startActivity(mTargetContext, intent, null);

        final ActivityManager.RecentTaskInfo taskInfo = task.getTaskInfo();
        assertTrue(taskInfo.numActivities == 1);
        assertTrue(taskInfo.baseActivity.equals(a1.getComponentName()));
    }

    /**
     * Ensure that the activity that is excluded from recents is reflected in the recent task info.
     */"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.app.cts.AppTaskTests"	"testSetExcludeFromRecents"	"CtsAppTestCases"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/AppTaskTests.java"	""	"public void testSetExcludeFromRecents() throws Exception {
        final Activity a1 = mActivityRule.launchActivity(null);
        final List<ActivityManager.AppTask> appTasks = getAppTasks();
        final ActivityManager.AppTask t1 = appTasks.get(0);
        t1.setExcludeFromRecents(true);
        assertTrue((t1.getTaskInfo().baseIntent.getFlags() & FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS)
                != 0);
        t1.setExcludeFromRecents(false);
        assertTrue((t1.getTaskInfo().baseIntent.getFlags() & FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS)
                == 0);
    }

    /**
     * @return all the {@param ActivityManager.AppTask}s for the current app.
     */
    private List<ActivityManager.AppTask> getAppTasks() {
        ActivityManager am = (ActivityManager) mTargetContext.getSystemService(ACTIVITY_SERVICE);
        return am.getAppTasks();
    }

    /**
     * @return the {@param ActivityManager.AppTask} for the associated activity.
     */
    private ActivityManager.AppTask getAppTask(Activity activity) {
        waitAndAssertCondition(() -> getAppTask(getAppTasks(), activity) != null,
                ""Waiting for app task"");
        return getAppTask(getAppTasks(), activity);
    }

    private ActivityManager.AppTask getAppTask(List<ActivityManager.AppTask> appTasks,
            Activity activity) {
        for (ActivityManager.AppTask task : appTasks) {
            if (task.getTaskInfo().taskId == activity.getTaskId()) {
                return task;
            }
        }
        return null;
    }

    /**
     * Removes all the app tasks the test app.
     */
    private void removeAllAppTasks() {
        final List<ActivityManager.AppTask> appTasks = getAppTasks();
        for (ActivityManager.AppTask task : appTasks) {
            task.finishAndRemoveTask();
        }
        waitAndAssertCondition(() -> getAppTasks().isEmpty(),
                ""Expected no app tasks after all removed"");
    }

    private void waitAndAssertCondition(BooleanSupplier condition, String failMsgContext) {
        long startTime = SystemClock.elapsedRealtime();
        while (true) {
            if (condition.getAsBoolean()) {
                // Condition passed
                return;
            } else if (SystemClock.elapsedRealtime() > (startTime + MAX_WAIT_MS)) {
                // Timed out
                fail(""Timed out waiting for: "" + failMsgContext);
            } else {
                SystemClock.sleep(TIME_SLICE_MS);
            }
        }
    }

    private class BooleanValue {
        boolean value;
    }
}"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.content.pm.cts.InstantAppTest"	"testInstantAppResolverQuery"	"CtsContentTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/InstantAppTest.java"	""	"public void testInstantAppResolverQuery() {
        final Intent resolverIntent = new Intent(Intent.ACTION_RESOLVE_INSTANT_APP_PACKAGE);
        final int resolveFlags =
                MATCH_DIRECT_BOOT_AWARE
                | MATCH_DIRECT_BOOT_UNAWARE
                | MATCH_SYSTEM_ONLY;
        final List<ResolveInfo> matches =
                mPackageManager.queryIntentServices(resolverIntent, resolveFlags);
        assertTrue(matches == null || matches.size() <= 1);
    }

    /** Ensure only one resolver is defined */"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.content.pm.cts.InstantAppTest"	"testInstantAppInstallerQuery"	"CtsContentTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/InstantAppTest.java"	""	"public void testInstantAppInstallerQuery() {
        final Intent intent = new Intent(Intent.ACTION_INSTALL_INSTANT_APP_PACKAGE);
        intent.addCategory(Intent.CATEGORY_DEFAULT);
        intent.setDataAndType(Uri.fromFile(new File(""foo.apk"")), PACKAGE_MIME_TYPE);
        final int resolveFlags =
                MATCH_DIRECT_BOOT_AWARE
                | MATCH_DIRECT_BOOT_UNAWARE
                | MATCH_SYSTEM_ONLY;
        final List<ResolveInfo> matches =
                mPackageManager.queryIntentActivities(intent, resolveFlags);
        assertTrue(matches == null || matches.size() <= 1);
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.alarmmanager.cts.InstantAppsTests"	"isInstantApp"	"CtsAlarmManagerTestCases"	"/home/gpoor/cts-12-source/cts/tests/AlarmManager/src/android/alarmmanager/cts/InstantAppsTests.java"	""	"/*
 *.
 */

package android.alarmmanager.cts;

import static android.app.AlarmManager.ELAPSED_REALTIME_WAKEUP;
import static android.app.AlarmManager.RTC_WAKEUP;

import static org.junit.Assert.assertTrue;
import static org.junit.Assume.assumeTrue;

import android.alarmmanager.util.AlarmManagerDeviceConfigHelper;
import android.app.AlarmManager;
import android.content.Context;
import android.os.SystemClock;
import android.platform.test.annotations.AppModeInstant;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * Tests that alarm manager works as expected with instant apps
 */
@AppModeInstant
@RunWith(AndroidJUnit4.class)
public class InstantAppsTests {
    private static final String TAG = ""AlarmManagerInstantTests"";
    private static final long WINDOW_LENGTH = 500;
    private static final long WAIT_TIMEOUT = 5_000;

    private AlarmManager mAlarmManager;
    private Context mContext;
    private AlarmManagerDeviceConfigHelper mConfigHelper = new AlarmManagerDeviceConfigHelper();

    @Before
    public void setUp() {
        mContext = InstrumentationRegistry.getTargetContext();
        mAlarmManager = mContext.getSystemService(AlarmManager.class);
        assumeTrue(mContext.getPackageManager().isInstantApp());
    }

    @Before
    public void updateAlarmManagerSettings() {
        mConfigHelper.with(""min_futurity"", 0L)
                .with(""min_window"", 0L)
                .commitAndAwaitPropagation();
    }"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.server.wm.AppConfigurationTests"	"testConfigurationUpdatesWhenRotatingWhileDocked"	"CtsWindowManagerDeviceTestCases"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/AppConfigurationTests.java"	""	"public void testConfigurationUpdatesWhenRotatingWhileDocked() {
        assumeTrue(""Skipping test: no multi-window support"", supportsSplitScreenMultiWindow());

        final ActivitySessionClient resizeableActivityClient = createManagedActivityClientSession();
        final RotationSession rotationSession = createManagedRotationSession();
        rotationSession.set(ROTATION_0);

        separateTestJournal();
        // Launch our own activity to side in case Recents (or other activity to side) doesn't
        // support rotation.
        launchActivitiesInSplitScreen(
                getLaunchActivityBuilder().setTargetActivity(LAUNCHING_ACTIVITY),
                getLaunchActivityBuilder().setTargetActivity(TEST_ACTIVITY));
        // Launch target activity in docked stack.
        getLaunchActivityBuilder().setTargetActivity(RESIZEABLE_ACTIVITY)
                .setActivitySessionClient(resizeableActivityClient).execute();
        final SizeInfo initialSizes = getLastReportedSizesForActivity(RESIZEABLE_ACTIVITY);

        rotateAndCheckSizes(rotationSession, resizeableActivityClient, initialSizes);
    }

    /**
     * Same as {@link #testConfigurationUpdatesWhenRotatingWhileDocked()} but when the Activity
     * is launched to side from docked stack.
     */"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.os.cts.CrossProcessExceptionTest"	"isInstantApp"	""	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/CrossProcessExceptionTest.java"	""	"public void test/*
 *.
 */

package android.os.cts;

import android.app.ActivityManager;
import android.app.AuthenticationRequiredException;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.IBinder;
import android.os.ParcelFileDescriptor;
import android.test.AndroidTestCase;

import com.google.common.util.concurrent.AbstractFuture;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

public class CrossProcessExceptionTest extends AndroidTestCase {

    private Intent greenIntent;
    private PeerConnection greenConn;
    private IBinder green;

    public static class PeerConnection extends AbstractFuture<IBinder>
            implements ServiceConnection {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            set(service);
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
        }

        @Override
        public IBinder get() throws InterruptedException, ExecutionException {
            try {
                return get(5, TimeUnit.SECONDS);
            } catch (TimeoutException e) {
                throw new RuntimeException(e);
            }
        }
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        final Context context = getContext();

        // Bring up both remote processes and wire them to each other
        greenIntent = new Intent();
        greenIntent.setComponent(new ComponentName(
                ""android.os.cts"", ""android.os.cts.CrossProcessExceptionService""));
        greenConn = new PeerConnection();
        context.startService(greenIntent);
        getContext().bindService(greenIntent, greenConn, 0);
        green = greenConn.get();
    }

    @Override
    protected void tearDown() throws Exception {
        super.tearDown();

        final Context context = getContext();
        context.unbindService(greenConn);
        context.stopService(greenIntent);

        // Instant Apps don't have the KILL_BACKGROUND_PROCESSES permission
        if (!context.getPackageManager().isInstantApp()) {
            final ActivityManager am = (ActivityManager) mContext.getSystemService(
                    Context.ACTIVITY_SERVICE);
            am.killBackgroundProcesses(context.getPackageName());
        }
    }"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.appsearch.app.a.AppSearchInstantAppTest"	"testInstantAppDoesntHaveAccess"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsearch/test-apps/AppSearchHostTestHelperA/src/android/appsearch/app/a/AppSearchInstantAppTest.java"	""	"public void testInstantAppDoesntHaveAccess() {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        assertThat(context.getPackageManager().isInstantApp()).isTrue();

        int userId = context.getUserId();
        ExecutionException exception = expectThrows(ExecutionException.class, () ->
                AppSearchSessionShimImpl.createSearchSession(
                        new AppSearchManager.SearchContext.Builder(DB_NAME).build(),
                        userId).get());
        assertThat(exception.getMessage()).contains(
                ""AppSearchResult is a failure: [FAILURE(8)]: SecurityException: Caller not allowed ""
                        + ""to create AppSearch session"");
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.hardware.camera2.cts.testcases.Camera2AndroidTestCase"	"isInstantApp"	"CtsCameraTestCases"	"/home/gpoor/cts-12-source/cts/tests/camera/src/android/hardware/camera2/cts/testcases/Camera2AndroidTestCase.java"	""	"public void test/*
 *.
 */

package android.hardware.camera2.cts.testcases;

import static android.hardware.camera2.cts.CameraTestUtils.*;
import static com.android.ex.camera2.blocking.BlockingStateCallback.*;

import android.content.Context;
import android.graphics.ImageFormat;
import android.graphics.Rect;
import android.hardware.cts.helpers.CameraParameterizedTestCase;
import android.hardware.camera2.CameraCaptureSession;
import android.hardware.camera2.CameraCaptureSession.CaptureCallback;
import android.hardware.camera2.CameraCharacteristics;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CameraManager;
import android.hardware.camera2.CaptureRequest;
import android.hardware.camera2.params.InputConfiguration;
import android.hardware.camera2.params.OutputConfiguration;
import android.hardware.camera2.params.SessionConfiguration;
import android.util.Size;
import android.hardware.camera2.cts.Camera2ParameterizedTestCase;
import android.hardware.camera2.cts.CameraTestUtils;
import android.hardware.camera2.cts.helpers.CameraErrorCollector;
import android.hardware.camera2.cts.helpers.StaticMetadata;
import android.hardware.camera2.cts.helpers.StaticMetadata.CheckLevel;
import android.media.Image;
import android.media.Image.Plane;
import android.media.ImageReader;
import android.os.Handler;
import android.os.HandlerThread;
import android.test.AndroidTestCase;
import android.util.Log;
import android.view.Surface;
import android.view.WindowManager;
import androidx.test.InstrumentationRegistry;

import com.android.ex.camera2.blocking.BlockingSessionCallback;
import com.android.ex.camera2.blocking.BlockingStateCallback;

import java.io.File;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;

import org.junit.Ignore;
import org.junit.Test;

// TODO: Can we de-duplicate this with Camera2AndroidBasicTestCase keeping in mind CtsVerifier ?
public class Camera2AndroidTestCase extends Camera2ParameterizedTestCase {
    private static final String TAG = ""Camera2AndroidTestCase"";
    private static final boolean VERBOSE = Log.isLoggable(TAG, Log.VERBOSE);

    // Default capture size: VGA size is required by CDD.
    protected static final Size DEFAULT_CAPTURE_SIZE = new Size(640, 480);
    protected static final int CAPTURE_WAIT_TIMEOUT_MS = 7000;

    protected CameraDevice mCamera;
    protected CameraCaptureSession mCameraSession;
    protected BlockingSessionCallback mCameraSessionListener;
    protected BlockingStateCallback mCameraListener;
    // include both standalone camera IDs and ""hidden"" physical camera IDs
    protected String[] mAllCameraIds;
    protected HashMap<String, StaticMetadata> mAllStaticInfo;
    protected ImageReader mReader;
    protected Surface mReaderSurface;
    protected Handler mHandler;
    protected HandlerThread mHandlerThread;
    protected StaticMetadata mStaticInfo;
    protected CameraErrorCollector mCollector;
    protected List<Size> mOrderedPreviewSizes; // In descending order.
    protected List<Size> mOrderedVideoSizes; // In descending order.
    protected List<Size> mOrderedStillSizes; // In descending order.
    protected String mDebugFileNameBase;

    protected WindowManager mWindowManager;

    /**
     * Set up the camera2 test case required environments, including CameraManager,
     * HandlerThread, Camera IDs, and CameraStateCallback etc.
     */
    @Override
    public void setUp() throws Exception {
        setUp(false);
    }

    /**
     * Set up the camera2 test case required environments, including CameraManager,
     * HandlerThread, Camera IDs, and CameraStateCallback etc.
     * @param useAll whether all camera ids are to be used for system camera tests
     */
    public void setUp(boolean useAll) throws Exception {
        super.setUp(useAll);
        mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);

        mHandlerThread = new HandlerThread(TAG);
        mHandlerThread.start();
        mHandler = new Handler(mHandlerThread.getLooper());
        mCameraListener = new BlockingStateCallback();
        mCollector = new CameraErrorCollector();

        File filesDir = mContext.getPackageManager().isInstantApp()
                ? mContext.getFilesDir()
                : mContext.getExternalFilesDir(null);

        mDebugFileNameBase = filesDir.getPath();

        mAllStaticInfo = new HashMap<String, StaticMetadata>();
        List<String> hiddenPhysicalIds = new ArrayList<>();
        for (String cameraId : mCameraIdsUnderTest) {
            CameraCharacteristics props = mCameraManager.getCameraCharacteristics(cameraId);
            StaticMetadata staticMetadata = new StaticMetadata(props,
                    CheckLevel.ASSERT, /*collector*/null);
            mAllStaticInfo.put(cameraId, staticMetadata);

            for (String physicalId : props.getPhysicalCameraIds()) {
                if (!Arrays.asList(mCameraIdsUnderTest).contains(physicalId) &&
                        !hiddenPhysicalIds.contains(physicalId)) {
                    hiddenPhysicalIds.add(physicalId);
                    props = mCameraManager.getCameraCharacteristics(physicalId);
                    staticMetadata = new StaticMetadata(
                            mCameraManager.getCameraCharacteristics(physicalId),
                            CheckLevel.ASSERT, /*collector*/null);
                    mAllStaticInfo.put(physicalId, staticMetadata);
                }
            }
        }
        mAllCameraIds = new String[mCameraIdsUnderTest.length + hiddenPhysicalIds.size()];
        System.arraycopy(mCameraIdsUnderTest, 0, mAllCameraIds, 0, mCameraIdsUnderTest.length);
        for (int i = 0; i < hiddenPhysicalIds.size(); i++) {
            mAllCameraIds[mCameraIdsUnderTest.length + i] = hiddenPhysicalIds.get(i);
        }
    }

    @Override
    public void tearDown() throws Exception {
        try {
            if (mHandlerThread != null) {
                mHandlerThread.quitSafely();
            }
            mHandler = null;
            closeDefaultImageReader();

            if (mCollector != null) {
                mCollector.verify();
            }
        } catch (Throwable e) {
            // When new Exception(e) is used, exception info will be printed twice.
            throw new Exception(e.getMessage());
        } finally {
            super.tearDown();
        }
    }

    /**
     * Start capture with given {@link #CaptureRequest}.
     *
     * @param request The {@link #CaptureRequest} to be captured.
     * @param repeating If the capture is single capture or repeating.
     * @param listener The {@link #CaptureCallback} camera device used to notify callbacks.
     * @param handler The handler camera device used to post callbacks.
     */
    protected void startCapture(CaptureRequest request, boolean repeating,
            CaptureCallback listener, Handler handler) throws Exception {
        if (VERBOSE) Log.v(TAG, ""Starting capture from device"");

        if (repeating) {
            mCameraSession.setRepeatingRequest(request, listener, handler);
        } else {
            mCameraSession.capture(request, listener, handler);
        }
    }

    /**
     * Stop the current active capture.
     *
     * @param fast When it is true, {@link CameraDevice#flush} is called, the stop capture
     * could be faster.
     */
    protected void stopCapture(boolean fast) throws Exception {
        if (VERBOSE) Log.v(TAG, ""Stopping capture"");

        if (fast) {
            /**
             * Flush is useful for canceling long exposure single capture, it also could help
             * to make the streaming capture stop sooner.
             */
            mCameraSession.abortCaptures();
            mCameraSessionListener.getStateWaiter().
                    waitForState(BlockingSessionCallback.SESSION_READY, CAMERA_IDLE_TIMEOUT_MS);
        } else {
            mCameraSession.close();
            mCameraSessionListener.getStateWaiter().
                    waitForState(BlockingSessionCallback.SESSION_CLOSED, CAMERA_IDLE_TIMEOUT_MS);
        }
    }

    /**
     * Open a {@link #CameraDevice camera device} and get the StaticMetadata for a given camera id.
     * The default mCameraListener is used to wait for states.
     *
     * @param cameraId The id of the camera device to be opened.
     */
    protected void openDevice(String cameraId) throws Exception {
        openDevice(cameraId, mCameraListener);
    }

    /**
     * Open a {@link #CameraDevice} and get the StaticMetadata for a given camera id and listener.
     *
     * @param cameraId The id of the camera device to be opened.
     * @param listener The {@link #BlockingStateCallback} used to wait for states.
     */
    protected void openDevice(String cameraId, BlockingStateCallback listener) throws Exception {
        mCamera = CameraTestUtils.openCamera(
                mCameraManager, cameraId, listener, mHandler);
        mCollector.setCameraId(cameraId);
        mStaticInfo = mAllStaticInfo.get(cameraId);
        if (mStaticInfo.isColorOutputSupported()) {
            mOrderedPreviewSizes = getSupportedPreviewSizes(
                    cameraId, mCameraManager,
                    getPreviewSizeBound(mWindowManager, PREVIEW_SIZE_BOUND));
            mOrderedVideoSizes = getSupportedVideoSizes(cameraId, mCameraManager, PREVIEW_SIZE_BOUND);
            mOrderedStillSizes = getSupportedStillSizes(cameraId, mCameraManager, null);
        }

        if (VERBOSE) {
            Log.v(TAG, ""Camera "" + cameraId + "" is opened"");
        }
    }

    /**
     * Create a {@link #CameraCaptureSession} using the currently open camera.
     *
     * @param outputSurfaces The set of output surfaces to configure for this session
     */
    protected void createSession(List<Surface> outputSurfaces) throws Exception {
        mCameraSessionListener = new BlockingSessionCallback();
        mCameraSession = CameraTestUtils.configureCameraSession(mCamera, outputSurfaces,
                mCameraSessionListener, mHandler);
    }

    /**
     * Create a reprocessable {@link #CameraCaptureSession} using the currently open camera.
     *
     * @param inputConfiguration The inputConfiguration for this session
     * @param outputSurfaces The set of output surfaces to configure for this session
     */
    protected void createReprocessableSession(InputConfiguration inputConfig,
            List<Surface> outputSurfaces) throws Exception {
        mCameraSessionListener = new BlockingSessionCallback();
        mCameraSession = CameraTestUtils.configureReprocessableCameraSession(
                mCamera, inputConfig, outputSurfaces, mCameraSessionListener, mHandler);
    }

    /**
     * Create a {@link #CameraCaptureSession} using the currently open camera with
     * OutputConfigurations.
     *
     * @param outputSurfaces The set of output surfaces to configure for this session
     */
    protected void createSessionByConfigs(List<OutputConfiguration> outputConfigs) throws Exception {
        mCameraSessionListener = new BlockingSessionCallback();
        mCameraSession = CameraTestUtils.configureCameraSessionWithConfig(mCamera, outputConfigs,
                mCameraSessionListener, mHandler);
    }

    /**
     * Close a {@link #CameraDevice camera device} and clear the associated StaticInfo field for a
     * given camera id. The default mCameraListener is used to wait for states.
     * <p>
     * This function must be used along with the {@link #openDevice} for the
     * same camera id.
     * </p>
     *
     * @param cameraId The id of the {@link #CameraDevice camera device} to be closed.
     */
    protected void closeDevice(String cameraId) {
        closeDevice(cameraId, mCameraListener);
    }

    /**
     * Close a {@link #CameraDevice camera device} and clear the associated StaticInfo field for a
     * given camera id and listener.
     * <p>
     * This function must be used along with the {@link #openDevice} for the
     * same camera id.
     * </p>
     *
     * @param cameraId The id of the camera device to be closed.
     * @param listener The BlockingStateCallback used to wait for states.
     */
    protected void closeDevice(String cameraId, BlockingStateCallback listener) {
        if (mCamera != null) {
            if (!cameraId.equals(mCamera.getId())) {
                throw new IllegalStateException(""Try to close a device that is not opened yet"");
            }
            mCamera.close();
            listener.waitForState(STATE_CLOSED, CAMERA_CLOSE_TIMEOUT_MS);
            mCamera = null;
            mCameraSession = null;
            mCameraSessionListener = null;
            mStaticInfo = null;
            mOrderedPreviewSizes = null;
            mOrderedVideoSizes = null;
            mOrderedStillSizes = null;

            if (VERBOSE) {
                Log.v(TAG, ""Camera "" + cameraId + "" is closed"");
            }
        }
    }

    /**
     * Create an {@link ImageReader} object and get the surface.
     * <p>
     * This function creates {@link ImageReader} object and surface, then assign
     * to the default {@link mReader} and {@link mReaderSurface}. It closes the
     * current default active {@link ImageReader} if it exists.
     * </p>
     *
     * @param size The size of this ImageReader to be created.
     * @param format The format of this ImageReader to be created
     * @param maxNumImages The max number of images that can be acquired
     *            simultaneously.
     * @param listener The listener used by this ImageReader to notify
     *            callbacks.
     */
    protected void createDefaultImageReader(Size size, int format, int maxNumImages,
            ImageReader.OnImageAvailableListener listener) throws Exception {
        closeDefaultImageReader();

        mReader = createImageReader(size, format, maxNumImages, listener);
        mReaderSurface = mReader.getSurface();
        if (VERBOSE) Log.v(TAG, ""Created ImageReader size "" + size.toString());
    }

    /**
     * Create an {@link ImageReader} object and get the surface.
     * <p>
     * This function creates {@link ImageReader} object and surface, then assign
     * to the default {@link mReader} and {@link mReaderSurface}. It closes the
     * current default active {@link ImageReader} if it exists.
     * </p>
     *
     * @param size The size of this ImageReader to be created.
     * @param format The format of this ImageReader to be created
     * @param maxNumImages The max number of images that can be acquired
     *            simultaneously.
     * @param usage The usage flag of the ImageReader
     * @param listener The listener used by this ImageReader to notify
     *            callbacks.
     */
    protected void createDefaultImageReader(Size size, int format, int maxNumImages, long usage,
            ImageReader.OnImageAvailableListener listener) throws Exception {
        closeDefaultImageReader();

        mReader = createImageReader(size, format, maxNumImages, usage, listener);
        mReaderSurface = mReader.getSurface();
        if (VERBOSE) Log.v(TAG, ""Created ImageReader size "" + size.toString());
    }

    /**
     * Create an {@link ImageReader} object.
     *
     * <p>This function creates image reader object for given format, maxImages, and size.</p>
     *
     * @param size The size of this ImageReader to be created.
     * @param format The format of this ImageReader to be created
     * @param maxNumImages The max number of images that can be acquired simultaneously.
     * @param listener The listener used by this ImageReader to notify callbacks.
     */

    protected ImageReader createImageReader(Size size, int format, int maxNumImages,
            ImageReader.OnImageAvailableListener listener) throws Exception {

        ImageReader reader = null;
        reader = ImageReader.newInstance(size.getWidth(), size.getHeight(),
                format, maxNumImages);

        reader.setOnImageAvailableListener(listener, mHandler);
        if (VERBOSE) Log.v(TAG, ""Created ImageReader size "" + size.toString());
        return reader;
    }

    /**
     * Create an {@link ImageReader} object.
     *
     * <p>This function creates image reader object for given format, maxImages, usage and size.</p>
     *
     * @param size The size of this ImageReader to be created.
     * @param format The format of this ImageReader to be created
     * @param maxNumImages The max number of images that can be acquired simultaneously.
     * @param usage The usage flag of the ImageReader
     * @param listener The listener used by this ImageReader to notify callbacks.
     */

    protected ImageReader createImageReader(Size size, int format, int maxNumImages, long usage,
            ImageReader.OnImageAvailableListener listener) throws Exception {
        ImageReader reader = null;
        reader = ImageReader.newInstance(size.getWidth(), size.getHeight(),
                format, maxNumImages, usage);

        reader.setOnImageAvailableListener(listener, mHandler);
        if (VERBOSE) Log.v(TAG, ""Created ImageReader size "" + size.toString());
        return reader;
    }

    /**
     * Close the pending images then close current default {@link ImageReader} object.
     */
    protected void closeDefaultImageReader() {
        closeImageReader(mReader);
        mReader = null;
        mReaderSurface = null;
    }

    /**
     * Close an image reader instance.
     *
     * @param reader
     */
    protected void closeImageReader(ImageReader reader) {
        if (reader != null) {
            try {
                // Close all possible pending images first.
                Image image = reader.acquireLatestImage();
                if (image != null) {
                    image.close();
                }
            } finally {
                reader.close();
                reader = null;
            }
        }
    }

    protected void checkImageReaderSessionConfiguration(String msg) throws Exception {
        checkImageReaderSessionConfiguration(msg, /*physicalCameraId*/null);
    }

    protected void checkImageReaderSessionConfiguration(String msg, String physicalCameraId)
            throws Exception {
        List<OutputConfiguration> outputConfigs = new ArrayList<OutputConfiguration>();
        OutputConfiguration config = new OutputConfiguration(mReaderSurface);
        if (physicalCameraId != null) {
            config.setPhysicalCameraId(physicalCameraId);
        }
        outputConfigs.add(config);
        checkSessionConfigurationSupported(mCamera, mHandler, outputConfigs, /*inputConfig*/ null,
                SessionConfiguration.SESSION_REGULAR, /*expectedResult*/ true, msg);
    }

    protected CaptureRequest prepareCaptureRequest() throws Exception {
        return prepareCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
    }

    protected CaptureRequest prepareCaptureRequest(int template) throws Exception {
        List<Surface> outputSurfaces = new ArrayList<Surface>();
        Surface surface = mReader.getSurface();
        assertNotNull(""Fail to get surface from ImageReader"", surface);
        outputSurfaces.add(surface);
        return prepareCaptureRequestForSurfaces(outputSurfaces, template)
                .build();
    }

    protected CaptureRequest.Builder prepareCaptureRequestForSurfaces(List<Surface> surfaces,
            int template)
            throws Exception {
        createSession(surfaces);

        CaptureRequest.Builder captureBuilder =
                mCamera.createCaptureRequest(template);
        assertNotNull(""Fail to get captureRequest"", captureBuilder);
        for (Surface surface : surfaces) {
            captureBuilder.addTarget(surface);
        }

        return captureBuilder;
    }

    protected CaptureRequest.Builder prepareCaptureRequestForConfigs(
            List<OutputConfiguration> outputConfigs, int template) throws Exception {
        createSessionByConfigs(outputConfigs);

        CaptureRequest.Builder captureBuilder =
                mCamera.createCaptureRequest(template);
        assertNotNull(""Fail to get captureRequest"", captureBuilder);
        for (OutputConfiguration config : outputConfigs) {
            for (Surface s : config.getSurfaces()) {
                captureBuilder.addTarget(s);
            }
        }

        return captureBuilder;
    }

    /**
     * Test the invalid Image access: accessing a closed image must result in
     * {@link IllegalStateException}.
     *
     * @param closedImage The closed image.
     * @param closedBuffer The ByteBuffer from a closed Image. buffer invalid
     *            access will be skipped if it is null.
     */
    protected void imageInvalidAccessTestAfterClose(Image closedImage,
            Plane closedPlane, ByteBuffer closedBuffer) {
        if (closedImage == null) {
            throw new IllegalArgumentException("" closedImage must be non-null"");
        }
        if (closedBuffer != null && !closedBuffer.isDirect()) {
            throw new IllegalArgumentException(""The input ByteBuffer should be direct ByteBuffer"");
        }

        if (closedPlane != null) {
            // Plane#getBuffer test
            try {
                closedPlane.getBuffer(); // An ISE should be thrown here.
                fail(""Image should throw IllegalStateException when calling getBuffer""
                        + "" after the image is closed"");
            } catch (IllegalStateException e) {
                // Expected.
            }

            // Plane#getPixelStride test
            try {
                closedPlane.getPixelStride(); // An ISE should be thrown here.
                fail(""Image should throw IllegalStateException when calling getPixelStride""
                        + "" after the image is closed"");
            } catch (IllegalStateException e) {
                // Expected.
            }

            // Plane#getRowStride test
            try {
                closedPlane.getRowStride(); // An ISE should be thrown here.
                fail(""Image should throw IllegalStateException when calling getRowStride""
                        + "" after the image is closed"");
            } catch (IllegalStateException e) {
                // Expected.
            }
        }

        // ByteBuffer access test
        if (closedBuffer != null) {
            try {
                closedBuffer.get(); // An ISE should be thrown here.
                fail(""Image should throw IllegalStateException when accessing a byte buffer""
                        + "" after the image is closed"");
            } catch (IllegalStateException e) {
                // Expected.
            }
        }

        // Image#getFormat test
        try {
            closedImage.getFormat();
            fail(""Image should throw IllegalStateException when calling getFormat""
                    + "" after the image is closed"");
        } catch (IllegalStateException e) {
            // Expected.
        }

        // Image#getWidth test
        try {
            closedImage.getWidth();
            fail(""Image should throw IllegalStateException when calling getWidth""
                    + "" after the image is closed"");
        } catch (IllegalStateException e) {
            // Expected.
        }

        // Image#getHeight test
        try {
            closedImage.getHeight();
            fail(""Image should throw IllegalStateException when calling getHeight""
                    + "" after the image is closed"");
        } catch (IllegalStateException e) {
            // Expected.
        }

        // Image#getTimestamp test
        try {
            closedImage.getTimestamp();
            fail(""Image should throw IllegalStateException when calling getTimestamp""
                    + "" after the image is closed"");
        } catch (IllegalStateException e) {
            // Expected.
        }

        // Image#getTimestamp test
        try {
            closedImage.getTimestamp();
            fail(""Image should throw IllegalStateException when calling getTimestamp""
                    + "" after the image is closed"");
        } catch (IllegalStateException e) {
            // Expected.
        }

        // Image#getCropRect test
        try {
            closedImage.getCropRect();
            fail(""Image should throw IllegalStateException when calling getCropRect""
                    + "" after the image is closed"");
        } catch (IllegalStateException e) {
            // Expected.
        }

        // Image#setCropRect test
        try {
            Rect rect = new Rect();
            closedImage.setCropRect(rect);
            fail(""Image should throw IllegalStateException when calling setCropRect""
                    + "" after the image is closed"");
        } catch (IllegalStateException e) {
            // Expected.
        }

        // Image#getPlanes test
        try {
            closedImage.getPlanes();
            fail(""Image should throw IllegalStateException when calling getPlanes""
                    + "" after the image is closed"");
        } catch (IllegalStateException e) {
            // Expected.
        }
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.server.wm.TestTaskOrganizer"	"registerOrganizer"	""	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/util/src/android/server/wm/TestTaskOrganizer.java"	""	"public void test/*
 *.
 */

package android.server.wm;

import static android.app.WindowConfiguration.ACTIVITY_TYPE_HOME;
import static android.app.WindowConfiguration.ACTIVITY_TYPE_RECENTS;
import static android.app.WindowConfiguration.ACTIVITY_TYPE_STANDARD;
import static android.app.WindowConfiguration.ACTIVITY_TYPE_UNDEFINED;
import static android.app.WindowConfiguration.WINDOWING_MODE_FULLSCREEN;
import static android.app.WindowConfiguration.WINDOWING_MODE_MULTI_WINDOW;
import static android.app.WindowConfiguration.WINDOWING_MODE_UNDEFINED;
import static android.view.Display.DEFAULT_DISPLAY;

import android.app.ActivityManager;
import android.content.Context;
import android.graphics.Rect;
import android.hardware.display.DisplayManager;
import android.os.Binder;
import android.os.IBinder;
import android.os.SystemClock;
import android.util.ArraySet;
import android.util.Log;
import android.view.Surface;
import android.view.SurfaceControl;
import android.view.WindowManager;
import android.window.TaskAppearedInfo;
import android.window.TaskOrganizer;
import android.window.WindowContainerToken;
import android.window.WindowContainerTransaction;

import androidx.annotation.NonNull;

import org.junit.Assert;

import java.util.HashMap;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.function.Predicate;

public class TestTaskOrganizer extends TaskOrganizer {
    private static final String TAG = TestTaskOrganizer.class.getSimpleName();
    public static final int INVALID_TASK_ID = -1;

    private boolean mRegistered;
    private ActivityManager.RunningTaskInfo mRootPrimary;
    private ActivityManager.RunningTaskInfo mRootSecondary;
    private IBinder mPrimaryCookie;
    private IBinder mSecondaryCookie;
    private final HashMap<Integer, ActivityManager.RunningTaskInfo> mKnownTasks = new HashMap<>();
    private final ArraySet<Integer> mPrimaryChildrenTaskIds = new ArraySet<>();
    private final ArraySet<Integer> mSecondaryChildrenTaskIds = new ArraySet<>();
    private final Rect mPrimaryBounds = new Rect();
    private final Rect mSecondaryBounds = new Rect();
    private final Context mContext;

    private static final int[] CONTROLLED_ACTIVITY_TYPES = {
            ACTIVITY_TYPE_STANDARD,
            ACTIVITY_TYPE_HOME,
            ACTIVITY_TYPE_RECENTS,
            ACTIVITY_TYPE_UNDEFINED
    };
    private static final int[] CONTROLLED_WINDOWING_MODES = {
            WINDOWING_MODE_FULLSCREEN,
            WINDOWING_MODE_MULTI_WINDOW,
            WINDOWING_MODE_UNDEFINED
    };

    public TestTaskOrganizer(Context context) {
        super();
        //TODO(b/192572357): Verify if the context is a UI context when b/190019118 is fixed.
        mContext = context;
    }

    @Override
    public List<TaskAppearedInfo> registerOrganizer() {
        //TODO(b/192572357): Replace createDisplayContext with createWindowContext and
        // getMaximumWindowMetrics with getCurrentWindowMetrics when b/190019118 is fixed.
        final Rect bounds = mContext.createDisplayContext(
                mContext.getSystemService(DisplayManager.class)
                        .getDisplay(DEFAULT_DISPLAY)).getSystemService(WindowManager.class)
                .getMaximumWindowMetrics()
                .getBounds();
        final boolean isLandscape = bounds.width() > bounds.height();
        if (isLandscape) {
            bounds.splitVertically(mPrimaryBounds, mSecondaryBounds);
        } else {
            bounds.splitHorizontally(mPrimaryBounds, mSecondaryBounds);
        }
        Log.i(TAG, ""registerOrganizer with PrimaryBounds="" + mPrimaryBounds
                + "" SecondaryBounds="" + mSecondaryBounds);

        synchronized (this) {
            final List<TaskAppearedInfo> taskInfos = super.registerOrganizer();
            for (int i = 0; i < taskInfos.size(); i++) {
                final TaskAppearedInfo info = taskInfos.get(i);
                onTaskAppeared(info.getTaskInfo(), info.getLeash());
            }
            createRootTasksIfNeeded();
            return taskInfos;
        }
    }

    private void createRootTasksIfNeeded() {
        synchronized (this) {
            if (mPrimaryCookie != null) return;
            mPrimaryCookie = new Binder();
            mSecondaryCookie = new Binder();

            createRootTask(DEFAULT_DISPLAY, WINDOWING_MODE_MULTI_WINDOW, mPrimaryCookie);
            createRootTask(DEFAULT_DISPLAY, WINDOWING_MODE_MULTI_WINDOW, mSecondaryCookie);

            waitForAndAssert(o -> mRootPrimary != null && mRootSecondary != null,
                    ""Failed to get root tasks"");
            Log.e(TAG, ""createRootTasksIfNeeded primary="" + mRootPrimary.taskId
                    + "" secondary="" + mRootSecondary.taskId);

            // Set the roots as adjacent to each other.
            final WindowContainerTransaction wct = new WindowContainerTransaction();
            wct.setAdjacentRoots(mRootPrimary.getToken(), mRootSecondary.getToken());
            applyTransaction(wct);
        }
    }

    private void waitForAndAssert(Predicate<Object> condition, String failureMessage) {
        waitFor(condition);
        if (!condition.test(this)) {
            Assert.fail(failureMessage);
        }
    }

    private void waitFor(Predicate<Object> condition) {
        final long waitTillTime = SystemClock.elapsedRealtime() + TimeUnit.SECONDS.toMillis(5);
        while (!condition.test(this)
                && SystemClock.elapsedRealtime() < waitTillTime) {
            try {
                wait(TimeUnit.SECONDS.toMillis(5));
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    private void notifyOnEnd(Runnable r) {
        r.run();
        notifyAll();
    }

    private void registerOrganizerIfNeeded() {
        if (mRegistered) return;

        registerOrganizer();
        mRegistered = true;
    }

    public void unregisterOrganizerIfNeeded() {
        synchronized (this) {
            if (!mRegistered) return;
            mRegistered = false;

            NestedShellPermission.run(() -> {
                dismissSplitScreen();

                deleteRootTask(mRootPrimary.getToken());
                mRootPrimary = null;
                mPrimaryCookie = null;
                mPrimaryChildrenTaskIds.clear();
                deleteRootTask(mRootSecondary.getToken());
                mRootSecondary = null;
                mSecondaryCookie = null;
                mSecondaryChildrenTaskIds.clear();

                super.unregisterOrganizer();
            });
        }
    }

    public void putTaskInSplitPrimary(int taskId) {
        NestedShellPermission.run(() -> {
            synchronized (this) {
                registerOrganizerIfNeeded();
                ActivityManager.RunningTaskInfo taskInfo = getTaskInfo(taskId);
                final WindowContainerTransaction t = new WindowContainerTransaction()
                        .setBounds(mRootPrimary.getToken(), mPrimaryBounds)
                        .setBounds(taskInfo.getToken(), null)
                        .setWindowingMode(taskInfo.getToken(), WINDOWING_MODE_UNDEFINED)
                        .reparent(taskInfo.getToken(), mRootPrimary.getToken(), true /* onTop */)
                        .reorder(mRootPrimary.getToken(), true /* onTop */);
                applyTransaction(t);

                waitForAndAssert(
                        o -> mPrimaryChildrenTaskIds.contains(taskId),
                        ""Can't put putTaskInSplitPrimary taskId="" + taskId);

                Log.e(TAG, ""putTaskInSplitPrimary taskId="" + taskId);
            }
        });
    }

    public void putTaskInSplitSecondary(int taskId) {
        NestedShellPermission.run(() -> {
            synchronized (this) {
                registerOrganizerIfNeeded();
                ActivityManager.RunningTaskInfo taskInfo = getTaskInfo(taskId);
                final WindowContainerTransaction t = new WindowContainerTransaction()
                        .setBounds(mRootSecondary.getToken(), mSecondaryBounds)
                        .setBounds(taskInfo.getToken(), null)
                        .setWindowingMode(taskInfo.getToken(), WINDOWING_MODE_UNDEFINED)
                        .reparent(taskInfo.getToken(), mRootSecondary.getToken(), true /* onTop */)
                        .reorder(mRootSecondary.getToken(), true /* onTop */);
                applyTransaction(t);

                waitForAndAssert(
                        o -> mSecondaryChildrenTaskIds.contains(taskId),
                        ""Can't put putTaskInSplitSecondary taskId="" + taskId);

                Log.e(TAG, ""putTaskInSplitSecondary taskId="" + taskId);
            }
        });
    }

    public void setLaunchRoot(int taskId) {
        NestedShellPermission.run(() -> {
            synchronized (this) {
                final WindowContainerTransaction t = new WindowContainerTransaction()
                        .setLaunchRoot(mKnownTasks.get(taskId).getToken(),
                                CONTROLLED_WINDOWING_MODES, CONTROLLED_ACTIVITY_TYPES);
                applyTransaction(t);
            }
        });
    }

    void dismissSplitScreen() {
        dismissSplitScreen(false /* primaryOnTop */);
    }

    void dismissSplitScreen(boolean primaryOnTop) {
        dismissSplitScreen(new WindowContainerTransaction(), primaryOnTop);
    }

    void dismissSplitScreen(WindowContainerTransaction t, boolean primaryOnTop) {
        synchronized (this) {
            NestedShellPermission.run(() -> {
                t.setLaunchRoot(mRootPrimary.getToken(), null, null)
                        .setLaunchRoot(
                                mRootSecondary.getToken(),
                                null,
                                null)
                        .reparentTasks(
                                primaryOnTop ? mRootSecondary.getToken() : mRootPrimary.getToken(),
                                null /* newParent */,
                                CONTROLLED_WINDOWING_MODES,
                                CONTROLLED_ACTIVITY_TYPES,
                                true /* onTop */)
                        .reparentTasks(
                                primaryOnTop ? mRootPrimary.getToken() : mRootSecondary.getToken(),
                                null /* newParent */,
                                CONTROLLED_WINDOWING_MODES,
                                CONTROLLED_ACTIVITY_TYPES,
                                true /* onTop */);
                applyTransaction(t);
            });
        }
    }

    void setRootPrimaryTaskBounds(Rect bounds) {
        setTaskBounds(mRootPrimary.getToken(), bounds);
    }

    void setRootSecondaryTaskBounds(Rect bounds) {
        setTaskBounds(mRootSecondary.getToken(), bounds);
    }

    public Rect getPrimaryTaskBounds() {
        return mPrimaryBounds;
    }

    public Rect getSecondaryTaskBounds() {
        return mSecondaryBounds;
    }

    private void setTaskBounds(WindowContainerToken container, Rect bounds) {
        synchronized (this) {
            NestedShellPermission.run(() -> {
                final WindowContainerTransaction t = new WindowContainerTransaction()
                        .setBounds(container, bounds);
                applyTransaction(t);
            });
        }
    }

    int getPrimarySplitTaskCount() {
        return mPrimaryChildrenTaskIds.size();
    }

    int getSecondarySplitTaskCount() {
        return mSecondaryChildrenTaskIds.size();
    }

    public int getPrimarySplitTaskId() {
        return mRootPrimary != null ? mRootPrimary.taskId : INVALID_TASK_ID;
    }

    public int getSecondarySplitTaskId() {
        return mRootSecondary != null ? mRootSecondary.taskId : INVALID_TASK_ID;
    }

    ActivityManager.RunningTaskInfo getTaskInfo(int taskId) {
        synchronized (this) {
            ActivityManager.RunningTaskInfo taskInfo = mKnownTasks.get(taskId);
            if (taskInfo != null) return taskInfo;

            final List<ActivityManager.RunningTaskInfo> rootTasks = getRootTasks(DEFAULT_DISPLAY,
                    null);
            for (ActivityManager.RunningTaskInfo info : rootTasks) {
                addTask(info);
            }

            return mKnownTasks.get(taskId);
        }
    }

    @Override
    public void onTaskAppeared(@NonNull ActivityManager.RunningTaskInfo taskInfo,
            SurfaceControl leash) {
        synchronized (this) {
            notifyOnEnd(() -> {
                SurfaceControl.Transaction t = new SurfaceControl.Transaction();
                t.setVisibility(leash, true /* visible */);
                addTask(taskInfo, leash, t);
                t.apply();
            });
        }
    }

    @Override
    public void onTaskVanished(@NonNull ActivityManager.RunningTaskInfo taskInfo) {
        synchronized (this) {
            removeTask(taskInfo);
        }
    }

    @Override
    public void onTaskInfoChanged(ActivityManager.RunningTaskInfo taskInfo) {
        synchronized (this) {
            notifyOnEnd(() -> addTask(taskInfo));
        }
    }

    private void addTask(ActivityManager.RunningTaskInfo taskInfo) {
        addTask(taskInfo, null /* SurfaceControl */, null /* Transaction */);
    }

    private void addTask(ActivityManager.RunningTaskInfo taskInfo, SurfaceControl leash,
            SurfaceControl.Transaction t) {
        mKnownTasks.put(taskInfo.taskId, taskInfo);
        if (taskInfo.hasParentTask()){
            if (mRootPrimary != null
                    && mRootPrimary.taskId == taskInfo.getParentTaskId()) {
                mPrimaryChildrenTaskIds.add(taskInfo.taskId);
            } else if (mRootSecondary != null
                    && mRootSecondary.taskId == taskInfo.getParentTaskId()) {
                mSecondaryChildrenTaskIds.add(taskInfo.taskId);
            }
            return;
        }

        if (mRootPrimary == null
                && mPrimaryCookie != null
                && taskInfo.containsLaunchCookie(mPrimaryCookie)) {
            mRootPrimary = taskInfo;
            if (t != null && leash != null) {
                t.setGeometry(leash, null, mPrimaryBounds, Surface.ROTATION_0);
            }
            return;
        }

        if (mRootSecondary == null
                && mSecondaryCookie != null
                && taskInfo.containsLaunchCookie(mSecondaryCookie)) {
            mRootSecondary = taskInfo;
            if (t != null && leash != null) {
                t.setGeometry(leash, null, mSecondaryBounds, Surface.ROTATION_0);
            }
        }
    }

    private void removeTask(ActivityManager.RunningTaskInfo taskInfo) {
        final int taskId = taskInfo.taskId;
        // ignores cleanup on duplicated removal request
        if (mKnownTasks.remove(taskId) == null) {
            return;
        }
        mPrimaryChildrenTaskIds.remove(taskId);
        mSecondaryChildrenTaskIds.remove(taskId);

        if ((mRootPrimary != null && taskId == mRootPrimary.taskId)
                || (mRootSecondary != null && taskId == mRootSecondary.taskId)) {
            unregisterOrganizerIfNeeded();
        }
    }
}"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"test.instant.cookie.CookieTest"	"testCookieUpdateAndRetrieval"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/InstantCookieApp/src/test/instant/cookie/CookieTest.java"	""	"public void testCookieUpdateAndRetrieval() throws Exception {
        PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();

        // We should be an instant app
        assertTrue(pm.isInstantApp());

        // The max cookie size is greater than zero
        assertTrue(pm.getInstantAppCookieMaxBytes() > 0);

        // Initially there is no cookie
        byte[] cookie = pm.getInstantAppCookie();
        assertTrue(cookie != null && cookie.length == 0);

        // Setting a cookie below max size should work
        pm.updateInstantAppCookie(""1"".getBytes());

        // Setting a cookie above max size should not work
        try {
            pm.updateInstantAppCookie(
                    new byte[pm.getInstantAppCookieMaxBytes() + 1]);
            fail(""Shouldn't be able to set a cookie larger than max size"");
        } catch (IllegalArgumentException e) {
            /* expected */
        }

        // Ensure cookie not modified
        assertEquals(""1"", new String(pm.getInstantAppCookie()));
    }"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"test.instant.cookie.CookieTest"	"testCookiePersistedAcrossInstantInstalls1"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/InstantCookieApp/src/test/instant/cookie/CookieTest.java"	""	"public void testCookiePersistedAcrossInstantInstalls1() throws Exception {
        PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();

        // Set a cookie to later check when reinstalled as instant app
        pm.updateInstantAppCookie(""2"".getBytes());
    }"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"test.instant.cookie.CookieTest"	"testCookiePersistedUpgradeFromInstant1"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/InstantCookieApp/src/test/instant/cookie/CookieTest.java"	""	"public void testCookiePersistedUpgradeFromInstant1() throws Exception {
        PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();

        // Make sure we are an instant app
        assertTrue(pm.isInstantApp());

        // Set a cookie to later check when upgrade to a normal app
        pm.updateInstantAppCookie(""3"".getBytes());
    }"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"test.instant.cookie.CookieTest"	"testCookiePersistedUpgradeFromInstant2"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/InstantCookieApp/src/test/instant/cookie/CookieTest.java"	""	"public void testCookiePersistedUpgradeFromInstant2() throws Exception {
        PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();

        // Make sure we are not an instant app
        assertFalse(pm.isInstantApp());

        // The cookie survives the upgrade to a normal app
        assertEquals(""3"", new String(pm.getInstantAppCookie()));
    }"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"test.instant.cookie.CookieTest"	"testCookieResetOnNonInstantReinstall1"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/InstantCookieApp/src/test/instant/cookie/CookieTest.java"	""	"public void testCookieResetOnNonInstantReinstall1() throws Exception {
        PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();

        // Set a cookie to later check when reinstalled as normal app
        pm.updateInstantAppCookie(""4"".getBytes());
    }"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"test.instant.cookie.CookieTest"	"testCookieResetOnNonInstantReinstall2"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/InstantCookieApp/src/test/instant/cookie/CookieTest.java"	""	"public void testCookieResetOnNonInstantReinstall2() throws Exception {
        PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();

        // The cookie should have been wiped if non-instant app is uninstalled
        byte[] cookie = pm.getInstantAppCookie();
        assertTrue(cookie != null && cookie.length == 0);
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.ScopedStorageTest"	"isInstantApp"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/src/android/scopedstorage/cts/ScopedStorageTest.java"	""	"/*
 *.
 */

package android.scopedstorage.cts;

import static android.scopedstorage.cts.lib.TestUtils.BYTES_DATA1;
import static android.scopedstorage.cts.lib.TestUtils.adoptShellPermissionIdentity;
import static android.scopedstorage.cts.lib.TestUtils.assertCanAccessPrivateAppAndroidDataDir;
import static android.scopedstorage.cts.lib.TestUtils.assertCanAccessPrivateAppAndroidObbDir;
import static android.scopedstorage.cts.lib.TestUtils.assertCanRenameFile;
import static android.scopedstorage.cts.lib.TestUtils.assertDirectoryContains;
import static android.scopedstorage.cts.lib.TestUtils.assertFileContent;
import static android.scopedstorage.cts.lib.TestUtils.assertMountMode;
import static android.scopedstorage.cts.lib.TestUtils.assertThrows;
import static android.scopedstorage.cts.lib.TestUtils.canOpen;
import static android.scopedstorage.cts.lib.TestUtils.canReadAndWriteAs;
import static android.scopedstorage.cts.lib.TestUtils.createFileAs;
import static android.scopedstorage.cts.lib.TestUtils.deleteFileAs;
import static android.scopedstorage.cts.lib.TestUtils.deleteFileAsNoThrow;
import static android.scopedstorage.cts.lib.TestUtils.dropShellPermissionIdentity;
import static android.scopedstorage.cts.lib.TestUtils.executeShellCommand;
import static android.scopedstorage.cts.lib.TestUtils.getAndroidDir;
import static android.scopedstorage.cts.lib.TestUtils.getAndroidMediaDir;
import static android.scopedstorage.cts.lib.TestUtils.getContentResolver;
import static android.scopedstorage.cts.lib.TestUtils.getDcimDir;
import static android.scopedstorage.cts.lib.TestUtils.getDefaultTopLevelDirs;
import static android.scopedstorage.cts.lib.TestUtils.getDownloadDir;
import static android.scopedstorage.cts.lib.TestUtils.getExternalFilesDir;
import static android.scopedstorage.cts.lib.TestUtils.getExternalMediaDir;
import static android.scopedstorage.cts.lib.TestUtils.getExternalStorageDir;
import static android.scopedstorage.cts.lib.TestUtils.getFileOwnerPackageFromDatabase;
import static android.scopedstorage.cts.lib.TestUtils.getFileRowIdFromDatabase;
import static android.scopedstorage.cts.lib.TestUtils.getFileUri;
import static android.scopedstorage.cts.lib.TestUtils.getMoviesDir;
import static android.scopedstorage.cts.lib.TestUtils.getMusicDir;
import static android.scopedstorage.cts.lib.TestUtils.getPicturesDir;
import static android.scopedstorage.cts.lib.TestUtils.openWithMediaProvider;
import static android.scopedstorage.cts.lib.TestUtils.pollForExternalStorageState;
import static android.scopedstorage.cts.lib.TestUtils.pollForManageExternalStorageAllowed;
import static android.scopedstorage.cts.lib.TestUtils.pollForPermission;
import static android.scopedstorage.cts.lib.TestUtils.setupDefaultDirectories;
import static android.scopedstorage.cts.lib.TestUtils.verifyInsertFromExternalMediaDirViaData_allowed;
import static android.scopedstorage.cts.lib.TestUtils.verifyInsertFromExternalMediaDirViaRelativePath_allowed;
import static android.scopedstorage.cts.lib.TestUtils.verifyInsertFromExternalPrivateDirViaData_denied;
import static android.scopedstorage.cts.lib.TestUtils.verifyInsertFromExternalPrivateDirViaRelativePath_denied;
import static android.scopedstorage.cts.lib.TestUtils.verifyUpdateToExternalDirsViaData_denied;
import static android.scopedstorage.cts.lib.TestUtils.verifyUpdateToExternalMediaDirViaRelativePath_allowed;
import static android.scopedstorage.cts.lib.TestUtils.verifyUpdateToExternalPrivateDirsViaRelativePath_denied;
import static android.system.OsConstants.F_OK;
import static android.system.OsConstants.R_OK;
import static android.system.OsConstants.W_OK;

import static androidx.test.InstrumentationRegistry.getContext;

import static com.google.common.truth.Truth.assertThat;

import static junit.framework.Assert.assertFalse;
import static junit.framework.Assert.assertTrue;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assume.assumeFalse;
import static org.junit.Assume.assumeTrue;

import android.Manifest;
import android.app.WallpaperManager;
import android.net.Uri;
import android.os.Build;
import android.os.Environment;
import android.os.ParcelFileDescriptor;
import android.os.storage.StorageManager;
import android.platform.test.annotations.AppModeInstant;
import android.provider.MediaStore;
import android.system.ErrnoException;
import android.system.Os;
import android.util.Log;

import androidx.test.runner.AndroidJUnit4;

import com.android.cts.install.lib.TestApp;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

/**
 * Runs the scoped storage tests on primary external storage.
 *
 * <p>These tests are also run on a public volume by {@link PublicVolumeTest}.
 */
@RunWith(AndroidJUnit4.class)
public class ScopedStorageTest {
    static final String TAG = ""ScopedStorageTest"";
    static final String THIS_PACKAGE_NAME = getContext().getPackageName();
    static final int USER_SYSTEM = 0;

    /**
     * To help avoid flaky tests, give ourselves a unique nonce to be used for
     * all filesystem paths, so that we don't risk conflicting with previous
     * test runs.
     */
    static final String NONCE = String.valueOf(System.nanoTime());

    static final String TEST_DIRECTORY_NAME = ""ScopedStorageTestDirectory"" + NONCE;

    static final String AUDIO_FILE_NAME = ""ScopedStorageTest_file_"" + NONCE + "".mp3"";
    static final String IMAGE_FILE_NAME = ""ScopedStorageTest_file_"" + NONCE + "".jpg"";
    static final String NONMEDIA_FILE_NAME = ""ScopedStorageTest_file_"" + NONCE + "".pdf"";

    // The following apps are installed before the tests are run via a target_preparer.
    // See test config for details.
    // An app with READ_EXTERNAL_STORAGE permission
    private static final TestApp APP_A_HAS_RES = new TestApp(""TestAppA"",
            ""android.scopedstorage.cts.testapp.A.withres"", 1, false,
            ""CtsScopedStorageTestAppA.apk"");
    // An app with no permissions
    private static final TestApp APP_B_NO_PERMS = new TestApp(""TestAppB"",
            ""android.scopedstorage.cts.testapp.B.noperms"", 1, false,
            ""CtsScopedStorageTestAppB.apk"");
    // A legacy targeting app with RES and WES permissions
    private static final TestApp APP_D_LEGACY_HAS_RW = new TestApp(""TestAppDLegacy"",
            ""android.scopedstorage.cts.testapp.D"", 1, false, ""CtsScopedStorageTestAppCLegacy.apk"");

    @Before
    public void setup() throws Exception {
        if (!getContext().getPackageManager().isInstantApp()) {
            pollForExternalStorageState();
            getExternalFilesDir().mkdirs();
        }
    }

    /**
     * This method needs to be called once before running the whole test.
     */"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.scopedstorage.cts.ScopedStorageTest"	"testInstantAppsCantAccessExternalStorage"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/src/android/scopedstorage/cts/ScopedStorageTest.java"	""	"@AppModeInstant
    public void testInstantAppsCantAccessExternalStorage() throws Exception {
        assumeTrue(""This test requires that the test runs as an Instant app"",
                getContext().getPackageManager().isInstantApp());
        assertThat(getContext().getPackageManager().isInstantApp()).isTrue();

        // Check that the app does not have legacy external storage access
        assertThat(Environment.isExternalStorageLegacy()).isFalse();

        // Can't read ExternalStorageDir
        assertThat(getExternalStorageDir().list()).isNull();

        // Can't create a top-level direcotry
        final File topLevelDir = new File(getExternalStorageDir(), TEST_DIRECTORY_NAME);
        assertThat(topLevelDir.mkdir()).isFalse();

        // Can't create file under root dir
        final File newTxtFile = new File(getExternalStorageDir(), NONMEDIA_FILE_NAME);
        assertThrows(IOException.class,
                () -> {
                    newTxtFile.createNewFile();
                });

        // Can't create music file under /MUSIC
        final File newMusicFile = new File(getMusicDir(), AUDIO_FILE_NAME);
        assertThrows(IOException.class,
                () -> {
                    newMusicFile.createNewFile();
                });

        // getExternalFilesDir() is not null
        assertThat(getExternalFilesDir()).isNotNull();

        // Can't read/write app specific dir
        assertThat(getExternalFilesDir().list()).isNull();
        assertThat(getExternalFilesDir().exists()).isFalse();
    }

    private static boolean isAtLeastS() {
        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.S;
    }

    private void createAndCheckFileAsApp(TestApp testApp, File newFile) throws Exception {
        assertThat(createFileAs(testApp, newFile.getPath())).isTrue();
        assertThat(getFileOwnerPackageFromDatabase(newFile))
            .isEqualTo(testApp.getPackageName());
        assertThat(getFileRowIdFromDatabase(newFile)).isNotEqualTo(-1);
    }

    private static void assertCreateFilesAs(TestApp testApp, File... files) throws Exception {
        for (File file : files) {
            assertFalse(""File already exists: "" + file, file.exists());
            assertTrue(""Failed to create file "" + file + "" on behalf of ""
                            + testApp.getPackageName(), createFileAs(testApp, file.getPath()));
        }
    }

    /**
     * Makes {@code testApp} create {@code files}. Publishes {@code files} by scanning the file.
     * Pending files from FUSE are not visible to other apps via MediaStore APIs. We have to publish
     * the file or make the file non-pending to make the file visible to other apps.
     * <p>
     * Note that this method can only be used for scannable files.
     */
    private static void assertCreatePublishedFilesAs(TestApp testApp, File... files)
            throws Exception {
        for (File file : files) {
            assertTrue(""Failed to create published file "" + file + "" on behalf of ""
                    + testApp.getPackageName(), createFileAs(testApp, file.getPath()));
            assertNotNull(""Failed to scan "" + file,
                    MediaStore.scanFile(getContentResolver(), file));
        }
    }

    private static void deleteFilesAs(TestApp testApp, File... files) throws Exception {
        for (File file : files) {
            deleteFileAs(testApp, file.getPath());
        }
    }

    /**
     * For possible values of {@code mode}, look at {@link android.content.ContentProvider#openFile}
     */
    private static void assertCanQueryAndOpenFile(File file, String mode) throws IOException {
        // This call performs the query
        final Uri fileUri = getFileUri(file);
        // The query succeeds iff it didn't return null
        assertThat(fileUri).isNotNull();
        // Now we assert that we can open the file through ContentResolver
        try (final ParcelFileDescriptor pfd =
                        getContentResolver().openFileDescriptor(fileUri, mode)) {
            assertThat(pfd).isNotNull();
        }
    }

    private static void assertCanCreateFile(File file) throws IOException {
        // If the file somehow managed to survive a previous run, then the test app was uninstalled
        // and MediaProvider will remove our its ownership of the file, so it's not guaranteed that
        // we can create nor delete it.
        if (!file.exists()) {
            assertThat(file.createNewFile()).isTrue();
            assertThat(file.delete()).isTrue();
        } else {
            Log.w(TAG,
                    ""Couldn't assertCanCreateFile("" + file + "") because file existed prior to ""
                            + ""running the test!"");
        }
    }

    private static void assertFileAccess_existsOnly(File file) throws Exception {
        assertThat(file.isFile()).isTrue();
        assertAccess(file, true, false, false);
    }

    private static void assertFileAccess_readOnly(File file) throws Exception {
        assertThat(file.isFile()).isTrue();
        assertAccess(file, true, true, false);
    }

    private static void assertFileAccess_readWrite(File file) throws Exception {
        assertThat(file.isFile()).isTrue();
        assertAccess(file, true, true, true);
    }

    private static void assertDirectoryAccess(File dir, boolean exists, boolean canWrite)
            throws Exception {
        // This util does not handle app data directories.
        assumeFalse(dir.getAbsolutePath().startsWith(getAndroidDir().getAbsolutePath())
                && !dir.equals(getAndroidDir()));
        assertThat(dir.isDirectory()).isEqualTo(exists);
        // For non-app data directories, exists => canRead().
        assertAccess(dir, exists, exists, exists && canWrite);
    }

    private static void assertAccess(File file, boolean exists, boolean canRead, boolean canWrite)
            throws Exception {
        assertAccess(file, exists, canRead, canWrite, true /* checkExists */);
    }

    private static void assertCannotReadOrWrite(File file)
            throws Exception {
        // App data directories have different 'x' bits on upgrading vs new devices. Let's not
        // check 'exists', by passing checkExists=false. But assert this app cannot read or write
        // the other app's file.
        assertAccess(file, false /* value is moot */, false /* canRead */,
                false /* canWrite */, false /* checkExists */);
    }

    private static void assertCanAccessMyAppFile(File file)
            throws Exception {
        assertAccess(file, true, true /* canRead */,
                true /*canWrite */, true /* checkExists */);
    }

    private static void assertAccess(File file, boolean exists, boolean canRead, boolean canWrite,
            boolean checkExists) throws Exception {
        if (checkExists) {
            assertThat(file.exists()).isEqualTo(exists);
        }
        assertThat(file.canRead()).isEqualTo(canRead);
        assertThat(file.canWrite()).isEqualTo(canWrite);
        if (file.isDirectory()) {
            if (checkExists) {
                assertThat(file.canExecute()).isEqualTo(exists);
            }
        } else {
            assertThat(file.canExecute()).isFalse(); // Filesytem is mounted with MS_NOEXEC
        }

        // Test some combinations of mask.
        assertAccess(file, R_OK, canRead);
        assertAccess(file, W_OK, canWrite);
        assertAccess(file, R_OK | W_OK, canRead && canWrite);
        assertAccess(file, W_OK | F_OK, canWrite);

        if (checkExists) {
            assertAccess(file, F_OK, exists);
        }
    }

    private static void assertAccess(File file, int mask, boolean expected) throws Exception {
        if (expected) {
            assertThat(Os.access(file.getAbsolutePath(), mask)).isTrue();
        } else {
            assertThrows(ErrnoException.class, () -> { Os.access(file.getAbsolutePath(), mask); });
        }
    }

    /**
     * Creates a file at any location on storage (except external app data directory).
     * The owner of the file is not the caller app.
     */
    private void createFileAsLegacyApp(File file) throws Exception {
        // Use a legacy app to create this file, since it could be outside shared storage.
        Log.d(TAG, ""Creating file "" + file);
        assertThat(createFileAs(APP_D_LEGACY_HAS_RW, file.getAbsolutePath())).isTrue();
    }

    /**
     * Creates a file at any location on storage (except external app data directory).
     * The owner of the file is not the caller app.
     */
    private void createDirectoryAsLegacyApp(File file) throws Exception {
        // Use a legacy app to create this file, since it could be outside shared storage.
        Log.d(TAG, ""Creating directory "" + file);
        // Create a tmp file in the target directory, this would also create the required
        // directory, then delete the tmp file. It would leave only new directory.
        assertThat(createFileAs(APP_D_LEGACY_HAS_RW, file.getAbsolutePath() + ""/tmp.txt"")).isTrue();
        assertThat(deleteFileAs(APP_D_LEGACY_HAS_RW, file.getAbsolutePath() + ""/tmp.txt"")).isTrue();
    }

    /**
     * Deletes a file at any location on storage (except external app data directory).
     */
    private void deleteAsLegacyApp(File file) throws Exception {
        // Use a legacy app to delete this file, since it could be outside shared storage.
        Log.d(TAG, ""Deleting file "" + file);
        deleteFileAs(APP_D_LEGACY_HAS_RW, file.getAbsolutePath());
    }

    private int getCurrentUser() throws Exception {
        String userId = executeShellCommand(""am get-current-user"");
        return Integer.parseInt(userId.trim());
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.os.cts.ParcelFileDescriptorProcessTest"	"isInstantApp"	""	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorProcessTest.java"	""	"public void test/*
 *.
 */

package android.os.cts;

import android.app.ActivityManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.IBinder;
import android.os.ParcelFileDescriptor;
import android.os.RemoteException;
import android.os.SystemClock;
import android.test.AndroidTestCase;

import com.google.common.util.concurrent.AbstractFuture;

import junit.framework.ComparisonFailure;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/**
 * Test various cross-process {@link ParcelFileDescriptor} interactions.
 */
public class ParcelFileDescriptorProcessTest extends AndroidTestCase {

    private Intent redIntent;
    private Intent blueIntent;
    private PeerConnection redConn;
    private PeerConnection blueConn;
    private IParcelFileDescriptorPeer red;
    private IParcelFileDescriptorPeer blue;

    public static class PeerConnection extends AbstractFuture<IParcelFileDescriptorPeer>
            implements ServiceConnection {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            set(IParcelFileDescriptorPeer.Stub.asInterface(service));
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
        }

        @Override
        public IParcelFileDescriptorPeer get() throws InterruptedException, ExecutionException {
            try {
                return get(5, TimeUnit.SECONDS);
            } catch (TimeoutException e) {
                throw new RuntimeException(e);
            }
        }
    }

    private static void assertContains(String expected, String actual) {
        if (actual.contains(expected)) return;
        throw new ComparisonFailure("""", expected, actual);
    }

    private static void crash(IParcelFileDescriptorPeer peer) {
        try {
            peer.crash();
        } catch (RemoteException e) {
        }
        SystemClock.sleep(500);
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        final Context context = getContext();

        // Bring up both remote processes and wire them to each other
        redIntent = new Intent();
        redIntent.setComponent(new ComponentName(
                ""android.os.cts"", ""android.os.cts.ParcelFileDescriptorPeer$Red""));
        blueIntent = new Intent();
        blueIntent.setComponent(new ComponentName(
                ""android.os.cts"", ""android.os.cts.ParcelFileDescriptorPeer$Blue""));
        redConn = new PeerConnection();
        blueConn = new PeerConnection();
        context.startService(redIntent);
        context.startService(blueIntent);
        getContext().bindService(redIntent, redConn, 0);
        getContext().bindService(blueIntent, blueConn, 0);
        red = redConn.get();
        blue = blueConn.get();
        red.setPeer(blue);
        blue.setPeer(red);
    }

    @Override
    protected void tearDown() throws Exception {
        super.tearDown();

        final Context context = getContext();
        context.unbindService(redConn);
        context.unbindService(blueConn);
        context.stopService(redIntent);
        context.stopService(blueIntent);

        // Instant Apps don't have the KILL_BACKGROUND_PROCESSES permission
        if (!context.getPackageManager().isInstantApp()) {
            final ActivityManager am = (ActivityManager) mContext.getSystemService(
                    Context.ACTIVITY_SERVICE);
            am.killBackgroundProcesses(context.getPackageName());
        }
    }"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.normalapp.ExposedActivity"	"finish"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/NormalApp/src/com/android/cts/normalapp/ExposedActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.normalapp;

import android.app.Activity;
import android.content.Intent;
import android.content.pm.ResolveInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.net.Uri;
import android.os.Bundle;
import android.util.Log;

import com.android.cts.util.TestResult;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.List;

public class ExposedActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        boolean canAccessInstantApp = false;
        String exception = null;
        try {
            canAccessInstantApp = tryAccessingInstantApp();
        } catch (Throwable t) {
            exception = t.getClass().getName();
        }

        TestResult.getBuilder()
                .setPackageName(""com.android.cts.normalapp"")
                .setComponentName(""ExposedActivity"")
                .setStatus(""PASS"")
                .setException(exception)
                .setEphemeralPackageInfoExposed(canAccessInstantApp)
                .build()
                .broadcast(this);
        finish();
    }

    private boolean tryAccessingInstantApp() throws NameNotFoundException {
        final PackageInfo info = getPackageManager()
                .getPackageInfo(""com.android.cts.ephemeralapp1"", 0 /*flags*/);
        return (info != null);
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.media.cts.BaseMultiUserTest"	"listUsers"	"CtsMediaHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/media/src/android/media/cts/BaseMultiUserTest.java"	""	"public void test/*
 *.
 */

package android.media.cts;

import com.android.compatibility.common.tradefed.build.CompatibilityBuildHelper;
import com.android.ddmlib.testrunner.RemoteAndroidTestRunner;
import com.android.ddmlib.testrunner.TestResult.TestStatus;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.log.LogUtil.CLog;
import com.android.tradefed.result.CollectingTestListener;
import com.android.tradefed.result.TestDescription;
import com.android.tradefed.result.TestResult;
import com.android.tradefed.result.TestRunResult;
import com.android.tradefed.testtype.DeviceTestCase;
import com.android.tradefed.testtype.IBuildReceiver;

import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

/**
 * Base class for host-side tests for multi-user aware media APIs.
 */
public class BaseMultiUserTest extends BaseMediaHostSideTest {
    private static final String SETTINGS_PACKAGE_VERIFIER_NAMESPACE = ""global"";
    private static final String SETTINGS_PACKAGE_VERIFIER_NAME = ""package_verifier_enable"";

    /**
     * User ID for all users.
     * The value is from the UserHandle class.
     */
    protected static final int USER_ALL = -1;

    /**
     * User ID for the system user.
     * The value is from the UserHandle class.
     */
    protected static final int USER_SYSTEM = 0;

    private String mPackageVerifier;

    private Set<String> mExistingPackages;
    private List<Integer> mExistingUsers;
    private HashSet<String> mAvailableFeatures;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        // Ensure that build has been set before test is run.
        assertNotNull(mCtsBuild);
        mExistingPackages = getDevice().getInstalledPackageNames();

        // Disable the package verifier to avoid the dialog when installing an app
        mPackageVerifier =
                getSettings(
                        SETTINGS_PACKAGE_VERIFIER_NAMESPACE,
                        SETTINGS_PACKAGE_VERIFIER_NAME,
                        USER_ALL);
        putSettings(
                SETTINGS_PACKAGE_VERIFIER_NAMESPACE,
                SETTINGS_PACKAGE_VERIFIER_NAME,
                ""0"",
                USER_ALL);

        mExistingUsers = new ArrayList<>();
        int primaryUserId = getDevice().getPrimaryUserId();
        mExistingUsers.add(primaryUserId);
        mExistingUsers.add(USER_SYSTEM);

        executeShellCommand(""am switch-user "" + primaryUserId);
        executeShellCommand(""wm dismiss-keyguard"");
    }

    @Override
    protected void tearDown() throws Exception {
        // Reset the package verifier setting to its original value.
        putSettings(
                SETTINGS_PACKAGE_VERIFIER_NAMESPACE,
                SETTINGS_PACKAGE_VERIFIER_NAME,
                mPackageVerifier,
                USER_ALL);

        // Remove users created during the test.
        for (int userId : getDevice().listUsers()) {
            if (!mExistingUsers.contains(userId)) {
                removeUser(userId);
            }
        }
        // Remove packages installed during the test.
        for (String packageName : getDevice().getUninstallablePackageNames()) {
            if (mExistingPackages.contains(packageName)) {
                continue;
            }
            CLog.d(""Removing leftover package: "" + packageName);
            getDevice().uninstallPackage(packageName);
        }
        super.tearDown();
    }

    /**
     * Installs the app as if the user of the ID {@param userId} has installed the app.
     *
     * @param appFileName file name of the app.
     * @param userId user ID to install the app against.
     */
    protected void installAppAsUser(String appFileName, int userId, boolean asInstantApp)
            throws FileNotFoundException, DeviceNotAvailableException {
        CLog.d(""Installing app "" + appFileName + "" for user "" + userId);
        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);
        String result = getDevice().installPackageForUser(
                buildHelper.getTestFile(appFileName),
                true,
                true,
                userId,
                ""-t"",
                asInstantApp ? ""--instant"" : """");
        assertNull(""Failed to install "" + appFileName + "" for user "" + userId + "": "" + result,
                result);
    }

    private int createAndStartUser(String extraParam) throws Exception {
        String command = ""pm create-user"" + extraParam + "" TestUser_"" + System.currentTimeMillis();
        String commandOutput = executeShellCommand(command);

        String[] tokens = commandOutput.split(""\\s+"");
        assertTrue(tokens.length > 0);
        assertEquals(""Success:"", tokens[0]);
        int userId = Integer.parseInt(tokens[tokens.length-1]);

        // Start user for MediaSessionService to notice the created user.
        getDevice().startUser(userId);
        return userId;
    }

    /**
     * Creates and starts a new user.
     */
    protected int createAndStartUser() throws Exception {
        return createAndStartUser("""");
    }

    /**
     * Creates and starts a restricted profile for the {@param parentUserId}.
     *
     * @param parentUserId parent user id.
     */
    protected int createAndStartRestrictedProfile(int parentUserId) throws Exception {
        return createAndStartUser("" --profileOf "" + parentUserId + "" --restricted"");
    }

    /**
     * Creates and starts a managed profile for the {@param parentUserId}.
     *
     * @param parentUserId parent user id.
     */
    protected int createAndStartManagedProfile(int parentUserId) throws Exception {
        return createAndStartUser("" --profileOf "" + parentUserId + "" --managed"");
    }

    /**
     * Removes the user that is created during the test.
     * <p>It will be no-op if the user cannot be removed or doesn't exist.
     *
     * @param userId user ID to remove.
     */
    protected void removeUser(int userId) throws Exception  {
        if (getDevice().listUsers().contains(userId) && userId != USER_SYSTEM
                && !mExistingUsers.contains(userId)) {
            getDevice().executeShellCommand(""am wait-for-broadcast-idle"");
            // Don't log output, as tests sometimes set no debug user restriction, which
            // causes this to fail, we should still continue and remove the user.
            String stopUserCommand = ""am stop-user -w -f "" + userId;
            CLog.d(""Stopping and removing user "" + userId);
            getDevice().executeShellCommand(stopUserCommand);
            assertTrue(""Couldn't remove user"", getDevice().removeUser(userId));
        }
    }

    /**
     * Runs tests on the device as if it's {@param userId}.
     *
     * @param pkgName test package file name that contains the {@link AndroidTestCase}
     * @param testClassName Class name to test within the test package. Can be {@code null} if you
     *    want to run all test classes in the package.
     * @param testMethodName Method name to test within the test class. Can be {@code null} if you
     *    want to run all test methods in the class. Will be ignored if {@param testClassName} is
     *    {@code null}.
     * @param userId user ID to run the tests as.
     */
    protected void runDeviceTests(
            String pkgName, @Nullable String testClassName,
            @Nullable String testMethodName, int userId) throws DeviceNotAvailableException {
        RemoteAndroidTestRunner testRunner = getTestRunner(pkgName, testClassName, testMethodName);
        CollectingTestListener listener = new CollectingTestListener();
        assertTrue(getDevice().runInstrumentationTestsAsUser(testRunner, userId, listener));

        final TestRunResult result = listener.getCurrentRunResults();
        assertTestsPassed(result);
    }

    /**
     * Checks whether it is possible to create the desired number of users.
     */
    protected boolean canCreateAdditionalUsers(int numberOfUsers)
            throws DeviceNotAvailableException {
        return getDevice().listUsers().size() + numberOfUsers <=
                getDevice().getMaxNumberOfUsersSupported();
    }

    /**
     * Gets the system setting as a string from the system settings provider for the user.
     *
     * @param namespace namespace of the setting.
     * @param name name of the setting.
     * @param userId user ID to query the setting. Can be {@link #USER_ALL}.
     * @return value of the system setting provider with the given namespace and name.
     *    {@code null}, empty string, or ""null"" will be returned to the empty string ("""") instead.
     */
    protected @Nonnull String getSettings(@Nonnull String namespace, @Nonnull String name,
            int userId) throws Exception {
        String userFlag = (userId == USER_ALL) ? """" : "" --user "" + userId;
        String commandOutput = executeShellCommand(
                ""settings"" + userFlag + "" get "" + namespace + "" "" + name);
        if (commandOutput == null || commandOutput.isEmpty() || commandOutput.equals(""null"")) {
            commandOutput = """";
        }
        return commandOutput;
    }

    /**
     * Puts the string to the system settings provider for the user.
     * <p>This deletes the setting for an empty {@param value} as 'settings put' doesn't allow
     * putting empty value.
     *
     * @param namespace namespace of the setting.
     * @param name name of the setting.
     * @param value value of the system setting provider with the given namespace and name.
     * @param userId user ID to set the setting. Can be {@link #USER_ALL}.
     */
    protected void putSettings(@Nonnull String namespace, @Nonnull String name,
            @Nullable String value, int userId) throws Exception {
        if (value == null || value.isEmpty()) {
            // Delete the setting if the value is null or empty as 'settings put' doesn't accept
            // them.
            // Ignore userId here because 'settings delete' doesn't support it.
            executeShellCommand(""settings delete "" + namespace + "" "" + name);
        } else {
            String userFlag = (userId == USER_ALL) ? """" : "" --user "" + userId;
            executeShellCommand(""settings"" + userFlag + "" put "" + namespace + "" "" + name
                    + "" "" + value);
        }
    }

    protected boolean hasDeviceFeature(String requiredFeature) throws DeviceNotAvailableException {
        if (mAvailableFeatures == null) {
            // TODO: Move this logic to ITestDevice.
            String command = ""pm list features"";
            String commandOutput = getDevice().executeShellCommand(command);
            CLog.i(""Output for command "" + command + "": "" + commandOutput);

            // Extract the id of the new user.
            mAvailableFeatures = new HashSet<>();
            for (String feature : commandOutput.split(""\\s+"")) {
                // Each line in the output of the command has the format ""feature:{FEATURE_VALUE}"".
                String[] tokens = feature.split("":"");
                assertTrue(
                        ""\"""" + feature + ""\"" expected to have format feature:{FEATURE_VALUE}"",
                        tokens.length > 1);
                assertEquals(feature, ""feature"", tokens[0]);
                mAvailableFeatures.add(tokens[1]);
            }
        }
        boolean result = mAvailableFeatures.contains(requiredFeature);
        return result;
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.managedprovisioning.RecentsRedactionActivity"	"getTestId"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/RecentsRedactionActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.managedprovisioning;

import android.app.AlertDialog;
import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.os.Bundle;
import android.provider.Settings;
import android.view.View;

import com.android.cts.verifier.ArrayTestListAdapter;
import com.android.cts.verifier.DialogTestListActivity;
import com.android.cts.verifier.R;
import com.android.cts.verifier.TestResult;

/**
 * This test verifies that if a work profile is locked with a separate password, Recents views for
 * for applications in the work profile are redacted appropriately.
 */
public class RecentsRedactionActivity extends DialogTestListActivity {
    private static final String TAG = RecentsRedactionActivity.class.getSimpleName();

    public static final String ACTION_RECENTS =
            ""com.android.cts.verifier.managedprovisioning.RECENTS"";

    private ComponentName mAdmin;
    private DevicePolicyManager mDevicePolicyManager;

    private DialogTestListItem mVerifyRedacted;
    private DialogTestListItem mVerifyNotRedacted;

    public RecentsRedactionActivity() {
        super(R.layout.provisioning_byod,
                /* title */ R.string.provisioning_byod_recents,
                /* description */ R.string.provisioning_byod_recents_info,
                /* instructions */ R.string.provisioning_byod_recents_instructions);
    }

    // Default listener will use setResult(), which won't work due to activity being in a new task.
    private View.OnClickListener clickListener = target -> {
        final int resultCode;
        switch (target.getId()) {
            case R.id.pass_button:
                resultCode = TestResult.TEST_RESULT_PASSED;
                break;
            case R.id.fail_button:
                resultCode = TestResult.TEST_RESULT_FAILED;
                break;
            default:
                throw new IllegalArgumentException(""Unknown id: "" + target.getId());
        }
        Intent resultIntent = TestResult.createResult(RecentsRedactionActivity.this, resultCode,
                getTestId(), getTestDetails(), getReportLog(), getHistoryCollection());

        new ByodFlowTestHelper(this).sendResultToPrimary(resultIntent);
        finish();
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        findViewById(R.id.pass_button).setOnClickListener(clickListener);
        findViewById(R.id.fail_button).setOnClickListener(clickListener);

        mPrepareTestButton.setText(R.string.provisioning_byod_recents_lock_now);
        mPrepareTestButton.setOnClickListener((View view) -> {
            mDevicePolicyManager.lockNow();
        });

        mAdmin = new ComponentName(this, DeviceAdminTestReceiver.class.getName());
        mDevicePolicyManager = (DevicePolicyManager)
                getSystemService(Context.DEVICE_POLICY_SERVICE);
    }

    @Override
    protected void setupTests(ArrayTestListAdapter adapter) {
        mVerifyRedacted = new DialogTestListItem(this,
                /* name */ R.string.provisioning_byod_recents_verify_redacted,
                /* testId */ ""BYOD_recents_verify_redacted"",
                /* instruction */ R.string.provisioning_byod_recents_verify_redacted_instruction,
                /* action */ new Intent(DevicePolicyManager.ACTION_SET_NEW_PASSWORD));

        mVerifyNotRedacted = new DialogTestListItem(this,
                /* name */ R.string.provisioning_byod_recents_verify_not_redacted,
                /* testId */ ""BYOD_recents_verify_not_redacted"",
                /* intruction */ R.string.provisioning_byod_recents_verify_not_redacted_instruction,
                /* action */ new Intent(Settings.ACTION_SECURITY_SETTINGS));

        adapter.add(mVerifyRedacted);
        adapter.add(mVerifyNotRedacted);
    }

    @Override
    public void onBackPressed() {
        if (hasPassword()) {
            requestRemovePassword();
            return;
        }
        super.onBackPressed();
    }

    private boolean hasPassword() {
        try {
            mDevicePolicyManager.setPasswordQuality(mAdmin,
                    DevicePolicyManager.PASSWORD_QUALITY_SOMETHING);
            return mDevicePolicyManager.isActivePasswordSufficient();
        } finally {
            mDevicePolicyManager.setPasswordQuality(mAdmin,
                    DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED);
        }
    }

    private void requestRemovePassword() {
        new AlertDialog.Builder(this)
                .setIcon(android.R.drawable.ic_dialog_info)
                .setTitle(R.string.provisioning_byod_recents)
                .setMessage(R.string.provisioning_byod_recents_remove_password)
                .setPositiveButton(android.R.string.ok, (DialogInterface dialog, int which) -> {
                    startActivity(new Intent(Settings.ACTION_SECURITY_SETTINGS));
                })
                .show();
    }
}"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.os.storage.cts.StorageManagerTest"	"testGetRecentStorageVolumes"	""	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/storage/cts/StorageManagerTest.java"	""	"public void testGetRecentStorageVolumes() throws Exception {
        // At a minimum recent volumes should include current volumes
        final Set<String> currentNames = mStorageManager.getStorageVolumes().stream()
                .map((v) -> v.getMediaStoreVolumeName()).collect(Collectors.toSet());
        final Set<String> recentNames = mStorageManager.getRecentStorageVolumes().stream()
                .map((v) -> v.getMediaStoreVolumeName()).collect(Collectors.toSet());
        assertTrue(recentNames.containsAll(currentNames));
    }

    @AppModeFull(reason = ""Instant apps cannot access external storage"")"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.view.inputmethod.cts.util.TestUtils"	"isInteractive"	"CtsInputMethodTestCases"	"/home/gpoor/cts-12-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/util/TestUtils.java"	""	"public void test/*
 *.
 */

package android.view.inputmethod.cts.util;

import static com.android.compatibility.common.util.SystemUtil.runShellCommand;
import static com.android.compatibility.common.util.SystemUtil.runShellCommandOrThrow;
import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;

import static org.junit.Assert.assertFalse;

import android.app.Instrumentation;
import android.app.KeyguardManager;
import android.content.Context;
import android.os.PowerManager;
import android.view.KeyEvent;

import androidx.annotation.NonNull;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.CommonTestUtils;
import com.android.compatibility.common.util.SystemUtil;

import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.BooleanSupplier;
import java.util.function.Supplier;

public final class TestUtils {
    private static final long TIME_SLICE = 100;  // msec

    /**
     * Executes a call on the application's main thread, blocking until it is complete.
     *
     * <p>A simple wrapper for {@link Instrumentation#runOnMainSync(Runnable)}.</p>
     *
     * @param task task to be called on the UI thread
     */
    public static void runOnMainSync(@NonNull Runnable task) {
        InstrumentationRegistry.getInstrumentation().runOnMainSync(task);
    }

    /**
     * Retrieves a value that needs to be obtained on the main thread.
     *
     * <p>A simple utility method that helps to return an object from the UI thread.</p>
     *
     * @param supplier callback to be called on the UI thread to return a value
     * @param <T> Type of the value to be returned
     * @return Value returned from {@code supplier}
     */
    public static <T> T getOnMainSync(@NonNull Supplier<T> supplier) {
        final AtomicReference<T> result = new AtomicReference<>();
        final Instrumentation instrumentation = InstrumentationRegistry.getInstrumentation();
        instrumentation.runOnMainSync(() -> result.set(supplier.get()));
        return result.get();
    }

    /**
     * Does polling loop on the UI thread to wait until the given condition is met.
     *
     * @param condition Condition to be satisfied. This is guaranteed to run on the UI thread.
     * @param timeout timeout in millisecond
     * @param message message to display when timeout occurs.
     * @throws TimeoutException when the no event is matched to the given condition within
     *                          {@code timeout}
     */
    public static void waitOnMainUntil(
            @NonNull BooleanSupplier condition, long timeout, String message)
            throws TimeoutException {
        final AtomicBoolean result = new AtomicBoolean();

        final Instrumentation instrumentation = InstrumentationRegistry.getInstrumentation();
        while (!result.get()) {
            if (timeout < 0) {
                throw new TimeoutException(message);
            }
            instrumentation.runOnMainSync(() -> {
                if (condition.getAsBoolean()) {
                    result.set(true);
                }
            });
            try {
                Thread.sleep(TIME_SLICE);
            } catch (InterruptedException e) {
                throw new IllegalStateException(e);
            }
            timeout -= TIME_SLICE;
        }
    }

    /**
     * Does polling loop on the UI thread to wait until the given condition is met.
     *
     * @param condition Condition to be satisfied. This is guaranteed to run on the UI thread.
     * @param timeout timeout in millisecond
     * @throws TimeoutException when the no event is matched to the given condition within
     *                          {@code timeout}
     */
    public static void waitOnMainUntil(@NonNull BooleanSupplier condition, long timeout)
            throws TimeoutException {
        waitOnMainUntil(condition, timeout, """");
    }

    /**
     * Call a command to turn screen On.
     *
     * This method will wait until the power state is interactive with {@link
     * PowerManager#isInteractive()}.
     */
    public static void turnScreenOn() throws Exception {
        final Context context = InstrumentationRegistry.getInstrumentation().getContext();
        final PowerManager pm = context.getSystemService(PowerManager.class);
        runShellCommand(""input keyevent KEYCODE_WAKEUP"");
        CommonTestUtils.waitUntil(""Device does not wake up after 5 seconds"", 5,
                () -> pm != null && pm.isInteractive());
    }

    /**
     * Call a command to turn screen off.
     *
     * This method will wait until the power state is *NOT* interactive with
     * {@link PowerManager#isInteractive()}.
     * Note that {@link PowerManager#isInteractive()} may not return {@code true} when the device
     * enables Aod mode, recommend to add (@link DisableScreenDozeRule} in the test to disable Aod
     * for making power state reliable.
     */
    public static void turnScreenOff() throws Exception {
        final Context context = InstrumentationRegistry.getInstrumentation().getContext();
        final PowerManager pm = context.getSystemService(PowerManager.class);
        runShellCommand(""input keyevent KEYCODE_SLEEP"");
        CommonTestUtils.waitUntil(""Device does not sleep after 5 seconds"", 5,
                () -> pm != null && !pm.isInteractive());
    }

    /**
     * Simulates a {@link KeyEvent#KEYCODE_MENU} event to unlock screen.
     *
     * This method will retry until {@link KeyguardManager#isKeyguardLocked()} return {@code false}
     * in given timeout.
     *
     * Note that {@link KeyguardManager} is not accessible in instant mode due to security concern,
     * so this method always throw exception with instant app.
     */
    public static void unlockScreen() throws Exception {
        final Instrumentation instrumentation = InstrumentationRegistry.getInstrumentation();
        final Context context = instrumentation.getContext();
        final KeyguardManager kgm = context.getSystemService(KeyguardManager.class);

        assertFalse(""This method is currently not supported in instant apps."",
                context.getPackageManager().isInstantApp());
        CommonTestUtils.waitUntil(""Device does not unlock after 3 seconds"", 3,
                () -> {
                    SystemUtil.runWithShellPermissionIdentity(
                            () -> instrumentation.sendKeyDownUpSync((KeyEvent.KEYCODE_MENU)));
                    return kgm != null && !kgm.isKeyguardLocked();
                });
    }

    /**
     * Call a command to force stop the given application package.
     *
     * @param pkg The name of the package to be stopped.
     */
    public static void forceStopPackage(@NonNull String pkg) {
        runWithShellPermissionIdentity(() -> {
            runShellCommandOrThrow(""am force-stop "" + pkg);
        });
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.hardware.cts.CameraTest"	"TestShutterCallback"	"CtsCameraTestCases"	"/home/gpoor/cts-12-source/cts/tests/camera/src/android/hardware/cts/CameraTest.java"	""	"/*
 *.
 */

package android.hardware.cts;

import android.content.pm.PackageManager;
import android.graphics.BitmapFactory;
import android.graphics.ImageFormat;
import android.graphics.Rect;
import android.hardware.Camera;
import android.hardware.Camera.Area;
import android.hardware.Camera.CameraInfo;
import android.hardware.Camera.ErrorCallback;
import android.hardware.Camera.Face;
import android.hardware.Camera.FaceDetectionListener;
import android.hardware.Camera.Parameters;
import android.hardware.Camera.PictureCallback;
import android.hardware.Camera.ShutterCallback;
import android.hardware.Camera.Size;
import android.hardware.cts.helpers.CameraUtils;
import android.media.CamcorderProfile;
import android.media.ExifInterface;
import android.media.MediaRecorder;
import android.os.Build;
import android.os.ConditionVariable;
import android.os.Looper;
import android.os.SystemClock;
import android.test.MoreAsserts;
import android.test.UiThreadTest;
import android.test.suitebuilder.annotation.LargeTest;
import android.util.Log;
import android.view.SurfaceHolder;

import androidx.test.rule.ActivityTestRule;

import junit.framework.Assert;
import junit.framework.AssertionFailedError;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.text.ParseException;
import java.text.ParsePosition;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.TimeZone;

import com.android.compatibility.common.util.WindowUtil;

/**
 * This test case must run with hardware. It can't be tested in emulator
 */
@LargeTest
public class CameraTest extends Assert {
    private static final String TAG = ""CameraTest"";
    private static final String PACKAGE = ""android.hardware.cts"";
    private static final boolean VERBOSE = Log.isLoggable(TAG, Log.VERBOSE);
    private String mRecordingPath = null;
    private String mJpegPath = null;
    private byte[] mJpegData;

    private static final int PREVIEW_CALLBACK_NOT_RECEIVED = 0;
    private static final int PREVIEW_CALLBACK_RECEIVED = 1;
    private static final int PREVIEW_CALLBACK_DATA_NULL = 2;
    private static final int PREVIEW_CALLBACK_INVALID_FRAME_SIZE = 3;
    private int mPreviewCallbackResult = PREVIEW_CALLBACK_NOT_RECEIVED;

    private boolean mShutterCallbackResult = false;
    private boolean mRawPictureCallbackResult = false;
    private boolean mJpegPictureCallbackResult = false;
    private static final int NO_ERROR = -1;
    private int mCameraErrorCode = NO_ERROR;
    private boolean mAutoFocusSucceeded = false;

    private static final int WAIT_FOR_COMMAND_TO_COMPLETE = 5000;  // Milliseconds.
    private static final int WAIT_FOR_FOCUS_TO_COMPLETE = 5000;
    private static final int WAIT_FOR_SNAPSHOT_TO_COMPLETE = 5000;

    private static final int FOCUS_AREA = 0;
    private static final int METERING_AREA = 1;

    private static final int AUTOEXPOSURE_LOCK = 0;
    private static final int AUTOWHITEBALANCE_LOCK = 1;

    // For external camera recording
    private static final int VIDEO_BIT_RATE_IN_BPS = 128000;

    // Some exif tags that are not defined by ExifInterface but supported.
    private static final String TAG_DATETIME_DIGITIZED = ""DateTimeDigitized"";
    private static final String TAG_SUBSEC_TIME = ""SubSecTime"";
    private static final String TAG_SUBSEC_TIME_ORIG = ""SubSecTimeOriginal"";
    private static final String TAG_SUBSEC_TIME_DIG = ""SubSecTimeDigitized"";

    private PreviewCallback mPreviewCallback = new PreviewCallback();
    private TestShutterCallback mShutterCallback = new TestShutterCallback();
    private RawPictureCallback mRawPictureCallback = new RawPictureCallback();
    private JpegPictureCallback mJpegPictureCallback = new JpegPictureCallback();
    private TestErrorCallback mErrorCallback = new TestErrorCallback();
    private AutoFocusCallback mAutoFocusCallback = new AutoFocusCallback();
    private AutoFocusMoveCallback mAutoFocusMoveCallback = new AutoFocusMoveCallback();

    private Looper mLooper = null;
    private final ConditionVariable mPreviewDone = new ConditionVariable();
    private final ConditionVariable mFocusDone = new ConditionVariable();
    private final ConditionVariable mSnapshotDone = new ConditionVariable();
    private int[] mCameraIds;

    Camera mCamera;
    boolean mIsExternalCamera;

    @Rule
    public ActivityTestRule<CameraCtsActivity> mActivityRule =
            new ActivityTestRule<>(CameraCtsActivity.class);

    @Before
    public void setUp() throws Exception {
        // Some of the tests run on the UI thread. In case some of the operations take a long time to complete,
        // wait for window to receive focus. This ensure that the focus event from input flinger has been handled,
        // and avoids getting ANR.
        WindowUtil.waitForFocus(mActivityRule.getActivity());
        mCameraIds = CameraUtils.deriveCameraIdsUnderTest();
    }

    @After
    public void tearDown() throws Exception {
        if (mCamera != null) {
            mCamera.release();
            mCamera = null;
        }
    }

    /*
     * Initializes the message looper so that the Camera object can
     * receive the callback messages.
     */
    private void initializeMessageLooper(final int cameraId) throws IOException {
        LooperInfo looperInfo = new LooperInfo();
        initializeMessageLooper(cameraId, mErrorCallback, looperInfo);
        mIsExternalCamera = looperInfo.isExternalCamera;
        mCamera = looperInfo.camera;
        mLooper = looperInfo.looper;
    }

    private final class LooperInfo {
        Camera camera = null;
        Looper looper = null;
        boolean isExternalCamera = false;
    };

    /*
     * Initializes the message looper so that the Camera object can
     * receive the callback messages.
     */
    private void initializeMessageLooper(final int cameraId, final ErrorCallback errorCallback,
            LooperInfo looperInfo) throws IOException {
        final ConditionVariable startDone = new ConditionVariable();
        final CameraCtsActivity activity = mActivityRule.getActivity();
        new Thread() {
            @Override
            public void run() {
                Log.v(TAG, ""start loopRun for cameraId "" + cameraId);
                // Set up a looper to be used by camera.
                Looper.prepare();
                // Save the looper so that we can terminate this thread
                // after we are done with it.
                looperInfo.looper = Looper.myLooper();
                try {
                    looperInfo.isExternalCamera = CameraUtils.isExternal(
                            activity.getApplicationContext(), cameraId);
                } catch (Exception e) {
                    Log.e(TAG, ""Unable to query external camera!"" + e);
                }

                try {
                    looperInfo.camera = Camera.open(cameraId);
                    looperInfo.camera.setErrorCallback(errorCallback);
                } catch (RuntimeException e) {
                    Log.e(TAG, ""Fail to open camera id "" + cameraId + "": "" + e);
                }
                Log.v(TAG, ""camera"" + cameraId + "" is opened"");
                startDone.open();
                Looper.loop(); // Blocks forever until Looper.quit() is called.
                if (VERBOSE) Log.v(TAG, ""initializeMessageLooper: quit."");
            }
        }.start();

        Log.v(TAG, ""start waiting for looper"");
        if (!startDone.block(WAIT_FOR_COMMAND_TO_COMPLETE)) {
            Log.v(TAG, ""initializeMessageLooper: start timeout"");
            fail(""initializeMessageLooper: start timeout"");
        }
        assertNotNull(""Fail to open camera "" + cameraId, looperInfo.camera);
        looperInfo.camera.setPreviewDisplay(activity.getSurfaceView().getHolder());
        File parent = activity.getPackageManager().isInstantApp()
                ? activity.getFilesDir()
                : activity.getExternalFilesDir(null);

        mJpegPath = parent.getPath() + ""/test.jpg"";
        mRecordingPath = parent.getPath() + ""/test_video.mp4"";
    }

    /*
     * Terminates the message looper thread.
     */
    private void terminateMessageLooper() throws Exception {
        terminateMessageLooper(false);
    }

    /*
     * Terminates the message looper thread, optionally allowing evict error
     */
    private void terminateMessageLooper(boolean allowEvict) throws Exception {
        LooperInfo looperInfo = new LooperInfo();
        looperInfo.camera = mCamera;
        looperInfo.looper = mLooper;
        terminateMessageLooper(allowEvict, mCameraErrorCode, looperInfo);
        mCamera = null;
    }

    /*
     * Terminates the message looper thread, optionally allowing evict error
     */
    private void terminateMessageLooper(final boolean allowEvict, final int errorCode,
            final LooperInfo looperInfo) throws Exception {
        looperInfo.looper.quit();
        // Looper.quit() is asynchronous. The looper may still has some
        // preview callbacks in the queue after quit is called. The preview
        // callback still uses the camera object (setHasPreviewCallback).
        // After camera is released, RuntimeException will be thrown from
        // the method. So we need to join the looper thread here.
        looperInfo.looper.getThread().join();
        looperInfo.camera.release();
        looperInfo.camera = null;
        if (allowEvict) {
            assertTrue(""Got unexpected camera error callback."",
                    (NO_ERROR == errorCode ||
                    Camera.CAMERA_ERROR_EVICTED == errorCode));
        } else {
            assertEquals(""Got camera error callback."", NO_ERROR, errorCode);
        }
    }

    // Align 'x' to 'to', which should be a power of 2
    private static int align(int x, int to) {
        return (x + (to-1)) & ~(to - 1);
    }
    private static int calculateBufferSize(int width, int height,
                                           int format, int bpp) {

        if (VERBOSE) {
            Log.v(TAG, ""calculateBufferSize: w="" + width + "",h="" + height
            + "",f="" + format + "",bpp="" + bpp);
        }

        if (format == ImageFormat.YV12) {
            /*
            http://developer.android.com/reference/android/graphics/ImageFormat.html#YV12
            */

            int stride = align(width, 16);

            int y_size = stride * height;
            int c_stride = align(stride/2, 16);
            int c_size = c_stride * height/2;
            int size = y_size + c_size * 2;

            if (VERBOSE) {
                Log.v(TAG, ""calculateBufferSize: YV12 size= "" + size);
            }

            return size;

        }
        else {
            return width * height * bpp / 8;
        }
    }

    //Implement the previewCallback
    private final class PreviewCallback
            implements android.hardware.Camera.PreviewCallback {
        public void onPreviewFrame(byte [] data, Camera camera) {
            if (data == null) {
                mPreviewCallbackResult = PREVIEW_CALLBACK_DATA_NULL;
                mPreviewDone.open();
                return;
            }
            Size size = camera.getParameters().getPreviewSize();
            int format = camera.getParameters().getPreviewFormat();
            int bitsPerPixel = ImageFormat.getBitsPerPixel(format);
            if (calculateBufferSize(size.width, size.height,
                    format, bitsPerPixel) != data.length) {
                Log.e(TAG, ""Invalid frame size "" + data.length + "". width="" + size.width
                        + "". height="" + size.height + "". bitsPerPixel="" + bitsPerPixel);
                mPreviewCallbackResult = PREVIEW_CALLBACK_INVALID_FRAME_SIZE;
                mPreviewDone.open();
                return;
            }
            mPreviewCallbackResult = PREVIEW_CALLBACK_RECEIVED;
            mCamera.stopPreview();
            if (VERBOSE) Log.v(TAG, ""notify the preview callback"");
            mPreviewDone.open();
            if (VERBOSE) Log.v(TAG, ""Preview callback stop"");
        }
    }

    //Implement the shutterCallback
    private final class TestShutterCallback implements ShutterCallback {
        public void onShutter() {
            mShutterCallbackResult = true;
            if (VERBOSE) Log.v(TAG, ""onShutter called"");
        }
    }

    //Implement the RawPictureCallback
    private final class RawPictureCallback implements PictureCallback {
        public void onPictureTaken(byte [] rawData, Camera camera) {
            mRawPictureCallbackResult = true;
            if (VERBOSE) Log.v(TAG, ""RawPictureCallback callback"");
        }
    }

    // Implement the JpegPictureCallback
    private final class JpegPictureCallback implements PictureCallback {
        public void onPictureTaken(byte[] rawData, Camera camera) {
            try {
                mJpegData = rawData;
                if (rawData != null) {
                    // try to store the picture on the SD card
                    File rawoutput = new File(mJpegPath);
                    FileOutputStream outStream = new FileOutputStream(rawoutput);
                    outStream.write(rawData);
                    outStream.close();
                    mJpegPictureCallbackResult = true;

                    if (VERBOSE) {
                        Log.v(TAG, ""JpegPictureCallback rawDataLength = "" + rawData.length);
                    }
                } else {
                    mJpegPictureCallbackResult = false;
                }
                mSnapshotDone.open();
                if (VERBOSE) Log.v(TAG, ""Jpeg Picture callback"");
            } catch (IOException e) {
                // no need to fail here; callback worked fine
                Log.w(TAG, ""Error writing picture to sd card."");
            }
        }
    }

    // Implement the ErrorCallback
    private final class TestErrorCallback implements ErrorCallback {
        public void onError(int error, Camera camera) {
            Log.e(TAG, ""Got camera error="" + error);
            mCameraErrorCode = error;
        }
    }

    // parent independent version of TestErrorCallback
    private static final class TestErrorCallbackI implements ErrorCallback {
        private int mCameraErrorCode = NO_ERROR;
        public void onError(int error, Camera camera) {
            Log.e(TAG, ""Got camera error="" + error);
            mCameraErrorCode = error;
        }
    }

    private final class AutoFocusCallback
            implements android.hardware.Camera.AutoFocusCallback {
        public void onAutoFocus(boolean success, Camera camera) {
            mAutoFocusSucceeded = success;
            Log.v(TAG, ""AutoFocusCallback success="" + success);
            mFocusDone.open();
        }
    }

    private final class AutoFocusMoveCallback
            implements android.hardware.Camera.AutoFocusMoveCallback {
        @Override
        public void onAutoFocusMoving(boolean start, Camera camera) {
        }
    }

    private void waitForPreviewDone() {
        if (VERBOSE) Log.v(TAG, ""Wait for preview callback"");
        if (!mPreviewDone.block(WAIT_FOR_COMMAND_TO_COMPLETE)) {
            // timeout could be expected or unexpected. The caller will decide.
            Log.v(TAG, ""waitForPreviewDone: timeout"");
        }
        mPreviewDone.close();
    }

    private boolean waitForFocusDone() {
        boolean result = mFocusDone.block(WAIT_FOR_FOCUS_TO_COMPLETE);
        if (!result) {
            // timeout could be expected or unexpected. The caller will decide.
            Log.v(TAG, ""waitForFocusDone: timeout"");
        }
        mFocusDone.close();
        return result;
    }

    private void waitForSnapshotDone() {
        if (!mSnapshotDone.block(WAIT_FOR_SNAPSHOT_TO_COMPLETE)) {
            // timeout could be expected or unexpected. The caller will decide.
            Log.v(TAG, ""waitForSnapshotDone: timeout"");
        }
        mSnapshotDone.close();
    }

    private void checkPreviewCallback() throws Exception {
        if (VERBOSE) Log.v(TAG, ""check preview callback"");
        mCamera.startPreview();
        waitForPreviewDone();
        mCamera.setPreviewCallback(null);
    }

    /**
     * Start preview and wait for the first preview callback, which indicates the
     * preview becomes active.
     */
    private void blockingStartPreview() {
        mCamera.setPreviewCallback(new SimplePreviewStreamCb(/*Id*/0));
        mCamera.startPreview();
        waitForPreviewDone();
        mCamera.setPreviewCallback(null);
    }

    /*
     * Test case 1: Take a picture and verify all the callback
     * functions are called properly.
     */
    @UiThreadTest"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.content.pm.cts.shortcutmanager.ShortcutManagerStartShortcutTest"	"testStartMultiple"	"CtsShortcutManagerTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/shortcutmanager/src/android/content/pm/cts/shortcutmanager/ShortcutManagerStartShortcutTest.java"	""	"public void testStartMultiple() {
        if (mOnWatch) {
            return; // b/109678268
        }
        setDefaultLauncher(getInstrumentation(), mLauncherContext1);

        Intent i1 = new Intent(""a1"")
                .setComponent(mLaunchedActivity)
                .setFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION)
                .putExtra(""k1"", ""v1"");
        Intent i2 = new Intent(""a2"")
                .setComponent(mLaunchedActivity)
                .setFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
        Intent i3 = new Intent(""a3"")
                .setComponent(mLaunchedActivity)
                .putExtra(""kx"", ""vx"");

        runWithCallerWithStrictMode(mPackageContext1, () -> {
            assertTrue(getManager().addDynamicShortcuts(list(
                    makeShortcutBuilder(""s1"").setShortLabel(""abc"")
                            .setIntents(new Intent[]{i1, i2, i3}).build()
                    )));
        });

        List<Intent> launched = launchShortcutAndGetIntents(mLauncherContext1, mPackageContext1,
                ""s1"", 3, EXPECTED_ACTIONS_MULTI);
        assertEquals(3, launched.size());

        Intent i = launched.get(2);
        assertEquals(""a1"", i.getAction());
        assertTrue((i.getFlags() & Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0);
        assertTrue((i.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == 0);
        assertEquals(""v1"", i.getStringExtra(""k1""));

        i = launched.get(1);
        assertEquals(""a2"", i.getAction());
        assertTrue((i.getFlags() & Intent.FLAG_ACTIVITY_NO_ANIMATION) == 0);
        assertTrue((i.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) != 0);
        assertEquals(null, i.getExtras());

        i = launched.get(0);
        assertEquals(""a3"", i.getAction());
        assertTrue((i.getFlags() & Intent.FLAG_ACTIVITY_NO_ANIMATION) == 0);
        assertTrue((i.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == 0);
        assertEquals(""vx"", i.getStringExtra(""kx""));
    }

    /**
     * Non default launcher can't start.
     */"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.instantapps.BaseTestActivity"	"setPassFailButtonClickListeners"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/instantapps/BaseTestActivity.java"	""	"public void test/*
 *.
 */
package com.android.cts.verifier.instantapps;

import android.app.AlertDialog;
import android.content.ActivityNotFoundException;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.net.Uri;
import android.util.Log;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.ImageButton;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

/**
 * Base {@link Activity} class for testing Instant Apps System UIs.
 */
public abstract class BaseTestActivity extends PassFailButtons.Activity
        implements OnClickListener {

    private static final String TAG = ""InstantApps"";
    private static final String APP_URL = ""https://source.android.com"";
    private static final String APP_PACKAGE = ""com.android.cts.instantapp"";

    private ImageButton mPassButton;
    private ImageButton mFailButton;
    private Button mStartTestButton;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.instant_apps);
        setPassFailButtonClickListeners();

        mPassButton = (ImageButton) findViewById(R.id.pass_button);
        mFailButton = (ImageButton) findViewById(R.id.fail_button);
        mStartTestButton = (Button) findViewById(R.id.start_test_button);
        mStartTestButton.setOnClickListener(this);

        resetButtons();

        mStartTestButton.setEnabled(true);
    }

    @Override
    public void onClick(View view) {
        if (view != mStartTestButton) return;

        Log.v(TAG, ""Start Test button clicked"");
        try {
          Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(APP_URL));
          intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
          intent.addCategory(Intent.CATEGORY_BROWSABLE);
          intent.setPackage(APP_PACKAGE);
          startActivity(intent);

          mStartTestButton.setEnabled(false);
          enablePassFailButtons(true);
        } catch (ActivityNotFoundException e) {
          // Use ActivityNotFoundException as an indicator that Instant App is
          // not installed.
          Log.v(TAG, ""Instant App not installed."");

          // Display alert dialog with instruction for installing the Instant App.
          new AlertDialog.Builder(
              BaseTestActivity.this)
                  .setIcon(android.R.drawable.ic_dialog_info)
                  .setTitle(R.string.ia_install_dialog_title)
                  .setMessage(R.string.ia_install_dialog_text)
                  .setPositiveButton(android.R.string.ok, null)
                  .show();
        }
    }

    private void resetButtons() {
        enablePassFailButtons(false);
    }

    private void enablePassFailButtons(boolean enable) {
        mPassButton.setEnabled(enable);
        mFailButton.setEnabled(enable);
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.app.usage.cts.UsageStatsTest"	"testInstantAppUsageEventsObfuscated"	"CtsUsageStatsTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	"public void testInstantAppUsageEventsObfuscated() throws Exception {
        @SuppressWarnings(""unchecked"")
        final Class<? extends Activity>[] activitySequence = new Class[] {
                Activities.ActivityOne.class,
                Activities.ActivityTwo.class,
                Activities.ActivityThree.class,
        };
        mUiDevice.wakeUp();
        mUiDevice.pressHome();

        final long startTime = System.currentTimeMillis();
        // Launch the series of Activities.
        launchSubActivities(activitySequence);
        SystemClock.sleep(250);

        final long endTime = System.currentTimeMillis();
        final UsageEvents events = mUsageStatsManager.queryEvents(startTime, endTime);

        int resumes = 0;
        int pauses = 0;
        int stops = 0;

        // Only look at events belongs to mTargetPackage.
        while (events.hasNextEvent()) {
            final UsageEvents.Event event = new UsageEvents.Event();
            assertTrue(events.getNextEvent(event));
            // There should be no events with this packages name
            assertNotEquals(""Instant app package name found in usage event list"",
                    mTargetPackage, event.getPackageName());

            // Look for the obfuscated instant app string instead
            if(UsageEvents.INSTANT_APP_PACKAGE_NAME.equals(event.getPackageName())) {
                switch (event.mEventType) {
                    case Event.ACTIVITY_RESUMED:
                        resumes++;
                        break;
                    case Event.ACTIVITY_PAUSED:
                        pauses++;
                        break;
                    case Event.ACTIVITY_STOPPED:
                        stops++;
                        break;
                }
            }
        }
        assertEquals(""Unexpected number of activity resumes"", 3, resumes);
        assertEquals(""Unexpected number of activity pauses"", 2, pauses);
        assertEquals(""Unexpected number of activity stops"", 2, stops);
    }

    @AppModeFull(reason = ""No usage events access in instant apps"")"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.server.wm.StartActivityTests"	"testNormalActivityCanNotSetActivityType"	"CtsWindowManagerDeviceTestCases"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/StartActivityTests.java"	""	"public void testNormalActivityCanNotSetActivityType() {
        // Activities should not be started if the launch activity type is set.
        boolean useShellPermission = false;
        startingActivityWithType(ACTIVITY_TYPE_STANDARD, useShellPermission);
        startingActivityWithType(ACTIVITY_TYPE_HOME, useShellPermission);
        startingActivityWithType(ACTIVITY_TYPE_RECENTS, useShellPermission);
        startingActivityWithType(ACTIVITY_TYPE_ASSISTANT, useShellPermission);
        startingActivityWithType(ACTIVITY_TYPE_DREAM, useShellPermission);

        // Activities can be started because they are started with shell permissions.
        useShellPermission = true;
        startingActivityWithType(ACTIVITY_TYPE_STANDARD, useShellPermission);
        startingActivityWithType(ACTIVITY_TYPE_HOME, useShellPermission);
        startingActivityWithType(ACTIVITY_TYPE_RECENTS, useShellPermission);
        startingActivityWithType(ACTIVITY_TYPE_ASSISTANT, useShellPermission);
        startingActivityWithType(ACTIVITY_TYPE_DREAM, useShellPermission);
    }

    private void startingActivityWithType(int type, boolean useShellPermission) {
        separateTestJournal();
        getLaunchActivityBuilder()
                .setTargetActivity(BROADCAST_RECEIVER_ACTIVITY)
                .setUseInstrumentation()
                .setWithShellPermission(useShellPermission)
                .setActivityType(type)
                .setWaitForLaunched(false)
                .setMultipleTask(true)
                .execute();

        mWmState.computeState();
        if (useShellPermission) {
            waitAndAssertResumedActivity(BROADCAST_RECEIVER_ACTIVITY,
                    ""Activity should be started and resumed"");
            mWmState.assertFrontStackActivityType(""The activity type should be same as requested."",
                    type);
            mBroadcastActionTrigger.finishBroadcastReceiverActivity();
            mWmState.waitAndAssertActivityRemoved(BROADCAST_RECEIVER_ACTIVITY);
        } else {
            assertSecurityExceptionFromActivityLauncher();
        }
    }

    /**
     * Assume there are 3 activities (A1, A2, B1) with default launch mode. The uid of B1 is
     * different from A1 and A2. After A1 called {@link Activity#startActivities} to start B1 and
     * A2, the result should be 3 tasks.
     */"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.appstart.AppStartStatsTests"	"testAppStartOccurred"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/appstart/AppStartStatsTests.java"	""	"public void testAppStartOccurred() throws Exception {
        final int atomTag = AtomsProto.Atom.APP_START_OCCURRED_FIELD_NUMBER;
        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomTag,  /*uidInAttributionChain=*/false);
        getDevice().executeShellCommand(getGlobalHibernationCommand(
                DeviceUtils.STATSD_ATOM_TEST_PKG, false));

        DeviceUtils.runActivity(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                STATSD_CTS_FOREGROUND_ACTIVITY, ""action"", ""action.sleep_top"", WAIT_TIME_MS);

        // Sorted list of events in order in which they occurred.
        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());

        assertThat(data).hasSize(1);
        AtomsProto.AppStartOccurred atom = data.get(0).getAtom().getAppStartOccurred();
        assertThat(atom.getPkgName()).isEqualTo(DeviceUtils.STATSD_ATOM_TEST_PKG);
        assertThat(atom.getActivityName())
                .isEqualTo(""com.android.server.cts.device.statsdatom.StatsdCtsForegroundActivity"");
        assertThat(atom.getIsInstantApp()).isFalse();
        assertThat(atom.getActivityStartTimestampMillis()).isGreaterThan(0L);
        assertThat(atom.getTransitionDelayMillis()).isGreaterThan(0);
        assertThat(atom.getIsHibernating()).isFalse();
    }"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.managedprovisioning.IntermediateRecentActivity"	"finish"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/managedprovisioning/IntermediateRecentActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.managedprovisioning;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;

/**
 * Handles com.android.cts.verifier.managedprovisioning.RECENTS intent sent
 * from main profile to work profile.
 *
 * {@link RecentsRedactionActivity} is required to stay in Recents to complete
 * ""Recent Redaction Test"". However a {@link Intent#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS} will be
 * added by framework when intent {@link RecentsRedactionActivity#ACTION_RECENTS} is sent from
 * personal profile to work profile. By adding this {@link IntermediateRecentActivity} and
 * let it hanlde {@link RecentsRedactionActivity#ACTION_RECENTS} and then start
 * {@link IntermediateRecentActivity} in a new task, we can make sure no
 * {@link Intent#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS} is added for starting
 * {@link IntermediateRecentActivity}.
 */
public class IntermediateRecentActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        startActivity(new Intent(this, RecentsRedactionActivity.class).addFlags(
                Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_MULTIPLE_TASK));
        finish();
    }
}"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.hardware.camera2.cts.testcases.Camera2SurfaceViewTestCase"	"isInstantApp"	"CtsCameraTestCases"	"/home/gpoor/cts-12-source/cts/tests/camera/src/android/hardware/camera2/cts/testcases/Camera2SurfaceViewTestCase.java"	""	"public void test/*
 *.
 */

package android.hardware.camera2.cts.testcases;

import static android.hardware.camera2.cts.CameraTestUtils.*;

import static com.android.ex.camera2.blocking.BlockingStateCallback.STATE_CLOSED;
import androidx.test.InstrumentationRegistry;
import android.app.UiAutomation;

import android.content.Context;
import android.graphics.ImageFormat;
import android.hardware.camera2.CameraAccessException;
import android.hardware.camera2.CameraCaptureSession;
import android.hardware.camera2.CameraCaptureSession.CaptureCallback;
import android.hardware.camera2.CameraCharacteristics;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CameraManager;
import android.hardware.camera2.CameraMetadata;
import android.hardware.camera2.CaptureRequest;
import android.hardware.camera2.CaptureResult;
import android.hardware.camera2.cts.Camera2SurfaceViewCtsActivity;
import android.hardware.camera2.cts.Camera2ParameterizedTestCase;
import android.hardware.camera2.cts.CameraTestUtils;
import android.hardware.camera2.cts.CameraTestUtils.SimpleCaptureCallback;
import android.hardware.camera2.cts.helpers.CameraErrorCollector;
import android.hardware.camera2.cts.helpers.StaticMetadata;
import android.hardware.camera2.cts.helpers.StaticMetadata.CheckLevel;
import android.media.ImageReader;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Looper;
import android.util.Log;
import android.util.Range;
import android.util.Size;
import android.view.Surface;
import android.view.SurfaceHolder;
import android.view.View;
import android.view.WindowManager;

import androidx.test.rule.ActivityTestRule;

import com.android.ex.camera2.blocking.BlockingSessionCallback;
import com.android.ex.camera2.blocking.BlockingStateCallback;
import com.android.ex.camera2.exceptions.TimeoutRuntimeException;

import org.junit.After;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Rule;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameter;
import org.junit.runners.Parameterized.Parameters;


/**
 * Camera2 Preview test case base class by using SurfaceView as rendering target.
 *
 * <p>This class encapsulates the SurfaceView based preview common functionalities.
 * The setup and teardown of CameraManager, test HandlerThread, Activity, Camera IDs
 * and CameraStateCallback are handled in this class. Some basic preview related utility
 * functions are provided to facilitate the derived preview-based test classes.
 * </p>
 */

public class Camera2SurfaceViewTestCase extends Camera2ParameterizedTestCase {
    private static final String TAG = ""SurfaceViewTestCase"";
    private static final boolean VERBOSE = Log.isLoggable(TAG, Log.VERBOSE);
    private static final int WAIT_FOR_SURFACE_CHANGE_TIMEOUT_MS = 1000;

    protected static final int WAIT_FOR_RESULT_TIMEOUT_MS = 3000;
    protected static final float FRAME_DURATION_ERROR_MARGIN = 0.01f; // 1 percent error margin.
    protected static final int NUM_RESULTS_WAIT_TIMEOUT = 100;
    protected static final int NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY = 8;
    protected static final int MIN_FRAME_DURATION_ERROR_MARGIN = 100; // ns

    protected HandlerThread mHandlerThread;
    protected Handler mHandler;
    protected BlockingStateCallback mCameraListener;
    protected BlockingSessionCallback mSessionListener;
    protected CameraErrorCollector mCollector;
    protected HashMap<String, StaticMetadata> mAllStaticInfo;
    // Per device fields:
    protected StaticMetadata mStaticInfo;
    protected CameraDevice mCamera;
    protected CameraCaptureSession mSession;
    protected ImageReader mReader;
    protected Surface mReaderSurface;
    protected Surface mPreviewSurface;
    protected SurfaceHolder mPreviewHolder;
    protected Size mPreviewSize;
    protected List<Size> mOrderedPreviewSizes; // In descending order.
    protected List<Size> m1080pBoundedOrderedPreviewSizes; // In descending order.
    protected List<Size> mOrderedVideoSizes; // In descending order.
    protected List<Size> mOrderedStillSizes; // In descending order.
    protected HashMap<Size, Long> mMinPreviewFrameDurationMap;
    protected String mDebugFileNameBase;

    protected WindowManager mWindowManager;

    @Rule
    public ActivityTestRule<Camera2SurfaceViewCtsActivity> mActivityRule =
            new ActivityTestRule<>(Camera2SurfaceViewCtsActivity.class);

    @Before
    public void setUp() throws Exception {
        super.setUp();
        mHandlerThread = new HandlerThread(TAG);
        mHandlerThread.start();
        mHandler = new Handler(mHandlerThread.getLooper());
        mCameraListener = new BlockingStateCallback();
        mCollector = new CameraErrorCollector();

        File filesDir = mContext.getPackageManager().isInstantApp()
                ? mContext.getFilesDir()
                : mContext.getExternalFilesDir(null);

        mDebugFileNameBase = filesDir.getPath();

        mAllStaticInfo = new HashMap<String, StaticMetadata>();
        List<String> hiddenPhysicalIds = new ArrayList<>();
        for (String cameraId : mCameraIdsUnderTest) {
            CameraCharacteristics props = mCameraManager.getCameraCharacteristics(cameraId);
            StaticMetadata staticMetadata = new StaticMetadata(props,
                    CheckLevel.ASSERT, /*collector*/null);
            mAllStaticInfo.put(cameraId, staticMetadata);

            for (String physicalId : props.getPhysicalCameraIds()) {
                if (!Arrays.asList(mCameraIdsUnderTest).contains(physicalId) &&
                        !hiddenPhysicalIds.contains(physicalId)) {
                    hiddenPhysicalIds.add(physicalId);
                    props = mCameraManager.getCameraCharacteristics(physicalId);
                    staticMetadata = new StaticMetadata(
                            mCameraManager.getCameraCharacteristics(physicalId),
                            CheckLevel.ASSERT, /*collector*/null);
                    mAllStaticInfo.put(physicalId, staticMetadata);
                }
            }
        }

        mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
    }

    @After
    public void tearDown() throws Exception {
        mHandlerThread.quitSafely();
        mHandler = null;
        mCameraListener = null;

        try {
            mCollector.verify();
        } catch (Throwable e) {
            // When new Exception(e) is used, exception info will be printed twice.
            throw new Exception(e.getMessage());
        }
        super.tearDown();
    }

    /**
     * Start camera preview by using the given request, preview size and capture
     * listener.
     * <p>
     * If preview is already started, calling this function will stop the
     * current preview stream and start a new preview stream with given
     * parameters. No need to call stopPreview between two startPreview calls.
     * </p>
     *
     * @param request The request builder used to start the preview.
     * @param previewSz The size of the camera device output preview stream.
     * @param listener The callbacks the camera device will notify when preview
     *            capture is available.
     */
    protected void startPreview(CaptureRequest.Builder request, Size previewSz,
            CaptureCallback listener) throws Exception {
        // Update preview size.
        updatePreviewSurface(previewSz);
        if (VERBOSE) {
            Log.v(TAG, ""start preview with size "" + mPreviewSize.toString());
        }

        configurePreviewOutput(request);

        mSession.setRepeatingRequest(request.build(), listener, mHandler);
    }

    /**
     * Configure the preview output stream.
     *
     * @param request The request to be configured with preview surface
     */
    protected void configurePreviewOutput(CaptureRequest.Builder request)
            throws CameraAccessException {
        List<Surface> outputSurfaces = new ArrayList<Surface>(/*capacity*/1);
        outputSurfaces.add(mPreviewSurface);
        mSessionListener = new BlockingSessionCallback();
        mSession = configureCameraSession(mCamera, outputSurfaces, mSessionListener, mHandler);

        request.addTarget(mPreviewSurface);
    }

    /**
     * Create a {@link CaptureRequest#Builder} and add the default preview surface.
     *
     * @return The {@link CaptureRequest#Builder} to be created
     * @throws CameraAccessException When create capture request from camera fails
     */
    protected CaptureRequest.Builder createRequestForPreview() throws CameraAccessException {
        if (mPreviewSurface == null) {
            throw new IllegalStateException(
                    ""Preview surface is not set yet, call updatePreviewSurface or startPreview""
                    + ""first to set the preview surface properly."");
        }
        CaptureRequest.Builder requestBuilder =
                mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
        requestBuilder.addTarget(mPreviewSurface);
        return requestBuilder;
    }

    /**
     * Stop preview for current camera device by closing the session.
     * Does _not_ wait for the device to go idle
     */
    protected void stopPreview() throws Exception {
        // Stop repeat, wait for captures to complete, and disconnect from surfaces
        if (mSession != null) {
            if (VERBOSE) Log.v(TAG, ""Stopping preview"");
            mSession.close();
        }
    }

    /**
     * Stop preview for current camera device by closing the session and waiting for it to close,
     * resulting in an idle device.
     */
    protected void stopPreviewAndDrain() throws Exception {
        // Stop repeat, wait for captures to complete, and disconnect from surfaces
        if (mSession != null) {
            if (VERBOSE) Log.v(TAG, ""Stopping preview and waiting for idle"");
            mSession.close();
            mSessionListener.getStateWaiter().waitForState(BlockingSessionCallback.SESSION_CLOSED,
                    /*timeoutMs*/WAIT_FOR_RESULT_TIMEOUT_MS);
        }
    }

    /**
     * Setup still (JPEG) capture configuration and start preview.
     * <p>
     * The default max number of image is set to image reader.
     * </p>
     *
     * @param previewRequest The capture request to be used for preview
     * @param stillRequest The capture request to be used for still capture
     * @param previewSz Preview size
     * @param stillSz The still capture size
     * @param resultListener Capture result listener
     * @param imageListener The still capture image listener
     */
    protected void prepareStillCaptureAndStartPreview(CaptureRequest.Builder previewRequest,
            CaptureRequest.Builder stillRequest, Size previewSz, Size stillSz,
            CaptureCallback resultListener,
            ImageReader.OnImageAvailableListener imageListener, boolean isHeic) throws Exception {
        prepareCaptureAndStartPreview(previewRequest, stillRequest, previewSz, stillSz,
                isHeic ? ImageFormat.HEIC : ImageFormat.JPEG, resultListener, MAX_READER_IMAGES,
                imageListener);
    }

    /**
     * Setup still (JPEG) capture configuration and start preview.
     *
     * @param previewRequest The capture request to be used for preview
     * @param stillRequest The capture request to be used for still capture
     * @param previewSz Preview size
     * @param stillSz The still capture size
     * @param resultListener Capture result listener
     * @param maxNumImages The max number of images set to the image reader
     * @param imageListener The still capture image listener
     */
    protected void prepareStillCaptureAndStartPreview(CaptureRequest.Builder previewRequest,
            CaptureRequest.Builder stillRequest, Size previewSz, Size stillSz,
            CaptureCallback resultListener, int maxNumImages,
            ImageReader.OnImageAvailableListener imageListener, boolean isHeic) throws Exception {
        prepareCaptureAndStartPreview(previewRequest, stillRequest, previewSz, stillSz,
                isHeic ? ImageFormat.HEIC : ImageFormat.JPEG, resultListener, maxNumImages, imageListener);
    }

    /**
     * Setup raw capture configuration and start preview.
     *
     * <p>
     * The default max number of image is set to image reader.
     * </p>
     *
     * @param previewRequest The capture request to be used for preview
     * @param rawRequest The capture request to be used for raw capture
     * @param previewSz Preview size
     * @param rawSz The raw capture size
     * @param resultListener Capture result listener
     * @param imageListener The raw capture image listener
     */
    protected void prepareRawCaptureAndStartPreview(CaptureRequest.Builder previewRequest,
            CaptureRequest.Builder rawRequest, Size previewSz, Size rawSz,
            CaptureCallback resultListener,
            ImageReader.OnImageAvailableListener imageListener) throws Exception {
        prepareCaptureAndStartPreview(previewRequest, rawRequest, previewSz, rawSz,
                ImageFormat.RAW_SENSOR, resultListener, MAX_READER_IMAGES, imageListener);
    }

    /**
     * Wait for expected result key value available in a certain number of results.
     *
     * <p>
     * Check the result immediately if numFramesWait is 0.
     * </p>
     *
     * @param listener The capture listener to get capture result
     * @param resultKey The capture result key associated with the result value
     * @param expectedValue The result value need to be waited for
     * @param numResultsWait Number of frame to wait before times out
     * @throws TimeoutRuntimeException If more than numResultsWait results are
     * seen before the result matching myRequest arrives, or each individual wait
     * for result times out after {@value #WAIT_FOR_RESULT_TIMEOUT_MS}ms.
     */
    protected static <T> void waitForResultValue(SimpleCaptureCallback listener,
            CaptureResult.Key<T> resultKey,
            T expectedValue, int numResultsWait) {
        CameraTestUtils.waitForResultValue(listener, resultKey, expectedValue,
                numResultsWait, WAIT_FOR_RESULT_TIMEOUT_MS);
    }

    /**
     * Wait for any expected result key values available in a certain number of results.
     *
     * <p>
     * Check the result immediately if numFramesWait is 0.
     * </p>
     *
     * @param listener The capture listener to get capture result.
     * @param resultKey The capture result key associated with the result value.
     * @param expectedValues The list of result value need to be waited for,
     * return immediately if the list is empty.
     * @param numResultsWait Number of frame to wait before times out.
     * @throws TimeoutRuntimeException If more than numResultsWait results are.
     * seen before the result matching myRequest arrives, or each individual wait
     * for result times out after {@value #WAIT_FOR_RESULT_TIMEOUT_MS}ms.
     */
    protected static <T> void waitForAnyResultValue(SimpleCaptureCallback listener,
            CaptureResult.Key<T> resultKey,
            List<T> expectedValues, int numResultsWait) {
        CameraTestUtils.waitForAnyResultValue(listener, resultKey, expectedValues, numResultsWait,
                WAIT_FOR_RESULT_TIMEOUT_MS);
    }

    /**
     * Submit a burst of the same capture request, then submit additional captures in order to
     * ensure that the camera will be synchronized.
     *
     * <p>
     * The additional capture count is determined by android.sync.maxLatency (or
     * a fixed {@value #NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY}) captures if maxLatency is unknown).
     * </p>
     *
     * <p>Returns the number of captures that were submitted (at least 1), which is useful
     * with {@link #waitForNumResults}.</p>
     *
     * @param request capture request to forward to {@link CameraDevice#capture}
     * @param listener request listener to forward to {@link CameraDevice#capture}
     * @param handler handler to forward to {@link CameraDevice#capture}
     *
     * @return the number of captures that were submitted
     *
     * @throws CameraAccessException if capturing failed
     */
    protected int captureRequestsSynchronizedBurst(
            CaptureRequest request, int count, CaptureCallback listener, Handler handler)
                    throws CameraAccessException {
        return captureRequestsSynchronizedImpl(request, count, listener, handler, true);
    }
    /**
     * Submit a capture once, then submit additional captures in order to ensure that
     * the camera will be synchronized.
     *
     * <p>
     * The additional capture count is determined by android.sync.maxLatency (or
     * a fixed {@value #NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY}) captures if maxLatency is unknown).
     * </p>
     *
     * <p>Returns the number of captures that were submitted (at least 1), which is useful
     * with {@link #waitForNumResults}.</p>
     *
     * @param request capture request to forward to {@link CameraDevice#capture}
     * @param listener request listener to forward to {@link CameraDevice#capture}
     * @param handler handler to forward to {@link CameraDevice#capture}
     *
     * @return the number of captures that were submitted
     *
     * @throws CameraAccessException if capturing failed
     */
    protected int captureRequestsSynchronized(
            CaptureRequest request, CaptureCallback listener, Handler handler)
                    throws CameraAccessException {
        return captureRequestsSynchronizedImpl(request, /*count*/1, listener, handler, false);
    }

    /**
     * Submit a capture {@code count} times, then submit additional captures in order to ensure that
     * the camera will be synchronized.
     *
     * <p>
     * The additional capture count is determined by android.sync.maxLatency (or
     * a fixed {@value #NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY}) captures if maxLatency is unknown).
     * </p>
     *
     * <p>Returns the number of captures that were submitted (at least 1), which is useful
     * with {@link #waitForNumResults}.</p>
     *
     * @param request capture request to forward to {@link CameraDevice#capture}
     * @param count the number of times to submit the request (minimally), must be at least 1
     * @param listener request listener to forward to {@link CameraDevice#capture}
     * @param handler handler to forward to {@link CameraDevice#capture}
     *
     * @return the number of captures that were submitted
     *
     * @throws IllegalArgumentException if {@code count} was not at least 1
     * @throws CameraAccessException if capturing failed
     */
    protected int captureRequestsSynchronized(
            CaptureRequest request, int count, CaptureCallback listener, Handler handler)
                    throws CameraAccessException {
        return captureRequestsSynchronizedImpl(request, count, listener, handler, false);
    }

    /**
     * Wait for numResultWait frames
     *
     * @param resultListener The capture listener to get capture result back.
     * @param numResultsWait Number of frame to wait
     *
     * @return the last result, or {@code null} if there was none
     */
    protected static CaptureResult waitForNumResults(SimpleCaptureCallback resultListener,
            int numResultsWait) {
        return CameraTestUtils.waitForNumResults(resultListener, numResultsWait,
                WAIT_FOR_RESULT_TIMEOUT_MS);
    }

    /**
     * Wait for enough results for settings to be applied
     *
     * @param resultListener The capture listener to get capture result back.
     * @param numResultWaitForUnknownLatency Number of frame to wait if camera device latency is
     *                                       unknown.
     */
    protected void waitForSettingsApplied(SimpleCaptureCallback resultListener,
            int numResultWaitForUnknownLatency) {
        int maxLatency = mStaticInfo.getSyncMaxLatency();
        if (maxLatency == CameraMetadata.SYNC_MAX_LATENCY_UNKNOWN) {
            maxLatency = numResultWaitForUnknownLatency;
        }
        // Wait for settings to take effect
        waitForNumResults(resultListener, maxLatency);
    }

    /**
     * Wait for AE to be stabilized before capture: CONVERGED or FLASH_REQUIRED.
     *
     * <p>Waits for {@code android.sync.maxLatency} number of results first, to make sure
     * that the result is synchronized (or {@code numResultWaitForUnknownLatency} if the latency
     * is unknown.</p>
     *
     * <p>This is a no-op for {@code LEGACY} devices since they don't report
     * the {@code aeState} result.</p>
     *
     * @param resultListener The capture listener to get capture result back.
     * @param numResultWaitForUnknownLatency Number of frame to wait if camera device latency is
     *                                       unknown.
     */
    protected void waitForAeStable(SimpleCaptureCallback resultListener,
            int numResultWaitForUnknownLatency) {
        CameraTestUtils.waitForAeStable(resultListener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY,
                mStaticInfo, WAIT_FOR_RESULT_TIMEOUT_MS, NUM_RESULTS_WAIT_TIMEOUT);
    }

    /**
     * Wait for AE to be: LOCKED
     *
     * <p>Waits for {@code android.sync.maxLatency} number of results first, to make sure
     * that the result is synchronized (or {@code numResultWaitForUnknownLatency} if the latency
     * is unknown.</p>
     *
     * <p>This is a no-op for {@code LEGACY} devices since they don't report
     * the {@code aeState} result.</p>
     *
     * @param resultListener The capture listener to get capture result back.
     * @param numResultWaitForUnknownLatency Number of frame to wait if camera device latency is
     *                                       unknown.
     */
    protected void waitForAeLocked(SimpleCaptureCallback resultListener,
            int numResultWaitForUnknownLatency) {

        waitForSettingsApplied(resultListener, numResultWaitForUnknownLatency);

        if (!mStaticInfo.isHardwareLevelAtLeastLimited()) {
            // No-op for legacy devices
            return;
        }

        List<Integer> expectedAeStates = new ArrayList<Integer>();
        expectedAeStates.add(new Integer(CaptureResult.CONTROL_AE_STATE_LOCKED));
        CameraTestUtils.waitForAnyResultValue(resultListener, CaptureResult.CONTROL_AE_STATE,
                expectedAeStates, NUM_RESULTS_WAIT_TIMEOUT, WAIT_FOR_RESULT_TIMEOUT_MS);
    }

    /**
     * Create an {@link ImageReader} object and get the surface.
     *
     * @param size The size of this ImageReader to be created.
     * @param format The format of this ImageReader to be created
     * @param maxNumImages The max number of images that can be acquired simultaneously.
     * @param listener The listener used by this ImageReader to notify callbacks.
     */
    protected void createImageReader(Size size, int format, int maxNumImages,
            ImageReader.OnImageAvailableListener listener) throws Exception {
        closeImageReader();

        ImageReader r = makeImageReader(size, format, maxNumImages, listener,
                mHandler);
        mReader = r;
        mReaderSurface = r.getSurface();
    }

    /**
     * Close the pending images then close current active {@link ImageReader} object.
     */
    protected void closeImageReader() {
        CameraTestUtils.closeImageReader(mReader);
        mReader = null;
        mReaderSurface = null;
    }

    /**
     * Close the pending images then close current active {@link ImageReader} objects.
     */
    protected void closeImageReaders(ImageReader[] readers) {
        CameraTestUtils.closeImageReaders(readers);
    }

    /**
     * Setup still capture configuration and start preview.
     *
     * @param previewRequest The capture request to be used for preview
     * @param stillRequest The capture request to be used for still capture
     * @param previewSz Preview size
     * @param captureSizes Still capture sizes
     * @param formats The single capture image formats
     * @param resultListener Capture result listener
     * @param maxNumImages The max number of images set to the image reader
     * @param imageListeners The single capture capture image listeners
     * @param isHeic HEIC still capture if true, JPEG still capture if false
     */
    protected ImageReader[] prepareStillCaptureAndStartPreview(
            CaptureRequest.Builder previewRequest, CaptureRequest.Builder stillRequest,
            Size previewSz, Size[] captureSizes, int[] formats, CaptureCallback resultListener,
            int maxNumImages, ImageReader.OnImageAvailableListener[] imageListeners,
            boolean isHeic)
            throws Exception {

        if ((captureSizes == null) || (formats == null) || (imageListeners == null) &&
                (captureSizes.length != formats.length) ||
                (formats.length != imageListeners.length)) {
            throw new IllegalArgumentException(""Invalid capture sizes/formats or image listeners!"");
        }

        if (VERBOSE) {
            Log.v(TAG, String.format(""Prepare still capture and preview (%s)"",
                    previewSz.toString()));
        }

        // Update preview size.
        updatePreviewSurface(previewSz);

        ImageReader[] readers = new ImageReader[captureSizes.length];
        List<Surface> outputSurfaces = new ArrayList<Surface>();
        outputSurfaces.add(mPreviewSurface);
        for (int i = 0; i < captureSizes.length; i++) {
            readers[i] = makeImageReader(captureSizes[i], formats[i], maxNumImages,
                    imageListeners[i], mHandler);
            outputSurfaces.add(readers[i].getSurface());
        }

        mSessionListener = new BlockingSessionCallback();
        mSession = configureCameraSession(mCamera, outputSurfaces, mSessionListener, mHandler);

        // Configure the requests.
        previewRequest.addTarget(mPreviewSurface);
        stillRequest.addTarget(mPreviewSurface);
        for (int i = 0; i < readers.length; i++) {
            stillRequest.addTarget(readers[i].getSurface());
        }

        // Start preview.
        mSession.setRepeatingRequest(previewRequest.build(), resultListener, mHandler);

        return readers;
    }

    /**
     * Open a camera device and get the StaticMetadata for a given camera id.
     *
     * @param cameraId The id of the camera device to be opened.
     */
    protected void openDevice(String cameraId) throws Exception {
        mCamera = CameraTestUtils.openCamera(
                mCameraManager, cameraId, mCameraListener, mHandler);
        mCollector.setCameraId(cameraId);
        mStaticInfo = new StaticMetadata(mCameraManager.getCameraCharacteristics(cameraId),
                CheckLevel.ASSERT, /*collector*/null);
        if (mStaticInfo.isColorOutputSupported()) {
            mOrderedPreviewSizes = getSupportedPreviewSizes(cameraId, mCameraManager,
                    getPreviewSizeBound(mWindowManager, PREVIEW_SIZE_BOUND));
            m1080pBoundedOrderedPreviewSizes = getSupportedPreviewSizes(cameraId, mCameraManager,
                    PREVIEW_SIZE_BOUND);
            mOrderedVideoSizes = getSupportedVideoSizes(cameraId, mCameraManager, PREVIEW_SIZE_BOUND);
            mOrderedStillSizes = getSupportedStillSizes(cameraId, mCameraManager, null);
            // Use ImageFormat.YUV_420_888 for now. TODO: need figure out what's format for preview
            // in public API side.
            mMinPreviewFrameDurationMap =
                mStaticInfo.getAvailableMinFrameDurationsForFormatChecked(ImageFormat.YUV_420_888);
        }
    }

    /**
     * Close the current actively used camera device.
     */
    protected void closeDevice() {
        if (mCamera != null) {
            mCamera.close();
            mCameraListener.waitForState(STATE_CLOSED, CAMERA_CLOSE_TIMEOUT_MS);
            mCamera = null;
            mSession = null;
            mSessionListener = null;
            mStaticInfo = null;
            mOrderedPreviewSizes = null;
            mOrderedVideoSizes = null;
            mOrderedStillSizes = null;
        }
    }

    /**
     * Update the preview surface size.
     *
     * @param size The preview size to be updated.
     */
    protected void updatePreviewSurface(Size size) {
        if (size.equals(mPreviewSize) && mPreviewSurface != null) {
            Log.w(TAG, ""Skipping update preview surface size..."");
            return;
        }

        mPreviewSize = size;
        Camera2SurfaceViewCtsActivity ctsActivity = mActivityRule.getActivity();
        final SurfaceHolder holder = ctsActivity.getSurfaceView().getHolder();
        Handler handler = new Handler(Looper.getMainLooper());
        handler.post(new Runnable() {
            @Override
            public void run() {
                holder.setFixedSize(mPreviewSize.getWidth(), mPreviewSize.getHeight());
            }
        });

        boolean res = ctsActivity.waitForSurfaceSizeChanged(
                WAIT_FOR_SURFACE_CHANGE_TIMEOUT_MS, mPreviewSize.getWidth(),
                mPreviewSize.getHeight());
        assertTrue(""wait for surface change to "" + mPreviewSize.toString() + "" timed out"", res);
        mPreviewHolder = holder;
        mPreviewSurface = holder.getSurface();
        assertNotNull(""Preview surface is null"", mPreviewSurface);
        assertTrue(""Preview surface is invalid"", mPreviewSurface.isValid());
    }

    /**
     * Recreate the SurfaceView's Surface
     *
     * Hide and unhide the activity's preview SurfaceView, so that its backing Surface is
     * recreated
     */
    protected void recreatePreviewSurface() {
        Camera2SurfaceViewCtsActivity ctsActivity = mActivityRule.getActivity();
        setPreviewVisibility(View.GONE);
        boolean res = ctsActivity.waitForSurfaceState(
            WAIT_FOR_SURFACE_CHANGE_TIMEOUT_MS, /*valid*/ false);
        assertTrue(""wait for surface destroyed timed out"", res);
        setPreviewVisibility(View.VISIBLE);
        res = ctsActivity.waitForSurfaceState(
            WAIT_FOR_SURFACE_CHANGE_TIMEOUT_MS, /*valid*/ true);
        assertTrue(""wait for surface created timed out"", res);
    }

    /**
     * Show/hide the preview SurfaceView.
     *
     * If set to View.GONE, the surfaceDestroyed callback will fire
     * @param visibility the new new visibility to set, one of View.VISIBLE / INVISIBLE / GONE
     */
    protected void setPreviewVisibility(int visibility) {
        final Camera2SurfaceViewCtsActivity ctsActivity = mActivityRule.getActivity();
        Handler handler = new Handler(Looper.getMainLooper());
        handler.post(new Runnable() {
            @Override
            public void run() {
                ctsActivity.getSurfaceView().setVisibility(visibility);
            }
        });
    }

    /**
     * Setup single capture configuration and start preview.
     *
     * @param previewRequest The capture request to be used for preview
     * @param stillRequest The capture request to be used for still capture
     * @param previewSz Preview size
     * @param captureSz Still capture size
     * @param format The single capture image format
     * @param resultListener Capture result listener
     * @param maxNumImages The max number of images set to the image reader
     * @param imageListener The single capture capture image listener
     */
    protected void prepareCaptureAndStartPreview(CaptureRequest.Builder previewRequest,
            CaptureRequest.Builder stillRequest, Size previewSz, Size captureSz, int format,
            CaptureCallback resultListener, int maxNumImages,
            ImageReader.OnImageAvailableListener imageListener) throws Exception {
        prepareCaptureAndStartPreview(previewRequest, stillRequest, previewSz, captureSz,
            format, resultListener, null, maxNumImages, imageListener);
    }

    /**
     * Setup single capture configuration and start preview.
     *
     * @param previewRequest The capture request to be used for preview
     * @param stillRequest The capture request to be used for still capture
     * @param previewSz Preview size
     * @param captureSz Still capture size
     * @param format The single capture image format
     * @param resultListener Capture result listener
     * @param sessionListener Session listener
     * @param maxNumImages The max number of images set to the image reader
     * @param imageListener The single capture capture image listener
     */
    protected void prepareCaptureAndStartPreview(CaptureRequest.Builder previewRequest,
            CaptureRequest.Builder stillRequest, Size previewSz, Size captureSz, int format,
            CaptureCallback resultListener, CameraCaptureSession.StateCallback sessionListener,
            int maxNumImages, ImageReader.OnImageAvailableListener imageListener) throws Exception {
        if (VERBOSE) {
            Log.v(TAG, String.format(""Prepare single capture (%s) and preview (%s)"",
                    captureSz.toString(), previewSz.toString()));
        }

        // Update preview size.
        updatePreviewSurface(previewSz);

        // Create ImageReader.
        createImageReader(captureSz, format, maxNumImages, imageListener);

        // Configure output streams with preview and jpeg streams.
        List<Surface> outputSurfaces = new ArrayList<Surface>();
        outputSurfaces.add(mPreviewSurface);
        outputSurfaces.add(mReaderSurface);
        if (sessionListener == null) {
            mSessionListener = new BlockingSessionCallback();
        } else {
            mSessionListener = new BlockingSessionCallback(sessionListener);
        }
        mSession = configureCameraSession(mCamera, outputSurfaces, mSessionListener, mHandler);

        // Configure the requests.
        previewRequest.addTarget(mPreviewSurface);
        stillRequest.addTarget(mPreviewSurface);
        stillRequest.addTarget(mReaderSurface);

        // Start preview.
        mSession.setRepeatingRequest(previewRequest.build(), resultListener, mHandler);
    }

    /**
     * Get the max preview size that supports the given fpsRange.
     *
     * @param fpsRange The fps range the returned size must support.
     * @return max size that support the given fps range.
     */
    protected Size getMaxPreviewSizeForFpsRange(Range<Integer> fpsRange) {
        if (fpsRange == null || fpsRange.getLower() <= 0 || fpsRange.getUpper() <= 0) {
            throw new IllegalArgumentException(""Invalid fps range argument"");
        }
        if (mOrderedPreviewSizes == null || mMinPreviewFrameDurationMap == null) {
            throw new IllegalStateException(""mOrderedPreviewSizes and mMinPreviewFrameDurationMap""
                    + "" must be initialized"");
        }

        long[] frameDurationRange =
                new long[]{(long) (1e9 / fpsRange.getUpper()), (long) (1e9 / fpsRange.getLower())};
        for (Size size : mOrderedPreviewSizes) {
            Long minDuration = mMinPreviewFrameDurationMap.get(size);
            if (minDuration == null ||
                    minDuration == 0) {
                if (mStaticInfo.isCapabilitySupported(
                        CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR)) {
                    throw new IllegalArgumentException(
                            ""No min frame duration available for the size "" + size);
                }
                continue;
            }
            if (minDuration <= (frameDurationRange[0] + MIN_FRAME_DURATION_ERROR_MARGIN)) {
                return size;
            }
        }

        // Search again for sizes not bounded by display size
        for (Size size : m1080pBoundedOrderedPreviewSizes) {
            Long minDuration = mMinPreviewFrameDurationMap.get(size);
            if (minDuration == null ||
                    minDuration == 0) {
                if (mStaticInfo.isCapabilitySupported(
                        CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR)) {
                    throw new IllegalArgumentException(
                            ""No min frame duration available for the size "" + size);
                }
                continue;
            }
            if (minDuration <= (frameDurationRange[0] + MIN_FRAME_DURATION_ERROR_MARGIN)) {
                return size;
            }
        }
        return null;
    }

    protected boolean isReprocessSupported(String cameraId, int format)
            throws CameraAccessException {
        if (format != ImageFormat.YUV_420_888 && format != ImageFormat.PRIVATE) {
            throw new IllegalArgumentException(
                    ""format "" + format + "" is not supported for reprocessing"");
        }

        StaticMetadata info =
                new StaticMetadata(mCameraManager.getCameraCharacteristics(cameraId),
                                   CheckLevel.ASSERT, /*collector*/ null);
        int cap = CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_YUV_REPROCESSING;
        if (format == ImageFormat.PRIVATE) {
            cap = CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING;
        }
        return info.isCapabilitySupported(cap);
    }

    protected Range<Integer> getSuitableFpsRangeForDuration(String cameraId, long frameDuration) {
        return CameraTestUtils.getSuitableFpsRangeForDuration(cameraId, frameDuration, mStaticInfo);
    }

    private int captureRequestsSynchronizedImpl(
            CaptureRequest request, int count, CaptureCallback listener, Handler handler,
            boolean isBurst) throws CameraAccessException {
        if (count < 1) {
            throw new IllegalArgumentException(""count must be positive"");
        }

        int maxLatency = mStaticInfo.getSyncMaxLatency();
        if (maxLatency == CameraMetadata.SYNC_MAX_LATENCY_UNKNOWN) {
            maxLatency = NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY;
        }

        assertTrue(""maxLatency is non-negative"", maxLatency >= 0);

        int numCaptures = maxLatency + count;
        ArrayList<CaptureRequest> burstCaptureRequests = new ArrayList<>();
        for (int i = 0; i < numCaptures; ++i) {
            if (isBurst) {
                burstCaptureRequests.add(request);
            } else {
                mSession.capture(request, listener, handler);
            }
        }
        if (isBurst) {
            mSession.captureBurst(burstCaptureRequests, listener, handler);
        }

        return numCaptures;
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.autofillservice.cts.commontests.CustomDescriptionWithLinkTestCase"	"testTapLinkAfterUpdateAppliedToAnotherView"	"CtsAutoFillServiceTestCases"	"/home/gpoor/cts-12-source/cts/tests/autofillservice/src/android/autofillservice/cts/commontests/CustomDescriptionWithLinkTestCase.java"	""	"public final void testTapLinkAfterUpdateAppliedToAnotherView() throws Exception {
        tapLinkAfterUpdateAppliedTest(false);
    }

    protected abstract void tapLinkAfterUpdateAppliedTest(boolean updateLinkView) throws Exception;

    public enum PostSaveLinkTappedAction {
        TAP_BACK_BUTTON,
        ROTATE_THEN_TAP_BACK_BUTTON,
        FINISH_ACTIVITY,
        LAUNCH_NEW_ACTIVITY,
        LAUNCH_PREVIOUS_ACTIVITY,
        TOUCH_OUTSIDE,
        TAP_NO_ON_SAVE_UI,
        TAP_YES_ON_SAVE_UI
    }

    protected final void startActivityOnNewTask(Class<?> clazz) {
        final Intent intent = new Intent(mContext, clazz);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(intent);
    }

    protected RemoteViews newTemplate() {
        final RemoteViews presentation = new RemoteViews(mPackageName,
                R.layout.custom_description_with_link);
        return presentation;
    }

    protected final CustomDescription.Builder newCustomDescriptionBuilder(
            Class<? extends Activity> activityClass) {
        final Intent intent = new Intent(mContext, activityClass);
        intent.setFlags(Intent.FLAG_ACTIVITY_RETAIN_IN_RECENTS | Intent.FLAG_ACTIVITY_NEW_DOCUMENT);
        return newCustomDescriptionBuilder(intent);
    }

    protected final CustomDescription newCustomDescription(
            Class<? extends Activity> activityClass) {
        return newCustomDescriptionBuilder(activityClass).build();
    }

    protected final CustomDescription.Builder newCustomDescriptionBuilder(Intent intent) {
        final RemoteViews presentation = newTemplate();
        final PendingIntent pendingIntent =
                PendingIntent.getActivity(mContext, 0, intent, PendingIntent.FLAG_MUTABLE);
        presentation.setOnClickPendingIntent(R.id.link, pendingIntent);
        return new CustomDescription.Builder(presentation);
    }

    protected final CustomDescription newCustomDescription(Intent intent) {
        return newCustomDescriptionBuilder(intent).build();
    }

    protected final UiObject2 assertSaveUiWithLinkIsShown(int saveType) throws Exception {
        return assertSaveUiWithLinkIsShown(saveType, ""DON'T TAP ME!"");
    }

    protected final UiObject2 assertSaveUiWithLinkIsShown(int saveType, String expectedText)
            throws Exception {
        // First make sure the UI is shown...
        final UiObject2 saveUi = mUiBot.assertSaveShowing(saveType);
        // Then make sure it does have the custom view with link on it...
        final UiObject2 link = getLink(saveUi);
        assertThat(link.getText()).isEqualTo(expectedText);
        return saveUi;
    }

    protected final UiObject2 getLink(final UiObject2 container) {
        final UiObject2 link = container.findObject(By.res(mPackageName, ID_LINK));
        assertThat(link).isNotNull();
        return link;
    }

    protected final void tapSaveUiLink(UiObject2 saveUi) {
        getLink(saveUi).click();
    }
}"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.host.blob.InstantAppAccessTest"	"testInstantAppAccess"	"CtsBlobStoreHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/blobstore/src/com/android/cts/host/blob/InstantAppAccessTest.java"	""	"public void testInstantAppAccess() throws Exception {
        runDeviceTest(TARGET_PKG, TEST_CLASS, ""testInstantAppAccess"");
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.ephemeralapp2.EphemeralActivity"	"finish"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/EphemeralApp2/src/com/android/cts/ephemeralapp2/EphemeralActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.ephemeralapp2;

import android.app.Activity;
import android.app.SearchManager;
import android.content.Intent;
import android.content.pm.PackageInfo;
import android.content.pm.ResolveInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.net.Uri;
import android.os.Bundle;
import android.provider.SearchRecentSuggestions;
import android.util.Log;

import com.android.cts.util.TestResult;

import java.util.List;

public class EphemeralActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        final Intent intent  = getIntent();
        if (Intent.ACTION_SEARCH.equals(intent.getAction())) {
            final String query = intent.getStringExtra(SearchManager.QUERY);
            final SearchRecentSuggestions suggestions = new SearchRecentSuggestions(this,
                    SearchSuggestionProvider.AUTHORITY, SearchSuggestionProvider.MODE);
            suggestions.saveRecentQuery(query, null);
        }

        TestResult.getBuilder()
                .setPackageName(""com.android.cts.ephemeralapp2"")
                .setComponentName(""EphemeralActivity"")
                .setIntent(getIntent())
                .setStatus(""PASS"")
                .build()
                .startActivity(this, Uri.parse(""https://cts.google.com/result""));
        finish();
    }
}"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.instantupgradeapp.ClientTest"	"testInstantApplicationWritePreferences"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/InstantUpgradeApp/src/com/android/cts/instantupgradeapp/ClientTest.java"	""	"public void testInstantApplicationWritePreferences() throws Exception {
        // only done in the context of an instant application
        assertTrue(InstrumentationRegistry.getContext().getPackageManager().isInstantApp());
        final SharedPreferences prefWriter =
                InstrumentationRegistry.getContext().getSharedPreferences(""preferences"", 0);
        prefWriter.edit().putString(""test"", ""value"").commit();
    }"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.instantupgradeapp.ClientTest"	"testFullApplicationReadPreferences"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/InstantUpgradeApp/src/com/android/cts/instantupgradeapp/ClientTest.java"	""	"public void testFullApplicationReadPreferences() throws Exception {
        // only done in the context of an full application
        assertFalse(InstrumentationRegistry.getContext().getPackageManager().isInstantApp());
        final SharedPreferences prefReader =
                InstrumentationRegistry.getContext().getSharedPreferences(""preferences"", 0);
        assertThat(prefReader.getString(""test"", ""default""), is(""value""));
    }"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.instantupgradeapp.ClientTest"	"testInstantApplicationWriteFile"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/InstantUpgradeApp/src/com/android/cts/instantupgradeapp/ClientTest.java"	""	"public void testInstantApplicationWriteFile() throws Exception {
        // only done in the context of an instant application
        assertTrue(InstrumentationRegistry.getContext().getPackageManager().isInstantApp());
        try (FileOutputStream fos = InstrumentationRegistry
                .getContext().openFileOutput(""test.txt"", Context.MODE_PRIVATE)) {
            fos.write(""MyTest"".getBytes());
        }
    }"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.instantupgradeapp.ClientTest"	"testFullApplicationReadFile"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/InstantUpgradeApp/src/com/android/cts/instantupgradeapp/ClientTest.java"	""	"public void testFullApplicationReadFile() throws Exception {
        // only done in the context of an full application
        assertFalse(InstrumentationRegistry.getContext().getPackageManager().isInstantApp());
        try (FileInputStream fis = InstrumentationRegistry
                .getContext().openFileInput(""test.txt"")) {
            final StringBuffer buffer = new StringBuffer();
            final byte[] b = new byte[1024];
            int count;
            while ((count = fis.read(b)) != -1) {
                buffer.append(new String(b, 0, count));
            }
            assertThat(buffer.toString(), is(""MyTest""));
        }
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.accessibilityservice.cts.AccessibilityGlobalActionsTest"	"testPerformGlobalActionRecents"	"CtsAccessibilityServiceTestCases"	"/home/gpoor/cts-12-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityGlobalActionsTest.java"	""	"public void testPerformGlobalActionRecents() throws Exception {
        // Perform the action.
        boolean actionWasPerformed = sUiAutomation.performGlobalAction(
                AccessibilityService.GLOBAL_ACTION_RECENTS);

        // Sleep a bit so the UI is settled.
        waitForIdle();

        if (actionWasPerformed) {
            // This is a necessary since the global action does not
            // dismiss recents until they stop animating. Sigh...
            SystemClock.sleep(5000);
        }
    }

    @MediumTest"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.voiceinteraction.cts.DirectActionsTest"	"testNotifyDirectActionsChanged"	"CtsVoiceInteractionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/voiceinteraction/src/android/voiceinteraction/cts/DirectActionsTest.java"	""	"public void testNotifyDirectActionsChanged() throws Exception {
        mActivityControl.startActivity();
        mSessionControl.startVoiceInteractionSession();
        try {
            // Get the actions to set up the VoiceInteractor
            mSessionControl.getDirectActions();

            assertThat(mSessionControl.detectDirectActionsInvalidated(
                    () -> mActivityControl.invalidateDirectActions())).isTrue();
        } finally {
            mSessionControl.stopVoiceInteractionSession();
            mActivityControl.finishActivity();
        }
    }
    private final class SessionControl {
        private @Nullable RemoteCallback mControl;

        private void startVoiceInteractionSession() throws Exception {
            final CountDownLatch latch = new CountDownLatch(1);

            final RemoteCallback callback = new RemoteCallback((result) -> {
                mControl = result.getParcelable(Utils.DIRECT_ACTIONS_KEY_CONTROL);
                latch.countDown();
            });

            final Intent intent = new Intent();
            intent.putExtra(Utils.DIRECT_ACTIONS_KEY_CLASS,
                    ""android.voiceinteraction.service.DirectActionsSession"");
            intent.setClassName(""android.voiceinteraction.service"",
                    ""android.voiceinteraction.service.VoiceInteractionMain"");
            intent.putExtra(Utils.DIRECT_ACTIONS_KEY_CALLBACK, callback);
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

            Log.v(TAG, ""startVoiceInteractionSession(): "" + intent);
            mContext.startActivity(intent);

            if (!latch.await(OPERATION_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
                throw new TimeoutException(""actitvity not started in "" + OPERATION_TIMEOUT_MS
                        + ""ms"");
            }
        }

        private void stopVoiceInteractionSession() throws Exception {
            executeCommand(Utils.DIRECT_ACTIONS_SESSION_CMD_FINISH,
                    null /*directAction*/, null /*arguments*/, null /*postActionCommand*/);
        }

        @Nullable List<DirectAction> getDirectActions() throws Exception {
            final ArrayList<DirectAction> actions = new ArrayList<>();
            final Bundle result = executeCommand(Utils.DIRECT_ACTIONS_SESSION_CMD_GET_ACTIONS,
                    null /*directAction*/, null /*arguments*/, null /*postActionCommand*/);
            actions.addAll(result.getParcelableArrayList(Utils.DIRECT_ACTIONS_KEY_RESULT));
            return actions;
        }

        @Nullable Bundle performDirectAction(@NonNull DirectAction directAction,
                @NonNull Bundle arguments) throws Exception {
            return executeCommand(Utils.DIRECT_ACTIONS_SESSION_CMD_PERFORM_ACTION,
                    directAction, arguments, null /*postActionCommand*/);
        }

        @Nullable Bundle performDirectActionAndCancel(@NonNull DirectAction directAction,
                @NonNull Bundle arguments) throws Exception {
            return executeCommand(Utils.DIRECT_ACTIONS_SESSION_CMD_PERFORM_ACTION_CANCEL,
                    directAction, arguments, null /*postActionCommand*/);
        }

        @Nullable
        boolean detectDirectActionsInvalidated(@NonNull ThrowingRunnable postActionCommand)
                throws Exception {
            final Bundle result = executeCommand(
                    Utils.DIRECT_ACTIONS_SESSION_CMD_DETECT_ACTIONS_CHANGED,
                    null /*directAction*/, null /*arguments*/, postActionCommand);
            return result.getBoolean(Utils.DIRECT_ACTIONS_KEY_RESULT);
        }

        @Nullable Bundle executeCommand(@NonNull String action, @Nullable DirectAction directAction,
                @Nullable Bundle arguments, @Nullable ThrowingRunnable postActionCommand)
                throws Exception {
            final CountDownLatch latch = new CountDownLatch(1);

            final Bundle result = new Bundle();

            final RemoteCallback callback = new RemoteCallback((b) -> {
                result.putAll(b);
                latch.countDown();
            });

            final Bundle command = new Bundle();
            command.putString(Utils.DIRECT_ACTIONS_KEY_COMMAND, action);
            command.putParcelable(Utils.DIRECT_ACTIONS_KEY_ACTION, directAction);
            command.putBundle(Utils.DIRECT_ACTIONS_KEY_ARGUMENTS, arguments);
            command.putParcelable(Utils.DIRECT_ACTIONS_KEY_CALLBACK, callback);

            Log.v(TAG, ""executeCommand(): action="" + action + "" command=""
                    + Utils.toBundleString(command));
            mControl.sendResult(command);

            if (postActionCommand != null) {
                Log.v(TAG, ""Executing post-action command for "" + action);
                postActionCommand.run();
            }

            if (!latch.await(OPERATION_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
                throw new TimeoutException(""result not received in "" + OPERATION_TIMEOUT_MS + ""ms"");
            }

            Log.v(TAG, ""returning "" + Utils.toBundleString(result));

            return result;
        }
    }

    private final class ActivityControl {
        private @Nullable RemoteCallback mControl;

        void startActivity() throws Exception {
            final CountDownLatch latch = new CountDownLatch(1);

            final RemoteCallback callback = new RemoteCallback((result) -> {
                Log.v(TAG, ""ActivityControl: testapp called the callback: ""
                        + Utils.toBundleString(result));
                mControl = result.getParcelable(Utils.DIRECT_ACTIONS_KEY_CONTROL);
                latch.countDown();
            });

            final Intent intent = new Intent()
                    .setAction(Intent.ACTION_VIEW)
                    .addCategory(Intent.CATEGORY_BROWSABLE)
                    .setData(Uri.parse(""https://android.voiceinteraction.testapp""
                            + ""/DirectActionsActivity""))
                    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    .putExtra(Utils.DIRECT_ACTIONS_KEY_CALLBACK, callback);
            if (mContext.getPackageManager().isInstantApp()) {
                // Override app-links domain verification.
                runShellCommand(
                        String.format(
                                ""pm set-app-links-user-selection --user cur --package %1$s true""
                                        + "" %1$s"",
                                TEST_APP_PACKAGE));
            } else {
                intent.setPackage(TEST_APP_PACKAGE);
            }

            Log.v(TAG, ""startActivity: "" + intent);
            mContext.startActivity(intent);

            if (!latch.await(OPERATION_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
                throw new TimeoutException(""actitvity not started in "" + OPERATION_TIMEOUT_MS
                        + ""ms"");
            }
        }

        private boolean detectInteractorDestroyed(ThrowingRunnable destroyTrigger)
                throws Exception {
            final Bundle result = executeRemoteCommand(
                    Utils.DIRECT_ACTIONS_ACTIVITY_CMD_DESTROYED_INTERACTOR,
                    destroyTrigger);
            return result.getBoolean(Utils.DIRECT_ACTIONS_KEY_RESULT);
        }

        void finishActivity() throws Exception {
            executeRemoteCommand(Utils.DIRECT_ACTIONS_ACTIVITY_CMD_FINISH);
        }

        void invalidateDirectActions() throws Exception {
            executeRemoteCommand(Utils.DIRECT_ACTIONS_ACTIVITY_CMD_INVALIDATE_ACTIONS);
        }

        @NonNull Bundle executeRemoteCommand(@NonNull String action) throws Exception {
            return executeRemoteCommand(action, /* postActionCommand= */ null);
        }

        @NonNull Bundle executeRemoteCommand(@NonNull String action,
                @Nullable ThrowingRunnable postActionCommand) throws Exception {
            final Bundle result = new Bundle();

            final CountDownLatch latch = new CountDownLatch(1);

            final RemoteCallback callback = new RemoteCallback((b) -> {
                Log.v(TAG, ""executeRemoteCommand(): received result from '"" + action + ""': ""
                        + Utils.toBundleString(b));
                if (b != null) {
                    result.putAll(b);
                }
                latch.countDown();
            });

            final Bundle command = new Bundle();
            command.putString(Utils.DIRECT_ACTIONS_KEY_COMMAND, action);
            command.putParcelable(Utils.DIRECT_ACTIONS_KEY_CALLBACK, callback);

            Log.v(TAG, ""executeRemoteCommand(): sending command for '"" + action + ""'"");
            mControl.sendResult(command);

            if (postActionCommand != null) {
                try {
                    postActionCommand.run();
                } catch (Exception e) {
                    Log.e(TAG, ""action '"" + action + ""' failed"");
                    throw e;
                }
            }

            if (!latch.await(OPERATION_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
                throw new TimeoutException(""result not received in "" + OPERATION_TIMEOUT_MS + ""ms"");
            }
            return result;
        }
    }

    private @NonNull DirectAction getExpectedDirectActionAssertively(
            @Nullable List<DirectAction> actions) {
        assertWithMessage(""no actions"").that(actions).isNotEmpty();
        final DirectAction action = actions.get(0);
        assertThat(action.getId()).isEqualTo(Utils.DIRECT_ACTIONS_ACTION_ID);
        assertThat(action.getExtras().getString(Utils.DIRECT_ACTION_EXTRA_KEY))
                .isEqualTo(Utils.DIRECT_ACTION_EXTRA_VALUE);
        assertThat(action.getLocusId().getId()).isEqualTo(Utils.DIRECT_ACTIONS_LOCUS_ID.getId());
        return action;
    }

    private @NonNull Bundle createActionArguments() {
        final Bundle args = new Bundle();
        args.putString(Utils.DIRECT_ACTIONS_KEY_ARGUMENTS, Utils.DIRECT_ACTIONS_KEY_ARGUMENTS);
        Log.v(TAG, ""createActionArguments(): "" + Utils.toBundleString(args));
        return args;
    }

    private void assertActionSucceeded(@NonNull Bundle result) {
        final Bundle bundle = result.getBundle(Utils.DIRECT_ACTIONS_KEY_RESULT);
        final String status = bundle.getString(Utils.DIRECT_ACTIONS_KEY_RESULT);
        assertWithMessage(""assertActionSucceeded(%s)"", Utils.toBundleString(result))
                .that(Utils.DIRECT_ACTIONS_RESULT_PERFORMED).isEqualTo(status);
    }

    private void assertActionCancelled(@NonNull Bundle result) {
        final Bundle bundle = result.getBundle(Utils.DIRECT_ACTIONS_KEY_RESULT);
        final String status = bundle.getString(Utils.DIRECT_ACTIONS_KEY_RESULT);
        assertWithMessage(""assertActionCancelled(%s)"", Utils.toBundleString(result))
                .that(Utils.DIRECT_ACTIONS_RESULT_CANCELLED).isEqualTo(status);
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.security.net.config.cts.BaseTestCase"	"isInstantApp"	""	"/home/gpoor/cts-12-source/cts/tests/tests/networksecurityconfig/src/android/security/net/config/cts/BaseTestCase.java"	""	"public void test/*
 *.
 */

package android.security.net.config.cts;

import android.content.Context;
import android.net.wifi.WifiManager;
import android.test.AndroidTestCase;

import com.android.compatibility.common.util.SystemUtil;

/**
 * Base test case for all tests under {@link android.security.net.config.cts}.
 */
public class BaseTestCase extends AndroidTestCase {
    @Override
    public void setUp() throws Exception {
        // Instant Apps cannot access WifiManager, skip wifi check.
        if (getContext().getPackageManager().isInstantApp()) {
            return;
        }
        WifiManager wifiManager = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        if (!wifiManager.isWifiEnabled()) {
            SystemUtil.runShellCommand(""svc wifi enable""); // toggle wifi on.
            Thread.sleep(5000); // sleep 5 second for wifi to connect to a network.
        }
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.instantapps.NotificationTestActivity"	"deviceIsGms"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/instantapps/NotificationTestActivity.java"	""	"public void test/*
 *.
 */
package com.android.cts.verifier.instantapps;

import android.os.Bundle;
import android.content.pm.PackageManager;
import android.widget.TextView;

import com.android.cts.verifier.R;

/**
 * Test for manual verification of Instant Apps notification.
 *
 * The test verifies that an Instant App notification will be shown when
 * an Instant App is at foreground.
 */
public class NotificationTestActivity extends BaseTestActivity {

    private String gms_package_name = ""com.google.android.gms"";
    private String store_package_name = ""com.android.vending"";

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setInfoResources(R.string.ia_notification, R.string.ia_notification_info, -1);
        TextView extraText = (TextView) findViewById(R.id.instruction_extra_text);
        if (deviceIsGms()) {
            extraText.setText(R.string.ia_notification_instruction_label);
        } else {
            extraText.setText(R.string.ia_notification_instruction_label_no_app_market_version);
        }
    }

    private boolean deviceIsGms() {
        return deviceHasGmsCore() && deviceHasPlayStore() && !deviceHasCnFeature();
    }

    private boolean deviceHasCnFeature() {
        boolean hasCnFeature = getApplicationContext().getPackageManager().hasSystemFeature(""cn.google.services"");
        return hasCnFeature;
    }

    private boolean deviceHasGmsCore() {
        try {
            return getPackageManager().getApplicationInfo(gms_package_name, PackageManager.MATCH_DIRECT_BOOT_AUTO) != null;
        } catch (PackageManager.NameNotFoundException ex) {
            return false;
        }
    }

    private boolean deviceHasPlayStore() {
        try {
            return getPackageManager().getApplicationInfo(store_package_name, PackageManager.MATCH_DIRECT_BOOT_AUTO) != null;
        } catch (PackageManager.NameNotFoundException ex) {
            return false;
        }
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.ManifestTestListAdapter"	"isEmpty"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/ManifestTestListAdapter.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier;

import static com.android.cts.verifier.TestListActivity.sCurrentDisplayMode;
import static com.android.cts.verifier.TestListActivity.sInitialLaunch;

import android.content.Context;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.content.res.Resources;
import android.os.Bundle;
import android.telephony.TelephonyManager;
import android.util.Log;
import android.widget.ListView;

import com.android.cts.verifier.TestListActivity.DisplayMode;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * {@link TestListAdapter} that populates the {@link TestListActivity}'s {@link ListView} by
 * reading data from the CTS Verifier's AndroidManifest.xml.
 * <p>
 * Making a new test activity to appear in the list requires the following steps:
 *
 * <ol>
 *     <li>REQUIRED: Add an activity to the AndroidManifest.xml with an intent filter with a
 *         main action and the MANUAL_TEST category.
 *         <pre>
 *             <intent-filter>
 *                <action android:name=""android.intent.action.MAIN"" />
 *                <category android:name=""android.cts.intent.category.MANUAL_TEST"" />
 *             </intent-filter>
 *         </pre>
 *     </li>
 *     <li>REQUIRED: Add a meta data attribute to indicate which display modes of tests the activity
 *         should belong to. ""single_display_mode"" indicates a test is only needed to run on the
 *         main display mode (i.e. unfolded), and ""multi_display_mode"" indicates a test is required
 *         to run under both modes (i.e. both folded and unfolded).If you don't add this attribute,
 *         your test will show up in both unfolded and folded modes.
 *         <pre>
 *             <meta-data android:name=""display_mode"" android:value=""multi_display_mode"" />
 *         </pre>
 *     </li>
 *     <li>OPTIONAL: Add a meta data attribute to indicate what category of tests the activity
 *         should belong to. If you don't add this attribute, your test will show up in the
 *         ""Other"" tests category.
 *         <pre>
 *             <meta-data android:name=""test_category"" android:value=""@string/test_category_security"" />
 *         </pre>
 *     </li>
 *     <li>OPTIONAL: Add a meta data attribute to indicate whether this test has a parent test.
 *         <pre>
 *             <meta-data android:name=""test_parent"" android:value=""com.android.cts.verifier.bluetooth.BluetoothTestActivity"" />
 *         </pre>
 *     </li>
 *     <li>OPTIONAL: Add a meta data attribute to indicate what features are required to run the
 *         test. If the device does not have all of the required features then it will not appear
 *         in the test list. Use a colon (:) to specify multiple required features.
 *         <pre>
 *             <meta-data android:name=""test_required_features"" android:value=""android.hardware.sensor.accelerometer"" />
 *         </pre>
 *     </li>
 *     <li>OPTIONAL: Add a meta data attribute to indicate features such that, if any present, the
 *         test gets excluded from being shown. If the device has any of the excluded features then
 *         the test will not appear in the test list. Use a colon (:) to specify multiple features
 *         to exclude for the test. Note that the colon means ""or"" in this case.
 *         <pre>
 *             <meta-data android:name=""test_excluded_features"" android:value=""android.hardware.type.television"" />
 *         </pre>
 *     </li>
 *     <li>OPTIONAL: Add a meta data attribute to indicate features such that, if any present,
 *         the test is applicable to run. If the device has any of the applicable features then
 *         the test will appear in the test list. Use a colon (:) to specify multiple features
 *         <pre>
 *             <meta-data android:name=""test_applicable_features"" android:value=""android.hardware.sensor.compass"" />
 *         </pre>
 *     </li>
 *     <li>OPTIONAL: Add a meta data attribute to indicate which intent actions are required to run
 *         the test. If the device does not have activities that handle all those actions, then it
 *         will not appear in the test list. Use a colon (:) to specify multiple required intent actions.
 *         <pre>
 *             <meta-data android:name=""test_required_actions"" android:value=""android.app.action.ADD_DEVICE_ADMIN"" />
 *         </pre>
 *     </li>
 *
 * </ol>
 */
public class ManifestTestListAdapter extends TestListAdapter {
    private static final String LOG_TAG = ""ManifestTestListAdapter"";

    private static final String TEST_CATEGORY_META_DATA = ""test_category"";

    private static final String TEST_PARENT_META_DATA = ""test_parent"";

    private static final String TEST_REQUIRED_FEATURES_META_DATA = ""test_required_features"";

    private static final String TEST_EXCLUDED_FEATURES_META_DATA = ""test_excluded_features"";

    private static final String TEST_APPLICABLE_FEATURES_META_DATA = ""test_applicable_features"";

    private static final String TEST_REQUIRED_CONFIG_META_DATA = ""test_required_configs"";

    private static final String TEST_REQUIRED_ACTIONS_META_DATA = ""test_required_actions"";

    private static final String TEST_DISPLAY_MODE_META_DATA = ""display_mode"";

    private static final String CONFIG_NO_EMULATOR = ""config_no_emulator"";

    private static final String CONFIG_VOICE_CAPABLE = ""config_voice_capable"";

    private static final String CONFIG_HAS_RECENTS = ""config_has_recents"";

    private static final String CONFIG_HDMI_SOURCE = ""config_hdmi_source"";

    private static final String CONFIG_QUICK_SETTINGS_SUPPORTED = ""config_quick_settings_supported"";

    /** The config to represent that a test is only needed to run in the main display mode
     * (i.e. unfolded) */
    private static final String SINGLE_DISPLAY_MODE = ""single_display_mode"";

    /** The config to represent that a test is needed to run in the multiple display modes
     * (i.e. both unfolded and folded) */
    private static final String MULTIPLE_DISPLAY_MODE = ""multi_display_mode"";

    private final HashSet<String> mDisabledTests;

    private Context mContext;

    private String mTestParent;

    public ManifestTestListAdapter(Context context, String testParent, String[] disabledTestArray) {
        super(context);
        mContext = context;
        mTestParent = testParent;
        mDisabledTests = new HashSet<>(disabledTestArray.length);
        for (int i = 0; i < disabledTestArray.length; i++) {
            mDisabledTests.add(disabledTestArray[i]);
        }

        // Configs to distinct that the adapter is for top-level tests or subtests.
        if (testParent == null) {
            // For top-level tests.
            hasTestParentInManifestAdapter = false;
        } else {
            hasTestParentInManifestAdapter = true;
        }
        adapterFromManifest = true;
    }

    public ManifestTestListAdapter(Context context, String testParent) {
        this(context, testParent, context.getResources().getStringArray(R.array.disabled_tests));
    }

    @Override
    protected List<TestListItem> getRows() {
        List<TestListItem> allRows = new ArrayList<TestListItem>();

        // When launching at the first time or after killing the process, needs to fetch the
        // test items of all display modes as the bases for switching.
        if (mDisplayModesTests.isEmpty()) {
            for (DisplayMode mode : DisplayMode.values()) {
                allRows = getRowsWithDisplayMode(mode.toString());
                mDisplayModesTests.put(mode.toString(), allRows);
            }
        }

        if (!sInitialLaunch) {
            return getRowsWithDisplayMode(sCurrentDisplayMode);
        }
        return allRows;
    }

    /**
     * Gets all rows based on the specific display mode.
     *
     * @param mode Given display mode.
     * @return A list containing all test itmes in the given display mode.
     */
    private List<TestListItem> getRowsWithDisplayMode (String mode) {
        /*
         * 1. Get all the tests belonging to the test parent.
         * 2. Get all the tests keyed by their category.
         * 3. Flatten the tests and categories into one giant list for the list view.
         */
        List<TestListItem> allRows = new ArrayList<TestListItem>();
        List<ResolveInfo> infos = getResolveInfosForParent();
        Map<String, List<TestListItem>> testsByCategory = getTestsByCategory(infos);

        List<String> testCategories = new ArrayList<String>(testsByCategory.keySet());
        Collections.sort(testCategories);
        for (String testCategory : testCategories) {
            List<TestListItem> tests = filterTests(testsByCategory.get(testCategory), mode);
            if (!tests.isEmpty()) {
                allRows.add(TestListItem.newCategory(testCategory));
                Collections.sort(tests, Comparator.comparing(item -> item.title));
                allRows.addAll(tests);
            }
        }
        return allRows;
    }

    List<ResolveInfo> getResolveInfosForParent() {
        Intent mainIntent = new Intent(Intent.ACTION_MAIN);
        mainIntent.addCategory(CATEGORY_MANUAL_TEST);
        mainIntent.setPackage(mContext.getPackageName());

        PackageManager packageManager = mContext.getPackageManager();
        List<ResolveInfo> list = packageManager.queryIntentActivities(mainIntent,
                PackageManager.GET_ACTIVITIES | PackageManager.GET_META_DATA);
        int size = list.size();

        List<ResolveInfo> matchingList = new ArrayList<>();
        for (int i = 0; i < size; i++) {
            ResolveInfo info = list.get(i);
            String parent = getTestParent(info.activityInfo.metaData);
            if ((mTestParent == null && parent == null)
                    || (mTestParent != null && mTestParent.equals(parent))) {
                matchingList.add(info);
            }
        }
        return matchingList;
    }

    Map<String, List<TestListItem>> getTestsByCategory(List<ResolveInfo> list) {
        Map<String, List<TestListItem>> testsByCategory = new HashMap<>();

        int size = list.size();
        for (int i = 0; i < size; i++) {
            ResolveInfo info = list.get(i);
            if (info.activityInfo == null || mDisabledTests.contains(info.activityInfo.name)) {
                Log.w(LOG_TAG, ""ignoring disabled test: "" + info.activityInfo.name);
                continue;
            }
            String title = getTitle(mContext, info.activityInfo);
            String testName = info.activityInfo.name;
            Intent intent = getActivityIntent(info.activityInfo);
            String[] requiredFeatures = getRequiredFeatures(info.activityInfo.metaData);
            String[] requiredConfigs = getRequiredConfigs(info.activityInfo.metaData);
            String[] requiredActions = getRequiredActions(info.activityInfo.metaData);
            String[] excludedFeatures = getExcludedFeatures(info.activityInfo.metaData);
            String[] applicableFeatures = getApplicableFeatures(info.activityInfo.metaData);
            String displayMode = getDisplayMode(info.activityInfo.metaData);

            TestListItem item = TestListItem.newTest(title, testName, intent, requiredFeatures,
                     requiredConfigs, requiredActions, excludedFeatures, applicableFeatures,
                     displayMode);

            String testCategory = getTestCategory(mContext, info.activityInfo.metaData);
            addTestToCategory(testsByCategory, testCategory, item);
        }

        return testsByCategory;
    }

    static String getTestCategory(Context context, Bundle metaData) {
        String testCategory = null;
        if (metaData != null) {
            testCategory = metaData.getString(TEST_CATEGORY_META_DATA);
        }
        if (testCategory != null) {
            return testCategory;
        } else {
            return context.getString(R.string.test_category_other);
        }
    }

    static String getTestParent(Bundle metaData) {
        return metaData != null ? metaData.getString(TEST_PARENT_META_DATA) : null;
    }

    static String[] getRequiredFeatures(Bundle metaData) {
        if (metaData == null) {
            return null;
        } else {
            String value = metaData.getString(TEST_REQUIRED_FEATURES_META_DATA);
            if (value == null) {
                return null;
            } else {
                return value.split("":"");
            }
        }
    }

    static String[] getRequiredActions(Bundle metaData) {
        if (metaData == null) {
            return null;
        } else {
            String value = metaData.getString(TEST_REQUIRED_ACTIONS_META_DATA);
            if (value == null) {
                return null;
            } else {
                return value.split("":"");
            }
        }
    }

    static String[] getRequiredConfigs(Bundle metaData) {
        if (metaData == null) {
            return null;
        } else {
            String value = metaData.getString(TEST_REQUIRED_CONFIG_META_DATA);
            if (value == null) {
                return null;
            } else {
                return value.split("":"");
            }
        }
    }

    static String[] getExcludedFeatures(Bundle metaData) {
        if (metaData == null) {
            return null;
        } else {
            String value = metaData.getString(TEST_EXCLUDED_FEATURES_META_DATA);
            if (value == null) {
                return null;
            } else {
                return value.split("":"");
            }
        }
    }

    static String[] getApplicableFeatures(Bundle metaData) {
        if (metaData == null) {
            return null;
        } else {
            String value = metaData.getString(TEST_APPLICABLE_FEATURES_META_DATA);
            if (value == null) {
                return null;
            } else {
                return value.split("":"");
            }
        }
    }

    /**
     * Gets the configuration of the display mode per test. The default value is multi_display_mode.
     *
     * @param metaData Given metadata of the display mode.
     * @return A string representing the display mode of the test.
     */
    static String getDisplayMode(Bundle metaData) {
        if (metaData == null) {
            return MULTIPLE_DISPLAY_MODE;
        }
        String displayMode = metaData.getString(TEST_DISPLAY_MODE_META_DATA);
        return displayMode == null ? MULTIPLE_DISPLAY_MODE : displayMode;
    }

    static String getTitle(Context context, ActivityInfo activityInfo) {
        if (activityInfo.labelRes != 0) {
            return context.getString(activityInfo.labelRes);
        } else {
            return activityInfo.name;
        }
    }

    static Intent getActivityIntent(ActivityInfo activityInfo) {
        Intent intent = new Intent();
        intent.setClassName(activityInfo.packageName, activityInfo.name);
        return intent;
    }

    static void addTestToCategory(Map<String, List<TestListItem>> testsByCategory,
            String testCategory, TestListItem item) {
        List<TestListItem> tests;
        if (testsByCategory.containsKey(testCategory)) {
            tests = testsByCategory.get(testCategory);
        } else {
            tests = new ArrayList<TestListItem>();
        }
        testsByCategory.put(testCategory, tests);
        tests.add(item);
    }

    private boolean hasAnyFeature(String[] features) {
        if (features != null) {
            PackageManager packageManager = mContext.getPackageManager();
            for (String feature : features) {
                if (packageManager.hasSystemFeature(feature)) {
                    return true;
                }
            }
            Log.v(LOG_TAG, ""Missing features "" + Arrays.toString(features));
        }
        return false;
    }

    private boolean hasAllFeatures(String[] features) {
        if (features != null) {
            PackageManager packageManager = mContext.getPackageManager();
            for (String feature : features) {
                if (!packageManager.hasSystemFeature(feature)) {
                    Log.v(LOG_TAG, ""Missing feature "" + feature);
                    return false;
                }
            }
        }
        return true;
    }

    private boolean hasAllActions(String[] actions) {
        if (actions != null) {
            PackageManager packageManager = mContext.getPackageManager();
            for (String action : actions) {
                Intent intent = new Intent(action);
                if (packageManager.queryIntentActivities(intent, /* flags= */ 0).isEmpty()) {
                    Log.v(LOG_TAG, ""Missing action "" + action);
                    return false;
                }
            }
        }
        return true;
    }

    private boolean matchAllConfigs(String[] configs) {
        if (configs != null) {
            for (String config : configs) {
                switch (config) {
                    case CONFIG_NO_EMULATOR:
                        try {
                            Method getStringMethod = ClassLoader.getSystemClassLoader()
                                .loadClass(""android.os.SystemProperties"")
                                .getMethod(""get"", String.class);
                            String emulatorKernel = (String) getStringMethod.invoke(""0"",
                                    ""ro.boot.qemu"");
                            if (emulatorKernel.equals(""1"")) {
                                return false;
                            }
                        } catch (Exception e) {
                            Log.e(LOG_TAG, ""Exception while checking for emulator support."", e);
                        }
                        break;
                    case CONFIG_VOICE_CAPABLE:
                        TelephonyManager telephonyManager = mContext.getSystemService(
                                TelephonyManager.class);
                        if (!telephonyManager.isVoiceCapable()) {
                            return false;
                        }
                        break;
                    case CONFIG_HAS_RECENTS:
                        if (!getSystemResourceFlag(""config_hasRecents"")) {
                            return false;
                        }
                        break;
                    case CONFIG_HDMI_SOURCE:
                        final int DEVICE_TYPE_HDMI_SOURCE = 4;
                        try {
                            if (!getHdmiDeviceType().contains(DEVICE_TYPE_HDMI_SOURCE)) {
                                return false;
                            }
                        } catch (Exception exception) {
                            Log.e(
                                    LOG_TAG,
                                    ""Exception while looking up HDMI device type."",
                                    exception);
                        }
                        break;
                    case CONFIG_QUICK_SETTINGS_SUPPORTED:
                        if (!getSystemResourceFlag(""config_quickSettingsSupported"")) {
                            return false;
                        }
                        break;
                    default:
                        break;
                }
            }
        }
        return true;
    }

    /**
     * Check if the test should be ran by the given display mode.
     *
     * @param mode Configs of the display mode.
     * @param currentMode Given display mode.
     * @return True if the given display mode matches the configs, otherwise, return false;
     */
    private boolean matchDisplayMode(String mode, String currentMode) {
        if (mode == null) {
            return false;
        }
        switch (mode) {
            case SINGLE_DISPLAY_MODE:
                return currentMode.equals(DisplayMode.UNFOLDED.toString());
            case MULTIPLE_DISPLAY_MODE:
                return true;
            default:
                return false;
        }
    }

    private boolean getSystemResourceFlag(String key) {
        final Resources systemRes = mContext.getResources().getSystem();
        final int id = systemRes.getIdentifier(key, ""bool"", ""android"");
        if (id == Resources.ID_NULL) {
            // The flag being queried should exist in
            // frameworks/base/core/res/res/values/config.xml.
            throw new RuntimeException(""System resource flag "" + key + "" not found"");
        }
        return systemRes.getBoolean(id);
    }

    private static List<Integer> getHdmiDeviceType()
            throws InvocationTargetException, IllegalAccessException, ClassNotFoundException,
                    NoSuchMethodException {
        Method getStringMethod =
                ClassLoader.getSystemClassLoader()
                        .loadClass(""android.os.SystemProperties"")
                        .getMethod(""get"", String.class);
        String deviceTypesStr = (String) getStringMethod.invoke(null, ""ro.hdmi.device_type"");
        if (deviceTypesStr.equals("""")) {
            return new ArrayList<>();
        }
        return Arrays.stream(deviceTypesStr.split("",""))
                .map(Integer::parseInt)
                .collect(Collectors.toList());
    }

    List<TestListItem> filterTests(List<TestListItem> tests, String mode) {
        List<TestListItem> filteredTests = new ArrayList<>();
        for (TestListItem test : tests) {
            if (!hasAnyFeature(test.excludedFeatures) && hasAllFeatures(test.requiredFeatures)
                    && hasAllActions(test.requiredActions)
                    && matchAllConfigs(test.requiredConfigs)
                    && matchDisplayMode(test.displayMode, mode)) {
                if (test.applicableFeatures == null || hasAnyFeature(test.applicableFeatures)) {
                    // Add suffix in test name if the test is in the folded mode.
                    test.testName = setTestNameSuffix(mode, test.testName);
                    filteredTests.add(test);
                } else {
                    Log.d(LOG_TAG, ""Skipping "" + test.testName + "" due to metadata filtering"");
                }
            } else {
                Log.d(LOG_TAG, ""Skipping "" + test.testName + "" due to metadata filtering"");
            }
        }
        return filteredTests;
    }
}"	""	""	"recents"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.hardware.camera2.cts.HeifWriterTest"	"isInstantApp"	"CtsCameraTestCases"	"/home/gpoor/cts-12-source/cts/tests/camera/src/android/hardware/camera2/cts/HeifWriterTest.java"	""	"/*
 *.
 */

package android.camera.cts;

import static android.hardware.camera2.cts.CameraTestUtils.SESSION_CONFIGURE_TIMEOUT_MS;
import static android.hardware.camera2.cts.CameraTestUtils.CAPTURE_RESULT_TIMEOUT_MS;
import static android.hardware.camera2.cts.CameraTestUtils.SimpleCaptureCallback;
import static android.hardware.camera2.cts.CameraTestUtils.getValueNotNull;

import static androidx.heifwriter.HeifWriter.INPUT_MODE_SURFACE;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import android.graphics.ImageFormat;
import android.graphics.SurfaceTexture;
import android.hardware.camera2.CameraCharacteristics;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CaptureRequest;
import android.hardware.camera2.CaptureResult;
import android.hardware.camera2.cts.helpers.StaticMetadata;
import android.hardware.camera2.cts.testcases.Camera2AndroidTestCase;
import android.hardware.camera2.params.OutputConfiguration;
import android.media.MediaExtractor;
import android.media.MediaFormat;
import android.media.MediaMetadataRetriever;
import android.os.Environment;
import android.os.SystemClock;
import android.util.Log;
import android.util.Size;
import android.view.Surface;

import androidx.heifwriter.HeifWriter;

import com.android.compatibility.common.util.MediaUtils;
import com.android.ex.camera2.blocking.BlockingSessionCallback;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.junit.runners.Parameterized;
import org.junit.runner.RunWith;
import org.junit.Test;

@RunWith(Parameterized.class)
public class HeifWriterTest extends Camera2AndroidTestCase {
    private static final String TAG = HeifWriterTest.class.getSimpleName();
    private static final boolean VERBOSE = Log.isLoggable(TAG, Log.VERBOSE);
    private static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);

    private String mFilePath;
    private static final String OUTPUT_FILENAME = ""output.heic"";

    @Override
    public void setUp() throws Exception {
        super.setUp();

        File filesDir = mContext.getPackageManager().isInstantApp()
                ? mContext.getFilesDir()
                : mContext.getExternalFilesDir(null);

        mFilePath = filesDir.getPath();
    }

    @Override
    public void tearDown() throws Exception {
        super.tearDown();
    }"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.implicitapp.ImplicitActivity"	"finish"	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/ImplicitlyExposedApp/src/com/android/cts/implicitapp/ImplicitActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.implicitapp;

import android.app.Activity;
import android.content.Intent;
import android.content.pm.PackageInfo;
import android.content.pm.ResolveInfo;
import android.content.pm.PackageManager.NameNotFoundException;
import android.net.Uri;
import android.os.Bundle;
import android.util.Log;

import com.android.cts.util.TestResult;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.List;

public class ImplicitActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        boolean canAccessInstantApp = false;
        String exception = null;
        try {
            canAccessInstantApp = tryAccessingInstantApp();
        } catch (Throwable t) {
            exception = t.getClass().getName();
        }

        TestResult.getBuilder()
                .setPackageName(""com.android.cts.implicitapp"")
                .setComponentName(""ImplicitActivity"")
                .setStatus(""PASS"")
                .setException(exception)
                .setEphemeralPackageInfoExposed(canAccessInstantApp)
                .build()
                .broadcast(this);
        finish();
    }

    private boolean tryAccessingInstantApp() throws NameNotFoundException {
        final PackageInfo info = getPackageManager()
                .getPackageInfo(""com.android.cts.ephemeralapp1"", 0 /*flags*/);
        return (info != null);
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"android.hardware.multiprocess.camera.cts.MediaRecorderCameraActivity"	"isInstantApp"	"CtsCameraTestCases"	"/home/gpoor/cts-12-source/cts/tests/camera/src/android/hardware/multiprocess/camera/cts/MediaRecorderCameraActivity.java"	""	"public void test/*
 *.
 */

package android.hardware.multiprocess.camera.cts;

import android.app.Activity;
import android.camera.cts.R;
import android.media.MediaRecorder;
import android.os.Bundle;
import android.util.Log;
import android.view.SurfaceHolder;
import android.view.SurfaceView;
import android.view.ViewGroup;

import java.io.File;

/**
 * Activity implementing basic access of camera using MediaRecorder API.
 *
 * <p />
 * This will log all errors to {@link android.hardware.multiprocess.camera.cts.ErrorLoggingService}.
 */
public class MediaRecorderCameraActivity extends Activity implements SurfaceHolder.Callback {
    private static final String TAG = ""MediaRecorderCameraActivity"";

    private static final int VIDEO_WIDTH = 640;
    private static final int VIDEO_HEIGHT = 480;
    private static final int LAYOUT_WIDTH = VIDEO_WIDTH;
    private static final int LAYOUT_HEIGHT = VIDEO_HEIGHT;

    private String mOutputPath;
    private File mOutFile;
    private SurfaceView mSurfaceView;
    private ErrorLoggingService.ErrorServiceConnection mErrorServiceConnection;
    private MediaRecorder mMediaRecorder;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        Log.i(TAG, ""onCreate called."");
        super.onCreate(savedInstanceState);

        setContentView(R.layout.surface_view);

        mErrorServiceConnection = new ErrorLoggingService.ErrorServiceConnection(this);
        mErrorServiceConnection.start();

        mMediaRecorder = new MediaRecorder();

        File filesDir = getPackageManager().isInstantApp()
                ? getFilesDir()
                : getExternalFilesDir(null);

        mOutputPath = new File(filesDir, ""record.out"").getAbsolutePath();
    }

    @Override
    protected void onResume() {
        Log.i(TAG, ""onResume called."");
        super.onResume();
        try {

            mSurfaceView = (SurfaceView)this.findViewById(R.id.surface_view);
            ViewGroup.LayoutParams lp = mSurfaceView.getLayoutParams();
            lp.width = LAYOUT_WIDTH;
            lp.height = LAYOUT_HEIGHT;
            mSurfaceView.setLayoutParams(lp);

            SurfaceHolder holder = mSurfaceView.getHolder();
            holder.setFixedSize(LAYOUT_WIDTH, LAYOUT_HEIGHT);
            holder.addCallback(this);

        } catch (Throwable e) {
            mErrorServiceConnection.logAsync(TestConstants.EVENT_CAMERA_ERROR, TAG +
                    "" camera exception during connection: "" + e);
            Log.e(TAG, ""Runtime error: "" + e);
        }
    }

    @Override
    protected void onPause() {
        Log.i(TAG, ""onPause called."");
        super.onPause();
    }

    @Override
    protected void onDestroy() {
        Log.i(TAG, ""onDestroy called."");
        super.onDestroy();
        if (mErrorServiceConnection != null) {
            mErrorServiceConnection.stop();
            mErrorServiceConnection = null;
        }

        if (mOutFile != null && mOutFile.exists()) {
            mOutFile.delete();
        }

        if (mMediaRecorder != null) {
            mMediaRecorder.stop();
            mMediaRecorder.release();
        }
    }

    @Override
    public void surfaceCreated(SurfaceHolder holder) {
    }

    @Override
    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
        try {
            mOutFile = new File(mOutputPath);
            mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);
            mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.DEFAULT);
            mMediaRecorder.setPreviewDisplay(mSurfaceView.getHolder().getSurface());
            mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.DEFAULT);
            mMediaRecorder.setVideoSize(VIDEO_WIDTH, VIDEO_HEIGHT);
            mMediaRecorder.setOutputFile(mOutputPath);
            mMediaRecorder.prepare();
            mMediaRecorder.start();

            mErrorServiceConnection.logAsync(TestConstants.EVENT_CAMERA_CONNECT,
                    TAG + "" camera connected"");
        } catch (Throwable e) {
            mErrorServiceConnection.logAsync(TestConstants.EVENT_CAMERA_ERROR, TAG +
                    "" camera exception during connection: "" + e);
            Log.e(TAG, ""Runtime error: "" + e);
        }
    }

    @Override
    public void surfaceDestroyed(SurfaceHolder holder) {
    }
}"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
"3.15  . Instant Apps"	"3.15"	"C-0-7"	"3.15/C-0-7"	"03150000.670007"	"""C-0-7] MUST allow running Instant Apps to be accessed from the Recents function if the Recents function is available on the device. If device implementations support Instant Apps, they:"""	""	""	"instantapp recents"	""	""	""	""	""	""	""	""	"com.android.cts.userapptest.ClientTest"	""	""	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/UserAppTest/src/com/android/cts/userapptest/ClientTest.java"	""	"/*
 *.
 */

package com.android.cts.userapptest;

import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.fail;

import android.content.Intent;
import android.content.pm.ResolveInfo;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;

@RunWith(AndroidJUnit4.class)
public class ClientTest {
    /** Action to query for test activities */
    private static final String ACTION_QUERY_ACTIVITY =
            ""com.android.cts.instantappusertest.QUERY"";"	""	""	"instantapp"	""	""	""	""	""	""	""	""	""	""
