"Section"	"section_id"	"req_id"	"full_key"	"key_as_number"	"requirement"	"Test Availability"	"search_roots"	"search_terms"	"manual_search_terms"	"not_search_terms"	"not_files"	"max_matches"	"class_defs"	"methods"	"modules"	"protected"	"class_def"	"method"	"module"	"file_name"	"matched_files"	"methods_string"	"urls"	"method_text"	"matched_terms"	"qualified_method"	"Annotation?"	"New Req for S?"	"New CTS for S?"	"Comment(internal) e.g. why a test is not possible"	"CTS Bug Id"	"CDD Bug Id"	"Area"	"Shortened"	"Test Level"
"2.2.5  . Security Model"	"9.8"	"H-1-5"	"9.8/H-1-5"	"09080000.720105"	"""[9.8/H-1-5] MUST NOT supply buffered mic audio older than 30 seconds to the voice interaction service or similar entity. """	""	""	"second 30 transmit cdd older buffer"	""	""	""	""	""	""	""	""	"android.voiceinteraction.cts.VoiceInteractionTest"	"testAll"	"CtsVoiceInteractionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/voiceinteraction/src/android/voiceinteraction/cts/VoiceInteractionTest.java"	""	"/*
 *.
 */

package android.voiceinteraction.cts;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.fail;

import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.platform.test.annotations.AppModeFull;
import android.util.Log;
import android.voiceinteraction.common.Utils;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

import androidx.test.rule.ActivityTestRule;

// TODO: ideally we should split testAll() into multiple tests, and run at least one of them
// on instant
@AppModeFull(reason = ""DirectActionsTest is enough"")
public class VoiceInteractionTest extends AbstractVoiceInteractionTestCase {
    static final String TAG = ""VoiceInteractionTest"";
    private static final int TIMEOUT_MS = 30 * 1000;

    private TestStartActivity mTestActivity;
    private TestResultsReceiver mReceiver;
    private Bundle mResults;
    private final CountDownLatch mLatch = new CountDownLatch(1);

    @Rule
    public final ActivityTestRule<TestStartActivity> mActivityTestRule =
            new ActivityTestRule<>(TestStartActivity.class, false, false);

    @Before
    public void setUp() throws Exception {
        mReceiver = new TestResultsReceiver();
        mContext.registerReceiver(mReceiver, new IntentFilter(Utils.BROADCAST_INTENT));
        startTestActivity();
    }

    @After
    public void tearDown() throws Exception {
        if (mReceiver != null) {
            try {
                mContext.unregisterReceiver(mReceiver);
            } catch (IllegalArgumentException e) {
                // This exception is thrown if mReceiver in
                // the above call to unregisterReceiver is never registered.
                // If so, no harm done by ignoring this exception.
            }
            mReceiver = null;
        }
    }

    private void startTestActivity() throws Exception {
        Intent intent = new Intent();
        intent.setAction(""android.intent.action.TEST_START_ACTIVITY"");
        intent.setComponent(new ComponentName(mContext, TestStartActivity.class));
        Log.v(TAG, ""startTestActivity:"" + intent);
        mTestActivity = mActivityTestRule.launchActivity(intent);
    }"	""	""	"second 30"	""	""	""	""	""	""	""	""	""	""
"2.2.5  . Security Model"	"9.8"	"H-1-5"	"9.8/H-1-5"	"09080000.720105"	"""[9.8/H-1-5] MUST NOT supply buffered mic audio older than 30 seconds to the voice interaction service or similar entity. """	""	""	"second 30 transmit cdd older buffer"	""	""	""	""	""	""	""	""	"android.voiceinteraction.service.MainHotwordDetectionService"	"PersistableBundle"	""	"/home/gpoor/cts-12-source/cts/tests/tests/voiceinteraction/service/src/android/voiceinteraction/service/MainHotwordDetectionService.java"	""	"public void test/*
 *.
 */

package android.voiceinteraction.service;

import static android.media.AudioFormat.CHANNEL_IN_FRONT;

import android.media.AudioAttributes;
import android.media.AudioFormat;
import android.media.AudioRecord;
import android.media.MediaRecorder;
import android.os.Handler;
import android.os.Looper;
import android.os.ParcelFileDescriptor;
import android.os.PersistableBundle;
import android.os.Process;
import android.os.SharedMemory;
import android.service.voice.AlwaysOnHotwordDetector;
import android.service.voice.HotwordDetectedResult;
import android.service.voice.HotwordDetectionService;
import android.service.voice.HotwordRejectedResult;
import android.system.ErrnoException;
import android.text.TextUtils;
import android.util.Log;
import android.voiceinteraction.common.Utils;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.io.IOException;
import java.io.InputStream;
import java.util.function.IntConsumer;

import javax.annotation.concurrent.GuardedBy;

public class MainHotwordDetectionService extends HotwordDetectionService {
    static final String TAG = ""MainHotwordDetectionService"";

    public static final HotwordDetectedResult DETECTED_RESULT =
            new HotwordDetectedResult.Builder()
                    .setAudioChannel(CHANNEL_IN_FRONT)
                    .setConfidenceLevel(HotwordDetectedResult.CONFIDENCE_LEVEL_HIGH)
                    .setHotwordDetectionPersonalized(true)
                    .setHotwordDurationMillis(1000)
                    .setHotwordOffsetMillis(500)
                    .setHotwordPhraseId(5)
                    .setPersonalizedScore(10)
                    .setScore(15)
                    .build();
    public static final HotwordDetectedResult DETECTED_RESULT_AFTER_STOP_DETECTION =
            new HotwordDetectedResult.Builder()
                    .setScore(57)
                    .build();
    public static final HotwordDetectedResult DETECTED_RESULT_FOR_MIC_FAILURE =
            new HotwordDetectedResult.Builder()
                    .setScore(58)
                    .build();
    public static final HotwordRejectedResult REJECTED_RESULT =
            new HotwordRejectedResult.Builder()
                    .setConfidenceLevel(HotwordRejectedResult.CONFIDENCE_LEVEL_MEDIUM)
                    .build();

    private Handler mHandler;
    @NonNull
    private final Object mLock = new Object();

    @GuardedBy(""mLock"")
    private boolean mStopDetectionCalled;

    @GuardedBy(""mLock"")
    @Nullable
    private Runnable mDetectionJob;

    @Override
    public void onCreate() {
        super.onCreate();
        mHandler = Handler.createAsync(Looper.getMainLooper());
    }

    @Override
    public void onDetect(@NonNull AlwaysOnHotwordDetector.EventPayload eventPayload,
            long timeoutMillis, @NonNull Callback callback) {
        Log.d(TAG, ""onDetect for DSP source"");

        if (!canReadAudio()) {
            callback.onDetected(DETECTED_RESULT_FOR_MIC_FAILURE);
            return;
        }

        // TODO: Check the capture session (needs to be reflectively accessed).
        byte[] data = eventPayload.getTriggerAudio();
        if (data != null && data.length > 0) {
            // Create the unaccepted HotwordDetectedResult first to test the protection in the
            // onDetected callback function of HotwordDetectionService. When the bundle data of
            // HotwordDetectedResult is larger than max bundle size, it will throw the
            // IllegalArgumentException.
            PersistableBundle persistableBundle = new PersistableBundle();
            HotwordDetectedResult hotwordDetectedResult =
                    new HotwordDetectedResult.Builder()
                            .setExtras(persistableBundle)
                            .build();
            int key = 0;
            do {
                persistableBundle.putInt(Integer.toString(key), 0);
                key++;
            } while (Utils.getParcelableSize(persistableBundle)
                    <= HotwordDetectedResult.getMaxBundleSize());

            try {
                callback.onDetected(hotwordDetectedResult);
            } catch (IllegalArgumentException e) {
                callback.onDetected(DETECTED_RESULT);
            }
        } else {
            callback.onRejected(REJECTED_RESULT);
        }
    }

    @Override
    public void onDetect(
            @NonNull ParcelFileDescriptor audioStream,
            @NonNull AudioFormat audioFormat,
            @Nullable PersistableBundle options,
            @NonNull Callback callback) {
        Log.d(TAG, ""onDetect for external source"");

        if (callback == null) {
            Log.w(TAG, ""callback is null"");
            return;
        }
        if (audioStream == null) {
            Log.w(TAG, ""audioStream is null"");
            return;
        }

        long startTime = System.currentTimeMillis();
        try (InputStream fis =
                     new ParcelFileDescriptor.AutoCloseInputStream(audioStream)) {

            // We added the fake audio data and set ""hotword!"" string at the head. Then we simulated
            // to verify the audio data with ""hotword!"" in HotwordDetectionService. If the audio
            // data includes ""hotword!"", it means that the hotword is valid.
            while (fis.available() < 8) {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    // Nothing
                }
                if (System.currentTimeMillis() - startTime > 3000) {
                    Log.w(TAG, ""Over timeout"");
                    return;
                }
            }
            Log.d(TAG, ""fis.available() = "" + fis.available());
            byte[] buffer = new byte[8];
            fis.read(buffer, 0, 8);
            if(isSame(buffer, BasicVoiceInteractionService.FAKE_HOTWORD_AUDIO_DATA,
                    buffer.length)) {
                Log.d(TAG, ""call callback.onDetected"");
                callback.onDetected(DETECTED_RESULT);
            }
        } catch (IOException e) {
            Log.w(TAG, ""Failed to read data : "", e);
        }
    }

    @Override
    public void onDetect(@NonNull Callback callback) {
        Log.d(TAG, ""onDetect for Mic source"");
        synchronized (mLock) {
            if (mDetectionJob != null) {
                throw new IllegalStateException(""onDetect called while already detecting"");
            }
            if (!mStopDetectionCalled) {
                // Delaying this allows us to test other flows, such as stopping detection. It's
                // also more realistic to schedule it onto another thread.
                mDetectionJob = () -> {
                    Log.d(TAG, ""Sending detected result"");

                    if (canReadAudio()) {
                        callback.onDetected(DETECTED_RESULT);
                    } else {
                        callback.onDetected(DETECTED_RESULT_FOR_MIC_FAILURE);
                    }
                };
                mHandler.postDelayed(mDetectionJob, 1500);
            } else {
                Log.d(TAG, ""Sending detected result after stop detection"");
                // We can't store and use this callback in onStopDetection (not valid anymore there), so
                // instead we trigger detection again to report the event.
                callback.onDetected(DETECTED_RESULT_AFTER_STOP_DETECTION);
            }
        }
    }

    @Override
    public void onStopDetection() {
        super.onStopDetection();
        synchronized (mLock) {
            mHandler.removeCallbacks(mDetectionJob);
            mDetectionJob = null;
            mStopDetectionCalled = true;
        }
    }

    @Override
    public void onUpdateState(
            @Nullable PersistableBundle options,
            @Nullable SharedMemory sharedMemory,
            long callbackTimeoutMillis,
            @Nullable IntConsumer statusCallback) {
        super.onUpdateState(options, sharedMemory, callbackTimeoutMillis, statusCallback);
        Log.d(TAG, ""onUpdateState"");

        if (options != null) {
            if (options.getInt(Utils.KEY_TEST_SCENARIO, -1)
                    == Utils.HOTWORD_DETECTION_SERVICE_ON_UPDATE_STATE_CRASH) {
                Log.d(TAG, ""Crash itself. Pid: "" + Process.myPid());
                Process.killProcess(Process.myPid());
                return;
            }
            String fakeData = options.getString(BasicVoiceInteractionService.KEY_FAKE_DATA);
            if (!TextUtils.equals(fakeData, BasicVoiceInteractionService.VALUE_FAKE_DATA)) {
                Log.d(TAG, ""options : data is not the same"");
                return;
            }
        }

        if (sharedMemory != null) {
            try {
                sharedMemory.mapReadWrite();
                Log.d(TAG, ""sharedMemory : is not read-only"");
                return;
            } catch (ErrnoException e) {
                // For read-only case
            } finally {
                sharedMemory.close();
            }
        }

        // Report success
        Log.d(TAG, ""onUpdateState success"");
        if (statusCallback != null) {
            statusCallback.accept(INITIALIZATION_STATUS_SUCCESS);
        }
    }

    private boolean isSame(byte[] array1, byte[] array2, int length) {
        if (length <= 0) {
            return false;
        }
        if (array1 == null || array2 == null || array1.length < length || array2.length < length) {
            return false;
        }
        for (int i = 0; i < length; i++) {
            if (array1[i] != array2[i]) {
                return false;
            }
        }
        return true;
    }

    private boolean canReadAudio() {
        int bytesPerSample = 2; // for ENCODING_PCM_16BIT
        int sampleRate = 16000;
        int bytesPerSecond = bytesPerSample * sampleRate; // for single channel
        AudioRecord record =
                new AudioRecord.Builder()
                        .setAudioAttributes(
                                new AudioAttributes.Builder()
                                        .setInternalCapturePreset(MediaRecorder.AudioSource.HOTWORD)
                                        .build())
                        .setAudioFormat(
                                new AudioFormat.Builder()
                                        .setChannelMask(AudioFormat.CHANNEL_IN_MONO)
                                        .setEncoding(AudioFormat.ENCODING_PCM_16BIT)
                                        .setSampleRate(sampleRate)
                                        .build())
                        .setBufferSizeInBytes(bytesPerSecond)
                        .build();
        if (record.getState() != AudioRecord.STATE_INITIALIZED) {
            Log.e(TAG, ""Failed to initialize AudioRecord"");
            record.release();
            return false;
        }

        record.startRecording();
        try {
            byte[] buffer = new byte[bytesPerSecond]; // read 1 second of audio
            int numBytes = 0;
            while (numBytes < buffer.length) {
                int bytesRead =
                        record.read(buffer, numBytes, Math.min(1024, buffer.length - numBytes));
                if (bytesRead < 0) {
                    Log.e(TAG, ""Error reading from mic: "" + bytesRead);
                    return false;
                }
                numBytes += bytesRead;
            }
            // The audio data will be zero on virtual device, so it would be better to skip to
            // check the audio data.
            if (Utils.isVirtualDevice()) {
                return true;
            }
            for (byte b : buffer) {
                // TODO: Maybe check that some portion of the bytes are non-zero.
                if (b != 0) {
                    return true;
                }
            }
            return false;
        } finally {
            record.release();
        }
    }
}"	""	""	"second 30 buffer"	""	""	""	""	""	""	""	""	""	""
"2.2.5  . Security Model"	"9.8"	"H-1-5"	"9.8/H-1-5"	"09080000.720105"	"""[9.8/H-1-5] MUST NOT supply buffered mic audio older than 30 seconds to the voice interaction service or similar entity. """	""	""	"second 30 transmit cdd older buffer"	""	""	""	""	""	""	""	""	"android.voiceinteraction.cts.HotwordDetectionServiceBasicTest"	"testHotwordDetectionService_concurrentCapture"	"CtsVoiceInteractionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/voiceinteraction/src/android/voiceinteraction/cts/HotwordDetectionServiceBasicTest.java"	""	"@RequiresDevice
    public void testHotwordDetectionService_concurrentCapture() throws Throwable {
        // Create SoftwareHotwordDetector and wait the HotwordDetectionService ready
        testHotwordDetection(Utils.HOTWORD_DETECTION_SERVICE_FROM_SOFTWARE_TRIGGER_TEST,
                Utils.HOTWORD_DETECTION_SERVICE_TRIGGER_RESULT_INTENT,
                Utils.HOTWORD_DETECTION_SERVICE_TRIGGER_SUCCESS);

        SystemUtil.runWithShellPermissionIdentity(() -> {
            AudioRecord record =
                    new AudioRecord.Builder()
                            .setAudioAttributes(
                                    new AudioAttributes.Builder()
                                            .setInternalCapturePreset(MediaRecorder.AudioSource.MIC)
                                            .build())
                            .setAudioFormat(
                                    new AudioFormat.Builder()
                                            .setChannelMask(AudioFormat.CHANNEL_IN_MONO)
                                            .setEncoding(AudioFormat.ENCODING_PCM_16BIT)
                                            .build())
                            .setBufferSizeInBytes(10240) // something large enough to not fail
                            .build();
            assertThat(record.getState()).isEqualTo(AudioRecord.STATE_INITIALIZED);

            try {
                record.startRecording();
                verifyDetectedResult(
                        performAndGetDetectionResult(
                                Utils.HOTWORD_DETECTION_SERVICE_MIC_ONDETECT_TEST),
                        MainHotwordDetectionService.DETECTED_RESULT);
                // TODO: Test that it still works after restarting the process or killing audio
                //  server.
            } finally {
                record.release();
            }
        });
    }"	""	""	"buffer"	""	""	""	""	""	""	""	""	""	""
"2.2.5  . Security Model"	"9.8"	"H-1-5"	"9.8/H-1-5"	"09080000.720105"	"""[9.8/H-1-5] MUST NOT supply buffered mic audio older than 30 seconds to the voice interaction service or similar entity. """	""	""	"second 30 transmit cdd older buffer"	""	""	""	""	""	""	""	""	"android.voiceinteraction.cts.LocalVoiceInteractionTest"	"testLifecycle"	"CtsVoiceInteractionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/voiceinteraction/src/android/voiceinteraction/cts/LocalVoiceInteractionTest.java"	""	"public void testLifecycle() throws Exception {
        assertWithMessage(""Doesn't support LocalVoiceInteraction"")
                .that(mTestActivity.isLocalVoiceInteractionSupported()).isTrue();
        mTestActivity.startLocalInteraction(mLatchStart);
        if (!mLatchStart.await(TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
            fail(""Failed to start voice interaction in "" + TIMEOUT_MS + ""msec"");
            return;
        }
        mTestActivity.stopLocalInteraction(mLatchStop);
        if (!mLatchStop.await(TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
            fail(""Failed to stop voice interaction in "" + TIMEOUT_MS + ""msec"");
            return;
        }
        mTestActivity.finish();
    }
}"	""	""	"second"	""	""	""	""	""	""	""	""	""	""
"2.2.5  . Security Model"	"9.8"	"H-1-5"	"9.8/H-1-5"	"09080000.720105"	"""[9.8/H-1-5] MUST NOT supply buffered mic audio older than 30 seconds to the voice interaction service or similar entity. """	""	""	"second 30 transmit cdd older buffer"	""	""	""	""	""	""	""	""	"android.voiceinteraction.service.MainInteractionSession"	"hasShortcutHostPermission"	""	"/home/gpoor/cts-12-source/cts/tests/tests/voiceinteraction/service/src/android/voiceinteraction/service/MainInteractionSession.java"	""	"public void test/*
 *.
 */

package android.voiceinteraction.service;

import android.app.VoiceInteractor;
import android.content.Context;
import android.content.Intent;
import android.content.pm.LauncherApps;
import android.os.AsyncTask;
import android.os.Bundle;
import android.service.voice.VoiceInteractionSession;
import android.util.Log;
import android.voiceinteraction.common.Utils;

import java.util.ArrayList;
import java.util.List;

public class MainInteractionSession extends VoiceInteractionSession {
    static final String TAG = ""MainInteractionSession"";

    Intent mStartIntent;
    List<MyTask> mUsedTasks = new ArrayList<MyTask>();

    MainInteractionSession(Context context) {
        super(context);
    }

    @Override
    public void onCreate() {
        super.onCreate();
        Intent sessionStarted = new Intent();
        sessionStarted.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
        if (!getContext().getSystemService(LauncherApps.class).hasShortcutHostPermission()) {
            sessionStarted.putExtra(""error"", ""Does not have shortcut permission"");
        }
        sessionStarted.setClassName(""android.voiceinteraction.cts"",
                ""android.voiceinteraction.cts.VoiceInteractionTestReceiver"");
        Log.i(TAG, ""onCreate(): broadcast intent="" + sessionStarted);
        getContext().sendBroadcast(sessionStarted);
    }

    @Override
    public void onDestroy() {
        Log.i(TAG, ""Canceling the Asynctask in onDestroy()"");
        for (MyTask t : mUsedTasks) {
            t.cancel(true);
        }
        super.onDestroy();
    }

    @Override
    public void onShow(Bundle args, int showFlags) {
        if (args == null) {
            Log.e(TAG, ""onshow() received null args"");
            return;
        }
        mStartIntent = args.getParcelable(""intent"");
        if (mStartIntent != null) {
            startVoiceActivity(mStartIntent);
        } else if ((showFlags & SHOW_SOURCE_ACTIVITY) == SHOW_SOURCE_ACTIVITY) {
            // Verify args
            if (args == null
                    || !Utils.PRIVATE_OPTIONS_VALUE.equals(
                            args.getString(Utils.PRIVATE_OPTIONS_KEY))) {
                throw new IllegalArgumentException(""Incorrect arguments for SHOW_SOURCE_ACTIVITY"");
            }
        }
    }

    void assertPromptFromTestApp(CharSequence prompt, Bundle extras) {
        String str = prompt.toString();
        if (str.equals(Utils.TEST_PROMPT)) {
            Log.i(TAG, ""prompt received ok from TestApp in Session"");
        } else {
            Utils.addErrorResult(extras, ""Invalid prompt received: "" + str);
        }
    }

    synchronized MyTask newTask() {
        MyTask t = new MyTask();
        mUsedTasks.add(t);
        return t;
    }

    @Override
    public boolean[] onGetSupportedCommands(String[] commands) {
        boolean[] results = new boolean[commands.length];
        Log.i(TAG, ""in onGetSupportedCommands"");
        for (int idx = 0; idx < commands.length; idx++) {
            results[idx] = Utils.TEST_COMMAND.equals(commands[idx]);
            Log.i(TAG, ""command "" + commands[idx] + "", support = "" + results[idx]);
        }
        return results;
    }

    @Override
    public void onRequestConfirmation(ConfirmationRequest request) {
        Bundle extras = request.getExtras();
        CharSequence prompt = request.getVoicePrompt().getVoicePromptAt(0);
        Log.i(TAG, ""in Session onRequestConfirmation recvd. prompt="" + prompt +
                "", extras="" + Utils.toBundleString(extras));
        assertPromptFromTestApp(prompt, extras);
        AsyncTaskArg asyncTaskArg = new AsyncTaskArg().setRequest(request).setExtras(extras);
        if (isTestTypeCancel(extras)) {
            Log.i(TAG, ""Sending Cancel."");
            newTask().execute(
                    asyncTaskArg.setTestType(Utils.TestCaseType.CONFIRMATION_REQUEST_CANCEL_TEST));
        } else {
            Log.i(TAG, ""in Session sending sendConfirmationResult. "" +
                    Utils.toBundleString(extras));
            newTask().execute(
                    asyncTaskArg.setTestType(Utils.TestCaseType.CONFIRMATION_REQUEST_TEST));
        }
    }

    @Override
    public void onRequestCompleteVoice(CompleteVoiceRequest request) {
        Bundle extras = request.getExtras();
        CharSequence prompt = request.getVoicePrompt().getVoicePromptAt(0);
        Log.i(TAG, ""in Session onRequestCompleteVoice recvd. message="" +
                prompt + "", extras="" + Utils.toBundleString(extras));
        assertPromptFromTestApp(prompt, extras);
        AsyncTaskArg asyncTaskArg = new AsyncTaskArg().setRequest(request).setExtras(extras);
        if (isTestTypeCancel(extras)) {
            Log.i(TAG, ""Sending Cancel."");
            newTask().execute(
                    asyncTaskArg.setTestType(Utils.TestCaseType.COMPLETION_REQUEST_CANCEL_TEST));
        } else {
            Log.i(TAG, ""in Session sending sendConfirmationResult. "" +
                    Utils.toBundleString(extras));
            newTask().execute(
                    asyncTaskArg.setTestType(Utils.TestCaseType.COMPLETION_REQUEST_TEST));
        }
    }

    @Override
    public void onRequestAbortVoice(AbortVoiceRequest request) {
        Bundle extras = request.getExtras();
        CharSequence prompt = request.getVoicePrompt().getVoicePromptAt(0);
        Log.i(TAG, ""in Session onRequestAbortVoice recvd. message="" +
                prompt + "", extras="" + Utils.toBundleString(extras));
        assertPromptFromTestApp(prompt, extras);
        AsyncTaskArg asyncTaskArg = new AsyncTaskArg().setRequest(request).setExtras(extras);
        if (isTestTypeCancel(extras)) {
            Log.i(TAG, ""Sending Cancel."");
            newTask().execute(
                    asyncTaskArg.setTestType(Utils.TestCaseType.ABORT_REQUEST_CANCEL_TEST));
        } else {
            Log.i(TAG, ""in Session sending sendAbortResult. "" +
                Utils.toBundleString(extras));
            newTask().execute(asyncTaskArg.setTestType(Utils.TestCaseType.ABORT_REQUEST_TEST));
        }
    }

    @Override
    public void onRequestCommand(CommandRequest request) {
        Bundle extras = request.getExtras();
        Log.i(TAG, ""in Session onRequestCommand recvd. Bundle = "" +
                Utils.toBundleString(extras));

        // Make sure that the input request has Utils.TEST_COMMAND sent by TestApp
        String command = request.getCommand();
        if (command.equals(Utils.TEST_COMMAND)) {
            Log.i(TAG, ""command received ok from TestApp in Session"");
        } else {
            Utils.addErrorResult(extras, ""Invalid TEST_COMMAND received: "" + command);
        }
        // Add a field and value in the bundle to be sent to TestApp.
        // TestApp will ensure that these are transmitted correctly.
        extras.putString(Utils.TEST_ONCOMMAND_RESULT, Utils.TEST_ONCOMMAND_RESULT_VALUE);
        AsyncTaskArg asyncTaskArg = new AsyncTaskArg().setRequest(request).setExtras(extras);
        if (isTestTypeCancel(extras)) {
            Log.i(TAG, ""Sending Cancel."");
            newTask().execute(
                    asyncTaskArg.setTestType(Utils.TestCaseType.COMMANDREQUEST_CANCEL_TEST));
        } else {
            Log.i(TAG, ""in Session sending sendResult. "" +
                    Utils.toBundleString(extras) + "", string_in_bundle: "" +
                    Utils.TEST_ONCOMMAND_RESULT + "" = "" + Utils.TEST_ONCOMMAND_RESULT_VALUE);
            newTask().execute(asyncTaskArg.setTestType(Utils.TestCaseType.COMMANDREQUEST_TEST));
        }
    }

    void assertPickOptionsFromTestApp(VoiceInteractor.PickOptionRequest.Option[] options,
            Bundle extras) {
        if ((options.length != 2) ||
            !options[0].getLabel().toString().equals(Utils.PICKOPTON_1) ||
            !options[1].getLabel().toString().equals(Utils.PICKOPTON_2)) {
            Utils.addErrorResult(extras, ""Pickoptions Not received correctly in Session."");
        } else {
            Log.i(TAG, ""Pickoptions received ok from TestApp in Session"");
        }
    }

    @Override
    public void onRequestPickOption(PickOptionRequest request) {
        Bundle extras = request.getExtras();
        CharSequence prompt = request.getVoicePrompt().getVoicePromptAt(0);
        Log.i(TAG, ""in Session onRequestPickOption recvd. message="" +
                prompt + "", options = "" + Utils.toOptionsString(request.getOptions()) +
                "", extras="" + Utils.toBundleString(extras));
        VoiceInteractor.PickOptionRequest.Option[] picked
            = new VoiceInteractor.PickOptionRequest.Option[1];
        assertPromptFromTestApp(prompt, extras);
        assertPickOptionsFromTestApp(request.getOptions(), extras);
        picked[0] = new VoiceInteractor.PickOptionRequest.Option(Utils.PICKOPTON_3, 0);
        AsyncTaskArg asyncTaskArg = new AsyncTaskArg().setRequest(request)
                .setExtras(extras)
                .setPickedOptions(picked);
        if (isTestTypeCancel(extras)) {
            Log.i(TAG, ""in MainInteractionSession, Sending Cancel."");
            newTask().execute(
                    asyncTaskArg.setTestType(Utils.TestCaseType.PICKOPTION_REQUEST_CANCEL_TEST));
        } else {
            Log.i(TAG, ""in MainInteractionSession sending sendPickOptionResult. "" +
                    Utils.toBundleString(extras));
            newTask().execute(asyncTaskArg.setTestType(Utils.TestCaseType.PICKOPTION_REQUEST_TEST));
        }
    }

    public static final boolean isTestTypeCancel(Bundle extras) {
        Utils.TestCaseType testCaseType;
        try {
            testCaseType = Utils.TestCaseType.valueOf(extras.getString(Utils.TESTCASE_TYPE));
        } catch (IllegalArgumentException | NullPointerException e) {
            Log.wtf(TAG, ""unexpected testCaseType value in Bundle received"", e);
            return true;
        }
        return testCaseType == Utils.TestCaseType.COMPLETION_REQUEST_CANCEL_TEST ||
                testCaseType == Utils.TestCaseType.COMMANDREQUEST_CANCEL_TEST ||
                testCaseType == Utils.TestCaseType.CONFIRMATION_REQUEST_CANCEL_TEST ||
                testCaseType == Utils.TestCaseType.PICKOPTION_REQUEST_CANCEL_TEST ||
                testCaseType == Utils.TestCaseType.ABORT_REQUEST_CANCEL_TEST;
    }

    private class AsyncTaskArg {
        ConfirmationRequest confReq;
        CommandRequest commandReq;
        CompleteVoiceRequest compReq;
        AbortVoiceRequest abortReq;
        PickOptionRequest pickReq;
        Bundle extras;
        VoiceInteractor.PickOptionRequest.Option[] picked;
        Utils.TestCaseType testType;

        AsyncTaskArg setTestType(Utils.TestCaseType t) {testType = t; return this;}
        AsyncTaskArg setRequest(CommandRequest r) {commandReq = r; return this;}
        AsyncTaskArg setRequest(ConfirmationRequest r) {confReq = r; return this;}
        AsyncTaskArg setRequest(CompleteVoiceRequest r) {compReq = r; return this;}
        AsyncTaskArg setRequest(AbortVoiceRequest r) {abortReq = r; return this;}
        AsyncTaskArg setRequest(PickOptionRequest r) {pickReq = r; return this;}
        AsyncTaskArg setExtras(Bundle e) {extras = e;  return this;}
        AsyncTaskArg setPickedOptions(VoiceInteractor.PickOptionRequest.Option[] p) {
            picked = p;
            return this;
        }
    }

    private class MyTask extends AsyncTask<AsyncTaskArg, Void, Void> {
        @Override
        protected Void doInBackground(AsyncTaskArg... params) {
            AsyncTaskArg arg = params[0];
            Log.i(TAG, ""in MyTask - doInBackground: requestType = "" +
                    arg.testType.toString());
            switch (arg.testType) {
                case ABORT_REQUEST_CANCEL_TEST:
                    arg.abortReq.cancel();
                    break;
                case ABORT_REQUEST_TEST:
                    arg.abortReq.sendAbortResult(arg.extras);
                    break;
                case COMMANDREQUEST_CANCEL_TEST:
                    arg.commandReq.cancel();
                    break;
                case COMMANDREQUEST_TEST:
                    Log.i(TAG, ""in MyTask sendResult. "" +
                            Utils.toBundleString(arg.extras) + "", string_in_bundle: "" +
                            Utils.TEST_ONCOMMAND_RESULT + "" = "" +
                            Utils.TEST_ONCOMMAND_RESULT_VALUE);
                    arg.commandReq.sendResult(arg.extras);
                    break;
                case COMPLETION_REQUEST_CANCEL_TEST:
                    arg.compReq.cancel();
                    break;
                case COMPLETION_REQUEST_TEST:
                    arg.compReq.sendCompleteResult(arg.extras);
                    break;
                case CONFIRMATION_REQUEST_CANCEL_TEST:
                     arg.confReq.cancel();
                     break;
                case CONFIRMATION_REQUEST_TEST:
                     arg.confReq.sendConfirmationResult(true, arg.extras);
                     break;
                case PICKOPTION_REQUEST_CANCEL_TEST:
                     arg.pickReq.cancel();
                     break;
                case PICKOPTION_REQUEST_TEST:
                     StringBuilder buf = new StringBuilder();
                     for (VoiceInteractor.PickOptionRequest.Option s : arg.picked) {
                         buf.append(""option: "" + s.toString() + "", "");
                     }
                     Log.i(TAG, ""******** Sending PickoptionResult: "" +
                             ""picked: size = "" + arg.picked.length +
                             "", Options = "" + buf.toString() +
                             "", Bundle: "" + Utils.toBundleString(arg.extras));
                     arg.pickReq.sendPickOptionResult(arg.picked, arg.extras);
                     break;
               default:
                   Log.i(TAG, ""Doing nothing for the testcase type: "" + arg.testType);
                   break;
            }
            return null;
        }
    }
}"	""	""	"transmit"	""	""	""	""	""	""	""	""	""	""
"2.2.5  . Security Model"	"9.8"	"H-1-5"	"9.8/H-1-5"	"09080000.720105"	"""[9.8/H-1-5] MUST NOT supply buffered mic audio older than 30 seconds to the voice interaction service or similar entity. """	""	""	"second 30 transmit cdd older buffer"	""	""	""	""	""	""	""	""	"android.voiceinteraction.cts.DirectActionsTest"	"testNotifyDirectActionsChanged"	"CtsVoiceInteractionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/voiceinteraction/src/android/voiceinteraction/cts/DirectActionsTest.java"	""	"public void testNotifyDirectActionsChanged() throws Exception {
        mActivityControl.startActivity();
        mSessionControl.startVoiceInteractionSession();
        try {
            // Get the actions to set up the VoiceInteractor
            mSessionControl.getDirectActions();

            assertThat(mSessionControl.detectDirectActionsInvalidated(
                    () -> mActivityControl.invalidateDirectActions())).isTrue();
        } finally {
            mSessionControl.stopVoiceInteractionSession();
            mActivityControl.finishActivity();
        }
    }
    private final class SessionControl {
        private @Nullable RemoteCallback mControl;

        private void startVoiceInteractionSession() throws Exception {
            final CountDownLatch latch = new CountDownLatch(1);

            final RemoteCallback callback = new RemoteCallback((result) -> {
                mControl = result.getParcelable(Utils.DIRECT_ACTIONS_KEY_CONTROL);
                latch.countDown();
            });

            final Intent intent = new Intent();
            intent.putExtra(Utils.DIRECT_ACTIONS_KEY_CLASS,
                    ""android.voiceinteraction.service.DirectActionsSession"");
            intent.setClassName(""android.voiceinteraction.service"",
                    ""android.voiceinteraction.service.VoiceInteractionMain"");
            intent.putExtra(Utils.DIRECT_ACTIONS_KEY_CALLBACK, callback);
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

            Log.v(TAG, ""startVoiceInteractionSession(): "" + intent);
            mContext.startActivity(intent);

            if (!latch.await(OPERATION_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
                throw new TimeoutException(""actitvity not started in "" + OPERATION_TIMEOUT_MS
                        + ""ms"");
            }
        }

        private void stopVoiceInteractionSession() throws Exception {
            executeCommand(Utils.DIRECT_ACTIONS_SESSION_CMD_FINISH,
                    null /*directAction*/, null /*arguments*/, null /*postActionCommand*/);
        }

        @Nullable List<DirectAction> getDirectActions() throws Exception {
            final ArrayList<DirectAction> actions = new ArrayList<>();
            final Bundle result = executeCommand(Utils.DIRECT_ACTIONS_SESSION_CMD_GET_ACTIONS,
                    null /*directAction*/, null /*arguments*/, null /*postActionCommand*/);
            actions.addAll(result.getParcelableArrayList(Utils.DIRECT_ACTIONS_KEY_RESULT));
            return actions;
        }

        @Nullable Bundle performDirectAction(@NonNull DirectAction directAction,
                @NonNull Bundle arguments) throws Exception {
            return executeCommand(Utils.DIRECT_ACTIONS_SESSION_CMD_PERFORM_ACTION,
                    directAction, arguments, null /*postActionCommand*/);
        }

        @Nullable Bundle performDirectActionAndCancel(@NonNull DirectAction directAction,
                @NonNull Bundle arguments) throws Exception {
            return executeCommand(Utils.DIRECT_ACTIONS_SESSION_CMD_PERFORM_ACTION_CANCEL,
                    directAction, arguments, null /*postActionCommand*/);
        }

        @Nullable
        boolean detectDirectActionsInvalidated(@NonNull ThrowingRunnable postActionCommand)
                throws Exception {
            final Bundle result = executeCommand(
                    Utils.DIRECT_ACTIONS_SESSION_CMD_DETECT_ACTIONS_CHANGED,
                    null /*directAction*/, null /*arguments*/, postActionCommand);
            return result.getBoolean(Utils.DIRECT_ACTIONS_KEY_RESULT);
        }

        @Nullable Bundle executeCommand(@NonNull String action, @Nullable DirectAction directAction,
                @Nullable Bundle arguments, @Nullable ThrowingRunnable postActionCommand)
                throws Exception {
            final CountDownLatch latch = new CountDownLatch(1);

            final Bundle result = new Bundle();

            final RemoteCallback callback = new RemoteCallback((b) -> {
                result.putAll(b);
                latch.countDown();
            });

            final Bundle command = new Bundle();
            command.putString(Utils.DIRECT_ACTIONS_KEY_COMMAND, action);
            command.putParcelable(Utils.DIRECT_ACTIONS_KEY_ACTION, directAction);
            command.putBundle(Utils.DIRECT_ACTIONS_KEY_ARGUMENTS, arguments);
            command.putParcelable(Utils.DIRECT_ACTIONS_KEY_CALLBACK, callback);

            Log.v(TAG, ""executeCommand(): action="" + action + "" command=""
                    + Utils.toBundleString(command));
            mControl.sendResult(command);

            if (postActionCommand != null) {
                Log.v(TAG, ""Executing post-action command for "" + action);
                postActionCommand.run();
            }

            if (!latch.await(OPERATION_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
                throw new TimeoutException(""result not received in "" + OPERATION_TIMEOUT_MS + ""ms"");
            }

            Log.v(TAG, ""returning "" + Utils.toBundleString(result));

            return result;
        }
    }

    private final class ActivityControl {
        private @Nullable RemoteCallback mControl;

        void startActivity() throws Exception {
            final CountDownLatch latch = new CountDownLatch(1);

            final RemoteCallback callback = new RemoteCallback((result) -> {
                Log.v(TAG, ""ActivityControl: testapp called the callback: ""
                        + Utils.toBundleString(result));
                mControl = result.getParcelable(Utils.DIRECT_ACTIONS_KEY_CONTROL);
                latch.countDown();
            });

            final Intent intent = new Intent()
                    .setAction(Intent.ACTION_VIEW)
                    .addCategory(Intent.CATEGORY_BROWSABLE)
                    .setData(Uri.parse(""https://android.voiceinteraction.testapp""
                            + ""/DirectActionsActivity""))
                    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    .putExtra(Utils.DIRECT_ACTIONS_KEY_CALLBACK, callback);
            if (mContext.getPackageManager().isInstantApp()) {
                // Override app-links domain verification.
                runShellCommand(
                        String.format(
                                ""pm set-app-links-user-selection --user cur --package %1$s true""
                                        + "" %1$s"",
                                TEST_APP_PACKAGE));
            } else {
                intent.setPackage(TEST_APP_PACKAGE);
            }

            Log.v(TAG, ""startActivity: "" + intent);
            mContext.startActivity(intent);

            if (!latch.await(OPERATION_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
                throw new TimeoutException(""actitvity not started in "" + OPERATION_TIMEOUT_MS
                        + ""ms"");
            }
        }

        private boolean detectInteractorDestroyed(ThrowingRunnable destroyTrigger)
                throws Exception {
            final Bundle result = executeRemoteCommand(
                    Utils.DIRECT_ACTIONS_ACTIVITY_CMD_DESTROYED_INTERACTOR,
                    destroyTrigger);
            return result.getBoolean(Utils.DIRECT_ACTIONS_KEY_RESULT);
        }

        void finishActivity() throws Exception {
            executeRemoteCommand(Utils.DIRECT_ACTIONS_ACTIVITY_CMD_FINISH);
        }

        void invalidateDirectActions() throws Exception {
            executeRemoteCommand(Utils.DIRECT_ACTIONS_ACTIVITY_CMD_INVALIDATE_ACTIONS);
        }

        @NonNull Bundle executeRemoteCommand(@NonNull String action) throws Exception {
            return executeRemoteCommand(action, /* postActionCommand= */ null);
        }

        @NonNull Bundle executeRemoteCommand(@NonNull String action,
                @Nullable ThrowingRunnable postActionCommand) throws Exception {
            final Bundle result = new Bundle();

            final CountDownLatch latch = new CountDownLatch(1);

            final RemoteCallback callback = new RemoteCallback((b) -> {
                Log.v(TAG, ""executeRemoteCommand(): received result from '"" + action + ""': ""
                        + Utils.toBundleString(b));
                if (b != null) {
                    result.putAll(b);
                }
                latch.countDown();
            });

            final Bundle command = new Bundle();
            command.putString(Utils.DIRECT_ACTIONS_KEY_COMMAND, action);
            command.putParcelable(Utils.DIRECT_ACTIONS_KEY_CALLBACK, callback);

            Log.v(TAG, ""executeRemoteCommand(): sending command for '"" + action + ""'"");
            mControl.sendResult(command);

            if (postActionCommand != null) {
                try {
                    postActionCommand.run();
                } catch (Exception e) {
                    Log.e(TAG, ""action '"" + action + ""' failed"");
                    throw e;
                }
            }

            if (!latch.await(OPERATION_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
                throw new TimeoutException(""result not received in "" + OPERATION_TIMEOUT_MS + ""ms"");
            }
            return result;
        }
    }

    private @NonNull DirectAction getExpectedDirectActionAssertively(
            @Nullable List<DirectAction> actions) {
        assertWithMessage(""no actions"").that(actions).isNotEmpty();
        final DirectAction action = actions.get(0);
        assertThat(action.getId()).isEqualTo(Utils.DIRECT_ACTIONS_ACTION_ID);
        assertThat(action.getExtras().getString(Utils.DIRECT_ACTION_EXTRA_KEY))
                .isEqualTo(Utils.DIRECT_ACTION_EXTRA_VALUE);
        assertThat(action.getLocusId().getId()).isEqualTo(Utils.DIRECT_ACTIONS_LOCUS_ID.getId());
        return action;
    }

    private @NonNull Bundle createActionArguments() {
        final Bundle args = new Bundle();
        args.putString(Utils.DIRECT_ACTIONS_KEY_ARGUMENTS, Utils.DIRECT_ACTIONS_KEY_ARGUMENTS);
        Log.v(TAG, ""createActionArguments(): "" + Utils.toBundleString(args));
        return args;
    }

    private void assertActionSucceeded(@NonNull Bundle result) {
        final Bundle bundle = result.getBundle(Utils.DIRECT_ACTIONS_KEY_RESULT);
        final String status = bundle.getString(Utils.DIRECT_ACTIONS_KEY_RESULT);
        assertWithMessage(""assertActionSucceeded(%s)"", Utils.toBundleString(result))
                .that(Utils.DIRECT_ACTIONS_RESULT_PERFORMED).isEqualTo(status);
    }

    private void assertActionCancelled(@NonNull Bundle result) {
        final Bundle bundle = result.getBundle(Utils.DIRECT_ACTIONS_KEY_RESULT);
        final String status = bundle.getString(Utils.DIRECT_ACTIONS_KEY_RESULT);
        assertWithMessage(""assertActionCancelled(%s)"", Utils.toBundleString(result))
                .that(Utils.DIRECT_ACTIONS_RESULT_CANCELLED).isEqualTo(status);
    }
}"	""	""	"second"	""	""	""	""	""	""	""	""	""	""
"2.2.5  . Security Model"	"9.8"	"H-1-5"	"9.8/H-1-5"	"09080000.720105"	"""[9.8/H-1-5] MUST NOT supply buffered mic audio older than 30 seconds to the voice interaction service or similar entity. """	""	""	"second 30 transmit cdd older buffer"	""	""	""	""	""	""	""	""	"android.voiceinteraction.testapp.DirectActionsActivity"	"emptyList"	""	"/home/gpoor/cts-12-source/cts/tests/tests/voiceinteraction/testapp/src/android/voiceinteraction/testapp/DirectActionsActivity.java"	""	"public void test/*
 *.
 */

package android.voiceinteraction.testapp;

import android.app.Activity;
import android.app.DirectAction;
import android.app.VoiceInteractor;
import android.content.Intent;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.CancellationSignal;
import android.os.RemoteCallback;
import android.util.Log;
import android.voiceinteraction.common.Utils;

import androidx.annotation.NonNull;

import com.android.compatibility.common.util.PollingCheck;

import com.google.common.truth.Truth;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.function.Consumer;

/**
 * Activity to test direct action behaviors.
 */
public final class DirectActionsActivity extends Activity {

    private static final String TAG = DirectActionsActivity.class.getSimpleName();

    @Override
    protected void onResume() {
        super.onResume();
        final Intent intent = getIntent();
        Log.v(TAG, ""onResume: "" + intent);
        final Bundle args = intent.getExtras();
        final RemoteCallback callBack = args.getParcelable(Utils.DIRECT_ACTIONS_KEY_CALLBACK);

        final RemoteCallback control = new RemoteCallback((cmdArgs) -> {
            final String command = cmdArgs.getString(Utils.DIRECT_ACTIONS_KEY_COMMAND);
            Log.v(TAG, ""on remote callback: command="" + command);
            switch (command) {
                case Utils.DIRECT_ACTIONS_ACTIVITY_CMD_DESTROYED_INTERACTOR: {
                    final RemoteCallback commandCallback = cmdArgs.getParcelable(
                            Utils.DIRECT_ACTIONS_KEY_CALLBACK);
                    detectDestroyedInteractor(commandCallback);
                } break;
                case Utils.DIRECT_ACTIONS_ACTIVITY_CMD_FINISH: {
                    final RemoteCallback commandCallback = cmdArgs.getParcelable(
                            Utils.DIRECT_ACTIONS_KEY_CALLBACK);
                    doFinish(commandCallback);
                } break;
                case Utils.DIRECT_ACTIONS_ACTIVITY_CMD_INVALIDATE_ACTIONS: {
                    final RemoteCallback commandCallback = cmdArgs.getParcelable(
                            Utils.DIRECT_ACTIONS_KEY_CALLBACK);
                    invalidateDirectActions(commandCallback);
                } break;
            }
        });

        final Bundle result = new Bundle();
        result.putParcelable(Utils.DIRECT_ACTIONS_KEY_CONTROL, control);
        Log.v(TAG, ""onResume(): result="" + Utils.toBundleString(result));
        callBack.sendResult(result);
    }

    @Override
    public void onGetDirectActions(@NonNull CancellationSignal cancellationSignal,
            @NonNull Consumer<List<DirectAction>> callback) {
        if (getVoiceInteractor() == null) {
            Log.e(TAG, ""onGetDirectActions(): no voice interactor"");
            callback.accept(Collections.emptyList());
            return;
        }
        Log.v(TAG, ""onGetDirectActions()"");
        final DirectAction action = new DirectAction.Builder(Utils.DIRECT_ACTIONS_ACTION_ID)
                .setExtras(Utils.DIRECT_ACTIONS_ACTION_EXTRAS)
                .setLocusId(Utils.DIRECT_ACTIONS_LOCUS_ID)
                .build();

        final ArrayList<DirectAction> actions = new ArrayList<>();
        actions.add(action);
        callback.accept(actions);
    }

    @Override
    public void onPerformDirectAction(String actionId, Bundle arguments,
            CancellationSignal cancellationSignal, Consumer<Bundle> callback) {
        Log.v(TAG, ""onPerformDirectAction(): "" + Utils.toBundleString(arguments));
        if (arguments == null || !arguments.getString(Utils.DIRECT_ACTIONS_KEY_ARGUMENTS)
                .equals(Utils.DIRECT_ACTIONS_KEY_ARGUMENTS)) {
            reportActionFailed(callback);
            return;
        }
        final RemoteCallback cancelCallback = arguments.getParcelable(
                Utils.DIRECT_ACTIONS_KEY_CANCEL_CALLBACK);
        if (cancelCallback != null) {
            cancellationSignal.setOnCancelListener(() -> reportActionCancelled(
                    cancelCallback::sendResult));
            reportActionExecuting(callback);
        } else {
            reportActionPerformed(callback);
        }
    }

    private void detectDestroyedInteractor(@NonNull RemoteCallback callback) {
        final CountDownLatch latch = new CountDownLatch(1);
        final VoiceInteractor interactor = getVoiceInteractor();
        interactor.registerOnDestroyedCallback(AsyncTask.THREAD_POOL_EXECUTOR, latch::countDown);
        Utils.await(latch);

        try {
            // Check that the interactor is properly marked destroyed. Polls the values since
            // there's no synchronization between destroy() and these methods.
            long pollingTimeoutMs = 3000;
            PollingCheck.check(
                    ""onDestroyedCallback called but interactor isn't destroyed"",
                    pollingTimeoutMs,
                    interactor::isDestroyed);
            PollingCheck.check(
                    ""onDestroyedCallback called but activity still has an interactor"",
                    pollingTimeoutMs,
                    () -> getVoiceInteractor() == null);
        } catch (Exception e) {
            Truth.assertWithMessage(""Unexpected exception: "" + e).fail();
        }

        final Bundle result = new Bundle();
        result.putBoolean(Utils.DIRECT_ACTIONS_KEY_RESULT, true);
        Log.v(TAG, ""detectDestroyedInteractor(): "" + Utils.toBundleString(result));
        callback.sendResult(result);
    }

    private void invalidateDirectActions(@NonNull RemoteCallback callback) {
        getVoiceInteractor().notifyDirectActionsChanged();
        final Bundle result = new Bundle();
        result.putBoolean(Utils.DIRECT_ACTIONS_KEY_RESULT, true);
        Log.v(TAG, ""invalidateDirectActions(): "" + Utils.toBundleString(result));
        callback.sendResult(result);
    }

    private void doFinish(@NonNull RemoteCallback callback) {
        finish();
        final Bundle result = new Bundle();
        result.putBoolean(Utils.DIRECT_ACTIONS_KEY_RESULT, true);
        Log.v(TAG, ""doFinish(): "" + Utils.toBundleString(result));
        callback.sendResult(result);
    }

    private static void reportActionPerformed(Consumer<Bundle> callback) {
        final Bundle result = new Bundle();
        result.putString(Utils.DIRECT_ACTIONS_KEY_RESULT,
                Utils.DIRECT_ACTIONS_RESULT_PERFORMED);
        Log.v(TAG, ""reportActionPerformed(): "" + Utils.toBundleString(result));
        callback.accept(result);
    }

    private static void reportActionCancelled(Consumer<Bundle> callback) {
        final Bundle result = new Bundle();
        result.putString(Utils.DIRECT_ACTIONS_KEY_RESULT,
                Utils.DIRECT_ACTIONS_RESULT_CANCELLED);
        Log.v(TAG, ""reportActionCancelled(): "" + Utils.toBundleString(result));
        callback.accept(result);
    }

    private static void reportActionExecuting(Consumer<Bundle> callback) {
        final Bundle result = new Bundle();
        result.putString(Utils.DIRECT_ACTIONS_KEY_RESULT,
                Utils.DIRECT_ACTIONS_RESULT_EXECUTING);
        Log.v(TAG, ""reportActionExecuting(): "" + Utils.toBundleString(result));
        callback.accept(result);
    }

    private static void reportActionFailed(Consumer<Bundle> callback) {
        Log.v(TAG, ""reportActionFailed()"");
        callback.accept( new Bundle());
    }
}"	""	""	"30"	""	""	""	""	""	""	""	""	""	""
"2.2.5  . Security Model"	"9.8"	"H-1-5"	"9.8/H-1-5"	"09080000.720105"	"""[9.8/H-1-5] MUST NOT supply buffered mic audio older than 30 seconds to the voice interaction service or similar entity. """	""	""	"second 30 transmit cdd older buffer"	""	""	""	""	""	""	""	""	"android.voiceinteraction.cts.VoiceInteractionRoleTest"	"testAssistRole_noRecognitionService"	"CtsVoiceInteractionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/voiceinteraction/src/android/voiceinteraction/cts/VoiceInteractionRoleTest.java"	""	"public void testAssistRole_noRecognitionService() throws Exception {
        roleTestingForPackage(VOICE_INTERACTION_NO_RECOGNITION_SERVICE, /* hasRecognition= */
                false);
    }

    // TODO: Use helpers and move the assertion in Test instead of move together
    private void roleTestingForPackage(String packageName, boolean hasRecognition)
            throws Exception {
        assertThat(getAssistRoleHolders()).doesNotContain(packageName);

        addAssistRoleHolder(packageName);
        if (mOriginalRoleHolders != null && mOriginalRoleHolders.size() > 0) {
            String originalHolder = mOriginalRoleHolders.get(0);
            removeAssistRoleHolder(originalHolder);
            assertThat(getAssistRoleHolders()).doesNotContain(originalHolder);
        }
        assertThat(getAssistRoleHolders()).containsExactly(packageName);

        Callable<Boolean> condition = hasRecognition
                ? () -> !TextUtils.isEmpty(Settings.Secure.getString(sContext.getContentResolver(),
                Settings.Secure.VOICE_INTERACTION_SERVICE))
                : () -> """".equals(Settings.Secure.getString(sContext.getContentResolver(),
                        Settings.Secure.VOICE_INTERACTION_SERVICE));
        PollingCheck.check(""Make sure that Settings VOICE_INTERACTION_SERVICE ""
                + ""becomes available."", 500, condition);
        final String curVoiceInteractionComponentName = Settings.Secure.getString(
                sContext.getContentResolver(),
                Settings.Secure.VOICE_INTERACTION_SERVICE);
        String curVoiceInteractionPackageName = """";
        if (!TextUtils.isEmpty(curVoiceInteractionComponentName)) {
            curVoiceInteractionPackageName =
                    ComponentName.unflattenFromString(
                            curVoiceInteractionComponentName).getPackageName();
        }
        assertThat(curVoiceInteractionPackageName).isEqualTo(hasRecognition ? packageName : """");

        removeAssistRoleHolder(packageName);
        assertThat(getAssistRoleHolders()).doesNotContain(packageName);
    }

    private List<String> getAssistRoleHolders() throws Exception {
        return callWithShellPermissionIdentity(
                () -> sRoleManager.getRoleHolders(RoleManager.ROLE_ASSISTANT));
    }

    private void addAssistRoleHolder(String packageName)
            throws Exception {
        Log.i(TAG, ""addAssistRoleHolder for "" + packageName);
        final CallbackFuture future = new CallbackFuture(""addAssistRoleHolder"");
        runWithShellPermissionIdentity(() -> {
            sRoleManager.addRoleHolderAsUser(RoleManager.ROLE_ASSISTANT, packageName,
                    RoleManager.MANAGE_HOLDERS_FLAG_DONT_KILL_APP, Process.myUserHandle(),
                    sContext.getMainExecutor(), future);
        });
        assertThat(future.get(TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
    }

    private void removeAssistRoleHolder(String packageName)
            throws Exception {
        Log.i(TAG, ""removeAssistRoleHolder for "" + packageName);
        final CallbackFuture future = new CallbackFuture(""removeAssistRoleHolder"");
        runWithShellPermissionIdentity(
                () -> sRoleManager.removeRoleHolderAsUser(RoleManager.ROLE_ASSISTANT, packageName,
                        0, Process.myUserHandle(), sContext.getMainExecutor(), future));
        assertThat(future.get(TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
    }

    private static class CallbackFuture extends CompletableFuture<Boolean>
            implements Consumer<Boolean> {
        String mMethodName;

        CallbackFuture(String methodName) {
            mMethodName = methodName;
        }

        @Override
        public void accept(Boolean successful) {
            Log.i(TAG, mMethodName + "" result "" + successful);
            complete(successful);
        }
    }
}"	""	""	"second older"	""	""	""	""	""	""	""	""	""	""
"2.2.5  . Security Model"	"9.8"	"H-1-5"	"9.8/H-1-5"	"09080000.720105"	"""[9.8/H-1-5] MUST NOT supply buffered mic audio older than 30 seconds to the voice interaction service or similar entity. """	""	""	"second 30 transmit cdd older buffer"	""	""	""	""	""	""	""	""	"android.voiceinteraction.cts.VoiceInteractionRoleTest"	"getAssistRoleHolders"	"CtsVoiceInteractionTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/voiceinteraction/src/android/voiceinteraction/cts/VoiceInteractionRoleTest.java"	""	"/*
 *.
 */

package android.voiceinteraction.cts;

import static com.android.compatibility.common.util.SystemUtil.callWithShellPermissionIdentity;
import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;

import static com.google.common.truth.Truth.assertThat;

import android.app.role.RoleManager;
import android.content.ComponentName;
import android.content.Context;
import android.os.Process;
import android.platform.test.annotations.AppModeFull;
import android.provider.Settings;
import android.text.TextUtils;
import android.util.Log;

import androidx.test.core.app.ApplicationProvider;
import androidx.test.ext.junit.runners.AndroidJUnit4;

import com.android.compatibility.common.util.PollingCheck;

import org.junit.After;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;

/**
 * Tests for successfully changing ROLE_ASSISTANT. The test focuses on changing ROLE_ASSISTANT role,
 * the target voice interaction services do nothing during the test.
 */
@AppModeFull(reason = ""No need for testing role for instant app"")
@RunWith(AndroidJUnit4.class)
public class VoiceInteractionRoleTest {

    private static final String TAG = ""VoiceInteractionRoleTest"";

    private static final long TIMEOUT_MILLIS = 15 * 1000;
    private static final String VOICE_INTERACTION_HAS_RECOGNITION_SERVICE =
            ""android.voiceinteraction.service"";
    private static final String VOICE_INTERACTION_NO_RECOGNITION_SERVICE =
            ""android.voiceinteraction.norecognition"";

    private static Context sContext;
    private static RoleManager sRoleManager;

    List<String> mOriginalRoleHolders;

    @BeforeClass
    public static void oneTimeSetup() {
        sContext = ApplicationProvider.getApplicationContext();
        sRoleManager = sContext.getSystemService(RoleManager.class);
    }

    @Before
    public void setup() throws Exception {
        mOriginalRoleHolders = getAssistRoleHolders();
    }

    @After
    public void cleanup() throws Exception {
        if (mOriginalRoleHolders != null && mOriginalRoleHolders.size() > 0) {
            // Restore to original, assistant is singleton role
            addAssistRoleHolder(mOriginalRoleHolders.get(0));
        }
    }"	""	""	"older"	""	""	""	""	""	""	""	""	""	""
"2.2.5  . Security Model"	"9.8"	"H-1-5"	"9.8/H-1-5"	"09080000.720105"	"""[9.8/H-1-5] MUST NOT supply buffered mic audio older than 30 seconds to the voice interaction service or similar entity. """	""	""	"second 30 transmit cdd older buffer"	""	""	""	""	""	""	""	""	"android.voiceinteraction.service.BasicVoiceInteractionService"	"dropShellPermissionIdentity"	""	"/home/gpoor/cts-12-source/cts/tests/tests/voiceinteraction/service/src/android/voiceinteraction/service/BasicVoiceInteractionService.java"	""	"public void test/*
 *.
 */

package android.voiceinteraction.service;

import static android.Manifest.permission.CAPTURE_AUDIO_HOTWORD;
import static android.Manifest.permission.RECORD_AUDIO;

import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;

import android.Manifest;
import android.app.UiAutomation;
import android.content.Intent;
import android.media.AudioFormat;
import android.os.ParcelFileDescriptor;
import android.os.Parcelable;
import android.os.PersistableBundle;
import android.os.SharedMemory;
import android.service.voice.AlwaysOnHotwordDetector;
import android.service.voice.HotwordDetectionService;
import android.service.voice.HotwordDetector;
import android.service.voice.HotwordRejectedResult;
import android.service.voice.VoiceInteractionService;
import android.system.ErrnoException;
import android.util.Log;
import android.voiceinteraction.common.Utils;

import androidx.annotation.NonNull;
import androidx.test.platform.app.InstrumentationRegistry;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.util.Locale;

/**
 * This service included a basic HotwordDetectionService for testing.
 */
public class BasicVoiceInteractionService extends VoiceInteractionService {
    // TODO: (b/182236586) Refactor the voice interaction service logic
    static final String TAG = ""BasicVoiceInteractionService"";

    public static String KEY_FAKE_DATA = ""fakeData"";
    public static String VALUE_FAKE_DATA = ""fakeData"";
    public static byte[] FAKE_BYTE_ARRAY_DATA = new byte[] {1, 2, 3};
    public static byte[] FAKE_HOTWORD_AUDIO_DATA =
            new byte[] {'h', 'o', 't', 'w', 'o', 'r', 'd', '!'};

    private boolean mReady = false;
    private AlwaysOnHotwordDetector mAlwaysOnHotwordDetector = null;
    private HotwordDetector mSoftwareHotwordDetector = null;
    private ParcelFileDescriptor[] mTempParcelFileDescriptor = null;

    @Override
    public void onReady() {
        super.onReady();
        mReady = true;
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        Log.i(TAG, ""onStartCommand received"");

        if (intent == null || !mReady) {
            Log.wtf(TAG, ""Can't start because either intent is null or onReady() ""
                    + ""is not called yet. intent = "" + intent + "", mReady = "" + mReady);
            return START_NOT_STICKY;
        }

        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        // Drop any identity adopted earlier.
        uiAutomation.dropShellPermissionIdentity();

        final int testEvent = intent.getIntExtra(Utils.KEY_TEST_EVENT, -1);
        Log.i(TAG, ""testEvent = "" + testEvent);
        if (testEvent == Utils.HOTWORD_DETECTION_SERVICE_TRIGGER_TEST) {
            runWithShellPermissionIdentity(() -> {
                mAlwaysOnHotwordDetector = callCreateAlwaysOnHotwordDetector();
            }, Manifest.permission.MANAGE_HOTWORD_DETECTION);
        } else if (testEvent == Utils.VIS_WITHOUT_MANAGE_HOTWORD_DETECTION_PERMISSION_TEST) {
            runWithShellPermissionIdentity(() -> callCreateAlwaysOnHotwordDetector(),
                    Manifest.permission.BIND_HOTWORD_DETECTION_SERVICE);
        } else if (testEvent == Utils.VIS_HOLD_BIND_HOTWORD_DETECTION_PERMISSION_TEST) {
            runWithShellPermissionIdentity(() -> callCreateAlwaysOnHotwordDetector());
        } else if (testEvent == Utils.HOTWORD_DETECTION_SERVICE_DSP_ONDETECT_TEST) {
            // need to retain the identity until the callback is triggered
            uiAutomation.adoptShellPermissionIdentity(RECORD_AUDIO, CAPTURE_AUDIO_HOTWORD);
            if (mAlwaysOnHotwordDetector != null) {
                mAlwaysOnHotwordDetector.triggerHardwareRecognitionEventForTest(/* status */ 0,
                        /* soundModelHandle */ 100, /* captureAvailable */ true,
                        /* captureSession */ 101, /* captureDelayMs */ 1000,
                        /* capturePreambleMs */ 1001, /* triggerInData */ true,
                        createFakeAudioFormat(), new byte[1024]);
            }
        } else if (testEvent == Utils.HOTWORD_DETECTION_SERVICE_DSP_ONREJECT_TEST) {
            runWithShellPermissionIdentity(() -> {
                if (mAlwaysOnHotwordDetector != null) {
                    mAlwaysOnHotwordDetector.triggerHardwareRecognitionEventForTest(/* status */ 0,
                            /* soundModelHandle */ 100, /* captureAvailable */ true,
                            /* captureSession */ 101, /* captureDelayMs */ 1000,
                            /* capturePreambleMs */ 1001, /* triggerInData */ true,
                            createFakeAudioFormat(), null);
                }
            });
        } else if (testEvent == Utils.HOTWORD_DETECTION_SERVICE_EXTERNAL_SOURCE_ONDETECT_TEST) {
            uiAutomation.adoptShellPermissionIdentity(RECORD_AUDIO, CAPTURE_AUDIO_HOTWORD);
            if (mAlwaysOnHotwordDetector != null) {
                ParcelFileDescriptor audioStream = createFakeAudioStream();
                if (audioStream != null) {
                    mAlwaysOnHotwordDetector.startRecognition(
                            audioStream,
                            createFakeAudioFormat(),
                            createFakePersistableBundleData());
                }
            }
        } else if (testEvent == Utils.HOTWORD_DETECTION_SERVICE_FROM_SOFTWARE_TRIGGER_TEST) {
            runWithShellPermissionIdentity(() -> {
                mSoftwareHotwordDetector = callCreateSoftwareHotwordDetector();
            }, Manifest.permission.MANAGE_HOTWORD_DETECTION);
        } else if (testEvent == Utils.HOTWORD_DETECTION_SERVICE_MIC_ONDETECT_TEST) {
            uiAutomation.adoptShellPermissionIdentity(RECORD_AUDIO, CAPTURE_AUDIO_HOTWORD);
            if (mSoftwareHotwordDetector != null) {
                mSoftwareHotwordDetector.startRecognition();
            }
        } else if (testEvent == Utils.HOTWORD_DETECTION_SERVICE_CALL_STOP_RECOGNITION) {
            if (mSoftwareHotwordDetector != null) {
                mSoftwareHotwordDetector.stopRecognition();
            }
        } else if (testEvent == Utils.HOTWORD_DETECTION_SERVICE_PROCESS_DIED_TEST) {
            runWithShellPermissionIdentity(() -> {
                if (mAlwaysOnHotwordDetector != null) {
                    PersistableBundle persistableBundle = new PersistableBundle();
                    persistableBundle.putInt(Utils.KEY_TEST_SCENARIO,
                            Utils.HOTWORD_DETECTION_SERVICE_ON_UPDATE_STATE_CRASH);
                    mAlwaysOnHotwordDetector.updateState(
                            persistableBundle,
                            createFakeSharedMemoryData());
                }
            }, Manifest.permission.MANAGE_HOTWORD_DETECTION);
        }

        return START_NOT_STICKY;
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        closeFakeAudioStream();
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .dropShellPermissionIdentity();
    }

    private AlwaysOnHotwordDetector callCreateAlwaysOnHotwordDetector() {
        Log.i(TAG, ""callCreateAlwaysOnHotwordDetector()"");
        try {
            return createAlwaysOnHotwordDetector(/* keyphrase */ ""Hello Android"",
                    Locale.forLanguageTag(""en-US""),
                    createFakePersistableBundleData(),
                    createFakeSharedMemoryData(),
                    new AlwaysOnHotwordDetector.Callback() {
                        @Override
                        public void onAvailabilityChanged(int status) {
                            Log.i(TAG, ""onAvailabilityChanged("" + status + "")"");
                        }

                        @Override
                        public void onDetected(AlwaysOnHotwordDetector.EventPayload eventPayload) {
                            Log.i(TAG, ""onDetected"");
                            broadcastIntentWithResult(
                                    Utils.HOTWORD_DETECTION_SERVICE_ONDETECT_RESULT_INTENT,
                                    new EventPayloadParcelable(eventPayload));
                        }

                        @Override
                        public void onRejected(@NonNull HotwordRejectedResult result) {
                            super.onRejected(result);
                            Log.i(TAG, ""onRejected"");
                            broadcastIntentWithResult(
                                    Utils.HOTWORD_DETECTION_SERVICE_ONDETECT_RESULT_INTENT,
                                    result);
                        }

                        @Override
                        public void onError() {
                            Log.i(TAG, ""onError"");
                            broadcastIntentWithResult(
                                    Utils.HOTWORD_DETECTION_SERVICE_TRIGGER_RESULT_INTENT,
                                    Utils.HOTWORD_DETECTION_SERVICE_GET_ERROR);
                        }

                        @Override
                        public void onRecognitionPaused() {
                            Log.i(TAG, ""onRecognitionPaused"");
                        }

                        @Override
                        public void onRecognitionResumed() {
                            Log.i(TAG, ""onRecognitionResumed"");
                        }

                        @Override
                        public void onHotwordDetectionServiceInitialized(int status) {
                            super.onHotwordDetectionServiceInitialized(status);
                            Log.i(TAG, ""onHotwordDetectionServiceInitialized"");
                            verifyHotwordDetectionServiceInitializedStatus(status);
                        }

                        @Override
                        public void onHotwordDetectionServiceRestarted() {
                            super.onHotwordDetectionServiceRestarted();
                            Log.i(TAG, ""onHotwordDetectionServiceRestarted"");
                        }
                    });
        } catch (IllegalStateException e) {
            Log.w(TAG, ""callCreateAlwaysOnHotwordDetector() exception: "" + e);
            broadcastIntentWithResult(
                    Utils.HOTWORD_DETECTION_SERVICE_TRIGGER_RESULT_INTENT,
                    Utils.HOTWORD_DETECTION_SERVICE_TRIGGER_ILLEGAL_STATE_EXCEPTION);
        } catch (SecurityException e) {
            Log.w(TAG, ""callCreateAlwaysOnHotwordDetector() exception: "" + e);
            broadcastIntentWithResult(
                    Utils.HOTWORD_DETECTION_SERVICE_TRIGGER_RESULT_INTENT,
                    Utils.HOTWORD_DETECTION_SERVICE_TRIGGER_SECURITY_EXCEPTION);
        }
        return null;
    }

    private HotwordDetector callCreateSoftwareHotwordDetector() {
        Log.i(TAG, ""callCreateSoftwareHotwordDetector()"");
        try {
            return createHotwordDetector(
                    createFakePersistableBundleData(),
                    createFakeSharedMemoryData(),
                    new HotwordDetector.Callback() {
                        @Override
                        public void onDetected(AlwaysOnHotwordDetector.EventPayload eventPayload) {
                            Log.i(TAG, ""onDetected"");
                            broadcastIntentWithResult(
                                    Utils.HOTWORD_DETECTION_SERVICE_ONDETECT_RESULT_INTENT,
                                    new EventPayloadParcelable(eventPayload));
                        }

                        @Override
                        public void onError() {
                            Log.i(TAG, ""onError"");
                            broadcastIntentWithResult(
                                    Utils.HOTWORD_DETECTION_SERVICE_TRIGGER_RESULT_INTENT,
                                    Utils.HOTWORD_DETECTION_SERVICE_GET_ERROR);
                        }

                        @Override
                        public void onRecognitionPaused() {
                            Log.i(TAG, ""onRecognitionPaused"");
                        }

                        @Override
                        public void onRecognitionResumed() {
                            Log.i(TAG, ""onRecognitionResumed"");
                        }

                        @Override
                        public void onRejected(HotwordRejectedResult result) {
                            Log.i(TAG, ""onRejected"");
                        }

                        @Override
                        public void onHotwordDetectionServiceInitialized(int status) {
                            verifyHotwordDetectionServiceInitializedStatus(status);
                        }

                        @Override
                        public void onHotwordDetectionServiceRestarted() {
                            Log.i(TAG, ""onHotwordDetectionServiceRestarted"");
                        }
                    });
        } catch (Exception e) {
            Log.w(TAG, ""callCreateSoftwareHotwordDetector() exception: "" + e);
        }
        return null;
    }

    private void broadcastIntentWithResult(String intentName, int result) {
        Intent intent = new Intent(intentName)
                .addFlags(Intent.FLAG_RECEIVER_FOREGROUND | Intent.FLAG_RECEIVER_REGISTERED_ONLY)
                .putExtra(Utils.KEY_TEST_RESULT, result);
        Log.d(TAG, ""broadcast intent = "" + intent + "", result = "" + result);
        sendBroadcast(intent);
    }

    private void broadcastIntentWithResult(String intentName, Parcelable result) {
        Intent intent = new Intent(intentName)
                .addFlags(Intent.FLAG_RECEIVER_FOREGROUND | Intent.FLAG_RECEIVER_REGISTERED_ONLY)
                .putExtra(Utils.KEY_TEST_RESULT, result);
        Log.d(TAG, ""broadcast intent = "" + intent + "", result = "" + result);
        sendBroadcast(intent);
    }

    private SharedMemory createFakeSharedMemoryData() {
        try {
            SharedMemory sharedMemory = SharedMemory.create(""SharedMemory"", 3);
            ByteBuffer byteBuffer = sharedMemory.mapReadWrite();
            byteBuffer.put(FAKE_BYTE_ARRAY_DATA);
            return sharedMemory;
        } catch (ErrnoException e) {
            Log.w(TAG, ""createFakeSharedMemoryData ErrnoException : "" + e);
            throw new RuntimeException(e.getMessage());
        }
    }

    private PersistableBundle createFakePersistableBundleData() {
        // TODO : Add more data for testing
        PersistableBundle persistableBundle = new PersistableBundle();
        persistableBundle.putString(KEY_FAKE_DATA, VALUE_FAKE_DATA);
        return persistableBundle;
    }

    private AudioFormat createFakeAudioFormat() {
        return new AudioFormat.Builder()
                .setSampleRate(32000)
                .setEncoding(AudioFormat.ENCODING_PCM_16BIT)
                .setChannelMask(AudioFormat.CHANNEL_IN_MONO).build();
    }

    private ParcelFileDescriptor createFakeAudioStream() {
        try {
            mTempParcelFileDescriptor = ParcelFileDescriptor.createPipe();
            try (OutputStream fos =
                         new ParcelFileDescriptor.AutoCloseOutputStream(
                                 mTempParcelFileDescriptor[1])) {
                fos.write(FAKE_HOTWORD_AUDIO_DATA, 0, 8);
            } catch (IOException e) {
                Log.w(TAG, ""Failed to pipe audio data : "", e);
                return null;
            }
            return mTempParcelFileDescriptor[0];
        } catch (IOException e) {
            Log.w(TAG, ""Failed to create a pipe : "" + e);
        }
        return null;
    }

    private void closeFakeAudioStream() {
        if (mTempParcelFileDescriptor != null) {
            try {
                mTempParcelFileDescriptor[0].close();
                mTempParcelFileDescriptor[1].close();
            } catch (IOException e) {
                Log.w(TAG, ""Failed closing : "" + e);
            }
            mTempParcelFileDescriptor = null;
        }
    }

    private void verifyHotwordDetectionServiceInitializedStatus(int status) {
        if (status == HotwordDetectionService.INITIALIZATION_STATUS_SUCCESS) {
            broadcastIntentWithResult(
                    Utils.HOTWORD_DETECTION_SERVICE_TRIGGER_RESULT_INTENT,
                    Utils.HOTWORD_DETECTION_SERVICE_TRIGGER_SUCCESS);
        }
    }
}"	""	""	"buffer"	""	""	""	""	""	""	""	""	""	""
"2.2.5  . Security Model"	"9.8"	"H-1-5"	"9.8/H-1-5"	"09080000.720105"	"""[9.8/H-1-5] MUST NOT supply buffered mic audio older than 30 seconds to the voice interaction service or similar entity. """	""	""	"second 30 transmit cdd older buffer"	""	""	""	""	""	""	""	""	"android.voiceinteraction.common.Utils"	"isVirtualDevice"	""	"/home/gpoor/cts-12-source/cts/tests/tests/voiceinteraction/common/src/android/voiceinteraction/common/Utils.java"	""	"public void test/*
 *.
 */
package android.voiceinteraction.common;

import android.app.VoiceInteractor.PickOptionRequest.Option;
import android.content.LocusId;
import android.os.Bundle;
import android.os.Parcel;
import android.os.Parcelable;
import android.util.Log;

import com.android.compatibility.common.util.PropertyUtil;

import java.util.ArrayList;
import java.util.Objects;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;

public class Utils {
    public enum TestCaseType {
        COMPLETION_REQUEST_TEST,
        COMPLETION_REQUEST_CANCEL_TEST,
        CONFIRMATION_REQUEST_TEST,
        CONFIRMATION_REQUEST_CANCEL_TEST,
        ABORT_REQUEST_TEST,
        ABORT_REQUEST_CANCEL_TEST,
        PICKOPTION_REQUEST_TEST,
        PICKOPTION_REQUEST_CANCEL_TEST,
        COMMANDREQUEST_TEST,
        COMMANDREQUEST_CANCEL_TEST,
        SUPPORTS_COMMANDS_TEST
    }

    private static final String TAG = Utils.class.getSimpleName();

    public static final long OPERATION_TIMEOUT_MS = 5000;

    /** CDD restricts the max size of each successful hotword result is 100 bytes. */
    public static final int MAX_HOTWORD_DETECTED_RESULT_SIZE = 100;

    /**
     * Limits the max value for the hotword offset.
     *
     * Note: Must match the definition in
     * frameworks/base/core/java/android/service/voice/HotwordDetectedResult.java.
     */
    public static final int LIMIT_HOTWORD_OFFSET_MAX_VALUE = 60 * 60 * 1000; // 1 hour

    /**
     * Limits the max value for the triggered audio channel.
     *
     * Note: Must match the definition in
     * frameworks/base/core/java/android/service/voice/HotwordDetectedResult.java.
     */
    public static final int LIMIT_AUDIO_CHANNEL_MAX_VALUE = 63;

    /** Decide which VoiceInteractionService should be started for testing. */
    public static final int HOTWORD_DETECTION_SERVICE_NONE = 0;
    public static final int HOTWORD_DETECTION_SERVICE_BASIC = 1;
    public static final int HOTWORD_DETECTION_SERVICE_INVALIDATION = 2;
    public static final int HOTWORD_DETECTION_SERVICE_WITHOUT_ISOLATED_PROCESS = 3;
    public static final int HOTWORD_DETECTION_SERVICE_WITHIN_ISOLATED_PROCESS = 4;

    /**
     * Indicate which test event for testing.
     *
     * Note: The VIS is the abbreviation of VoiceInteractionService
     */
    public static final int VIS_NORMAL_TEST = 0;
    public static final int VIS_WITHOUT_MANAGE_HOTWORD_DETECTION_PERMISSION_TEST = 1;
    public static final int VIS_HOLD_BIND_HOTWORD_DETECTION_PERMISSION_TEST = 2;

    public static final int HOTWORD_DETECTION_SERVICE_TRIGGER_TEST = 100;
    public static final int HOTWORD_DETECTION_SERVICE_DSP_ONDETECT_TEST = 101;
    public static final int HOTWORD_DETECTION_SERVICE_EXTERNAL_SOURCE_ONDETECT_TEST = 102;
    public static final int HOTWORD_DETECTION_SERVICE_FROM_SOFTWARE_TRIGGER_TEST = 103;
    public static final int HOTWORD_DETECTION_SERVICE_MIC_ONDETECT_TEST = 104;
    public static final int HOTWORD_DETECTION_SERVICE_DSP_ONREJECT_TEST = 105;
    public static final int HOTWORD_DETECTION_SERVICE_PROCESS_DIED_TEST = 106;
    public static final int HOTWORD_DETECTION_SERVICE_CALL_STOP_RECOGNITION = 107;

    public static final int HOTWORD_DETECTION_SERVICE_TRIGGER_SUCCESS = 1;
    public static final int HOTWORD_DETECTION_SERVICE_TRIGGER_ILLEGAL_STATE_EXCEPTION = 2;
    public static final int HOTWORD_DETECTION_SERVICE_TRIGGER_SECURITY_EXCEPTION = 3;
    public static final int HOTWORD_DETECTION_SERVICE_TRIGGER_SHARED_MEMORY_NOT_READ_ONLY = 4;
    public static final int HOTWORD_DETECTION_SERVICE_GET_ERROR = 5;

    /** Indicate which test scenario for testing. */
    public static final int HOTWORD_DETECTION_SERVICE_ON_UPDATE_STATE_CRASH = 1;

    public static final String TESTCASE_TYPE = ""testcase_type"";
    public static final String TESTINFO = ""testinfo"";
    public static final String BROADCAST_INTENT = ""android.intent.action.VOICE_TESTAPP"";
    public static final String TEST_PROMPT = ""testprompt"";
    public static final String PICKOPTON_1 = ""one"";
    public static final String PICKOPTON_2 = ""two"";
    public static final String PICKOPTON_3 = ""3"";
    public static final String TEST_COMMAND = ""test_command"";
    public static final String TEST_ONCOMMAND_RESULT = ""test_oncommand_result"";
    public static final String TEST_ONCOMMAND_RESULT_VALUE = ""test_oncommand_result value"";

    public static final String CONFIRMATION_REQUEST_SUCCESS = ""confirmation ok"";
    public static final String COMPLETION_REQUEST_SUCCESS = ""completion ok"";
    public static final String ABORT_REQUEST_SUCCESS = ""abort ok"";
    public static final String PICKOPTION_REQUEST_SUCCESS = ""pickoption ok"";
    public static final String COMMANDREQUEST_SUCCESS = ""commandrequest ok"";
    public static final String SUPPORTS_COMMANDS_SUCCESS = ""supportsCommands ok"";

    public static final String CONFIRMATION_REQUEST_CANCEL_SUCCESS = ""confirm cancel ok"";
    public static final String COMPLETION_REQUEST_CANCEL_SUCCESS = ""completion canel ok"";
    public static final String ABORT_REQUEST_CANCEL_SUCCESS = ""abort cancel ok"";
    public static final String PICKOPTION_REQUEST_CANCEL_SUCCESS = ""pickoption  cancel ok"";
    public static final String COMMANDREQUEST_CANCEL_SUCCESS = ""commandrequest cancel ok"";
    public static final String TEST_ERROR = ""Error In Test:"";

    public static final String PRIVATE_OPTIONS_KEY = ""private_key"";
    public static final String PRIVATE_OPTIONS_VALUE = ""private_value"";

    public static final String DIRECT_ACTION_EXTRA_KEY = ""directActionExtraKey"";
    public static final String DIRECT_ACTION_EXTRA_VALUE = ""directActionExtraValue"";
    public static final String DIRECT_ACTION_FILE_NAME = ""directActionFileName"";
    public static final String DIRECT_ACTION_FILE_CONTENT = ""directActionFileContent"";
    public static final String DIRECT_ACTION_AUTHORITY =
            ""android.voiceinteraction.testapp.fileprovider"";

    public static final String DIRECT_ACTIONS_KEY_CALLBACK = ""callback"";
    public static final String DIRECT_ACTIONS_KEY_CANCEL_CALLBACK = ""cancelCallback"";
    public static final String DIRECT_ACTIONS_KEY_CONTROL = ""control"";
    public static final String DIRECT_ACTIONS_KEY_COMMAND = ""command"";
    public static final String DIRECT_ACTIONS_KEY_RESULT = ""result"";
    public static final String DIRECT_ACTIONS_KEY_ACTION = ""action"";
    public static final String DIRECT_ACTIONS_KEY_ARGUMENTS = ""arguments"";
    public static final String DIRECT_ACTIONS_KEY_CLASS = ""class"";

    public static final String DIRECT_ACTIONS_SESSION_CMD_PERFORM_ACTION = ""performAction"";
    public static final String DIRECT_ACTIONS_SESSION_CMD_PERFORM_ACTION_CANCEL =
            ""performActionCancel"";
    public static final String DIRECT_ACTIONS_SESSION_CMD_DETECT_ACTIONS_CHANGED =
            ""detectActionsChanged"";
    public static final String DIRECT_ACTIONS_SESSION_CMD_GET_ACTIONS = ""getActions"";
    public static final String DIRECT_ACTIONS_SESSION_CMD_FINISH = ""hide"";

    public static final String DIRECT_ACTIONS_ACTIVITY_CMD_DESTROYED_INTERACTOR =
            ""destroyedInteractor"";
    public static final String DIRECT_ACTIONS_ACTIVITY_CMD_FINISH = ""finish"";
    public static final String DIRECT_ACTIONS_ACTIVITY_CMD_INVALIDATE_ACTIONS = ""invalidateActions"";

    public static final String DIRECT_ACTIONS_RESULT_PERFORMED = ""performed"";
    public static final String DIRECT_ACTIONS_RESULT_CANCELLED = ""cancelled"";
    public static final String DIRECT_ACTIONS_RESULT_EXECUTING = ""executing"";

    public static final String DIRECT_ACTIONS_ACTION_ID = ""actionId"";
    public static final Bundle DIRECT_ACTIONS_ACTION_EXTRAS = new Bundle();
    static {
        DIRECT_ACTIONS_ACTION_EXTRAS.putString(DIRECT_ACTION_EXTRA_KEY,
                DIRECT_ACTION_EXTRA_VALUE);
    }
    public static final LocusId DIRECT_ACTIONS_LOCUS_ID = new LocusId(""locusId"");

    public static final String SERVICE_NAME =
            ""android.voiceinteraction.service/.MainInteractionService"";

    public static final String HOTWORD_DETECTION_SERVICE_TRIGGER_RESULT_INTENT =
            ""android.intent.action.HOTWORD_DETECTION_SERVICE_TRIGGER_RESULT"";
    public static final String HOTWORD_DETECTION_SERVICE_ONDETECT_RESULT_INTENT =
            ""android.intent.action.HOTWORD_DETECTION_SERVICE_ONDETECT_RESULT"";
    public static final String KEY_SERVICE_TYPE = ""serviceType"";
    public static final String KEY_TEST_EVENT = ""testEvent"";
    public static final String KEY_TEST_RESULT = ""testResult"";
    public static final String KEY_TEST_SCENARIO = ""testScenario"";

    public static final String toBundleString(Bundle bundle) {
        if (bundle == null) {
            return ""null_bundle"";
        }
        StringBuffer buf = new StringBuffer(""Bundle[ "");
        String testType = bundle.getString(TESTCASE_TYPE);
        boolean empty = true;
        if (testType != null) {
            empty = false;
            buf.append(""testcase type = "" + testType);
        }
        ArrayList<String> info = bundle.getStringArrayList(TESTINFO);
        if (info != null) {
            for (String s : info) {
                empty = false;
                buf.append(s + ""\n\t\t"");
            }
        } else {
            for (String key : bundle.keySet()) {
                empty = false;
                Object value = bundle.get(key);
                if (value instanceof Bundle) {
                    value = toBundleString((Bundle) value);
                }
                buf.append(key).append('=').append(value).append(' ');
            }
        }
        return empty ? ""empty_bundle"" : buf.append(']').toString();
    }

    public static final String toOptionsString(Option[] options) {
        StringBuilder sb = new StringBuilder();
        sb.append(""{"");
        for (int i = 0; i < options.length; i++) {
            if (i >= 1) {
                sb.append("", "");
            }
            sb.append(options[i].getLabel());
        }
        sb.append(""}"");
        return sb.toString();
    }

    public static final void addErrorResult(final Bundle testinfo, final String msg) {
        testinfo.getStringArrayList(testinfo.getString(Utils.TESTCASE_TYPE))
            .add(TEST_ERROR + "" "" + msg);
    }

    public static boolean await(CountDownLatch latch) {
        try {
            if (latch.await(OPERATION_TIMEOUT_MS, TimeUnit.MILLISECONDS)) return true;
            Log.e(TAG, ""latch timed out"");
        } catch (InterruptedException e) {
            /* ignore */
            Log.e(TAG, ""Interrupted"", e);
        }
        return false;
    }

    public static boolean await(Condition condition) {
        try {
            if (condition.await(OPERATION_TIMEOUT_MS, TimeUnit.MILLISECONDS)) return true;
            Log.e(TAG, ""condition timed out"");
        } catch (InterruptedException e) {
            /* ignore */
            Log.e(TAG, ""Interrupted"", e);
        }
        return false;
    }

    public static int getParcelableSize(Parcelable parcelable) {
        final Parcel p = Parcel.obtain();
        parcelable.writeToParcel(p, 0);
        p.setDataPosition(0);
        final int size = p.dataSize();
        p.recycle();
        return size;
    }

    public static int bitCount(long value) {
        int bits = 0;
        while (value > 0) {
            bits++;
            value = value >> 1;
        }
        return bits;
    }

    public static boolean isVirtualDevice() {
        final String property = PropertyUtil.getProperty(""ro.hardware.virtual_device"");
        Log.v(TAG, ""virtual device property="" + property);
        return Objects.equals(property, ""1"");
    }
}"	""	""	"second cdd buffer buffer"	""	""	""	""	""	""	""	""	""	""
