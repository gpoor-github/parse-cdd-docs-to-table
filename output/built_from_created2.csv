Section,section_id,req_id,Test Availability,class_def,method,module,method_text,full_key,requirement,key_as_number,search_terms,qualified_method,manual_search_terms,matched_terms,file_name,matched_files,methods_string,urls
,7.1.1.1,H-1-1,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",7.1.1.1/H-1-1,,07010101.720101,7.1.1.1 H-1-1,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,7.1.4.6,H-1-1,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",7.1.4.6/H-1-1,,07010406.720101,H-1-1 7.1.4.6,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,7.1.4.6,H-1-2,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",7.1.4.6/H-1-2,,07010406.720102,H-1-2 7.1.4.6,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-2,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,7.1.4.6,H-1-3,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",7.1.4.6/H-1-3,,07010406.720103,H-1-3 7.1.4.6,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-3,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,7.1.4.6,H-1-4,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",7.1.4.6/H-1-4,,07010406.720104,H-1-4 7.1.4.6,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-4,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,3.8.16,H-1-1,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",3.8.16/H-1-1,,03081600.720101,3.8.16 H-1-1,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,3.8.16,H-1-2,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",3.8.16/H-1-2,,03081600.720102,H-1-2 3.8.16,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-2,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,3.8.16,H-1-3,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",3.8.16/H-1-3,,03081600.720103,H-1-3 3.8.16,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-3,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,3.8.16,H-1-4,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testCameraPerfClassCharacteristics(),CtsCameraTestCases,"     @CddTest(requirement=""7.5"")     public void testCameraPerfClassCharacteristics() throws Exception {         if (mAdoptShellPerm) {             // Skip test for system camera. Performance class is only applicable for public camera             // ids.             return;         }         boolean isRPerfClass = CameraTestUtils.isRPerfClass();         boolean isSPerfClass = CameraTestUtils.isSPerfClass();         if (!isRPerfClass && !isSPerfClass) {             return;         }          boolean hasPrimaryRear = false;         boolean hasPrimaryFront = false;         for (int i = 0; i < mCameraIdsUnderTest.length; i++) {             String cameraId = mCameraIdsUnderTest[i];             boolean isPrimaryRear = CameraTestUtils.isPrimaryRearFacingCamera(                     mCameraManager, cameraId);             boolean isPrimaryFront = CameraTestUtils.isPrimaryFrontFacingCamera(                     mCameraManager, cameraId);             if (!isPrimaryRear && !isPrimaryFront) {                 continue;             }              CameraCharacteristics c = mCharacteristics.get(i);             StaticMetadata staticInfo = mAllStaticInfo.get(cameraId);              // H-1-1, H-1-2             Size pixelArraySize = CameraTestUtils.getValueNotNull(                     c, CameraCharacteristics.SENSOR_INFO_PIXEL_ARRAY_SIZE);             long sensorResolution = pixelArraySize.getHeight() * pixelArraySize.getWidth();             StreamConfigurationMap config = staticInfo.getValueFromKeyNonNull(                     CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);             assertNotNull(""No stream configuration map found for ID "" + cameraId, config);             List<Size> videoSizes = CameraTestUtils.getSupportedVideoSizes(cameraId,                     mCameraManager, null /*bound*/);              if (isPrimaryRear) {                 hasPrimaryRear = true;                 mCollector.expectTrue(""Primary rear camera resolution should be at least "" +                         MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION + "" pixels, is ""+                         sensorResolution,                         sensorResolution >= MIN_BACK_SENSOR_PERF_CLASS_RESOLUTION);                  // 4K @ 30fps                 boolean supportUHD = videoSizes.contains(UHD);                 boolean supportDC4K = videoSizes.contains(DC4K);                 mCollector.expectTrue(""Primary rear camera should support 4k video recording"",                         supportUHD || supportDC4K);                 if (supportUHD || supportDC4K) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, supportDC4K ? DC4K : UHD);                     mCollector.expectTrue(""Primary rear camera should support 4k video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             } else {                 hasPrimaryFront = true;                 if (isSPerfClass) {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_S_PERF_CLASS_RESOLUTION);                 } else {                     mCollector.expectTrue(""Primary front camera resolution should be at least "" +                             MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION + "" pixels, is ""+                             sensorResolution,                             sensorResolution >= MIN_FRONT_SENSOR_R_PERF_CLASS_RESOLUTION);                 }                 // 1080P @ 30fps                 boolean supportFULLHD = videoSizes.contains(FULLHD);                 mCollector.expectTrue(""Primary front camera should support 1080P video recording"",                         supportFULLHD);                 if (supportFULLHD) {                     long minFrameDuration = config.getOutputMinFrameDuration(                             android.media.MediaRecorder.class, FULLHD);                     mCollector.expectTrue(""Primary front camera should support 1080P video @ 30fps"",                             minFrameDuration < (1e9 / 29.9));                 }             }              String facingString = hasPrimaryRear ? ""rear"" : ""front"";             // H-1-3             if (isSPerfClass || (isRPerfClass && isPrimaryRear)) {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least FULL, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastFull());             } else {                 mCollector.expectTrue(""Primary "" + facingString +                         "" camera should be at least LIMITED, but is "" +                         toStringHardwareLevel(staticInfo.getHardwareLevelChecked()),                         staticInfo.isHardwareLevelAtLeastLimited());             }              // H-1-4             Integer timestampSource = c.get(CameraCharacteristics.SENSOR_INFO_TIMESTAMP_SOURCE);             mCollector.expectTrue(                     ""Primary rear/front camera should support real-time timestamp source"",                     timestampSource != null &&                     timestampSource.equals(CameraMetadata.SENSOR_INFO_TIMESTAMP_SOURCE_REALTIME));              // H-1-8             if (isSPerfClass && isPrimaryRear) {                 mCollector.expectTrue(""Primary rear camera should support RAW capability"",                         staticInfo.isCapabilitySupported(RAW));             }         }         mCollector.expectTrue(""There must be a primary rear camera for performance class."",                 hasPrimaryRear);         mCollector.expectTrue(""There must be a primary front camera for performance class."",                 hasPrimaryFront);     }      /**      * Get lens distortion coefficients, as a list of 6 floats; returns null if no valid      * distortion field is available      */     private float[] getLensDistortion(CameraCharacteristics c) {         float[] distortion = null;         float[] newDistortion = c.get(CameraCharacteristics.LENS_DISTORTION);         if (Build.VERSION.FIRST_SDK_INT > Build.VERSION_CODES.O_MR1 || newDistortion != null) {             // New devices need to use fixed radial distortion definition; old devices can             // opt-in to it             if (newDistortion != null && newDistortion.length == 5) {                 distortion = new float[6];                 distortion[0] = 1.0f;                 for (int i = 1; i < 6; i++) {                     distortion[i] = newDistortion[i-1];                 }             }         } else {             // Select old field only if on older first SDK and new definition not available             distortion = c.get(CameraCharacteristics.LENS_RADIAL_DISTORTION);         }         return distortion;     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(Size[] goodSizes) {         return findInvalidSize(Arrays.asList(goodSizes));     }      /**      * Create an invalid size that's close to one of the good sizes in the list, but not one of them      */     private Size findInvalidSize(List<Size> goodSizes) {         Size invalidSize = new Size(goodSizes.get(0).getWidth() + 1, goodSizes.get(0).getHeight());         while(goodSizes.contains(invalidSize)) {             invalidSize = new Size(invalidSize.getWidth() + 1, invalidSize.getHeight());         }         return invalidSize;     }      /**      * Check key is present in characteristics if the hardware level is at least {@code hwLevel};      * check that the key is present if the actual capabilities are one of {@code capabilities}.      *      * @return value of the {@code key} from {@code c}      */     private <T> T expectKeyAvailable(CameraCharacteristics c, CameraCharacteristics.Key<T> key,             int hwLevel, int... capabilities) {          Integer actualHwLevel = c.get(CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL);         assertNotNull(""android.info.supportedHardwareLevel must never be null"", actualHwLevel);          int[] actualCapabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);         assertNotNull(""android.request.availableCapabilities must never be null"",                 actualCapabilities);          List<Key<?>> allKeys = c.getKeys();          T value = c.get(key);          // For LIMITED-level targeted keys, rely on capability check, not level         if ((compareHardwareLevel(actualHwLevel, hwLevel) >= 0) && (hwLevel != LIMITED)) {             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for this hardware level "" +                             ""(required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     value != null);             mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for this "" +                             ""hardware level (required minimal HW level %s, actual HW level %s)"",                             key.getName(), toStringHardwareLevel(hwLevel),                             toStringHardwareLevel(actualHwLevel)),                     allKeys.contains(key));         } else if (arrayContainsAnyOf(actualCapabilities, capabilities)) {             if (!(hwLevel == LIMITED && compareHardwareLevel(actualHwLevel, hwLevel) < 0)) {                 // Don't enforce LIMITED-starting keys on LEGACY level, even if cap is defined                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics for these capabilities "" +                             ""(required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     value != null);                 mCollector.expectTrue(                     String.format(""Key (%s) must be in characteristics list of keys for "" +                             ""these capabilities (required capabilities %s, actual capabilities %s)"",                             key.getName(), Arrays.toString(capabilities),                             Arrays.toString(actualCapabilities)),                     allKeys.contains(key));             }         } else {             if (actualHwLevel == LEGACY && hwLevel != OPT) {                 if (value != null || allKeys.contains(key)) {                     Log.w(TAG, String.format(                             ""Key (%s) is not required for LEGACY devices but still appears"",                             key.getName()));                 }             }             // OK: Key may or may not be present.         }         return value;     }      private static boolean arrayContains(int[] arr, int needle) {         if (arr == null) {             return false;         }          for (int elem : arr) {             if (elem == needle) {                 return true;             }         }          return false;     }      private static <T> boolean arrayContains(T[] arr, T needle) {         if (arr == null) {             return false;         }          for (T elem : arr) {             if (elem.equals(needle)) {                 return true;             }         }          return false;     }      private static boolean arrayContainsAnyOf(int[] arr, int[] needles) {         for (int needle : needles) {             if (arrayContains(arr, needle)) {                 return true;             }         }         return false;     }      /**      * The key name has a prefix of either ""android."" or a valid TLD; other prefixes are not valid.      */     private static void assertKeyPrefixValid(String keyName) {         assertStartsWithAndroidOrTLD(                 ""All metadata keys must start with 'android.' (built-in keys) "" +                 ""or valid TLD (vendor-extended keys)"", keyName);     }      private static void assertTrueForKey(String msg, CameraCharacteristics.Key<?> key,             boolean actual) {         assertTrue(msg + "" (key = '"" + key.getName() + ""')"", actual);     }      private static <T> void assertOneOf(String msg, T[] expected, T actual) {         for (int i = 0; i < expected.length; ++i) {             if (Objects.equals(expected[i], actual)) {                 return;             }         }          fail(String.format(""%s: (expected one of %s, actual %s)"",                 msg, Arrays.toString(expected), actual));     }      private static <T> void assertStartsWithAndroidOrTLD(String msg, String keyName) {         String delimiter = ""."";         if (keyName.startsWith(PREFIX_ANDROID + delimiter)) {             return;         }         Pattern tldPattern = Pattern.compile(Patterns.TOP_LEVEL_DOMAIN_STR);         Matcher match = tldPattern.matcher(keyName);         if (match.find(0) && (0 == match.start()) && (!match.hitEnd())) {             if (keyName.regionMatches(match.end(), delimiter, 0, delimiter.length())) {                 return;             }         }          fail(String.format(""%s: (expected to start with %s or valid TLD, but value was %s)"",                 msg, PREFIX_ANDROID + delimiter, keyName));     }      /** Return a positive int if left > right, 0 if left==right, negative int if left < right */     private static int compareHardwareLevel(int left, int right) {         return remapHardwareLevel(left) - remapHardwareLevel(right);     }      /** Remap HW levels worst<->best, 0 = LEGACY, 1 = LIMITED, 2 = FULL, ..., N = LEVEL_N */     private static int remapHardwareLevel(int level) {         switch (level) {             case OPT:                 return Integer.MAX_VALUE;             case LEGACY:                 return 0; // lowest             case EXTERNAL:                 return 1; // second lowest             case LIMITED:                 return 2;             case FULL:                 return 3; // good             case LEVEL_3:                 return 4;             default:                 fail(""Unknown HW level: "" + level);         }         return -1;     }      private static String toStringHardwareLevel(int level) {         switch (level) {             case LEGACY:                 return ""LEGACY"";             case LIMITED:                 return ""LIMITED"";             case FULL:                 return ""FULL"";             case EXTERNAL:                 return ""EXTERNAL"";             default:                 if (level >= LEVEL_3) {                     return String.format(""LEVEL_%d"", level);                 }         }          // unknown         Log.w(TAG, ""Unknown hardware level "" + level);         return Integer.toString(level);     } } ",3.8.16/H-1-4,,03081600.720104,3.8.16 H-1-4,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testCameraPerfClassCharacteristics()],,H-1-4,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,3.2.3.5,C-2-6,,android.server.wm.MultiDisplaySecurityTests,testConsequentLaunchActivityFromVirtualDisplayNoEmbedding(),,"     public void testConsequentLaunchActivityFromVirtualDisplayNoEmbedding() {         // Create new virtual display.         final DisplayContent newDisplay = createManagedVirtualDisplaySession().createDisplay();          // Launch activity on new secondary display.         launchActivityOnDisplay(LAUNCHING_ACTIVITY, newDisplay.mId);          waitAndAssertActivityStateOnDisplay(LAUNCHING_ACTIVITY, STATE_RESUMED, newDisplay.mId,                 ""Activity launched on secondary display must be resumed"");          separateTestJournal();          // Launch second activity from app on secondary display specifying same display id.         getLaunchActivityBuilder()                 .setTargetActivity(SECOND_NO_EMBEDDING_ACTIVITY)                 .setDisplayId(newDisplay.mId)                 .execute();          assertSecurityExceptionFromActivityLauncher();     }      private boolean isActivityStartAllowedOnDisplay(int displayId, ComponentName activity) {         final Intent intent = new Intent(Intent.ACTION_VIEW).setComponent(activity);         return mTargetContext.getSystemService(ActivityManager.class)                 .isActivityStartAllowedOnDisplay(mTargetContext, displayId, intent);     }      /**      * Tests      * {@link android.app.ActivityManager#isActivityStartAllowedOnDisplay(Context, int, Intent)}      * for simulated display. It is owned by system and is public, so should be accessible.      */     ",3.2.3.5/C-2-6,,03020305.670206,3.2.3.5 ACTION_SENDTO C-2-6 android.intent.action.VIEW VIEW SENDTO android.intent.action.SENDTO SMS,Test[None]:[android.server.wm.MultiDisplaySecurityTests:testConsequentLaunchActivityFromVirtualDisplayNoEmbedding()],,VIEW,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplaySecurityTests.java,,
,3.2.3.5,C-5-2,,android.app.notification.legacy.cts.ConditionProviderServiceTest,testUnboundCPSMaintainsCondition_otherProviderRuleChanges(),,"     public void testUnboundCPSMaintainsCondition_otherProviderRuleChanges() throws Exception {         // make sure both services get bound         pollForConnection(LegacyConditionProviderService.class, true);         pollForConnection(SecondaryConditionProviderService.class, true);          // add rules for both         mModeReceiver.reset();          addRule(LegacyConditionProviderService.getId(), INTERRUPTION_FILTER_PRIORITY, true);         pollForSubscribe(LegacyConditionProviderService.getInstance());          addRule(SecondaryConditionProviderService.getId(), INTERRUPTION_FILTER_ALARMS, true);         pollForSubscribe(SecondaryConditionProviderService.getInstance());          mModeReceiver.waitFor(2/*Legacy and Secondary*/, 1000/*Limit is 1 second*/);         assertEquals(INTERRUPTION_FILTER_ALARMS, mNm.getCurrentInterruptionFilter());          // unbind one of the services         SecondaryConditionProviderService.getInstance().requestUnbind();          // verify that DND state doesn't change         assertEquals(INTERRUPTION_FILTER_ALARMS, mNm.getCurrentInterruptionFilter());          // trigger a change in the bound service's rule         addRule(SecondaryConditionProviderService.getId(), INTERRUPTION_FILTER_PRIORITY, false);          // verify that the unbound service maintains it's DND vote         assertEquals(INTERRUPTION_FILTER_ALARMS, mNm.getCurrentInterruptionFilter());     }      ",3.2.3.5/C-5-2,,03020305.670502,3.2.3.5 DND android.bluetooth.adapter.action.REQUEST C-5-2 ACTION_REQUEST_DISCOVERABLE REQUEST_DISCOVERABLE,Test[None]:[android.app.notification.legacy.cts.ConditionProviderServiceTest:testUnboundCPSMaintainsCondition_otherProviderRuleChanges()],,DND,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/tests/notificationlegacy/notificationlegacy27/src/android/app/notification/legacy/cts/ConditionProviderServiceTest.java,,
,3.2.3.5,C-6-1,,android.app.notification.legacy.cts.ConditionProviderServiceTest,testUnboundCPSMaintainsCondition_otherProviderRuleChanges(),,"     public void testUnboundCPSMaintainsCondition_otherProviderRuleChanges() throws Exception {         // make sure both services get bound         pollForConnection(LegacyConditionProviderService.class, true);         pollForConnection(SecondaryConditionProviderService.class, true);          // add rules for both         mModeReceiver.reset();          addRule(LegacyConditionProviderService.getId(), INTERRUPTION_FILTER_PRIORITY, true);         pollForSubscribe(LegacyConditionProviderService.getInstance());          addRule(SecondaryConditionProviderService.getId(), INTERRUPTION_FILTER_ALARMS, true);         pollForSubscribe(SecondaryConditionProviderService.getInstance());          mModeReceiver.waitFor(2/*Legacy and Secondary*/, 1000/*Limit is 1 second*/);         assertEquals(INTERRUPTION_FILTER_ALARMS, mNm.getCurrentInterruptionFilter());          // unbind one of the services         SecondaryConditionProviderService.getInstance().requestUnbind();          // verify that DND state doesn't change         assertEquals(INTERRUPTION_FILTER_ALARMS, mNm.getCurrentInterruptionFilter());          // trigger a change in the bound service's rule         addRule(SecondaryConditionProviderService.getId(), INTERRUPTION_FILTER_PRIORITY, false);          // verify that the unbound service maintains it's DND vote         assertEquals(INTERRUPTION_FILTER_ALARMS, mNm.getCurrentInterruptionFilter());     }      ",3.2.3.5/C-6-1,,03020305.670601,3.2.3.5 ACTION_NOTIFICATION_POLICY_ACCESS_SETTINGS DND MODE_TYPE_NORMAL C-6-1,Test[None]:[android.app.notification.legacy.cts.ConditionProviderServiceTest:testUnboundCPSMaintainsCondition_otherProviderRuleChanges()],,DND,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/tests/notificationlegacy/notificationlegacy27/src/android/app/notification/legacy/cts/ConditionProviderServiceTest.java,,
,3.2.3.5,C-8-1,,android.accessibilityservice.cts.AccessibilitySettingsTest,testAccessibilitySettingsIntentHandled(),CtsAccessibilityServiceTestCases,"     public void testAccessibilitySettingsIntentHandled() throws Throwable {         PackageManager packageManager = getContext().getPackageManager();         Intent intent = new Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS);         List<ResolveInfo> resolvedActivities = packageManager.queryIntentActivities(intent,                 PackageManager.MATCH_DEFAULT_ONLY);          // make sure accessibility settings exist         String message = ""Accessibility settings activity must be launched via Intent "" +                 ""Settings.ACTION_ACCESSIBILITY_SETTINGS"";         assertTrue(message, !resolvedActivities.isEmpty());     } }  ",3.2.3.5/C-8-1,,03020305.670801,3.2.3.5 ACTION_ACCESSIBILITY_SETTINGS android.settings.ACCESSIBILITY ACCESSIBILITY_SETTINGS C-8-1,Test[CtsAccessibilityServiceTestCases]:[android.accessibilityservice.cts.AccessibilitySettingsTest:testAccessibilitySettingsIntentHandled()],,ACCESSIBILITY_SETTINGS,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilitySettingsTest.java,,
,3.2.3.5,C-11-1,,android.app.uiautomation.cts.UiAutomationTest,testServiceSupressingA11yServices_a11yServiceStartsWhenFlagsChange(),,"     public void testServiceSupressingA11yServices_a11yServiceStartsWhenFlagsChange()             throws Exception {         turnAccessibilityOff();         try {             getInstrumentation()                     .getUiAutomation(UiAutomation.FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES);             enableAccessibilityService();             getInstrumentation().getUiAutomation();             // We verify above that the connection is broken here. Make sure we see a new one             // after we change the flags             waitForAccessibilityServiceToUnbind();             getInstrumentation()                     .getUiAutomation(UiAutomation.FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES);             waitForAccessibilityServiceToStart();         } finally {             turnAccessibilityOff();         }     }      private void scrollListView(UiAutomation uiAutomation, final ListView listView,             final int position) throws TimeoutException {         getInstrumentation().runOnMainSync(new Runnable() {             @Override             public void run() {                 listView.smoothScrollToPosition(position);             }         });         Runnable emptyRunnable = new Runnable() {             @Override             public void run() {             }         };         UiAutomation.AccessibilityEventFilter scrollFilter =                 new UiAutomation.AccessibilityEventFilter() {                     @Override                     public boolean accept(AccessibilityEvent accessibilityEvent) {                         return accessibilityEvent.getEventType()                                 == AccessibilityEvent.TYPE_VIEW_SCROLLED;                     }                 };         uiAutomation.executeAndWaitForEvent(emptyRunnable, scrollFilter,                 TOTAL_TIME_TO_WAIT_FOR_IDLE_STATE);         uiAutomation.waitForIdle(                 QUIET_TIME_TO_BE_CONSIDERED_IDLE_STATE, TOTAL_TIME_TO_WAIT_FOR_IDLE_STATE);     }      private void grantWriteSecureSettingsPermission(UiAutomation uiAutomation) {         uiAutomation.grantRuntimePermission(getInstrumentation().getContext().getPackageName(),                 android.Manifest.permission.WRITE_SECURE_SETTINGS);     }      private void enableAccessibilityService() {         Context context = getInstrumentation().getContext();         AccessibilityManager manager =                 (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);         List<AccessibilityServiceInfo> serviceInfos =                 manager.getInstalledAccessibilityServiceList();         for (int i = 0; i < serviceInfos.size(); i++) {             AccessibilityServiceInfo serviceInfo = serviceInfos.get(i);             if (context.getString(R.string.uiautomation_a11y_service_description)                     .equals(serviceInfo.getDescription())) {                 ContentResolver cr = context.getContentResolver();                 String enabledServices = Settings.Secure.getString(cr,                         Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES);                 Settings.Secure.putString(cr, Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES,                         enabledServices + COMPONENT_NAME_SEPARATOR + serviceInfo.getId());                 Settings.Secure.putInt(cr, Settings.Secure.ACCESSIBILITY_ENABLED, 1);                 waitForAccessibilityServiceToStart();                 return;             }         }         throw new RuntimeException(""Test accessibility service not found"");     }      private void waitForAccessibilityServiceToStart() {         long timeoutTimeMillis = SystemClock.uptimeMillis() + TIMEOUT_FOR_SERVICE_ENABLE;         while (SystemClock.uptimeMillis() < timeoutTimeMillis) {             synchronized(UiAutomationTestA11yService.sWaitObjectForConnectOrUnbind) {                 if (UiAutomationTestA11yService.sConnectedInstance != null) {                     return;                 }                 try {                     UiAutomationTestA11yService.sWaitObjectForConnectOrUnbind.wait(                             timeoutTimeMillis - SystemClock.uptimeMillis());                 } catch (InterruptedException e) {                     // Ignored; loop again                 }             }         }         throw new RuntimeException(""Test accessibility service not starting"");     }      private void waitForAccessibilityServiceToUnbind() {         long timeoutTimeMillis = SystemClock.uptimeMillis() + TIMEOUT_FOR_SERVICE_ENABLE;         while (SystemClock.uptimeMillis() < timeoutTimeMillis) {             synchronized(UiAutomationTestA11yService.sWaitObjectForConnectOrUnbind) {                 if (UiAutomationTestA11yService.sConnectedInstance == null) {                     return;                 }                 try {                     UiAutomationTestA11yService.sWaitObjectForConnectOrUnbind.wait(                             timeoutTimeMillis - SystemClock.uptimeMillis());                 } catch (InterruptedException e) {                     // Ignored; loop again                 }             }         }         throw new RuntimeException(""Test accessibility service doesn't unbind"");     }      private void turnAccessibilityOff() {         getInstrumentation().getUiAutomation().destroy();         final Object waitLockForA11yOff = new Object();         Context context = getInstrumentation().getContext();         AccessibilityManager manager =                 (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);         manager.addAccessibilityStateChangeListener(                 new AccessibilityManager.AccessibilityStateChangeListener() {                     @Override                     public void onAccessibilityStateChanged(boolean b) {                         synchronized (waitLockForA11yOff) {                             waitLockForA11yOff.notifyAll();                         }                     }                 });         ContentResolver cr = context.getContentResolver();         Settings.Secure.putString(                 cr, Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES, null);         long timeoutTimeMillis = SystemClock.uptimeMillis() + TIMEOUT_FOR_SERVICE_ENABLE;         while (SystemClock.uptimeMillis() < timeoutTimeMillis) {             synchronized (waitLockForA11yOff) {                 if (!manager.isEnabled()) {                     return;                 }                 try {                     waitLockForA11yOff.wait(timeoutTimeMillis - SystemClock.uptimeMillis());                 } catch (InterruptedException e) {                     // Ignored; loop again                 }             }         }         throw new RuntimeException(""Unable to turn accessibility off"");     }      private void assertWindowContentTimestampsInAscendingOrder(WindowContentFrameStats stats) {         long lastExpectedTimeNano = 0;         long lastPresentedTimeNano = 0;         long lastPreparedTimeNano = 0;          final int frameCount = stats.getFrameCount();         for (int i = 0; i < frameCount; i++) {             final long expectedTimeNano = stats.getFramePostedTimeNano(i);             assertTrue(expectedTimeNano >= lastExpectedTimeNano);             lastExpectedTimeNano = expectedTimeNano;              final long presentedTimeNano = stats.getFramePresentedTimeNano(i);             if (lastPresentedTimeNano == FrameStats.UNDEFINED_TIME_NANO) {                 assertTrue(presentedTimeNano == FrameStats.UNDEFINED_TIME_NANO);             } else if (presentedTimeNano != FrameStats.UNDEFINED_TIME_NANO) {                 assertTrue(presentedTimeNano >= lastPresentedTimeNano);             }             lastPresentedTimeNano = presentedTimeNano;              final long preparedTimeNano = stats.getFrameReadyTimeNano(i);             if (lastPreparedTimeNano == FrameStats.UNDEFINED_TIME_NANO) {                 assertTrue(preparedTimeNano == FrameStats.UNDEFINED_TIME_NANO);             } else if (preparedTimeNano != FrameStats.UNDEFINED_TIME_NANO) {                 assertTrue(preparedTimeNano >= lastPreparedTimeNano);             }             lastPreparedTimeNano = preparedTimeNano;         }     }      private void assertWindowAnimationTimestampsInAscendingOrder(WindowAnimationFrameStats stats) {         long lastPresentedTimeNano = 0;          final int frameCount = stats.getFrameCount();         for (int i = 0; i < frameCount; i++) {             final long presentedTimeNano = stats.getFramePresentedTimeNano(i);             if (lastPresentedTimeNano == FrameStats.UNDEFINED_TIME_NANO) {                 assertTrue(presentedTimeNano == FrameStats.UNDEFINED_TIME_NANO);             } else if (presentedTimeNano != FrameStats.UNDEFINED_TIME_NANO) {                 assertTrue(presentedTimeNano >= lastPresentedTimeNano);             }             lastPresentedTimeNano = presentedTimeNano;         }     }      private int findAppWindowId(List<AccessibilityWindowInfo> windows) {         final int windowCount = windows.size();         for (int i = 0; i < windowCount; i++) {             AccessibilityWindowInfo window = windows.get(i);             if (window.getType() == AccessibilityWindowInfo.TYPE_APPLICATION) {                 return window.getId();             }         }         return -1;     }      private Instrumentation getInstrumentation() {         return InstrumentationRegistry.getInstrumentation();     } } ",3.2.3.5/C-11-1,,03020305.671101,3.2.3.5 ACTION_IGNORE_BACKGROUND_DATA_RESTRICTIONS_SET Settings.ACTION C-11-1 android.hardware.camera.any TINGS,Test[None]:[android.app.uiautomation.cts.UiAutomationTest:testServiceSupressingA11yServices_a11yServiceStartsWhenFlagsChange()],,TINGS,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/tests/uiautomation/src/android/app/uiautomation/cts/UiAutomationTest.java,,
,3.2.3.5,C-13-2,,android.content.cts.ClipboardManagerTest,testPrimaryClipNotAvailableWithoutFocus(),,"     public void testPrimaryClipNotAvailableWithoutFocus() throws Exception {         ClipData textData = ClipData.newPlainText(""TextLabel"", ""Text1"");         assertSetPrimaryClip(textData, ""TextLabel"",                 new String[] {ClipDescription.MIMETYPE_TEXT_PLAIN},                 new ExpectedClipItem(""Text1"", null, null));          // Press the home button to unfocus the app.         mUiDevice.pressHome();         mUiDevice.wait(Until.gone(By.clazz(MockActivity.class)), 5000);          // We should see an empty clipboard now.         assertFalse(mClipboardManager.hasPrimaryClip());         assertFalse(mClipboardManager.hasText());         assertNull(mClipboardManager.getPrimaryClip());         assertNull(mClipboardManager.getPrimaryClipDescription());          // We should be able to set the clipboard but not see the contents.         mClipboardManager.setPrimaryClip(ClipData.newPlainText(""TextLabel"", ""Text2""));         assertFalse(mClipboardManager.hasPrimaryClip());         assertFalse(mClipboardManager.hasText());         assertNull(mClipboardManager.getPrimaryClip());         assertNull(mClipboardManager.getPrimaryClipDescription());          // Launch an activity to get back in focus.         launchActivity(MockActivity.class);           // Verify clipboard access is restored.         assertNotNull(mClipboardManager.getPrimaryClip());         assertNotNull(mClipboardManager.getPrimaryClipDescription());          // Verify we were unable to change the clipboard while out of focus.         assertClipData(mClipboardManager.getPrimaryClip(),                 ""TextLabel"",                 new String[] {ClipDescription.MIMETYPE_TEXT_PLAIN},                 new ExpectedClipItem(""Text2"", null, null));     }      private void launchActivity(Class<? extends Activity> clazz) {         Intent intent = new Intent(Intent.ACTION_MAIN);         intent.setClassName(mContext.getPackageName(), clazz.getName());         intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);         mContext.startActivity(intent);         mUiDevice.wait(Until.hasObject(By.clazz(clazz)), 5000);     }      private class ExpectedClipItem {         CharSequence mText;         Intent mIntent;         Uri mUri;          ExpectedClipItem(CharSequence text, Intent intent, Uri uri) {             mText = text;             mIntent = intent;             mUri = uri;         }     }      private void assertSetPrimaryClip(ClipData clipData,             String expectedLabel,             String[] expectedMimeTypes,             ExpectedClipItem... expectedClipItems) {         ClipboardManager clipboardManager = mClipboardManager;          clipboardManager.setPrimaryClip(clipData);         assertTrue(clipboardManager.hasPrimaryClip());          if (expectedClipItems != null                 && expectedClipItems.length > 0                 && expectedClipItems[0].mText != null) {             assertTrue(clipboardManager.hasText());         } else {             assertFalse(clipboardManager.hasText());         }          assertNotNull(clipboardManager.getPrimaryClip());         assertNotNull(clipboardManager.getPrimaryClipDescription());          assertClipData(clipboardManager.getPrimaryClip(),                 expectedLabel, expectedMimeTypes, expectedClipItems);          assertClipDescription(clipboardManager.getPrimaryClipDescription(),                 expectedLabel, expectedMimeTypes);     }      private static void assertClipData(ClipData actualData, String expectedLabel,             String[] expectedMimeTypes, ExpectedClipItem... expectedClipItems) {         if (expectedClipItems != null) {             assertEquals(expectedClipItems.length, actualData.getItemCount());             for (int i = 0; i < expectedClipItems.length; i++) {                 assertClipItem(expectedClipItems[i], actualData.getItemAt(i));             }         } else {             throw new IllegalArgumentException(""Should have at least one expectedClipItem..."");         }          assertClipDescription(actualData.getDescription(), expectedLabel, expectedMimeTypes);     }      private static void assertClipDescription(ClipDescription description, String expectedLabel,             String... mimeTypes) {         assertEquals(expectedLabel, description.getLabel());         assertEquals(mimeTypes.length, description.getMimeTypeCount());         int mimeTypeCount = description.getMimeTypeCount();         for (int i = 0; i < mimeTypeCount; i++) {             assertEquals(mimeTypes[i], description.getMimeType(i));         }     }      private static void assertClipItem(ExpectedClipItem expectedItem, Item item) {         assertEquals(expectedItem.mText, item.getText());         if (expectedItem.mIntent != null) {             assertNotNull(item.getIntent());         } else {             assertNull(item.getIntent());         }         if (expectedItem.mUri != null) {             assertEquals(expectedItem.mUri.toString(), item.getUri().toString());         } else {             assertNull(item.getUri());         }     }      private boolean hasAutoFillFeature() {         return mContext.getPackageManager().hasSystemFeature(                 PackageManager.FEATURE_AUTOFILL);     } } ",3.2.3.5/C-13-2,,03020305.671302,android.app.action.SET PROVISIONING_SUCCESSFUL ACTION_ADMIN_POLICY_COMPLIANCE android.app.action.PROVISIONING PackageManager.html android.app.action.START SET_NEW_PARENT_PROFILE_PASSWORD SET_NEW_PASSWORD android.software.autofill android.app.action.GET PROVISION_MANAGED_PROFILE PROVISION_MANAGED_DEVICE ACTION_START_ENCRYPTION C-13-2 android.app.action.PROVISION GET_PROVISIONING_MODE 3.2.3.5 START_ENCRYPTION FEATURE_AUTOFILL android.app.action.ADMIN ADMIN_POLICY_COMPLIANCE,Test[None]:[android.content.cts.ClipboardManagerTest:testPrimaryClipNotAvailableWithoutFocus()],,FEATURE_AUTOFILL,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/tests/content/src/android/content/cts/ClipboardManagerTest.java,,
,3.2.3.5,C-14-1,,android.autofillservice.cts.SettingsIntentTest,testWarningShown_userRejectsByTappingBack(),CtsAutoFillServiceTestCases,"     public void testWarningShown_userRejectsByTappingBack() throws Exception {         disableService();          // Launches Settings.         mActivity.startForResult(newSettingsIntent(), MY_REQUEST_CODE);          // Asserts services are shown.         final UiObject2 object = mUiBot                 .assertShownByText(InstrumentedAutoFillService.sServiceLabel);         object.click();          // TODO(b/79615759): should assert that ""autofill_confirmation_message"" is shown, but that         // string belongs to Settings - we need to move it to frameworks/base first (and/or use         // a resource id, also on framework).         // So, for now, just asserts the service name is showing again (in the popup), and the other         // services are not showing (because the popup hides then).          final UiObject2 msgObj = mUiBot.assertShownById(""android:id/message"");         final String msg = msgObj.getText();         assertWithMessage(""Wrong warning message"").that(msg)                 .contains(InstrumentedAutoFillService.sServiceLabel);          // NOTE: assertion below is fine because it looks for the full text, not a substring         mUiBot.assertNotShowingForSure(InstrumentedAutoFillService.sServiceLabel);         mUiBot.assertNotShowingForSure(InstrumentedAutoFillServiceCompatMode.sServiceLabel);         mUiBot.assertNotShowingForSure(NoOpAutofillService.SERVICE_LABEL);         mUiBot.assertNotShowingForSure(BadAutofillService.SERVICE_LABEL);          // Finishes and asserts result.         mUiBot.pressBack();         mActivity.assertResult(Activity.RESULT_CANCELED);     }      // TODO(b/79615759): add testWarningShown_userRejectsByTappingCancel() and     // testWarningShown_userAccepts() - these tests would require adding the strings and resource     // ids to frameworks/base      private Intent newSettingsIntent() {         return new Intent(Settings.ACTION_REQUEST_SET_AUTOFILL_SERVICE)                 .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK)                 .setData(Uri.parse(""package:"" + Helper.MY_PACKAGE));     } } ",3.2.3.5/C-14-1,,03020305.671401,3.2.3.5 AutofillManager.html AutofillService.html android.settings.REQUEST ACTION_REQUEST_SET_AUTOFILL_SERVICE C-14-1 Settings.html REQUEST_SET_AUTOFILL_SERVICE,Test[CtsAutoFillServiceTestCases]:[android.autofillservice.cts.SettingsIntentTest:testWarningShown_userRejectsByTappingBack()],,REQUEST_SET_AUTOFILL_SERVICE,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/autofillservice/src/android/autofillservice/cts/SettingsIntentTest.java,,
,3.2.3.5,C-15-1,,android.car.cts.CarPropertyManagerTest,testSetProperty(),,"     public void testSetProperty() {         List<CarPropertyConfig> configs = mCarPropertyManager.getPropertyList();         for (CarPropertyConfig cfg : configs) {             if (cfg.getAccess() == CarPropertyConfig.VEHICLE_PROPERTY_ACCESS_READ_WRITE                     && cfg.getPropertyType() == Boolean.class) {                 // In R, there is no property which is writable for third-party apps.                 for (int areaId : getAreaIdsHelper(cfg)) {                     assertThrows(SecurityException.class,                             () -> mCarPropertyManager.setBooleanProperty(                                     cfg.getPropertyId(), areaId,true));                 }             }         }     }      ",3.2.3.5/C-15-1,,03020305.671501,SETTINGS 3.2.3.5 USAGE android.settings.ACTION C-15-1 ACTION_USAGE_ACCESS_SETTINGS ACCESS Settings.html ACTION android.hardware.audio.output,Test[None]:[android.car.cts.CarPropertyManagerTest:testSetProperty()],,ACCESS,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/tests/car/src/android/car/cts/CarPropertyManagerTest.java,,
,3.9.2,C-2-1,,android.server.wm.DreamManagerServiceTests,getPackageName(),,"/*  *  */  package android.server.wm;  import static android.app.WindowConfiguration.WINDOWING_MODE_FULLSCREEN; import static android.server.wm.app.Components.TEST_ACTIVITY; import static android.server.wm.app.Components.TEST_DREAM_SERVICE; import static android.server.wm.app.Components.TEST_STUBBORN_DREAM_SERVICE; import static android.server.wm.ComponentNameUtils.getWindowName;  import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import static android.view.Display.DEFAULT_DISPLAY;  import static org.junit.Assume.assumeTrue;  import android.app.DreamManager; import android.content.ComponentName; import android.platform.test.annotations.Presubmit; import android.provider.Settings; import android.view.Surface; import android.content.res.Resources;  import androidx.test.filters.FlakyTest;  import com.android.compatibility.common.util.SystemUtil;  import org.junit.After; import org.junit.Before; import org.junit.Test;  @Presubmit @FlakyTest(detail = ""Promote once confirmed non-flaky"") public class DreamManagerServiceTests extends ActivityManagerTestBase {      // Timeout after which the dream should have finished willingly     private static final long ACTIVITY_STOP_TIMEOUT = 3000;      // Timeout after which the dream should have been forcefully stopped     private static final long ACTIVITY_FORCE_STOP_TIMEOUT = 6500;      private ComponentName mDreamActivityName;      private boolean mDefaultDreamServiceEnabled = true;      private static final ComponentName getDreamActivityName(ComponentName dream) {         return new ComponentName(dream.getPackageName(),                                  ""android.service.dreams.DreamActivity"");     }      @Before     public void setup() { 	assumeTrue(""Skipping test: no dream support"", supportsDream());          mDefaultDreamServiceEnabled =                 Settings.Secure.getInt(mContext.getContentResolver(),                                 ""screensaver_enabled"", 1) != 0;         if (!mDefaultDreamServiceEnabled) {             SystemUtil.runWithShellPermissionIdentity(() -> {                 Settings.Secure.putInt(mContext.getContentResolver(), ""screensaver_enabled"", 1);             });         }     }      @After     public void reset()  {         if (!mDefaultDreamServiceEnabled) {             SystemUtil.runWithShellPermissionIdentity(() -> {                 Settings.Secure.putInt(mContext.getContentResolver(), ""screensaver_enabled"", 0);             });         }     }      private void startDream(ComponentName name) {         DreamManager dreamer = mContext.getSystemService(DreamManager.class);         SystemUtil.runWithShellPermissionIdentity(() -> {             dreamer.startDream(name);         });     }      private void stopDream() {         DreamManager dreamer = mContext.getSystemService(DreamManager.class);         SystemUtil.runWithShellPermissionIdentity(() -> {             dreamer.stopDream();         });     }      private void setActiveDream(ComponentName dream) {         DreamManager dreamer = mContext.getSystemService(DreamManager.class);         SystemUtil.runWithShellPermissionIdentity(() -> {             dreamer.setActiveDream(dream);         });         mDreamActivityName = getDreamActivityName(dream);     }      private boolean getIsDreaming() {         DreamManager dreamer = mContext.getSystemService(DreamManager.class);         return SystemUtil.runWithShellPermissionIdentity(() -> {             return dreamer.isDreaming();         });     }      private boolean supportsDream() {         return mContext.getResources().getBoolean(             Resources.getSystem().getIdentifier(""config_dreamsSupported"", ""bool"", ""android""));     }      private void assertDreamActivityGone() {         mWmState.computeState();         assertTrue(!mWmState.containsWindow(getWindowName(mDreamActivityName))                    && !mWmState.containsActivity(mDreamActivityName));     }      private void startFullscreenTestActivity() {         launchActivity(TEST_ACTIVITY, WINDOWING_MODE_FULLSCREEN);         waitAndAssertTopResumedActivity(TEST_ACTIVITY, DEFAULT_DISPLAY,                 ""Test activity should be the top resumed activity"");         mWmState.assertVisibility(TEST_ACTIVITY, true);     }      ",3.9.2/C-2-1,,03090200.670201,ACTION_SET_NEW_PASSWORD android.content.ComponentName index.html C-2-1 DevicePolicyManager.html admin.html 3.9.2 DevicePolicyManager.ACTION DPC,Test[None]:[android.server.wm.DreamManagerServiceTests:getPackageName()],,android.content.ComponentName,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DreamManagerServiceTests.java,,
,6.1,C-0-11,,android.net.cts.InetAddressesTest,validNumericAddressesAndStringRepresentation(),,"/*  *.  */ package android.net.cts;  import android.net.InetAddresses; import java.net.InetAddress; import junitparams.JUnitParamsRunner; import junitparams.Parameters; import org.junit.Test; import org.junit.runner.RunWith;  import static com.google.common.truth.Truth.assertThat; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  @RunWith(JUnitParamsRunner.class) public class InetAddressesTest {      public static String[][] validNumericAddressesAndStringRepresentation() {         return new String[][] {             // Regular IPv4.             { ""1.2.3.4"", ""1.2.3.4"" },              // Regular IPv6.             { ""2001:4860:800d::68"", ""2001:4860:800d::68"" },             { ""1234:5678::9ABC:DEF0"", ""1234:5678::9abc:def0"" },             { ""2001:cdba:9abc:5678::"", ""2001:cdba:9abc:5678::"" },             { ""::2001:cdba:9abc:5678"", ""::2001:cdba:9abc:5678"" },             { ""64:ff9b::1.2.3.4"", ""64:ff9b::102:304"" },              { ""::9abc:5678"", ""::154.188.86.120"" },              // Mapped IPv4             { ""::ffff:127.0.0.1"", ""127.0.0.1"" },              // Android does not recognize Octal (leading 0) cases: they are treated as decimal.             { ""0177.00.00.01"", ""177.0.0.1"" },              // Verify that examples from JavaDoc work correctly.             { ""192.0.2.1"", ""192.0.2.1"" },             { ""2001:db8::1:2"", ""2001:db8::1:2"" },         };     }      public static String[] invalidNumericAddresses() {         return new String[] {             """",             "" "",             ""\t"",             ""\n"",             ""1.2.3.4."",             ""1.2.3"",             ""1.2"",             ""1"",             ""1234"",             ""0"",             ""0x1.0x2.0x3.0x4"",             ""0x7f.0x00.0x00.0x01"",             ""0256.00.00.01"",             ""fred"",             ""www.google.com"",             // IPv6 encoded for use in URL as defined in RFC 2732             ""[fe80::6:2222]"",         };     }      @Parameters(method = ""validNumericAddressesAndStringRepresentation"")     ",6.1/C-0-11,,06010000.670011,C-0-11 6.1,Test[None]:[android.net.cts.InetAddressesTest:validNumericAddressesAndStringRepresentation()],/home/gpoor/aosp_platform_source/cts/hostsidetests/adbmanager/src/android/adbmanager/cts/AdbManagerHostDeviceTest.java,6.1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/InetAddressesTest.java,,
,6.1,C-3-1,,android.net.cts.InetAddressesTest,validNumericAddressesAndStringRepresentation(),,"/*  *.  */ package android.net.cts;  import android.net.InetAddresses; import java.net.InetAddress; import junitparams.JUnitParamsRunner; import junitparams.Parameters; import org.junit.Test; import org.junit.runner.RunWith;  import static com.google.common.truth.Truth.assertThat; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  @RunWith(JUnitParamsRunner.class) public class InetAddressesTest {      public static String[][] validNumericAddressesAndStringRepresentation() {         return new String[][] {             // Regular IPv4.             { ""1.2.3.4"", ""1.2.3.4"" },              // Regular IPv6.             { ""2001:4860:800d::68"", ""2001:4860:800d::68"" },             { ""1234:5678::9ABC:DEF0"", ""1234:5678::9abc:def0"" },             { ""2001:cdba:9abc:5678::"", ""2001:cdba:9abc:5678::"" },             { ""::2001:cdba:9abc:5678"", ""::2001:cdba:9abc:5678"" },             { ""64:ff9b::1.2.3.4"", ""64:ff9b::102:304"" },              { ""::9abc:5678"", ""::154.188.86.120"" },              // Mapped IPv4             { ""::ffff:127.0.0.1"", ""127.0.0.1"" },              // Android does not recognize Octal (leading 0) cases: they are treated as decimal.             { ""0177.00.00.01"", ""177.0.0.1"" },              // Verify that examples from JavaDoc work correctly.             { ""192.0.2.1"", ""192.0.2.1"" },             { ""2001:db8::1:2"", ""2001:db8::1:2"" },         };     }      public static String[] invalidNumericAddresses() {         return new String[] {             """",             "" "",             ""\t"",             ""\n"",             ""1.2.3.4."",             ""1.2.3"",             ""1.2"",             ""1"",             ""1234"",             ""0"",             ""0x1.0x2.0x3.0x4"",             ""0x7f.0x00.0x00.0x01"",             ""0256.00.00.01"",             ""fred"",             ""www.google.com"",             // IPv6 encoded for use in URL as defined in RFC 2732             ""[fe80::6:2222]"",         };     }      @Parameters(method = ""validNumericAddressesAndStringRepresentation"")     ",6.1/C-3-1,,06010000.670301,6.1 C-3-1,Test[None]:[android.net.cts.InetAddressesTest:validNumericAddressesAndStringRepresentation()],,6.1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/InetAddressesTest.java,,
,6.1,C-3-2,,android.net.cts.InetAddressesTest,validNumericAddressesAndStringRepresentation(),,"/*  *.  */ package android.net.cts;  import android.net.InetAddresses; import java.net.InetAddress; import junitparams.JUnitParamsRunner; import junitparams.Parameters; import org.junit.Test; import org.junit.runner.RunWith;  import static com.google.common.truth.Truth.assertThat; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  @RunWith(JUnitParamsRunner.class) public class InetAddressesTest {      public static String[][] validNumericAddressesAndStringRepresentation() {         return new String[][] {             // Regular IPv4.             { ""1.2.3.4"", ""1.2.3.4"" },              // Regular IPv6.             { ""2001:4860:800d::68"", ""2001:4860:800d::68"" },             { ""1234:5678::9ABC:DEF0"", ""1234:5678::9abc:def0"" },             { ""2001:cdba:9abc:5678::"", ""2001:cdba:9abc:5678::"" },             { ""::2001:cdba:9abc:5678"", ""::2001:cdba:9abc:5678"" },             { ""64:ff9b::1.2.3.4"", ""64:ff9b::102:304"" },              { ""::9abc:5678"", ""::154.188.86.120"" },              // Mapped IPv4             { ""::ffff:127.0.0.1"", ""127.0.0.1"" },              // Android does not recognize Octal (leading 0) cases: they are treated as decimal.             { ""0177.00.00.01"", ""177.0.0.1"" },              // Verify that examples from JavaDoc work correctly.             { ""192.0.2.1"", ""192.0.2.1"" },             { ""2001:db8::1:2"", ""2001:db8::1:2"" },         };     }      public static String[] invalidNumericAddresses() {         return new String[] {             """",             "" "",             ""\t"",             ""\n"",             ""1.2.3.4."",             ""1.2.3"",             ""1.2"",             ""1"",             ""1234"",             ""0"",             ""0x1.0x2.0x3.0x4"",             ""0x7f.0x00.0x00.0x01"",             ""0256.00.00.01"",             ""fred"",             ""www.google.com"",             // IPv6 encoded for use in URL as defined in RFC 2732             ""[fe80::6:2222]"",         };     }      @Parameters(method = ""validNumericAddressesAndStringRepresentation"")     ",6.1/C-3-2,,06010000.670302,C-3-2 6.1,Test[None]:[android.net.cts.InetAddressesTest:validNumericAddressesAndStringRepresentation()],,6.1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/InetAddressesTest.java,,
,6.1,C-4-1,,android.net.cts.InetAddressesTest,validNumericAddressesAndStringRepresentation(),,"/*  *.  */ package android.net.cts;  import android.net.InetAddresses; import java.net.InetAddress; import junitparams.JUnitParamsRunner; import junitparams.Parameters; import org.junit.Test; import org.junit.runner.RunWith;  import static com.google.common.truth.Truth.assertThat; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  @RunWith(JUnitParamsRunner.class) public class InetAddressesTest {      public static String[][] validNumericAddressesAndStringRepresentation() {         return new String[][] {             // Regular IPv4.             { ""1.2.3.4"", ""1.2.3.4"" },              // Regular IPv6.             { ""2001:4860:800d::68"", ""2001:4860:800d::68"" },             { ""1234:5678::9ABC:DEF0"", ""1234:5678::9abc:def0"" },             { ""2001:cdba:9abc:5678::"", ""2001:cdba:9abc:5678::"" },             { ""::2001:cdba:9abc:5678"", ""::2001:cdba:9abc:5678"" },             { ""64:ff9b::1.2.3.4"", ""64:ff9b::102:304"" },              { ""::9abc:5678"", ""::154.188.86.120"" },              // Mapped IPv4             { ""::ffff:127.0.0.1"", ""127.0.0.1"" },              // Android does not recognize Octal (leading 0) cases: they are treated as decimal.             { ""0177.00.00.01"", ""177.0.0.1"" },              // Verify that examples from JavaDoc work correctly.             { ""192.0.2.1"", ""192.0.2.1"" },             { ""2001:db8::1:2"", ""2001:db8::1:2"" },         };     }      public static String[] invalidNumericAddresses() {         return new String[] {             """",             "" "",             ""\t"",             ""\n"",             ""1.2.3.4."",             ""1.2.3"",             ""1.2"",             ""1"",             ""1234"",             ""0"",             ""0x1.0x2.0x3.0x4"",             ""0x7f.0x00.0x00.0x01"",             ""0256.00.00.01"",             ""fred"",             ""www.google.com"",             // IPv6 encoded for use in URL as defined in RFC 2732             ""[fe80::6:2222]"",         };     }      @Parameters(method = ""validNumericAddressesAndStringRepresentation"")     ",6.1/C-4-1,,06010000.670401,6.1 C-4-1 isAdbWifiSupported(),Test[None]:[android.net.cts.InetAddressesTest:validNumericAddressesAndStringRepresentation()],,6.1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/InetAddressesTest.java,,
,6.1,C-5-1,,android.net.cts.InetAddressesTest,validNumericAddressesAndStringRepresentation(),,"/*  *.  */ package android.net.cts;  import android.net.InetAddresses; import java.net.InetAddress; import junitparams.JUnitParamsRunner; import junitparams.Parameters; import org.junit.Test; import org.junit.runner.RunWith;  import static com.google.common.truth.Truth.assertThat; import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import static org.junit.Assert.fail;  @RunWith(JUnitParamsRunner.class) public class InetAddressesTest {      public static String[][] validNumericAddressesAndStringRepresentation() {         return new String[][] {             // Regular IPv4.             { ""1.2.3.4"", ""1.2.3.4"" },              // Regular IPv6.             { ""2001:4860:800d::68"", ""2001:4860:800d::68"" },             { ""1234:5678::9ABC:DEF0"", ""1234:5678::9abc:def0"" },             { ""2001:cdba:9abc:5678::"", ""2001:cdba:9abc:5678::"" },             { ""::2001:cdba:9abc:5678"", ""::2001:cdba:9abc:5678"" },             { ""64:ff9b::1.2.3.4"", ""64:ff9b::102:304"" },              { ""::9abc:5678"", ""::154.188.86.120"" },              // Mapped IPv4             { ""::ffff:127.0.0.1"", ""127.0.0.1"" },              // Android does not recognize Octal (leading 0) cases: they are treated as decimal.             { ""0177.00.00.01"", ""177.0.0.1"" },              // Verify that examples from JavaDoc work correctly.             { ""192.0.2.1"", ""192.0.2.1"" },             { ""2001:db8::1:2"", ""2001:db8::1:2"" },         };     }      public static String[] invalidNumericAddresses() {         return new String[] {             """",             "" "",             ""\t"",             ""\n"",             ""1.2.3.4."",             ""1.2.3"",             ""1.2"",             ""1"",             ""1234"",             ""0"",             ""0x1.0x2.0x3.0x4"",             ""0x7f.0x00.0x00.0x01"",             ""0256.00.00.01"",             ""fred"",             ""www.google.com"",             // IPv6 encoded for use in URL as defined in RFC 2732             ""[fe80::6:2222]"",         };     }      @Parameters(method = ""validNumericAddressesAndStringRepresentation"")     ",6.1/C-5-1,,06010000.670501,6.1 isAdbWifiQrSupported() C-5-1,Test[None]:[android.net.cts.InetAddressesTest:validNumericAddressesAndStringRepresentation()],,6.1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/InetAddressesTest.java,,
,7.1.1.1,C-2-1,,android.appwidget.cts.RequestPinAppWidgetTest,testPinWidget_launcher2(),,"     public void testPinWidget_launcher2() throws Exception {         runPinWidgetTest(""android.appwidget.cts.packages.launcher2"");     }      @CddTest(requirement=""3.8.2/C-2-1"")     public void verifyIsRequestPinAppWidgetSupported(String launcherPkg, boolean expectedSupport)         throws Exception {         setLauncher(launcherPkg + ""/"" + LAUNCHER_CLASS);          Context context = getInstrumentation().getContext();         assertEquals(expectedSupport,                 AppWidgetManager.getInstance(context).isRequestPinAppWidgetSupported());     }      ",7.1.1.1/C-2-1,,07010101.670201,display(s) cs.android.com C-2-1 7.1.1.1,Test[None]:[android.appwidget.cts.RequestPinAppWidgetTest:testPinWidget_launcher2()],,C-2-1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/tests/appwidget/src/android/appwidget/cts/RequestPinAppWidgetTest.java,,
,7.1.1.1,C-3-1,,android.app.cts.SystemFeaturesTest,testFakeTouchFeatures(),CtsAppTestCases,"     public void testFakeTouchFeatures() {         // If device implementations declare support for android.hardware.faketouch, they:         // [C-1-7] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field         if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_FAKETOUCH) &&                 !mPackageManager.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN)) {             // The device *only* supports faketouch, and does not have a touchscreen             Configuration configuration = mContext.getResources().getConfiguration();             assertEquals(configuration.touchscreen, Configuration.TOUCHSCREEN_NOTOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.distinct, they:         // [C-2-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_DISTINCT)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.jazzhand, they:         // [C-3-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_JAZZHAND)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",7.1.1.1/C-3-1,,07010101.670301,7.1.1.1 C-3-1,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testFakeTouchFeatures()],,C-3-1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java,,
,7.1.4.2,C-1-10,,android.graphics.cts.VulkanFeaturesTest,testVulkanHardwareFeatures(),,"     public void testVulkanHardwareFeatures() throws JSONException {         if (DEBUG) {             Log.d(TAG, ""Inspecting "" + mVulkanDevices.length + "" devices"");         }         if (mVulkanDevices.length == 0) {             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareLevel);             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareLevel);             assertNull(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                        "" is supported, but no Vulkan physical devices are available"",                        mVulkanHardwareCompute);             return;         }          if (hasOnlyCpuDevice()) {             return;         }          assertNotNull(""Vulkan physical devices are available, but system feature "" +                       PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL + "" is not supported"",                       mVulkanHardwareLevel);         assertNotNull(""Vulkan physical devices are available, but system feature "" +                       PackageManager.FEATURE_VULKAN_HARDWARE_VERSION + "" is not supported"",                       mVulkanHardwareVersion);         if (mVulkanHardwareLevel == null || mVulkanHardwareVersion == null) {             return;         }          assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +                    "" version "" + mVulkanHardwareLevel.version + "" is not one of the defined "" +                    "" versions [0..1]"",                    mVulkanHardwareLevel.version >= 0 && mVulkanHardwareLevel.version <= 1);         assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +                    "" version 0x"" + Integer.toHexString(mVulkanHardwareVersion.version) + "" is not"" +                    "" one of the versions allowed"",                    isHardwareVersionAllowed(mVulkanHardwareVersion.version));         if (mVulkanHardwareCompute != null) {             assertTrue(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                        "" version "" + mVulkanHardwareCompute.version +                        "" is not one of the versions allowed"",                        mVulkanHardwareCompute.version == 0);         }          int bestDeviceLevel = determineHardwareLevel(mBestDevice);         int bestComputeLevel = determineHardwareCompute(mBestDevice);         int bestDeviceVersion = determineHardwareVersion(mBestDevice);          assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_LEVEL +             "" version "" + mVulkanHardwareLevel.version + "" doesn't match best physical device "" +             "" hardware level "" + bestDeviceLevel,             bestDeviceLevel, mVulkanHardwareLevel.version);         assertTrue(             ""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_VERSION +             "" version 0x"" + Integer.toHexString(mVulkanHardwareVersion.version) +             "" isn't close enough (same major and minor version, less or equal patch version)"" +             "" to best physical device version 0x"" + Integer.toHexString(bestDeviceVersion),             isVersionCompatible(bestDeviceVersion, mVulkanHardwareVersion.version));         if (mVulkanHardwareCompute == null) {             assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                 "" not present, but required features are supported"",                 bestComputeLevel, -1);         } else {             assertEquals(""System feature "" + PackageManager.FEATURE_VULKAN_HARDWARE_COMPUTE +                 "" version "" + mVulkanHardwareCompute.version +                 "" doesn't match best physical device (version: "" + bestComputeLevel + "")"",                 bestComputeLevel, mVulkanHardwareCompute.version);         }     }      @CddTest(requirement = ""7.1.4.2/C-3-1"")     ",7.1.4.2/C-1-10,,07010402.670110,android.software.vulkan.deqp.level EQP C-1-10 7.1.4.2,Test[None]:[android.graphics.cts.VulkanFeaturesTest:testVulkanHardwareFeatures()],,7.1.4.2,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/tests/graphics/src/android/graphics/cts/VulkanFeaturesTest.java,,
,7.2.3,C-3-1,,android.app.cts.SystemFeaturesTest,testFakeTouchFeatures(),CtsAppTestCases,"     public void testFakeTouchFeatures() {         // If device implementations declare support for android.hardware.faketouch, they:         // [C-1-7] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field         if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_FAKETOUCH) &&                 !mPackageManager.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN)) {             // The device *only* supports faketouch, and does not have a touchscreen             Configuration configuration = mContext.getResources().getConfiguration();             assertEquals(configuration.touchscreen, Configuration.TOUCHSCREEN_NOTOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.distinct, they:         // [C-2-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_DISTINCT)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.jazzhand, they:         // [C-3-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_JAZZHAND)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",7.2.3/C-3-1,,07020300.670301,KeyEvent.html 7.2.3 KEYCODE_ASSIST C-3-1,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testFakeTouchFeatures()],,C-3-1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java,,
,7.2.4,C-3-2,,android.app.cts.SystemFeaturesTest,testFakeTouchFeatures(),CtsAppTestCases,"     public void testFakeTouchFeatures() {         // If device implementations declare support for android.hardware.faketouch, they:         // [C-1-7] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field         if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_FAKETOUCH) &&                 !mPackageManager.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN)) {             // The device *only* supports faketouch, and does not have a touchscreen             Configuration configuration = mContext.getResources().getConfiguration();             assertEquals(configuration.touchscreen, Configuration.TOUCHSCREEN_NOTOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.distinct, they:         // [C-2-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_DISTINCT)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.jazzhand, they:         // [C-3-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_JAZZHAND)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",7.2.4/C-3-2,,07020400.670302,C-3-2 android.hardware.faketouch 7.2.4,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testFakeTouchFeatures()],,android.hardware.faketouch,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java,,
,7.2.4,C-3-3,,android.app.cts.SystemFeaturesTest,testFakeTouchFeatures(),CtsAppTestCases,"     public void testFakeTouchFeatures() {         // If device implementations declare support for android.hardware.faketouch, they:         // [C-1-7] MUST report TOUCHSCREEN_NOTOUCH for the Configuration.touchscreen API field         if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_FAKETOUCH) &&                 !mPackageManager.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN)) {             // The device *only* supports faketouch, and does not have a touchscreen             Configuration configuration = mContext.getResources().getConfiguration();             assertEquals(configuration.touchscreen, Configuration.TOUCHSCREEN_NOTOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.distinct, they:         // [C-2-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_DISTINCT)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }          // If device implementations declare support for         // android.hardware.faketouch.multitouch.jazzhand, they:         // [C-3-1] MUST declare support for android.hardware.faketouch         if (mPackageManager.hasSystemFeature(                 PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_JAZZHAND)) {             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",7.2.4/C-3-3,,07020400.670303,TOUCHSCREEN_NOTOUCH C-3-3 Configuration.touchscreen 7.2.4 Configuration.html,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testFakeTouchFeatures()],,Configuration.touchscreen,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java,,
,7.2.6.1,C-2-1,,android.transition.cts.SlideBadEdgeTest,,,"/*  *.  */ package android.transition.cts;  import static org.junit.Assert.fail;  import android.transition.Slide; import android.view.Gravity;  import androidx.test.filters.MediumTest; import androidx.test.filters.SmallTest; import androidx.test.runner.AndroidJUnit4;  import org.junit.Test; import org.junit.runner.RunWith;  @MediumTest @RunWith(AndroidJUnit4.class) public class SlideBadEdgeTest {      private static final Object[][] sBadGravity = {             { Gravity.AXIS_CLIP, ""AXIS_CLIP"" },             { Gravity.AXIS_PULL_AFTER, ""AXIS_PULL_AFTER"" },             { Gravity.AXIS_PULL_BEFORE, ""AXIS_PULL_BEFORE"" },             { Gravity.AXIS_SPECIFIED, ""AXIS_SPECIFIED"" },             { Gravity.AXIS_Y_SHIFT, ""AXIS_Y_SHIFT"" },             { Gravity.AXIS_X_SHIFT, ""AXIS_X_SHIFT"" },             { Gravity.CENTER, ""CENTER"" },             { Gravity.CLIP_VERTICAL, ""CLIP_VERTICAL"" },             { Gravity.CLIP_HORIZONTAL, ""CLIP_HORIZONTAL"" },             { Gravity.CENTER_VERTICAL, ""CENTER_VERTICAL"" },             { Gravity.CENTER_HORIZONTAL, ""CENTER_HORIZONTAL"" },             { Gravity.DISPLAY_CLIP_VERTICAL, ""DISPLAY_CLIP_VERTICAL"" },             { Gravity.DISPLAY_CLIP_HORIZONTAL, ""DISPLAY_CLIP_HORIZONTAL"" },             { Gravity.FILL_VERTICAL, ""FILL_VERTICAL"" },             { Gravity.FILL, ""FILL"" },             { Gravity.FILL_HORIZONTAL, ""FILL_HORIZONTAL"" },             { Gravity.HORIZONTAL_GRAVITY_MASK, ""HORIZONTAL_GRAVITY_MASK"" },             { Gravity.NO_GRAVITY, ""NO_GRAVITY"" },             { Gravity.RELATIVE_LAYOUT_DIRECTION, ""RELATIVE_LAYOUT_DIRECTION"" },             { Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK, ""RELATIVE_HORIZONTAL_GRAVITY_MASK"" },             { Gravity.VERTICAL_GRAVITY_MASK, ""VERTICAL_GRAVITY_MASK"" },     };      @SmallTest     ",7.2.6.1/C-2-1,,07020601.670201,KEYCODE_BUTTON_A KEYCODE_BACK AXIS_HAT_X4 HID KEYCODE_BUTTON_THUMBL AXIS_Y KEYCODE_BUTTON_R1 KEYCODE_BUTTON_Y AXIS_LTRIGGER 7.2.6.1 KEYCODE_HOME C-2-1 AXIS_RTRIGGER android.hardware.gamepad KEYCODE_BUTTON_THUMBR MotionEvent.html AXIS_X KEYCODE_BUTTON_X AXIS_Z KEYCODE_BUTTON_L1 KEYCODE_BUTTON_B AXIS_HAT_Y4 AXIS_RZ,Test[None]:[android.transition.cts.SlideBadEdgeTest:],,AXIS_X,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/tests/transition/src/android/transition/cts/SlideBadEdgeTest.java,,
,7.3,C-1-6,,android.print.cts.PrintJobTest,advancedOption(),,"     public void advancedOption() throws Exception {         testSuccess[0] = false;          // Create the session of the printers that we will be checking.         PrinterDiscoverySessionCallbacks sessionCallbacks                 = createFirstMockPrinterDiscoverySessionCallbacks();          // Create the service callbacks for the first print service.         PrintServiceCallbacks serviceCallbacks = createFirstMockPrinterServiceCallbacks(                 sessionCallbacks, printJob -> {                     assertTrue(printJob.hasAdvancedOption(VALID_STRING_KEY));                     assertEquals(STRING_VALUE, printJob.getAdvancedStringOption(VALID_STRING_KEY));                      assertFalse(printJob.hasAdvancedOption(INVALID_STRING_KEY));                     assertNull(printJob.getAdvancedStringOption(INVALID_STRING_KEY));                      assertTrue(printJob.hasAdvancedOption(VALID_INT_KEY));                     assertEquals(INT_VALUE, printJob.getAdvancedIntOption(VALID_INT_KEY));                      assertTrue(printJob.hasAdvancedOption(VALID_NULL_KEY));                     assertNull(printJob.getAdvancedStringOption(VALID_NULL_KEY));                      assertFalse(printJob.hasAdvancedOption(INVALID_INT_KEY));                     assertEquals(0, printJob.getAdvancedIntOption(INVALID_INT_KEY));                      assertNull(printJob.getAdvancedStringOption(VALID_INT_KEY));                     assertEquals(0, printJob.getAdvancedIntOption(VALID_STRING_KEY));                 });          final int[] callCount = new int[1];          CustomPrintOptionsActivity.setCallBack(                 (printJob, printer) -> {                     if (callCount[0] == 0) {                         PrintJobInfo.Builder printJobBuilder = new PrintJobInfo.Builder(printJob);                          try {                             printJobBuilder.putAdvancedOption(null, STRING_VALUE);                             throw new RuntimeException(""Should not be able to use a null key"");                         } catch (NullPointerException e) {                             // expected                         }                          // Second put overrides the first                         printJobBuilder.putAdvancedOption(VALID_STRING_KEY, ""something"");                         printJobBuilder.putAdvancedOption(VALID_STRING_KEY, STRING_VALUE);                          printJobBuilder.putAdvancedOption(VALID_INT_KEY, ""something"");                         printJobBuilder.putAdvancedOption(VALID_INT_KEY, INT_VALUE);                          printJobBuilder.putAdvancedOption(VALID_NULL_KEY, null);                          // Rotate the media size to force adapter to write again                         PrintAttributes.Builder attributeBuilder = new PrintAttributes.Builder();                         attributeBuilder.setMediaSize(printJob.getAttributes().getMediaSize()                                 .asLandscape());                         attributeBuilder.setResolution(printJob.getAttributes().getResolution());                         attributeBuilder.setDuplexMode(printJob.getAttributes().getDuplexMode());                         attributeBuilder.setColorMode(printJob.getAttributes().getColorMode());                         attributeBuilder.setMinMargins(printJob.getAttributes().getMinMargins());                          printJobBuilder.setAttributes(attributeBuilder.build());                          return printJobBuilder.build();                     } else {                         // Check that options are readable                         assertTrue(printJob.hasAdvancedOption(VALID_STRING_KEY));                         assertEquals(STRING_VALUE,                                 printJob.getAdvancedStringOption(VALID_STRING_KEY));                          assertFalse(printJob.hasAdvancedOption(INVALID_STRING_KEY));                         assertNull(printJob.getAdvancedStringOption(INVALID_STRING_KEY));                          assertTrue(printJob.hasAdvancedOption(VALID_INT_KEY));                         assertEquals(INT_VALUE, printJob.getAdvancedIntOption(VALID_INT_KEY));                          assertTrue(printJob.hasAdvancedOption(VALID_NULL_KEY));                         assertNull(printJob.getAdvancedStringOption(VALID_NULL_KEY));                          assertFalse(printJob.hasAdvancedOption(INVALID_INT_KEY));                         assertEquals(0, printJob.getAdvancedIntOption(INVALID_INT_KEY));                          assertNull(printJob.getAdvancedStringOption(VALID_INT_KEY));                         assertEquals(0, printJob.getAdvancedIntOption(VALID_STRING_KEY));                          return null;                     }                 });          // Configure the print services.         FirstPrintService.setCallbacks(serviceCallbacks);          // We don't use the second service, but we have to still configure it         SecondPrintService.setCallbacks(createMockPrintServiceCallbacks(null, null, null));          // Create a print adapter that respects the print contract.         PrintDocumentAdapter adapter = createDefaultPrintDocumentAdapter(1);          // Start printing.         print(adapter, ""advancedOption"");          waitForWriteAdapterCallback(1);          openPrintOptions();         openCustomPrintOptions();          waitForWriteAdapterCallback(2);          callCount[0]++;          // The advanced option should not be readable from the activity         getActivity().getSystemService(PrintManager.class).getPrintJobs().stream()                 .filter(printJob -> printJob.getInfo().getLabel().equals(""advancedOption""))                 .forEach(printJob -> {                     assertFalse(printJob.getInfo().hasAdvancedOption(VALID_STRING_KEY));                     assertEquals(null,                             printJob.getInfo().getAdvancedStringOption(VALID_STRING_KEY));                      assertFalse(printJob.getInfo().hasAdvancedOption(INVALID_STRING_KEY));                     assertNull(printJob.getInfo().getAdvancedStringOption(INVALID_STRING_KEY));                      assertFalse(printJob.getInfo().hasAdvancedOption(VALID_INT_KEY));                     assertEquals(0, printJob.getInfo().getAdvancedIntOption(VALID_INT_KEY));                      assertFalse(printJob.getInfo().hasAdvancedOption(VALID_NULL_KEY));                     assertNull(printJob.getInfo().getAdvancedStringOption(VALID_NULL_KEY));                      assertFalse(printJob.getInfo().hasAdvancedOption(INVALID_INT_KEY));                     assertEquals(0, printJob.getInfo().getAdvancedIntOption(INVALID_INT_KEY));                      assertNull(printJob.getInfo().getAdvancedStringOption(VALID_INT_KEY));                     assertEquals(0, printJob.getInfo().getAdvancedIntOption(VALID_STRING_KEY));                 });          openCustomPrintOptions();         mPrintHelper.submitPrintJob();          // Wait for print job to be queued         waitForServiceOnPrintJobQueuedCallbackCalled(1);          // Wait for discovery session to be destroyed to isolate tests from each other         waitForPrinterDiscoverySessionDestroyCallbackCalled(1);          if (!testSuccess[0]) {             throw new Exception(""Did not succeed"");         }     }      ",7.3/C-1-6,,07030000.670106,SystemClock.elapsedRealtimeNano 7.3 C-1-6 elapsedRealtimeNano() Sensor.getResolution SensorEvent.html getResolution(),Test[None]:[android.print.cts.PrintJobTest:advancedOption()],,getResolution(),/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/tests/print/src/android/print/cts/PrintJobTest.java,,
,7.3,C-1-7,,android.database.cts.CursorWindowTest,testAccessDataValues(),,"     public void testAccessDataValues() {         final long NUMBER_LONG_INTEGER = (long) 0xaabbccddffL;         final long NUMBER_INTEGER = (int) NUMBER_LONG_INTEGER;         final long NUMBER_SHORT = (short) NUMBER_INTEGER;         final float NUMBER_FLOAT_SCIENCE = 7.332952E11f;         final double NUMBER_DOUBLE_SCIENCE = 7.33295205887E11;         final String NUMBER_FLOAT_SCIENCE_STRING = ""7.332952E11"";         final String NUMBER_DOUBLE_SCIENCE_STRING = ""7.33295205887E11"";         final String NUMBER_FLOAT_SCIENCE_STRING2 = ""7.33295e+11"";          byte[] originalBlob = new byte[Byte.MAX_VALUE];         for (int i = 0; i < Byte.MAX_VALUE; i++) {             originalBlob[i] = (byte) i;         }          CursorWindow cursorWindow = new CursorWindow(true);         cursorWindow.setNumColumns(5);         cursorWindow.allocRow();          // Test putString, getString, getLong, getInt, isBlob         assertTrue(cursorWindow.putString(Long.toString(NUMBER_LONG_INTEGER), 0, 0));         assertEquals(Long.toString(NUMBER_LONG_INTEGER), cursorWindow.getString(0, 0));         assertEquals(NUMBER_LONG_INTEGER, cursorWindow.getLong(0, 0));         assertEquals(NUMBER_INTEGER, cursorWindow.getInt(0, 0));         assertEquals(NUMBER_SHORT, cursorWindow.getShort(0, 0));         // Converting of Float, there would be some little precision differences. So just compare         // first 6 digits.         assertEquals(NUMBER_FLOAT_SCIENCE_STRING.substring(0, 6), Float.toString(                 cursorWindow.getFloat(0, 0)).substring(0, 6));         assertEquals(NUMBER_DOUBLE_SCIENCE_STRING, Double.toString(cursorWindow.getDouble(0, 0)));         assertFalse(cursorWindow.isNull(0, 0));         assertFalse(cursorWindow.isBlob(0, 0));          // Test null String         assertTrue(cursorWindow.putString("""", 0, 0));         assertEquals("""", cursorWindow.getString(0, 0));         assertEquals(0, cursorWindow.getLong(0, 0));         assertEquals(0, cursorWindow.getInt(0, 0));         assertEquals(0, cursorWindow.getShort(0, 0));         assertEquals(0.0, cursorWindow.getDouble(0, 0), 0.0);         assertEquals(0.0f, cursorWindow.getFloat(0, 0), 0.0);         assertFalse(cursorWindow.isNull(0, 0));         assertFalse(cursorWindow.isBlob(0, 0));          // Test putNull, getString, getLong, getDouble, getBlob, getInd, getShort, getFloat,         // isBlob.         assertTrue(cursorWindow.putNull(0, 1));         assertNull(cursorWindow.getString(0, 1));         assertEquals(0, cursorWindow.getLong(0, 1));         assertEquals(0, cursorWindow.getInt(0, 1));         assertEquals(0, cursorWindow.getShort(0, 1));         assertEquals(0.0, cursorWindow.getDouble(0, 1), 0.0);         assertEquals(0.0f, cursorWindow.getFloat(0, 1), 0.0);         assertNull(cursorWindow.getBlob(0, 1));         assertTrue(cursorWindow.isNull(0, 1));         // If the field is null, isBlob will return true.         assertTrue(cursorWindow.isBlob(0, 1));          // Test putLong, getLong, getInt, getString , getShort, getFloat, getDouble, isBlob.         assertTrue(cursorWindow.putLong(NUMBER_LONG_INTEGER, 0, 2));         assertEquals(NUMBER_LONG_INTEGER, cursorWindow.getLong(0, 2));         assertEquals(NUMBER_INTEGER, cursorWindow.getInt(0, 2));         assertEquals(Long.toString(NUMBER_LONG_INTEGER), cursorWindow.getString(0, 2));         assertEquals(NUMBER_SHORT, cursorWindow.getShort(0, 2));         assertEquals(NUMBER_FLOAT_SCIENCE, cursorWindow.getFloat(0, 2), 0.0);         assertEquals(NUMBER_DOUBLE_SCIENCE, cursorWindow.getDouble(0, 2), 0.0);         try {             cursorWindow.getBlob(0, 2);             fail(""Can't get Blob from a Integer value."");         } catch (SQLiteException e) {             // expected         }         assertFalse(cursorWindow.isNull(0, 2));         assertFalse(cursorWindow.isBlob(0, 2));          // Test putDouble         assertTrue(cursorWindow.putDouble(NUMBER_DOUBLE_SCIENCE, 0, 3));         assertEquals(NUMBER_LONG_INTEGER, cursorWindow.getLong(0, 3));         assertEquals(NUMBER_INTEGER, cursorWindow.getInt(0, 3));         // Converting from Double to String, there would be some little precision differences. So         // Just compare first 6 digits.         assertEquals(NUMBER_FLOAT_SCIENCE_STRING2.substring(0, 6), cursorWindow.getString(0, 3)                 .substring(0, 6));         assertEquals(NUMBER_SHORT, cursorWindow.getShort(0, 3));         assertEquals(NUMBER_FLOAT_SCIENCE, cursorWindow.getFloat(0, 3), 0.0);         assertEquals(NUMBER_DOUBLE_SCIENCE, cursorWindow.getDouble(0, 3), 0.0);         try {             cursorWindow.getBlob(0, 3);             fail(""Can't get Blob from a Double value."");         } catch (SQLiteException e) {             // expected         }         assertFalse(cursorWindow.isNull(0, 3));         assertFalse(cursorWindow.isBlob(0, 3));          // Test putBlob         assertTrue(cursorWindow.putBlob(originalBlob, 0, 4));         byte[] targetBlob = cursorWindow.getBlob(0, 4);         assertTrue(Arrays.equals(originalBlob, targetBlob));         assertFalse(cursorWindow.isNull(0, 4));         // Test isBlob         assertTrue(cursorWindow.isBlob(0, 4));     }      ",7.3/C-1-7,,07030000.670107,7.3 C-1-7,Test[None]:[android.database.cts.CursorWindowTest:testAccessDataValues()],,7.3,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/tests/database/src/android/database/cts/CursorWindowTest.java,,
,7.3.6,C-2-1,,android.appwidget.cts.RequestPinAppWidgetTest,testPinWidget_launcher2(),,"     public void testPinWidget_launcher2() throws Exception {         runPinWidgetTest(""android.appwidget.cts.packages.launcher2"");     }      @CddTest(requirement=""3.8.2/C-2-1"")     public void verifyIsRequestPinAppWidgetSupported(String launcherPkg, boolean expectedSupport)         throws Exception {         setLauncher(launcherPkg + ""/"" + LAUNCHER_CLASS);          Context context = getInstrumentation().getContext();         assertEquals(expectedSupport,                 AppWidgetManager.getInstance(context).isRequestPinAppWidgetSupported());     }      ",7.3.6/C-2-1,,07030600.670201,SENSOR_TYPE_AMBIENT_TEMPERATURE C-2-1 7.3.6 TYPE_AMBIENT_TEMPERATURE,Test[None]:[android.appwidget.cts.RequestPinAppWidgetTest:testPinWidget_launcher2()],,C-2-1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/tests/appwidget/src/android/appwidget/cts/RequestPinAppWidgetTest.java,,
,7.3.10,C-6-2,,android.security.identity.cts.IdentityApiTest,,,"/*  *.  */  package android.security.identity.cts;  import android.content.Context; import android.hardware.biometrics.BiometricPrompt.CryptoObject; import android.security.identity.AccessControlProfileId; import android.security.identity.AlreadyPersonalizedException; import android.security.identity.CipherSuiteNotSupportedException; import android.security.identity.DocTypeNotSupportedException; import android.security.identity.EphemeralPublicKeyNotFoundException; import android.security.identity.IdentityCredential; import android.security.identity.IdentityCredentialException; import android.security.identity.IdentityCredentialStore; import android.security.identity.InvalidReaderSignatureException; import android.security.identity.InvalidRequestMessageException; import android.security.identity.MessageDecryptionException; import android.security.identity.NoAuthenticationKeyAvailableException; import android.security.identity.SessionTranscriptMismatchException; import android.security.identity.UnknownAuthenticationKeyException;  import androidx.test.InstrumentationRegistry;  import org.junit.Test; import static org.junit.Assert.assertEquals;  public class IdentityApiTest {     private static final String TAG = ""IdentityApiTest"";      ",7.3.10/C-6-2,,07031000.670602,BiometricManager.Authenticators 7.3.10 BiometricPrompt.CryptoObject C-6-2 BIOMETRIC_STRONG,Test[None]:[android.security.identity.cts.IdentityApiTest:],,BiometricPrompt.CryptoObject,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/tests/identity/src/android/security/identity/cts/IdentityApiTest.java,,
,7.3.10,C-3-4,,android.server.wm.lifecycle.ActivityLifecycleTopResumedStateTests,testTopPositionNotSwitchedToPip(),,"     public void testTopPositionNotSwitchedToPip() throws Exception {         assumeTrue(supportsPip());          // Launch first activity         final Activity activity = launchActivityAndWait(CallbackTrackingActivity.class);          // Clear the log before launching to Pip         getLifecycleLog().clear();          // Launch Pip-capable activity and enter Pip immediately         final Activity pipActivity = new Launcher(PipActivity.class)                 .setExtraFlags(EXTRA_ENTER_PIP)                 .setExpectedState(ON_PAUSE)                 .launch();          // The PipMenuActivity could start anytime after moving pipActivity to pinned stack,         // however, we cannot control when would it start or finish, so this test could fail when         // PipMenuActivity just start and pipActivity call finish almost at the same time.         // So the strategy here is to wait the PipMenuActivity start and finish after pipActivity         // moved to pinned stack and paused, because pipActivity is not focusable but the         // PipMenuActivity is focusable, when the pinned stack gain top focus means the         // PipMenuActivity is launched and resumed, then when pinned stack lost top focus means the         // PipMenuActivity is finished.         mWmState.waitWindowingModeTopFocus(WINDOWING_MODE_PINNED, true /* topFocus */                 , ""wait PipMenuActivity get top focus"");         mWmState.waitWindowingModeTopFocus(WINDOWING_MODE_PINNED, false /* topFocus */                 , ""wait PipMenuActivity lost top focus"");         waitAndAssertActivityStates(state(activity, ON_TOP_POSITION_GAINED));          LifecycleVerifier.assertOrder(getLifecycleLog(), Arrays.asList(                 transition(CallbackTrackingActivity.class, ON_TOP_POSITION_LOST),                 transition(CallbackTrackingActivity.class, ON_PAUSE),                 transition(CallbackTrackingActivity.class, ON_RESUME),                 transition(CallbackTrackingActivity.class, ON_TOP_POSITION_GAINED)), ""startPIP"");          // Exit PiP         getLifecycleLog().clear();         pipActivity.finish();          waitAndAssertActivityStates(state(pipActivity, ON_DESTROY));         LifecycleVerifier.assertSequence(PipActivity.class, getLifecycleLog(),                 Arrays.asList(                         ON_STOP, ON_DESTROY), ""finishPip"");         LifecycleVerifier.assertEmptySequence(CallbackTrackingActivity.class, getLifecycleLog(),                 ""finishPip"");     }      ",7.3.10/C-3-4,,07031000.670304,7.3.10 PIN C-3-4,Test[None]:[android.server.wm.lifecycle.ActivityLifecycleTopResumedStateTests:testTopPositionNotSwitchedToPip()],,PIN,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleTopResumedStateTests.java,,
,7.3.13,C-1-1,,android.app.cts.SystemFeaturesTest,testTouchScreenFeatures(),CtsAppTestCases,"     public void testTouchScreenFeatures() {         // If device implementations include a touchscreen (single-touch or better), they:         // [C-1-1] MUST report TOUCHSCREEN_FINGER for the Configuration.touchscreen API field.         // [C-1-2] MUST report the android.hardware.touchscreen and         // android.hardware.faketouch feature flags         ConfigurationInfo configInfo = mActivityManager.getDeviceConfigurationInfo();         if (configInfo.reqTouchScreen == Configuration.TOUCHSCREEN_NOTOUCH) {             // Device does not include a touchscreen             assertNotAvailable(PackageManager.FEATURE_TOUCHSCREEN);         } else {             // Device has a touchscreen             assertAvailable(PackageManager.FEATURE_TOUCHSCREEN);             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",7.3.13/C-1-1,,07031300.670101,STRING_TYPE_HINGE_ANGLE 7.3.13 C-1-1 TYPE_HINGLE_ANGLE,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testTouchScreenFeatures()],,C-1-1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java,,
,7.3.13,C-1-2,,android.app.cts.SystemFeaturesTest,testTouchScreenFeatures(),CtsAppTestCases,"     public void testTouchScreenFeatures() {         // If device implementations include a touchscreen (single-touch or better), they:         // [C-1-1] MUST report TOUCHSCREEN_FINGER for the Configuration.touchscreen API field.         // [C-1-2] MUST report the android.hardware.touchscreen and         // android.hardware.faketouch feature flags         ConfigurationInfo configInfo = mActivityManager.getDeviceConfigurationInfo();         if (configInfo.reqTouchScreen == Configuration.TOUCHSCREEN_NOTOUCH) {             // Device does not include a touchscreen             assertNotAvailable(PackageManager.FEATURE_TOUCHSCREEN);         } else {             // Device has a touchscreen             assertAvailable(PackageManager.FEATURE_TOUCHSCREEN);             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",7.3.13/C-1-2,,07031300.670102,C-1-2 7.3.13,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testTouchScreenFeatures()],,C-1-2,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java,,
,7.4.5.3,C-1-1,,android.app.cts.SystemFeaturesTest,testTouchScreenFeatures(),CtsAppTestCases,"     public void testTouchScreenFeatures() {         // If device implementations include a touchscreen (single-touch or better), they:         // [C-1-1] MUST report TOUCHSCREEN_FINGER for the Configuration.touchscreen API field.         // [C-1-2] MUST report the android.hardware.touchscreen and         // android.hardware.faketouch feature flags         ConfigurationInfo configInfo = mActivityManager.getDeviceConfigurationInfo();         if (configInfo.reqTouchScreen == Configuration.TOUCHSCREEN_NOTOUCH) {             // Device does not include a touchscreen             assertNotAvailable(PackageManager.FEATURE_TOUCHSCREEN);         } else {             // Device has a touchscreen             assertAvailable(PackageManager.FEATURE_TOUCHSCREEN);             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",7.4.5.3/C-1-1,,07040503.670101,7.4.5.3 ACTION_CAPTIVE_PORTAL_SIGN_IN C-1-1,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testTouchScreenFeatures()],,C-1-1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java,,
,7.4.5.3,C-1-2,,android.app.cts.SystemFeaturesTest,testTouchScreenFeatures(),CtsAppTestCases,"     public void testTouchScreenFeatures() {         // If device implementations include a touchscreen (single-touch or better), they:         // [C-1-1] MUST report TOUCHSCREEN_FINGER for the Configuration.touchscreen API field.         // [C-1-2] MUST report the android.hardware.touchscreen and         // android.hardware.faketouch feature flags         ConfigurationInfo configInfo = mActivityManager.getDeviceConfigurationInfo();         if (configInfo.reqTouchScreen == Configuration.TOUCHSCREEN_NOTOUCH) {             // Device does not include a touchscreen             assertNotAvailable(PackageManager.FEATURE_TOUCHSCREEN);         } else {             // Device has a touchscreen             assertAvailable(PackageManager.FEATURE_TOUCHSCREEN);             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",7.4.5.3/C-1-2,,07040503.670102,7.4.5.3 C-1-2,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testTouchScreenFeatures()],,C-1-2,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java,,
,7.4.5.3,C-1-3,,android.net.cts.ConnectivityDiagnosticsManagerTest,testOnDataStallSuspected_DnsEvents(),,"     public void testOnDataStallSuspected_DnsEvents() throws Exception {         final PersistableBundle extras = new PersistableBundle();         extras.putInt(KEY_DNS_CONSECUTIVE_TIMEOUTS, DNS_CONSECUTIVE_TIMEOUTS);          verifyOnDataStallSuspected(DETECTION_METHOD_DNS_EVENTS, TIMESTAMP, extras);     }      ",7.4.5.3/C-1-3,,07040503.670103,DNS 7.4.5.3 C-1-3,Test[None]:[android.net.cts.ConnectivityDiagnosticsManagerTest:testOnDataStallSuspected_DnsEvents()],,DNS,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/ConnectivityDiagnosticsManagerTest.java,,
,7.4.5.3,C-1-4,,android.net.cts.ConnectivityDiagnosticsManagerTest,testOnDataStallSuspected_DnsEvents(),,"     public void testOnDataStallSuspected_DnsEvents() throws Exception {         final PersistableBundle extras = new PersistableBundle();         extras.putInt(KEY_DNS_CONSECUTIVE_TIMEOUTS, DNS_CONSECUTIVE_TIMEOUTS);          verifyOnDataStallSuspected(DETECTION_METHOD_DNS_EVENTS, TIMESTAMP, extras);     }      ",7.4.5.3/C-1-4,,07040503.670104,android.net.LinkProperties.isPrivateDnsActive LinkProperties.html C-1-4 android.net.LinkProperties.getPrivateDnsServerName 7.4.5.3 DNS,Test[None]:[android.net.cts.ConnectivityDiagnosticsManagerTest:testOnDataStallSuspected_DnsEvents()],,DNS,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/tests/net/src/android/net/cts/ConnectivityDiagnosticsManagerTest.java,,
,7.4.5.3,C-1-5,,android.car.cts.CarTest,testConnection(),,"     public void testConnection() throws Exception {         mServiceConnectionListener = new DefaultServiceConnectionListener();         mCar = Car.createCar(mContext, mServiceConnectionListener);         assertThat(mCar.isConnected()).isFalse();         assertThat(mCar.isConnecting()).isFalse();         mCar.connect();         mServiceConnectionListener.waitForConnection(DEFAULT_WAIT_TIMEOUT_MS);         assertThat(mServiceConnectionListener.isConnected()).isTrue();         assertThat(mCar.getCarConnectionType()).isEqualTo(Car.CONNECTION_TYPE_EMBEDDED);         mCar.disconnect();         assertThat(mCar.isConnected()).isFalse();         assertThat(mCar.isConnecting()).isFalse();     }      ",7.4.5.3/C-1-5,,07040503.670105,android.net.ConnectivityManager.NetworkCallback ConnectivityManager.registerDefaultNetworkCallback 7.4.5.3 ConnectivityManager.getActiveNetwork C-1-5 connect() java.net.Socket,Test[None]:[android.car.cts.CarTest:testConnection()],,connect(),/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/tests/car/src/android/car/cts/CarTest.java,,
,7.4.8,C-1-2,,android.omapi.accesscontrol3.cts.AccessControlTest,Object(),,"/*  *.  */  /* Contributed by Orange */  package android.omapi.accesscontrol3.cts;  import static org.hamcrest.CoreMatchers.is; import static org.junit.Assert.*; import static org.junit.Assume.assumeTrue;  import android.content.pm.PackageManager; import android.os.Build; import android.se.omapi.Channel; import android.se.omapi.Reader; import android.se.omapi.SEService; import android.se.omapi.SEService.OnConnectedListener; import android.se.omapi.Session;  import androidx.test.InstrumentationRegistry;  import com.android.compatibility.common.util.PropertyUtil;  import org.junit.After; import org.junit.Before; import org.junit.Test;  import java.util.Timer; import java.util.TimerTask; import java.util.concurrent.Executor; import java.util.concurrent.TimeoutException;  public class AccessControlTest {     private final static String UICC_READER_PREFIX = ""SIM"";     private final static String ESE_READER_PREFIX = ""eSE"";     private final static String SD_READER_PREFIX = ""SD"";      private final static byte[] AID_40 = new byte[] { (byte) 0xA0, 0x00, 0x00,         0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,         0x53, 0x40 };     private final static byte[] AID_41 = new byte[] { (byte) 0xA0, 0x00, 0x00,         0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,         0x53, 0x41 };     private final static byte[] AID_42 = new byte[] { (byte) 0xA0, 0x00, 0x00,         0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,         0x53, 0x42 };     private final static byte[] AID_43 = new byte[] { (byte) 0xA0, 0x00, 0x00,         0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,         0x53, 0x43 };     private final static byte[] AID_44 = new byte[] { (byte) 0xA0, 0x00, 0x00,         0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,         0x53, 0x44 };     private final static byte[] AID_45 = new byte[] { (byte) 0xA0, 0x00, 0x00,         0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,         0x53, 0x45 };     private final static byte[] AID_46 = new byte[] { (byte) 0xA0, 0x00, 0x00,         0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,         0x53, 0x46 };     private final static byte[] AID_47 = new byte[] { (byte) 0xA0, 0x00, 0x00,         0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,         0x53, 0x47 };     private final static byte[] AID_48 = new byte[] { (byte) 0xA0, 0x00, 0x00,         0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,         0x53, 0x48 };     private final static byte[] AID_49 = new byte[] { (byte) 0xA0, 0x00, 0x00,         0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,         0x53, 0x49 };     private final static byte[] AID_4A = new byte[] { (byte) 0xA0, 0x00, 0x00,         0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,         0x53, (byte) 0x4A };     private final static byte[] AID_4B = new byte[] { (byte) 0xA0, 0x00, 0x00,         0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,         0x53, (byte) 0x4B };     private final static byte[] AID_4C = new byte[] { (byte) 0xA0, 0x00, 0x00,         0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,         0x53, (byte) 0x4C };     private final static byte[] AID_4D = new byte[] { (byte) 0xA0, 0x00, 0x00,         0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,         0x53, (byte) 0x4D };     private final static byte[] AID_4E = new byte[] { (byte) 0xA0, 0x00, 0x00,         0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,         0x53, (byte) 0x4E };     private final static byte[] AID_4F = new byte[] { (byte) 0xA0, 0x00, 0x00,         0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,         0x53, (byte) 0x4F };      private final static byte[][] AUTHORIZED_AID = new byte[][] { AID_40,         AID_41, AID_45, AID_46 };     private final static byte[][] UNAUTHORIZED_AID = new byte[][] { AID_42,         AID_43, AID_44, AID_47, AID_48, AID_49, AID_4A, AID_4B, AID_4C, AID_4D, AID_4E,         AID_4F };      /* Authorized APDU for AID_40 */     private final static byte[][] AUTHORIZED_APDU_AID_40 = new byte[][] {         { 0x00, 0x06, 0x00, 0x00 }, { (byte) 0x80, 0x06, 0x00, 0x00 },         { (byte) 0xA0, 0x06, 0x00, 0x00 },         { (byte) 0x94, 0x06, 0x00, 0x00 },         { 0x00, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },         { (byte) 0x80, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },         { (byte) 0xA0, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },         { (byte) 0x94, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },         { 0x00, 0x08, 0x00, 0x00, 0x00 },         { (byte) 0x80, 0x08, 0x00, 0x00, 0x00 },         { (byte) 0xA0, 0x08, 0x00, 0x00, 0x00 },         { (byte) 0x94, 0x08, 0x00, 0x00, 0x00 },         { 0x00, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },         { (byte) 0x80, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },         { (byte) 0xA0, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },         { (byte) 0x94, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 }};      /* Authorized APDU for AID_41 */     private final static byte[][] AUTHORIZED_APDU_AID_41 = new byte[][] {         { (byte) 0x94, 0x06, 0x00, 0x00 },         { (byte) 0x94, 0x08, 0x00, 0x00, 0x00 },         { (byte) 0x94, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },         { (byte) 0x94, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA } };     /* Unauthorized APDU for AID_41 */     private final static byte[][] UNAUTHORIZED_APDU_AID_41 = new byte[][] {         { 0x00, 0x06, 0x00, 0x00 }, { (byte) 0x80, 0x06, 0x00, 0x00 },         { (byte) 0xA0, 0x06, 0x00, 0x00 },         { 0x00, 0x08, 0x00, 0x00, 0x00 },         { (byte) 0x00, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },         { (byte) 0x80, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },         { (byte) 0xA0, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },         { (byte) 0x80, 0x08, 0x00, 0x00, 0x00 },         { (byte) 0xA0, 0x08, 0x00, 0x00, 0x00 },         { 0x00, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },         { (byte) 0x80, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },         { (byte) 0xA0, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },     };      private final long SERVICE_CONNECTION_TIME_OUT = 3000;     private SEService seService;     private Object serviceMutex = new Object();     private Timer connectionTimer;     private ServiceConnectionTimerTask mTimerTask = new ServiceConnectionTimerTask();     private boolean connected = false;      private final OnConnectedListener mListener = new OnConnectedListener() {         @Override         public void onConnected() {             synchronized (serviceMutex) {                 connected = true;                 serviceMutex.notify();             }         }     };      class SynchronousExecutor implements Executor {         public void execute(Runnable r) {             r.run();         }     }      private boolean supportsHardware() {         final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();         boolean lowRamDevice = PropertyUtil.propertyEquals(""ro.config.low_ram"", ""true"");         return !lowRamDevice || pm.hasSystemFeature(""android.hardware.type.watch"")                 || hasSecureElementPackage(pm);     }      private boolean hasSecureElementPackage(PackageManager pm) {         try {             pm.getPackageInfo(""com.android.se"", 0 /* flags*/);             return true;         } catch (PackageManager.NameNotFoundException e) {             return false;         }     }      private boolean supportOMAPIReaders() {         final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();         return (pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_UICC)             || pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_ESE)             || pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_SD));     }      @Before     public void setUp() throws Exception {         assumeTrue(PropertyUtil.getFirstApiLevel() > Build.VERSION_CODES.O_MR1);         assumeTrue(supportsHardware());         assumeTrue(supportOMAPIReaders());         seService = new SEService(InstrumentationRegistry.getContext(), new SynchronousExecutor(), mListener);         connectionTimer = new Timer();         connectionTimer.schedule(mTimerTask, SERVICE_CONNECTION_TIME_OUT);     }      @After     public void tearDown() throws Exception {         if (seService != null && seService.isConnected()) {             seService.shutdown();             connected = false;         }     }      private void waitForConnection() throws TimeoutException {         synchronized (serviceMutex) {             if (!connected) {                 try {                     serviceMutex.wait();                  } catch (InterruptedException e) {                     e.printStackTrace();                  }             }             if (!connected) {                 throw new TimeoutException(                     ""Service could not be connected after ""                     + SERVICE_CONNECTION_TIME_OUT + "" ms"");             }             if (connectionTimer != null) {                 connectionTimer.cancel();             }         }     }      ",7.4.8/C-1-2,,07040800.670102,7.4.8 UICC FEATURE_SE_OMAPI_ESE C-1-2 FEATURE_SE_OMAPI_UICC android.hardware.se.omapi.sd FEATURE_SE_OMAPI_SD android.hardware.se.omapi.ese android.hardware.se.omapi.uicc,Test[None]:[android.omapi.accesscontrol3.cts.AccessControlTest:Object()],,FEATURE_SE_OMAPI_SD,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/tests/secure_element/access_control/AccessControlApp3/src/android/omapi/accesscontrol3/cts/AccessControlTest.java,,
,7.5.4,C-0-12,,android.hardware.camera2.cts.SurfaceViewPreviewTest,setUp(),CtsCameraTestCases,"/*  *.  */  package android.hardware.camera2.cts;  import static android.hardware.camera2.cts.CameraTestUtils.*;  import android.graphics.ImageFormat; import android.view.Surface;  import com.android.ex.camera2.blocking.BlockingSessionCallback;  import android.graphics.SurfaceTexture; import android.hardware.camera2.CameraCaptureSession; import android.hardware.camera2.CameraCaptureSession.CaptureCallback; import android.hardware.camera2.CameraDevice; import android.hardware.camera2.CaptureFailure; import android.hardware.camera2.CaptureRequest; import android.hardware.camera2.CaptureResult; import android.hardware.camera2.TotalCaptureResult; import android.util.Size; import android.hardware.camera2.cts.CameraTestUtils.SimpleCaptureCallback; import android.hardware.camera2.cts.helpers.StaticMetadata; import android.hardware.camera2.cts.testcases.Camera2SurfaceViewTestCase; import android.hardware.camera2.params.OutputConfiguration; import android.hardware.camera2.params.SessionConfiguration; import android.util.Log; import android.util.Pair; import android.util.Range; import android.view.SurfaceView; import android.view.SurfaceHolder;  import org.mockito.ArgumentCaptor; import org.mockito.ArgumentMatcher;  import static org.mockito.Mockito.*;  import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.HashMap;  import org.junit.runners.Parameterized; import org.junit.runner.RunWith; import org.junit.Test;  /**  * CameraDevice preview test by using SurfaceView.  */  @RunWith(Parameterized.class) public class SurfaceViewPreviewTest extends Camera2SurfaceViewTestCase {     private static final String TAG = ""SurfaceViewPreviewTest"";     private static final boolean VERBOSE = Log.isLoggable(TAG, Log.VERBOSE);     private static final int FRAME_TIMEOUT_MS = 1000;     private static final int NUM_FRAMES_VERIFIED = 30;     private static final int NUM_TEST_PATTERN_FRAMES_VERIFIED = 60;     private static final float FRAME_DURATION_ERROR_MARGIN = 0.01f; // 1 percent error margin.     private static final int PREPARE_TIMEOUT_MS = 10000; // 10 s      @Override     public void setUp() throws Exception {         super.setUp();     }      @Override     public void tearDown() throws Exception {         super.tearDown();     }      /**      * Test all supported preview sizes for each camera device.      * <p>      * For the first  {@link #NUM_FRAMES_VERIFIED}  of capture results,      * the {@link CaptureCallback} callback availability and the capture timestamp      * (monotonically increasing) ordering are verified.      * </p>      */     ",7.5.4/C-0-12,,07050400.670012,7.5.4 android.hardware.camera android.hardware.Camera C-0-12,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.SurfaceViewPreviewTest:setUp()],,android.hardware.camera,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/SurfaceViewPreviewTest.java,,
,9.1,C-2-1,,android.appwidget.cts.RequestPinAppWidgetTest,testPinWidget_launcher2(),,"     public void testPinWidget_launcher2() throws Exception {         runPinWidgetTest(""android.appwidget.cts.packages.launcher2"");     }      @CddTest(requirement=""3.8.2/C-2-1"")     public void verifyIsRequestPinAppWidgetSupported(String launcherPkg, boolean expectedSupport)         throws Exception {         setLauncher(launcherPkg + ""/"" + LAUNCHER_CLASS);          Context context = getInstrumentation().getContext();         assertEquals(expectedSupport,                 AppWidgetManager.getInstance(context).isRequestPinAppWidgetSupported());     }      ",9.1/C-2-1,,09010000.670201,Settings.html ACTION_MANAGE_OVERLAY_PERMISSION C-2-1 9.1,Test[None]:[android.appwidget.cts.RequestPinAppWidgetTest:testPinWidget_launcher2()],,C-2-1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/tests/appwidget/src/android/appwidget/cts/RequestPinAppWidgetTest.java,,
,9.5,C-1-2,,android.uirendering.cts.testclasses.ExactCanvasTests,testUnclippedSaveLayerRounding(),,"     public void testUnclippedSaveLayerRounding() {         createTest()                 .addCanvasClient((canvas, width, height) -> {                     canvas.saveLayerAlpha(10.5f, 10.5f, 79.5f, 79.5f, 255);                     canvas.drawRect(20, 20, 70, 70, new Paint());                     canvas.restore();                 })                 .runWithVerifier(new RectVerifier(Color.WHITE, Color.BLACK,                         new Rect(20, 20, 70, 70)));     }      ",9.5/C-1-2,,09050000.670102,permissions.html C-1-2 9.5,Test[None]:[android.uirendering.cts.testclasses.ExactCanvasTests:testUnclippedSaveLayerRounding()],,9.5,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/tests/uirendering/src/android/uirendering/cts/testclasses/ExactCanvasTests.java,,
,9.8.9,C-0-1,,android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest,testMonochromeCharacteristics(),CtsCameraTestCases,"     public void testMonochromeCharacteristics() {         for (int i = 0; i < mAllCameraIds.length; i++) {             Log.i(TAG, ""testMonochromeCharacteristics: Testing camera ID "" + mAllCameraIds[i]);              CameraCharacteristics c = mCharacteristics.get(i);             int[] capabilities = c.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);             assertNotNull(""android.request.availableCapabilities must never be null"",                     capabilities);             boolean supportMonochrome = arrayContains(capabilities, MONOCHROME);              if (!supportMonochrome) {                 continue;             }              List<Key<?>> allKeys = c.getKeys();             List<CaptureRequest.Key<?>> requestKeys = c.getAvailableCaptureRequestKeys();             List<CaptureResult.Key<?>> resultKeys = c.getAvailableCaptureResultKeys();              assertTrue(""Monochrome camera must have BACKWARD_COMPATIBLE capability"",                     arrayContains(capabilities, BC));             int colorFilterArrangement = c.get(                     CameraCharacteristics.SENSOR_INFO_COLOR_FILTER_ARRANGEMENT);             assertTrue(""Monochrome camera must have either MONO or NIR color filter pattern"",                     colorFilterArrangement ==                             CameraCharacteristics.SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_MONO                     || colorFilterArrangement ==                             CameraCharacteristics.SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_NIR);              assertFalse(""Monochrome camera must not contain SENSOR_CALIBRATION_TRANSFORM1 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_CALIBRATION_TRANSFORM1));             assertFalse(""Monochrome camera must not contain SENSOR_COLOR_TRANSFORM1 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_COLOR_TRANSFORM1));             assertFalse(""Monochrome camera must not contain SENSOR_FORWARD_MATRIX1 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_FORWARD_MATRIX1));             assertFalse(""Monochrome camera must not contain SENSOR_REFERENCE_ILLUMINANT1 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_REFERENCE_ILLUMINANT1));             assertFalse(""Monochrome camera must not contain SENSOR_CALIBRATION_TRANSFORM2 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_CALIBRATION_TRANSFORM2));             assertFalse(""Monochrome camera must not contain SENSOR_COLOR_TRANSFORM2 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_COLOR_TRANSFORM2));             assertFalse(""Monochrome camera must not contain SENSOR_FORWARD_MATRIX2 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_FORWARD_MATRIX2));             assertFalse(""Monochrome camera must not contain SENSOR_REFERENCE_ILLUMINANT2 key"",                     allKeys.contains(CameraCharacteristics.SENSOR_REFERENCE_ILLUMINANT2));              assertFalse(                     ""Monochrome capture result must not contain SENSOR_NEUTRAL_COLOR_POINT key"",                     resultKeys.contains(CaptureResult.SENSOR_NEUTRAL_COLOR_POINT));             assertFalse(""Monochrome capture result must not contain SENSOR_GREEN_SPLIT key"",                     resultKeys.contains(CaptureResult.SENSOR_GREEN_SPLIT));              // Check that color correction tags are not available for monochrome cameras             assertTrue(""Monochrome camera must not have MANUAL_POST_PROCESSING capability"",                     !arrayContains(capabilities, MANUAL_POSTPROC));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_MODE in request keys"",                     !requestKeys.contains(CaptureRequest.COLOR_CORRECTION_MODE));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_MODE in result keys"",                     !resultKeys.contains(CaptureResult.COLOR_CORRECTION_MODE));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_TRANSFORM in request keys"",                     !requestKeys.contains(CaptureRequest.COLOR_CORRECTION_TRANSFORM));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_TRANSFORM in result keys"",                     !resultKeys.contains(CaptureResult.COLOR_CORRECTION_TRANSFORM));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_GAINS in request keys"",                     !requestKeys.contains(CaptureRequest.COLOR_CORRECTION_GAINS));             assertTrue(""Monochrome camera must not have COLOR_CORRECTION_GAINS in result keys"",                     !resultKeys.contains(CaptureResult.COLOR_CORRECTION_GAINS));              // Check that awbSupportedModes only contains AUTO             int[] awbAvailableModes = c.get(CameraCharacteristics.CONTROL_AWB_AVAILABLE_MODES);             assertTrue(""availableAwbModes must not be null"", awbAvailableModes != null);             assertTrue(""availableAwbModes must contain only AUTO"", awbAvailableModes.length == 1 &&                     awbAvailableModes[0] == CaptureRequest.CONTROL_AWB_MODE_AUTO);         }     }      /**      * Check that all devices available through the legacy API are also      * accessible via Camera2.      */     @CddTest(requirement=""7.5.4/C-0-11"")     ",9.8.9/C-0-1,,09080900.670001,C-0-1 9.8.9,Test[CtsCameraTestCases]:[android.hardware.camera2.cts.ExtendedCameraCharacteristicsTest:testMonochromeCharacteristics()],,C-0-1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/camera/src/android/hardware/camera2/cts/ExtendedCameraCharacteristicsTest.java,,
,9.8.10,C-1-1,,android.app.cts.SystemFeaturesTest,testTouchScreenFeatures(),CtsAppTestCases,"     public void testTouchScreenFeatures() {         // If device implementations include a touchscreen (single-touch or better), they:         // [C-1-1] MUST report TOUCHSCREEN_FINGER for the Configuration.touchscreen API field.         // [C-1-2] MUST report the android.hardware.touchscreen and         // android.hardware.faketouch feature flags         ConfigurationInfo configInfo = mActivityManager.getDeviceConfigurationInfo();         if (configInfo.reqTouchScreen == Configuration.TOUCHSCREEN_NOTOUCH) {             // Device does not include a touchscreen             assertNotAvailable(PackageManager.FEATURE_TOUCHSCREEN);         } else {             // Device has a touchscreen             assertAvailable(PackageManager.FEATURE_TOUCHSCREEN);             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",9.8.10/C-1-1,,09081000.670101,BUGREPORT_MODE_TELEPHONY C-1-1 9.8.10,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testTouchScreenFeatures()],,C-1-1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java,,
,9.8.10,C-1-2,,android.app.cts.SystemFeaturesTest,testTouchScreenFeatures(),CtsAppTestCases,"     public void testTouchScreenFeatures() {         // If device implementations include a touchscreen (single-touch or better), they:         // [C-1-1] MUST report TOUCHSCREEN_FINGER for the Configuration.touchscreen API field.         // [C-1-2] MUST report the android.hardware.touchscreen and         // android.hardware.faketouch feature flags         ConfigurationInfo configInfo = mActivityManager.getDeviceConfigurationInfo();         if (configInfo.reqTouchScreen == Configuration.TOUCHSCREEN_NOTOUCH) {             // Device does not include a touchscreen             assertNotAvailable(PackageManager.FEATURE_TOUCHSCREEN);         } else {             // Device has a touchscreen             assertAvailable(PackageManager.FEATURE_TOUCHSCREEN);             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",9.8.10/C-1-2,,09081000.670102,C-1-2 9.8.10,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testTouchScreenFeatures()],,C-1-2,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java,,
,9.8.10,C-1-4,,android.carrierapi.cts.NetworkScanApiTest,testNetworkScanPermission(),,"     public void testNetworkScanPermission() {         PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();          List<Integer> specialUids = Arrays.asList(Process.SYSTEM_UID,                 Process.PHONE_UID, Process.SHELL_UID);          List<PackageInfo> holding = pm.getPackagesHoldingPermissions(                 new String[] { NETWORK_SCAN_PERMISSION },                 PackageManager.MATCH_DISABLED_COMPONENTS);          List<Integer> nonSpecialPackages = holding.stream()                 .map(pi -> {                     try {                         return pm.getPackageUid(pi.packageName, 0);                     } catch (PackageManager.NameNotFoundException e) {                         return Process.INVALID_UID;                     }                 })                 .filter(uid -> !specialUids.contains(UserHandle.getAppId(uid)))                 .collect(Collectors.toList());          if (nonSpecialPackages.size() > 1) {             fail(""Only one app on the device is allowed to hold the NETWORK_SCAN permission."");         }     }      private boolean getAndSetLocationSwitch(boolean enabled) {         CountDownLatch locationChangeLatch = new CountDownLatch(1);         ContentObserver settingsObserver = new ContentObserver(mHandler) {             @Override             public void onChange(boolean selfChange) {                 locationChangeLatch.countDown();                 super.onChange(selfChange);             }         };          InstrumentationRegistry.getInstrumentation().getUiAutomation()                 .adoptShellPermissionIdentity();         try {             int oldLocationMode = Settings.Secure.getInt(                     InstrumentationRegistry.getContext().getContentResolver(),                     Settings.Secure.LOCATION_MODE, Settings.Secure.LOCATION_MODE_OFF);              int locationMode = enabled ? Settings.Secure.LOCATION_MODE_HIGH_ACCURACY                     : Settings.Secure.LOCATION_MODE_OFF;             if (locationMode != oldLocationMode) {                 InstrumentationRegistry.getContext().getContentResolver().registerContentObserver(                         Settings.Secure.getUriFor(Settings.Secure.LOCATION_MODE),                         false, settingsObserver);                 Settings.Secure.putInt(InstrumentationRegistry.getContext().getContentResolver(),                         Settings.Secure.LOCATION_MODE, locationMode);                 try {                     assertTrue(locationChangeLatch.await(LOCATION_SETTING_CHANGE_WAIT_MS,                             TimeUnit.MILLISECONDS));                 } catch (InterruptedException e) {                     Log.w(NetworkScanApiTest.class.getSimpleName(),                             ""Interrupted while waiting for location settings change. Test results""                             + "" may not be accurate."");                 } finally {                     InstrumentationRegistry.getContext().getContentResolver()                             .unregisterContentObserver(settingsObserver);                 }             }             return oldLocationMode == Settings.Secure.LOCATION_MODE_HIGH_ACCURACY;         } finally {             InstrumentationRegistry.getInstrumentation().getUiAutomation()                     .dropShellPermissionIdentity();         }     }      private boolean isScanStatusValid() {         // TODO(b/72162885): test the size of ScanResults is not zero after the blocking bug fixed.         if ((mNetworkScanStatus == EVENT_NETWORK_SCAN_COMPLETED) && (mScanResults != null)) {             // Scan complete.             return true;         }         if ((mNetworkScanStatus == EVENT_NETWORK_SCAN_ERROR)                 && ((mErrorCode == NetworkScan.ERROR_MODEM_UNAVAILABLE)                 || (mErrorCode == NetworkScan.ERROR_UNSUPPORTED))) {             // Scan error but the error type is allowed.             return true;         }         return false;     }      private ArrayList<String> getPlmns() {         ArrayList<String> mccMncs = new ArrayList<>();         mccMncs.add(""310260"");         mccMncs.add(""310120"");         return mccMncs;     }      /**      * To test its constructor and getters.      */     ",9.8.10/C-1-4,,09081000.670104,C-1-4 UID 9.8.10,Test[None]:[android.carrierapi.cts.NetworkScanApiTest:testNetworkScanPermission()],,UID,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/tests/carrierapi/src/android/carrierapi/cts/NetworkScanApiTest.java,,
,9.8.11,C-1-1,,com.android.cts.blob.BlobStoreManagerTest,testMixedAccessType_fromMultiplePackages(),CtsBlobStoreTestCases,"     public void testMixedAccessType_fromMultiplePackages() throws Exception {         final DummyBlobData blobData = new DummyBlobData.Builder(mContext).build();         blobData.prepare();         final TestServiceConnection connection1 = bindToHelperService(HELPER_PKG);         final TestServiceConnection connection2 = bindToHelperService(HELPER_PKG2);         final TestServiceConnection connection3 = bindToHelperService(HELPER_PKG3);         try {             final long sessionId = mBlobStoreManager.createSession(blobData.getBlobHandle());             assertThat(sessionId).isGreaterThan(0L);              commitBlob(blobData, session -> {                 session.allowSameSignatureAccess();                 session.allowPackageAccess(HELPER_PKG2, HELPER_PKG2_CERT_SHA256);                 assertThat(session.isSameSignatureAccessAllowed()).isTrue();                 assertThat(session.isPackageAccessAllowed(HELPER_PKG2, HELPER_PKG2_CERT_SHA256))                         .isTrue();                 assertThat(session.isPublicAccessAllowed()).isFalse();             });              assertPkgCanAccess(blobData, connection1);             assertPkgCanAccess(blobData, connection2);             assertPkgCannotAccess(blobData, connection3);              commitBlobFromPkg(blobData, ICommandReceiver.FLAG_ACCESS_TYPE_PUBLIC, connection2);              assertPkgCanAccess(blobData, connection1);             assertPkgCanAccess(blobData, connection2);             assertPkgCanAccess(blobData, connection3);         } finally {             blobData.delete();             connection1.unbind();             connection2.unbind();             connection3.unbind();         }     }      ",9.8.11/C-1-1,,09081100.670101,allowPackageAccess() BlobStoreManager.session allowPublicAccess() allowSameSignatureAccess() 9.8.11 C-1-1,Test[CtsBlobStoreTestCases]:[com.android.cts.blob.BlobStoreManagerTest:testMixedAccessType_fromMultiplePackages()],,allowSameSignatureAccess(),/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/BlobStore/src/com/android/cts/blob/BlobStoreManagerTest.java,,
,9.8.11,C-1-2,,android.app.cts.SystemFeaturesTest,testTouchScreenFeatures(),CtsAppTestCases,"     public void testTouchScreenFeatures() {         // If device implementations include a touchscreen (single-touch or better), they:         // [C-1-1] MUST report TOUCHSCREEN_FINGER for the Configuration.touchscreen API field.         // [C-1-2] MUST report the android.hardware.touchscreen and         // android.hardware.faketouch feature flags         ConfigurationInfo configInfo = mActivityManager.getDeviceConfigurationInfo();         if (configInfo.reqTouchScreen == Configuration.TOUCHSCREEN_NOTOUCH) {             // Device does not include a touchscreen             assertNotAvailable(PackageManager.FEATURE_TOUCHSCREEN);         } else {             // Device has a touchscreen             assertAvailable(PackageManager.FEATURE_TOUCHSCREEN);             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",9.8.11/C-1-2,,09081100.670102,9.8.11 C-1-2,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testTouchScreenFeatures()],,C-1-2,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java,,
,9.9.4,C-0-1,,android.server.wm.DreamManagerServiceTests,testDreamNotFinishAfterRotation(),,"     public void testDreamNotFinishAfterRotation() {         assumeTrue(""Skipping test: no rotation support"", supportsRotation());          final RotationSession rotationSession = createManagedRotationSession();         rotationSession.set(Surface.ROTATION_0);         setActiveDream(TEST_DREAM_SERVICE);         startDream(TEST_DREAM_SERVICE);         rotationSession.set(Surface.ROTATION_90);          waitAndAssertTopResumedActivity(mDreamActivityName, DEFAULT_DISPLAY,                 ""Dream activity should be the top resumed activity"");     } } ",9.9.4/C-0-1,,09090400.670001,OTA 9.9.4 PIN RAM C-0-1,Test[None]:[android.server.wm.DreamManagerServiceTests:testDreamNotFinishAfterRotation()],,OTA,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DreamManagerServiceTests.java,,
,9.11.3,C-0-1,,android.theme.cts.ThemeRebaseTest,TypedValue(),,"/*  *.  */  package android.theme.cts;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotEquals;  import android.content.Context; import android.content.res.Configuration; import android.content.res.Resources; import android.util.DisplayMetrics; import android.util.TypedValue;  import androidx.test.InstrumentationRegistry; import androidx.test.filters.SmallTest; import androidx.test.runner.AndroidJUnit4;  import org.junit.After; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith;  @SmallTest @RunWith(AndroidJUnit4.class) public class ThemeRebaseTest {      private Context mContext;     private Resources.Theme mTheme;     private Configuration mInitialConfig;     private TypedValue mOutValue = new TypedValue();      @Before     public void before() {         Context targetContext = InstrumentationRegistry.getTargetContext();         Configuration config = new Configuration();         config.orientation = Configuration.ORIENTATION_PORTRAIT;         mContext = targetContext.createConfigurationContext(config);         mTheme = mContext.getTheme();         mInitialConfig = new Configuration(mContext.getResources().getConfiguration());     }      /**      * {@link Resources#updateConfiguration(Configuration, DisplayMetrics)} doesn't update the      * {@link android.app.ResourcesManager} cache's {@link android.content.res.ResourcesKey},      * so we need to manually reset the {@link Configuration} so that new calls to      * {@link Context#createConfigurationContext} work as expected.      */     @After     public void after() {         Resources resources = mContext.getResources();         resources.updateConfiguration(mInitialConfig, resources.getDisplayMetrics());     }      ",9.11.3/C-0-1,,09110300.670001,android.content.Context getInstance() 9.11.3 C-0-1,Test[None]:[android.theme.cts.ThemeRebaseTest:TypedValue()],,android.content.Context,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/tests/theme/src/android/theme/cts/ThemeRebaseTest.java,,
,9.11.3,C-0-2,,android.security.identity.cts.CreateItemsRequestTest,,,/*  *.  */  package android.security.identity.cts;  import static org.junit.Assert.assertEquals;  import org.junit.Test;  import java.util.Arrays; import java.util.Collection; import java.util.LinkedHashMap; import java.util.Map;  import co.nstant.in.cbor.CborException;  public class CreateItemsRequestTest {     ,9.11.3/C-0-2,,09110300.670002,android.security.identity C-0-2 9.11.3 DMA,Test[None]:[android.security.identity.cts.CreateItemsRequestTest:],,android.security.identity,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/tests/identity/src/android/security/identity/cts/CreateItemsRequestTest.java,,
,9.11.3,C-0-3,,android.security.identity.cts.CreateItemsRequestTest,,,/*  *.  */  package android.security.identity.cts;  import static org.junit.Assert.assertEquals;  import org.junit.Test;  import java.util.Arrays; import java.util.Collection; import java.util.LinkedHashMap; import java.util.Map;  import co.nstant.in.cbor.CborException;  public class CreateItemsRequestTest {     ,9.11.3/C-0-3,,09110300.670003,createEphemeralKeyPair() android.security.identity C-0-3 9.11.3,Test[None]:[android.security.identity.cts.CreateItemsRequestTest:],,android.security.identity,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/tests/identity/src/android/security/identity/cts/CreateItemsRequestTest.java,,
,9.11.3,C-0-4,,android.provider.cts.settings.Settings_SecureTest,testBluetoothAddressNotAvailable(),,"     public void testBluetoothAddressNotAvailable() {         assertNull(Settings.Secure.getString(cr, BLUETOOTH_MAC_ADDRESS_SETTING_NAME));          // Assert this setting is not accessible when listing all settings         try (Cursor c = cr.query(Settings.Secure.CONTENT_URI, null, null, null, null)) {             while ((c != null) && (c.moveToNext())) {                 String name = c.getString(1);                 if (BLUETOOTH_MAC_ADDRESS_SETTING_NAME.equals(name)) {                     fail(""Settings.Secure contains "" + name + "": "" + c.getString(2));                 }             }         }          // Assert this setting is not accessible when listing this specific setting         Uri settingUri =                 Settings.Secure.CONTENT_URI.buildUpon().appendPath(""bluetooth_address"").build();         try (Cursor c = cr.query(settingUri, null, null, null, null)) {             while ((c != null) && (c.moveToNext())) {                 String name = c.getString(1);                 fail(""Settings.Secure contains "" + name + "": "" + c.getString(2));             }         }     } } ",9.11.3/C-0-4,,09110300.670004,C-0-4 9.11.3 MAC,Test[None]:[android.provider.cts.settings.Settings_SecureTest:testBluetoothAddressNotAvailable()],,MAC,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/tests/provider/src/android/provider/cts/settings/Settings_SecureTest.java,,
,9.16,C-1-1,,android.app.cts.SystemFeaturesTest,testTouchScreenFeatures(),CtsAppTestCases,"     public void testTouchScreenFeatures() {         // If device implementations include a touchscreen (single-touch or better), they:         // [C-1-1] MUST report TOUCHSCREEN_FINGER for the Configuration.touchscreen API field.         // [C-1-2] MUST report the android.hardware.touchscreen and         // android.hardware.faketouch feature flags         ConfigurationInfo configInfo = mActivityManager.getDeviceConfigurationInfo();         if (configInfo.reqTouchScreen == Configuration.TOUCHSCREEN_NOTOUCH) {             // Device does not include a touchscreen             assertNotAvailable(PackageManager.FEATURE_TOUCHSCREEN);         } else {             // Device has a touchscreen             assertAvailable(PackageManager.FEATURE_TOUCHSCREEN);             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",9.16/C-1-1,,09160000.670101,9.16 C-1-1,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testTouchScreenFeatures()],,C-1-1,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java,,
,9.16,C-1-2,,android.app.cts.SystemFeaturesTest,testTouchScreenFeatures(),CtsAppTestCases,"     public void testTouchScreenFeatures() {         // If device implementations include a touchscreen (single-touch or better), they:         // [C-1-1] MUST report TOUCHSCREEN_FINGER for the Configuration.touchscreen API field.         // [C-1-2] MUST report the android.hardware.touchscreen and         // android.hardware.faketouch feature flags         ConfigurationInfo configInfo = mActivityManager.getDeviceConfigurationInfo();         if (configInfo.reqTouchScreen == Configuration.TOUCHSCREEN_NOTOUCH) {             // Device does not include a touchscreen             assertNotAvailable(PackageManager.FEATURE_TOUCHSCREEN);         } else {             // Device has a touchscreen             assertAvailable(PackageManager.FEATURE_TOUCHSCREEN);             assertAvailable(PackageManager.FEATURE_FAKETOUCH);         }     }      ",9.16/C-1-2,,09160000.670102,9.16 C-1-2,Test[CtsAppTestCases]:[android.app.cts.SystemFeaturesTest:testTouchScreenFeatures()],,C-1-2,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/app/src/android/app/cts/SystemFeaturesTest.java,,
,9.16,C-1-4,,android.theme.cts.ThemeRebaseTest,testConfigChangeAndRebase(),,"     public void testConfigChangeAndRebase() {         mTheme.applyStyle(R.style.RebaseTestThemeBase, false);          assertConfigText(""base"");          mTheme.applyStyle(R.style.RebaseTestThemeOverlay, true);          assertConfigText(""rebase_portrait"");          Configuration newConfig = new Configuration(mInitialConfig);         newConfig.orientation = Configuration.ORIENTATION_LANDSCAPE;         mContext.getResources().updateConfiguration(newConfig, null);          assertNotEquals(mTheme.getChangingConfigurations(), 0);          // Assert value hasn't changed before rebase         assertConfigText(""rebase_portrait"");          mTheme.rebase();          assertConfigText(""rebase_landscape"");     }      ",9.16/C-1-4,,09160000.670104,9.16 C-1-4 AND,Test[None]:[android.theme.cts.ThemeRebaseTest:testConfigChangeAndRebase()],,AND,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/tests/theme/src/android/theme/cts/ThemeRebaseTest.java,,
,9.16,C-1-5,,android.graphics.cts.VulkanFeaturesTest,testVulkan1_1Requirements(),,"     public void testVulkan1_1Requirements() throws JSONException {         if (mVulkanHardwareVersion == null || mVulkanHardwareVersion.version < VULKAN_1_1                 || !PropertyUtil.isVendorApiLevelNewerThan(                         API_LEVEL_BEFORE_ANDROID_HARDWARE_BUFFER_REQ)) {             return;         }         assertTrue(""Devices with Vulkan 1.1 must support sampler YCbCr conversion"",                 mBestDevice.getJSONObject(""samplerYcbcrConversionFeatures"")                            .getInt(""samplerYcbcrConversion"") != 0);          if (hasOnlyCpuDevice()) {             return;         }         assertTrue(""Devices with Vulkan 1.1 must support "" +                 VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME +                 "" (version >= "" + VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION +                 "")"",                 hasExtension(mBestDevice,                     VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME,                     VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION));         assertTrue(""Devices with Vulkan 1.1 must support SYNC_FD external semaphores"",                 hasHandleType(mBestDevice.getJSONArray(""externalSemaphoreProperties""),                     VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT,                     ""externalSemaphoreFeatures"", 0x3 /* importable + exportable */));         assertTrue(""Devices with Vulkan 1.1 must support SYNC_FD external fences"",                 hasHandleType(mBestDevice.getJSONArray(""externalFenceProperties""),                     VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT,                     ""externalFenceFeatures"", 0x3 /* importable + exportable */));     }      @CddTest(requirement = ""7.9.2/C-1-5"")     ",9.16/C-1-5,,09160000.670105,9.16 C-1-5,Test[None]:[android.graphics.cts.VulkanFeaturesTest:testVulkan1_1Requirements()],,C-1-5,/home/gpoor/cts-source/cts/tests/framework/base/windowmanager/src/android/server/wm/lifecycle/ActivityLifecycleKeyguardTests.java,/home/gpoor/cts-source/cts/tests/tests/graphics/src/android/graphics/cts/VulkanFeaturesTest.java,,
