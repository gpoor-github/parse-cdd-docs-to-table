"Section"	"section_id"	"req_id"	"full_key"	"manual_search_terms"	"requirement"	"Test Availability"	"class_def"	"method"	"module"	"matched_terms"	"methods_string"	"search_terms"	"file_name"	"Comment(internal) e.g. why a test is not possible"	"CTS Bug Id"	"Test Level"
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.compatibility.common.generator.ManifestGeneratorTest"	"testManifest"	""	"1: permission"	"([12:/com/android/compatibility/common/generator/ManifestGeneratorTest.java]:[permission]:[12]:method_text:[, activityXml);        assertEquals(""Wrong manifest output"", expected, output.toString());    }}]) :|: public void testManifest() throws Exception {
        List<String> permissions = new ArrayList<>();
        permissions.add(PERMISSION_A);
        permissions.add(PERMISSION_B);
        List<String> activities = new ArrayList<>();
        activities.add(ACTIVITY_A);
        activities.add(ACTIVITY_B);
        List<String> libraries = new ArrayList<>();
        libraries.add(LIBRARY);
        List<String> optionalLibs = new ArrayList<>();
        optionalLibs.add(OPTIONAL_LIBRARY);
        OutputStream output = new OutputStream() {
            private StringBuilder string = new StringBuilder();
            @Override
            public void write(int b) throws IOException {
                this.string.append((char) b);
            }

            @Override
            public String toString(){
                return this.string.toString();
            }
        };
        ManifestGenerator.generate(
                output,
                PACKAGE,
                INSTRUMENT,
                MIN_SDK,
                TARGET_SDK,
                permissions,
                activities,
                libraries,
                optionalLibs);
        String permissionXml = String.format(PERMISSION, PERMISSION_A)
                + String.format(PERMISSION, PERMISSION_B);
        String activityXml = String.format(ACTIVITY, ACTIVITY_A)
                + String.format(ACTIVITY, ACTIVITY_B);
        String libraryXml = String.format(USES_LIBRARY, LIBRARY);
        String optionalLibraryXml = String.format(USES_OPTIONAL_LIBRARY, OPTIONAL_LIBRARY);
        String expected =
                String.format(MANIFEST, permissionXml, libraryXml, optionalLibraryXml, activityXml);
        assertEquals(""Wrong manifest output"", expected, output.toString());
    }

}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tools/manifest-generator/tests/src/com/android/compatibility/common/generator/ManifestGeneratorTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.google.android.cts.settings.PrivacyDeviceOwnerTest"	"isHeadlessSystemUserMode"	"CtsSettingsHostTestCases"	"1: permission"	"([1:/com/google/android/cts/settings/PrivacyDeviceOwnerTest.java]:[permission]:[1]:method_text:[    super.tearDown();    }    /** The case: app is the device owner, has work policy info. */   ]) :|: public void test/*
 *.
 */
package com.google.android.cts.settings;

import com.android.compatibility.common.tradefed.build.CompatibilityBuildHelper;
import com.android.ddmlib.Log.LogLevel;
import com.android.ddmlib.testrunner.RemoteAndroidTestRunner;
import com.android.ddmlib.testrunner.TestResult.TestStatus;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.log.LogUtil.CLog;
import com.android.tradefed.result.CollectingTestListener;
import com.android.tradefed.result.TestDescription;
import com.android.tradefed.result.TestResult;
import com.android.tradefed.result.TestRunResult;
import com.android.tradefed.testtype.DeviceTestCase;
import com.android.tradefed.testtype.IBuildReceiver;
import java.io.FileNotFoundException;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import javax.annotation.Nullable;

/** Set of tests for Device Owner use cases. */
public class PrivacyDeviceOwnerTest extends DeviceTestCase implements IBuildReceiver {
    private static final String RUNNER = ""androidx.test.runner.AndroidJUnitRunner"";

    private static final String DEVICE_OWNER_APK = ""CtsSettingsDeviceOwnerApp.apk"";
    private static final String DEVICE_OWNER_PKG = ""com.google.android.cts.deviceowner"";

    private static final String ADMIN_RECEIVER_TEST_CLASS = "".DeviceOwnerTest$BasicAdminReceiver"";
    private static final String CLEAR_DEVICE_OWNER_TEST_CLASS = "".ClearDeviceOwnerTest"";

    // TODO (b/174775905) move to ITestDevice.
    private static final int USER_SYSTEM = 0;

    /**
     * The defined timeout (in milliseconds) is used as a maximum waiting time when expecting the
     * command output from the device. At any time, if the shell command does not output anything
     * for a period longer than defined timeout the Trad"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/settings/src/com/google/android/cts/settings/PrivacyDeviceOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.google.android.cts.settings.PrivacyDeviceOwnerTest"	"testNonDeviceOwnerWithoutInfo"	"CtsSettingsHostTestCases"	"1: permission"	"([4:/com/google/android/cts/settings/PrivacyDeviceOwnerTest.java]:[permission]:[4]:method_text:[prop ro.fw.mu.headless_system_user"").trim();        return ""true"".equalsIgnoreCase(result);    }}]) :|: public void testNonDeviceOwnerWithoutInfo() throws Exception {
        if (!mHasFeature) {
            return;
        }
        executeDeviceOwnerTest(""testNonDeviceOwnerWithoutInfo"");
    }

    private void executeDeviceOwnerTest(String testMethodName) throws Exception {
        String testClass = DEVICE_OWNER_PKG + "".DeviceOwnerTest"";
        assertTrue(
                testClass + "" failed."",
                runDeviceTests(DEVICE_OWNER_PKG, testClass, testMethodName));
    }

    protected void installPackage(int userId, String appFileName)
            throws FileNotFoundException, DeviceNotAvailableException {
        CLog.d(""Installing app %s on user %d"", appFileName, userId);
        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);
        List<String> extraArgs = new LinkedList<>();
        extraArgs.add(""-t"");
        String result =
                getDevice()
                        .installPackageForUser(
                                buildHelper.getTestFile(appFileName),
                                true,
                                true,
                                userId,
                                extraArgs.toArray(new String[extraArgs.size()]));
        assertNull(""Failed to install "" + appFileName + "" on user "" + userId + "": "" + result,
                result);
    }

    protected boolean runDeviceTests(
            String pkgName, @Nullable String testClassName, @Nullable String testMethodName)
            throws DeviceNotAvailableException {
        if (testClassName != null && testClassName.startsWith(""."")) {
            testClassName = pkgName + testClassName;
        }
        RemoteAndroidTestRunner testRunner =
                new RemoteAndroidTestRunner(pkgName, RUNNER, getDevice().getIDevice());
        testRunner.setMaxTimeToOutputResponse(DEFAULT_SHELL_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
        testRunner.addInstrumentationArg(
                TEST_TIMEOUT_INST_ARGS_KEY, Long.toStri"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/settings/src/com/google/android/cts/settings/PrivacyDeviceOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.google.android.cts.deviceowner.DeviceOwnerTest"	"isTrue"	""	"1: permission"	"([1:/com/google/android/cts/deviceowner/DeviceOwnerTest.java]:[permission]:[1]:method_text:[evice owner and has work policy info, then we should have a Privacy     * entry for it.     */   ]) :|: public void test/*
 *.
 */
package com.google.android.cts.deviceowner;

import static android.server.wm.WindowManagerState.STATE_RESUMED;

import static com.google.common.truth.Truth.assertWithMessage;

import android.app.admin.DeviceAdminReceiver;
import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.RemoteException;
import android.provider.Settings;
import android.server.wm.WindowManagerStateHelper;
import android.support.test.uiautomator.By;
import android.support.test.uiautomator.UiDevice;
import android.support.test.uiautomator.Until;
import android.test.InstrumentationTestCase;
import android.util.Log;

import androidx.test.InstrumentationRegistry;

import com.android.bedstead.dpmwrapper.DeviceOwnerHelper;
import com.android.bedstead.dpmwrapper.TestAppSystemServiceFactory;
import com.android.compatibility.common.util.enterprise.DeviceAdminReceiverUtils;

/**
 * Class for device-owner based tests.
 *
 * <p>This class handles making sure that the test is the device owner and that it has an active
 * admin registered if necessary. The admin component can be accessed through {@link #getWho()}.
 */
public final class DeviceOwnerTest extends InstrumentationTestCase {

    private static final String TAG = DeviceOwnerTest.class.getSimpleName();

    private static final String WORK_POLICY_INFO_TEXT = ""Your work policy info"";

    public static final int TIMEOUT_MS = 2_000;

    protected Context mContext;
    protected UiDevice mDevice;

    /** Device Admin receiver for DO. */
    public static final class BasicAdminReceiver extends DeviceAdminReceiver {

        @Override
        public void onReceive(Context context, Intent intent) {
            // Ignore intents used by DpmWrapper IPC between current and system users
            if (DeviceOwnerHelper.runManagerMethod(this, context, intent)) return;

            /"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/settings/app/DeviceOwnerApp/src/com/google/android/cts/deviceowner/DeviceOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.ManagedProfileProvisioningSingleAdminTest"	"removeTestUsers"	"CtsDevicePolicyManagerTestCases"	"2: managed_users permission"	"([1:/com/android/cts/devicepolicy/ManagedProfileProvisioningSingleAdminTest.java]:[permission]:[1]:method_text:[getDevice().uninstallPackage(SINGLE_ADMIN_PKG);        super.tearDown();    }    @FlakyTest   ]) :|: /*
 *
 */
package com.android.cts.devicepolicy;

import static com.android.cts.devicepolicy.DeviceAdminFeaturesCheckerRule.FEATURE_MANAGED_USERS;

import android.platform.test.annotations.FlakyTest;

import com.android.cts.devicepolicy.DeviceAdminFeaturesCheckerRule.RequiresAdditionalFeatures;

import org.junit.Ignore;
import org.junit.Test;

/**
 * This class tests the provisioning flow with an APK that declares a single receiver with
 * BIND_DEVICE_ADMIN permissions, which was a requirement for the app sending the
 * ACTION_PROVISION_MANAGED_PROFILE intent before Android M.
 */
// We need multi user to be supported in order to create a profile of the user owner.
@RequiresAdditionalFeatures({FEATURE_MANAGED_USERS})
public class ManagedProfileProvisioningSingleAdminTest extends BaseDevicePolicyTest {

    private static final String SINGLE_ADMIN_PKG = ""com.android.cts.devicepolicy.singleadmin"";
    private static final String SINGLE_ADMIN_APP_APK = ""CtsDevicePolicySingleAdminTestApp.apk"";

    private int mProfileUserId;

    @Override
    public void setUp() throws Exception {
        super.setUp();


        removeTestUsers();
        installAppAsUser(SINGLE_ADMIN_APP_APK, mPrimaryUserId);
        mProfileUserId = 0;
    }

    @Override
    public void tearDown() throws Exception {
        if (mProfileUserId != 0) {
            removeUser(mProfileUserId);
        }
        getDevice().uninstallPackage(SINGLE_ADMIN_PKG);

        super.tearDown();
    }

    @FlakyTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/ManagedProfileProvisioningSingleAdminTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.DeviceOwnerTest"	"testIsManagedProfileProvisioningAllowed_deviceOwnerIsSet"	"CtsDevicePolicyManagerTestCases"	"1: managed_users"	"([1:/com/android/cts/devicepolicy/DeviceOwnerTest.java]:[managed_users]:[1]:method_text:[""testIsProvisioningNotAllowedForManagedProfileAction"");    }    @FlakyTest(bugId = 137096267)   ]) :|: 
    @RequiresAdditionalFeatures({FEATURE_MANAGED_USERS})
    public void testIsManagedProfileProvisioningAllowed_deviceOwnerIsSet() throws Exception {
        executeDeviceTestMethod("".PreDeviceOwnerTest"",
                ""testIsProvisioningNotAllowedForManagedProfileAction"");
    }

    @FlakyTest(bugId = 137096267)"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.DeviceOwnerTest"	"testDeviceOwnerCanGetDeviceIdentifiers"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([1:/com/android/cts/devicepolicy/DeviceOwnerTest.java]:[permission]:[1]:method_text:[dentifiersTest"",                ""testDeviceOwnerCanGetDeviceIdentifiersWithPermission"");    }   ]) :|: 
    @AsbSecurityTest(cveBugId = 173421434)
    public void testDeviceOwnerCanGetDeviceIdentifiers() throws Exception {
        // The Device Owner should have access to all device identifiers.

        executeDeviceOwnerTestMethod("".DeviceIdentifiersTest"",
                ""testDeviceOwnerCanGetDeviceIdentifiersWithPermission"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.DeviceOwnerTest"	"testListForegroundAffiliatedUsers_onlyForegroundUserCalledByDeviceOwner"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([5:/com/android/cts/devicepolicy/DeviceOwnerTest.java]:[permission]:[5]:method_text:[RACT_ACROSS_USERS, mDeviceOwnerUserId,                    /* reason= */ null);        }    }   ]) :|: 
    public void testListForegroundAffiliatedUsers_onlyForegroundUserCalledByDeviceOwner()
            throws Exception {
        assumeHeadlessSystemUserMode(""redundant, same as ""
                + ""testListForegroundAffiliatedUsers_onlyForegroundUser"");

        // Must temporarily revoke permission to make sure internal checks are allowing it to be
        // called by profile owner
        revokePermission(DEVICE_OWNER_PKG, PERMISSION_INTERACT_ACROSS_USERS, mDeviceOwnerUserId);

        try {
            executeDeviceOwnerTestMethod("".ListForegroundAffiliatedUsersTest"",
                    ""testListForegroundAffiliatedUsers_onlyForegroundUser"");
        } finally {
            grantPermission(DEVICE_OWNER_PKG, PERMISSION_INTERACT_ACROSS_USERS, mDeviceOwnerUserId,
                    /* reason= */ null);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.DeviceOwnerTest"	"testWifiNetworkConfigurationWithoutFineLocationPermission"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([5:/com/android/cts/devicepolicy/DeviceOwnerTest.java]:[permission]:[5]:method_text:[int newUserId = newUsers.get(0);        assertFalse(getDevice().isUserRunning(newUserId));    }}]) :|: 
    public void testWifiNetworkConfigurationWithoutFineLocationPermission() throws Exception {
        executeShellCommand(""pm revoke --user %d %s android.permission.ACCESS_FINE_LOCATION"",
                mPrimaryUserId, DEVICE_OWNER_PKG);

        executeDeviceOwnerTest(""WifiNetworkConfigurationWithoutFineLocationPermissionTest"");
    }

    private int createAffiliatedSecondaryUser() throws Exception {
        final int userId = createUser();
        installAppAsUser(INTENT_RECEIVER_APK, userId);
        // For headless system user mode, after DO is setup, PO is already
        // set on the secondary user. Meanwhile, it requires additional permission while
        // using DevicePolicyManagerWrapper while using DPM APIs from secondary user.
        if (!isHeadlessSystemUserMode()) {
            installAppAsUser(DEVICE_OWNER_APK, userId);
            setProfileOwnerOrFail(DEVICE_OWNER_COMPONENT, userId);
        } else {
            grantDpmWrapperPermissions(DEVICE_OWNER_PKG, userId);
        }
        wakeupAndDismissKeyguard();

        // Setting the same affiliation ids on both users
        CLog.d(""createAffiliatedSecondaryUser(): deviceOwnerId="" + mDeviceOwnerUserId
                + "", primaryUserId="" + mPrimaryUserId + "", newUserId="" + userId);
        affiliateUsers(DEVICE_OWNER_PKG, mDeviceOwnerUserId, userId);

        return userId;
    }

    private void executeDeviceTestMethod(String className, String testName,
            Map<String, String> params) throws Exception {
        runDeviceTestsAsUser(DEVICE_OWNER_PKG, className, testName,
                /* deviceOwnerUserId */ mPrimaryUserId, params);
    }

    private void executeCreateAndManageUserTest(String testMethod) throws Exception {
        // These test must be run on device owner user, as it's the only user that's guaranteed  to
        // be always running (otherwise, the test case would crash on headless system user mode if
        // the current user is switched out)
        executeDe"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTestApi25"	"testPermissionGrantPreMApp"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([3:/com/android/cts/devicepolicy/DeviceAndProfileOwnerTestApi25.java]:[permission]:[3]:method_text:[DeviceTestMethod("".PermissionsTest"", ""testPermissionGrantState_preMApp_preQDeviceAdmin"");    }   ]) :|: 
    public void testPermissionGrantPreMApp() throws Exception {
        installAppAsUser(SIMPLE_PRE_M_APP_APK, mUserId);
        executeDeviceTestMethod("".PermissionsTest"", ""testPermissionGrantState_preMApp_preQDeviceAdmin"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTestApi25.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.LauncherAppsProfileTest"	"removeTestUsers"	"CtsDevicePolicyManagerTestCases"	"1: managed_users"	"([2:/com/android/cts/devicepolicy/LauncherAppsProfileTest.java]:[managed_users]:[2]:method_text:[().uninstallPackage(LAUNCHER_TESTS_HAS_LAUNCHER_ACTIVITY_APK);        super.tearDown();    }   ]) :|: /*
 *.
 */

package com.android.cts.devicepolicy;

import static com.android.cts.devicepolicy.DeviceAdminFeaturesCheckerRule.FEATURE_MANAGED_USERS;

import android.platform.test.annotations.FlakyTest;

import com.android.cts.devicepolicy.DeviceAdminFeaturesCheckerRule.RequiresAdditionalFeatures;
import com.android.tradefed.log.LogUtil.CLog;

import org.junit.Test;

import java.util.Collections;

/**
 * Set of tests for LauncherApps with managed profiles.
 */
@RequiresAdditionalFeatures({FEATURE_MANAGED_USERS})
public class LauncherAppsProfileTest extends BaseLauncherAppsTest {

    private static final String MANAGED_PROFILE_PKG = ""com.android.cts.managedprofile"";
    private static final String MANAGED_PROFILE_APK = ""CtsManagedProfileApp.apk"";
    private static final String ADMIN_RECEIVER_TEST_CLASS =
            MANAGED_PROFILE_PKG + "".BaseManagedProfileTest$BasicAdminReceiver"";
    private static final String LAUNCHER_TESTS_HAS_LAUNCHER_ACTIVITY_APK =
            ""CtsHasLauncherActivityApp.apk"";

    private int mProfileUserId;
    private int mParentUserId;
    private String mProfileSerialNumber;
    private String mMainUserSerialNumber;

    @Override
    public void setUp() throws Exception {
        super.setUp();

        removeTestUsers();
        // Create a managed profile
        mParentUserId = mPrimaryUserId;
        mProfileUserId = createManagedProfile(mParentUserId);
        installAppAsUser(MANAGED_PROFILE_APK, mProfileUserId);
        setProfileOwnerOrFail(MANAGED_PROFILE_PKG + ""/"" + ADMIN_RECEIVER_TEST_CLASS,
                mProfileUserId);
        mProfileSerialNumber = Integer.toString(getUserSerialNumber(mProfileUserId));
        mMainUserSerialNumber = Integer.toString(getUserSerialNumber(mParentUserId));
        startUserAndWait(mProfileUserId);

        // Install test APK on primary user and the managed profile.
        installTestApps(USER_ALL);
    }

    @Override
    public void tearDown() throws Exception {
        removeUser(mProf"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/LauncherAppsProfileTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.LauncherAppsProfileTest"	"testLauncherCallbackPackageChangedProfile"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([1:/com/android/cts/devicepolicy/LauncherAppsProfileTest.java]:[permission]:[1]:method_text:[         mParentUserId, Collections.singletonMap(PARAM_TEST_USER, mProfileSerialNumber));    }   ]) :|: 
    public void testLauncherCallbackPackageChangedProfile() throws Exception {
        installAppAsUser(SIMPLE_APP_APK, mProfileUserId);
        startCallbackService(mPrimaryUserId);
        installAppAsUser(SIMPLE_APP_APK, /* grantPermissions */ true, /* dontKillApp */ true,
                mProfileUserId);
        runDeviceTestsAsUser(LAUNCHER_TESTS_PKG,
                LAUNCHER_TESTS_CLASS,
                ""testPackageChangedCallbackForUser"",
                mParentUserId, Collections.singletonMap(PARAM_TEST_USER, mProfileSerialNumber));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/LauncherAppsProfileTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.DeviceAdminHostSideTestApi24"	"testAdminWithNoProtection"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([1:/com/android/cts/devicepolicy/DeviceAdminHostSideTestApi24.java]:[permission]:[1]:method_text:[(), mUserId,                ""must be protected with android.permission.BIND_DEVICE_ADMIN"");    }}]) :|: 
    public void testAdminWithNoProtection() throws Exception {
        installAppAsUser(getDeviceAdminApkFileName(), mUserId);
        setDeviceAdminExpectingFailure(getUnprotectedAdminReceiverComponent(), mUserId,
                ""must be protected with android.permission.BIND_DEVICE_ADMIN"");
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAdminHostSideTestApi24.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.OrgOwnedProfileOwnerTest"	"removeTestUsers"	"CtsDevicePolicyManagerTestCases"	"1: managed_users"	"([2:/com/android/cts/devicepolicy/OrgOwnedProfileOwnerTest.java]:[managed_users]:[2]:method_text:[                           mUserId, DEVICE_ADMIN_PKG + ""/"" + ADMIN_RECEIVER_TEST_CLASS));    }   ]) :|: /*
 *.
 */

package com.android.cts.devicepolicy;

import static com.android.cts.devicepolicy.DeviceAdminFeaturesCheckerRule.FEATURE_MANAGED_USERS;
import static com.android.cts.devicepolicy.DeviceAndProfileOwnerTest.DEVICE_ADMIN_COMPONENT_FLATTENED;
import static com.android.cts.devicepolicy.metrics.DevicePolicyEventLogVerifier.assertMetricsLogged;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.assertTrue;

import android.platform.test.annotations.FlakyTest;
import android.platform.test.annotations.LargeTest;
import android.stats.devicepolicy.EventId;

import com.android.cts.devicepolicy.DeviceAdminFeaturesCheckerRule.RequiresAdditionalFeatures;
import com.android.cts.devicepolicy.metrics.DevicePolicyEventWrapper;
import com.android.tradefed.device.DeviceNotAvailableException;

import org.junit.Ignore;
import org.junit.Test;

/**
 * Tests for organization-owned Profile Owner.
 */
// We need managed users to be supported in order to create a profile of the user owner.
@RequiresAdditionalFeatures({FEATURE_MANAGED_USERS})
public class OrgOwnedProfileOwnerTest extends BaseDevicePolicyTest {
    private static final String DEVICE_ADMIN_PKG = DeviceAndProfileOwnerTest.DEVICE_ADMIN_PKG;
    private static final String DEVICE_ADMIN_APK = DeviceAndProfileOwnerTest.DEVICE_ADMIN_APK;
    private static final String CERT_INSTALLER_PKG = DeviceAndProfileOwnerTest.CERT_INSTALLER_PKG;
    private static final String CERT_INSTALLER_APK = DeviceAndProfileOwnerTest.CERT_INSTALLER_APK;
    private static final String DELEGATE_APP_PKG = DeviceAndProfileOwnerTest.DELEGATE_APP_PKG;
    private static final String DELEGATE_APP_APK = DeviceAndProfileOwnerTest.DELEGATE_APP_APK;
    private static final String LOG_TAG_PROFILE_OWNER = ""profile-owner"";

    private static final String ADMIN_RECEIVER_TEST_CLASS =
            DeviceAndProfileOwnerTest.ADMIN_RECEIVER_TEST_CLASS;
    private static final String ACTION_WIPE_DATA =
            ""com.android."	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/OrgOwnedProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.OrgOwnedProfileOwnerTest"	"testProfileOwnerCanGetDeviceIdentifiers"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([1:/com/android/cts/devicepolicy/OrgOwnedProfileOwnerTest.java]:[permission]:[1]:method_text:[Test"",                ""testProfileOwnerCanGetDeviceIdentifiersWithPermission"", mUserId);    }   ]) :|: 
    public void testProfileOwnerCanGetDeviceIdentifiers() throws Exception {
        // The Profile Owner should have access to all device identifiers.
        runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".DeviceIdentifiersTest"",
                ""testProfileOwnerCanGetDeviceIdentifiersWithPermission"", mUserId);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/OrgOwnedProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.OrgOwnedProfileOwnerTest"	"testScreenCaptureDisabled"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([1:/com/android/cts/devicepolicy/OrgOwnedProfileOwnerTest.java]:[permission]:[1]:method_text:[+ ADMIN_RECEIVER_TEST_CLASS,                        userId, /* expectFailure */ false));    }   ]) :|: 
    public void testScreenCaptureDisabled() throws Exception {
        installAppAsUser(DEVICE_ADMIN_APK, mPrimaryUserId);
        setPoAsUser(mPrimaryUserId);

        try {
            setScreenCaptureDisabled(true);
        } finally {
            setScreenCaptureDisabled(false);
        }
    }

    private void takeScreenCaptureAsUser(int userId, String testMethodName) throws Exception {
        installAppAsUser(TEST_APP_APK, /* grantPermissions */ true, /* dontKillApp */ true, userId);
        startActivityAsUser(userId, TEST_APP_PKG, TEST_APP_PKG + "".SimpleActivity"");
        runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".ScreenCaptureDisabledTest"",
                testMethodName, userId);
        forceStopPackageForUser(TEST_APP_PKG, userId);
    }

    private void setScreenCaptureDisabled(boolean disabled) throws Exception {
        String testMethodName = disabled
                ? ""testSetScreenCaptureDisabledOnParent_true""
                : ""testSetScreenCaptureDisabledOnParent_false"";
        runDeviceTestsAsUser(DEVICE_ADMIN_PKG, "".ScreenCaptureDisabledTest"",
                testMethodName, mUserId);

        testMethodName = disabled
                ? ""testScreenCaptureImpossible""
                : ""testScreenCapturePossible"";

        // Test personal profile
        takeScreenCaptureAsUser(mPrimaryUserId, testMethodName);

        // Test managed profile. This should not be disabled when screen capture is disabled on
        // the parent by the profile owner of an organization-owned device.
        takeScreenCaptureAsUser(mUserId, ""testScreenCapturePossible"");
    }

    private void assertHasNoUser(int userId) throws DeviceNotAvailableException {
        int numWaits = 0;
        final int MAX_NUM_WAITS = 15;
        while (listUsers().contains(userId) && (numWaits < MAX_NUM_WAITS)) {
            try {
                Thread.sleep(1000);
                numWaits += 1;
            } catch (InterruptedException e) {
                Thread.currentThread("	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/OrgOwnedProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.MixedManagedProfileOwnerTestApi25"	"removeTestUsers"	"CtsDevicePolicyManagerTestCases"	"2: managed_users permission"	"([2:/com/android/cts/devicepolicy/MixedManagedProfileOwnerTestApi25.java]:[permission]:[2]:method_text:[       removeUser(mUserId);        super.tearDown();    }    @Override    @PermissionsTest   ]) :|: /*
 *.
 */

package com.android.cts.devicepolicy;

import static com.android.cts.devicepolicy.DeviceAdminFeaturesCheckerRule.FEATURE_MANAGED_USERS;

import com.android.cts.devicepolicy.DeviceAdminFeaturesCheckerRule.RequiresAdditionalFeatures;
import com.android.cts.devicepolicy.annotations.PermissionsTest;

import org.junit.Test;

/**
 * Set of tests for managed profile owner use cases that also apply to device owners.
 * Tests that should be run identically in both cases are added in DeviceAndProfileOwnerTestApi25.
 */
// We need managed users to be supported in order to create a profile of the user owner.
@RequiresAdditionalFeatures({FEATURE_MANAGED_USERS})
public class MixedManagedProfileOwnerTestApi25 extends DeviceAndProfileOwnerTestApi25 {
    private int mParentUserId = -1;

    @Override
    public void setUp() throws Exception {
        super.setUp();

        removeTestUsers();
        mParentUserId = mPrimaryUserId;
        createManagedProfile();
    }

    private void createManagedProfile() throws Exception {
        mUserId = createManagedProfile(mParentUserId);
        switchUser(mParentUserId);
        startUserAndWait(mUserId);

        installAppAsUser(DEVICE_ADMIN_APK, mUserId);
        setProfileOwnerOrFail(DEVICE_ADMIN_PKG + ""/"" + ADMIN_RECEIVER_TEST_CLASS, mUserId);
        startUserAndWait(mUserId);
    }

    @Override
    public void tearDown() throws Exception {
        removeUser(mUserId);

        super.tearDown();
    }

    @Override
    @PermissionsTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/MixedManagedProfileOwnerTestApi25.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.MixedManagedProfileOwnerTestApi25"	"testPermissionGrantPreMApp"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([2:/com/android/cts/devicepolicy/MixedManagedProfileOwnerTestApi25.java]:[permission]:[2]:method_text:[ testPermissionGrantPreMApp() throws Exception {        super.testPermissionGrantPreMApp();    }}]) :|: 
    public void testPermissionGrantPreMApp() throws Exception {
        super.testPermissionGrantPreMApp();
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/MixedManagedProfileOwnerTestApi25.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.LimitAppIconHidingTest"	"assumeTestEnabled"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([4:/com/android/cts/devicepolicy/LimitAppIconHidingTest.java]:[permission]:[4]:method_text:[ITY_APK);        getDevice().uninstallPackage(LAUNCHER_TESTS_HAS_LAUNCHER_ACTIVITY_APK);    }   ]) :|: /*
 *.
 */

package com.android.cts.devicepolicy;

import org.junit.Test;

import java.util.Collections;

/**
 * Set of tests for the limit app icon hiding feature.
 */
public class LimitAppIconHidingTest extends BaseLauncherAppsTest {

    private static final String LAUNCHER_TESTS_HAS_LAUNCHER_ACTIVITY_APK =
            ""CtsHasLauncherActivityApp.apk"";
    private static final String LAUNCHER_TESTS_NO_LAUNCHER_ACTIVITY_APK =
            ""CtsNoLauncherActivityApp.apk"";
    private static final String LAUNCHER_TESTS_NO_PERMISSION_APK =
            ""CtsNoPermissionApp.apk"";

    private String mSerialNumber;
    private int mCurrentUserId;

    @Override
    protected void assumeTestEnabled() throws Exception {
        assumeApiLevel(21);
    }

    @Override
    public void setUp() throws Exception {
        super.setUp();

        mCurrentUserId = getDevice().getCurrentUser();
        mSerialNumber = Integer.toString(getUserSerialNumber(mCurrentUserId));
        uninstallTestApps();
        installTestApps(mCurrentUserId);
    }

    @Override
    public void tearDown() throws Exception {
        uninstallTestApps();

        super.tearDown();
    }

    @Override
    protected void installTestApps(int userId) throws Exception {
        super.installTestApps(mCurrentUserId);
        installAppAsUser(LAUNCHER_TESTS_HAS_LAUNCHER_ACTIVITY_APK, mCurrentUserId);
        installAppAsUser(LAUNCHER_TESTS_NO_LAUNCHER_ACTIVITY_APK, mCurrentUserId);
        installAppAsUser(LAUNCHER_TESTS_NO_PERMISSION_APK, mCurrentUserId);
    }

    @Override
    protected void uninstallTestApps() throws Exception {
        super.uninstallTestApps();
        getDevice().uninstallPackage(LAUNCHER_TESTS_NO_PERMISSION_APK);
        getDevice().uninstallPackage(LAUNCHER_TESTS_NO_LAUNCHER_ACTIVITY_APK);
        getDevice().uninstallPackage(LAUNCHER_TESTS_HAS_LAUNCHER_ACTIVITY_APK);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/LimitAppIconHidingTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.LimitAppIconHidingTest"	"testNoPermissionAppNotInjected"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([2:/com/android/cts/devicepolicy/LimitAppIconHidingTest.java]:[permission]:[2]:method_text:[               mCurrentUserId, Collections.singletonMap(PARAM_TEST_USER, mSerialNumber));    }   ]) :|: 
    public void testNoPermissionAppNotInjected() throws Exception {
        runDeviceTestsAsUser(LAUNCHER_TESTS_PKG,
                LAUNCHER_TESTS_CLASS, ""testNoPermissionAppNotInjected"",
                mCurrentUserId, Collections.singletonMap(PARAM_TEST_USER, mSerialNumber));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/LimitAppIconHidingTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.ManagedProfileCrossProfileTest"	"testCrossProfileContent"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([3:/com/android/cts/devicepolicy/ManagedProfileCrossProfileTest.java]:[permission]:[3]:method_text:[ runDeviceTestsAsUser(INTENT_SENDER_PKG, "".ContentTest"", mProfileUserId);    }    @FlakyTest   ]) :|: 
    public void testCrossProfileContent() throws Exception {

        // Storage permission shouldn't be granted, we check if missing permissions are respected
        // in ContentTest#testSecurity.
        installAppAsUser(INTENT_SENDER_APK, false /* grantPermissions */, USER_ALL);
        installAppAsUser(INTENT_RECEIVER_APK, USER_ALL);

        // Test from parent to managed
        runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".CrossProfileUtils"",
                ""testRemoveAllFilters"", mProfileUserId);
        runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".CrossProfileUtils"",
                ""testAddManagedCanAccessParentFilters"", mProfileUserId);
        runDeviceTestsAsUser(INTENT_SENDER_PKG, "".ContentTest"", mParentUserId);

        // Test from managed to parent
        runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".CrossProfileUtils"",
                ""testRemoveAllFilters"", mProfileUserId);
        runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".CrossProfileUtils"",
                ""testAddParentCanAccessManagedFilters"", mProfileUserId);
        runDeviceTestsAsUser(INTENT_SENDER_PKG, "".ContentTest"", mProfileUserId);

    }

    @FlakyTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/ManagedProfileCrossProfileTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.CrossProfileAppsHostSideTest"	"testStartActivityIntentPermissions"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([5:/com/android/cts/devicepolicy/CrossProfileAppsHostSideTest.java]:[permission]:[5]:method_text:[ASS, ""testCanStartActivityByIntentWithInteractAcrossUsersFullPermission"");    }    @LargeTest   ]) :|: 
    public void testStartActivityIntentPermissions() throws Exception {
        if (!mHasManagedUserFeature) {
            return;
        }
        verifyCrossProfileAppsApi(mProfileId, mPrimaryUserId, START_ACTIVITY_TEST_CLASS, ""testCannotStartActivityByIntentWithNoPermissions"");
        verifyCrossProfileAppsApi(mProfileId, mPrimaryUserId, START_ACTIVITY_TEST_CLASS, ""testCanStartActivityByIntentWithInteractAcrossProfilesPermission"");
        verifyCrossProfileAppsApi(mProfileId, mPrimaryUserId, START_ACTIVITY_TEST_CLASS, ""testCanStartActivityByIntentWithInteractAcrossUsersPermission"");
        verifyCrossProfileAppsApi(mProfileId, mPrimaryUserId, START_ACTIVITY_TEST_CLASS, ""testCanStartActivityByIntentWithInteractAcrossUsersFullPermission"");
    }

    @LargeTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/CrossProfileAppsHostSideTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.SeparateProfileChallengeTest"	"removeTestUsers"	"CtsDevicePolicyManagerTestCases"	"2: managed_users permission"	"([2:/com/android/cts/devicepolicy/SeparateProfileChallengeTest.java]:[permission]:[2]:method_text:[PARATE_PROFILE_PKG);        setHiddenApiPolicyPreviousOrOff();        super.tearDown();    }   ]) :|: /*
 *.
 */

package com.android.cts.devicepolicy;

import static com.android.cts.devicepolicy.DeviceAdminFeaturesCheckerRule.FEATURE_MANAGED_USERS;

import android.platform.test.annotations.AsbSecurityTest;

import com.android.cts.devicepolicy.DeviceAdminFeaturesCheckerRule.RequiresAdditionalFeatures;

import org.junit.Test;

/**
 * Host side tests for separate profile challenge permissions.
 * Run the CtsSeparateProfileChallengeApp device side test.
 */
@RequiresAdditionalFeatures({FEATURE_MANAGED_USERS})
public class SeparateProfileChallengeTest extends BaseDevicePolicyTest {
    private static final String SEPARATE_PROFILE_PKG = ""com.android.cts.separateprofilechallenge"";
    private static final String SEPARATE_PROFILE_APK = ""CtsSeparateProfileChallengeApp.apk"";
    private static final String SEPARATE_PROFILE_TEST_CLASS =
        "".SeparateProfileChallengePermissionsTest"";
    private String mPreviousHiddenApiPolicy = ""0"";

    @Override
    public void setUp() throws Exception {
        super.setUp();

        setHiddenApiPolicyOn();
    }

    @Override
    public void tearDown() throws Exception {

        removeTestUsers();
        getDevice().uninstallPackage(SEPARATE_PROFILE_PKG);
        setHiddenApiPolicyPreviousOrOff();
        super.tearDown();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/SeparateProfileChallengeTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.SeparateProfileChallengeTest"	"testSeparateProfileChallengePermissions"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([1:/com/android/cts/devicepolicy/SeparateProfileChallengeTest.java]:[permission]:[1]:method_text:[n {        runDeviceTestsAsUser(SEPARATE_PROFILE_PKG, SEPARATE_PROFILE_TEST_CLASS, userId);    }}]) :|: 
    @AsbSecurityTest(cveBugId = 128599668)
    public void testSeparateProfileChallengePermissions() throws Exception {
        assumeCanCreateOneManagedUser();

        // Create managed profile.
        final int profileUserId = createManagedProfile(mPrimaryUserId);
        // createManagedProfile doesn't start the user automatically.
        startUser(profileUserId);
        installAppAsUser(SEPARATE_PROFILE_APK, profileUserId);
        executeSeparateProfileChallengeTest(profileUserId);
    }

    protected void setHiddenApiPolicyOn() throws Exception {
        mPreviousHiddenApiPolicy = getDevice().executeShellCommand(
                ""settings get global hidden_api_policy_p_apps"");
        executeShellCommand(""settings put global hidden_api_policy_p_apps 1"");
    }

    protected void setHiddenApiPolicyPreviousOrOff() throws Exception {
        executeShellCommand(""settings put global hidden_api_policy_p_apps ""
            + mPreviousHiddenApiPolicy);
    }

    private void executeSeparateProfileChallengeTest(int userId) throws Exception {
        runDeviceTestsAsUser(SEPARATE_PROFILE_PKG, SEPARATE_PROFILE_TEST_CLASS, userId);
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/SeparateProfileChallengeTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.ManagedProfileTest"	"testCanGetWorkShortcutIconDrawableFromPersonalProfile"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([1:/com/android/cts/devicepolicy/ManagedProfileTest.java]:[permission]:[1]:method_text:[herAppsTest"",                    ""removeAllDynamicShortcuts"", mProfileUserId);        }    }   ]) :|: 
    public void testCanGetWorkShortcutIconDrawableFromPersonalProfile()
            throws DeviceNotAvailableException {
        runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".LauncherAppsTest"",
                ""addDynamicShortcuts"", mProfileUserId);
        try {
            Map<String, String> params = new HashMap<>();
            params.put(""otherProfileUserId"", String.valueOf(mProfileUserId));
            runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".LauncherAppsTest"",
                    ""shortcutIconDrawable_currentToOtherProfile_withUsersFullPermission_isNotNull"",
                    mPrimaryUserId, params);
        } finally {
            runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".LauncherAppsTest"",
                    ""removeAllDynamicShortcuts"", mProfileUserId);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/ManagedProfileTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.ManagedProfileTest"	"testCanGetPersonalShortcutIconDrawableFromWorkProfile"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([2:/com/android/cts/devicepolicy/ManagedProfileTest.java]:[permission]:[2]:method_text:[herAppsTest"",                    ""removeAllDynamicShortcuts"", mPrimaryUserId);        }    }   ]) :|: 
    public void testCanGetPersonalShortcutIconDrawableFromWorkProfile()
            throws DeviceNotAvailableException {
        runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".LauncherAppsTest"",
                ""addDynamicShortcuts"", mPrimaryUserId);
        try {
            Map<String, String> params = new HashMap<>();
            params.put(""otherProfileUserId"", String.valueOf(mPrimaryUserId));
            runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".LauncherAppsTest"",
                    ""shortcutIconDrawable_currentToOtherProfile_withUsersFullPermission_isNotNull"",
                    mProfileUserId, params);
            runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".LauncherAppsTest"",
                    ""shortcutIconDrawable_currentToOtherProfile_withoutUsersFullPermission_isNull"",
                    mProfileUserId, params);
        } finally {
            runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".LauncherAppsTest"",
                    ""removeAllDynamicShortcuts"", mPrimaryUserId);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/ManagedProfileTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.ManagedProfileRingtoneTest"	"testRingtoneSync"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([1:/com/android/cts/devicepolicy/ManagedProfileRingtoneTest.java]:[permission]:[1]:method_text:[       ""testRingtoneSync"", mProfileUserId);    }    // Test if setting RINGTONE disables sync   ]) :|: 
    public void testRingtoneSync() throws Exception {
        givePackageWriteSettingsPermission(mProfileUserId);
        runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".RingtoneSyncTest"",
                ""testRingtoneSync"", mProfileUserId);
    }

    // Test if setting RINGTONE disables sync"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/ManagedProfileRingtoneTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.ManagedProfileRingtoneTest"	"testRingtoneSyncAutoDisableRingtone"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([1:/com/android/cts/devicepolicy/ManagedProfileRingtoneTest.java]:[permission]:[1]:method_text:[tRingtoneDisableSync"", mProfileUserId);    }    // Test if setting NOTIFICATION disables sync   ]) :|: 
    public void testRingtoneSyncAutoDisableRingtone() throws Exception {
        givePackageWriteSettingsPermission(mProfileUserId);
        runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".RingtoneSyncTest"",
                ""testRingtoneDisableSync"", mProfileUserId);
    }

    // Test if setting NOTIFICATION disables sync"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/ManagedProfileRingtoneTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.ManagedProfileRingtoneTest"	"testRingtoneSyncAutoDisableNotification"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([1:/com/android/cts/devicepolicy/ManagedProfileRingtoneTest.java]:[permission]:[1]:method_text:[testNotificationDisableSync"", mProfileUserId);    }    // Test if setting ALARM disables sync   ]) :|: 
    public void testRingtoneSyncAutoDisableNotification() throws Exception {
        givePackageWriteSettingsPermission(mProfileUserId);
        runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".RingtoneSyncTest"",
                ""testNotificationDisableSync"", mProfileUserId);
    }

    // Test if setting ALARM disables sync"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/ManagedProfileRingtoneTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.ManagedProfileRingtoneTest"	"testRingtoneSyncAutoDisableAlarm"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([2:/com/android/cts/devicepolicy/ManagedProfileRingtoneTest.java]:[permission]:[2]:method_text:[  CLog.d(""Output for command "" + command + "": "" + getDevice().executeShellCommand(command));    }}]) :|: 
    public void testRingtoneSyncAutoDisableAlarm() throws Exception {
        givePackageWriteSettingsPermission(mProfileUserId);
        runDeviceTestsAsUser(MANAGED_PROFILE_PKG, "".RingtoneSyncTest"",
                ""testAlarmDisableSync"", mProfileUserId);
    }

    private void givePackageWriteSettingsPermission(int userId) throws DeviceNotAvailableException {
        // Allow app to write to settings (for RingtoneManager.setActualDefaultUri to work)
        String command = ""appops set --user "" + userId + "" "" + MANAGED_PROFILE_PKG
                + "" android:write_settings allow"";
        CLog.d(""Output for command "" + command + "": "" + getDevice().executeShellCommand(command));
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/ManagedProfileRingtoneTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.MixedDeviceOwnerTest"	"testLocationPermissionGrantNotifies"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([5:/com/android/cts/devicepolicy/MixedDeviceOwnerTest.java]:[permission]:[5]:method_text:[       ""testPermissionGrantStateGranted_userNotifiedOfLocationPermission"");    }    @Override   ]) :|: 
    public void testLocationPermissionGrantNotifies() throws Exception {
        installAppPermissionAppAsUser();
        configureNotificationListener();
        executeDeviceTestMethod("".PermissionsTest"",
                ""testPermissionGrantStateGranted_userNotifiedOfLocationPermission"");
    }

    @Override"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/MixedDeviceOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.MixedDeviceOwnerTest"	"testAdminControlOverSensorPermissionGrantsDefault"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([4:/com/android/cts/devicepolicy/MixedDeviceOwnerTest.java]:[permission]:[4]:method_text:[rmissionGrantTest"",                ""testAdminCanGrantSensorsPermissions"");    }    @Override   ]) :|: 
    public void testAdminControlOverSensorPermissionGrantsDefault() throws Exception {
        // In Device Owner mode, by default, admin should be able to grant sensors-related
        // permissions.
        executeDeviceTestMethod("".SensorPermissionGrantTest"",
                ""testAdminCanGrantSensorsPermissions"");
    }

    @Override"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/MixedDeviceOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.MixedDeviceOwnerTest"	"testGrantOfSensorsRelatedPermissions"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([2:/com/android/cts/devicepolicy/MixedDeviceOwnerTest.java]:[permission]:[2]:method_text:[for now, re-enable when the code path sets DO as able to grant permissions.    }    @Override   ]) :|: 
    public void testGrantOfSensorsRelatedPermissions() throws Exception {
        // Skip for now, re-enable when the code path sets DO as able to grant permissions.
    }

    @Override"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/MixedDeviceOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.MixedDeviceOwnerTest"	"testSensorsRelatedPermissionsNotGrantedViaPolicy"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([2:/com/android/cts/devicepolicy/MixedDeviceOwnerTest.java]:[permission]:[2]:method_text:[for now, re-enable when the code path sets DO as able to grant permissions.    }    @Override   ]) :|: 
    public void testSensorsRelatedPermissionsNotGrantedViaPolicy() throws Exception {
        // Skip for now, re-enable when the code path sets DO as able to grant permissions.
    }

    @Override"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/MixedDeviceOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.MixedDeviceOwnerTest"	"testStateOfSensorsRelatedPermissionsCannotBeRead"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([2:/com/android/cts/devicepolicy/MixedDeviceOwnerTest.java]:[permission]:[2]:method_text:[n state.    }    //TODO(b/180413140) Investigate why the test fails on DO mode.    @Override   ]) :|: 
    public void testStateOfSensorsRelatedPermissionsCannotBeRead() throws Exception {
        // Skip because in DO mode the admin can read permission state.
    }

    //TODO(b/180413140) Investigate why the test fails on DO mode.
    @Override"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/MixedDeviceOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.MixedDeviceOwnerTest"	"testPermissionPrompts"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([1:/com/android/cts/devicepolicy/MixedDeviceOwnerTest.java]:[permission]:[1]:method_text:[    public void testPermissionPrompts() throws Exception {    }    @Override    ]) :|: 
    public void testPermissionPrompts() throws Exception {
    }

    @Override"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/MixedDeviceOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.MixedDeviceOwnerTest"	"testDisallowAutofill_allowed"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([1:/com/android/cts/devicepolicy/MixedDeviceOwnerTest.java]:[permission]:[1]:method_text:[ser(                DEVICE_ADMIN_PKG, "".AffiliationTest"", ""testSetAffiliationId1"", userId);    }}]) :|: 
    @IgnoreOnHeadlessSystemUserMode(reason = ""Headless system user doesn't launch activities"")
    public void testDisallowAutofill_allowed() throws Exception {
        super.testDisallowAutofill_allowed();
    }

    @Override
    public void testApplicationHidden() throws Exception {
        if (isHeadlessSystemUserMode()) {
            // Must run on user 0 because the test has a broadcast receiver that listen to packages
            // added / removed intents
            mUserId = mDeviceOwnerUserId;
            CLog.d(""testApplicationHidden(): setting mUserId as %d before running it"", mUserId);
        }
        super.testApplicationHidden();
    }

    @Override
    protected void installDelegateApp() throws Exception {
        // TODO(b/176993670): must call installDeviceOwnerApp() - even though it's not one - so
        // the permissions required to use DpmWrapper are set on headless system user mode
        installDeviceOwnerApp(DELEGATE_APP_APK);
    }

    @Override
    protected void runDeviceTestsAsUser(String pkgName, String testClassName, String testName,
            int userId, Map<String, String> params) throws DeviceNotAvailableException {
        Map<String, String> newParams = new HashMap(params);
        newParams.putAll(getParamsForDeviceOwnerTest());
        super.runDeviceTestsAsUser(
                pkgName, testClassName, testName, userId, newParams);
    }

    @Override
    protected void executeDeviceTestMethod(String className, String testName,
            Map<String, String> params) throws Exception {
        runDeviceTestsAsUser(DEVICE_ADMIN_PKG, className, testName, mUserId, params);
    }

    private void executeDeviceTestMethodOnDeviceOwnerUser(String className, String testName)
            throws Exception {
        executeDeviceTestMethod(className, testName, mDeviceOwnerUserId,
                /* params= */ new HashMap<>());
    }

    private void configureNotificationListener() throws DeviceNotAvailableException {
        g"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/MixedDeviceOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.UserRestrictionsTest"	"isHeadlessSystemUserMode"	"CtsDevicePolicyManagerTestCases"	"1: managed_users"	"([1:/com/android/cts/devicepolicy/UserRestrictionsTest.java]:[managed_users]:[1]:method_text:[          throws DeviceNotAvailableException {        runTests(className, null, userId);    }   ]) :|: /*
 *.
 */
package com.android.cts.devicepolicy;

import static com.android.cts.devicepolicy.DeviceAdminFeaturesCheckerRule.FEATURE_MANAGED_USERS;

import static org.junit.Assert.assertTrue;

import com.android.cts.devicepolicy.DeviceAdminFeaturesCheckerRule.RequiresAdditionalFeatures;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.log.LogUtil.CLog;

import org.junit.Test;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

public class UserRestrictionsTest extends BaseDevicePolicyTest {
    private static final String DEVICE_ADMIN_PKG = ""com.android.cts.deviceandprofileowner"";
    private static final String DEVICE_ADMIN_APK = ""CtsDeviceAndProfileOwnerApp.apk"";
    private static final String ADMIN_RECEIVER_TEST_CLASS
            = "".BaseDeviceAdminTest$BasicAdminReceiver"";

    private static final String GLOBAL_RESTRICTIONS_TEST_CLASS =
            ""userrestrictions.ProfileGlobalRestrictionsTest"";
    private static final String SET_GLOBAL_RESTRICTIONS_TEST =
            ""testSetProfileGlobalRestrictions"";
    private static final String CLEAR_GLOBAL_RESTRICTIONS_TEST =
            ""testClearProfileGlobalRestrictions"";
    private static final String ENSURE_GLOBAL_RESTRICTIONS_TEST =
            ""testProfileGlobalRestrictionsEnforced"";
    private static final String ENSURE_NO_GLOBAL_RESTRICTIONS_TEST =
            ""testProfileGlobalRestrictionsNotEnforced"";

    private boolean mRemoveOwnerInTearDown;
    private int mDeviceOwnerUserId;

    @Override
    public void setUp() throws Exception {
        super.setUp();

        mRemoveOwnerInTearDown = false;
    }

    @Override
    public void tearDown() throws Exception {
        if (mRemoveOwnerInTearDown) {
            String componentName = DEVICE_ADMIN_PKG + ""/"" + ADMIN_RECEIVER_TEST_CLASS;
            assertTrue(""Failed to clear owner"", removeAdmin(componentName, mDeviceOwnerUserId));
            runTests(""userrestrictions.CheckNoOwnerRestriction"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/UserRestrictionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.UserRestrictionsTest"	"testUserRestrictions_secondaryProfileOwnerOnly"	"CtsDevicePolicyManagerTestCases"	"1: managed_users"	"([1:/com/android/cts/devicepolicy/UserRestrictionsTest.java]:[managed_users]:[1]:method_text:[hecks restrictions for managed profile.    @RequiresAdditionalFeatures({FEATURE_MANAGED_USERS})   ]) :|: 
    public void testUserRestrictions_secondaryProfileOwnerOnly() throws Exception {
        assumeSupportsMultiUser();

        final int secondaryUserId = createUser();
        setPoAsUser(secondaryUserId);

        runTests(""userrestrictions.SecondaryProfileOwnerUserRestrictionsTest"",
                ""testDefaultRestrictions"", secondaryUserId);
        runTests(""userrestrictions.SecondaryProfileOwnerUserRestrictionsTest"",
                ""testSetAllRestrictions"", secondaryUserId);
        runTests(""userrestrictions.SecondaryProfileOwnerUserRestrictionsTest"",
                ""testBroadcast"", secondaryUserId);
    }

    // Checks restrictions for managed profile.
    @RequiresAdditionalFeatures({FEATURE_MANAGED_USERS})"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/UserRestrictionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.UserRestrictionsTest"	"testUserRestrictions_profileGlobalRestrictionsAsDo"	"CtsDevicePolicyManagerTestCases"	"1: managed_users"	"([1:/com/android/cts/devicepolicy/UserRestrictionsTest.java]:[managed_users]:[1]:method_text:[should     * affect all users.     */    @RequiresAdditionalFeatures({FEATURE_MANAGED_USERS})   ]) :|: 
    public void testUserRestrictions_profileGlobalRestrictionsAsDo() throws Exception {
        assumeSupportsMultiUser();
        setDo();
        final int secondaryUserId;
        if (!isHeadlessSystemUserMode()) {
            // Create another user and set PO.
            secondaryUserId = createUserAndWaitStart();
            setPoAsUser(secondaryUserId);
        } else {
            // In headless system user mode, PO is set on primary user when DO is set.
            secondaryUserId = mPrimaryUserId;
        }

        final int[] usersToCheck = {mDeviceOwnerUserId, secondaryUserId};

        // Do sets the restriction.
        setAndCheckProfileGlobalRestriction(mDeviceOwnerUserId, usersToCheck);
    }

    /**
     * Managed profile owner sets profile global restrictions (only ENSURE_VERIFY_APPS), should
     * affect all users.
     */
    @RequiresAdditionalFeatures({FEATURE_MANAGED_USERS})"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/UserRestrictionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.QuietModeHostsideTest"	"wakeupAndDismissKeyguard"	"CtsDevicePolicyManagerTestCases"	"1: managed_users"	"([2:/com/android/cts/devicepolicy/QuietModeHostsideTest.java]:[managed_users]:[2]:method_text:[vice().uninstallPackage(TEST_LAUNCHER_PACKAGE);        super.tearDown();    }    @LargeTest   ]) :|: package com.android.cts.devicepolicy;

import static com.android.cts.devicepolicy.DeviceAdminFeaturesCheckerRule.FEATURE_MANAGED_USERS;

import static com.google.common.truth.Truth.assertThat;

import android.platform.test.annotations.LargeTest;

import com.android.cts.devicepolicy.DeviceAdminFeaturesCheckerRule.RequiresAdditionalFeatures;
import com.android.tradefed.device.DeviceNotAvailableException;

import org.junit.Test;

import java.io.FileNotFoundException;
import java.util.HashMap;
import java.util.Map;

/**
 * CTS to verify toggling quiet mode in work profile by using
 * {@link android.os.UserManager#requestQuietModeEnabled(boolean, android.os.UserHandle)}.
 */
@RequiresAdditionalFeatures({FEATURE_MANAGED_USERS})
public class QuietModeHostsideTest extends BaseDevicePolicyTest {
    private static final String TEST_PACKAGE = ""com.android.cts.launchertests"";
    private static final String TEST_CLASS = "".QuietModeTest"";
    private static final String PARAM_TARGET_USER = ""TARGET_USER"";
    private static final String PARAM_ORIGINAL_DEFAULT_LAUNCHER = ""ORIGINAL_DEFAULT_LAUNCHER"";
    private static final String TEST_APK = ""CtsLauncherAppsTests.apk"";

    private static final String TEST_LAUNCHER_PACKAGE = ""com.android.cts.launchertests.support"";
    private static final String TEST_LAUNCHER_APK = ""CtsLauncherAppsTestsSupport.apk"";
    private static final String ENABLED_TEST_APK = ""CtsCrossProfileEnabledApp.apk"";
    private static final String USER_ENABLED_TEST_APK = ""CtsCrossProfileUserEnabledApp.apk"";
    private static final String ENABLED_NO_PERMS_TEST_APK = ""CtsCrossProfileEnabledNoPermsApp.apk"";
    private static final String QUIET_MODE_ENABLED_TEST_APK = ""CtsModifyQuietModeEnabledApp.apk"";
    private static final String NOT_ENABLED_TEST_APK = ""CtsCrossProfileNotEnabledApp.apk"";
    private static final String ENABLED_TEST_PACKAGE = ""com.android.cts.crossprofileenabledapp"";
    private static final String USER_ENABLED_TEST_PACKAGE =
            ""com.a"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/QuietModeHostsideTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.QuietModeHostsideTest"	"testBroadcastManagedProfileAvailable_withCrossProfileAppsOp"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([5:/com/android/cts/devicepolicy/QuietModeHostsideTest.java]:[permission]:[5]:method_text:[        return String.format(""%s: onReceive(%s)"", className, actionName);    }    @LargeTest   ]) :|: 
    public void testBroadcastManagedProfileAvailable_withCrossProfileAppsOp() throws Exception {
        checkBroadcastManagedProfileAvailable(/* withCrossProfileAppOps= */ true);
    }

    private void checkBroadcastManagedProfileAvailable(boolean withCrossProfileAppOps)
            throws Exception {
        installCrossProfileApps();
        if (withCrossProfileAppOps) {
            enableCrossProfileAppsOp();
        }
        clearLogcat();
        runDeviceTestsAsUser(
                TEST_PACKAGE,
                TEST_CLASS,
                ""testTryEnableQuietMode"",
                mPrimaryUserId,
                createParams(mProfileId));
        // In case of a necessary log is not captured
        // cause of too many logs while waiting idle broadcast, capture log previously.
        // This log will be concatenated.
        String log = getDevice().executeAdbCommand(""logcat"", ""-d"");
        waitForBroadcastIdle();
        verifyBroadcastSent(""android.intent.action.MANAGED_PROFILE_UNAVAILABLE"",
                /* needPermissions= */ !withCrossProfileAppOps, log);

        clearLogcat();
        runDeviceTestsAsUser(
                TEST_PACKAGE,
                TEST_CLASS,
                ""testTryDisableQuietMode"",
                mPrimaryUserId,
                createParams(mProfileId));
        log = getDevice().executeAdbCommand(""logcat"", ""-d"");
        waitForBroadcastIdle();
        verifyBroadcastSent(""android.intent.action.MANAGED_PROFILE_AVAILABLE"",
                /* needPermissions= */ !withCrossProfileAppOps, log);

        clearLogcat();
        removeUser(mProfileId);
        log = getDevice().executeAdbCommand(""logcat"", ""-d"");
        waitForBroadcastIdle();
        verifyBroadcastSent(""android.intent.action.MANAGED_PROFILE_REMOVED"",
                /* needPermissions= */ false, log);
    }

    private void clearLogcat() throws DeviceNotAvailableException {
        getDevice().executeAdbCommand(""logcat"", ""-c"");
        getDevice().executeA"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/QuietModeHostsideTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.QuietModeHostsideTest"	"testQuietMode_noCredentialRequest"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([8:/com/android/cts/devicepolicy/QuietModeHostsideTest.java]:[permission]:[8]:method_text:[      params.put(PARAM_ORIGINAL_DEFAULT_LAUNCHER, mOriginalLauncher);        return params;    }}]) :|: 
    public void testQuietMode_noCredentialRequest() throws Exception {
        assumeHasSecureLockScreenFeature();

        // Set a separate work challenge so turning on the profile requires entering the
        // separate challenge.
        changeUserCredential(/* newCredential= */ TEST_PASSWORD, /* oldCredential= */ null,
                mProfileId);
        runDeviceTestsAsUser(
                TEST_PACKAGE,
                TEST_CLASS,
                ""testTryEnableQuietMode_noCredentialRequest"",
                mPrimaryUserId,
                createParams(mProfileId));
    }

    private void createAndStartManagedProfile() throws Exception {
        mProfileId = createManagedProfile(mPrimaryUserId);
        switchUser(mPrimaryUserId);
        startUser(mProfileId);
    }

    private void uninstallRequiredApps()
            throws DeviceNotAvailableException {
        getDevice().uninstallPackage(TEST_PACKAGE);
        getDevice().uninstallPackage(ENABLED_TEST_PACKAGE);
        getDevice().uninstallPackage(USER_ENABLED_TEST_PACKAGE);
        getDevice().uninstallPackage(ENABLED_NO_PERMS_TEST_PACKAGE);
        getDevice().uninstallPackage(NOT_ENABLED_TEST_PACKAGE);
        getDevice().uninstallPackage(QUIET_MODE_ENABLED_TEST_PACKAGE);
    }

    private void installCrossProfileApps()
            throws FileNotFoundException, DeviceNotAvailableException {
        installCrossProfileApp(ENABLED_TEST_APK, /* grantPermissions= */ true);
        installCrossProfileApp(USER_ENABLED_TEST_APK, /* grantPermissions= */ true);
        installCrossProfileApp(NOT_ENABLED_TEST_APK, /* grantPermissions= */ true);
        installCrossProfileApp(ENABLED_NO_PERMS_TEST_APK, /* grantPermissions= */  false);
        installCrossProfileApp(QUIET_MODE_ENABLED_TEST_APK, /* grantPermissions= */  true);
    }

    private void enableCrossProfileAppsOp() throws DeviceNotAvailableException {
        enableCrossProfileAppsOp(ENABLED_NO_PERMS_TEST_PACKAGE, mPrimaryUserId);
    }

    priva"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/QuietModeHostsideTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.CrossProfileAppsPermissionHostSideTest"	"assumeTestEnabled"	"CtsDevicePolicyManagerTestCases"	"2: managed_users permission"	"([13:/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java]:[permission]:[13]:method_text:[  @Before    @Override    public void setUp() throws Exception {        super.setUp();    }   ]) :|: /*
 *.
 */

package com.android.cts.devicepolicy;

import static com.android.cts.devicepolicy.DeviceAdminFeaturesCheckerRule.FEATURE_MANAGED_USERS;

import com.android.cts.devicepolicy.DeviceAdminFeaturesCheckerRule.RequiresAdditionalFeatures;

import org.junit.Before;
import org.junit.Test;

import java.util.Collections;
import java.util.Map;

/**
 * Tests to verify
 * {@link android.content.pm.crossprofile.CrossProfileApps#canRequestInteractAcrossProfiles()},
 * {@link android.content.pm.crossprofile.CrossProfileApps#canInteractAcrossProfiles()}, and
 * {@link
 * android.content.pm.crossprofile.CrossProfileApps#createRequestInteractAcrossProfilesIntent()}.
 *
 * The rest of the tests for {@link android.content.pm.crossprofile.CrossProfileApps}
 * can be found in {@link CrossProfileAppsHostSideTest}.
 */
@RequiresAdditionalFeatures({FEATURE_MANAGED_USERS})
public class CrossProfileAppsPermissionHostSideTest extends BaseDevicePolicyTest {
    private static final String TEST_WITH_REQUESTED_PERMISSION_PACKAGE =
            ""com.android.cts.crossprofileappstest"";
    private static final String TEST_WITH_REQUESTED_PERMISSION_CLASS =
            "".CrossProfileAppsPermissionToInteractTest"";
    private static final String TEST_WITH_REQUESTED_PERMISSION_APK = ""CtsCrossProfileAppsTests.apk"";
    private static final String TEST_WITH_REQUESTED_PERMISSION_RECEIVER_TEST_CLASS =
            TEST_WITH_REQUESTED_PERMISSION_PACKAGE + "".AdminReceiver"";

    private static final String TEST_WITH_NO_REQUESTED_PERMISSION_PACKAGE =
            ""com.android.cts.crossprofilenopermissionappstest"";
    private static final String TEST_WITH_NO_REQUESTED_PERMISSION_CLASS =
            "".CrossProfileAppsWithNoPermission"";
    private static final String TEST_WITH_NO_REQUESTED_PERMISSION_APK =
            ""CtsCrossProfileAppsWithNoPermissionTests.apk"";

    private static final String MANAGED_PROFILE_PKG = ""com.android.cts.managedprofile"";
    private static final String MANAGED_PROFILE_APK"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.CrossProfileAppsPermissionHostSideTest"	"testCanRequestInteractAcrossProfiles_fromPersonalProfile_returnsTrue"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([5:/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java]:[permission]:[5]:method_text:[les_returnsTrue"",                mPrimaryUserId,                Collections.EMPTY_MAP);    }   ]) :|: 
    public void testCanRequestInteractAcrossProfiles_fromPersonalProfile_returnsTrue()
            throws Exception {
        installAppAsUser(TEST_WITH_REQUESTED_PERMISSION_APK, mPrimaryUserId);
        addManagedProfileAndInstallRequiredPackages(TEST_WITH_REQUESTED_PERMISSION_APK);
        addDefaultCrossProfilePackage(mProfileId, TEST_WITH_REQUESTED_PERMISSION_PACKAGE);

        runDeviceTestsAsUser(
                TEST_WITH_REQUESTED_PERMISSION_PACKAGE,
                TEST_WITH_REQUESTED_PERMISSION_CLASS,
                ""testCanRequestInteractAcrossProfiles_returnsTrue"",
                mPrimaryUserId,
                Collections.EMPTY_MAP);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.CrossProfileAppsPermissionHostSideTest"	"testCanRequestInteractAcrossProfiles_fromWorkProfile_returnsTrue"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([5:/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java]:[permission]:[5]:method_text:[rofiles_returnsTrue"",                mProfileId,                Collections.EMPTY_MAP);    }   ]) :|: 
    public void testCanRequestInteractAcrossProfiles_fromWorkProfile_returnsTrue()
            throws Exception {
        installAppAsUser(TEST_WITH_REQUESTED_PERMISSION_APK, mPrimaryUserId);
        addManagedProfileAndInstallRequiredPackages(TEST_WITH_REQUESTED_PERMISSION_APK);
        addDefaultCrossProfilePackage(mProfileId, TEST_WITH_REQUESTED_PERMISSION_PACKAGE);

        runDeviceTestsAsUser(
                TEST_WITH_REQUESTED_PERMISSION_PACKAGE,
                TEST_WITH_REQUESTED_PERMISSION_CLASS,
                ""testCanRequestInteractAcrossProfiles_returnsTrue"",
                mProfileId,
                Collections.EMPTY_MAP);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.CrossProfileAppsPermissionHostSideTest"	"testCanRequestInteractAcrossProfiles_noOtherProfiles_ReturnsFalse"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([3:/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java]:[permission]:[3]:method_text:[es_returnsFalse"",                mPrimaryUserId,                Collections.EMPTY_MAP);    }   ]) :|: 
    public void testCanRequestInteractAcrossProfiles_noOtherProfiles_ReturnsFalse()
            throws Exception {
        installAppAsUser(TEST_WITH_REQUESTED_PERMISSION_APK, mPrimaryUserId);

        runDeviceTestsAsUser(
                TEST_WITH_REQUESTED_PERMISSION_PACKAGE,
                TEST_WITH_REQUESTED_PERMISSION_CLASS,
                ""testCanRequestInteractAcrossProfiles_returnsFalse"",
                mPrimaryUserId,
                Collections.EMPTY_MAP);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.CrossProfileAppsPermissionHostSideTest"	"testCanRequestInteractAcrossProfiles_packageNotAllowed_returnsTrue"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([4:/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java]:[permission]:[4]:method_text:[les_returnsTrue"",                mPrimaryUserId,                Collections.EMPTY_MAP);    }   ]) :|: 
    public void testCanRequestInteractAcrossProfiles_packageNotAllowed_returnsTrue()
            throws Exception {
        installAppAsUser(TEST_WITH_REQUESTED_PERMISSION_APK, mPrimaryUserId);
        addManagedProfileAndInstallRequiredPackages(TEST_WITH_REQUESTED_PERMISSION_APK);

        runDeviceTestsAsUser(
                TEST_WITH_REQUESTED_PERMISSION_PACKAGE,
                TEST_WITH_REQUESTED_PERMISSION_CLASS,
                ""testCanRequestInteractAcrossProfiles_returnsTrue"",
                mPrimaryUserId,
                Collections.EMPTY_MAP);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.CrossProfileAppsPermissionHostSideTest"	"testCanRequestInteractAcrossProfiles_packageNotInstalled_returnsTrue"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([4:/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java]:[permission]:[4]:method_text:[les_returnsTrue"",                mPrimaryUserId,                Collections.EMPTY_MAP);    }   ]) :|: 
    public void testCanRequestInteractAcrossProfiles_packageNotInstalled_returnsTrue()
            throws Exception {
        installAppAsUser(TEST_WITH_REQUESTED_PERMISSION_APK, mPrimaryUserId);
        mProfileId = createManagedProfile(mPrimaryUserId);
        getDevice().startUser(mProfileId, /*waitFlag= */true);
        installAppAsUser(MANAGED_PROFILE_APK, mProfileId);
        setProfileOwnerOrFail(MANAGED_PROFILE_PKG + ""/"" + ADMIN_RECEIVER_TEST_CLASS,
                mProfileId);
        addDefaultCrossProfilePackage(mProfileId, TEST_WITH_REQUESTED_PERMISSION_PACKAGE);

        runDeviceTestsAsUser(
                TEST_WITH_REQUESTED_PERMISSION_PACKAGE,
                TEST_WITH_REQUESTED_PERMISSION_CLASS,
                ""testCanRequestInteractAcrossProfiles_returnsTrue"",
                mPrimaryUserId,
                Collections.EMPTY_MAP);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.CrossProfileAppsPermissionHostSideTest"	"testCanRequestInteractAcrossProfiles_permissionNotRequested_returnsFalse"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([7:/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java]:[permission]:[7]:method_text:[ed_returnsFalse"",                mPrimaryUserId,                Collections.EMPTY_MAP);    }   ]) :|: 
    public void testCanRequestInteractAcrossProfiles_permissionNotRequested_returnsFalse()
            throws Exception {
        installAppAsUser(TEST_WITH_NO_REQUESTED_PERMISSION_APK, mPrimaryUserId);
        addManagedProfileAndInstallRequiredPackages(TEST_WITH_NO_REQUESTED_PERMISSION_APK);
        addDefaultCrossProfilePackage(mProfileId, TEST_WITH_NO_REQUESTED_PERMISSION_PACKAGE);

        runDeviceTestsAsUser(
                TEST_WITH_NO_REQUESTED_PERMISSION_PACKAGE,
                TEST_WITH_NO_REQUESTED_PERMISSION_CLASS,
                ""testCanRequestInteractAcrossProfiles_permissionNotRequested_returnsFalse"",
                mPrimaryUserId,
                Collections.EMPTY_MAP);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.CrossProfileAppsPermissionHostSideTest"	"testCanRequestInteractAcrossProfiles_profileOwner_returnsFalse"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([9:/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java]:[permission]:[9]:method_text:[es_returnsFalse"",                mPrimaryUserId,                Collections.EMPTY_MAP);    }   ]) :|: 
    public void testCanRequestInteractAcrossProfiles_profileOwner_returnsFalse()
            throws Exception {
        installAppAsUser(TEST_WITH_REQUESTED_PERMISSION_APK, mPrimaryUserId);
        mProfileId = createManagedProfile(mPrimaryUserId);
        getDevice().startUser(mProfileId, /* waitFlag= */ true);
        installAppAsUser(TEST_WITH_REQUESTED_PERMISSION_APK, mProfileId);
        final String receiverComponentName =
                TEST_WITH_REQUESTED_PERMISSION_PACKAGE + ""/""
                        + TEST_WITH_REQUESTED_PERMISSION_RECEIVER_TEST_CLASS;
        setProfileOwnerOrFail(receiverComponentName, mProfileId);
        runDeviceTestsAsUser(
                TEST_WITH_REQUESTED_PERMISSION_PACKAGE,
                TEST_WITH_REQUESTED_PERMISSION_CLASS,
                ""testSetCrossProfilePackages_noAsserts"",
                mProfileId,
                createCrossProfilePackageParam(TEST_WITH_REQUESTED_PERMISSION_PACKAGE));

        runDeviceTestsAsUser(
                TEST_WITH_REQUESTED_PERMISSION_PACKAGE,
                TEST_WITH_REQUESTED_PERMISSION_CLASS,
                ""testCanRequestInteractAcrossProfiles_returnsFalse"",
                mPrimaryUserId,
                Collections.EMPTY_MAP);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.CrossProfileAppsPermissionHostSideTest"	"testCanInteractAcrossProfiles_withAppOpEnabled_returnsTrue"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([4:/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java]:[permission]:[4]:method_text:[led_returnsTrue"",                mPrimaryUserId,                Collections.EMPTY_MAP);    }   ]) :|: 
    public void testCanInteractAcrossProfiles_withAppOpEnabled_returnsTrue()
            throws Exception {
        installAppAsUser(TEST_WITH_REQUESTED_PERMISSION_APK, mPrimaryUserId);
        addManagedProfileAndInstallRequiredPackages(TEST_WITH_REQUESTED_PERMISSION_APK);

        runDeviceTestsAsUser(
                TEST_WITH_REQUESTED_PERMISSION_PACKAGE,
                TEST_WITH_REQUESTED_PERMISSION_CLASS,
                ""testCanInteractAcrossProfiles_withAppOpEnabled_returnsTrue"",
                mPrimaryUserId,
                Collections.EMPTY_MAP);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.CrossProfileAppsPermissionHostSideTest"	"testCanInteractAcrossProfiles_withCrossProfilesPermission_returnsTrue"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([6:/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java]:[permission]:[6]:method_text:[ion_returnsTrue"",                mPrimaryUserId,                Collections.EMPTY_MAP);    }   ]) :|: 
    public void testCanInteractAcrossProfiles_withCrossProfilesPermission_returnsTrue()
            throws Exception {
        installAppAsUser(TEST_WITH_REQUESTED_PERMISSION_APK, mPrimaryUserId);
        addManagedProfileAndInstallRequiredPackages(TEST_WITH_REQUESTED_PERMISSION_APK);

        runDeviceTestsAsUser(
                TEST_WITH_REQUESTED_PERMISSION_PACKAGE,
                TEST_WITH_REQUESTED_PERMISSION_CLASS,
                ""testCanInteractAcrossProfiles_withCrossProfilesPermission_returnsTrue"",
                mPrimaryUserId,
                Collections.EMPTY_MAP);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.CrossProfileAppsPermissionHostSideTest"	"testCanInteractAcrossProfiles_withCrossUsersPermission_returnsTrue"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([6:/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java]:[permission]:[6]:method_text:[ion_returnsTrue"",                mPrimaryUserId,                Collections.EMPTY_MAP);    }   ]) :|: 
    public void testCanInteractAcrossProfiles_withCrossUsersPermission_returnsTrue()
            throws Exception {
        installAppAsUser(TEST_WITH_REQUESTED_PERMISSION_APK, mPrimaryUserId);
        addManagedProfileAndInstallRequiredPackages(TEST_WITH_REQUESTED_PERMISSION_APK);

        runDeviceTestsAsUser(
                TEST_WITH_REQUESTED_PERMISSION_PACKAGE,
                TEST_WITH_REQUESTED_PERMISSION_CLASS,
                ""testCanInteractAcrossProfiles_withCrossUsersPermission_returnsTrue"",
                mPrimaryUserId,
                Collections.EMPTY_MAP);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.CrossProfileAppsPermissionHostSideTest"	"testCanInteractAcrossProfiles_withCrossUsersFullPermission_returnsTrue"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([6:/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java]:[permission]:[6]:method_text:[ion_returnsTrue"",                mPrimaryUserId,                Collections.EMPTY_MAP);    }   ]) :|: 
    public void testCanInteractAcrossProfiles_withCrossUsersFullPermission_returnsTrue()
            throws Exception {
        installAppAsUser(TEST_WITH_REQUESTED_PERMISSION_APK, mPrimaryUserId);
        addManagedProfileAndInstallRequiredPackages(TEST_WITH_REQUESTED_PERMISSION_APK);

        runDeviceTestsAsUser(
                TEST_WITH_REQUESTED_PERMISSION_PACKAGE,
                TEST_WITH_REQUESTED_PERMISSION_CLASS,
                ""testCanInteractAcrossProfiles_withCrossUsersFullPermission_returnsTrue"",
                mPrimaryUserId,
                Collections.EMPTY_MAP);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.CrossProfileAppsPermissionHostSideTest"	"testCanInteractAcrossProfiles_fromWorkProfile_returnsTrue"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([4:/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java]:[permission]:[4]:method_text:[Enabled_returnsTrue"",                mProfileId,                Collections.EMPTY_MAP);    }   ]) :|: 
    public void testCanInteractAcrossProfiles_fromWorkProfile_returnsTrue()
            throws Exception {
        installAppAsUser(TEST_WITH_REQUESTED_PERMISSION_APK, mPrimaryUserId);
        addManagedProfileAndInstallRequiredPackages(TEST_WITH_REQUESTED_PERMISSION_APK);

        runDeviceTestsAsUser(
                TEST_WITH_REQUESTED_PERMISSION_PACKAGE,
                TEST_WITH_REQUESTED_PERMISSION_CLASS,
                ""testCanInteractAcrossProfiles_withAppOpEnabled_returnsTrue"",
                mProfileId,
                Collections.EMPTY_MAP);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.CrossProfileAppsPermissionHostSideTest"	"testCanInteractAcrossProfiles_withAppOpDisabled_returnsFalse"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([4:/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java]:[permission]:[4]:method_text:[ed_returnsFalse"",                mPrimaryUserId,                Collections.EMPTY_MAP);    }   ]) :|: 
    public void testCanInteractAcrossProfiles_withAppOpDisabled_returnsFalse()
            throws Exception {
        installAppAsUser(TEST_WITH_REQUESTED_PERMISSION_APK, mPrimaryUserId);
        addManagedProfileAndInstallRequiredPackages(TEST_WITH_REQUESTED_PERMISSION_APK);

        runDeviceTestsAsUser(
                TEST_WITH_REQUESTED_PERMISSION_PACKAGE,
                TEST_WITH_REQUESTED_PERMISSION_CLASS,
                ""testCanInteractAcrossProfiles_withAppOpDisabled_returnsFalse"",
                mPrimaryUserId,
                Collections.EMPTY_MAP);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.CrossProfileAppsPermissionHostSideTest"	"testCanInteractAcrossProfiles_withNoOtherProfile_returnsFalse"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([3:/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java]:[permission]:[3]:method_text:[le_returnsFalse"",                mPrimaryUserId,                Collections.EMPTY_MAP);    }   ]) :|: 
    public void testCanInteractAcrossProfiles_withNoOtherProfile_returnsFalse()
            throws Exception {
        installAppAsUser(TEST_WITH_REQUESTED_PERMISSION_APK, mPrimaryUserId);

        runDeviceTestsAsUser(
                TEST_WITH_REQUESTED_PERMISSION_PACKAGE,
                TEST_WITH_REQUESTED_PERMISSION_CLASS,
                ""testCanInteractAcrossProfiles_withNoOtherProfile_returnsFalse"",
                mPrimaryUserId,
                Collections.EMPTY_MAP);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.CrossProfileAppsPermissionHostSideTest"	"testCanInteractAcrossProfiles_withAppOpDisabledOnCallingProfile_returnsFalse"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([3:/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java]:[permission]:[3]:method_text:[le_returnsFalse"",                mPrimaryUserId,                Collections.EMPTY_MAP);    }   ]) :|: 
    public void testCanInteractAcrossProfiles_withAppOpDisabledOnCallingProfile_returnsFalse()
            throws Exception {
        installAppAsUser(TEST_WITH_REQUESTED_PERMISSION_APK, mPrimaryUserId);

        runDeviceTestsAsUser(
                TEST_WITH_REQUESTED_PERMISSION_PACKAGE,
                TEST_WITH_REQUESTED_PERMISSION_CLASS,
                ""testCanInteractAcrossProfiles_withAppOpDisabledOnCallingProfile_returnsFalse"",
                mPrimaryUserId,
                Collections.EMPTY_MAP);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.CrossProfileAppsPermissionHostSideTest"	"testCanInteractAcrossProfiles_withAppOpDisabledOnOtherProfiles_returnsFalse"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([3:/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java]:[permission]:[3]:method_text:[es_returnsFalse"",                mPrimaryUserId,                Collections.EMPTY_MAP);    }   ]) :|: 
    public void testCanInteractAcrossProfiles_withAppOpDisabledOnOtherProfiles_returnsFalse()
            throws Exception {
        installAppAsUser(TEST_WITH_REQUESTED_PERMISSION_APK, mPrimaryUserId);

        runDeviceTestsAsUser(
                TEST_WITH_REQUESTED_PERMISSION_PACKAGE,
                TEST_WITH_REQUESTED_PERMISSION_CLASS,
                ""testCanInteractAcrossProfiles_withAppOpDisabledOnOtherProfiles_returnsFalse"",
                mPrimaryUserId,
                Collections.EMPTY_MAP);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.CrossProfileAppsPermissionHostSideTest"	"testCreateRequestInteractAcrossProfilesIntent_canRequestInteraction_returnsIntent"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([5:/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java]:[permission]:[5]:method_text:[n_returnsIntent"",                mPrimaryUserId,                Collections.EMPTY_MAP);    }   ]) :|: 
    public void testCreateRequestInteractAcrossProfilesIntent_canRequestInteraction_returnsIntent()
            throws Exception {
        installAppAsUser(TEST_WITH_REQUESTED_PERMISSION_APK, mPrimaryUserId);
        addManagedProfileAndInstallRequiredPackages(TEST_WITH_REQUESTED_PERMISSION_APK);
        addDefaultCrossProfilePackage(mProfileId, TEST_WITH_REQUESTED_PERMISSION_PACKAGE);

        runDeviceTestsAsUser(
                TEST_WITH_REQUESTED_PERMISSION_PACKAGE,
                TEST_WITH_REQUESTED_PERMISSION_CLASS,
                ""testCreateRequestInteractAcrossProfilesIntent_canRequestInteraction_returnsIntent"",
                mPrimaryUserId,
                Collections.EMPTY_MAP);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.CrossProfileAppsPermissionHostSideTest"	"testCreateRequestInteractAcrossProfilesIntent_fromWorkProfile_returnsIntent"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([5:/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java]:[permission]:[5]:method_text:[ction_returnsIntent"",                mProfileId,                Collections.EMPTY_MAP);    }   ]) :|: 
    public void testCreateRequestInteractAcrossProfilesIntent_fromWorkProfile_returnsIntent()
            throws Exception {
        installAppAsUser(TEST_WITH_REQUESTED_PERMISSION_APK, mPrimaryUserId);
        addManagedProfileAndInstallRequiredPackages(TEST_WITH_REQUESTED_PERMISSION_APK);
        addDefaultCrossProfilePackage(mProfileId, TEST_WITH_REQUESTED_PERMISSION_PACKAGE);

        runDeviceTestsAsUser(
                TEST_WITH_REQUESTED_PERMISSION_PACKAGE,
                TEST_WITH_REQUESTED_PERMISSION_CLASS,
                ""testCreateRequestInteractAcrossProfilesIntent_canRequestInteraction_returnsIntent"",
                mProfileId,
                Collections.EMPTY_MAP);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.CrossProfileAppsPermissionHostSideTest"	"testCreateRequestInteractAcrossProfilesIntent_canNotRequestInteraction_throwsSecurityException"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([3:/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java]:[permission]:[3]:method_text:[geName) {        return Collections.singletonMap(PARAM_CROSS_PROFILE_PACKAGE, packageName);    }}]) :|: 
    public void testCreateRequestInteractAcrossProfilesIntent_canNotRequestInteraction_throwsSecurityException()
            throws Exception {
        installAppAsUser(TEST_WITH_REQUESTED_PERMISSION_APK, mPrimaryUserId);

        runDeviceTestsAsUser(
                TEST_WITH_REQUESTED_PERMISSION_PACKAGE,
                TEST_WITH_REQUESTED_PERMISSION_CLASS,
                ""testCreateRequestInteractAcrossProfilesIntent_canNotRequestInteraction_throwsSecurityException"",
                mProfileId,
                Collections.EMPTY_MAP);
    }

    private void addManagedProfileAndInstallRequiredPackages(String testPackage) throws Exception {
        mProfileId = createManagedProfile(mPrimaryUserId);
        getDevice().startUser(mProfileId, /*waitFlag= */true);

        installAppAsUser(testPackage, mProfileId);

        installAppAsUser(MANAGED_PROFILE_APK, mProfileId);
        setProfileOwnerOrFail(MANAGED_PROFILE_PKG + ""/"" + ADMIN_RECEIVER_TEST_CLASS,
                mProfileId);
    }

    private void addDefaultCrossProfilePackage(int userId, String packageName)
            throws Exception {
        runDeviceTestsAsUser(
                MANAGED_PROFILE_PKG,
                "".CrossProfileUtils"",
                ""testSetCrossProfilePackages"",
                userId,
                createCrossProfilePackageParam(packageName));
    }

    private Map<String, String> createCrossProfilePackageParam(String packageName) {
        return Collections.singletonMap(PARAM_CROSS_PROFILE_PACKAGE, packageName);
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/CrossProfileAppsPermissionHostSideTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.MixedManagedProfileOwnerTest"	"removeTestUsers"	"CtsDevicePolicyManagerTestCases"	"2: managed_users permission"	"([1:/com/android/cts/devicepolicy/MixedManagedProfileOwnerTest.java]:[permission]:[1]:method_text:[s in the primary user when the policy     * is set on the profile owner.     */    @LargeTest   ]) :|: /*
 *.
 */

package com.android.cts.devicepolicy;

import static com.android.cts.devicepolicy.DeviceAdminFeaturesCheckerRule.FEATURE_MANAGED_USERS;

import android.platform.test.annotations.FlakyTest;
import android.platform.test.annotations.LargeTest;
import android.stats.devicepolicy.EventId;

import com.android.cts.devicepolicy.DeviceAdminFeaturesCheckerRule.RequiresAdditionalFeatures;
import com.android.cts.devicepolicy.annotations.LockSettingsTest;
import com.android.cts.devicepolicy.annotations.PermissionsTest;
import com.android.cts.devicepolicy.metrics.DevicePolicyEventLogVerifier;
import com.android.cts.devicepolicy.metrics.DevicePolicyEventWrapper;
import com.android.tradefed.device.DeviceNotAvailableException;

import org.junit.Test;

import java.util.ArrayList;
import java.util.List;

/**
 * Set of tests for managed profile owner use cases that also apply to device owners.
 * Tests that should be run identically in both cases are added in DeviceAndProfileOwnerTest.
 */
// We need managed users to be supported in order to create a profile of the user owner.
@RequiresAdditionalFeatures({FEATURE_MANAGED_USERS})
public class MixedManagedProfileOwnerTest extends DeviceAndProfileOwnerTest {

    private static final String CLEAR_PROFILE_OWNER_NEGATIVE_TEST_CLASS =
            DEVICE_ADMIN_PKG + "".ClearProfileOwnerNegativeTest"";

    private static final String DELEGATION_NETWORK_LOGGING = ""delegation-network-logging"";

    private int mParentUserId = -1;

    @Override
    public void setUp() throws Exception {
        super.setUp();

        removeTestUsers();
        mParentUserId = mPrimaryUserId;
        createManagedProfile();
    }

    private void createManagedProfile() throws Exception {
        mUserId = createManagedProfile(mParentUserId);
        switchUser(mParentUserId);
        startUserAndWait(mUserId);

        installAppAsUser(DEVICE_ADMIN_APK, mUserId);
        setProfileOwnerOrFail(DEVICE_ADMIN_PKG + ""/"" + ADMIN_RECEIVER_TEST_CLASS, mUserId"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/MixedManagedProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.MixedManagedProfileOwnerTest"	"testPackageInstallUserRestrictions"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([1:/com/android/cts/devicepolicy/MixedManagedProfileOwnerTest.java]:[permission]:[1]:method_text:[ {        super.testPackageInstallUserRestrictions();    }    @Override    @PermissionsTest   ]) :|: 
    public void testPackageInstallUserRestrictions() throws Exception {
        super.testPackageInstallUserRestrictions();
    }

    @Override
    @PermissionsTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/MixedManagedProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.MixedManagedProfileOwnerTest"	"testPermissionGrant"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([3:/com/android/cts/devicepolicy/MixedManagedProfileOwnerTest.java]:[permission]:[3]:method_text:[hrows Exception {        super.testPermissionGrant();    }    @Override    @PermissionsTest   ]) :|: 
    public void testPermissionGrant() throws Exception {
        super.testPermissionGrant();
    }

    @Override
    @PermissionsTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/MixedManagedProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.MixedManagedProfileOwnerTest"	"testPermissionMixedPolicies"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([2:/com/android/cts/devicepolicy/MixedManagedProfileOwnerTest.java]:[permission]:[2]:method_text:[ows Exception {        super.testPermissionMixedPolicies();    }    @FlakyTest    @Override   ]) :|: 
    public void testPermissionMixedPolicies() throws Exception {
        super.testPermissionMixedPolicies();
    }

    @FlakyTest
    @Override"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/MixedManagedProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.MixedManagedProfileOwnerTest"	"testScreenCaptureDisabled_assist"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([1:/com/android/cts/devicepolicy/MixedManagedProfileOwnerTest.java]:[permission]:[1]:method_text:[on {        super.testScreenCaptureDisabled_assist();    }    @Override    @PermissionsTest   ]) :|: 
    public void testScreenCaptureDisabled_assist() throws Exception {
        super.testScreenCaptureDisabled_assist();
    }

    @Override
    @PermissionsTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/MixedManagedProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.MixedManagedProfileOwnerTest"	"testPermissionPolicy"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([2:/com/android/cts/devicepolicy/MixedManagedProfileOwnerTest.java]:[permission]:[2]:method_text:[y() throws Exception {        super.testPermissionPolicy();    }    @FlakyTest    @Override   ]) :|: 
    public void testPermissionPolicy() throws Exception {
        super.testPermissionPolicy();
    }

    @FlakyTest
    @Override"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/MixedManagedProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.MixedManagedProfileOwnerTest"	"testSetMeteredDataDisabledPackages"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([1:/com/android/cts/devicepolicy/MixedManagedProfileOwnerTest.java]:[permission]:[1]:method_text:[ {        super.testSetMeteredDataDisabledPackages();    }    @Override    @PermissionsTest   ]) :|: 
    public void testSetMeteredDataDisabledPackages() throws Exception {
        super.testSetMeteredDataDisabledPackages();
    }

    @Override
    @PermissionsTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/MixedManagedProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.MixedManagedProfileOwnerTest"	"testPermissionAppUpdate"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([3:/com/android/cts/devicepolicy/MixedManagedProfileOwnerTest.java]:[permission]:[3]:method_text:[s Exception {        super.testPermissionAppUpdate();    }    @Override    @PermissionsTest   ]) :|: 
    public void testPermissionAppUpdate() throws Exception {
        super.testPermissionAppUpdate();
    }

    @Override
    @PermissionsTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/MixedManagedProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.MixedManagedProfileOwnerTest"	"testPermissionGrantPreMApp"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([3:/com/android/cts/devicepolicy/MixedManagedProfileOwnerTest.java]:[permission]:[3]:method_text:[xception {        super.testPermissionGrantPreMApp();    }    @Override    @PermissionsTest   ]) :|: 
    public void testPermissionGrantPreMApp() throws Exception {
        super.testPermissionGrantPreMApp();
    }

    @Override
    @PermissionsTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/MixedManagedProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.MixedManagedProfileOwnerTest"	"testPermissionGrantOfDisallowedPermissionWhileOtherPermIsGranted"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([4:/com/android/cts/devicepolicy/MixedManagedProfileOwnerTest.java]:[permission]:[4]:method_text:[ption {        super.testPermissionGrantOfDisallowedPermissionWhileOtherPermIsGranted();    }   ]) :|: 
    public void testPermissionGrantOfDisallowedPermissionWhileOtherPermIsGranted()
            throws Exception {
        super.testPermissionGrantOfDisallowedPermissionWhileOtherPermIsGranted();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/MixedManagedProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testApplicationRestrictions"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([3:/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java]:[permission]:[3]:method_text:[Delegations} to test that     *    the scope can only be delegatd to one app at a time.     */   ]) :|: 
    public void testApplicationRestrictions() throws Exception {
        installAppAsUser(DELEGATE_APP_APK, mUserId);
        installAppAsUser(APP_RESTRICTIONS_TARGET_APP_APK, mUserId);

        try {
            // Only the DPC can manage app restrictions by default.
            executeDeviceTestClass("".ApplicationRestrictionsTest"");
            executeAppRestrictionsManagingPackageTest(""testCannotAccessApis"");

            // Letting the DELEGATE_APP_PKG manage app restrictions too.
            changeApplicationRestrictionsManagingPackage(DELEGATE_APP_PKG);
            executeAppRestrictionsManagingPackageTest(""testCanAccessApis"");
            runDeviceTestsAsUser(DELEGATE_APP_PKG, "".GeneralDelegateTest"",
                    ""testSettingAdminComponentNameThrowsException"", mUserId);

            // The DPC should still be able to manage app restrictions normally.
            executeDeviceTestClass("".ApplicationRestrictionsTest"");

            // The app shouldn't be able to manage app restrictions for other users.
            int parentUserId = getPrimaryUser();
            if (parentUserId != mUserId) {
                installAppAsUser(DELEGATE_APP_APK, parentUserId);
                installAppAsUser(APP_RESTRICTIONS_TARGET_APP_APK, parentUserId);
                runDeviceTestsAsUser(DELEGATE_APP_PKG, "".AppRestrictionsDelegateTest"",
                        ""testCannotAccessApis"", parentUserId);
            }

            // Revoking the permission for DELEGAYE_APP_PKG to manage restrictions.
            changeApplicationRestrictionsManagingPackage(null);
            executeAppRestrictionsManagingPackageTest(""testCannotAccessApis"");

            // The DPC should still be able to manage app restrictions normally.
            executeDeviceTestClass("".ApplicationRestrictionsTest"");

            assertMetricsLogged(getDevice(), () -> {
                executeDeviceTestMethod("".ApplicationRestrictionsTest"",
                        ""testSetApplicationRestrictions"");"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testPermissionGrant"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([8:/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java]:[permission]:[8]:method_text:[ssionsTest"",                ""testPermissionGrantStateGranted_permissionRemainsGranted"");    }   ]) :|: 
    public void testPermissionGrant() throws Exception {
        installAppPermissionAppAsUser();
        executeDeviceTestMethod("".PermissionsTest"",
                ""testPermissionGrantStateDenied_permissionRemainsDenied"");
        executeDeviceTestMethod("".PermissionsTest"",
                ""testPermissionGrantStateGranted_permissionRemainsGranted"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testPermissionGrant_developmentPermission"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([6:/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java]:[permission]:[6]:method_text:[d(                "".PermissionsTest"", ""testPermissionGrantState_developmentPermission"");    }   ]) :|: 
    public void testPermissionGrant_developmentPermission() throws Exception {
        installAppPermissionAppAsUser();
        executeDeviceTestMethod(
                "".PermissionsTest"", ""testPermissionGrantState_developmentPermission"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testGrantOfSensorsRelatedPermissions"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([4:/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java]:[permission]:[4]:method_text:[cuteDeviceTestMethod("".PermissionsTest"", ""testSensorsRelatedPermissionsCannotBeGranted"");    }   ]) :|: 
    public void testGrantOfSensorsRelatedPermissions() throws Exception {
        installAppPermissionAppAsUser();
        executeDeviceTestMethod("".PermissionsTest"", ""testSensorsRelatedPermissionsCannotBeGranted"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testDenyOfSensorsRelatedPermissions"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([4:/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java]:[permission]:[4]:method_text:[ executeDeviceTestMethod("".PermissionsTest"", ""testSensorsRelatedPermissionsCanBeDenied"");    }   ]) :|: 
    public void testDenyOfSensorsRelatedPermissions() throws Exception {
        installAppPermissionAppAsUser();
        executeDeviceTestMethod("".PermissionsTest"", ""testSensorsRelatedPermissionsCanBeDenied"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testSensorsRelatedPermissionsNotGrantedViaPolicy"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([4:/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java]:[permission]:[4]:method_text:[("".PermissionsTest"",                ""testSensorsRelatedPermissionsNotGrantedViaPolicy"");    }   ]) :|: 
    public void testSensorsRelatedPermissionsNotGrantedViaPolicy() throws Exception {
        installAppPermissionAppAsUser();
        executeDeviceTestMethod("".PermissionsTest"",
                ""testSensorsRelatedPermissionsNotGrantedViaPolicy"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testStateOfSensorsRelatedPermissionsCannotBeRead"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([4:/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java]:[permission]:[4]:method_text:[YSTEM, because     * network rules for this user will affect UID 0.     */    @RequiresDevice   ]) :|: 
    public void testStateOfSensorsRelatedPermissionsCannotBeRead() throws Exception {
        installAppPermissionAppAsUser();
        executeDeviceTestMethod("".PermissionsTest"",
                ""testStateOfSensorsRelatedPermissionsCannotBeRead"");
    }

    /**
     * Require a device for tests that use the network stack. Headless Androids running in
     * data centres might need their network rules un-tampered-with in order to keep the ADB / VNC
     * connection alive.
     *
     * This is only a problem on device owner / profile owner running on USER_SYSTEM, because
     * network rules for this user will affect UID 0.
     */
    @RequiresDevice"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testPermissionPolicy"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([8:/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java]:[permission]:[8]:method_text:[od("".PermissionsTest"",                ""testPermissionPolicyAutoGrant_permissionLocked"");    }   ]) :|: 
    public void testPermissionPolicy() throws Exception {
        installAppPermissionAppAsUser();
        executeDeviceTestMethod("".PermissionsTest"",
                ""testPermissionPolicyAutoDeny_permissionLocked"");
        executeDeviceTestMethod("".PermissionsTest"",
                ""testPermissionPolicyAutoGrant_permissionLocked"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testAutoGrantMultiplePermissionsInGroup"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([5:/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java]:[permission]:[5]:method_text:[ssionsTest"",                ""testPermissionPolicyAutoGrant_multiplePermissionsInGroup"");    }   ]) :|: 
    public void testAutoGrantMultiplePermissionsInGroup() throws Exception {
        installAppPermissionAppAsUser();
        executeDeviceTestMethod("".PermissionsTest"",
                ""testPermissionPolicyAutoGrant_multiplePermissionsInGroup"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testPermissionMixedPolicies"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([6:/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java]:[permission]:[6]:method_text:[hod("".PermissionsTest"",                ""testPermissionGrantStateGranted_mixedPolicies"");    }   ]) :|: 
    public void testPermissionMixedPolicies() throws Exception {
        installAppPermissionAppAsUser();
        executeDeviceTestMethod("".PermissionsTest"",
                ""testPermissionGrantStateDenied_mixedPolicies"");
        executeDeviceTestMethod("".PermissionsTest"",
                ""testPermissionGrantStateGranted_mixedPolicies"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testPermissionGrantOfDisallowedPermissionWhileOtherPermIsGranted"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([6:/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java]:[permission]:[6]:method_text:[issionsTest"",                ""testPermissionGrantStateDenied_otherPermissionIsGranted"");    }   ]) :|: 
    public void testPermissionGrantOfDisallowedPermissionWhileOtherPermIsGranted()
            throws Exception {
        installAppPermissionAppAsUser();
        executeDeviceTestMethod("".PermissionsTest"",
                ""testPermissionGrantStateDenied_otherPermissionIsGranted"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testPermissionPrompts"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([4:/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java]:[permission]:[4]:method_text:[ppAsUser();        executeDeviceTestMethod("".PermissionsTest"", ""testPermissionPrompts"");    }   ]) :|: 
    @FlakyTest(bugId = 187862351)
    public void testPermissionPrompts() throws Exception {
        installAppPermissionAppAsUser();
        executeDeviceTestMethod("".PermissionsTest"", ""testPermissionPrompts"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testPermissionAppUpdate"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([28:/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java]:[permission]:[28]:method_text:[sUser();        executeDeviceTestMethod("".PermissionsTest"", ""testCanRequestPermission"");    }   ]) :|: 
    public void testPermissionAppUpdate() throws Exception {
        installAppPermissionAppAsUser();
        executeDeviceTestMethod("".PermissionsTest"", ""testPermissionGrantStateDenied"");
        installAppPermissionAppAsUser();
        executeDeviceTestMethod("".PermissionsTest"", ""testCannotRequestPermission"");

        assertNull(getDevice().uninstallPackage(PERMISSIONS_APP_PKG));
        installAppPermissionAppAsUser();
        executeDeviceTestMethod("".PermissionsTest"", ""testPermissionGrantStateGranted"");
        installAppPermissionAppAsUser();
        executeDeviceTestMethod("".PermissionsTest"", ""testCanRequestPermission"");

        assertNull(getDevice().uninstallPackage(PERMISSIONS_APP_PKG));
        installAppPermissionAppAsUser();
        executeDeviceTestMethod("".PermissionsTest"", ""testPermissionPolicyAutoDeny"");
        installAppPermissionAppAsUser();
        executeDeviceTestMethod("".PermissionsTest"", ""testCannotRequestPermission"");

        assertNull(getDevice().uninstallPackage(PERMISSIONS_APP_PKG));
        installAppPermissionAppAsUser();
        executeDeviceTestMethod("".PermissionsTest"", ""testPermissionPolicyAutoGrant"");
        installAppPermissionAppAsUser();
        executeDeviceTestMethod("".PermissionsTest"", ""testCanRequestPermission"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testPermissionGrantPreMApp"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([3:/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java]:[permission]:[3]:method_text:[        executeDeviceTestMethod("".PermissionsTest"", ""testPermissionGrantState_preMApp"");    }   ]) :|: 
    public void testPermissionGrantPreMApp() throws Exception {
        installAppAsUser(SIMPLE_PRE_M_APP_APK, mUserId);
        executeDeviceTestMethod("".PermissionsTest"", ""testPermissionGrantState_preMApp"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testApplicationHidden"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([4:/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java]:[permission]:[4]:method_text:[ngs(PERMISSIONS_APP_PKG, ""not_hidden"", NOT_CALLED_FROM_PARENT)                .build());    }   ]) :|: 
    public void testApplicationHidden() throws Exception {
        installAppPermissionAppAsUser();
        executeDeviceTestClass("".ApplicationHiddenTest"");
        installAppAsUser(PERMISSIONS_APP_APK, mUserId);
        assertMetricsLogged(getDevice(), () -> {
            executeDeviceTestMethod("".ApplicationHiddenTest"",""testSetApplicationHidden"");
        }, new DevicePolicyEventWrapper.Builder(EventId.SET_APPLICATION_HIDDEN_VALUE)
                .setAdminPackageName(DEVICE_ADMIN_PKG)
                .setBoolean(false)
                .setStrings(PERMISSIONS_APP_PKG, ""hidden"", NOT_CALLED_FROM_PARENT)
                .build(),
        new DevicePolicyEventWrapper.Builder(EventId.SET_APPLICATION_HIDDEN_VALUE)
                .setAdminPackageName(DEVICE_ADMIN_PKG)
                .setBoolean(false)
                .setStrings(PERMISSIONS_APP_PKG, ""not_hidden"", NOT_CALLED_FROM_PARENT)
                .build());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testSetPermissionPolicyLogged"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([8:/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java]:[permission]:[8]:method_text:[t(PERMISSION_POLICY_PROMPT)                .setBoolean(false)                .build());    }   ]) :|: 
    public void testSetPermissionPolicyLogged() throws Exception {
        assertMetricsLogged(getDevice(), () -> {
            executeDeviceTestMethod(
                    "".DevicePolicyLoggingTest"", ""testSetPermissionPolicyLogged"");
        }, new DevicePolicyEventWrapper.Builder(EventId.SET_PERMISSION_POLICY_VALUE)
                .setAdminPackageName(DEVICE_ADMIN_PKG)
                .setInt(PERMISSION_POLICY_AUTO_DENY)
                .setBoolean(false)
                .build(),
        new DevicePolicyEventWrapper.Builder(EventId.SET_PERMISSION_POLICY_VALUE)
                .setAdminPackageName(DEVICE_ADMIN_PKG)
                .setInt(PERMISSION_POLICY_AUTO_GRANT)
                .setBoolean(false)
                .build(),
        new DevicePolicyEventWrapper.Builder(EventId.SET_PERMISSION_POLICY_VALUE)
                .setAdminPackageName(DEVICE_ADMIN_PKG)
                .setInt(PERMISSION_POLICY_PROMPT)
                .setBoolean(false)
                .build());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testSetPermissionGrantStateLogged"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([12:/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java]:[permission]:[12]:method_text:[           .setStrings(""android.permission.READ_CONTACTS"")                    .build());    }   ]) :|: 
    public void testSetPermissionGrantStateLogged() throws Exception {
        installAppPermissionAppAsUser();
        assertMetricsLogged(getDevice(), () -> {
            executeDeviceTestMethod(
                    "".DevicePolicyLoggingTest"", ""testSetPermissionGrantStateLogged"");
        }, new DevicePolicyEventWrapper.Builder(EventId.SET_PERMISSION_GRANT_STATE_VALUE)
                    .setAdminPackageName(DEVICE_ADMIN_PKG)
                    .setInt(PERMISSION_GRANT_STATE_GRANTED)
                    .setBoolean(false)
                    .setStrings(""android.permission.READ_CONTACTS"")
                    .build(),
            new DevicePolicyEventWrapper.Builder(EventId.SET_PERMISSION_GRANT_STATE_VALUE)
                    .setAdminPackageName(DEVICE_ADMIN_PKG)
                    .setInt(PERMISSION_GRANT_STATE_DENIED)
                    .setBoolean(false)
                    .setStrings(""android.permission.READ_CONTACTS"")
                    .build(),
            new DevicePolicyEventWrapper.Builder(EventId.SET_PERMISSION_GRANT_STATE_VALUE)
                    .setAdminPackageName(DEVICE_ADMIN_PKG)
                    .setInt(PERMISSION_GRANT_STATE_DEFAULT)
                    .setBoolean(false)
                    .setStrings(""android.permission.READ_CONTACTS"")
                    .build());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testSetUninstallBlockedLogged"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([2:/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java]:[permission]:[2]:method_text:[oolean(false)                .setStrings(PERMISSIONS_APP_PKG)                .build());    }   ]) :|: 
    public void testSetUninstallBlockedLogged() throws Exception {
        installAppAsUser(PERMISSIONS_APP_APK, mUserId);
        assertMetricsLogged(getDevice(), () -> {
            executeDeviceTestMethod("".DevicePolicyLoggingTest"",
                    ""testSetUninstallBlockedLogged"");
        }, new DevicePolicyEventWrapper.Builder(EventId.SET_UNINSTALL_BLOCKED_VALUE)
                .setAdminPackageName(DEVICE_ADMIN_PKG)
                .setBoolean(false)
                .setStrings(PERMISSIONS_APP_PKG)
                .build());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testAdminControlOverSensorPermissionGrantsDefault"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([4:/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java]:[permission]:[4]:method_text:[d("".SensorPermissionGrantTest"",                ""testAdminCannotGrantSensorsPermission"");    }   ]) :|: 
    public void testAdminControlOverSensorPermissionGrantsDefault() throws Exception {
        // By default, admin should not be able to grant sensors-related permissions.
        executeDeviceTestMethod("".SensorPermissionGrantTest"",
                ""testAdminCannotGrantSensorsPermission"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.DeviceAndProfileOwnerTest"	"testSetNearbyAppStreamingPolicy_changesPolicy"	"CtsDevicePolicyManagerTestCases"	"1: permission"	"([3:/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java]:[permission]:[3]:method_text:[and(                restricted ? RESTRICT_BACKGROUND_ON_CMD : RESTRICT_BACKGROUND_OFF_CMD);    }}]) :|: 
    public void testSetNearbyAppStreamingPolicy_changesPolicy() throws Exception {
        executeDeviceTestMethod(
                "".NearbyAppStreamingPolicyTest"", ""testSetNearbyAppStreamingPolicy_changesPolicy"");
    }

    /**
     * Executes a test class on device. Prior to running, turn off background data usage
     * restrictions, and restore the original restrictions after the test.
     */
    private void executeDeviceTestClassNoRestrictBackground(String className) throws Exception {
        boolean originalRestriction = ensureRestrictBackgroundPolicyOff();
        try {
            executeDeviceTestClass(className);
        } catch (Exception e) {
            throw e;
        } finally {
            // if the test throws exception, still restore the policy
            restoreRestrictBackgroundPolicyTo(originalRestriction);
        }
    }

    protected void executeDeviceTestClass(String className) throws Exception {
        executeDeviceTestMethod(className, /* testName= */ null);
    }

    protected void executeDeviceTestMethod(String className, String testName) throws Exception {
        executeDeviceTestMethod(className, testName, /* params= */ new HashMap<>());
    }

    protected void executeDeviceTestMethod(String className, String testName,
            Map<String, String> params) throws Exception {
        executeDeviceTestMethod(className, testName, mUserId, params);
    }

    protected void executeDeviceTestMethod(String className, String testName, int userId,
            Map<String, String> params) throws Exception {
        runDeviceTestsAsUser(DEVICE_ADMIN_PKG, className, testName, userId, params);
    }

    protected void installAppPermissionAppAsUser()
            throws FileNotFoundException, DeviceNotAvailableException {
        installAppAsUser(PERMISSIONS_APP_APK, false, mUserId);
    }

    private void executeSuspendPackageTestMethod(String testName) throws Exception {
        runDeviceTestsAsUser(INTENT_SENDER_PKG, "".SuspendPack"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/DeviceAndProfileOwnerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.MixedManagedProfileOwnerTestApi30"	"removeTestUsers"	"CtsDevicePolicyManagerTestCases"	"1: managed_users"	"([2:/com/android/cts/devicepolicy/MixedManagedProfileOwnerTestApi30.java]:[managed_users]:[2]:method_text:[oid tearDown() throws Exception {        removeUser(mUserId);        super.tearDown();    }   ]) :|: /*
 *.
 */

package com.android.cts.devicepolicy;

import static com.android.cts.devicepolicy.DeviceAdminFeaturesCheckerRule.FEATURE_MANAGED_USERS;

import com.android.cts.devicepolicy.DeviceAdminFeaturesCheckerRule.RequiresAdditionalFeatures;

import org.junit.Test;

/**
 * Set of tests for managed profile owner use cases that may also apply to device owner.
 * Tests that should be run identically in both cases are added in DeviceAndProfileOwnerTestApi30.
 */
// We need managed users to be supported in order to create a profile of the user owner.
@RequiresAdditionalFeatures({FEATURE_MANAGED_USERS})
public class MixedManagedProfileOwnerTestApi30 extends DeviceAndProfileOwnerTestApi30 {
    private int mParentUserId = -1;

    @Override
    public void setUp() throws Exception {
        super.setUp();

        removeTestUsers();
        mParentUserId = mPrimaryUserId;
        createManagedProfile();
    }

    private void createManagedProfile() throws Exception {
        mUserId = createManagedProfile(mParentUserId);
        switchUser(mParentUserId);
        startUserAndWait(mUserId);

        installAppAsUser(DEVICE_ADMIN_APK, mUserId);
        setProfileOwnerOrFail(DEVICE_ADMIN_PKG + ""/"" + ADMIN_RECEIVER_TEST_CLASS, mUserId);
        startUserAndWait(mUserId);
    }

    @Override
    public void tearDown() throws Exception {
        removeUser(mUserId);

        super.tearDown();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/MixedManagedProfileOwnerTestApi30.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.separateprofilechallenge.SeparateProfileChallengePermissionsTest"	"testSeparateProfileChallengePermissions"	""	"1: permission"	"([1:/com/android/cts/separateprofilechallenge/SeparateProfileChallengePermissionsTest.java]:[permission]:[1]:method_text:[t!        } catch (NoSuchMethodError err) {            // API unavailable - pass        }    }}]) :|: public void testSeparateProfileChallengePermissions() throws Exception {
        DevicePolicyManager dpm = (DevicePolicyManager)
                mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);
        assertNotNull(dpm);
        try {
            dpm.isSeparateProfileChallengeAllowed(0); /* Try to use USER_SYSTEM */
            fail(""The user must be system to call isSeparateProfileChallengeAllowed()."");
        } catch (SecurityException ignore) {
            // That's what we want!
        } catch (NoSuchMethodError err) {
            // API unavailable - pass
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/SeparateProfileChallenge/src/com/android/cts/separateprofilechallenge/SeparateProfileChallengePermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.launchertests.LauncherAppsTests"	"testGetSetSyntheticAppDetailsActivityEnabled"	""	"1: permission"	"([4:/com/android/cts/launchertests/LauncherAppsTests.java]:[permission]:[4]:method_text:[            mInstrumentation.getUiAutomation().dropShellPermissionIdentity();        }    }   ]) :|: 
    public void testGetSetSyntheticAppDetailsActivityEnabled() throws Exception {
        assumeNotHeadlessSystemUserMode();

        disableLauncherActivity();
        assertActivityInjected(HAS_LAUNCHER_ACTIVITY_APP_PACKAGE);
        PackageManager pm = mContext.getPackageManager();
        try {
            pm.setSyntheticAppDetailsActivityEnabled(mContext.getPackageName(), false);
            fail(""Should not able to change current app's app details activity state"");
        } catch (SecurityException e) {
            // Expected: No permission
        }
        try {
            pm.setSyntheticAppDetailsActivityEnabled(HAS_LAUNCHER_ACTIVITY_APP_PACKAGE, false);
            fail(""Should not able to change other app's app details activity state"");
        } catch (SecurityException e) {
            // Expected: No permission
        }
        mInstrumentation.getUiAutomation().adoptShellPermissionIdentity();
        try {
            assertThat(pm.getSyntheticAppDetailsActivityEnabled(HAS_LAUNCHER_ACTIVITY_APP_PACKAGE))
                    .isTrue();
            // Disable app details activity and assert if the change is applied
            pm.setSyntheticAppDetailsActivityEnabled(HAS_LAUNCHER_ACTIVITY_APP_PACKAGE, false);
            assertThat(pm.getSyntheticAppDetailsActivityEnabled(HAS_LAUNCHER_ACTIVITY_APP_PACKAGE))
                    .isFalse();
            assertInjectedActivityNotFound(HAS_LAUNCHER_ACTIVITY_APP_PACKAGE);
            // Enable app details activity and assert if the change is applied
            pm.setSyntheticAppDetailsActivityEnabled(HAS_LAUNCHER_ACTIVITY_APP_PACKAGE, true);
            assertThat(pm.getSyntheticAppDetailsActivityEnabled(HAS_LAUNCHER_ACTIVITY_APP_PACKAGE))
                    .isTrue();
            assertActivityInjected(HAS_LAUNCHER_ACTIVITY_APP_PACKAGE);
        } finally {
            mInstrumentation.getUiAutomation().dropShellPermissionIdentity();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/LauncherTests/src/com/android/cts/launchertests/LauncherAppsTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.launchertests.LauncherAppsTests"	"testNoPermissionAppNotInjected"	""	"1: permission"	"([3:/com/android/cts/launchertests/LauncherAppsTests.java]:[permission]:[3]:method_text:[t on the activity list        assertInjectedActivityNotFound(NO_PERMISSION_APP_PACKAGE);    }   ]) :|: 
    public void testNoPermissionAppNotInjected() throws Exception {
        // NoPermissionApp is installed for duration of this test - make sure
        // it's NOT present on the activity list
        assertInjectedActivityNotFound(NO_PERMISSION_APP_PACKAGE);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/LauncherTests/src/com/android/cts/launchertests/LauncherAppsTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.intent.sender.ContentTest"	"finish"	""	"1: permission"	"([2:/com/android/cts/intent/sender/ContentTest.java]:[permission]:[2]:method_text:[ * The receiver will read the message from the uri, and put it inside the result intent.     */   ]) :|: public void test/*
 *.
 */

package com.android.cts.intent.sender;

import android.content.ClipData;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.database.ContentObserver;
import android.net.Uri;
import android.os.Handler;
import android.os.HandlerThread;
import androidx.core.content.FileProvider;
import android.test.InstrumentationTestCase;
import android.util.Log;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.TimeUnit;

public class ContentTest extends InstrumentationTestCase {

    private static final String MESSAGE = ""Sample Message"";

    private static final String ACTION_READ_FROM_URI = ""com.android.cts.action.READ_FROM_URI"";

    private static final String ACTION_WRITE_TO_URI = ""com.android.cts.action.WRITE_TO_URI"";

    private static final String ACTION_TAKE_PERSISTABLE_URI_PERMISSION =
            ""com.android.cts.action.TAKE_PERSISTABLE_URI_PERMISSION"";

    public static final String ACTION_NOTIFY_URI_CHANGE
            = ""com.android.cts.action.NOTIFY_URI_CHANGE"";

    public static final String ACTION_OBSERVE_URI_CHANGE
            = ""com.android.cts.action.OBSERVE_URI_CHANGE"";

    private static final String TAG = ""CrossProfileContentTest"";

    private Context mContext;
    private IntentSenderActivity mActivity;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mContext = getInstrumentation().getTargetContext();
        mActivity = launchActivity(mContext.getPackageName(), IntentSenderActivity.class, null);
    }

    @Override
    public void tearDown() throws Exception {
        mActivity.finish();
        super.tearDown();
    }

    /**
     * This method will send an intent to a rec"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/IntentSender/src/com/android/cts/intent/sender/ContentTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.intent.sender.ContentTest"	"testReceiverCanRead"	""	"1: permission"	"([1:/com/android/cts/intent/sender/ContentTest.java]:[permission]:[1]:method_text:[er will read the message from the extra, and write it to the uri in     * the ClipData.     */   ]) :|: public void testReceiverCanRead() throws Exception {
        Uri uri = getUriWithTextInFile(""reading_test"", MESSAGE);
        assertNotNull(uri);
        Intent intent = new Intent(ACTION_READ_FROM_URI);
        intent.setClipData(ClipData.newRawUri("""", uri));
        intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);

        final Intent result = mActivity.getCrossProfileResult(intent);
        assertNotNull(result);
        assertEquals(MESSAGE, result.getStringExtra(""extra_response""));
    }

    /**
     * This method will send an intent to a receiver in another profile.
     * This intent will have a message in an extra, and a uri specified by the ClipData.
     * The receiver will read the message from the extra, and write it to the uri in
     * the ClipData.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/IntentSender/src/com/android/cts/intent/sender/ContentTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.intent.sender.ContentTest"	"testReceiverCanWrite"	""	"1: permission"	"([2:/com/android/cts/intent/sender/ContentTest.java]:[permission]:[2]:method_text:[y.getCrossProfileResult(intent);        assertEquals(MESSAGE, getFirstLineFromUri(uri));    }   ]) :|: public void testReceiverCanWrite() throws Exception {
        // It's the receiver of the intent that should write to the uri, not us. So, for now, we
        // write an empty string.
        Uri uri = getUriWithTextInFile(""writing_test"", """");
        assertTrue(uri != null);
        Intent intent = new Intent(ACTION_WRITE_TO_URI);
        intent.setClipData(ClipData.newRawUri("""", uri));
        intent.putExtra(""extra_message"", MESSAGE);
        intent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION
                | Intent.FLAG_GRANT_READ_URI_PERMISSION);

        mActivity.getCrossProfileResult(intent);
        assertEquals(MESSAGE, getFirstLineFromUri(uri));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/IntentSender/src/com/android/cts/intent/sender/ContentTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.intent.sender.ContentTest"	"testPersistablePermission"	""	"1: permission"	"([7:/com/android/cts/intent/sender/ContentTest.java]:[permission]:[7]:method_text:[ri of a     * ContentProvider, it still cannot access a uri it does not have access to.     */   ]) :|: public void testPersistablePermission() throws Exception {
        Uri uri = getUriWithTextInFile(""persistable_test"", MESSAGE);
        grantPersistableReadPermission(uri);

        // Now checking if the receiver can read this uri, without re-granting the read permission.
        Intent intent = new Intent(ACTION_READ_FROM_URI);
        intent.setClipData(ClipData.newRawUri("""", uri));

        final Intent result = mActivity.getCrossProfileResult(intent);
        assertNotNull(result);
        assertEquals(MESSAGE, result.getStringExtra(""extra_response""));
    }

    /**
     * The intent receiver will try to read uriNotGranted.
     * Inside the same user, this uri can be read if the receiver has the
     * com.android.cts.managedprofile.permission.SAMPLE permission. But since we cross
     * user-boundaries, it should not be able to (only uri grants work accross users for apps
     * without special permission).
     * We also grant uriGranted to the receiver (this uri belongs to the same content provider as
     * uriNotGranted), to enforce that even if an app has permission to one uri of a
     * ContentProvider, it still cannot access a uri it does not have access to.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/IntentSender/src/com/android/cts/intent/sender/ContentTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.intent.sender.ContentTest"	"testAppPermissionsDontWorkAcrossProfiles"	""	"1: permission"	"([6:/com/android/cts/intent/sender/ContentTest.java]:[permission]:[6]:method_text:[       }    }    /**     * Test that an app can notify a uri change across profiles.     */   ]) :|: public void testAppPermissionsDontWorkAcrossProfiles() throws Exception {
        // The FileProvider does not allow to use app permissions. So we need to use another
        // ContentProvider.
        Uri uriGranted = getBasicContentProviderUri(""uri_granted"");
        Uri uriNotGranted = getBasicContentProviderUri(""uri_not_granted"");

        // Granting uriGranted to the receiver
        // Using a persistable permission so that it is kept even after we restart the receiver
        // activity with another intent.
        grantPersistableReadPermission(uriGranted);

        Intent notGrant = new Intent(ACTION_READ_FROM_URI);
        notGrant.setClipData(ClipData.newRawUri("""", uriNotGranted));

        final Intent result = mActivity.getCrossProfileResult(notGrant);
        assertNotNull(result);
        // The receiver did not have permission to read the uri. So it should have caught a security
        // exception.
        assertTrue(result.getBooleanExtra(""extra_caught_security_exception"", false));
    }

    /**
     * Ensure that sender is only able to send data that it has access to.
     */
    // STOPSHIP: enable once b/115619667 is fixed
    public void _testSecurity() throws Exception {
        // Pick a URI that neither of us have access to; it doens't matter if
        // its missing, since we expect a SE before a FNFE.
        final Uri uri = Uri.parse(""content://media/external/images/media/10240"");
        final Intent intent = new Intent(ACTION_READ_FROM_URI);
        intent.setClipData(ClipData.newRawUri("""", uri));
        intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);

        // We're expecting to run into a security exception
        final Intent result = mActivity.getCrossProfileResult(intent);
        if (result == null) {
            // This is fine; probably of a SecurityException when off in the
            // system somewhere.
        } else {
            // But if we somehow came through, make sure they threw.
            assertT"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/IntentSender/src/com/android/cts/intent/sender/ContentTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.intent.sender.ContentTest"	"testCanNotifyAcrossProfiles"	""	"1: permission"	"([2:/com/android/cts/intent/sender/ContentTest.java]:[permission]:[2]:method_text:[      }    }    /**     * Test that an app can observe a uri change across profiles.     */   ]) :|: public void testCanNotifyAcrossProfiles() throws Exception {
        Uri uri = getUriWithTextInFile(""notifying_test"", """");
        assertNotNull(uri);
        Intent intent = new Intent(ACTION_NOTIFY_URI_CHANGE);
        intent.setClipData(ClipData.newRawUri("""", uri));
        intent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION
                | Intent.FLAG_GRANT_READ_URI_PERMISSION);
        HandlerThread handlerThread = new HandlerThread(""observer"");
        handlerThread.start();
        UriObserver uriObserver = new UriObserver(new Handler(handlerThread.getLooper()));
        try {
            mContext.getContentResolver().registerContentObserver(uri, false, uriObserver);
            // ask the cross-profile receiver to notify the uri
            mActivity.getCrossProfileResult(intent);
            assertEquals(uri, uriObserver.waitForNotify());
        } finally {
            mContext.getContentResolver().unregisterContentObserver(uriObserver);
            handlerThread.quit();
        }
    }

    /**
     * Test that an app can observe a uri change across profiles.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/IntentSender/src/com/android/cts/intent/sender/ContentTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.intent.sender.ContentTest"	"testCanObserveAcrossProfiles"	""	"1: permission"	"([5:/com/android/cts/intent/sender/ContentTest.java]:[permission]:[5]:method_text:[            Log.e(TAG, ""could not read the uri "" + uri);            return null;        }    }}]) :|: public void testCanObserveAcrossProfiles() throws Exception {
        final Uri uri = getUriWithTextInFile(""observing_test"", """");
        assertNotNull(uri);
        Intent intent = new Intent(ACTION_OBSERVE_URI_CHANGE);
        intent.setClipData(ClipData.newRawUri("""", uri));
        intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);

        Timer timer = new Timer();
        timer.schedule(new TimerTask() {
            @Override
            public void run() {
                mContext.getContentResolver().notifyChange(uri, null);
            }
        }, 5000 /* 5 seconds */);

        // Check that the app in the other profile could be notified of the change.
        // A non-null result intent indicates success.
        assertNotNull(mActivity.getCrossProfileResult(intent));
    }

    private class UriObserver extends ContentObserver {
        private final SynchronousQueue<Uri> mSynchronousQueue;

        public UriObserver(Handler handler) {
           super(handler);
           mSynchronousQueue = new SynchronousQueue<Uri>();
        }

        @Override
        public void onChange(boolean selfChange, Uri uri) {
            super.onChange(selfChange, uri);
            try {
                if (!mSynchronousQueue.offer(uri, 5, TimeUnit.SECONDS)) {
                    Log.e(TAG, ""Failed to offer uri "" + uri + "" to synchronous queue"");
                }
            } catch (InterruptedException e) {
                Log.e(TAG, ""Interrupted while receiving onChange for "" + uri, e);
            }
        }

        private Uri waitForNotify() throws InterruptedException {
            // The uri notification may not come immediately.
            return mSynchronousQueue.poll(30, TimeUnit.SECONDS);
        }
    }

    private void grantPersistableReadPermission(Uri uri) throws Exception {
        Intent grantPersistable = new Intent(ACTION_TAKE_PERSISTABLE_URI_PERMISSION);
        grantPersistable.setClipData(ClipData.newRawUri("""", uri));
        grantPersis"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/IntentSender/src/com/android/cts/intent/sender/ContentTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.intent.sender.SuspendPackageTest"	"testPackageSuspendedWithPackageManager"	""	"1: permission"	"([3:/com/android/cts/intent/sender/SuspendPackageTest.java]:[permission]:[3]:method_text:[s(settingsPackageName + "":id/admin_support_icon"")                .pkg(settingsPackageName);    }}]) :|: public void testPackageSuspendedWithPackageManager() throws Exception {
        assertPackageSuspended(/* suspended= */ true, /* customDialog= */ true);
    }

    /**
     * Verify that the package is suspended by trying to start the activity inside it. If the
     * package is not suspended, the target activity will return the result.
     */
    private void assertPackageSuspended(boolean suspended, boolean customDialog) throws Exception {
        Intent intent = new Intent();
        intent.setClassName(INTENT_RECEIVER_PKG, TARGET_ACTIVITY_NAME);
        if (!temporarilySkipActivityLaunch()) {
            Intent result = mActivity.getResult(intent);
            Log.d(TAG, ""assertPackageSuspended(suspended="" + suspended
                    + "", customDialog="" + customDialog + ""): result for activity ""
                    + INTENT_RECEIVER_PKG + ""/"" + TARGET_ACTIVITY_NAME + "" on user ""
                    + mContext.getUserId() + "": "" + result);
            if (suspended) {
                if (customDialog) {
                    dismissCustomDialog();
                } else {
                    dismissPolicyTransparencyDialog();
                }
                assertWithMessage(""result for activitiy %s while suspended"", intent).that(result)
                        .isNull();
            } else {
                assertWithMessage(""result for activitiy %s while NOT suspended"", intent)
                        .that(result).isNotNull();
            }
        }
        // No matter if it is suspended or not, we should be able to resolve the activity.
        ResolveInfo resolveInfo = mPackageManager.resolveActivity(intent, /* flags= */ 0);
        assertWithMessage(""ResolveInfo for activity %s"", intent).that(resolveInfo).isNotNull();
        Log.d(TAG, ""ResolveInfo: "" + resolveInfo);
    }

    /**
     * Wait for the policy transparency dialog and dismiss it.
     */
    private void dismissPolicyTransparencyDialog() {
        final UiDevice device = UiDevice.getIn"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/IntentSender/src/com/android/cts/intent/sender/SuspendPackageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceowner.CreateAndManageUserTest"	"testCreateAndManageUser_LeaveAllSystemApps"	""	"1: permission"	"([1:/com/android/cts/deviceowner/CreateAndManageUserTest.java]:[permission]:[1]:method_text:[serHandle;    }    // createAndManageUser should circumvent the DISALLOW_ADD_USER restriction   ]) :|: public void testCreateAndManageUser_LeaveAllSystemApps() throws Exception {
        int currentUserId = ActivityManager.getCurrentUser();
        // TODO: instead of hard-coding the user type, calling getPreInstallableSystemPackages(),
        // and passing the packages to runCrossUserVerification() / assertAllSystemAppsInstalled(),
        // ideally the later should call um.getPreInstallableSystemPackages(um.getUsertype())
        // (where um is the UserManager with the context of the newly created user),
        // but currently the list of pre-installed apps is passed to the new user in the bundle.
        // Given that these tests will be refactored anyways, it's not worth to try to change it.
        String newUserType = UserManager.USER_TYPE_FULL_SECONDARY;
        Set<String> preInstalledSystemPackages = SystemUtil.callWithShellPermissionIdentity(
                () -> UserManager.get(mContext).getPreInstallableSystemPackages(newUserType));
        if (preInstalledSystemPackages != null) {
            Log.d(TAG, preInstalledSystemPackages.size() + "" pre-installed system apps for ""
                    + ""new user of type "" + newUserType + "": "" + preInstalledSystemPackages);
        } else {
            Log.d(TAG, ""no pre-installed system apps allowlist for new user of type"" + newUserType);
        }

        runCrossUserVerification(/* callback= */ null,
                DevicePolicyManager.LEAVE_ALL_SYSTEM_APPS_ENABLED, ""assertAllSystemAppsInstalled"",
                preInstalledSystemPackages);
        PrimaryUserService.assertCrossUserCallArrived();
    }

    private UserHandle runCrossUserVerification(int createAndManageUserFlags, String methodName)
            throws Exception {
        return runCrossUserVerification(/* callback= */ null, createAndManageUserFlags, methodName,
                /* currentUserPackages= */ null);
    }

    private UserHandle runCrossUserVerification(UserActionCallback callback,
            int createAndManageUserFlags, St"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/CreateAndManageUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceowner.HeadlessSystemUserTest"	"isHeadlessSystemUserMode"	""	"1: permission"	"([1:/com/android/cts/deviceowner/HeadlessSystemUserTest.java]:[permission]:[1]:method_text:[.getSystemService(UserManager.class);        Log.d(TAG, ""setUp(): userId="" + mUserId);    }   ]) :|: public void test/*
 *.
 */
package com.android.cts.deviceowner;

import static com.android.compatibility.common.util.SystemUtil.callWithShellPermissionIdentity;
import static com.android.compatibility.common.util.SystemUtil.eventually;

import static com.google.common.truth.Truth.assertWithMessage;

import android.annotation.UserIdInt;
import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.pm.UserInfo;
import android.os.UserHandle;
import android.os.UserManager;
import android.util.Log;

//TODO(b/174859111): move to automotive specific module
/**
 * Device owner tests specific for devices that use
 * {@link android.os.UserManager#isHeadlessSystemUserMode()}.
 */
public final class HeadlessSystemUserTest extends BaseDeviceOwnerTest {

    private static final String TAG = HeadlessSystemUserTest.class.getSimpleName();

    // To be used in cases where it needs to test the DPM of the current user (as
    // mDevicePolicyManager wraps calls to user 0's DeviceOwner DPM);
    private DevicePolicyManager mCurrentUserDpm;

    private UserManager mUserManager;

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        mCurrentUserDpm = mContext.getSystemService(DevicePolicyManager.class);
        mUserManager = mContext.getSystemService(UserManager.class);

        Log.d(TAG, ""setUp(): userId="" + mUserId);

    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/HeadlessSystemUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceowner.HeadlessSystemUserTest"	"testProfileOwnerIsSetOnNewUser"	""	"1: permission"	"([2:/com/android/cts/deviceowner/HeadlessSystemUserTest.java]:[permission]:[2]:method_text:[profile owner for user %s"", admin, userId)                .that(admin).isEqualTo(getWho());    }}]) :|: public void testProfileOwnerIsSetOnNewUser() throws Exception {
        UserInfo user = null;
        try {
            user = callWithShellPermissionIdentity(() -> mUserManager
                    .createUser(""testProfileOwnerIsSetOnNewUser"", /* flags= */ 0));
            assertWithMessage(""new user"").that(user).isNotNull();
            Log.d(TAG, ""Created user "" + user.toFullString());
            final int userId = user.id;

            // Must try a couple times as PO is asynchronously set after user is created.
            // TODO(b/178102911): use a callback instead
            Context newUserContext = mContext.createContextAsUser(UserHandle.of(userId),
                    /* flags=*/ 0);
            DevicePolicyManager newUserDpm = newUserContext
                    .getSystemService(DevicePolicyManager.class);
            eventually(() -> assertProfileOwner(newUserDpm.getProfileOwner(), userId));

        } finally {
            if (user != null) {
                final int userId = user.id;
                Log.d(TAG, ""Removing user "" + userId);
                boolean removed = callWithShellPermissionIdentity(
                        () -> mUserManager.removeUser(userId));
                assertWithMessage(""user %s removed"", userId).that(removed).isTrue();
            }
        }
    }

    private void assertProfileOwner(ComponentName admin, @UserIdInt int userId) {
        assertWithMessage(""Component %s is profile owner for user %s"", admin, userId)
                .that(admin).isEqualTo(getWho());
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/HeadlessSystemUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceowner.ListForegroundAffiliatedUsersTest"	"testListForegroundAffiliatedUsers_onlyForegroundUser"	""	"1: permission"	"([1:/com/android/cts/deviceowner/ListForegroundAffiliatedUsersTest.java]:[permission]:[1]:method_text:[        assertWithMessage(""foreground users"").that(users).containsExactly(currentUser);    }   ]) :|: public void testListForegroundAffiliatedUsers_onlyForegroundUser() throws Exception {
        List<UserHandle> users = mDevicePolicyManager.listForegroundAffiliatedUsers();

        UserHandle currentUser = invokeStaticMethodWithShellPermissions(() -> getCurrentUser());
        Log.d(TAG, ""currentUser: "" + currentUser + "" users: ""  + users);

        assertWithMessage(""foreground users"").that(users).containsExactly(currentUser);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/ListForegroundAffiliatedUsersTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceowner.WifiNetworkConfigurationWithoutFineLocationPermissionTest"	"isWifiEnabled"	""	"1: permission"	"([2:/com/android/cts/deviceowner/WifiNetworkConfigurationWithoutFineLocationPermissionTest.java]:[permission]:[2]:method_text:[WifiEnabled();            Log.d(TAG, ""Done: "" + mWifiManager.isWifiEnabled());        }    }   ]) :|: public void test/*
 *.
 */

package com.android.cts.deviceowner;

import static com.android.compatibility.common.util.WifiConfigCreator.SECURITY_TYPE_NONE;

import static com.google.common.truth.Truth.assertWithMessage;

import android.Manifest;
import android.content.pm.PackageManager;
import android.net.wifi.WifiConfiguration;
import android.os.SystemClock;
import android.util.Log;

import com.android.compatibility.common.util.SystemUtil;

import java.util.List;
import java.util.concurrent.TimeUnit;

public class WifiNetworkConfigurationWithoutFineLocationPermissionTest extends BaseDeviceOwnerTest {
    private static final String TAG = ""WifiNetworkConfigurationWithoutFineLocationPermissionTest"";

    // Unique SSID to use for this test (max SSID length is 32)
    private static final String NETWORK_SSID = ""com.android.cts.abcdefghijklmnop"";
    private static final int INVALID_NETWORK_ID = -1;

    // Time duration to allow before assuming that a WiFi operation failed and ceasing to wait.
    private static final long UPDATE_TIMEOUT_MS = TimeUnit.MINUTES.toMillis(5);
    private static final long UPDATE_INTERVAL_MS = TimeUnit.SECONDS.toMillis(1);

    @Override
    public void setUp() throws Exception {
        super.setUp();

        // WiFi is supposed to be a prerequisite of CTS but sometimes it's not enabled
        // for some unknown reason. Check it here just in case.
        if (!mWifiManager.isWifiEnabled()) {
            Log.d(TAG, ""Enabling wifi using shell"");
            SystemUtil.runShellCommand(""svc wifi enable"");
            awaitWifiEnabled();
            Log.d(TAG, ""Done: "" + mWifiManager.isWifiEnabled());
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/WifiNetworkConfigurationWithoutFineLocationPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceowner.WifiNetworkConfigurationWithoutFineLocationPermissionTest"	"testAddAndRetrieveCallerConfiguredNetworks"	""	"1: permission"	"([6:/com/android/cts/deviceowner/WifiNetworkConfigurationWithoutFineLocationPermissionTest.java]:[permission]:[6]:method_text:[           return;            }        }        fail(""Waited too long for wifi enabled"");    }}]) :|: public void testAddAndRetrieveCallerConfiguredNetworks() throws Exception {
        assertWithMessage(""wifi is enabled"").that(mWifiManager.isWifiEnabled()).isTrue();
        assertWithMessage(""permission status (denied=%s) for %s on user %s"",
                PackageManager.PERMISSION_DENIED, Manifest.permission.ACCESS_FINE_LOCATION, mUserId)
                        .that(mContext.checkSelfPermission(
                                        Manifest.permission.ACCESS_FINE_LOCATION))
                        .isEqualTo(PackageManager.PERMISSION_DENIED);

        int netId = mWifiConfigCreator.addNetwork(NETWORK_SSID, /* hidden */ false,
                SECURITY_TYPE_NONE, /* password */ null);
        assertWithMessage(""id of added network"").that(netId).isNotEqualTo(INVALID_NETWORK_ID);

        try {
            List<WifiConfiguration> configs = mWifiManager.getCallerConfiguredNetworks();
            assertWithMessage(""configured networks"").that(configs).isNotEmpty();
            assertWithMessage(""SSID of configured networks"").that(configs.get(0).SSID)
                    .isEqualTo('""' + NETWORK_SSID + '""');
        } finally {
            Log.d(TAG, ""Removing network "" + netId);
            mWifiManager.removeNetwork(netId);
        }
    }

    private void awaitWifiEnabled()  {
        for (int probes = 0; probes * UPDATE_INTERVAL_MS <= UPDATE_TIMEOUT_MS; probes++) {
            if (probes != 0) {
                SystemClock.sleep(UPDATE_INTERVAL_MS);
            }
            if (mWifiManager.isWifiEnabled()) {
                return;
            }
        }
        fail(""Waited too long for wifi enabled"");
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/WifiNetworkConfigurationWithoutFineLocationPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceowner.DeviceIdentifiersTest"	"testDeviceOwnerCanGetDeviceIdentifiersWithPermission"	""	"1: permission"	"([21:/com/android/cts/deviceowner/DeviceIdentifiersTest.java]:[permission]:[21]:method_text:[permission must be able to access ""                    + ""the device IDs: "" + e);        }    }}]) :|: public void testDeviceOwnerCanGetDeviceIdentifiersWithPermission() {
        // The device owner with the READ_PHONE_STATE permission should have access to all device
        // identifiers. However since the TelephonyManager methods can return null this method
        // verifies that the device owner with the READ_PHONE_STATE permission receives the same
        // value that the shell identity receives with the READ_PRIVILEGED_PHONE_STATE permission.
        TelephonyManager telephonyManager = (TelephonyManager) mContext.getSystemService(
                Context.TELEPHONY_SERVICE);
        try {
            assertEquals(String.format(DEVICE_ID_WITH_PERMISSION_ERROR_MESSAGE, ""getDeviceId""),
                    ShellIdentityUtils.invokeMethodWithShellPermissions(telephonyManager,
                            TelephonyManager::getDeviceId), telephonyManager.getDeviceId());
            assertEquals(String.format(DEVICE_ID_WITH_PERMISSION_ERROR_MESSAGE, ""getImei""),
                    ShellIdentityUtils.invokeMethodWithShellPermissions(telephonyManager,
                            TelephonyManager::getImei), telephonyManager.getImei());
            assertEquals(String.format(DEVICE_ID_WITH_PERMISSION_ERROR_MESSAGE, ""getMeid""),
                    ShellIdentityUtils.invokeMethodWithShellPermissions(telephonyManager,
                            TelephonyManager::getMeid), telephonyManager.getMeid());
            assertEquals(String.format(DEVICE_ID_WITH_PERMISSION_ERROR_MESSAGE, ""getSubscriberId""),
                    ShellIdentityUtils.invokeMethodWithShellPermissions(telephonyManager,
                            TelephonyManager::getSubscriberId), telephonyManager.getSubscriberId());
            assertEquals(
                    String.format(DEVICE_ID_WITH_PERMISSION_ERROR_MESSAGE, ""getSimSerialNumber""),
                    ShellIdentityUtils.invokeMethodWithShellPermissions(telephonyManager,
                            TelephonyManager::getSimSerialNumber),"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/DeviceIdentifiersTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceowner.SensorToggleRestrictionTest"	"testCameraToggle_RestrictionSet_CannotChangeSensorPrivacy"	""	"1: permission"	"([3:/com/android/cts/deviceowner/SensorToggleRestrictionTest.java]:[permission]:[3]:method_text:[                    m -> m.isSensorPrivacyEnabled(SensorPrivacyManager.Sensors.CAMERA)));    }   ]) :|: public void testCameraToggle_RestrictionSet_CannotChangeSensorPrivacy() {
        if (!mSensorPrivacyManager.supportsSensorToggle(SensorPrivacyManager.Sensors.CAMERA)) {
            return;
        }
        assertFalse(""Camera sensor privacy should be off by default"",
                ShellIdentityUtils.invokeMethodWithShellPermissions(mSensorPrivacyManager,
                        m -> m.isSensorPrivacyEnabled(SensorPrivacyManager.Sensors.CAMERA)));

        mDevicePolicyManager.addUserRestriction(getWho(), UserManager.DISALLOW_CAMERA_TOGGLE);
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mSensorPrivacyManager,
                m -> m.setSensorPrivacy(OTHER, SensorPrivacyManager.Sensors.CAMERA, true));

        assertFalse(""Camera sensor privacy should not be enabled given admin restriction"",
                ShellIdentityUtils.invokeMethodWithShellPermissions(mSensorPrivacyManager,
                        m -> m.isSensorPrivacyEnabled(SensorPrivacyManager.Sensors.CAMERA)));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/SensorToggleRestrictionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceowner.SensorToggleRestrictionTest"	"testMicrophoneToggle_RestrictionSet_CannotChangeSensorPrivacy"	""	"1: permission"	"([3:/com/android/cts/deviceowner/SensorToggleRestrictionTest.java]:[permission]:[3]:method_text:[                m -> m.isSensorPrivacyEnabled(SensorPrivacyManager.Sensors.MICROPHONE)));    }   ]) :|: public void testMicrophoneToggle_RestrictionSet_CannotChangeSensorPrivacy() {
        if (!mSensorPrivacyManager.supportsSensorToggle(SensorPrivacyManager.Sensors.MICROPHONE)) {
            return;
        }
        assertFalse(""Microphone sensor privacy should be off by default"",
                ShellIdentityUtils.invokeMethodWithShellPermissions(mSensorPrivacyManager,
                        m -> m.isSensorPrivacyEnabled(SensorPrivacyManager.Sensors.MICROPHONE)));

        mDevicePolicyManager.addUserRestriction(getWho(), UserManager.DISALLOW_MICROPHONE_TOGGLE);
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mSensorPrivacyManager,
                m -> m.setSensorPrivacy(OTHER, SensorPrivacyManager.Sensors.MICROPHONE, true));

        assertFalse(""Microphone sensor privacy should not be enabled given admin restriction"",
                ShellIdentityUtils.invokeMethodWithShellPermissions(mSensorPrivacyManager,
                        m -> m.isSensorPrivacyEnabled(SensorPrivacyManager.Sensors.MICROPHONE)));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/SensorToggleRestrictionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceowner.SensorToggleRestrictionTest"	"testCameraToggle_RestrictionSet_ResetSensorPrivacy"	""	"1: permission"	"([2:/com/android/cts/deviceowner/SensorToggleRestrictionTest.java]:[permission]:[2]:method_text:[            }        }        fail(""Camera sensor privacy did not get reset in time"");    }   ]) :|: public void testCameraToggle_RestrictionSet_ResetSensorPrivacy() {
        if (!mSensorPrivacyManager.supportsSensorToggle(SensorPrivacyManager.Sensors.CAMERA)) {
            return;
        }
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mSensorPrivacyManager,
                m -> m.setSensorPrivacy(OTHER, SensorPrivacyManager.Sensors.CAMERA, true));

        mDevicePolicyManager.addUserRestriction(getWho(), UserManager.DISALLOW_CAMERA_TOGGLE);

        long deadline = System.nanoTime() + RESTRICTION_WAITING_TIMEOUT_NANO;
        while (System.nanoTime() < deadline) {
            if (!ShellIdentityUtils.invokeMethodWithShellPermissions(mSensorPrivacyManager,
                    m -> m.isSensorPrivacyEnabled(SensorPrivacyManager.Sensors.CAMERA))) {
                return;
            }
        }
        fail(""Camera sensor privacy did not get reset in time"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/SensorToggleRestrictionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceowner.SensorToggleRestrictionTest"	"testMicrophoneToggle_RestrictionSet_ResetSensorPrivacy"	""	"1: permission"	"([2:/com/android/cts/deviceowner/SensorToggleRestrictionTest.java]:[permission]:[2]:method_text:[            }        }        fail(""Microphone sensor privacy did not get reset in time"");    }}]) :|: public void testMicrophoneToggle_RestrictionSet_ResetSensorPrivacy() {
        if (!mSensorPrivacyManager.supportsSensorToggle(SensorPrivacyManager.Sensors.MICROPHONE)) {
            return;
        }
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mSensorPrivacyManager,
                m -> m.setSensorPrivacy(OTHER, SensorPrivacyManager.Sensors.MICROPHONE, true));

        mDevicePolicyManager.addUserRestriction(getWho(), UserManager.DISALLOW_MICROPHONE_TOGGLE);

        long deadline = System.nanoTime() + RESTRICTION_WAITING_TIMEOUT_NANO;
        while (System.nanoTime() < deadline) {
            if (!ShellIdentityUtils.invokeMethodWithShellPermissions(mSensorPrivacyManager,
                    m -> m.isSensorPrivacyEnabled(SensorPrivacyManager.Sensors.MICROPHONE))) {
                return;
            }
        }
        fail(""Microphone sensor privacy did not get reset in time"");
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/SensorToggleRestrictionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.packageinstaller.ManualPackageInstallTest"	"testManualInstallBlocked"	""	"1: permission"	"([3:/com/android/cts/packageinstaller/ManualPackageInstallTest.java]:[permission]:[3]:method_text:[       .res(settingsPackageName + "":id/"" + resId)                .pkg(settingsPackageName);    }}]) :|: public void testManualInstallBlocked() throws Exception {
        synchronized (mPackageInstallerTimeoutLock) {
            mCallbackReceived = false;
            mCallbackStatus = PACKAGE_INSTALLER_STATUS_UNDEFINED;
        }
        // Calls the original installPackage which does not click through the install button.
        Log.d(TAG, ""Installing "" + TEST_APP_LOCATION);
        super.installPackage(TEST_APP_LOCATION);
        synchronized (mPackageInstallerTimeoutLock) {
            try {
                mPackageInstallerTimeoutLock.wait(PACKAGE_INSTALLER_TIMEOUT_MS);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                Log.e(TAG, ""Interrupted"", e);
            }
            assertTrue(mCallbackReceived);
            assertEquals(PackageInstaller.STATUS_PENDING_USER_ACTION, mCallbackStatus);
        }

        mCallbackIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        Log.d(TAG, ""Starting "" + mCallbackIntent + "" on user "" + UserHandle.myUserId());
        mContext.startActivity(mCallbackIntent);

        automateDismissInstallBlockedDialog();

        // Assuming installation is not synchronous, we should wait a while before checking.
        Thread.sleep(INSTALL_WAIT_TIME);
        assertFalse(isPackageInstalled(TEST_APP_PKG));
    }

    @Override
    protected void installPackage(String packageLocation) throws Exception {
        super.installPackage(packageLocation);

        synchronized (mPackageInstallerTimeoutLock) {
            try {
                mPackageInstallerTimeoutLock.wait(PACKAGE_INSTALLER_TIMEOUT_MS);
            } catch (InterruptedException e) {
            }
            assertTrue(mCallbackReceived);
            assertEquals(PackageInstaller.STATUS_PENDING_USER_ACTION, mCallbackStatus);
        }

        // Use a receiver to listen for package install.
        synchronized (mPackageInstallerTimeoutLock) {
            mCallbackReceived = false;
            mCallbackStatus"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/PackageInstaller/src/com/android/cts/packageinstaller/ManualPackageInstallTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.ApplicationHiddenParentTest"	"isNotNull"	""	"1: permission"	"([1:/com/android/cts/deviceandprofileowner/ApplicationHiddenParentTest.java]:[permission]:[1]:method_text:[IVER_COMPONENT,                SYSTEM_PACKAGE_TO_HIDE, false);        super.tearDown();    }   ]) :|: public void test/*
 *.
 */

package com.android.cts.deviceandprofileowner;

import static com.google.common.truth.Truth.assertThat;

import static org.testng.Assert.assertThrows;

import android.app.admin.DevicePolicyManager;
import android.content.pm.PackageManager;

public class ApplicationHiddenParentTest extends BaseDeviceAdminTest {

    private DevicePolicyManager mParentDevicePolicyManager;
    private PackageManager mPackageManager;

    private static final String SYSTEM_PACKAGE_TO_HIDE = ""com.android.keychain"";
    private static final String NON_SYSTEM_NON_INSTALLED_PACKAGE = ""com.android.cts.permissionapp"";
    private static final String NON_SYSTEM_INSTALLED_PACKAGE =
            ""com.android.cts.deviceandprofileowner"";

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mParentDevicePolicyManager =
                mDevicePolicyManager.getParentProfileInstance(ADMIN_RECEIVER_COMPONENT);
        mPackageManager = mContext.getPackageManager();
        assertThat(mParentDevicePolicyManager).isNotNull();

        assertThat(mDevicePolicyManager.isProfileOwnerApp(ADMIN_RECEIVER_COMPONENT.getPackageName())).isTrue();
        assertThat(mDevicePolicyManager.isOrganizationOwnedDeviceWithManagedProfile()).isTrue();
    }

    @Override
    protected void tearDown() throws Exception {
        mParentDevicePolicyManager.setApplicationHidden(ADMIN_RECEIVER_COMPONENT,
                SYSTEM_PACKAGE_TO_HIDE, false);
        super.tearDown();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/ApplicationHiddenParentTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.EnrollmentSpecificIdTest"	"testThrowsWhenTryingToReSetOrganizationId"	""	"1: permission"	"([2:/com/android/cts/deviceandprofileowner/EnrollmentSpecificIdTest.java]:[permission]:[2]:method_text:[d     * does not, for example, return the same ESID regardless of the managing package.     */   ]) :|: public void testThrowsWhenTryingToReSetOrganizationId() {
        mUiAutomation.adoptShellPermissionIdentity(PERMISSIONS_TO_ADOPT);

        mDevicePolicyManager.setOrganizationId(""abc"");
        final String firstEsid = mDevicePolicyManager.getEnrollmentSpecificId();
        assertThat(firstEsid).isNotEmpty();

        assertThrows(IllegalStateException.class,
                () -> mDevicePolicyManager.setOrganizationId(""xyz""));
    }

    /**
     * This test tests that the platform calculates the ESID according to the specification and
     * does not, for example, return the same ESID regardless of the managing package.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/EnrollmentSpecificIdTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.EnrollmentSpecificIdTest"	"testCorrectCalculationOfEsid"	""	"1: permission"	"([2:/com/android/cts/deviceandprofileowner/EnrollmentSpecificIdTest.java]:[permission]:[2]:method_text:[      encoded[--index] = alphabet[group];        }        return String.valueOf(encoded);    }}]) :|: public void testCorrectCalculationOfEsid() {
        mUiAutomation.adoptShellPermissionIdentity(PERMISSIONS_TO_ADOPT);
        mDevicePolicyManager.setOrganizationId(ORGANIZATION_ID);
        final String esidFromDpm = mDevicePolicyManager.getEnrollmentSpecificId();
        final String calculatedEsid = calculateEsid(ADMIN_RECEIVER_COMPONENT.getPackageName(),
                ORGANIZATION_ID);
        assertThat(esidFromDpm).isEqualTo(calculatedEsid);
    }

    private String calculateEsid(String profileOwnerPackage, String enterpriseIdString) {
        TelephonyManager telephonyService = mContext.getSystemService(TelephonyManager.class);
        assertThat(telephonyService).isNotNull();

        WifiManager wifiManager = mContext.getSystemService(WifiManager.class);
        assertThat(wifiManager).isNotNull();

        final byte[] serialNumber = getPaddedHardwareIdentifier(Build.getSerial()).getBytes();
        final byte[] imei = getPaddedHardwareIdentifier(telephonyService.getImei(0)).getBytes();
        final byte[] meid = getPaddedHardwareIdentifier(telephonyService.getMeid(0)).getBytes();

        final byte[] macAddress;
        final String[] macAddresses = wifiManager.getFactoryMacAddresses();
        if (macAddresses == null || macAddresses.length == 0) {
            macAddress = """".getBytes();
        } else {
            macAddress = macAddresses[0].getBytes();
        }

        final int totalIdentifiersLength = serialNumber.length + imei.length + meid.length
                + macAddress.length;
        final ByteBuffer fixedIdentifiers = ByteBuffer.allocate(totalIdentifiersLength);
        fixedIdentifiers.put(serialNumber);
        fixedIdentifiers.put(imei);
        fixedIdentifiers.put(meid);
        fixedIdentifiers.put(macAddress);

        final byte[] dpcPackage = getPaddedProfileOwnerName(profileOwnerPackage).getBytes();
        final byte[] enterpriseId = getPaddedEnterpriseId(enterpriseIdString).getBytes();
        final ByteBuffer info = B"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/EnrollmentSpecificIdTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.DevicePolicyLoggingTest"	"testSetPermissionPolicyLogged"	""	"1: permission"	"([7:/com/android/cts/deviceandprofileowner/DevicePolicyLoggingTest.java]:[permission]:[7]:method_text:[.setPermissionPolicy(ADMIN_RECEIVER_COMPONENT,                PERMISSION_POLICY_PROMPT);    }   ]) :|: public void testSetPermissionPolicyLogged() {
        mDevicePolicyManager.setPermissionPolicy(ADMIN_RECEIVER_COMPONENT,
                PERMISSION_POLICY_AUTO_DENY);
        mDevicePolicyManager.setPermissionPolicy(ADMIN_RECEIVER_COMPONENT,
                PERMISSION_POLICY_AUTO_GRANT);
        mDevicePolicyManager.setPermissionPolicy(ADMIN_RECEIVER_COMPONENT,
                PERMISSION_POLICY_PROMPT);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/DevicePolicyLoggingTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.DevicePolicyLoggingTest"	"testSetPermissionGrantStateLogged"	""	"1: permission"	"([7:/com/android/cts/deviceandprofileowner/DevicePolicyLoggingTest.java]:[permission]:[7]:method_text:[_COMPONENT, PACKAGE_NAME,                READ_CONTACTS, PERMISSION_GRANT_STATE_DEFAULT);    }   ]) :|: public void testSetPermissionGrantStateLogged() throws InterruptedException {
        mDevicePolicyManager.setPermissionGrantState(ADMIN_RECEIVER_COMPONENT,
                PACKAGE_NAME, READ_CONTACTS, PERMISSION_GRANT_STATE_GRANTED);
        mDevicePolicyManager.setPermissionGrantState(ADMIN_RECEIVER_COMPONENT, PACKAGE_NAME,
                READ_CONTACTS, PERMISSION_GRANT_STATE_DENIED);
        mDevicePolicyManager.setPermissionGrantState(ADMIN_RECEIVER_COMPONENT, PACKAGE_NAME,
                READ_CONTACTS, PERMISSION_GRANT_STATE_DEFAULT);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/DevicePolicyLoggingTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.PermissionsTest"	"PermissionBroadcastReceiver"	""	"1: permission"	"([43:/com/android/cts/deviceandprofileowner/PermissionsTest.java]:[permission]:[43]:method_text:[er(mReceiver);        mDevice.removeWatcher(CRASH_WATCHER_ID);        super.tearDown();    }   ]) :|: public void test/*
 *.
 */
package com.android.cts.deviceandprofileowner;

import static android.Manifest.permission.READ_CONTACTS;
import static android.Manifest.permission.WRITE_CONTACTS;
import static android.app.admin.DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT;
import static android.app.admin.DevicePolicyManager.PERMISSION_GRANT_STATE_DENIED;
import static android.app.admin.DevicePolicyManager.PERMISSION_GRANT_STATE_GRANTED;
import static android.app.admin.DevicePolicyManager.PERMISSION_POLICY_AUTO_DENY;
import static android.app.admin.DevicePolicyManager.PERMISSION_POLICY_AUTO_GRANT;
import static android.app.admin.DevicePolicyManager.PERMISSION_POLICY_PROMPT;
import static android.content.pm.PackageManager.PERMISSION_DENIED;
import static android.content.pm.PackageManager.PERMISSION_GRANTED;

import android.Manifest.permission;
import android.app.UiAutomation;
import android.app.admin.DevicePolicyManager;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.support.test.uiautomator.By;
import android.support.test.uiautomator.BySelector;
import android.support.test.uiautomator.UiDevice;
import android.support.test.uiautomator.UiObject2;
import android.util.Log;

import com.android.cts.devicepolicy.PermissionBroadcastReceiver;
import com.android.cts.devicepolicy.PermissionUtils;

import com.google.android.collect.Sets;

import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * Test Runtime Permissions APIs in DevicePolicyManager.
 */
public class PermissionsTest extends BaseDeviceAdminTest {

    private static final String TAG = ""PermissionsTest"";

    private static final String PERMISSION_APP_PACKAGE_NAME = ""com.android.cts.permissionapp"";
    private static final String PRE_M_APP_PACKAGE_NAME
            = ""com.android.cts.launcherapps.simplepremapp"";
    private static final String PERMISSIONS_ACTIVITY_NAME
            = PERMISSION_APP_PACKAGE_NAME + "".Per"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.PermissionsTest"	"testPermissionGrantStateDenied"	""	"1: permission"	"([6:/com/android/cts/deviceandprofileowner/PermissionsTest.java]:[permission]:[6]:method_text:[ON_GRANT_STATE_DENIED);        assertCannotRequestPermissionFromActivity(READ_CONTACTS);    }   ]) :|: public void testPermissionGrantStateDenied() throws Exception {
        setPermissionGrantState(READ_CONTACTS, PERMISSION_GRANT_STATE_DENIED);

        assertPermissionGrantState(READ_CONTACTS, PERMISSION_GRANT_STATE_DENIED);
        assertCannotRequestPermissionFromActivity(READ_CONTACTS);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.PermissionsTest"	"testPermissionGrantStateDenied_permissionRemainsDenied"	""	"1: permission"	"([11:/com/android/cts/deviceandprofileowner/PermissionsTest.java]:[permission]:[11]:method_text:[ original state            setPermissionGrantState(READ_CONTACTS, grantState);        }    }   ]) :|: public void testPermissionGrantStateDenied_permissionRemainsDenied() throws Exception {
        int grantState = mDevicePolicyManager.getPermissionGrantState(ADMIN_RECEIVER_COMPONENT,
                PERMISSION_APP_PACKAGE_NAME, READ_CONTACTS);
        try {
            setPermissionGrantState(READ_CONTACTS, PERMISSION_GRANT_STATE_DENIED);

            assertNoPermissionFromActivity(READ_CONTACTS);

            // Should stay denied
            setPermissionGrantState(READ_CONTACTS, PERMISSION_GRANT_STATE_DEFAULT);

            assertNoPermissionFromActivity(READ_CONTACTS);
        } finally {
            // Restore original state
            setPermissionGrantState(READ_CONTACTS, grantState);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.PermissionsTest"	"testPermissionGrantStateDenied_mixedPolicies"	""	"1: permission"	"([27:/com/android/cts/deviceandprofileowner/PermissionsTest.java]:[permission]:[27]:method_text:[(READ_CONTACTS, grantState);            setPermissionPolicy(permissionPolicy);        }    }   ]) :|: public void testPermissionGrantStateDenied_mixedPolicies() throws Exception {
        int grantState = mDevicePolicyManager.getPermissionGrantState(ADMIN_RECEIVER_COMPONENT,
                PERMISSION_APP_PACKAGE_NAME, READ_CONTACTS);
        int permissionPolicy = mDevicePolicyManager.getPermissionPolicy(ADMIN_RECEIVER_COMPONENT);
        try {
            setPermissionGrantState(READ_CONTACTS, PERMISSION_GRANT_STATE_DENIED);

            // Check no permission by launching an activity and requesting the permission
            // Should stay denied if grant state is denied
            setPermissionPolicy(PERMISSION_POLICY_AUTO_GRANT);

            assertPermissionPolicy(PERMISSION_POLICY_AUTO_GRANT);
            assertCannotRequestPermissionFromActivity(READ_CONTACTS);

            setPermissionPolicy(PERMISSION_POLICY_AUTO_DENY);

            assertPermissionPolicy(PERMISSION_POLICY_AUTO_DENY);
            assertCannotRequestPermissionFromActivity(READ_CONTACTS);

            setPermissionPolicy(PERMISSION_POLICY_PROMPT);

            assertPermissionPolicy(PERMISSION_POLICY_PROMPT);
            assertCannotRequestPermissionFromActivity(READ_CONTACTS);
        } finally {
            // Restore original state
            setPermissionGrantState(READ_CONTACTS, grantState);
            setPermissionPolicy(permissionPolicy);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.PermissionsTest"	"testPermissionGrantStateDenied_otherPermissionIsGranted"	""	"1: permission"	"([19:/com/android/cts/deviceandprofileowner/PermissionsTest.java]:[permission]:[19]:method_text:[tStateA);            setPermissionGrantState(CUSTOM_PERM_B_NAME, grantStateB);        }    }   ]) :|: public void testPermissionGrantStateDenied_otherPermissionIsGranted() throws Exception {
        int grantStateA = mDevicePolicyManager.getPermissionGrantState(ADMIN_RECEIVER_COMPONENT,
                PERMISSION_APP_PACKAGE_NAME, CUSTOM_PERM_A_NAME);
        int grantStateB = mDevicePolicyManager.getPermissionGrantState(ADMIN_RECEIVER_COMPONENT,
                PERMISSION_APP_PACKAGE_NAME, CUSTOM_PERM_B_NAME);
        try {
            setPermissionGrantState(CUSTOM_PERM_A_NAME, PERMISSION_GRANT_STATE_GRANTED);
            setPermissionGrantState(CUSTOM_PERM_B_NAME, PERMISSION_GRANT_STATE_DENIED);

            assertPermissionGrantState(CUSTOM_PERM_A_NAME, PERMISSION_GRANT_STATE_GRANTED);
            assertPermissionGrantState(CUSTOM_PERM_B_NAME, PERMISSION_GRANT_STATE_DENIED);

            /*
             * CUSTOM_PERM_A_NAME and CUSTOM_PERM_B_NAME are in the same permission group and one is
             * granted the other one is not.
             *
             * It should not be possible to get the permission that was denied via policy granted by
             * requesting it.
             */
            assertCannotRequestPermissionFromActivity(CUSTOM_PERM_B_NAME);
        } finally {
            // Restore original state
            setPermissionGrantState(CUSTOM_PERM_A_NAME, grantStateA);
            setPermissionGrantState(CUSTOM_PERM_B_NAME, grantStateB);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.PermissionsTest"	"testPermissionGrantStateGranted"	""	"1: permission"	"([6:/com/android/cts/deviceandprofileowner/PermissionsTest.java]:[permission]:[6]:method_text:[SION_GRANT_STATE_GRANTED);        assertCanRequestPermissionFromActivity(READ_CONTACTS);    }   ]) :|: public void testPermissionGrantStateGranted() throws Exception {
        setPermissionGrantState(READ_CONTACTS, PERMISSION_GRANT_STATE_GRANTED);

        assertPermissionGrantState(READ_CONTACTS, PERMISSION_GRANT_STATE_GRANTED);
        assertCanRequestPermissionFromActivity(READ_CONTACTS);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.PermissionsTest"	"testPermissionGrantStateGranted_permissionRemainsGranted"	""	"1: permission"	"([11:/com/android/cts/deviceandprofileowner/PermissionsTest.java]:[permission]:[11]:method_text:[ original state            setPermissionGrantState(READ_CONTACTS, grantState);        }    }   ]) :|: public void testPermissionGrantStateGranted_permissionRemainsGranted() throws Exception {
        int grantState = mDevicePolicyManager.getPermissionGrantState(ADMIN_RECEIVER_COMPONENT,
                PERMISSION_APP_PACKAGE_NAME, READ_CONTACTS);
        try {
            setPermissionGrantState(READ_CONTACTS, PERMISSION_GRANT_STATE_GRANTED);

            assertHasPermissionFromActivity(READ_CONTACTS);

            // Should stay granted
            setPermissionGrantState(READ_CONTACTS, PERMISSION_GRANT_STATE_DEFAULT);

            assertHasPermissionFromActivity(READ_CONTACTS);
        } finally {
            // Restore original state
            setPermissionGrantState(READ_CONTACTS, grantState);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.PermissionsTest"	"testPermissionGrantStateGranted_mixedPolicies"	""	"1: permission"	"([27:/com/android/cts/deviceandprofileowner/PermissionsTest.java]:[permission]:[27]:method_text:[(READ_CONTACTS, grantState);            setPermissionPolicy(permissionPolicy);        }    }   ]) :|: public void testPermissionGrantStateGranted_mixedPolicies() throws Exception {
        int grantState = mDevicePolicyManager.getPermissionGrantState(ADMIN_RECEIVER_COMPONENT,
                PERMISSION_APP_PACKAGE_NAME, READ_CONTACTS);
        int permissionPolicy = mDevicePolicyManager.getPermissionPolicy(ADMIN_RECEIVER_COMPONENT);
        try {
            setPermissionGrantState(READ_CONTACTS, PERMISSION_GRANT_STATE_GRANTED);

            // Check permission by launching an activity and requesting the permission
            setPermissionPolicy(PERMISSION_POLICY_AUTO_GRANT);

            assertPermissionPolicy(PERMISSION_POLICY_AUTO_GRANT);
            assertCanRequestPermissionFromActivity(READ_CONTACTS);

            setPermissionPolicy(PERMISSION_POLICY_AUTO_DENY);

            assertPermissionPolicy(PERMISSION_POLICY_AUTO_DENY);
            assertCanRequestPermissionFromActivity(READ_CONTACTS);

            setPermissionPolicy(PERMISSION_POLICY_PROMPT);

            assertPermissionPolicy(PERMISSION_POLICY_PROMPT);
            assertCanRequestPermissionFromActivity(READ_CONTACTS);
        } finally {
            // Restore original state
            setPermissionGrantState(READ_CONTACTS, grantState);
            setPermissionPolicy(permissionPolicy);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.PermissionsTest"	"testPermissionGrantStateGranted_userNotifiedOfLocationPermission"	""	"1: permission"	"([13:/com/android/cts/deviceandprofileowner/PermissionsTest.java]:[permission]:[13]:method_text:[nit.SECONDS));            NotificationListener.getInstance().clearListeners();        }    }   ]) :|: public void testPermissionGrantStateGranted_userNotifiedOfLocationPermission()
            throws Exception {
        for (String locationPermission : LOCATION_PERMISSIONS) {
            // TODO(b/161359841): move NotificationListener to app/common
            CountDownLatch notificationLatch = initPermissionNotificationLatch();

            setPermissionGrantState(locationPermission, PERMISSION_GRANT_STATE_GRANTED);

            assertPermissionGrantState(locationPermission, PERMISSION_GRANT_STATE_GRANTED);
            assertTrue(String.format(""Did not receive notification for permission %s"",
                    locationPermission), notificationLatch.await(60, TimeUnit.SECONDS));
            NotificationListener.getInstance().clearListeners();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.PermissionsTest"	"testPermissionGrantState_developmentPermission"	""	"1: permission"	"([23:/com/android/cts/deviceandprofileowner/PermissionsTest.java]:[permission]:[23]:method_text:[(DEVELOPMENT_PERMISSION, PERMISSION_DENIED,                PERMISSION_APP_PACKAGE_NAME);    }   ]) :|: public void testPermissionGrantState_developmentPermission() {
        assertCannotSetPermissionGrantStateDevelopmentPermission(PERMISSION_GRANT_STATE_DENIED);
        assertCannotSetPermissionGrantStateDevelopmentPermission(PERMISSION_GRANT_STATE_DEFAULT);
        assertCannotSetPermissionGrantStateDevelopmentPermission(PERMISSION_GRANT_STATE_GRANTED);
    }

    private void assertCannotSetPermissionGrantStateDevelopmentPermission(int value) {
        unableToSetPermissionGrantState(DEVELOPMENT_PERMISSION, value);

        assertPermissionGrantState(DEVELOPMENT_PERMISSION, PERMISSION_GRANT_STATE_DEFAULT);
        PermissionUtils.checkPermission(DEVELOPMENT_PERMISSION, PERMISSION_DENIED,
                PERMISSION_APP_PACKAGE_NAME);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.PermissionsTest"	"testPermissionGrantState_preMApp_preQDeviceAdmin"	""	"1: permission"	"([22:/com/android/cts/deviceandprofileowner/PermissionsTest.java]:[permission]:[22]:method_text:[missionAndAppOps(permission, PERMISSION_GRANTED,                PRE_M_APP_PACKAGE_NAME);    }   ]) :|: public void testPermissionGrantState_preMApp_preQDeviceAdmin() throws Exception {
        // These tests are to make sure that pre-M apps are not granted/denied runtime permissions
        // by a profile owner that targets pre-Q
        assertCannotSetPermissionGrantStatePreMApp(READ_CONTACTS, PERMISSION_GRANT_STATE_DENIED);
        assertCannotSetPermissionGrantStatePreMApp(READ_CONTACTS, PERMISSION_GRANT_STATE_GRANTED);
    }

    private void assertCannotSetPermissionGrantStatePreMApp(String permission, int value)
            throws Exception {
        assertFalse(mDevicePolicyManager.setPermissionGrantState(ADMIN_RECEIVER_COMPONENT,
                PRE_M_APP_PACKAGE_NAME, permission, value));
        assertEquals(mDevicePolicyManager.getPermissionGrantState(ADMIN_RECEIVER_COMPONENT,
                PRE_M_APP_PACKAGE_NAME, permission), PERMISSION_GRANT_STATE_DEFAULT);

        // Install runtime permissions should always be granted
        PermissionUtils.checkPermission(permission, PERMISSION_GRANTED, PRE_M_APP_PACKAGE_NAME);
        PermissionUtils.checkPermissionAndAppOps(permission, PERMISSION_GRANTED,
                PRE_M_APP_PACKAGE_NAME);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.PermissionsTest"	"testPermissionGrantState_preMApp"	""	"1: permission"	"([27:/com/android/cts/deviceandprofileowner/PermissionsTest.java]:[permission]:[27]:method_text:[  break;            default:                fail(""unsupported policy value"");        }    }   ]) :|: public void testPermissionGrantState_preMApp() throws Exception {
        // These tests are to make sure that pre-M apps can be granted/denied runtime permissions
        // by a profile owner targets Q or later
        assertCanSetPermissionGrantStatePreMApp(READ_CONTACTS, PERMISSION_GRANT_STATE_DENIED);
        assertCanSetPermissionGrantStatePreMApp(READ_CONTACTS, PERMISSION_GRANT_STATE_GRANTED);
    }

    private void assertCanSetPermissionGrantStatePreMApp(String permission, int value)
            throws Exception {
        assertTrue(mDevicePolicyManager.setPermissionGrantState(ADMIN_RECEIVER_COMPONENT,
                PRE_M_APP_PACKAGE_NAME, permission, value));
        assertEquals(mDevicePolicyManager.getPermissionGrantState(ADMIN_RECEIVER_COMPONENT,
                PRE_M_APP_PACKAGE_NAME, permission), value);

        // Install time permissions should always be granted
        PermissionUtils.checkPermission(permission, PERMISSION_GRANTED, PRE_M_APP_PACKAGE_NAME);

        // For pre-M apps the access to the data might be prevented via app-ops. Hence check that
        // they are correctly set
        switch (value) {
            case PERMISSION_GRANT_STATE_GRANTED:
                PermissionUtils.checkPermissionAndAppOps(permission, PERMISSION_GRANTED,
                        PRE_M_APP_PACKAGE_NAME);
                break;
            case PERMISSION_GRANT_STATE_DENIED:
                PermissionUtils.checkPermissionAndAppOps(permission, PERMISSION_DENIED,
                        PRE_M_APP_PACKAGE_NAME);
                break;
            default:
                fail(""unsupported policy value"");
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.PermissionsTest"	"testPermissionPolicyAutoDeny"	""	"1: permission"	"([6:/com/android/cts/deviceandprofileowner/PermissionsTest.java]:[permission]:[6]:method_text:[SION_POLICY_AUTO_DENY);        assertCannotRequestPermissionFromActivity(READ_CONTACTS);    }   ]) :|: public void testPermissionPolicyAutoDeny() throws Exception {
        setPermissionPolicy(PERMISSION_POLICY_AUTO_DENY);

        assertPermissionPolicy(PERMISSION_POLICY_AUTO_DENY);
        assertCannotRequestPermissionFromActivity(READ_CONTACTS);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.PermissionsTest"	"testPermissionPolicyAutoDeny_permissionLocked"	""	"1: permission"	"([25:/com/android/cts/deviceandprofileowner/PermissionsTest.java]:[permission]:[25]:method_text:[(READ_CONTACTS, grantState);            setPermissionPolicy(permissionPolicy);        }    }   ]) :|: public void testPermissionPolicyAutoDeny_permissionLocked() throws Exception {
        int grantState = mDevicePolicyManager.getPermissionGrantState(ADMIN_RECEIVER_COMPONENT,
                PERMISSION_APP_PACKAGE_NAME, READ_CONTACTS);
        int permissionPolicy = mDevicePolicyManager.getPermissionPolicy(ADMIN_RECEIVER_COMPONENT);
        try {
            setPermissionGrantState(READ_CONTACTS, PERMISSION_GRANT_STATE_DENIED);
            setPermissionGrantState(READ_CONTACTS, PERMISSION_GRANT_STATE_DEFAULT);
            testPermissionPolicyAutoDeny();

            // Permission should be locked, so changing the policy should not change the grant state
            setPermissionPolicy(PERMISSION_POLICY_PROMPT);

            assertPermissionPolicy(PERMISSION_POLICY_PROMPT);
            assertCannotRequestPermissionFromActivity(READ_CONTACTS);

            setPermissionPolicy(PERMISSION_POLICY_AUTO_GRANT);

            assertPermissionPolicy(PERMISSION_POLICY_AUTO_GRANT);
            assertCannotRequestPermissionFromActivity(READ_CONTACTS);
        } finally {
            // Restore original state
            setPermissionGrantState(READ_CONTACTS, grantState);
            setPermissionPolicy(permissionPolicy);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.PermissionsTest"	"testPermissionPolicyAutoGrant"	""	"1: permission"	"([6:/com/android/cts/deviceandprofileowner/PermissionsTest.java]:[permission]:[6]:method_text:[ISSION_POLICY_AUTO_GRANT);        assertCanRequestPermissionFromActivity(READ_CONTACTS);    }   ]) :|: public void testPermissionPolicyAutoGrant() throws Exception {
        setPermissionPolicy(PERMISSION_POLICY_AUTO_GRANT);

        assertPermissionPolicy(PERMISSION_POLICY_AUTO_GRANT);
        assertCanRequestPermissionFromActivity(READ_CONTACTS);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.PermissionsTest"	"testPermissionPolicyAutoGrant_permissionLocked"	""	"1: permission"	"([27:/com/android/cts/deviceandprofileowner/PermissionsTest.java]:[permission]:[27]:method_text:[(READ_CONTACTS, grantState);            setPermissionPolicy(permissionPolicy);        }    }   ]) :|: public void testPermissionPolicyAutoGrant_permissionLocked() throws Exception {
        int grantState = mDevicePolicyManager.getPermissionGrantState(ADMIN_RECEIVER_COMPONENT,
                PERMISSION_APP_PACKAGE_NAME, READ_CONTACTS);
        int permissionPolicy = mDevicePolicyManager.getPermissionPolicy(ADMIN_RECEIVER_COMPONENT);
        try {
            setPermissionGrantState(READ_CONTACTS, PERMISSION_GRANT_STATE_DEFAULT);
            setPermissionPolicy(PERMISSION_POLICY_AUTO_GRANT);

            assertPermissionPolicy(PERMISSION_POLICY_AUTO_GRANT);
            assertCanRequestPermissionFromActivity(READ_CONTACTS);

            // permission should be locked, so changing the policy should not change the grant state
            setPermissionPolicy(PERMISSION_POLICY_PROMPT);

            assertPermissionPolicy(PERMISSION_POLICY_PROMPT);
            assertCanRequestPermissionFromActivity(READ_CONTACTS);

            setPermissionPolicy(PERMISSION_POLICY_AUTO_DENY);

            assertPermissionPolicy(PERMISSION_POLICY_AUTO_DENY);
            assertCanRequestPermissionFromActivity(READ_CONTACTS);
        } finally {
            // Restore original state
            setPermissionGrantState(READ_CONTACTS, grantState);
            setPermissionPolicy(permissionPolicy);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.PermissionsTest"	"testPermissionPolicyAutoGrant_multiplePermissionsInGroup"	""	"1: permission"	"([13:/com/android/cts/deviceandprofileowner/PermissionsTest.java]:[permission]:[13]:method_text:[   // Restore original state            setPermissionPolicy(permissionPolicy);        }    }   ]) :|: public void testPermissionPolicyAutoGrant_multiplePermissionsInGroup() throws Exception {
        int permissionPolicy = mDevicePolicyManager.getPermissionPolicy(ADMIN_RECEIVER_COMPONENT);
        try {
            setPermissionPolicy(PERMISSION_POLICY_AUTO_GRANT);

            // Both permissions should be granted
            assertPermissionPolicy(PERMISSION_POLICY_AUTO_GRANT);
            assertCanRequestPermissionFromActivity(READ_CONTACTS);
            assertCanRequestPermissionFromActivity(WRITE_CONTACTS);
        } finally {
            // Restore original state
            setPermissionPolicy(permissionPolicy);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.PermissionsTest"	"testCannotRequestPermission"	""	"1: permission"	"([2:/com/android/cts/deviceandprofileowner/PermissionsTest.java]:[permission]:[2]:method_text:[on() throws Exception {        assertCannotRequestPermissionFromActivity(READ_CONTACTS);    }   ]) :|: public void testCannotRequestPermission() throws Exception {
        assertCannotRequestPermissionFromActivity(READ_CONTACTS);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.PermissionsTest"	"testCanRequestPermission"	""	"1: permission"	"([2:/com/android/cts/deviceandprofileowner/PermissionsTest.java]:[permission]:[2]:method_text:[ssion() throws Exception {        assertCanRequestPermissionFromActivity(READ_CONTACTS);    }   ]) :|: public void testCanRequestPermission() throws Exception {
        assertCanRequestPermissionFromActivity(READ_CONTACTS);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.PermissionsTest"	"testPermissionPrompts"	""	"1: permission"	"([23:/com/android/cts/deviceandprofileowner/PermissionsTest.java]:[permission]:[23]:method_text:[rmission(READ_CONTACTS, PERMISSION_GRANTED,                PERMISSION_APP_PACKAGE_NAME);    }   ]) :|: public void testPermissionPrompts() throws Exception {
        // register a crash watcher
        mDevice.registerWatcher(CRASH_WATCHER_ID, () -> {
            UiObject2 button = mDevice.findObject(CRASH_POPUP_BUTTON_SELECTOR);
            if (button != null) {
                UiObject2 text = mDevice.findObject(CRASH_POPUP_TEXT_SELECTOR);
                Log.d(TAG, ""Removing an error dialog: "" + text != null ? text.getText() : null);
                button.click();
                return true;
            }
            return false;
        });
        mDevice.runWatchers();
        setPermissionPolicy(PERMISSION_POLICY_PROMPT);

        assertPermissionPolicy(PERMISSION_POLICY_PROMPT);
        PermissionUtils.launchActivityAndRequestPermission(mReceiver, mDevice, READ_CONTACTS,
                PERMISSION_DENIED, PERMISSION_APP_PACKAGE_NAME, PERMISSIONS_ACTIVITY_NAME);
        PermissionUtils.checkPermission(READ_CONTACTS, PERMISSION_DENIED,
                PERMISSION_APP_PACKAGE_NAME);
        PermissionUtils.launchActivityAndRequestPermission(mReceiver, mDevice, READ_CONTACTS,
                PERMISSION_GRANTED, PERMISSION_APP_PACKAGE_NAME, PERMISSIONS_ACTIVITY_NAME);
        PermissionUtils.checkPermission(READ_CONTACTS, PERMISSION_GRANTED,
                PERMISSION_APP_PACKAGE_NAME);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.PermissionsTest"	"testSensorsRelatedPermissionsCannotBeGranted"	""	"1: permission"	"([20:/com/android/cts/deviceandprofileowner/PermissionsTest.java]:[permission]:[20]:method_text:[  } finally {                revokePermission(sensorPermission);            }        }    }   ]) :|: public void testSensorsRelatedPermissionsCannotBeGranted() throws Exception {
        for (String sensorPermission : SENSORS_PERMISSIONS) {
            try {
                // The permission cannot be granted.
                assertFailedToSetPermissionGrantState(
                        sensorPermission, DevicePolicyManager.PERMISSION_GRANT_STATE_GRANTED);

                // But the user can grant it.
                PermissionUtils.launchActivityAndRequestPermission(mReceiver, mDevice,
                        sensorPermission, PERMISSION_GRANTED, PERMISSION_APP_PACKAGE_NAME,
                        PERMISSIONS_ACTIVITY_NAME);

                // And the package manager should show it as granted.
                PermissionUtils.checkPermission(sensorPermission, PERMISSION_GRANTED,
                        PERMISSION_APP_PACKAGE_NAME);
            } finally {
                revokePermission(sensorPermission);
            }
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.PermissionsTest"	"testSensorsRelatedPermissionsCanBeDenied"	""	"1: permission"	"([12:/com/android/cts/deviceandprofileowner/PermissionsTest.java]:[permission]:[12]:method_text:[NIED);            assertCannotRequestPermissionFromActivity(sensorPermission);        }    }   ]) :|: public void testSensorsRelatedPermissionsCanBeDenied() throws Exception {
        for (String sensorPermission : SENSORS_PERMISSIONS) {
            // The permission can be denied
            setPermissionGrantState(sensorPermission, PERMISSION_GRANT_STATE_DENIED);

            assertPermissionGrantState(sensorPermission, PERMISSION_GRANT_STATE_DENIED);
            assertCannotRequestPermissionFromActivity(sensorPermission);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.PermissionsTest"	"testSensorsRelatedPermissionsNotGrantedViaPolicy"	""	"1: permission"	"([24:/com/android/cts/deviceandprofileowner/PermissionsTest.java]:[permission]:[24]:method_text:[  } finally {                revokePermission(sensorPermission);            }        }    }   ]) :|: public void testSensorsRelatedPermissionsNotGrantedViaPolicy() throws Exception {
        setPermissionPolicy(PERMISSION_POLICY_AUTO_GRANT);
        for (String sensorPermission : SENSORS_PERMISSIONS) {
            try {
                // The permission is not granted by default.
                PermissionUtils.checkPermission(sensorPermission, PERMISSION_DENIED,
                        PERMISSION_APP_PACKAGE_NAME);
                // But the user can grant it.
                PermissionUtils.launchActivityAndRequestPermission(mReceiver, mDevice,
                        sensorPermission,
                        PERMISSION_GRANTED, PERMISSION_APP_PACKAGE_NAME, PERMISSIONS_ACTIVITY_NAME);

                // And the package manager should show it as granted.
                PermissionUtils.checkPermission(sensorPermission, PERMISSION_GRANTED,
                        PERMISSION_APP_PACKAGE_NAME);
            } finally {
                revokePermission(sensorPermission);
            }
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.PermissionsTest"	"testStateOfSensorsRelatedPermissionsCannotBeRead"	""	"1: permission"	"([101:/com/android/cts/deviceandprofileowner/PermissionsTest.java]:[permission]:[101]:method_text:[ PERMISSION_DENIED,                PERMISSION_APP_PACKAGE_NAME, PERMISSIONS_ACTIVITY_NAME);    }}]) :|: public void testStateOfSensorsRelatedPermissionsCannotBeRead() throws Exception {
        for (String sensorPermission : SENSORS_PERMISSIONS) {
            try {
                // The admin tries to grant the permission.
                setPermissionGrantState(sensorPermission, PERMISSION_GRANT_STATE_GRANTED);

                // But the user denies it.
                PermissionUtils.launchActivityAndRequestPermission(mReceiver, mDevice,
                        sensorPermission, PERMISSION_DENIED, PERMISSION_APP_PACKAGE_NAME,
                        PERMISSIONS_ACTIVITY_NAME);

                // And the admin cannot learn of it.
                assertPermissionGrantState(sensorPermission, PERMISSION_GRANT_STATE_DEFAULT);
            } finally {
                revokePermission(sensorPermission);
            }
        }
    }

    private void revokePermission(String sensorPermission) {
        if (LOCATION_PERMISSIONS.contains(sensorPermission)) {
            mUiAutomation.revokeRuntimePermission(PERMISSION_APP_PACKAGE_NAME,
                    permission.ACCESS_FINE_LOCATION);
            mUiAutomation.revokeRuntimePermission(PERMISSION_APP_PACKAGE_NAME,
                    permission.ACCESS_COARSE_LOCATION);
        } else {
            mUiAutomation.revokeRuntimePermission(PERMISSION_APP_PACKAGE_NAME, sensorPermission);
        }
    }

    private void assertFailedToSetPermissionGrantState(String permission, int value) {
        assertTrue(mDevicePolicyManager.setPermissionGrantState(ADMIN_RECEIVER_COMPONENT,
                PERMISSION_APP_PACKAGE_NAME, permission, value));
        assertEquals(mDevicePolicyManager.getPermissionGrantState(ADMIN_RECEIVER_COMPONENT,
                PERMISSION_APP_PACKAGE_NAME, permission),
                DevicePolicyManager.PERMISSION_GRANT_STATE_DEFAULT);
        assertEquals(mContext.getPackageManager().checkPermission(permission,
                PERMISSION_APP_PACKAGE_NAME),
                PackageManager.PERMISSION_DENIED)"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/PermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.DeviceIdentifiersTest"	"testProfileOwnerCanGetDeviceIdentifiersWithPermission"	""	"1: permission"	"([21:/com/android/cts/deviceandprofileowner/DeviceIdentifiersTest.java]:[permission]:[21]:method_text:[permission must be able to access ""                    + ""the device IDs: "" + e);        }    }}]) :|: public void testProfileOwnerCanGetDeviceIdentifiersWithPermission() throws Exception {
        // The profile owner with the READ_PHONE_STATE permission should have access to all device
        // identifiers. However since the TelephonyManager methods can return null this method
        // verifies that the profile owner with the READ_PHONE_STATE permission receives the same
        // value that the shell identity receives with the READ_PRIVILEGED_PHONE_STATE permission.
        TelephonyManager telephonyManager = (TelephonyManager) mContext.getSystemService(
                Context.TELEPHONY_SERVICE);
        try {
            assertEquals(String.format(DEVICE_ID_WITH_PERMISSION_ERROR_MESSAGE, ""getDeviceId""),
                    ShellIdentityUtils.invokeMethodWithShellPermissions(telephonyManager,
                            TelephonyManager::getDeviceId), telephonyManager.getDeviceId());
            assertEquals(String.format(DEVICE_ID_WITH_PERMISSION_ERROR_MESSAGE, ""getImei""),
                    ShellIdentityUtils.invokeMethodWithShellPermissions(telephonyManager,
                            TelephonyManager::getImei), telephonyManager.getImei());
            assertEquals(String.format(DEVICE_ID_WITH_PERMISSION_ERROR_MESSAGE, ""getMeid""),
                    ShellIdentityUtils.invokeMethodWithShellPermissions(telephonyManager,
                            TelephonyManager::getMeid), telephonyManager.getMeid());
            assertEquals(String.format(DEVICE_ID_WITH_PERMISSION_ERROR_MESSAGE, ""getSubscriberId""),
                    ShellIdentityUtils.invokeMethodWithShellPermissions(telephonyManager,
                            TelephonyManager::getSubscriberId), telephonyManager.getSubscriberId());
            assertEquals(
                    String.format(DEVICE_ID_WITH_PERMISSION_ERROR_MESSAGE, ""getSimSerialNumber""),
                    ShellIdentityUtils.invokeMethodWithShellPermissions(telephonyManager,
                            TelephonyManager::getSimSeri"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/DeviceIdentifiersTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.MeteredDataRestrictionTest"	"testSetMeteredDataDisabledPackages"	""	"1: permission"	"([2:/com/android/cts/deviceandprofileowner/MeteredDataRestrictionTest.java]:[permission]:[2]:method_text:[      // has not come up yet.        } while (latestNetId == 0 || latestNetId == oldNetId);    }}]) :|: public void testSetMeteredDataDisabledPackages() {
        final List<String> restrictedPkgs = new ArrayList<>();
        restrictedPkgs.add(METERED_DATA_APP_PKG);
        final List<String> excludedPkgs = mDevicePolicyManager.setMeteredDataDisabledPackages(
                ADMIN_RECEIVER_COMPONENT, restrictedPkgs);
        assertTrue(""Packages not restricted: "" + excludedPkgs, excludedPkgs.isEmpty());

        List<String> actualRestrictedPkgs = mDevicePolicyManager.getMeteredDataDisabledPackages(
                ADMIN_RECEIVER_COMPONENT);
        assertEquals(""Actual restricted pkgs: "" + actualRestrictedPkgs,
                1, actualRestrictedPkgs.size());
        assertTrue(""Actual restricted pkgs: "" + actualRestrictedPkgs,
                actualRestrictedPkgs.contains(METERED_DATA_APP_PKG));
        verifyAppNetworkState(true);

        restrictedPkgs.clear();
        mDevicePolicyManager.setMeteredDataDisabledPackages(ADMIN_RECEIVER_COMPONENT,
                restrictedPkgs);
        actualRestrictedPkgs = mDevicePolicyManager.getMeteredDataDisabledPackages(
                ADMIN_RECEIVER_COMPONENT);
        assertTrue(""Actual restricted pkgs: "" + actualRestrictedPkgs,
                actualRestrictedPkgs.isEmpty());
        verifyAppNetworkState(false);
    }

    private void verifyAppNetworkState(boolean blocked) {
        final Bundle extras = new Bundle();
        extras.putBinder(EXTRA_MESSENGER, mCallbackMessenger.getBinder());
        mNetworkInfos.clear();
        final Intent launchIntent = new Intent()
                .setClassName(METERED_DATA_APP_PKG, METERED_DATA_APP_MAIN_ACTIVITY)
                .putExtras(extras)
                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(launchIntent);

        try {
            final NetworkInfo networkInfo = mNetworkInfos.poll(WAIT_FOR_NETWORK_INFO_TIMEOUT_SEC,
                    TimeUnit.SECONDS);
            if (networkInfo == null) {
                fail(""Timed out waiting f"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/MeteredDataRestrictionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.OrgOwnedProfileOwnerParentTest"	"testAddGetAndClearUserRestriction_onParent"	""	"1: permission"	"([2:/com/android/cts/deviceandprofileowner/OrgOwnedProfileOwnerParentTest.java]:[permission]:[2]:method_text:[ns(ADMIN_RECEIVER_COMPONENT);        assertThat(restrictions.get(restriction)).isNull();    }   ]) :|: public void testAddGetAndClearUserRestriction_onParent() {
        int locationMode = 1;
        try {
            locationMode = runWithShellPermissionIdentity(
                    () -> Settings.Secure.getIntForUser(mContentResolver,
                            Settings.Secure.LOCATION_MODE, UserHandle.USER_SYSTEM));

            for (String restriction : PROFILE_OWNER_ORGANIZATION_OWNED_GLOBAL_RESTRICTIONS) {
                testAddGetAndClearUserRestriction_onParent(restriction);
            }
            for (String restriction : PROFILE_OWNER_ORGANIZATION_OWNED_LOCAL_RESTRICTIONS) {
                testAddGetAndClearUserRestriction_onParent(restriction);
            }
        } finally {
            // Restore the location mode setting after adding and removing the
            // DISALLOW_SHARE_LOCATION user restriction. This is because, modifying this user
            // restriction causes the location mode setting to be turned off.
            final int finalLocationMode = locationMode;
            runWithShellPermissionIdentity(() -> Settings.Secure.putIntForUser(mContentResolver,
                    Settings.Secure.LOCATION_MODE, finalLocationMode, UserHandle.USER_SYSTEM));
        }
    }

    private void testAddGetAndClearUserRestriction_onParent(String restriction) {
        mParentDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT, restriction);

        Bundle restrictions = mParentDevicePolicyManager.getUserRestrictions(
                ADMIN_RECEIVER_COMPONENT);
        assertThat(restrictions.get(restriction)).isNotNull();

        mParentDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT, restriction);

        restrictions = mParentDevicePolicyManager.getUserRestrictions(ADMIN_RECEIVER_COMPONENT);
        assertThat(restrictions.get(restriction)).isNull();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/OrgOwnedProfileOwnerParentTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.UserRestrictionsParentTest"	"dropShellPermissionIdentity"	""	"1: permission"	"([1:/com/android/cts/deviceandprofileowner/UserRestrictionsParentTest.java]:[permission]:[1]:method_text:[ad.sleep(1000);        }        throw new AssertionError(""Failed to get UiAutomation"");    }   ]) :|: public void test/*
 *.
 */

package com.android.cts.deviceandprofileowner;

import static com.android.cts.deviceandprofileowner.BaseDeviceAdminTest.ADMIN_RECEIVER_COMPONENT;

import static com.google.common.truth.Truth.assertThat;

import android.app.UiAutomation;
import android.app.admin.DevicePolicyManager;
import android.content.ContentResolver;
import android.content.Context;
import android.hardware.camera2.CameraManager;
import android.os.Bundle;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.UserHandle;
import android.os.UserManager;
import android.provider.Settings;
import android.test.InstrumentationTestCase;
import android.util.Log;

import com.android.cts.devicepolicy.CameraUtils;

import com.google.common.collect.ImmutableSet;

import java.util.Set;
import java.util.concurrent.TimeUnit;

public class UserRestrictionsParentTest extends InstrumentationTestCase {

    private static final String TAG = ""UserRestrictionsParentTest"";

    protected Context mContext;
    private ContentResolver mContentResolver;
    private UiAutomation mUiAutomation;
    private DevicePolicyManager mDevicePolicyManager;
    private UserManager mUserManager;

    private CameraManager mCameraManager;

    private HandlerThread mBackgroundThread;
    private static final long GET_UIAUTOMATION_TIMEOUT_NS = TimeUnit.SECONDS.toNanos(60);

    /**
     * A {@link Handler} for running tasks in the background.
     */
    private Handler mBackgroundHandler;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mContext = getInstrumentation().getContext();
        mContentResolver = mContext.getContentResolver();
        mUiAutomation = getUiAutomation();

        mDevicePolicyManager = (DevicePolicyManager)
                mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);
        assertNotNull(mDevicePolicyManager);

        mCameraManager = (CameraManager) mContext.getSystemService(Context.CAMERA_SERVICE);"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/UserRestrictionsParentTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.UserRestrictionsParentTest"	"testPerProfileUserRestriction_onParent"	""	"1: permission"	"([3:/com/android/cts/deviceandprofileowner/UserRestrictionsParentTest.java]:[permission]:[3]:method_text:[ISALLOW_CONFIG_DATE_TIME,                    UserManager.DISALLOW_AIRPLANE_MODE            );   ]) :|: public void testPerProfileUserRestriction_onParent() throws Settings.SettingNotFoundException {
        mUiAutomation.adoptShellPermissionIdentity(
                ""android.permission.INTERACT_ACROSS_USERS_FULL"",
                ""android.permission.CREATE_USERS"");

        DevicePolicyManager parentDevicePolicyManager =
                mDevicePolicyManager.getParentProfileInstance(ADMIN_RECEIVER_COMPONENT);
        assertNotNull(parentDevicePolicyManager);

        int locationMode = Settings.Secure.getIntForUser(mContentResolver,
                Settings.Secure.LOCATION_MODE, UserHandle.USER_SYSTEM);

        for (String restriction : PROFILE_OWNER_ORGANIZATION_OWNED_LOCAL_RESTRICTIONS) {
            try {
                boolean hasRestrictionOnManagedProfile = mUserManager.hasUserRestriction(
                        restriction);

                parentDevicePolicyManager.addUserRestriction(ADMIN_RECEIVER_COMPONENT, restriction);
                // Assert user restriction on personal profile has been added
                assertThat(hasUserRestriction(restriction)).isTrue();
                // Assert user restriction on managed profile has not changed
                assertThat(mUserManager.hasUserRestriction(restriction)).isEqualTo(
                        hasRestrictionOnManagedProfile);
            } finally {
                parentDevicePolicyManager.clearUserRestriction(ADMIN_RECEIVER_COMPONENT,
                        restriction);
                assertThat(hasUserRestriction(restriction)).isFalse();
            }
        }

        // Restore the location mode setting after adding and removing the
        // DISALLOW_SHARE_LOCATION user restriction. This is because, modifying this user
        // restriction causes the location mode setting to be turned off.
        Settings.Secure.putIntForUser(mContentResolver, Settings.Secure.LOCATION_MODE, locationMode,
                UserHandle.USER_SYSTEM);
    }

    private static final Set<String> PROFILE_OWNER_"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/UserRestrictionsParentTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.SensorPermissionGrantTest"	"testAdminCanGrantSensorsPermissions"	""	"1: permission"	"([2:/com/android/cts/deviceandprofileowner/SensorPermissionGrantTest.java]:[permission]:[2]:method_text:[() {        assertThat(mDevicePolicyManager.canAdminGrantSensorsPermissions()).isTrue();    }   ]) :|: public void testAdminCanGrantSensorsPermissions() {
        assertThat(mDevicePolicyManager.canAdminGrantSensorsPermissions()).isTrue();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/SensorPermissionGrantTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.SensorPermissionGrantTest"	"testAdminCannotGrantSensorsPermission"	""	"1: permission"	"([2:/com/android/cts/deviceandprofileowner/SensorPermissionGrantTest.java]:[permission]:[2]:method_text:[on() {        assertThat(mDevicePolicyManager.canAdminGrantSensorsPermissions()).isFalse();    }}]) :|: public void testAdminCannotGrantSensorsPermission() {
        assertThat(mDevicePolicyManager.canAdminGrantSensorsPermissions()).isFalse();
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/SensorPermissionGrantTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.deviceandprofileowner.userrestrictions.BaseUserRestrictionsTest"	"assertClearDefaultRestrictions"	""	"1: permission"	"([1:/com/android/cts/deviceandprofileowner/userrestrictions/BaseUserRestrictionsTest.java]:[permission]:[1]:method_text:[abledRestrictions();    /**     * Test restrictions that should be enabled by default     */   ]) :|: public void test/*
 *.
 */
package com.android.cts.deviceandprofileowner.userrestrictions;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Process;
import android.os.UserHandle;
import android.os.UserManager;

import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.cts.deviceandprofileowner.BaseDeviceAdminTest;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

public abstract class BaseUserRestrictionsTest extends BaseDeviceAdminTest {
    protected static final String[] ALL_USER_RESTRICTIONS = new String[]{
            UserManager.DISALLOW_CONFIG_WIFI,
            UserManager.DISALLOW_MODIFY_ACCOUNTS,
            UserManager.DISALLOW_INSTALL_APPS,
            UserManager.DISALLOW_UNINSTALL_APPS,
            UserManager.DISALLOW_SHARE_LOCATION,
            UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES,
            UserManager.DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY,
            UserManager.DISALLOW_CONFIG_BLUETOOTH,
            UserManager.DISALLOW_USB_FILE_TRANSFER,
            UserManager.DISALLOW_CONFIG_CREDENTIALS,
            UserManager.DISALLOW_REMOVE_USER,
            UserManager.DISALLOW_DEBUGGING_FEATURES,
            UserManager.DISALLOW_CONFIG_VPN,
            UserManager.DISALLOW_CONFIG_TETHERING,
            UserManager.DISALLOW_NETWORK_RESET,
            UserManager.DISALLOW_FACTORY_RESET,
            UserManager.DISALLOW_ADD_USER,
            UserManager.ENSURE_VERIFY_APPS,
            UserManager.DISALLOW_CONFIG_CELL_BROADCASTS,
            UserManager.DISALLOW_CONFIG_MOBILE_NETWORKS,
            UserManager.DISALLOW_APPS_CONTROL,
            UserManager.DISALLOW_MOUNT_PHYSICAL_MEDIA,
            UserManager.DISALLOW_UNMUTE_MICROPHONE,
            UserManager.DISALLOW_ADJUST_VOLUME,
            UserManage"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/userrestrictions/BaseUserRestrictionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.certinstaller.CertSelectionDelegateTest"	"finish"	""	"1: permission"	"([1:/com/android/cts/certinstaller/CertSelectionDelegateTest.java]:[permission]:[1]:method_text:[ void tearDown() throws Exception {        mActivity.finish();        super.tearDown();    }   ]) :|: public void test/*
 *.
 */
package com.android.cts.certinstaller;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.assertNull;

import android.app.Activity;
import android.app.admin.DelegatedAdminReceiver;
import android.app.admin.DevicePolicyManager;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.os.Process;
import android.security.KeyChain;
import android.security.KeyChainAliasCallback;
import android.support.test.uiautomator.UiDevice;
import android.test.InstrumentationTestCase;

import com.android.compatibility.common.util.FakeKeys.FAKE_RSA_1;

import java.io.ByteArrayInputStream;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.cert.Certificate;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * Tests a delegate app with DELEGATION_CERT_SELECTION receives the
 * {@link android.app.admin.DelegatedAdminReceiver#onChoosePrivateKeyAlias} callback when a
 * requesting app (in this case, ourselves) invokes {@link KeyChain#choosePrivateKeyAlias},
 * and is able to force a designated cert to be returned.
 *
 * This test is driven by hostside {@code DeviceAndProfileOwnerTest#testDelegationCertSelection},
 * which grants this app DELEGATION_CERT_SELECTION permission and executes tests in this class.
 */
public class CertSelectionDelegateTest extends InstrumentationTestCase {

    private static final long KEYCHAIN_TIMEOUT_MINS = 1;

    private Context mContext;
    private DevicePolicyManager mDpm;
    private Activity mActivity;"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/CertInstaller/src/com/android/cts/certinstaller/CertSelectionDelegateTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.certinstaller.DirectDelegatedCertInstallerTest"	"testAccessToDeviceIdentifiers"	""	"1: permission"	"([1:/com/android/cts/certinstaller/DirectDelegatedCertInstallerTest.java]:[permission]:[1]:method_text:[Exception e) {            fail(""Should have permission to access IMEI: "" + e);        }    }   ]) :|: public void testAccessToDeviceIdentifiers() {
        final String adminPackageName = ""com.android.cts.deviceandprofileowner"";
        if (mDpm.isDeviceOwnerApp(adminPackageName)) {
            validateCanAccessDeviceIdentifiers();
        } else {
            validateNoAccessToIdentifier();
        }
    }

    private void validateNoAccessToIdentifier() {
        assertThrows(SecurityException.class, () -> Build.getSerial());

        if (!mHasTelephony) {
            return;
        }

        assertWithMessage(""Telephony service must be available."")
                .that(mTelephonyManager).isNotNull();

        assertThrows(SecurityException.class, () -> mTelephonyManager.getImei());
    }

    public void validateCanAccessDeviceIdentifiers() {
        assertThat(Build.getSerial()).doesNotMatch(Build.UNKNOWN);

        if (!mHasTelephony) {
            return;
        }

        assertWithMessage(""Telephony service must be available."")
                .that(mTelephonyManager).isNotNull();

        try {
            mTelephonyManager.getImei();
        } catch (SecurityException e) {
            fail(""Should have permission to access IMEI: "" + e);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/CertInstaller/src/com/android/cts/certinstaller/DirectDelegatedCertInstallerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.managedprofile.UserManagerTest"	"dropShellPermissionIdentity"	""	"1: permission"	"([1:/com/android/cts/managedprofile/UserManagerTest.java]:[permission]:[1]:method_text:[xception {        mUiAutomation.dropShellPermissionIdentity();        super.tearDown();    }   ]) :|: public void test/*
 *.
 */

package com.android.cts.managedprofile;

import static com.google.common.truth.Truth.assertThat;

import android.app.UiAutomation;
import android.os.Process;
import android.os.UserHandle;
import android.os.UserManager;
import android.test.AndroidTestCase;

import androidx.test.platform.app.InstrumentationRegistry;

import java.util.HashSet;
import java.util.List;

public class UserManagerTest extends AndroidTestCase {

    private UserManager mUserManager;
    private UiAutomation mUiAutomation;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mUserManager = mContext.getSystemService(UserManager.class);
        mUiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
    }

    @Override
    protected void tearDown() throws Exception {
        mUiAutomation.dropShellPermissionIdentity();
        super.tearDown();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/UserManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.managedprofile.UserManagerTest"	"testCreateProfile_managedProfile"	""	"1: permission"	"([2:/com/android/cts/managedprofile/UserManagerTest.java]:[permission]:[2]:method_text:[be run as the managed profile     *  by com.android.cts.devicepolicy.ManagedProfileTest     */   ]) :|: public void testCreateProfile_managedProfile() {
        mUiAutomation.adoptShellPermissionIdentity(""android.permission.CREATE_USERS"");

        UserHandle newProfile = mUserManager.createProfile(""testProfile1"",
                UserManager.USER_TYPE_PROFILE_MANAGED, new HashSet<String>());
        assertThat(newProfile).isNotNull();

        List<UserHandle> profiles = mUserManager.getAllProfiles();
        assertThat(profiles).contains(newProfile);
    }

    /** This test should be run as the managed profile
     *  by com.android.cts.devicepolicy.ManagedProfileTest
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/UserManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.managedprofile.UserManagerTest"	"testIsProfileReturnsTrue_runAsProfile"	""	"1: permission"	"([2:/com/android/cts/managedprofile/UserManagerTest.java]:[permission]:[2]:method_text:[ be run as the parent profile     *  by com.android.cts.devicepolicy.ManagedProfileTest     */   ]) :|: public void testIsProfileReturnsTrue_runAsProfile() {
        mUiAutomation.adoptShellPermissionIdentity(""android.permission.INTERACT_ACROSS_USERS"");
        assertThat(mUserManager.isProfile()).isTrue();
    }

    /** This test should be run as the parent profile
     *  by com.android.cts.devicepolicy.ManagedProfileTest
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/UserManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.managedprofile.UserManagerTest"	"testIsProfileReturnsFalse_runAsPrimary"	""	"1: permission"	"([2:/com/android/cts/managedprofile/UserManagerTest.java]:[permission]:[2]:method_text:[.permission.INTERACT_ACROSS_USERS"");        assertThat(mUserManager.isProfile()).isFalse();    }}]) :|: public void testIsProfileReturnsFalse_runAsPrimary() {
        mUiAutomation.adoptShellPermissionIdentity(""android.permission.INTERACT_ACROSS_USERS"");
        assertThat(mUserManager.isProfile()).isFalse();
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/UserManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.managedprofile.DeviceIdentifiersTest"	"testProfileOwnerOnPersonalDeviceCannotGetDeviceIdentifiers"	""	"1: permission"	"([1:/com/android/cts/managedprofile/DeviceIdentifiersTest.java]:[permission]:[1]:method_text:[      }    }    private interface ThrowingProvider<T> {        T get() throws Throwable;    }}]) :|: public void testProfileOwnerOnPersonalDeviceCannotGetDeviceIdentifiers() {
        // The profile owner with the READ_PHONE_STATE permission should still receive a
        // SecurityException when querying for device identifiers if it's not on an
        // organization-owned device.
        TelephonyManager telephonyManager = (TelephonyManager) mContext.getSystemService(
                Context.TELEPHONY_SERVICE);
        // Allow the APIs to also return null if the telephony feature is not supported.
        boolean hasTelephonyFeature =
                mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_TELEPHONY);

        boolean mayReturnNull = !hasTelephonyFeature;

        assertAccessDenied(telephonyManager::getDeviceId, mayReturnNull);
        assertAccessDenied(telephonyManager::getImei, mayReturnNull);
        assertAccessDenied(telephonyManager::getMeid, mayReturnNull);
        assertAccessDenied(telephonyManager::getSubscriberId, mayReturnNull);
        assertAccessDenied(telephonyManager::getSimSerialNumber, mayReturnNull);
        assertAccessDenied(telephonyManager::getNai, mayReturnNull);
        assertAccessDenied(Build::getSerial, mayReturnNull);
    }

    private static <T> void assertAccessDenied(ThrowingProvider<T> provider,
            boolean mayReturnNull) {
        try {
            T object = provider.get();
            if (mayReturnNull) {
                assertNull(object);
            } else {
                fail(""Expected SecurityException, received "" + object);
            }
        } catch (SecurityException ignored) {
            // assertion succeeded
        } catch (Throwable th) {
            fail(""Expected SecurityException but was: "" + th);
        }
    }

    private interface ThrowingProvider<T> {
        T get() throws Throwable;
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/DeviceIdentifiersTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.managedprofile.CrossProfileTest"	"testSetCrossProfilePackages_sendsBroadcastWhenResettingAppOps_noAsserts"	""	"1: permission"	"([17:/com/android/cts/managedprofile/CrossProfileTest.java]:[permission]:[17]:method_text:[ new HashSet<>());    }    private static class NonAdminReceiver extends DeviceAdminReceiver {}}]) :|: public void testSetCrossProfilePackages_sendsBroadcastWhenResettingAppOps_noAsserts()
            throws Exception {
        mDevicePolicyManager.setCrossProfilePackages(
                ADMIN_RECEIVER_COMPONENT, ALL_CROSS_PROFILE_PACKAGES);
        explicitlySetInteractAcrossProfilesAppOps(MODE_ALLOWED);

        mDevicePolicyManager.setCrossProfilePackages(
                ADMIN_RECEIVER_COMPONENT, SUBLIST_CROSS_PROFILE_PACKAGES);
    }

    private void explicitlySetInteractAcrossProfilesAppOps(int mode) throws Exception {
        for (String packageName : ALL_CROSS_PROFILE_PACKAGES) {
            explicitlySetInteractAcrossProfilesAppOp(packageName, mode);
        }
    }

    private void explicitlySetInteractAcrossProfilesAppOp(String packageName, int mode)
            throws Exception {
        for (UserHandle profile : mUserManager.getUserProfiles()) {
            if (isPackageInstalledForUser(packageName, profile)) {
                explicitlySetInteractAcrossProfilesAppOp(packageName, mode, profile);
            }
        }
    }

    private boolean isPackageInstalledForUser(String packageName, UserHandle user) {
        try {
            sUiAutomation.adoptShellPermissionIdentity(INTERACT_ACROSS_USERS_PERMISSION);
            mContext.createContextAsUser(user, /* flags= */ 0).getPackageManager()
                    .getPackageInfo(packageName, /* flags= */ 0);
            return true;
        } catch (PackageManager.NameNotFoundException e) {
            return false;
        } finally {
            sUiAutomation.dropShellPermissionIdentity();
        }
    }

    private void explicitlySetInteractAcrossProfilesAppOp(
            String packageName, int mode, UserHandle userHandle) throws Exception {
        sUiAutomation.adoptShellPermissionIdentity(
                MANAGE_APP_OPS_MODES_PERMISSION,
                UPDATE_APP_OPS_STATS_PERMISSION,
                INTERACT_ACROSS_USERS_PERMISSION);
        mAppOpsManager.setUidMode(
                AppOps"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/CrossProfileTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.managedprofile.CrossProfileUtils"	"testAddManagedCanAccessParentFilters"	""	"1: permission"	"([1:/com/android/cts/managedprofile/CrossProfileUtils.java]:[permission]:[1]:method_text:[;        intentFilter.addAction(ACTION_OBSERVE_URI_CHANGE);        return intentFilter;    }   ]) :|: public void testAddManagedCanAccessParentFilters() {
        testRemoveAllFilters();

        final DevicePolicyManager dpm = (DevicePolicyManager) getContext().getSystemService(
                Context.DEVICE_POLICY_SERVICE);
        dpm.addCrossProfileIntentFilter(ADMIN_RECEIVER_COMPONENT, getIntentFilter(),
                DevicePolicyManager.FLAG_MANAGED_CAN_ACCESS_PARENT);
    }

    public IntentFilter getIntentFilter() {
        IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(ACTION_READ_FROM_URI);
        intentFilter.addAction(ACTION_WRITE_TO_URI);
        intentFilter.addAction(ACTION_TAKE_PERSISTABLE_URI_PERMISSION);
        intentFilter.addAction(ACTION_COPY_TO_CLIPBOARD);
        intentFilter.addAction(ACTION_NOTIFY_URI_CHANGE);
        intentFilter.addAction(ACTION_OBSERVE_URI_CHANGE);
        return intentFilter;
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/CrossProfileUtils.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.delegate.PermissionGrantDelegateTest"	"testCannotAccessApis"	""	"1: permission"	"([14:/com/android/cts/delegate/PermissionGrantDelegateTest.java]:[permission]:[14]:method_text:[   mDpm.getPermissionGrantState(null, TEST_APP_PKG, TEST_PERMISSION);                });    }   ]) :|: public void testCannotAccessApis() {
        assertFalse(""DelegateApp should not be a permisssion grant delegate"",
            amIPermissionGrantDelegate());

        // Exercise setPermissionPolicy.
        assertExpectException(SecurityException.class,
                ""Calling identity is not authorized"", () -> {
                    mDpm.setPermissionPolicy(null, PERMISSION_POLICY_AUTO_GRANT);
                });
        assertFalse(""Permission policy should not have been set"",
                PERMISSION_POLICY_AUTO_GRANT == mDpm.getPermissionPolicy(null));

        // Exercise setPermissionGrantState.
        assertExpectException(SecurityException.class,
                ""Calling identity is not authorized"", () -> {
                    mDpm.setPermissionGrantState(null, TEST_APP_PKG, TEST_PERMISSION,
                            PERMISSION_GRANT_STATE_GRANTED);
                });

        // Exercise getPermissionGrantState.
        assertExpectException(SecurityException.class,
                ""Calling identity is not authorized"", () -> {
                    mDpm.getPermissionGrantState(null, TEST_APP_PKG, TEST_PERMISSION);
                });
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DelegateApp/src/com/android/cts/delegate/PermissionGrantDelegateTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.delegate.PermissionGrantDelegateTest"	"testCanAccessApis"	""	"1: permission"	"([20:/com/android/cts/delegate/PermissionGrantDelegateTest.java]:[permission]:[20]:method_text:[gatedScopes(null, packageName);        return scopes.contains(DELEGATION_PERMISSION_GRANT);    }}]) :|: public void testCanAccessApis() {
        assertTrue(""DelegateApp is not a permission grant delegate"",
            amIPermissionGrantDelegate());

        // Exercise setPermissionPolicy.
        mDpm.setPermissionPolicy(null, PERMISSION_POLICY_AUTO_DENY);
        assertTrue(""Permission policy was not set"",
                PERMISSION_POLICY_AUTO_DENY == mDpm.getPermissionPolicy(null));

        // Exercise setPermissionGrantState.
        assertTrue(""Permission grant state was not set successfully"",
                mDpm.setPermissionGrantState(null, TEST_APP_PKG, TEST_PERMISSION,
                    PERMISSION_GRANT_STATE_DENIED));

        // Exercise getPermissionGrantState.
        assertEquals(""Permission grant state is not denied"", PERMISSION_GRANT_STATE_DENIED,
                mDpm.getPermissionGrantState(null, TEST_APP_PKG, TEST_PERMISSION));
    }

    private boolean amIPermissionGrantDelegate() {
        final String packageName = getInstrumentation().getContext().getPackageName();
        final List<String> scopes = mDpm.getDelegatedScopes(null, packageName);
        return scopes.contains(DELEGATION_PERMISSION_GRANT);
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DelegateApp/src/com/android/cts/delegate/PermissionGrantDelegateTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.DevicePolicySafetyCheckerIntegrationTester"	"isEmpty"	""	"1: permission"	"([4:/com/android/cts/devicepolicy/DevicePolicySafetyCheckerIntegrationTester.java]:[permission]:[4]:method_text:[        }    }    /**     * Tests {@link DevicePolicyManager#isSafeOperation(int)}.     */   ]) :|: public void test/*
 *.
 */
package com.android.cts.devicepolicy;

import static android.app.admin.DevicePolicyManager.OPERATION_LOCK_NOW;
import static android.app.admin.DevicePolicyManager.OPERATION_LOGOUT_USER;
import static android.app.admin.DevicePolicyManager.OPERATION_REMOVE_ACTIVE_ADMIN;
import static android.app.admin.DevicePolicyManager.OPERATION_REMOVE_KEY_PAIR;
import static android.app.admin.DevicePolicyManager.OPERATION_SAFETY_REASON_DRIVING_DISTRACTION;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_ALWAYS_ON_VPN_PACKAGE;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_MASTER_VOLUME_MUTED;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_PERMISSION_GRANT_STATE;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_PERMISSION_POLICY;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_RESTRICTIONS_PROVIDER;
import static android.app.admin.DevicePolicyManager.OPERATION_SET_USER_RESTRICTION;
import static android.app.admin.DevicePolicyManager.operationSafetyReasonToString;
import static android.app.admin.DevicePolicyManager.operationToString;

import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.fail;
import static org.testng.Assert.assertThrows;
import static org.testng.Assert.expectThrows;

import android.app.admin.DevicePolicyManager;
import android.app.admin.UnsafeStateException;
import android.content.ComponentName;
import android.content.Context;
import android.os.UserManager;
import android.util.Log;

import com.android.compatibility.common.util.ShellIdentityUtils;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Set;

/**
 * Helper class to test that DPM calls fail when determined by the
 * {@link android.app.admin.DevicePolicySafetyChecker}; it provides the base infra, so it can be
 * used by both device and profile owner tests.
 */
public class DevicePolicySafetyCheckerIntegration"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/common/src/com/android/cts/devicepolicy/DevicePolicySafetyCheckerIntegrationTester.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.devicepolicy.DevicePolicySafetyCheckerIntegrationTester"	"testOnOperationSafetyStateChanged"	""	"1: permission"	"([6:/com/android/cts/devicepolicy/DevicePolicySafetyCheckerIntegrationTester.java]:[permission]:[6]:method_text:[ssionsNoReturn(dpm,                (obj) -> obj.setNextOperationSafety(operation, reason));    }}]) :|: public void testOnOperationSafetyStateChanged(Context context, DevicePolicyManager dpm) {
        // Currently there's just one reason...
        int reason = OPERATION_SAFETY_REASON_DRIVING_DISTRACTION;
        // Operation doesn't really matter
        int operation = OPERATION_LOCK_NOW;
        Log.d(TAG, ""testOnOperationSafetyStateChanged(): dpm="" + dpm
                + "", reason="" + operationSafetyReasonToString(reason)
                + "", operation="" + operationToString(operation));
        OperationSafetyChangedCallback receiver = OperationSafetyChangedCallback.register(context);
        try {
            setOperationUnsafe(dpm, operation, reason);
            // Must force OneTimeSafetyChecker to generate the event by calling the unsafe operation
            assertThrows(UnsafeStateException.class, () -> dpm.lockNow());

            Log.d(TAG, ""Waiting isSafe=false event"");
            assertNextEvent(receiver, reason, /* isSafe= */ false);

            // OneTimeSafetyChecker automatically disables itself after one operation, which in turn
            // triggers another event
            Log.d(TAG, ""Waiting isSafe=true event"");
            assertNextEvent(receiver, reason, /* isSafe= */ true);
        } finally {
            receiver.unregister(context);
        }
    }

    private void assertNextEvent(OperationSafetyChangedCallback receiver,
            int reason, boolean isSafe) {
        OperationSafetyChangedEvent event = receiver.getNextEvent();
        Log.v(TAG, ""Received event: "" + event);
        assertWithMessage(""event (%s) reason"", event).that(event.reason).isEqualTo(reason);
        assertWithMessage(""event (%s) safety state"", event).that(event.isSafe).isEqualTo(isSafe);
    }

    /**
     * Gets the device / profile owner-specific operations.
     *
     * <p>By default it returns an empty array, but sub-classes can override to add its supported
     * operations.
     */
    protected int[] getSafetyAwareOperations() {
        return ne"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/common/src/com/android/cts/devicepolicy/DevicePolicySafetyCheckerIntegrationTester.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.crossprofileappstest.CrossProfileAppsStartActivityTest"	"testCannotStartActivityByIntentWithNoPermissions"	""	"1: permission"	"([2:/com/android/cts/crossprofileappstest/CrossProfileAppsStartActivityTest.java]:[permission]:[2]:method_text:[       mCrossProfileApps.startActivity(intent, mTargetUser, /* callingActivity= */ null);    }   ]) :|: (expected=SecurityException.class)
    public void testCannotStartActivityByIntentWithNoPermissions() {
        Intent intent = new Intent();
        intent.setComponent(MainActivity.getComponentName(mContext));
        ShellIdentityUtils.dropShellPermissionIdentity();

        mCrossProfileApps.startActivity(intent, mTargetUser, /* callingActivity= */ null);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/CrossProfileTestApps/CrossProfileAppsTest/src/com/android/cts/crossprofileappstest/CrossProfileAppsStartActivityTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.crossprofileappstest.CrossProfileAppsStartActivityTest"	"testCanStartActivityByIntentWithInteractAcrossProfilesPermission"	""	"1: permission"	"([3:/com/android/cts/crossprofileappstest/CrossProfileAppsStartActivityTest.java]:[permission]:[3]:method_text:[d in wrong user"",                String.valueOf(mUserSerialNumber), textView.getText());    }   ]) :|: 
    public void testCanStartActivityByIntentWithInteractAcrossProfilesPermission() {
        Intent intent = new Intent();
        intent.setComponent(MainActivity.getComponentName(mContext));
        ShellIdentityUtils.dropShellPermissionIdentity();

        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                mCrossProfileApps,
                crossProfileApps -> crossProfileApps.startActivity(
                        intent, mTargetUser, /* callingActivity= */ null),
                INTERACT_ACROSS_PROFILES);

        // Look for the text view to verify that MainActivity is started.
        UiObject2 textView = mDevice.wait(Until.findObject(By.res(ID_USER_TEXTVIEW)),
                TIMEOUT_WAIT_UI);
        assertNotNull(""Failed to start main activity in target user"", textView);
        assertEquals(""Main Activity is started in wrong user"",
                String.valueOf(mUserSerialNumber), textView.getText());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/CrossProfileTestApps/CrossProfileAppsTest/src/com/android/cts/crossprofileappstest/CrossProfileAppsStartActivityTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.crossprofileappstest.CrossProfileAppsStartActivityTest"	"testCanStartActivityByIntentWithInteractAcrossUsersPermission"	""	"1: permission"	"([3:/com/android/cts/crossprofileappstest/CrossProfileAppsStartActivityTest.java]:[permission]:[3]:method_text:[d in wrong user"",                String.valueOf(mUserSerialNumber), textView.getText());    }   ]) :|: 
    public void testCanStartActivityByIntentWithInteractAcrossUsersPermission() {
        Intent intent = new Intent();
        intent.setComponent(MainActivity.getComponentName(mContext));
        ShellIdentityUtils.dropShellPermissionIdentity();

        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                mCrossProfileApps,
                crossProfileApps -> crossProfileApps.startActivity(
                        intent, mTargetUser, /* callingActivity= */ null),
                INTERACT_ACROSS_USERS);

        // Look for the text view to verify that MainActivity is started.
        UiObject2 textView = mDevice.wait(Until.findObject(By.res(ID_USER_TEXTVIEW)),
                TIMEOUT_WAIT_UI);
        assertNotNull(""Failed to start main activity in target user"", textView);
        assertEquals(""Main Activity is started in wrong user"",
                String.valueOf(mUserSerialNumber), textView.getText());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/CrossProfileTestApps/CrossProfileAppsTest/src/com/android/cts/crossprofileappstest/CrossProfileAppsStartActivityTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.crossprofileappstest.CrossProfileAppsStartActivityTest"	"testCanStartActivityByIntentWithInteractAcrossUsersFullPermission"	""	"1: permission"	"([3:/com/android/cts/crossprofileappstest/CrossProfileAppsStartActivityTest.java]:[permission]:[3]:method_text:[ in wrong user"",                String.valueOf(mUserSerialNumber), textView.getText());    }   ]) :|: 
    public void testCanStartActivityByIntentWithInteractAcrossUsersFullPermission() {
        Intent intent = new Intent();
        intent.setComponent(MainActivity.getComponentName(mContext));
        ShellIdentityUtils.dropShellPermissionIdentity();

        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                mCrossProfileApps,
                crossProfileApps -> crossProfileApps.startActivity(
                        intent, mTargetUser, /* callingActivity= */ null),
                INTERACT_ACROSS_USERS_FULL);

        // Look for the text view to verify that MainActivity is started.
        UiObject2 textView = mDevice.wait(Until.findObject(By.res(ID_USER_TEXTVIEW)),
                TIMEOUT_WAIT_UI);
        assertNotNull(""Failed to start main activity in target user"", textView);
        assertEquals(""Main Activity is started in wrong user"",
                String.valueOf(mUserSerialNumber), textView.getText());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/CrossProfileTestApps/CrossProfileAppsTest/src/com/android/cts/crossprofileappstest/CrossProfileAppsStartActivityTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.crossprofileappstest.CrossProfileAppsStartActivityTest"	"testCannotStartActivityWithImplicitIntent"	""	"1: permission"	"([1:/com/android/cts/crossprofileappstest/CrossProfileAppsStartActivityTest.java]:[permission]:[1]:method_text:[               nonMainActivityImplicitIntent, mTargetUser, /* callingActivity= */ null));    }   ]) :|: (expected = NullPointerException.class)
    public void testCannotStartActivityWithImplicitIntent() {
        Intent nonMainActivityImplicitIntent = new Intent();
        nonMainActivityImplicitIntent.setAction(Intent.ACTION_VIEW);

        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                mCrossProfileApps,
                crossProfileApps -> crossProfileApps.startActivity(
                        nonMainActivityImplicitIntent, mTargetUser, /* callingActivity= */ null));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/CrossProfileTestApps/CrossProfileAppsTest/src/com/android/cts/crossprofileappstest/CrossProfileAppsStartActivityTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.crossprofileappstest.CrossProfileAppsStartActivityTest"	"testCanStartMainActivityByIntent"	""	"1: permission"	"([1:/com/android/cts/crossprofileappstest/CrossProfileAppsStartActivityTest.java]:[permission]:[1]:method_text:[fail(""unable to start main activity via CrossProfileApps#startActivity: "" + e);        }    }   ]) :|: 
    public void testCanStartMainActivityByIntent() {
        Intent mainActivityIntent = new Intent();
        mainActivityIntent.setComponent(MainActivity.getComponentName(mContext));

        try {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                    mCrossProfileApps,
                    crossProfileApps -> mCrossProfileApps.startActivity(
                            mainActivityIntent, mTargetUser, /* callingActivity= */ null));

            // Look for the text view to verify that MainActivity is started.
            UiObject2 textView = mDevice.wait(Until.findObject(By.res(ID_USER_TEXTVIEW)),
                    TIMEOUT_WAIT_UI);
            assertNotNull(""Failed to start main activity in target user"", textView);
            assertEquals(""Main Activity is started in wrong user"",
                    String.valueOf(mUserSerialNumber), textView.getText());
        } catch (Exception e) {
            fail(""unable to start main activity via CrossProfileApps#startActivity: "" + e);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/CrossProfileTestApps/CrossProfileAppsTest/src/com/android/cts/crossprofileappstest/CrossProfileAppsStartActivityTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.crossprofileappstest.CrossProfileAppsStartActivityTest"	"testCanStartMainActivityByIntent_withOptionsBundle"	""	"1: permission"	"([1:/com/android/cts/crossprofileappstest/CrossProfileAppsStartActivityTest.java]:[permission]:[1]:method_text:[fail(""unable to start main activity via CrossProfileApps#startActivity: "" + e);        }    }   ]) :|: 
    public void testCanStartMainActivityByIntent_withOptionsBundle() throws Exception {
        Intent mainActivityIntent = new Intent();
        mainActivityIntent.setComponent(MainActivity.getComponentName(mContext));

        try {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                    mCrossProfileApps,
                    crossProfileApps ->
                            mCrossProfileApps.startActivity(
                                    mainActivityIntent,
                                    mTargetUser,
                                    /* callingActivity= */ null,
                                    ActivityOptions.makeBasic().toBundle()));

            // Look for the text view to verify that MainActivity is started.
            UiObject2 textView = mDevice.wait(Until.findObject(By.res(ID_USER_TEXTVIEW)),
                    TIMEOUT_WAIT_UI);
            assertNotNull(""Failed to start main activity in target user"", textView);
            assertEquals(""Main Activity is started in wrong user"",
                    String.valueOf(mUserSerialNumber), textView.getText());
        } catch (Exception e) {
            fail(""unable to start main activity via CrossProfileApps#startActivity: "" + e);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/CrossProfileTestApps/CrossProfileAppsTest/src/com/android/cts/crossprofileappstest/CrossProfileAppsStartActivityTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.crossprofileappstest.CrossProfileAppsStartActivityTest"	"testCanStartNonMainActivityByIntent"	""	"1: permission"	"([1:/com/android/cts/crossprofileappstest/CrossProfileAppsStartActivityTest.java]:[permission]:[1]:method_text:[rify that the tasks     * are the same using the log messages printed by each activity.     */   ]) :|: 
    public void testCanStartNonMainActivityByIntent() {
        Intent nonMainActivityIntent = new Intent();
        nonMainActivityIntent.setComponent(NonMainActivity.getComponentName(mContext));

        try {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                    mCrossProfileApps,
                    crossProfileApps -> mCrossProfileApps.startActivity(
                            nonMainActivityIntent, mTargetUser, /* callingActivity= */ null));

            // Look for the text view to verify that NonMainActivity is started.
            UiObject2 textView = mDevice.wait(Until.findObject(By.res(ID_USER_TEXTVIEW_NONMAIN)),
                    TIMEOUT_WAIT_UI);
            assertNotNull(""Failed to start non-main activity in target user"", textView);
            assertEquals(""Non-Main Activity is started in wrong user"",
                    String.valueOf(mUserSerialNumber), textView.getText());
        } catch (Exception e) {
            fail(""unable to start non-main activity via CrossProfileApps#startActivity: "" + e);
        }
    }

    /**
     * Starts an activity in the same task in the target user. Asserts that the activity is
     * correctly started in the correct user, but the host-side test should verify that the tasks
     * are the same using the log messages printed by each activity.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/CrossProfileTestApps/CrossProfileAppsTest/src/com/android/cts/crossprofileappstest/CrossProfileAppsStartActivityTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.crossprofileappstest.CrossProfileAppsStartActivityTest"	"testStartActivityByIntent_noAsserts"	""	"1: permission"	"([1:/com/android/cts/crossprofileappstest/CrossProfileAppsStartActivityTest.java]:[permission]:[1]:method_text:[                       nonMainActivityIntent, mTargetUser, /* callingActivity= */ null));    }   ]) :|: 
    public void testStartActivityByIntent_noAsserts() throws Exception {
        Intent nonMainActivityIntent = new Intent();
        nonMainActivityIntent.setComponent(NonMainActivity.getComponentName(mContext));

        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                mCrossProfileApps,
                crossProfileApps -> mCrossProfileApps.startActivity(
                        nonMainActivityIntent, mTargetUser, /* callingActivity= */ null));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/CrossProfileTestApps/CrossProfileAppsTest/src/com/android/cts/crossprofileappstest/CrossProfileAppsStartActivityTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.crossprofileappstest.CrossProfileAppsStartActivityTest"	"testCanStartMainActivityByComponent"	""	"1: permission"	"([1:/com/android/cts/crossprofileappstest/CrossProfileAppsStartActivityTest.java]:[permission]:[1]:method_text:[fail(""unable to start main activity via CrossProfileApps#startActivity: "" + e);        }    }   ]) :|: 
    public void testCanStartMainActivityByComponent() {
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mCrossProfileApps,
                    crossProfileApps -> mCrossProfileApps.startActivity(
                            MainActivity.getComponentName(mContext), mTargetUser));

            // Look for the text view to verify that MainActivity is started.
            UiObject2 textView = mDevice.wait(Until.findObject(By.res(ID_USER_TEXTVIEW)),
                    TIMEOUT_WAIT_UI);
            assertNotNull(""Failed to start main activity in target user"", textView);
            assertEquals(""Main Activity is started in wrong user"",
                    String.valueOf(mUserSerialNumber), textView.getText());
        } catch (Exception e) {
            fail(""unable to start main activity via CrossProfileApps#startActivity: "" + e);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/CrossProfileTestApps/CrossProfileAppsTest/src/com/android/cts/crossprofileappstest/CrossProfileAppsStartActivityTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.crossprofileappstest.CrossProfileAppsStartActivityTest"	"testCanStartNonMainActivityByComponent"	""	"1: permission"	"([1:/com/android/cts/crossprofileappstest/CrossProfileAppsStartActivityTest.java]:[permission]:[1]:method_text:[(""unable to start non-main activity via CrossProfileApps#startActivity: "" + e);        }    }   ]) :|: 
    public void testCanStartNonMainActivityByComponent() {
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mCrossProfileApps,
                    crossProfileApps -> mCrossProfileApps.startActivity(
                            NonMainActivity.getComponentName(mContext), mTargetUser));

            // Look for the text view to verify that NonMainActivity is started.
            UiObject2 textView = mDevice.wait(Until.findObject(By.res(ID_USER_TEXTVIEW_NONMAIN)),
                    TIMEOUT_WAIT_UI);
            assertNotNull(""Failed to start non-main activity in target user"", textView);
            assertEquals(""Non-Main Activity is started in wrong user"",
                    String.valueOf(mUserSerialNumber), textView.getText());
        } catch (Exception e) {
            fail(""unable to start non-main activity via CrossProfileApps#startActivity: "" + e);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/CrossProfileTestApps/CrossProfileAppsTest/src/com/android/cts/crossprofileappstest/CrossProfileAppsStartActivityTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.crossprofileappstest.CrossProfileAppsStartActivityTest"	"testCanStartNotExportedActivityByIntent"	""	"1: permission"	"([1:/com/android/cts/crossprofileappstest/CrossProfileAppsStartActivityTest.java]:[permission]:[1]:method_text:[d in wrong user"",                String.valueOf(mUserSerialNumber), textView.getText());    }   ]) :|: 
    public void testCanStartNotExportedActivityByIntent() throws Exception {
        Intent nonExportedActivityIntent = new Intent();
        nonExportedActivityIntent.setComponent(NonExportedActivity.getComponentName(mContext));

        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                mCrossProfileApps,
                crossProfileApps -> mCrossProfileApps.startActivity(
                        nonExportedActivityIntent, mTargetUser, /* callingActivity= */ null));

        // Look for the text view to verify that NonExportedActivity is started.
        UiObject2 textView = mDevice.wait(Until.findObject(By.res(ID_USER_TEXTVIEW_NONMAIN)),
                TIMEOUT_WAIT_UI);
        assertNotNull(""Failed to start not exported activity in target user"", textView);
        assertEquals(""Not exported Activity is started in wrong user"",
                String.valueOf(mUserSerialNumber), textView.getText());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/CrossProfileTestApps/CrossProfileAppsTest/src/com/android/cts/crossprofileappstest/CrossProfileAppsStartActivityTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.crossprofileappstest.CrossProfileAppsPermissionToInteractTest"	"TestApis"	""	"1: permission"	"([12:/com/android/cts/crossprofileappstest/CrossProfileAppsPermissionToInteractTest.java]:[permission]:[12]:method_text:[ry.getInstrumentation().getUiAutomation()                .dropShellPermissionIdentity();    }   ]) :|: /*
 *.
 */

package com.android.cts.crossprofileappstest;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.fail;

import android.app.AppOpsManager;
import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.CrossProfileApps;
import android.content.pm.PackageManager;
import android.os.Binder;
import android.os.Bundle;
import android.os.UserHandle;
import android.os.UserManager;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.android.bedstead.nene.TestApis;
import com.android.bedstead.nene.permissions.PermissionContext;

import org.junit.After;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.Collections;

@RunWith(AndroidJUnit4.class)
public class CrossProfileAppsPermissionToInteractTest {
    public static final String MANAGE_APP_OPS_MODES_PERMISSION =
            ""android.permission.MANAGE_APP_OPS_MODES"";
    public static final String INTERACT_ACROSS_PROFILES_PERMISSION =
            ""android.permission.INTERACT_ACROSS_PROFILES"";
    public static final String INTERACT_ACROSS_USERS_PERMISSION =
            ""android.permission.INTERACT_ACROSS_USERS"";
    public static final String INTERACT_ACROSS_USERS_FULL_PERMISSION =
            ""android.permission.INTERACT_ACROSS_USERS_FULL"";
    public static final String ACTION_MANAGE_CROSS_PROFILE_ACCESS =
            ""android.settings.MANAGE_CROSS_PROFILE_ACCESS"";

    private static final ComponentName ADMIN_RECEIVER_COMPONENT =
            new ComponentName(
                    AdminReceiver.class.getPackage().getName(), AdminReceiver.class.getName());
    private static final String PARAM_CROSS_PROFILE_PACKAGE = ""crossProfilePackage"";
    private static final TestApis sTestApis = new TestApis();

    private final Context mContext = InstrumentationRegistry.getContext();
    private final Cros"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/CrossProfileTestApps/CrossProfileAppsTest/src/com/android/cts/crossprofileappstest/CrossProfileAppsPermissionToInteractTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.crossprofileappstest.CrossProfileAppsPermissionToInteractTest"	"testCanInteractAcrossProfiles_withCrossProfilesPermission_returnsTrue"	""	"1: permission"	"([7:/com/android/cts/crossprofileappstest/CrossProfileAppsPermissionToInteractTest.java]:[permission]:[7]:method_text:[            assertThat(mCrossProfileApps.canInteractAcrossProfiles()).isTrue();        }    }   ]) :|: 
    public void testCanInteractAcrossProfiles_withCrossProfilesPermission_returnsTrue() {
        // Ideally we want to grant the permission in the other profile instead of allowing the
        // appop, however UiAutomation#adoptShellPermission can't be used for multiple UIDs.
        setAppOpOnAllProfiles(AppOpsManager.MODE_ALLOWED, /* includeCallingProfile= */ false);
        setAppOpOnCurrentProfile(AppOpsManager.MODE_IGNORED);

        try (PermissionContext p = sTestApis.permissions().withPermission(
                INTERACT_ACROSS_PROFILES_PERMISSION)) {
            assertThat(mCrossProfileApps.canInteractAcrossProfiles()).isTrue();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/CrossProfileTestApps/CrossProfileAppsTest/src/com/android/cts/crossprofileappstest/CrossProfileAppsPermissionToInteractTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.crossprofileappstest.CrossProfileAppsPermissionToInteractTest"	"testCanInteractAcrossProfiles_withCrossUsersPermission_returnsTrue"	""	"1: permission"	"([7:/com/android/cts/crossprofileappstest/CrossProfileAppsPermissionToInteractTest.java]:[permission]:[7]:method_text:[            assertThat(mCrossProfileApps.canInteractAcrossProfiles()).isTrue();        }    }   ]) :|: 
    public void testCanInteractAcrossProfiles_withCrossUsersPermission_returnsTrue() {
        // Ideally we want to grant the permission in the other profile instead of allowing the
        // appop, however UiAutomation#adoptShellPermission can't be used for multiple UIDs.
        setAppOpOnAllProfiles(AppOpsManager.MODE_ALLOWED, /* includeCallingProfile= */ false);
        setAppOpOnCurrentProfile(AppOpsManager.MODE_IGNORED);

        try (PermissionContext p = sTestApis.permissions().withPermission(
                INTERACT_ACROSS_USERS_PERMISSION)) {
            assertThat(mCrossProfileApps.canInteractAcrossProfiles()).isTrue();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/CrossProfileTestApps/CrossProfileAppsTest/src/com/android/cts/crossprofileappstest/CrossProfileAppsPermissionToInteractTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.crossprofileappstest.CrossProfileAppsPermissionToInteractTest"	"testCanInteractAcrossProfiles_withCrossUsersFullPermission_returnsTrue"	""	"1: permission"	"([7:/com/android/cts/crossprofileappstest/CrossProfileAppsPermissionToInteractTest.java]:[permission]:[7]:method_text:[            assertThat(mCrossProfileApps.canInteractAcrossProfiles()).isTrue();        }    }   ]) :|: 
    public void testCanInteractAcrossProfiles_withCrossUsersFullPermission_returnsTrue() {
        // Ideally we want to grant the permission in the other profile instead of allowing the
        // appop, however UiAutomation#adoptShellPermission can't be used for multiple UIDs.
        setAppOpOnAllProfiles(AppOpsManager.MODE_ALLOWED, /* includeCallingProfile= */ false);
        setAppOpOnCurrentProfile(AppOpsManager.MODE_IGNORED);

        try (PermissionContext p = sTestApis.permissions().withPermission(
                INTERACT_ACROSS_USERS_FULL_PERMISSION)) {
            assertThat(mCrossProfileApps.canInteractAcrossProfiles()).isTrue();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/CrossProfileTestApps/CrossProfileAppsTest/src/com/android/cts/crossprofileappstest/CrossProfileAppsPermissionToInteractTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.crossprofileappstest.CrossProfileAppsPermissionToInteractTest"	"testSetCrossProfilePackages_noAsserts"	""	"1: permission"	"([9:/com/android/cts/crossprofileappstest/CrossProfileAppsPermissionToInteractTest.java]:[permission]:[9]:method_text:[ndException e) {                    // Do nothing                }            }        }    }}]) :|: 
    public void testSetCrossProfilePackages_noAsserts() {
        final DevicePolicyManager devicePolicyManager =
                (DevicePolicyManager) mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);
        devicePolicyManager.setCrossProfilePackages(
                ADMIN_RECEIVER_COMPONENT, Collections.singleton(getCrossProfilePackage()));
    }

    private String getCrossProfilePackage() {
        final Bundle testArguments = InstrumentationRegistry.getArguments();
        if (testArguments.containsKey(PARAM_CROSS_PROFILE_PACKAGE)) {
            try {
                return testArguments.getString(PARAM_CROSS_PROFILE_PACKAGE);
            } catch (NumberFormatException ignore) {
            }
        }
        fail(""cross profile package param not found."");
        return null;
    }

    private void setAppOpOnCurrentProfile(int mode) {
        try (PermissionContext p = sTestApis.permissions().withPermission(
                MANAGE_APP_OPS_MODES_PERMISSION)) {
            mAppOpsManager.setMode(AppOpsManager.OPSTR_INTERACT_ACROSS_PROFILES,
                    Binder.getCallingUid(), mContext.getPackageName(), mode);
        }
    }

    private void setAppOpOnAllProfiles(int mode) {
        setAppOpOnAllProfiles(mode, /* includeCallingProfile= */ true);
    }

    private void setAppOpOnAllProfiles(int mode, boolean includeCallingProfile) {
        try (PermissionContext p = sTestApis.permissions().withPermission(
                MANAGE_APP_OPS_MODES_PERMISSION, INTERACT_ACROSS_USERS_PERMISSION)) {
            for (UserHandle profile : mContext.getSystemService(
                    UserManager.class).getAllProfiles()) {
                if (!includeCallingProfile && profile.getIdentifier() == mContext.getUserId()) {
                    continue;
                }
                try {
                    final int uid = mContext.createContextAsUser(profile, /* flags= */ 0)
                            .getPackageManager().getPackageUid("	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/CrossProfileTestApps/CrossProfileAppsTest/src/com/android/cts/crossprofileappstest/CrossProfileAppsPermissionToInteractTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.crossprofilenopermissionappstest.CrossProfileAppsWithNoPermission"	"testCanRequestInteractAcrossProfiles_permissionNotRequested_returnsFalse"	""	"1: permission"	"([1:/com/android/cts/crossprofilenopermissionappstest/CrossProfileAppsWithNoPermission.java]:[permission]:[1]:method_text:[alse() {        assertThat(mCrossProfileApps.canRequestInteractAcrossProfiles()).isFalse();    }}]) :|: 
    public void testCanRequestInteractAcrossProfiles_permissionNotRequested_returnsFalse() {
        assertThat(mCrossProfileApps.canRequestInteractAcrossProfiles()).isFalse();
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/CrossProfileTestApps/CrossProfileAppsWithNoPermissionTest/src/com/android/cts/crossprofilenopermissionappstest/CrossProfileAppsWithNoPermission.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.dumpsys.cts.ProcessStatsDumpsysTest"	"testProcstatsOutput"	"CtsDumpsysHostTestCases"	"1: permission"	"([2:/android/dumpsys/cts/ProcessStatsDumpsysTest.java]:[permission]:[2]:method_text:[            + "".ProcStatsHelperServiceSub,"").replace(""$U"", uid),//                lines));    }}]) :|: public void testProcstatsOutput() throws Exception {
        if (true) {
            return; // TODO http://b/70858729
        }
        // First, run the helper app so that we have some interesting records in the output.
        checkWithProcStatsApp();

        String procstats = mDevice.executeShellCommand(""dumpsys procstats -c"");
        assertNotNull(procstats);
        assertTrue(procstats.length() > 0);

        final int sep24h = procstats.indexOf(""AGGREGATED OVER LAST 24 HOURS:"");
        final int sep3h = procstats.indexOf(""AGGREGATED OVER LAST 3 HOURS:"");

        assertTrue(""24 hour stats not found."", sep24h > 1);
        assertTrue(""3 hour stats not found."", sep3h > 1);

        // Current
        checkProcStateOutput(procstats.substring(0, sep24h), /*checkAvg=*/ true);

        // Last 24 hours
        checkProcStateOutput(procstats.substring(sep24h, sep3h), /*checkAvg=*/ false);

        // Last 3 hours
        checkProcStateOutput(procstats.substring(sep3h), /*checkAvg=*/ false);
    }

    private static String[] commaSplit(String line) {
        if (line.endsWith("","")) {
            line = line + "" "";
        }
        final String[] values = line.split("","");
        if ("" "".equals(values[values.length - 1])) {
            values[values.length - 1] = """";
        }
        return values;
    }

    private void checkProcStateOutput(String text, boolean checkAvg) throws Exception {
        final Set<String> seenTags = new HashSet<>();

        try (BufferedReader reader = new BufferedReader(
                new StringReader(text))) {

            String line;
            while ((line = reader.readLine()) != null) {
                if (line.isEmpty()) {
                    continue;
                }
                CLog.d(""Checking line: "" + line);

                String[] parts = commaSplit(line);
                seenTags.add(parts[0]);

                switch (parts[0]) {
                    case ""vers"":
                        assertEquals(2, par"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/dumpsys/src/android/dumpsys/cts/ProcessStatsDumpsysTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.webkit.WebViewHostSideMultipleProfileTest"	"testManagedProfile"	""	"3: android.software.managed android.software.managed_users managed_users"	"([1:/com/android/cts/webkit/WebViewHostSideMultipleProfileTest.java]:[managed_users]:[1]:method_text:[st-side test if the device-side test fails.                        .setCheckResults(true));    }}]) :|: 
    public void testManagedProfile() throws DeviceNotAvailableException, TargetSetupError {
        Assume.assumeTrue(isMultiUsersSupported() && isManagedProfileSupported());

        mUserId = createUser(SECONDARY_USER_NAME + System.currentTimeMillis(), true);
        startUser(mUserId);
        installTestApkForUser(mUserId);
        setProfileOwnwer(mUserId, PROFILE_OWNER_CLASS);

        assertWebViewDeviceTestAsUserPasses(this, ""testCreateWebViewAndNavigate"", mUserId);
    }

    private void installTestApkForUser(int userId) throws DeviceNotAvailableException {
        try {
            // TODO: it would be nice to use BaseHostJUnit4Test#installPackageAsUser instead.
            // However, this method removes installed package for all users after test is finished.
            // Therefore it breaks other tests that rely on targetprep which installs test APK once
            // before tests are executed.
            // See b/178367954.
            File file = getTestInformation().getDependencyFile(DEVICE_TEST_APK, true);

            // --dont-kill is to avoid the test app being killed if ActivityManager is slow to
            // respond to the install event.
            // See b/202824003.
            String output = mDevice.installPackageForUser(file, true, false, userId, ""--dont-kill"");
            if (output != null) {
                stopAndRemoveUser(userId);
                Assert.fail(""Failed to install test apk "" + output);
            }
        } catch (FileNotFoundException e) {
            stopAndRemoveUser(userId);
            Assert.fail(""Failed to install test apk "" + DEVICE_TEST_APK);
        }
    }

    private int createUser(String profileName, boolean isManaged)
            throws DeviceNotAvailableException {
        String command = isManaged ?
                ""pm create-user --profileOf %d --managed %s"" :
                ""pm create-user --profileOf %d %s"";
        command = String.format(command, mDevice.getPrimaryUserId(), profileName)"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/webkit/src/com/android/cts/webkit/WebViewHostSideMultipleProfileTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.jvmti.cts.JvmtiRedefineClassesTest"	"Finish"	""	"1: permission"	"([1:/android/jvmti/cts/JvmtiRedefineClassesTest.java]:[permission]:[1]:method_text:[             ""TRANSFORMED - post Finish private method call"",                }, output);    }   ]) :|: /*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package android.jvmti.cts;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertTrue;

import dalvik.system.InMemoryDexClassLoader;

import java.lang.ref.WeakReference;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Base64;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

import org.junit.Assert;
import org.junit.After;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import art.Main;

/**
 * Check redefineClasses-related functionality.
 */
public class JvmtiRedefineClassesTest extends JvmtiTestBase {

    @Before
    public void setUp() throws Exception {
        // make sure everything is cleared.
        setTransformationEvent(false);
        setPopTransformations(true);
        clearTransformations();
        // Make sure Transform.class is in the initial state.
        checkRedefinition(INITIAL_TRANSFORM);
    }

    static class RedefineError {
        public int expectedError;
        public Class<?> target;
        public byte[] dexData;

        public RedefineError(int err, Class<?> target, String base64string) {
            this(err, target, Base64.getDecoder().decode(base64string));
        }

        public RedefineError(int err, Class<?> klass, byte[] dex) {"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/jvmti/redefining/app/src/android/jvmti/cts/JvmtiRedefineClassesTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.jvmti.cts.JvmtiRunTestBasedTest"	"getTestNumber"	""	"1: permission"	"([1:/android/jvmti/cts/JvmtiRunTestBasedTest.java]:[permission]:[1]:method_text:[ata            .getBoolean(""android.jvmti.cts.needs_new_thread"", /*defaultValue*/false);    }   ]) :|: /*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package android.jvmti.cts;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;

import android.content.pm.PackageManager;
import android.util.Log;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

/**
 * Check redefineClasses-related functionality.
 */
public class JvmtiRunTestBasedTest extends JvmtiTestBase {

    private PrintStream oldOut, oldErr;
    private ByteArrayOutputStream bufferedOut, bufferedErr;

    private class TeeLogcatOutputStream extends OutputStream {
        private OutputStream os;
        private ByteArrayOutputStream lc_os;
        public TeeLogcatOutputStream(OutputStream os) {
            this.lc_os = new ByteArrayOutputStream();
            this.os = os;
        }
        public void write(int b) throws IOException {
            os.write(b);
            if (b == (int)'\n') {
              lc_os.flush();
              Log.i(mActivity.getPackageName(), ""Test Output: "" +  lc_os.toString());
              lc_os.reset();
            } else {
              lc_os.write(b);
            }
        }
        public void close() throws IOException"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/jvmti/base/run-test-based-app/src/android/jvmti/cts/JvmtiRunTestBasedTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.jvmti.cts.JvmtiTaggingTest"	"test"	""	"1: permission"	"([1:/android/jvmti/cts/JvmtiTaggingTest.java]:[permission]:[1]:method_text:[tTag(o2));        return new WeakReference<Object>(o1);    }    // Very simplistic tagging.   ]) :|: /*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package android.jvmti.cts;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import org.junit.Before;
import org.junit.Test;

import art.Main;

/**
 * Check tagging-related functionality.
 */
public class JvmtiTaggingTest extends JvmtiTestBase {

    private static WeakReference<Object> test() {
        Object o1 = new Object();
        Main.setTag(o1, 1);

        Object o2 = new Object();
        Main.setTag(o2, 2);

        assertEquals(1, Main.getTag(o1));
        assertEquals(2, Main.getTag(o2));

        Runtime.getRuntime().gc();
        Runtime.getRuntime().gc();

        assertEquals(1, Main.getTag(o1));
        assertEquals(2, Main.getTag(o2));

        Runtime.getRuntime().gc();
        Runtime.getRuntime().gc();

        Main.setTag(o1, 10);
        Main.setTag(o2, 20);

        assertEquals(10, Main.getTag(o1));
        assertEquals(20, Main.getTag(o2));

        return new WeakReference<Object>(o1);
    }

    // Very simplistic tagging."	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/jvmti/tagging/app/src/android/jvmti/cts/JvmtiTaggingTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.lib.app.StaticSharedLibsTests"	"dropShellPermissionIdentity"	""	"1: permission"	"([3:/android/os/lib/app/StaticSharedLibsTests.java]:[permission]:[3]:method_text:[tion()                .getUiAutomation()                .dropShellPermissionIdentity();    }   ]) :|: /*
 *.
 */

package android.os.lib.app;

import static com.android.compatibility.common.util.SystemUtil.runShellCommand;

import static com.google.common.truth.Truth.assertThat;

import android.Manifest;
import android.content.pm.PackageManager;
import android.content.pm.SharedLibraryInfo;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.android.cts.install.lib.Install;
import com.android.cts.install.lib.InstallUtils;
import com.android.cts.install.lib.TestApp;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.Optional;

/**
 * On-device tests driven by StaticSharedLibsHostTests.
 */
@RunWith(AndroidJUnit4.class)
public class StaticSharedLibsTests {

    private static final String STATIC_LIB_PROVIDER5_PKG = ""android.os.lib.provider"";
    private static final String STATIC_LIB_PROVIDER5_NAME = ""android.os.lib.provider_2"";
    private static final TestApp TESTAPP_STATIC_LIB_PROVIDER5 = new TestApp(
            ""TestStaticSharedLibProvider5"", STATIC_LIB_PROVIDER5_PKG, 1, /*isApex*/ false,
            ""CtsStaticSharedLibProviderApp5.apk"");

    @Before
    public void setUp() throws Exception {
        InstrumentationRegistry
                .getInstrumentation()
                .getUiAutomation()
                .adoptShellPermissionIdentity(
                        Manifest.permission.INSTALL_PACKAGES);
        clear();
    }

    @After
    public void tearDown() throws Exception {
        clear();
        InstrumentationRegistry
                .getInstrumentation()
                .getUiAutomation()
                .dropShellPermissionIdentity();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/os/test-apps/StaticSharedLibTestApp/src/android/os/lib/app/StaticSharedLibsTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.lib.consumer1.UseSharedLibraryTest"	"testDeclaredSharedLibrariesProperlyReported"	""	"1: permission"	"([1:/android/os/lib/consumer1/UseSharedLibraryTest.java]:[permission]:[1]:method_text:[Found);        assertTrue(""Did not find lib "" + LIB_NAME + "" version 5"", thirdLibFound);    }   ]) :|: 
    public void testDeclaredSharedLibrariesProperlyReported() throws Exception {
        PackageManager packageManager = InstrumentationRegistry.getContext().getPackageManager();
        List<SharedLibraryInfo> sharedLibs = SystemUtil.runWithShellPermissionIdentity(() ->
                packageManager.getDeclaredSharedLibraries(STATIC_LIB_PROVIDER_PKG, 0));

        assertNotNull(sharedLibs);

        boolean firstLibFound = false;
        boolean secondLibFound = false;
        boolean thirdLibFound = false;

        for (SharedLibraryInfo sharedLib : sharedLibs) {
            assertEquals(LIB_NAME, sharedLib.getName());
            VersionedPackage declaringPackage = sharedLib.getDeclaringPackage();
            assertEquals(STATIC_LIB_PROVIDER_PKG, declaringPackage.getPackageName());
            assertSame(SharedLibraryInfo.TYPE_STATIC, sharedLib.getType());

            List<VersionedPackage> dependentPackages = sharedLib.getDependentPackages();
            final long versionCode = sharedLib.getLongVersion();
            if (versionCode == 1) {
                firstLibFound = true;
                assertSame(1L, declaringPackage.getLongVersionCode());
                assertSame(1, dependentPackages.size());
                VersionedPackage dependentPackage = dependentPackages.get(0);
                assertEquals(STATIC_LIB_CONSUMER1_PKG, dependentPackage.getPackageName());
                assertSame(1L, dependentPackage.getLongVersionCode());
            } else if (versionCode == 2) {
                secondLibFound = true;
                assertSame(4L, declaringPackage.getLongVersionCode());
                assertTrue(dependentPackages.isEmpty());
            } else if (versionCode == 5) {
                thirdLibFound = true;
                assertSame(5L, declaringPackage.getLongVersionCode());
                assertSame(1, dependentPackages.size());
                VersionedPackage dependentPackage = dependentPackages.get(0);
                assertEquals(STA"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/os/test-apps/StaticSharedLibConsumerApp1/src/android/os/lib/consumer1/UseSharedLibraryTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.OsHostTests"	"testNonExportedActivities"	"CtsOsHostTestCases"	"1: permission"	"([1:/android/os/cts/OsHostTests.java]:[permission]:[1]:method_text:[ws Exception     */    @AppModeFull(reason = ""Instant apps may not start foreground services"")   ]) :|: public void testNonExportedActivities() throws Exception {
        // Run as unroot
        boolean wasRoot = mDevice.isAdbRoot();
        try {
            mDevice.disableAdbRoot();
            // Attempt to launch the non-exported activity in the test app
            CollectingOutputReceiver outputReceiver = new CollectingOutputReceiver();
            mDevice.executeShellCommand(START_NON_EXPORTED_ACTIVITY_COMMAND, outputReceiver);
            final String output = outputReceiver.getOutput();

            assertTrue(output.contains(""Permission Denial"") && output.contains("" not exported""));
        } finally {
            // Restore back to original root state
            if (wasRoot) {
                mDevice.enableAdbRoot();
            }
        }
    }

    /**
     * Test behavior of malformed Notifications w.r.t. foreground services
     * @throws Exception
     */
    @AppModeFull(reason = ""Instant apps may not start foreground services"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/os/src/android/os/cts/OsHostTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.StaticSharedLibsHostTests"	"testGetSharedLibrariesFullMode"	"CtsOsHostTestCases"	"1: permission"	"([1:/android/os/cts/StaticSharedLibsHostTests.java]:[permission]:[1]:method_text:[            reason = ""getDeclaredSharedLibraries() requires ACCESS_SHARED_LIBRARIES permission"")   ]) :|: public void testGetSharedLibrariesFullMode() throws Exception {
        doTestGetSharedLibraries();
    }

    private void doTestGetSharedLibraries() throws Exception {
        getDevice().uninstallPackage(STATIC_LIB_CONSUMER1_PKG);
        getDevice().uninstallPackage(STATIC_LIB_CONSUMER2_PKG);
        getDevice().uninstallPackage(STATIC_LIB_PROVIDER1_PKG);
        getDevice().uninstallPackage(STATIC_LIB_PROVIDER2_PKG);
        getDevice().uninstallPackage(STATIC_LIB_PROVIDER4_PKG);
        getDevice().uninstallPackage(STATIC_LIB_PROVIDER_RECURSIVE_PKG);
        try {
            // Install library dependency
            assertNull(install(STATIC_LIB_PROVIDER_RECURSIVE_APK));
            // Install the first library
            assertNull(install(STATIC_LIB_PROVIDER1_APK));
            // Install the second library
            assertNull(install(STATIC_LIB_PROVIDER2_APK));
            // Install the third library
            assertNull(install(STATIC_LIB_PROVIDER4_APK));
            // Install the first client
            assertNull(install(STATIC_LIB_CONSUMER1_APK));
            // Install the second client
            assertNull(install(STATIC_LIB_CONSUMER2_APK));
            // Ensure the first library has the REQUEST_INSTALL_PACKAGES app op
            getDevice().executeShellV2Command(""appops set ""
                    + STATIC_LIB_CONSUMER1_PKG
                    + "" REQUEST_INSTALL_PACKAGES allow"");
            // Ensure libraries are properly reported
            runDeviceTests(STATIC_LIB_CONSUMER1_PKG,
                    ""android.os.lib.consumer1.UseSharedLibraryTest"",
                    ""testSharedLibrariesProperlyReported"");
        } finally {
            getDevice().uninstallPackage(STATIC_LIB_CONSUMER1_PKG);
            getDevice().uninstallPackage(STATIC_LIB_CONSUMER2_PKG);
            getDevice().uninstallPackage(STATIC_LIB_PROVIDER1_PKG);
            getDevice().uninstallPackage(STATIC_LIB_PROVIDER2_PKG);
            getDevice().uninstallPackage"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/os/src/android/os/cts/StaticSharedLibsHostTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.appcompat.CompatChangesOverrideOnReleaseBuildTest"	"testPutPackageOverridesSecurityExceptionMissingPermission"	"CtsAppCompatHostTestCases"	"1: permission"	"([2:/com/android/cts/appcompat/CompatChangesOverrideOnReleaseBuildTest.java]:[permission]:[2]:method_text:[sChange.hasRawOverrides).isFalse();        assertThat(ctsChange.hasOverrides).isFalse();    }   ]) :|: public void testPutPackageOverridesSecurityExceptionMissingPermission() throws Exception {
        installPackage(""appcompat_preinstall_override_versioncode1_release.apk"", false);

        runDeviceCompatTest(TEST_PKG, "".CompatChangesTest"",
                ""putPackageOverrides_securityExceptionForNotHoldingPermission"",
                /*enabledChanges*/ImmutableSet.of(),
                /*disabledChanges*/ ImmutableSet.of());

        Change ctsChange = getOnDeviceChangeIdConfig(CTS_OVERRIDABLE_CHANGE_ID);
        assertWithMessage(""CTS specific change %s not found on device"", CTS_OVERRIDABLE_CHANGE_ID)
                .that(ctsChange).isNotNull();
        assertThat(ctsChange.hasRawOverrides).isFalse();
        assertThat(ctsChange.hasOverrides).isFalse();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appcompat/compatchanges/src/com/android/cts/appcompat/CompatChangesOverrideOnReleaseBuildTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.appcompat.CompatChangesOverrideOnReleaseBuildTest"	"testRemovePackageOverridesSecurityExceptionMissingPermission"	"CtsAppCompatHostTestCases"	"1: permission"	"([2:/com/android/cts/appcompat/CompatChangesOverrideOnReleaseBuildTest.java]:[permission]:[2]:method_text:[);        assertThat(ctsChange.rawOverrideStr).isEqualTo(""{"" + OVERRIDE_PKG + ""=true}"");    }   ]) :|: public void testRemovePackageOverridesSecurityExceptionMissingPermission() throws Exception {
        installPackage(""appcompat_preinstall_override_versioncode1_release.apk"", false);

        runDeviceCompatTest(TEST_PKG, "".CompatChangesTest"",
                ""removePackageOverrides_securityExceptionForNotHoldingPermission"",
                /*enabledChanges*/ImmutableSet.of(),
                /*disabledChanges*/ ImmutableSet.of());

        Change ctsChange = getOnDeviceChangeIdConfig(CTS_OVERRIDABLE_CHANGE_ID);
        assertWithMessage(""CTS specific change %s not found on device"", CTS_OVERRIDABLE_CHANGE_ID)
                .that(ctsChange).isNotNull();
        assertThat(ctsChange.hasRawOverrides).isTrue();
        assertThat(ctsChange.rawOverrideStr).isEqualTo(""{"" + OVERRIDE_PKG + ""=true}"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appcompat/compatchanges/src/com/android/cts/appcompat/CompatChangesOverrideOnReleaseBuildTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.device.blob.DataPersistenceTest"	"testCreateSession"	""	"1: permission"	"([2:/com/android/cts/device/blob/DataPersistenceTest.java]:[permission]:[2]:method_text:[UT_WAIT_FOR_IDLE_MS),                Exception.class, android.Manifest.permission.DUMP);    }   ]) :|: 
    public void testCreateSession() throws Exception {
        final FakeBlobData blobData = new FakeBlobData.Builder(mContext)
                .setRandomSeed(22)
                .setFileName(""test_blob_data"")
                .build();
        blobData.prepare();

        final long sessionId = createSession(blobData.getBlobHandle());
        assertThat(sessionId).isGreaterThan(0L);
        try (BlobStoreManager.Session session = mBlobStoreManager.openSession(sessionId)) {
            blobData.writeToSession(session, 0, PARTIAL_FILE_LENGTH_BYTES);
        }
        writeSessionIdToDisk(sessionId);
        writeBlobHandleToDisk(blobData.getBlobHandle());

        ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(mBlobStoreManager,
                (blobStoreManager) -> blobStoreManager.waitForIdle(TIMEOUT_WAIT_FOR_IDLE_MS),
                Exception.class, android.Manifest.permission.DUMP);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/blobstore/test-apps/BlobStoreHostTestHelper/src/com/android/cts/device/blob/DataPersistenceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.host.blob.BlobStoreMultiUserTest"	"isTrue"	"CtsBlobStoreHostTestCases"	"1: permission"	"([5:/com/android/cts/host/blob/BlobStoreMultiUserTest.java]:[permission]:[5]:method_text:[aryUserId > 0) {            testInfo.getDevice().removeUser(mSecondaryUserId);        }    }   ]) :|: /*
 *.
 */
package com.android.cts.host.blob;

import static org.junit.Assume.assumeTrue;

import static com.google.common.truth.Truth.assertThat;

import com.android.tradefed.invoker.TestInformation;
import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;
import com.android.tradefed.testtype.junit4.AfterClassWithInfo;
import com.android.tradefed.testtype.junit4.BeforeClassWithInfo;
import com.android.tradefed.util.Pair;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.Map;

@RunWith(DeviceJUnit4ClassRunner.class)
public class BlobStoreMultiUserTest extends BaseBlobStoreHostTest {
    private static final String TEST_CLASS = TARGET_PKG + "".DataCleanupTest"";

    private static int mPrimaryUserId;
    private static int mSecondaryUserId;

    @BeforeClassWithInfo
    public static void setUpClass(TestInformation testInfo) throws Exception {
        assumeTrue(""Multi-user is not supported on this device"",
                isMultiUserSupported(testInfo.getDevice()));

        mPrimaryUserId = testInfo.getDevice().getPrimaryUserId();
        mSecondaryUserId = testInfo.getDevice().createUser(""Test_User"");
        assertThat(testInfo.getDevice().startUser(mSecondaryUserId)).isTrue();
    }

    @Before
    public void setUp() throws Exception {
        for (String apk : new String[] {TARGET_APK, TARGET_APK_DEV}) {
            installPackageAsUser(apk, true /* grantPermissions */, mPrimaryUserId, ""-t"");
            installPackageAsUser(apk, true /* grantPermissions */, mSecondaryUserId, ""-t"");
        }
        // We would verify access with and without the app holding the assist role, so we don't
        // want the ACCESS_BLOBS_ACROSS_USERS permission to be granted by default.
        installPackageAsUser(TARGET_APK_ASSIST, false /* grantPermissions */, mPrimaryUserId);
        installPackageAsUser(TARGET_APK_ASSIST, false /* grantPermissions */, mSecondaryUserId);
    }

    @AfterClassWithInfo
    public static v"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/blobstore/src/com/android/cts/host/blob/BlobStoreMultiUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.host.blob.BlobStoreMultiUserTest"	"testBlobAccessAcrossUsers_withTestOnlyApp"	"CtsBlobStoreHostTestCases"	"1: permission"	"([1:/com/android/cts/host/blob/BlobStoreMultiUserTest.java]:[permission]:[1]:method_text:[_DEV, TEST_CLASS, ""testOpenBlob"", argsFromLastTestRun,                mSecondaryUserId);    }   ]) :|: 
    public void testBlobAccessAcrossUsers_withTestOnlyApp() throws Exception {
        Map<String, String> args = createArgs(Pair.create(KEY_ALLOW_PUBLIC, String.valueOf(1)));
        // Commit a blob.
        runDeviceTestAsUser(TARGET_PKG_DEV, TEST_CLASS, ""testCommitBlob"", args,
                mPrimaryUserId);
        Map<String, String> argsFromLastTestRun = createArgsFromLastTestRun();
        // Verify that previously committed blob can be accessed.
        runDeviceTestAsUser(TARGET_PKG, TEST_CLASS, ""testOpenBlob"", argsFromLastTestRun,
                mPrimaryUserId);
        // Verify that previously committed blob cannot be access from another user.
        runDeviceTestAsUser(TARGET_PKG, TEST_CLASS, ""testOpenBlob_shouldThrow"", argsFromLastTestRun,
                mSecondaryUserId);

        // Verify that previously committed blob can be accessed from another user holding
        // a priv permission.
        runDeviceTestAsUser(TARGET_PKG_DEV, TEST_CLASS, ""testOpenBlob"", argsFromLastTestRun,
                mSecondaryUserId);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/blobstore/src/com/android/cts/host/blob/BlobStoreMultiUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.host.blob.BlobStoreMultiUserTest"	"testBlobAccessAcrossUsers_withAssistRole"	"CtsBlobStoreHostTestCases"	"1: permission"	"([1:/com/android/cts/host/blob/BlobStoreMultiUserTest.java]:[permission]:[1]:method_text:[inally {            removeAssistRoleHolder(TARGET_PKG_ASSIST, mPrimaryUserId);        }    }   ]) :|: 
    public void testBlobAccessAcrossUsers_withAssistRole() throws Exception {
        // TODO: make it same signature
        Map<String, String> args = createArgs(Pair.create(KEY_ALLOW_SAME_SIGNATURE,
                String.valueOf(1)));
        try {
            addAssistRoleHolder(TARGET_PKG_ASSIST, mPrimaryUserId);
            // Commit a blob.
            runDeviceTestAsUser(TARGET_PKG_ASSIST, TEST_CLASS, ""testCommitBlob"", args,
                    mPrimaryUserId);
            Map<String, String> argsFromLastTestRun = createArgsFromLastTestRun();
            // Verify that previously committed blob cannot be access from another user.
            runDeviceTestAsUser(TARGET_PKG_ASSIST, TEST_CLASS, ""testOpenBlob_shouldThrow"",
                    argsFromLastTestRun, mSecondaryUserId);

            // Verify that previously committed blob can be accessed from another user holding
            // a priv permission.
            try {
                addAssistRoleHolder(TARGET_PKG_ASSIST, mSecondaryUserId);
                runDeviceTestAsUser(TARGET_PKG_ASSIST, TEST_CLASS, ""testOpenBlob"",
                        argsFromLastTestRun, mSecondaryUserId);
                runDeviceTestAsUser(TARGET_PKG, TEST_CLASS, ""testOpenBlob_shouldThrow"",
                        argsFromLastTestRun, mSecondaryUserId);
            } finally {
                removeAssistRoleHolder(TARGET_PKG_ASSIST, mSecondaryUserId);
            }
        } finally {
            removeAssistRoleHolder(TARGET_PKG_ASSIST, mPrimaryUserId);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/blobstore/src/com/android/cts/host/blob/BlobStoreMultiUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.host.blob.BlobStoreMultiUserTest"	"testBlobAccessAcrossUsers_withDifferentApps"	"CtsBlobStoreHostTestCases"	"1: permission"	"([1:/com/android/cts/host/blob/BlobStoreMultiUserTest.java]:[permission]:[1]:method_text:[} finally {            removeAssistRoleHolder(TARGET_PKG_ASSIST, mPrimaryUserId);        }    }}]) :|: 
    public void testBlobAccessAcrossUsers_withDifferentApps() throws Exception {
        Map<String, String> args = createArgs(Pair.create(KEY_ALLOW_PUBLIC,
                String.valueOf(1)));
        try {
            addAssistRoleHolder(TARGET_PKG_ASSIST, mPrimaryUserId);
            // Commit a blob.
            runDeviceTestAsUser(TARGET_PKG_ASSIST, TEST_CLASS, ""testCommitBlob"", args,
                    mPrimaryUserId);
            Map<String, String> argsFromLastTestRun = createArgsFromLastTestRun();
            // Verify that previously committed blob cannot be access from another user.
            runDeviceTestAsUser(TARGET_PKG_ASSIST, TEST_CLASS, ""testOpenBlob_shouldThrow"",
                    argsFromLastTestRun, mSecondaryUserId);

            // Verify that previously committed blob can be accessed from another user holding
            // a priv permission.
            runDeviceTestAsUser(TARGET_PKG_DEV, TEST_CLASS, ""testOpenBlob"", argsFromLastTestRun,
                    mSecondaryUserId);
        } finally {
            removeAssistRoleHolder(TARGET_PKG_ASSIST, mPrimaryUserId);
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/blobstore/src/com/android/cts/host/blob/BlobStoreMultiUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.session.cts.MediaSessionManagerHostTest"	"testGetActiveSessionsFull_managedProfiles"	"CtsMediaHostTestCases"	"3: android.software.managed android.software.managed_users managed_users"	"([1:/android/media/session/cts/MediaSessionManagerHostTest.java]:[managed_users]:[1]:method_text:[ediaSession"", newUser);        removeUser(newUser);    }    @AppModeFull    @RequiresDevice   ]) :|: public void testGetActiveSessionsFull_managedProfiles() throws Exception {
        testGetActiveSessions_managedProfiles(false);
    }

    private void testGetActiveSessions_managedProfiles(boolean instant)
            throws Exception {
        if (!hasDeviceFeature(""android.software.managed_users"")) {
            CLog.logAndDisplay(LogLevel.INFO,
                    ""Device doesn't support managed profiles. Test won't run."");
            return;
        }

        // Test if another managed profile can get the session.
        // Remove the created user first not to exceed system's user number limit.
        int newUser = createAndStartManagedProfile(getDevice().getPrimaryUserId());
        installAppAsUser(DEVICE_SIDE_TEST_APK, newUser, instant);
        setAllowGetActiveSessionForTest(true, newUser);
        runTestAsUser(""testGetActiveSessions_noMediaSession"", newUser);
        removeUser(newUser);
    }

    @AppModeFull
    @RequiresDevice"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/media/src/android/media/session/cts/MediaSessionManagerHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.session.cts.MediaSessionManagerHostTest"	"testIsTrusted_withoutEnabledNotificationListener_returnsFalse"	"CtsMediaHostTestCases"	"1: permission"	"([2:/android/media/session/cts/MediaSessionManagerHostTest.java]:[permission]:[2]:method_text:[     executeShellCommand(MediaSessionTestHelperConstants.buildControlCommand(userId, flag));    }}]) :|: public void testIsTrusted_withoutEnabledNotificationListener_returnsFalse()
            throws Exception {
        if (!canCreateAdditionalUsers(1)) {
            CLog.logAndDisplay(LogLevel.INFO,
                    ""Cannot create a new user. Skipping multi-user test cases."");
            return;
        }

        int newUserId = createAndStartUser();
        setAllowGetActiveSessionForTest(false, newUserId);
        installAppAsUser(DEVICE_SIDE_TEST_APK, newUserId, false);
        runTestAsUser(""testIsTrusted_returnsFalse"", newUserId);
    }

    private void runTest(String testMethodName) throws DeviceNotAvailableException {
        runTestAsUser(testMethodName, getDevice().getPrimaryUserId());
    }

    private void runTestAsUser(String testMethodName, int userId)
            throws DeviceNotAvailableException {
        runDeviceTests(DEVICE_SIDE_TEST_PKG, DEVICE_SIDE_TEST_CLASS, testMethodName, userId);
    }

    /**
     * Sets to allow or disallow the {@link #DEVICE_SIDE_TEST_CLASS}
     * to call {@link MediaSessionManager#getActiveSessions} for testing.
     * <p>{@link MediaSessionManager#getActiveSessions} bypasses the permission check if the
     * caller is the enabled notification listener. This method uses the behavior by allowing
     * this class as the notification listener service.
     * <p>Note that the device-side test {@link android.media.cts.MediaSessionManagerTest} already
     * covers the test for failing {@link MediaSessionManager#getActiveSessions} without the
     * permission nor the notification listener.
     */
    private void setAllowGetActiveSessionForTest(boolean allow, int userId) throws Exception {
        String notificationListener = DEVICE_SIDE_TEST_PKG + ""/"" + DEVICE_SIDE_TEST_CLASS;
        String command = ""cmd notification ""
                + ((allow) ? ""allow_listener "" : ""disallow_listener "")
                + notificationListener + "" "" + userId;
        executeShellCommand(command);
        if (allow) {"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/media/src/android/media/session/cts/MediaSessionManagerHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.metrics.cts.MediaMetricsAtomHostSideTests"	"turnOnForTesting"	""	"1: permission"	"([2:/android/media/metrics/cts/MediaMetricsAtomHostSideTests.java]:[permission]:[2]:method_text:[e property is set.        Thread.sleep(DEVICE_PROPERTY_PROPAGATION_DELAY_MICROSECONDS);    }   ]) :|: /*
 *.
 */

package android.media.metrics.cts;

import static com.google.common.truth.Truth.assertThat;

import android.content.Context;
import android.media.metrics.LogSessionId;
import android.media.metrics.MediaMetricsManager;
import android.media.metrics.NetworkEvent;
import android.media.metrics.PlaybackErrorEvent;
import android.media.metrics.PlaybackMetrics;
import android.media.metrics.PlaybackSession;
import android.media.metrics.PlaybackStateEvent;
import android.media.metrics.RecordingSession;
import android.media.metrics.TrackChangeEvent;
import android.os.Bundle;
import android.provider.DeviceConfig;

import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.SystemUtil;

import java.lang.InterruptedException;

import org.junit.Test;

public class MediaMetricsAtomHostSideTests {
    private static final String MEDIA_METRICS_MODE = ""media_metrics_mode"";
    private static final String PLAYER_METRICS_APP_ALLOWLIST = ""player_metrics_app_allowlist"";
    private static final String PLAYER_METRICS_APP_BLOCKLIST = ""player_metrics_app_blocklist"";
    private static final String PLAYER_METRICS_PER_APP_ATTRIBUTION_ALLOWLIST =
            ""player_metrics_per_app_attribution_allowlist"";
    private static final String PLAYER_METRICS_PER_APP_ATTRIBUTION_BLOCKLIST =
            ""player_metrics_per_app_attribution_blocklist"";
    private static final String MEDIA_METRICS_MODE_ON = ""1"";
    private static final String MEDIA_METRICS_MODE_BLOCKLIST = ""2"";
    private static final String MEDIA_METRICS_MODE_ALLOWLIST = ""3"";
    private static final String TEST_PKG = ""android.media.metrics.cts"";
    private static final int DEVICE_PROPERTY_PROPAGATION_DELAY_MICROSECONDS = 1000;

    static {
        System.loadLibrary(""CtsMediaMetricsHostTestAppJni"");
    }

    private static void resetProperties() throws InterruptedException {
        // ensure the event/metric is sent.
        Thread.sleep(1000);
        // see DeviceConfig#resetToDefault"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/media/app/MediaMetricsTest/src/android/media/metrics/cts/MediaMetricsAtomHostSideTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.metrics.cts.MediaMetricsAtomHostSideTests"	"testAppBlocklist"	""	"1: permission"	"([1:/android/media/metrics/cts/MediaMetricsAtomHostSideTests.java]:[permission]:[1]:method_text:[              .build();        s.reportPlaybackStateEvent(e);        resetProperties();    }   ]) :|: 
    public void testAppBlocklist() throws Exception {
        SystemUtil.runWithShellPermissionIdentity(() -> {
            DeviceConfig.setProperties(
                    new DeviceConfig.Properties.Builder(DeviceConfig.NAMESPACE_MEDIA)
                            .setString(MEDIA_METRICS_MODE, MEDIA_METRICS_MODE_BLOCKLIST)
                            .setString(PLAYER_METRICS_PER_APP_ATTRIBUTION_BLOCKLIST, """")
                            .setString(PLAYER_METRICS_APP_BLOCKLIST, TEST_PKG)
                            .build());
        });
        Thread.sleep(DEVICE_PROPERTY_PROPAGATION_DELAY_MICROSECONDS);
        Context context = InstrumentationRegistry.getContext();
        MediaMetricsManager manager = context.getSystemService(MediaMetricsManager.class);
        PlaybackSession s = manager.createPlaybackSession();
        PlaybackStateEvent e =
                new PlaybackStateEvent.Builder()
                        .setTimeSinceCreatedMillis(1763L)
                        .setState(PlaybackStateEvent.STATE_JOINING_FOREGROUND)
                        .setMetricsBundle(new Bundle())
                        .build();
        s.reportPlaybackStateEvent(e);
        resetProperties();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/media/app/MediaMetricsTest/src/android/media/metrics/cts/MediaMetricsAtomHostSideTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.metrics.cts.MediaMetricsAtomHostSideTests"	"testAttributionBlocklist"	""	"1: permission"	"([1:/android/media/metrics/cts/MediaMetricsAtomHostSideTests.java]:[permission]:[1]:method_text:[                 .build();        s.reportPlaybackMetrics(e);        resetProperties();    }   ]) :|: 
    public void testAttributionBlocklist() throws Exception {
        SystemUtil.runWithShellPermissionIdentity(() -> {
            DeviceConfig.setProperties(
                    new DeviceConfig.Properties.Builder(DeviceConfig.NAMESPACE_MEDIA)
                            .setString(MEDIA_METRICS_MODE, MEDIA_METRICS_MODE_BLOCKLIST)
                            .setString(PLAYER_METRICS_PER_APP_ATTRIBUTION_BLOCKLIST, TEST_PKG)
                            .setString(PLAYER_METRICS_APP_BLOCKLIST, """")
                            .build());
        });
        Thread.sleep(DEVICE_PROPERTY_PROPAGATION_DELAY_MICROSECONDS);
        Context context = InstrumentationRegistry.getContext();
        MediaMetricsManager manager = context.getSystemService(MediaMetricsManager.class);
        PlaybackSession s = manager.createPlaybackSession();
        PlaybackMetrics e =
                new PlaybackMetrics.Builder()
                        .setMediaDurationMillis(233L)
                        .setStreamSource(PlaybackMetrics.STREAM_SOURCE_NETWORK)
                        .setStreamType(PlaybackMetrics.STREAM_TYPE_OTHER)
                        .setPlaybackType(PlaybackMetrics.PLAYBACK_TYPE_LIVE)
                        .setDrmType(PlaybackMetrics.DRM_TYPE_WIDEVINE_L1)
                        .setContentType(PlaybackMetrics.CONTENT_TYPE_MAIN)
                        .setPlayerName(""ExoPlayer"")
                        .setPlayerVersion(""1.01x"")
                        .setVideoFramesPlayed(1024)
                        .setVideoFramesDropped(32)
                        .setAudioUnderrunCount(22)
                        .setNetworkBytesRead(102400)
                        .setLocalBytesRead(2000)
                        .setNetworkTransferDurationMillis(6000)
                        .setDrmSessionId(new byte[] {2, 3, 3, 10})
                        .setMetricsBundle(new Bundle())
                        .addExperimentId(123)
                        .build();
        s.reportPlaybackM"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/media/app/MediaMetricsTest/src/android/media/metrics/cts/MediaMetricsAtomHostSideTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.metrics.cts.MediaMetricsAtomHostSideTests"	"testAppAllowlist"	""	"1: permission"	"([1:/android/media/metrics/cts/MediaMetricsAtomHostSideTests.java]:[permission]:[1]:method_text:[              .build();        s.reportPlaybackStateEvent(e);        resetProperties();    }   ]) :|: 
    public void testAppAllowlist() throws Exception {
        SystemUtil.runWithShellPermissionIdentity(() -> {
            DeviceConfig.setProperties(
                    new DeviceConfig.Properties.Builder(DeviceConfig.NAMESPACE_MEDIA)
                            .setString(MEDIA_METRICS_MODE, MEDIA_METRICS_MODE_ALLOWLIST)
                            .setString(PLAYER_METRICS_PER_APP_ATTRIBUTION_ALLOWLIST, """")
                            .setString(PLAYER_METRICS_APP_ALLOWLIST, TEST_PKG)
                            .build());
        });
        Thread.sleep(DEVICE_PROPERTY_PROPAGATION_DELAY_MICROSECONDS);
        Context context = InstrumentationRegistry.getContext();
        MediaMetricsManager manager = context.getSystemService(MediaMetricsManager.class);
        PlaybackSession s = manager.createPlaybackSession();
        PlaybackStateEvent e =
                new PlaybackStateEvent.Builder()
                        .setTimeSinceCreatedMillis(1763L)
                        .setState(PlaybackStateEvent.STATE_JOINING_FOREGROUND)
                        .setMetricsBundle(new Bundle())
                        .build();
        s.reportPlaybackStateEvent(e);
        resetProperties();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/media/app/MediaMetricsTest/src/android/media/metrics/cts/MediaMetricsAtomHostSideTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.metrics.cts.MediaMetricsAtomHostSideTests"	"testAttributionAllowlist"	""	"1: permission"	"([1:/android/media/metrics/cts/MediaMetricsAtomHostSideTests.java]:[permission]:[1]:method_text:[  resetProperties();    }    /**     * Open aaudio mmap output stream and then close     */   ]) :|: 
    public void testAttributionAllowlist() throws Exception {
        SystemUtil.runWithShellPermissionIdentity(() -> {
            DeviceConfig.setProperties(
                    new DeviceConfig.Properties.Builder(DeviceConfig.NAMESPACE_MEDIA)
                            .setString(MEDIA_METRICS_MODE, MEDIA_METRICS_MODE_ALLOWLIST)
                            .setString(PLAYER_METRICS_PER_APP_ATTRIBUTION_ALLOWLIST, TEST_PKG)
                            .setString(PLAYER_METRICS_APP_ALLOWLIST, """")
                            .build());
        });
        Thread.sleep(DEVICE_PROPERTY_PROPAGATION_DELAY_MICROSECONDS);
        Context context = InstrumentationRegistry.getContext();
        MediaMetricsManager manager = context.getSystemService(MediaMetricsManager.class);
        PlaybackSession s = manager.createPlaybackSession();
        PlaybackMetrics e =
                new PlaybackMetrics.Builder()
                        .setMediaDurationMillis(233L)
                        .setStreamSource(PlaybackMetrics.STREAM_SOURCE_NETWORK)
                        .setStreamType(PlaybackMetrics.STREAM_TYPE_OTHER)
                        .setPlaybackType(PlaybackMetrics.PLAYBACK_TYPE_LIVE)
                        .setDrmType(PlaybackMetrics.DRM_TYPE_WIDEVINE_L1)
                        .setContentType(PlaybackMetrics.CONTENT_TYPE_MAIN)
                        .setPlayerName(""ExoPlayer"")
                        .setPlayerVersion(""1.01x"")
                        .setVideoFramesPlayed(1024)
                        .setVideoFramesDropped(32)
                        .setAudioUnderrunCount(22)
                        .setNetworkBytesRead(102400)
                        .setLocalBytesRead(2000)
                        .setNetworkTransferDurationMillis(6000)
                        .setDrmSessionId(new byte[] {2, 3, 3, 10})
                        .setMetricsBundle(new Bundle())
                        .addExperimentId(123)
                        .build();
        s.reportPlaybackM"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/media/app/MediaMetricsTest/src/android/media/metrics/cts/MediaMetricsAtomHostSideTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.provider.cts.contacts.testapp.CallLogDirectBootTest"	"testShadowCallComposerPicture"	""	"1: permission"	"([2:/android/provider/cts/contacts/testapp/CallLogDirectBootTest.java]:[permission]:[2]:method_text:[;        mDevice.waitForIdle();        mDevice.pressHome();        mDevice.waitForIdle();    }}]) :|: public void testShadowCallComposerPicture() throws Exception {
        BootReceiver.waitForBootComplete(mDe, BootReceiver.LOCKED_BOOT_COMPLETE,60000);
        Log.i(LOG_TAG, ""Locked boot complete received, starting test"");

        byte[] expected = readResourceDrawable(mDe, R.drawable.cupcake);
        Log.i(LOG_TAG, ""read drawable from resources"");


        getInstrumentation().getUiAutomation().adoptShellPermissionIdentity();
        try {
            // While still locked, write a picture to the call log, assuming it ends up in the shadow.
            CompletableFuture<Pair<Uri, CallLog.CallComposerLoggingException>> resultFuture =
                    new CompletableFuture<>();
            Pair<Uri, CallLog.CallComposerLoggingException> result;
            try (InputStream inputStream =
                         mDe.getResources().openRawResource(R.drawable.cupcake)) {
                CallLog.storeCallComposerPicture(
                        mDe.createContextAsUser(android.os.Process.myUserHandle(), 0),
                        inputStream,
                        Executors.newSingleThreadExecutor(),
                        new OutcomeReceiver<Uri, CallLog.CallComposerLoggingException>() {
                            @Override
                            public void onResult(@NonNull Uri result) {
                                resultFuture.complete(Pair.create(result, null));
                            }

                            @Override
                            public void onError(CallLog.CallComposerLoggingException error) {
                                resultFuture.complete(Pair.create(null, error));
                            }
                        });
                result = resultFuture.get(CONTENT_RESOLVER_TIMEOUT_MS, TimeUnit.MILLISECONDS);
            }
            if (result.second != null) {
                fail(""Got error "" + result.second.getErrorCode() + "" when storing image"");
            }
            Log.i(LOG_TAG, ""successfull"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/calllog/app/src/android/provider/cts/contacts/testapp/CallLogDirectBootTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.device.cts.TelephonyTest"	"testListenerRegistrationWithChangeEnabled"	""	"1: permission"	"([1:/android/telephony/device/cts/TelephonyTest.java]:[permission]:[1]:method_text:[it.MILLISECONDS);        assertTrue(""Never got anything on the extra listener"", result);    }   ]) :|: 
    public void testListenerRegistrationWithChangeEnabled() throws Throwable {
        // Register a bunch of filler listeners first so that we hit the cap
        List<PhoneStateListener> fillerListeners = registerFillerListeners();
        if (fillerListeners == null) {
            return;
        }

        TelephonyRegistryManager telephonyRegistryManager = InstrumentationRegistry.getContext()
                .getSystemService(TelephonyRegistryManager.class);

        LinkedBlockingQueue<Boolean> queue = new LinkedBlockingQueue<>(1);
        PhoneStateListener testListener = new PhoneStateListener(new HandlerExecutor(mHandler)) {
            @Override
            public void onCallStateChanged(int state, String number) {
                queue.offer(true);
            }
        };

        try {
            mTelephonyManager.listen(testListener, PhoneStateListener.LISTEN_CALL_STATE);
            fail(""Expected an IllegalStateException"");
        } catch (IllegalStateException e) {
            // expected
        }

        // Now, deregister one of the fillers and try that again. This time it should succeed
        mTelephonyManager.listen(fillerListeners.get(0), PhoneStateListener.LISTEN_NONE);

        mTelephonyManager.listen(testListener, PhoneStateListener.LISTEN_CALL_STATE);
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(telephonyRegistryManager,
                (trm) -> trm.notifyCallStateChangedForAllSubscriptions(
                        TelephonyManager.CALL_STATE_IDLE, ""12345678""));

        Boolean result = queue.poll(TEST_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
        assertTrue(""Never got anything on the extra listener"", result);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/telephony/devicetest/src/android/telephony/device/cts/TelephonyTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.device.cts.TelephonyTest"	"testListenerRegistrationWithChangeDisabled"	""	"1: permission"	"([2:/android/telephony/device/cts/TelephonyTest.java]:[permission]:[2]:method_text:[              l, PhoneStateListener.LISTEN_SERVICE_STATE));        return fillerListeners;    }}]) :|: 
    public void testListenerRegistrationWithChangeDisabled() throws Throwable {
        if (registerFillerListeners() == null) {
            return;
        }

        TelephonyRegistryManager telephonyRegistryManager = InstrumentationRegistry.getContext()
                .getSystemService(TelephonyRegistryManager.class);

        LinkedBlockingQueue<Boolean> queue = new LinkedBlockingQueue<>(1);
        PhoneStateListener testListener = new PhoneStateListener(new HandlerExecutor(mHandler)) {
            @Override
            public void onCallStateChanged(int state, String number) {
                queue.offer(true);
            }
        };

        mTelephonyManager.listen(testListener, PhoneStateListener.LISTEN_CALL_STATE);
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(telephonyRegistryManager,
                (trm) -> trm.notifyCallStateChangedForAllSubscriptions(
                        TelephonyManager.CALL_STATE_IDLE, ""12345678""));

        Boolean result = queue.poll(TEST_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
        assertTrue(""Never got anything on the extra listener"", result);
    }

    private List<PhoneStateListener> registerFillerListeners() {
        int registrationLimit = ShellIdentityUtils.invokeStaticMethodWithShellPermissions(() ->
                DeviceConfig.getInt(DeviceConfig.NAMESPACE_TELEPHONY,
                        TelephonyCallback.FLAG_PER_PID_REGISTRATION_LIMIT,
                        TelephonyCallback.DEFAULT_PER_PID_REGISTRATION_LIMIT));
        if (registrationLimit < 1) {
            // Don't test anything if the limit is too small
            return null;
        }
        List<PhoneStateListener> fillerListeners = Stream.generate(
                () -> new PhoneStateListener(new HandlerExecutor(mHandler)))
                .limit(registrationLimit)
                .collect(Collectors.toList());
        fillerListeners.forEach((l) -> mTelephonyManager.listen(
                l, PhoneStateListener.LISTEN"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/telephony/devicetest/src/android/telephony/device/cts/TelephonyTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.car.cts.PreCreateUsersHostTest"	"testAppsAreNotInstalledOnPreCreatedGuestAfterReboot"	"CtsCarHostTestCases"	"1: permission"	"([1:/android/car/cts/PreCreateUsersHostTest.java]:[permission]:[1]:method_text:[* Verifies a pre-created user have same packages as non-precreated users.     */    @Presubmit   ]) :|: 
    public void testAppsAreNotInstalledOnPreCreatedGuestAfterReboot() throws Exception {
        appsAreNotInstalledOnPreCreatedUserTest(/* isGuest= */ true, /* afterReboot= */ true);
    }

    private void appsAreNotInstalledOnPreCreatedUserTest(boolean isGuest,
            boolean afterReboot) throws Exception {
        deletePreCreatedUsers();
        requiresExtraUsers(1);

        int initialUserId = getCurrentUserId();
        int preCreatedUserId = preCreateUser(isGuest);

        installPackageAsUser(APP_APK, /* grantPermission= */ false, initialUserId);

        assertAppInstalledForUser(APP_PKG, initialUserId);
        assertAppNotInstalledForUser(APP_PKG, preCreatedUserId);

        if (afterReboot) {
            restartSystem();

            // Checks again
            assertAppInstalledForUser(APP_PKG, initialUserId);
            assertAppNotInstalledForUser(APP_PKG, preCreatedUserId);
        }
        convertPreCreatedUser(isGuest, preCreatedUserId);
        assertAppNotInstalledForUser(APP_PKG, preCreatedUserId);
    }

    /**
     * Verifies a pre-created user have same packages as non-precreated users.
     */
    @Presubmit"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/car/src/android/car/cts/PreCreateUsersHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.car.cts.PreCreateUsersHostTest"	"testAppPermissionsPreCreatedUserPackages"	"CtsCarHostTestCases"	"1: permission"	"([2:/android/car/cts/PreCreateUsersHostTest.java]:[permission]:[2]:method_text:[ Verifies a pre-created guest have same packages as non-precreated users.     */    @Presubmit   ]) :|: 
    public void testAppPermissionsPreCreatedUserPackages() throws Exception {
        appPermissionsPreCreatedUserPackagesTest(/* isGuest= */ false, /* afterReboot= */ false);
    }

    /**
     * Verifies a pre-created guest have same packages as non-precreated users.
     */
    @Presubmit"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/car/src/android/car/cts/PreCreateUsersHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.car.cts.PreCreateUsersHostTest"	"testAppPermissionsPreCreatedGuestPackages"	"CtsCarHostTestCases"	"1: permission"	"([2:/android/car/cts/PreCreateUsersHostTest.java]:[permission]:[2]:method_text:[* Verifies a pre-created user have same packages as non-precreated users.     */    @Presubmit   ]) :|: 
    public void testAppPermissionsPreCreatedGuestPackages() throws Exception {
        appPermissionsPreCreatedUserPackagesTest(/* isGuest= */ true, /* afterReboot= */ false);
    }

    /**
     * Verifies a pre-created user have same packages as non-precreated users.
     */
    @Presubmit"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/car/src/android/car/cts/PreCreateUsersHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.car.cts.PreCreateUsersHostTest"	"testAppPermissionsPreCreatedUserPackagesAfterReboot"	"CtsCarHostTestCases"	"1: permission"	"([2:/android/car/cts/PreCreateUsersHostTest.java]:[permission]:[2]:method_text:[ Verifies a pre-created guest have same packages as non-precreated users.     */    @Presubmit   ]) :|: 
    public void testAppPermissionsPreCreatedUserPackagesAfterReboot() throws Exception {
        appPermissionsPreCreatedUserPackagesTest(/* isGuest= */ false, /* afterReboot= */ true);
    }

    /**
     * Verifies a pre-created guest have same packages as non-precreated users.
     */
    @Presubmit"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/car/src/android/car/cts/PreCreateUsersHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.car.cts.PreCreateUsersHostTest"	"testAppPermissionsPreCreatedGuestPackagesAfterReboot"	"CtsCarHostTestCases"	"1: permission"	"([14:/android/car/cts/PreCreateUsersHostTest.java]:[permission]:[14]:method_text:[ystem to make sure PackageManager preserves the installed bit        restartSystemServer();    }}]) :|: 
    public void testAppPermissionsPreCreatedGuestPackagesAfterReboot() throws Exception {
        appPermissionsPreCreatedUserPackagesTest(/* isGuest= */ true, /* afterReboot= */ true);
    }

    private void appPermissionsPreCreatedUserPackagesTest(boolean isGuest, boolean afterReboot)
            throws Exception {
        deletePreCreatedUsers();
        requiresExtraUsers(2);

        // Create a normal reference user
        int referenceUserId = isGuest
                ? createGuestUser(""PreCreatedUsersTest_Reference_Guest"")
                : createFullUser(""PreCreatedUsersTest_Reference_User"");
        // Some permissions (e.g. Role permission) are given only after initialization.
        switchUser(referenceUserId);
        waitUntilUserPermissionsIsReady(referenceUserId);
        Map<String, List<String>> refPkgMap = getPackagesAndPermissionsForUser(referenceUserId);

        // There can be just one guest by default, so remove it now otherwise
        // convertPreCreatedUser() below will fail
        if (isGuest && !afterReboot) {
            removeUser(referenceUserId);
        }

        int preCreatedUserId = preCreateUser(isGuest);

        if (afterReboot) {
            restartSystem();
        }

        convertPreCreatedUser(isGuest, preCreatedUserId);
        // Some permissions (e.g. Role permission) are given only after initialization.
        switchUser(preCreatedUserId);
        waitUntilUserPermissionsIsReady(preCreatedUserId);
        Map<String, List<String>> actualPkgMap = getPackagesAndPermissionsForUser(preCreatedUserId);

        List<String> errors = new ArrayList<>();
        for (String pkg: refPkgMap.keySet()) {
            addError(errors, () ->
                    assertWithMessage(""permissions state mismatch for %s"", pkg)
                            .that(actualPkgMap.get(pkg))
                            .isEqualTo(refPkgMap.get(pkg)));
        }
        assertWithMessage(""found %s error"", errors.size()).that(errors).isEmpty()"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/car/src/android/car/cts/PreCreateUsersHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.server.cts.ProcStatsProtoTest"	"testDump"	"CtsIncidentHostTestCases"	"1: permission"	"([1:/com/android/server/cts/ProcStatsProtoTest.java]:[permission]:[1]:method_text:[ assertTrue(N > 0);        assertTrue(containsTestApp); // found test app in procstats dump    }}]) :|: public void testDump() throws Exception {
        installPackage(DEVICE_SIDE_TEST_APK, /* grantPermissions= */ true);
        int retries = 3;
        do {
            getDevice().executeShellCommand(
                ""am start -n com.android.server.cts.procstats/.SimpleActivity"");
        } while (!checkLogcatForText(TEST_APP_TAG, TEST_APP_LOG, WAIT_MS) && retries-- > 0);

        final ProcessStatsServiceDumpProto dump = getDump(ProcessStatsServiceDumpProto.parser(),
                ""dumpsys procstats --proto"");

        int N = dump.getProcstatsNow().getProcessStatsCount();
        boolean containsTestApp = false;
        for (int i = 0; i < N; i++) {
            ProcessStatsProto ps = dump.getProcstatsNow().getProcessStats(i);
            if (DEVICE_SIDE_TEST_PACKAGE.equals(ps.getProcess())) {
                containsTestApp = true;
            }
        }

        assertTrue(N > 0);
        assertTrue(containsTestApp); // found test app in procstats dump
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/incident/src/com/android/server/cts/ProcStatsProtoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.server.cts.ActivityManagerIncidentTest"	"testDumpServices"	"CtsIncidentHostTestCases"	"1: permission"	"([4:/com/android/server/cts/ActivityManagerIncidentTest.java]:[permission]:[4]:method_text:[eDescriptor()));        }    }    /**     * Tests activity manager dumps processes.     */   ]) :|: public void testDumpServices() throws Exception {
        final ActivityManagerServiceDumpServicesProto dump = getDump(
                ActivityManagerServiceDumpServicesProto.parser(),
                ""dumpsys activity --proto service"");
        ActiveServicesProto activeServices = dump.getActiveServices();
        assertTrue(activeServices.getServicesByUsersCount() > 0);

        for (ServicesByUser perUserServices : activeServices.getServicesByUsersList()) {
            assertTrue(perUserServices.getServiceRecordsCount() >= 0);
            for (ServiceRecordProto service : perUserServices.getServiceRecordsList()) {
                assertFalse(service.getShortName().isEmpty());
                assertFalse(service.getPackageName().isEmpty());
                assertFalse(service.getProcessName().isEmpty());
                assertFalse(service.getAppinfo().getBaseDir().isEmpty());
                assertFalse(service.getAppinfo().getDataDir().isEmpty());
            }
        }

        verifyActivityManagerServiceDumpServicesProto(dump, PRIVACY_NONE);
    }

    static void verifyActivityManagerServiceDumpServicesProto(ActivityManagerServiceDumpServicesProto dump, final int filterLevel) throws Exception {
        for (ServicesByUser sbu : dump.getActiveServices().getServicesByUsersList()) {
            for (ServiceRecordProto srp : sbu.getServiceRecordsList()) {
                verifyServiceRecordProto(srp, filterLevel);
            }
        }
    }

    private static void verifyServiceRecordProto(ServiceRecordProto srp, final int filterLevel) throws Exception {
        if (filterLevel == PRIVACY_AUTO) {
            assertTrue(srp.getAppinfo().getBaseDir().isEmpty());
            assertTrue(srp.getAppinfo().getResDir().isEmpty());
            assertTrue(srp.getAppinfo().getDataDir().isEmpty());
        } else {
            assertFalse(srp.getAppinfo().getBaseDir().isEmpty());
            assertFalse(srp.getAppinfo().getDataDir().isEmpty());
        }
        for (S"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/incident/src/com/android/server/cts/ActivityManagerIncidentTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.server.cts.GraphicsStatsValidationTest"	"killTestApp"	"CtsIncidentHostTestCases"	"1: permission"	"([1:/com/android/server/cts/GraphicsStatsValidationTest.java]:[permission]:[1]:method_text:[eyevent KEYCODE_WAKEUP"");        getDevice().executeShellCommand(""wm dismiss-keyguard"");    }   ]) :|: public void test/*
 *.
 */
package com.android.server.cts;

import static com.google.common.truth.Truth.assertThat;

import android.platform.test.annotations.RequiresDevice;
import android.service.GraphicsStatsHistogramBucketProto;
import android.service.GraphicsStatsJankSummaryProto;
import android.service.GraphicsStatsProto;
import android.service.GraphicsStatsServiceDumpProto;

import com.android.tradefed.device.CollectingByteOutputReceiver;
import com.google.common.collect.Range;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

// Although this test does not directly test performance, it does indirectly require consistent
// performance for the ""good"" frames. Although pass-through GPU virtual devices should have
// sufficient performance to pass OK, not all virtual devices do. So restrict this to physical
// devices.
@RequiresDevice
public class GraphicsStatsValidationTest extends ProtoDumpTestCase {
    private static final String TAG = ""GraphicsStatsValidationTest"";

    private static final String DEVICE_SIDE_TEST_APK = ""CtsGraphicsStatsApp.apk"";
    private static final String DEVICE_SIDE_TEST_PACKAGE
            = ""com.android.server.cts.device.graphicsstats"";

    @Override
    protected void tearDown() throws Exception {
        getDevice().uninstallPackage(DEVICE_SIDE_TEST_PACKAGE);
        super.tearDown();
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        installPackage(DEVICE_SIDE_TEST_APK, /* grantPermissions= */ true);
        turnScreenOn();
        // Ensure that we have a starting point for our stats
        runDeviceTests(DEVICE_SIDE_TEST_PACKAGE, "".SimpleDrawFrameTests"",
                ""testNothing"");
        // Kill to ensure that stats persist/merge across process death
        killTestApp();
    }

    private void turnScreenOn() throws Exception {
        getDevice().executeShellCommand(""input keyevent KEYCODE_WAKEUP"");
        getDevice().executeShellCommand(""wm di"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/incident/src/com/android/server/cts/GraphicsStatsValidationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.server.cts.PackageIncidentTest"	"testPackageServiceDump"	"CtsIncidentHostTestCases"	"1: permission"	"([2:/com/android/server/cts/PackageIncidentTest.java]:[permission]:[2]:method_text:[dump.getMessagesList()) {                assertTrue(msg.isEmpty());            }        }    }}]) :|: public void testPackageServiceDump() throws Exception {
        final long st = System.currentTimeMillis();

        installPackage(DEVICE_SIDE_TEST_APK, /* grantPermissions= */ true);

        // Find the package UID, version code, and version string.
        final Matcher matcher =
                execCommandAndFind(
                        ""dumpsys package "" + DEVICE_SIDE_TEST_PACKAGE,
                        ""userId=(\\d+).*versionCode=(\\d+).*versionName=([^\\n]*)"",
                        Pattern.DOTALL);
        final int uid = Integer.parseInt(matcher.group(1));
        final int versionCode = Integer.parseInt(matcher.group(2));
        final String versionString = matcher.group(3).trim();

        final PackageServiceDumpProto dump =
                getDump(PackageServiceDumpProto.parser(), ""dumpsys package --proto"");

        PackageProto testPackage = null;
        for (PackageProto pkg : dump.getPackagesList()) {
            if (pkg.getName().equals(DEVICE_SIDE_TEST_PACKAGE)) {
                testPackage = pkg;
                break;
            }
        }

        assertNotNull(testPackage);
        assertEquals(testPackage.getName(), DEVICE_SIDE_TEST_PACKAGE);
        assertEquals(testPackage.getUid(), uid);
        assertEquals(testPackage.getVersionCode(), versionCode);
        assertEquals(testPackage.getVersionString(), versionString);
        assertPositive(""install_time_ms"", testPackage.getInstallTimeMs());
        assertEquals(testPackage.getInstallTimeMs(), testPackage.getUpdateTimeMs());
        assertEquals(testPackage.getSplits(0).getName(), ""base"");
        assertEquals(testPackage.getSplits(0).getRevisionCode(), 0);
        assertNotNull(testPackage.getUserPermissionsList());

        UserInfoProto testUser = testPackage.getUsers(0);
        assertEquals(testUser.getId(), 0);
        assertEquals(testUser.getInstallType(),
                PackageProto.UserInfoProto.InstallType.FULL_APP_INSTALL);
        assertFalse(testUser.getIsHidden()"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/incident/src/com/android/server/cts/PackageIncidentTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.server.cts.BatteryStatsValidationTest"	"testAlarms"	"CtsIncidentHostTestCases"	"1: permission"	"([1:/com/android/server/cts/BatteryStatsValidationTest.java]:[permission]:[1]:method_text:[               ""am start -n com.android.server.cts.device.batterystats/.SimpleActivity"");    }   ]) :|: public void testAlarms() throws Exception {
        batteryOnScreenOff();

        installPackage(DEVICE_SIDE_TEST_APK, /* grantPermissions= */ true);

        runDeviceTests(DEVICE_SIDE_TEST_PACKAGE, "".BatteryStatsAlarmTest"", ""testAlarms"");

        assertValueRange(""wua"", ""*walarm*:com.android.server.cts.device.batterystats.ALARM"",
                5, 3, 3);

        batteryOffScreenOn();
    }

    private void startSimpleActivity() throws Exception {
        getDevice().executeShellCommand(
                ""am start -n com.android.server.cts.device.batterystats/.SimpleActivity"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/incident/src/com/android/server/cts/BatteryStatsValidationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.server.cts.ErrorsTest"	"testThrowException"	"CtsIncidentHostTestCases"	"1: permission"	"([1:/com/android/server/cts/ErrorsTest.java]:[permission]:[1]:method_text:[unDeviceTests(DEVICE_SIDE_TEST_PACKAGE, "".ErrorsTests"",                ""testException"");    }   ]) :|: public void testThrowException() throws Exception {
        installPackage(DEVICE_SIDE_TEST_APK, /* grantPermissions= */ true);

        runDeviceTests(DEVICE_SIDE_TEST_PACKAGE, "".ErrorsTests"",
                ""testException"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/incident/src/com/android/server/cts/ErrorsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.server.cts.ErrorsTest"	"testANR"	"CtsIncidentHostTestCases"	"1: permission"	"([1:/com/android/server/cts/ErrorsTest.java]:[permission]:[1]:method_text:[     runDeviceTests(DEVICE_SIDE_TEST_PACKAGE, "".ErrorsTests"",                ""testANR"");    }   ]) :|: public void testANR() throws Exception {
        installPackage(DEVICE_SIDE_TEST_APK, /* grantPermissions= */ true);

        runDeviceTests(DEVICE_SIDE_TEST_PACKAGE, "".ErrorsTests"",
                ""testANR"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/incident/src/com/android/server/cts/ErrorsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.server.cts.ErrorsTest"	"testNativeCrash"	"CtsIncidentHostTestCases"	"1: permission"	"([1:/com/android/server/cts/ErrorsTest.java]:[permission]:[1]:method_text:[DeviceTests(DEVICE_SIDE_TEST_PACKAGE, "".ErrorsTests"",                ""testNativeCrash"");    }   ]) :|: public void testNativeCrash() throws Exception {
        installPackage(DEVICE_SIDE_TEST_APK, /* grantPermissions= */ true);

        runDeviceTests(DEVICE_SIDE_TEST_PACKAGE, "".ErrorsTests"",
                ""testNativeCrash"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/incident/src/com/android/server/cts/ErrorsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.server.cts.ErrorsTest"	"testTombstone"	"CtsIncidentHostTestCases"	"1: permission"	"([1:/com/android/server/cts/ErrorsTest.java]:[permission]:[1]:method_text:[  runDeviceTests(DEVICE_SIDE_TEST_PACKAGE, "".ErrorsTests"",                ""testTombstone"");    }}]) :|: public void testTombstone() throws Exception {
        installPackage(DEVICE_SIDE_TEST_APK, /* grantPermissions= */ true);

        runDeviceTests(DEVICE_SIDE_TEST_PACKAGE, "".ErrorsTests"",
                ""testTombstone"");
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/incident/src/com/android/server/cts/ErrorsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appwidget.cts.AppWidgetTest"	"testCleanup"	""	"1: permission"	"([4:/android/appwidget/cts/AppWidgetTest.java]:[permission]:[4]:method_text:[ion() throws Exception {        runShellCommand(GRANT_BIND_APP_WIDGET_PERMISSION_COMMAND);    }}]) :|: public void testCleanup() throws Exception {
        Log.d(TAG, ""deleting host"");
        grantBindAppWidgetPermission();
        AppWidgetHost host = new AppWidgetHost(mContext, HOST_ID);
        host.deleteHost();
    }

    private void setupWidget(AppWidgetProviderInfo prov, Bundle options, boolean bindWidget) throws Exception {
        // We want to bind widgets.
        grantBindAppWidgetPermission();

        // Create a host and start listening.
        AppWidgetHost host = new AppWidgetHost(mContext, HOST_ID);
        host.deleteHost();
        host.startListening();

        AppWidgetManager mgr = getAppWidgetManager();

        // Initially we have no widgets.
        assertEquals(0, mgr.getAppWidgetIds(prov.provider).length);

        // Allocate the first widget id to bind.
        int appWidgetId = host.allocateAppWidgetId();

        if (bindWidget) {
            // Bind the widget.
            getAppWidgetManager().bindAppWidgetIdIfAllowed(appWidgetId,
                prov.getProfile(), prov.provider, options);

            assertEquals(1, mgr.getAppWidgetIds(prov.provider).length);
        }
    }

    private ComponentName getFirstWidgetComponent() {
        return new ComponentName(mContext.getPackageName(),
                FirstAppWidgetProvider.class.getName());
    }

    private ComponentName getSecondWidgetComponent() {
        return new ComponentName(mContext.getPackageName(),
                SecondAppWidgetProvider.class.getName());
    }

    private ArrayList<String> runShellCommand(String command) throws Exception {
        ParcelFileDescriptor pfd = getInstrumentation().getUiAutomation()
                .executeShellCommand(command);

        ArrayList<String> ret = new ArrayList<>();
        // Read the input stream fully.
        try (BufferedReader r = new BufferedReader(
                new InputStreamReader(new ParcelFileDescriptor.AutoCloseInputStream(pfd)))) {
            String line;
            while ((line = r.readLine()) !="	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/incident/apps/boundwidgetapp/src/android/appwidget/cts/AppWidgetTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.server.cts.device.batterystats.BatteryStatsRadioPowerStateTest"	"testReportMobileRadioPowerState"	""	"1: permission"	"([3:/com/android/server/cts/device/batterystats/BatteryStatsRadioPowerStateTest.java]:[permission]:[3]:method_text:[rentMobileRadio, UID);            mUiAutomation.dropShellPermissionIdentity();        }    }   ]) :|: 
    public void testReportMobileRadioPowerState() throws Exception {
        // Expect fail w/o UPDATE_DEVICE_STATS permission.
        assertThrows(SecurityException.class, () -> mBsm.reportMobileRadioPowerState(true, UID));

        mUiAutomation.adoptShellPermissionIdentity();
        final NetworkCapabilities activeNc = mCm.getNetworkCapabilities(mCm.getActiveNetwork());
        final boolean expectedCurrentMobileRadio = (activeNc == null) ? false :
                activeNc.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR);
        try {
            // Skip other information before testing to reduce the information contained in the dump
            // result.
            final long time = SystemClock.elapsedRealtime();
            final String cmd = ""dumpsys batterystats --history-start "" + time;
            // Mobile radio power stats only updates when:
            // 1. the radio state is changed, and
            // 2. the radio power is inactive.
            // Thus, trigger twice with different radio power state to ensure that it updates.
            mBsm.reportMobileRadioPowerState(!expectedCurrentMobileRadio, UID);
            mBsm.reportMobileRadioPowerState(expectedCurrentMobileRadio, UID);
            final String dump = runShellCommand(mInstrumentation, cmd);
            assertTrue(Pattern.compile(PATTERN_MOBILE).matcher(dump).find());
        } finally {
            // Restore state
            mBsm.reportMobileRadioPowerState(expectedCurrentMobileRadio, UID);
            mUiAutomation.dropShellPermissionIdentity();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/incident/apps/batterystatsapp/src/com/android/server/cts/device/batterystats/BatteryStatsRadioPowerStateTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.server.cts.device.batterystats.BatteryStatsRadioPowerStateTest"	"testReportWifiRadioPowerState"	""	"1: permission"	"([3:/com/android/server/cts/device/batterystats/BatteryStatsRadioPowerStateTest.java]:[permission]:[3]:method_text:[edCurrentWifiRadio, UID);            mUiAutomation.dropShellPermissionIdentity();        }    }}]) :|: 
    public void testReportWifiRadioPowerState() throws Exception {
        // Expect fail w/o UPDATE_DEVICE_STATS permission.
        assertThrows(SecurityException.class, () -> mBsm.reportWifiRadioPowerState(true, UID));

        mUiAutomation.adoptShellPermissionIdentity();
        final NetworkCapabilities activeNc = mCm.getNetworkCapabilities(mCm.getActiveNetwork());
        final boolean expectedCurrentWifiRadio = (activeNc == null) ? false :
                activeNc.hasTransport(NetworkCapabilities.TRANSPORT_WIFI);
        try {
            // Skip other information before testing to reduce the information contained in the dump
            // result.
            final long time = SystemClock.elapsedRealtime();
            final String cmd = ""dumpsys batterystats --history-start "" + time;
            mBsm.reportWifiRadioPowerState(!expectedCurrentWifiRadio, UID);
            final String dump = runShellCommand(mInstrumentation, cmd);
            assertTrue(Pattern.compile(PATTERN_WIFI).matcher(dump).find());
        } finally {
            // Restore state
            mBsm.reportWifiRadioPowerState(expectedCurrentWifiRadio, UID);
            mUiAutomation.dropShellPermissionIdentity();
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/incident/apps/batterystatsapp/src/com/android/server/cts/device/batterystats/BatteryStatsRadioPowerStateTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.security.cts.FileSystemPermissionTest"	"testDevHwRandomPermissions"	"CtsSecurityHostTestCases"	"1: permission"	"([2:/android/security/cts/FileSystemPermissionTest.java]:[permission]:[2]:method_text:[[4]);        assertEquals(""Wrong device minor on "" + HW_RNG_DEVICE, ""183"", outputWords[5]);    }}]) :|: public void testDevHwRandomPermissions() throws Exception {
        if (!mDevice.doesFileExist(HW_RNG_DEVICE)) {
            // Hardware RNG device is missing. This is OK because it is not required to be exposed
            // on all devices.
            return;
        }

        // This test asserts that, if present, /dev/hw_random must:
        //
        // 1. Have ownership root:root
        // 2. Have permissions 0600 (the kernel default). Only the kernel hwrng
        //    thread needs access to the HW RNG output. Neither apps nor system
        //    code should use it directly.
        // 3. Be a character device with major:minor 10:183 (the kernel
        //    default).

        // That translates to `ls -l` output like this:
        // crw------- 1 root root 10, 183 2021-02-11 17:55 /dev/hw_random

        String command = ""ls -l "" + HW_RNG_DEVICE;
        String output = mDevice.executeShellCommand(command).trim();
        if (!output.endsWith("" "" + HW_RNG_DEVICE)) {
            fail(""Unexpected output from "" + command + "": \"""" + output + ""\"""");
        }
        String[] outputWords = output.split(""\\s"");
        assertEquals(""Wrong mode on "" + HW_RNG_DEVICE, ""crw-------"", outputWords[0]);
        assertEquals(""Wrong owner of "" + HW_RNG_DEVICE, ""root"", outputWords[2]);
        assertEquals(""Wrong group of "" + HW_RNG_DEVICE, ""root"", outputWords[3]);
        assertEquals(""Wrong device major on "" + HW_RNG_DEVICE, ""10,"", outputWords[4]);
        assertEquals(""Wrong device minor on "" + HW_RNG_DEVICE, ""183"", outputWords[5]);
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/security/src/android/security/cts/FileSystemPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.security.cts.SELinuxHostTest"	"testWpaDomain"	"CtsSecurityHostTestCases"	"1: permission"	"([2:/android/security/cts/SELinuxHostTest.java]:[permission]:[2]:method_text:[ntroller, if running, always runs in permissioncontroller_app */    @CddTest(requirement=""9.7"")   ]) :|: 
    public void testWpaDomain() throws DeviceNotAvailableException {
        assertDomainZeroOrOne(""u:r:wpa:s0"", ""/system/bin/wpa_supplicant"");
    }

    /* permissioncontroller, if running, always runs in permissioncontroller_app */
    @CddTest(requirement=""9.7"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/security/src/android/security/cts/SELinuxHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.security.cts.SELinuxHostTest"	"testPermissionControllerDomain"	"CtsSecurityHostTestCases"	"1: permission"	"([5:/android/security/cts/SELinuxHostTest.java]:[permission]:[5]:method_text:[p:s0"");    }    /* vzwomatrigger may or may not be running */    @CddTest(requirement=""9.7"")   ]) :|: 
    public void testPermissionControllerDomain() throws DeviceNotAvailableException {
        assertExecutableHasDomain(""com.google.android.permissioncontroller"", ""u:r:permissioncontroller_app:s0"");
        assertExecutableHasDomain(""com.android.permissioncontroller"", ""u:r:permissioncontroller_app:s0"");
    }

    /* vzwomatrigger may or may not be running */
    @CddTest(requirement=""9.7"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/security/src/android/security/cts/SELinuxHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.security.cts.KernelConfigTest"	"testConfigDisableUsermodehelper"	"CtsSecurityHostTestCases"	"1: 9.1"	"([1:/android/security/cts/KernelConfigTest.java]:[9.1]:[1]:method_text:[l enables fs-verity and its built-in signature support.     */    @CddTest(requirement=""9.10"")   ]) :|: 
    public void testConfigDisableUsermodehelper() throws Exception {
        if (PropertyUtil.getFirstApiLevel(mDevice) < 30) {
            return;
        }

        final String ENABLE_CONFIG = ""CONFIG_STATIC_USERMODEHELPER=y"";
        final String PATH_CONFIG = ""CONFIG_STATIC_USERMODEHELPER_PATH="";

        final Set<String> ALLOWED_PATH_PREFIXES = new HashSet<String>();
        ALLOWED_PATH_PREFIXES.add(""/vendor/"");
        ALLOWED_PATH_PREFIXES.add(""/system/"");
        ALLOWED_PATH_PREFIXES.add(""/system_ext/"");

        assertTrue(""Linux kernel must enable static usermodehelper: "" + ENABLE_CONFIG,
            configSet.contains(ENABLE_CONFIG));

        String configPath = null;

        for (String option : configSet) {
            if (option.startsWith(PATH_CONFIG)) {
                configPath = option;
            }
        }

        int index = configPath.indexOf('=');
        String path = configPath.substring(index+1).replace(""\"""", """");

        assertTrue(""Linux kernel must specify an absolute path for static usermodehelper path"",
            configPath.contains("".."") == false);

        boolean pathIsWhitelisted = false;

        for (String allowedPath : ALLOWED_PATH_PREFIXES) {
            if (path.startsWith(allowedPath)) {
                pathIsWhitelisted = true;
                break;
            }
        }

        // Specifying no path, which disables usermodehelper, is also
        // valid.
        pathIsWhitelisted |= path.isEmpty();

        String whitelistedPathPrefixExample = ""'"" +
            String.join(""', '"", ALLOWED_PATH_PREFIXES) + ""'"";

        assertTrue(""Linux kernel must specify a whitelisted static usermodehelper path, ""
                   + ""and it must be empty or start with one of the following ""
                   + ""prefixes: "" + whitelistedPathPrefixExample, pathIsWhitelisted);
    }

    /**
     * Test that the kernel enables fs-verity and its built-in signature support.
     */
    @CddTest(requirement=""9.10"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/security/src/android/security/cts/KernelConfigTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.keysets.KeySetPermissionsTest"	"testHasPerm"	""	"1: permission"	"([2:/com/android/cts/keysets/KeySetPermissionsTest.java]:[permission]:[2]:method_text:[ pm.checkPermission(KEYSET_PERM_NAME, KEYSET_APP_PKG) == PackageManager.PERMISSION_GRANTED);    }}]) :|: public void testHasPerm() throws Exception {
        PackageManager pm = getContext().getPackageManager();
        assertTrue(KEYSET_PERM_NAME + "" not granted to "" + KEYSET_APP_PKG,
                pm.checkPermission(KEYSET_PERM_NAME, KEYSET_APP_PKG) == PackageManager.PERMISSION_GRANTED);
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/keysets/testApp/src/com/android/cts/keysets/KeySetPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.usespermissiondiffcertapp.UriGrantsResultTest"	"finish"	""	"1: permission"	"([11:/com/android/cts/usespermissiondiffcertapp/UriGrantsResultTest.java]:[permission]:[11]:method_text:[;    }    public void destroyActivity() throws Exception {        mActivity.finish();    }   ]) :|: /*
 *.
 */

package com.android.cts.usespermissiondiffcertapp;

import static com.android.cts.usespermissiondiffcertapp.AccessPermissionWithDiffSigTest.GRANTABLE;
import static com.android.cts.usespermissiondiffcertapp.AccessPermissionWithDiffSigTest.GRANTABLE_MODES;
import static com.android.cts.usespermissiondiffcertapp.AccessPermissionWithDiffSigTest.NOT_GRANTABLE;
import static com.android.cts.usespermissiondiffcertapp.AccessPermissionWithDiffSigTest.NOT_GRANTABLE_MODES;
import static com.android.cts.usespermissiondiffcertapp.Asserts.assertAccess;
import static com.android.cts.usespermissiondiffcertapp.UriGrantsTest.TAG;

import android.app.Instrumentation;
import android.content.ClipData;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.util.Log;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.function.Function;

@RunWith(AndroidJUnit4.class)
public class UriGrantsResultTest {
    private static final int REQUEST_CODE = 42;

    private Instrumentation mInstrumentation;
    private Context mContext;
    private GetResultActivity mActivity;

    public void createActivity() throws Exception {
        mInstrumentation = InstrumentationRegistry.getInstrumentation();
        mContext = InstrumentationRegistry.getTargetContext();

        final Intent intent = new Intent(mContext, GetResultActivity.class);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mActivity = (GetResultActivity) mInstrumentation.startActivitySync(intent);
        mInstrumentation.waitForIdleSync();
        mActivity.clearResult();
    }

    public void destroyActivity() throws Exception {
        mActivity.finish();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/UsePermissionDiffCert/src/com/android/cts/usespermissiondiffcertapp/UriGrantsResultTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.usespermissiondiffcertapp.UriGrantsResultTest"	"testNotGrantableToResult"	""	"1: permission"	"([2:/com/android/cts/usespermissiondiffcertapp/UriGrantsResultTest.java]:[permission]:[2]:method_text:[EXTRA_TEXT, clip);        intent.putExtra(Intent.EXTRA_INDEX, mode);        return intent;    }}]) :|: 
    public void testNotGrantableToResult() throws Exception {
        for (Uri uri : NOT_GRANTABLE) {
            for (int mode : NOT_GRANTABLE_MODES) {
                Log.d(TAG, ""Testing "" + uri + "" "" + mode);
                assertNotGrantableToResult(uri, mode, UriGrantsTest::makeSingleClipData);
                assertNotGrantableToResult(uri, mode, UriGrantsTest::makeMultiClipData);
            }
        }
    }

    private void assertNotGrantableToResult(Uri uri, int mode,
            Function<Uri, ClipData> clipper) throws Exception {
        try {
            createActivity();
            assertNotGrantableToResultInternal(uri, mode, clipper);
        } finally {
            destroyActivity();
        }
    }

    private void assertNotGrantableToResultInternal(Uri uri, int mode,
            Function<Uri, ClipData> clipper) {
        final Uri subUri = Uri.withAppendedPath(uri, ""foo"");
        final Uri subSubUri = Uri.withAppendedPath(subUri, ""bar"");
        final ClipData subClip = clipper.apply(subUri);

        final Intent intent = buildIntent(subClip, mode);
        mActivity.startActivityForResult(intent, REQUEST_CODE);
        mActivity.getResult();

        assertAccess(uri, 0);
        assertAccess(subClip, 0);
        assertAccess(subUri, 0);
        assertAccess(subSubUri, 0);
    }

    private Intent buildIntent(ClipData clip, int mode) {
        final Intent intent = new Intent();
        intent.setComponent(new ComponentName(""com.android.cts.permissiondeclareapp"",
                ""com.android.cts.permissiondeclareapp.SendResultActivity""));
        intent.putExtra(Intent.EXTRA_TEXT, clip);
        intent.putExtra(Intent.EXTRA_INDEX, mode);
        return intent;
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/UsePermissionDiffCert/src/com/android/cts/usespermissiondiffcertapp/UriGrantsResultTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.usespermissiondiffcertapp.UriGrantsServiceTest"	"testGrantableToService"	""	"1: permission"	"([3:/com/android/cts/usespermissiondiffcertapp/UriGrantsServiceTest.java]:[permission]:[3]:method_text:[cess(sub2Clip, 0);        assertAccess(sub2Uri, 0);        assertAccess(sub2SubUri, 0);    }   ]) :|: 
    public void testGrantableToService() {
        for (Uri uri : GRANTABLE) {
            for (int mode : GRANTABLE_MODES) {
                Log.d(TAG, ""Testing "" + uri + "" "" + mode);
                assertGrantableToService(uri, mode, UriGrantsTest::makeSingleClipData);
                assertGrantableToService(uri, mode, UriGrantsTest::makeMultiClipData);
            }
        }
    }

    private void assertGrantableToService(Uri uri, int mode, Function<Uri, ClipData> clipper) {
        final Uri subUri = Uri.withAppendedPath(uri, ""foo"");
        final Uri subSubUri = Uri.withAppendedPath(subUri, ""bar"");
        final Uri sub2Uri = Uri.withAppendedPath(uri, ""yes"");
        final Uri sub2SubUri = Uri.withAppendedPath(sub2Uri, ""no"");

        ReceiveUriService.stop(getContext());

        final ClipData subClip = clipper.apply(subUri);
        final ClipData sub2Clip = clipper.apply(sub2Uri);

        assertAccess(uri, 0);
        assertAccess(subClip, 0);
        assertAccess(subUri, 0);
        assertAccess(subSubUri, 0);
        assertAccess(sub2Clip, 0);
        assertAccess(sub2Uri, 0);
        assertAccess(sub2SubUri, 0);

        // --------------------------------

        ReceiveUriService.clearStarted();
        grantClipUriPermissionViaService(subClip, mode);
        ReceiveUriService.waitForStart();

        int firstStartId = ReceiveUriService.getCurStartId();

        assertAccess(uri, 0);
        assertAccess(subClip, mode);
        assertAccess(subUri, mode);
        assertAccess(subSubUri, 0);
        assertAccess(sub2Clip, 0);
        assertAccess(sub2Uri, 0);
        assertAccess(sub2SubUri, 0);

        // --------------------------------

        // Send another Intent to it.
        ReceiveUriService.clearStarted();
        grantClipUriPermissionViaService(sub2Clip, mode);
        ReceiveUriService.waitForStart();

        assertAccess(uri, 0);
        assertAccess(subClip, mode);
        assertAccess(subUri, mode);
        assertAccess(subSu"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/UsePermissionDiffCert/src/com/android/cts/usespermissiondiffcertapp/UriGrantsServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.usespermissiondiffcertapp.UriGrantsTest"	"testGrantPersistableUriPermission"	""	"1: permission"	"([38:/com/android/cts/usespermissiondiffcertapp/UriGrantsTest.java]:[permission]:[38]:method_text:[hCurInstanceSync();    }    /**     * Validate behavior of prefix permission grants.     */   ]) :|: 
    public void testGrantPersistableUriPermission() {
        final ContentResolver resolver = getContext().getContentResolver();

        final Uri target = Uri.withAppendedPath(PERM_URI_GRANTING, ""foo"");
        final ClipData clip = makeSingleClipData(target);

        // Make sure we can't see the target
        assertReadingClipNotAllowed(clip, ""reading should have failed"");
        assertWritingClipNotAllowed(clip, ""writing should have failed"");

        // Make sure we can't take a grant we don't have
        try {
            resolver.takePersistableUriPermission(target, Intent.FLAG_GRANT_READ_URI_PERMISSION);
            fail(""taking read should have failed"");
        } catch (SecurityException expected) {
        }

        // And since we were just installed, no persisted grants yet
        assertNoPersistedUriPermission();

        // Now, let's grant ourselves some access
        ReceiveUriActivity.clearStarted();
        grantClipUriPermissionViaActivity(clip, Intent.FLAG_GRANT_READ_URI_PERMISSION
                | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION);
        ReceiveUriActivity.waitForStart();

        // We should now have reading access, even before taking the persistable
        // grant. Persisted grants should still be empty.
        assertReadingClipAllowed(clip);
        assertWritingClipNotAllowed(clip, ""writing should have failed"");
        assertNoPersistedUriPermission();

        // Take the read grant and verify we have it!
        long before = System.currentTimeMillis();
        resolver.takePersistableUriPermission(target, Intent.FLAG_GRANT_READ_URI_PERMISSION);
        long after = System.currentTimeMillis();
        assertPersistedUriPermission(target, Intent.FLAG_GRANT_READ_URI_PERMISSION, before, after);

        // Make sure we can't take a grant we don't have
        try {
            resolver.takePersistableUriPermission(target, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
            fail(""taking write should have failed"""	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/UsePermissionDiffCert/src/com/android/cts/usespermissiondiffcertapp/UriGrantsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.usespermissiondiffcertapp.UriGrantsTest"	"testGrantPrefixUriPermission"	""	"1: permission"	"([6:/com/android/cts/usespermissiondiffcertapp/UriGrantsTest.java]:[permission]:[6]:method_text:[wCat, ""writing should have failed"");        ReceiveUriActivity.finishCurInstanceSync();    }   ]) :|: 
    public void testGrantPrefixUriPermission() throws Exception {
        final Uri target = Uri.withAppendedPath(PERM_URI_GRANTING, ""foo1"");
        final Uri targetMeow = Uri.withAppendedPath(target, ""meow"");
        final Uri targetMeowCat = Uri.withAppendedPath(targetMeow, ""cat"");

        final ClipData clip = makeSingleClipData(target);
        final ClipData clipMeow = makeSingleClipData(targetMeow);
        final ClipData clipMeowCat = makeSingleClipData(targetMeowCat);

        // Make sure we can't see the target
        assertReadingClipNotAllowed(clip, ""reading should have failed"");
        assertWritingClipNotAllowed(clip, ""writing should have failed"");

        // Give ourselves prefix read access
        ReceiveUriActivity.clearStarted();
        grantClipUriPermissionViaActivity(clipMeow, Intent.FLAG_GRANT_READ_URI_PERMISSION
                | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION);
        ReceiveUriActivity.waitForStart();

        // Verify prefix read access
        assertReadingClipNotAllowed(clip, ""reading should have failed"");
        assertReadingClipAllowed(clipMeow);
        assertReadingClipAllowed(clipMeowCat);
        assertWritingClipNotAllowed(clip, ""writing should have failed"");
        assertWritingClipNotAllowed(clipMeow, ""writing should have failed"");
        assertWritingClipNotAllowed(clipMeowCat, ""writing should have failed"");

        // Now give ourselves exact write access
        ReceiveUriActivity.clearNewIntent();
        grantClipUriPermissionViaActivity(clip, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
        ReceiveUriActivity.waitForNewIntent();

        // Verify we have exact write access, but not prefix write
        assertReadingClipNotAllowed(clip, ""reading should have failed"");
        assertReadingClipAllowed(clipMeow);
        assertReadingClipAllowed(clipMeowCat);
        assertWritingClipAllowed(clip);
        assertWritingClipNotAllowed(clipMeow, ""writing should have failed"");
        assertWritingClipNotAl"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/UsePermissionDiffCert/src/com/android/cts/usespermissiondiffcertapp/UriGrantsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.usespermissiondiffcertapp.UriGrantsTest"	"testGrantPersistablePrefixUriPermission"	""	"1: permission"	"([15:/com/android/cts/usespermissiondiffcertapp/UriGrantsTest.java]:[permission]:[15]:method_text:[    }    /**     * Validate behavior of directly granting/revoking permission grants.     */   ]) :|: 
    public void testGrantPersistablePrefixUriPermission() {
        final ContentResolver resolver = getContext().getContentResolver();

        final Uri target = Uri.withAppendedPath(PERM_URI_GRANTING, ""foo2"");
        final Uri targetMeow = Uri.withAppendedPath(target, ""meow"");

        final ClipData clip = makeSingleClipData(target);
        final ClipData clipMeow = makeSingleClipData(targetMeow);

        // Make sure we can't see the target
        assertReadingClipNotAllowed(clip, ""reading should have failed"");

        // Give ourselves prefix read access
        ReceiveUriActivity.clearStarted();
        grantClipUriPermissionViaActivity(clip, Intent.FLAG_GRANT_READ_URI_PERMISSION
                | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION
                | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION);
        ReceiveUriActivity.waitForStart();

        // Verify prefix read access
        assertReadingClipAllowed(clip);
        assertReadingClipAllowed(clipMeow);

        // Verify we can persist direct grant
        long before = System.currentTimeMillis();
        resolver.takePersistableUriPermission(target, Intent.FLAG_GRANT_READ_URI_PERMISSION);
        long after = System.currentTimeMillis();
        assertPersistedUriPermission(target, Intent.FLAG_GRANT_READ_URI_PERMISSION, before, after);

        // But we can't take anywhere under the prefix
        try {
            resolver.takePersistableUriPermission(targetMeow,
                    Intent.FLAG_GRANT_READ_URI_PERMISSION);
            fail(""taking under prefix should have failed"");
        } catch (SecurityException expected) {
        }

        // Should still have access regardless of taking
        assertReadingClipAllowed(clip);
        assertReadingClipAllowed(clipMeow);

        // And clean up our grants
        resolver.releasePersistableUriPermission(target, Intent.FLAG_GRANT_READ_URI_PERMISSION);
        assertNoPersistedUriPermission();

        ReceiveUriActivity.finishCurInstanc"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/UsePermissionDiffCert/src/com/android/cts/usespermissiondiffcertapp/UriGrantsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.usespermissiondiffcertapp.UriGrantsTest"	"testDirectGrantRevokeUriPermission"	""	"1: permission"	"([22:/com/android/cts/usespermissiondiffcertapp/UriGrantsTest.java]:[permission]:[22]:method_text:[r of a direct permission grant, where the receiver of     * that permission revokes it.     */   ]) :|: 
    public void testDirectGrantRevokeUriPermission() throws Exception {
        final ContentResolver resolver = getContext().getContentResolver();

        final Uri target = Uri.withAppendedPath(PERM_URI_GRANTING, ""foo3"");
        final Uri targetMeow = Uri.withAppendedPath(target, ""meow"");
        final Uri targetMeowCat = Uri.withAppendedPath(targetMeow, ""cat"");

        final ClipData clip = makeSingleClipData(target);
        final ClipData clipMeow = makeSingleClipData(targetMeow);
        final ClipData clipMeowCat = makeSingleClipData(targetMeowCat);

        // Make sure we can't see the target
        assertReadingClipNotAllowed(clipMeow, ""reading should have failed"");
        assertWritingClipNotAllowed(clipMeow, ""writing should have failed"");

        // Give ourselves some grants:
        // /meow/cat  WRITE|PERSISTABLE
        // /meow      READ|PREFIX
        // /meow      WRITE
        grantClipUriPermissionViaContext(targetMeowCat, Intent.FLAG_GRANT_WRITE_URI_PERMISSION
                | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION);
        grantClipUriPermissionViaContext(targetMeow, Intent.FLAG_GRANT_READ_URI_PERMISSION
                | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION);
        grantClipUriPermissionViaContext(targetMeow, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);

        long before = System.currentTimeMillis();
        resolver.takePersistableUriPermission(targetMeowCat, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
        long after = System.currentTimeMillis();
        assertPersistedUriPermission(targetMeowCat, Intent.FLAG_GRANT_WRITE_URI_PERMISSION, before, after);

        // Verify they look good
        assertReadingClipNotAllowed(clip, ""reading should have failed"");
        assertReadingClipAllowed(clipMeow);
        assertReadingClipAllowed(clipMeowCat);
        assertWritingClipNotAllowed(clip, ""writing should have failed"");
        assertWritingClipAllowed(clipMeow);
        assertWritingClipAllowed(clipMeowCat);

        // Re"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/UsePermissionDiffCert/src/com/android/cts/usespermissiondiffcertapp/UriGrantsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.usespermissiondiffcertapp.UriGrantsTest"	"testDirectGrantReceiverRevokeUriPermission"	""	"1: permission"	"([20:/com/android/cts/usespermissiondiffcertapp/UriGrantsTest.java]:[permission]:[20]:method_text:[llowed(clipMeowCat, ""writing should have failed"");        assertNoPersistedUriPermission();    }}]) :|: 
    public void testDirectGrantReceiverRevokeUriPermission() throws Exception {
        final ContentResolver resolver = getContext().getContentResolver();

        final Uri target = Uri.withAppendedPath(PERM_URI_GRANTING, ""foo3"");
        final Uri targetMeow = Uri.withAppendedPath(target, ""meow"");
        final Uri targetMeowCat = Uri.withAppendedPath(targetMeow, ""cat"");

        final ClipData clip = makeSingleClipData(target);
        final ClipData clipMeow = makeSingleClipData(targetMeow);
        final ClipData clipMeowCat = makeSingleClipData(targetMeowCat);

        // Make sure we can't see the target
        assertReadingClipNotAllowed(clipMeow, ""reading should have failed"");
        assertWritingClipNotAllowed(clipMeow, ""writing should have failed"");

        // Give ourselves some grants:
        // /meow/cat  WRITE|PERSISTABLE
        // /meow      READ|PREFIX
        // /meow      WRITE
        grantClipUriPermissionViaContext(targetMeowCat, Intent.FLAG_GRANT_WRITE_URI_PERMISSION
                | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION);
        grantClipUriPermissionViaContext(targetMeow, Intent.FLAG_GRANT_READ_URI_PERMISSION
                | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION);
        grantClipUriPermissionViaContext(targetMeow, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);

        long before = System.currentTimeMillis();
        resolver.takePersistableUriPermission(targetMeowCat, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
        long after = System.currentTimeMillis();
        assertPersistedUriPermission(targetMeowCat, Intent.FLAG_GRANT_WRITE_URI_PERMISSION, before, after);

        // Verify they look good
        assertReadingClipNotAllowed(clip, ""reading should have failed"");
        assertReadingClipAllowed(clipMeow);
        assertReadingClipAllowed(clipMeowCat);
        assertWritingClipNotAllowed(clip, ""writing should have failed"");
        assertWritingClipAllowed(clipMeow);
        assertWritingClipAllowed(clipMeowCat);"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/UsePermissionDiffCert/src/com/android/cts/usespermissiondiffcertapp/UriGrantsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.usespermissiondiffcertapp.UriGrantsActivityTest"	"finishCurInstanceSync"	""	"1: permission"	"([15:/com/android/cts/usespermissiondiffcertapp/UriGrantsActivityTest.java]:[permission]:[15]:method_text:[usually to clean up from failed tests        ReceiveUriActivity.finishCurInstanceSync();    }   ]) :|: /*
 *.
 */

package com.android.cts.usespermissiondiffcertapp;

import static com.android.cts.usespermissiondiffcertapp.AccessPermissionWithDiffSigTest.GRANTABLE;
import static com.android.cts.usespermissiondiffcertapp.AccessPermissionWithDiffSigTest.GRANTABLE_MODES;
import static com.android.cts.usespermissiondiffcertapp.AccessPermissionWithDiffSigTest.NOT_GRANTABLE;
import static com.android.cts.usespermissiondiffcertapp.AccessPermissionWithDiffSigTest.NOT_GRANTABLE_MODES;
import static com.android.cts.usespermissiondiffcertapp.Asserts.assertAccess;
import static com.android.cts.usespermissiondiffcertapp.UriGrantsTest.TAG;
import static com.android.cts.usespermissiondiffcertapp.Utils.grantClipUriPermissionViaActivities;
import static com.android.cts.usespermissiondiffcertapp.Utils.grantClipUriPermissionViaActivity;

import static junit.framework.Assert.fail;

import android.content.ClipData;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.os.SystemClock;
import android.util.Log;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import org.junit.After;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.function.Function;

@RunWith(AndroidJUnit4.class)
public class UriGrantsActivityTest {
    private static Context getContext() {
        return InstrumentationRegistry.getTargetContext();
    }

    @After
    public void tearDown() throws Exception {
        // Always dispose, usually to clean up from failed tests
        ReceiveUriActivity.finishCurInstanceSync();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/UsePermissionDiffCert/src/com/android/cts/usespermissiondiffcertapp/UriGrantsActivityTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.usespermissiondiffcertapp.UriGrantsActivityTest"	"testGrantableToActivity"	""	"1: permission"	"([3:/com/android/cts/usespermissiondiffcertapp/UriGrantsActivityTest.java]:[permission]:[3]:method_text:[cess(sub2Clip, 0);        assertAccess(sub2Uri, 0);        assertAccess(sub2SubUri, 0);    }   ]) :|: 
    public void testGrantableToActivity() {
        for (Uri uri : GRANTABLE) {
            for (int mode : GRANTABLE_MODES) {
                Log.d(TAG, ""Testing "" + uri + "" "" + mode);
                assertGrantableToActivity(uri, mode, UriGrantsTest::makeSingleClipData);
                assertGrantableToActivity(uri, mode, UriGrantsTest::makeMultiClipData);
            }
        }
    }

    private void assertGrantableToActivity(Uri uri, int mode, Function<Uri, ClipData> clipper) {
        final Uri subUri = Uri.withAppendedPath(uri, ""foo"");
        final Uri subSubUri = Uri.withAppendedPath(subUri, ""bar"");
        final Uri sub2Uri = Uri.withAppendedPath(uri, ""yes"");
        final Uri sub2SubUri = Uri.withAppendedPath(sub2Uri, ""no"");

        final ClipData subClip = clipper.apply(subUri);
        final ClipData sub2Clip = clipper.apply(sub2Uri);

        assertAccess(uri, 0);
        assertAccess(subClip, 0);
        assertAccess(subUri, 0);
        assertAccess(subSubUri, 0);
        assertAccess(sub2Clip, 0);
        assertAccess(sub2Uri, 0);
        assertAccess(sub2SubUri, 0);

        // --------------------------------

        ReceiveUriActivity.clearStarted();
        grantClipUriPermissionViaActivities(subClip, mode);
        ReceiveUriActivity.waitForStart();

        assertAccess(uri, 0);
        assertAccess(subClip, mode);
        assertAccess(subUri, mode);
        assertAccess(subSubUri, 0);
        assertAccess(sub2Clip, 0);
        assertAccess(sub2Uri, 0);
        assertAccess(sub2SubUri, 0);

        // --------------------------------

        ReceiveUriActivity.clearNewIntent();
        grantClipUriPermissionViaActivity(sub2Clip, mode);
        ReceiveUriActivity.waitForNewIntent();

        assertAccess(uri, 0);
        assertAccess(subClip, mode);
        assertAccess(subUri, mode);
        assertAccess(subSubUri, 0);
        assertAccess(sub2Clip, mode);
        assertAccess(sub2Uri, mode);
        assertAccess(sub2SubUri, 0);"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/UsePermissionDiffCert/src/com/android/cts/usespermissiondiffcertapp/UriGrantsActivityTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.usespermissiondiffcertapp.UriGrantsClipboardTest"	"testClipboardWithPermission"	""	"1: permission"	"([4:/com/android/cts/usespermissiondiffcertapp/UriGrantsClipboardTest.java]:[permission]:[4]:method_text:[clipFromClipboard);            assertWritingClipNotAllowed(clipFromClipboard);        }    }   ]) :|: 
    public void testClipboardWithPermission() throws Exception {
        for (Uri target : GRANTABLE) {
            Log.d(TAG, ""Testing "" + target);
            final ClipData clip = makeSingleClipData(target);

            // Normally we can't see the underlying clip data
            assertReadingClipNotAllowed(clip);
            assertWritingClipNotAllowed(clip);

            // Use shell's permissions to ensure we can access the clipboard
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                    .adoptShellPermissionIdentity();
            ClipData clipFromClipboard;
            try {
                // But if someone puts it on the clipboard, we can read it
                setPrimaryClip(clip);
                clipFromClipboard = getContext()
                        .getSystemService(ClipboardManager.class).getPrimaryClip();
            } finally {
                InstrumentationRegistry.getInstrumentation().getUiAutomation()
                        .dropShellPermissionIdentity();
            }
            assertClipDataEquals(clip, clipFromClipboard);
            assertReadingClipAllowed(clipFromClipboard);
            assertWritingClipNotAllowed(clipFromClipboard);

            // And if clipboard is cleared, we lose access
            clearPrimaryClip();
            assertReadingClipNotAllowed(clipFromClipboard);
            assertWritingClipNotAllowed(clipFromClipboard);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/UsePermissionDiffCert/src/com/android/cts/usespermissiondiffcertapp/UriGrantsClipboardTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.usespermissiondiffcertapp.UriGrantsClipboardTest"	"testClipboardWithoutPermission"	""	"1: permission"	"([1:/com/android/cts/usespermissiondiffcertapp/UriGrantsClipboardTest.java]:[permission]:[1]:method_text:[clip + "" on clipboard!"");            } catch (Exception expected) {            }        }    }}]) :|: 
    public void testClipboardWithoutPermission() throws Exception {
        for (Uri target : NOT_GRANTABLE) {
            Log.d(TAG, ""Testing "" + target);
            final ClipData clip = makeSingleClipData(target);

            // Can't see it directly
            assertReadingClipNotAllowed(clip);
            assertWritingClipNotAllowed(clip);

            // Can't put on clipboard if we don't own it
            try {
                setPrimaryClip(clip);
                fail(""Unexpected ability to put protected data "" + clip + "" on clipboard!"");
            } catch (Exception expected) {
            }
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/UsePermissionDiffCert/src/com/android/cts/usespermissiondiffcertapp/UriGrantsClipboardTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.usespermissiondiffcertapp.AccessPermissionWithDiffSigTest"	"testReadProviderWithDiff"	""	"1: permission"	"([1:/com/android/cts/usespermissiondiffcertapp/AccessPermissionWithDiffSigTest.java]:[permission]:[1]:method_text:[ature content provider cannot be written,     * since this app lacks the required certs     */   ]) :|: 
    public void testReadProviderWithDiff() {
        assertReadingContentUriNotAllowed(PERM_URI, null);
    }

    /**
     * Test that the ctspermissionwithsignature content provider cannot be written,
     * since this app lacks the required certs
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/UsePermissionDiffCert/src/com/android/cts/usespermissiondiffcertapp/AccessPermissionWithDiffSigTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.usespermissiondiffcertapp.AccessPermissionWithDiffSigTest"	"testWriteProviderWhenAmbiguous"	""	"1: permission"	"([2:/com/android/cts/usespermissiondiffcertapp/AccessPermissionWithDiffSigTest.java]:[permission]:[2]:method_text:[-permission}     * protections, which should only rely on {@code provider} permissions.     */   ]) :|: 
    public void testWriteProviderWhenAmbiguous() {
        assertWritingContentUriNotAllowed(AMBIGUOUS_URI, ""shouldn't write ambiguous provider"");
    }

    /**
     * Verify that we can access paths outside the {@code path-permission}
     * protections, which should only rely on {@code provider} permissions.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/UsePermissionDiffCert/src/com/android/cts/usespermissiondiffcertapp/AccessPermissionWithDiffSigTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.usespermissiondiffcertapp.AccessPermissionWithDiffSigTest"	"testRestrictingProviderNoMatchingPath"	""	"1: permission"	"([3:/com/android/cts/usespermissiondiffcertapp/AccessPermissionWithDiffSigTest.java]:[permission]:[3]:method_text:[riction aren't     * allowed, even though the {@code provider} requires no permissions.     */   ]) :|: 
    public void testRestrictingProviderNoMatchingPath() {
        assertReadingContentUriAllowed(PERM_URI_PATH_RESTRICTING);
        assertWritingContentUriAllowed(PERM_URI_PATH_RESTRICTING);

        // allowed by no top-level permission
        final Uri test = PERM_URI_PATH_RESTRICTING.buildUpon().appendPath(""fo"").build();
        assertReadingContentUriAllowed(test);
        assertWritingContentUriAllowed(test);
    }

    /**
     * Verify that paths under {@code path-permission} restriction aren't
     * allowed, even though the {@code provider} requires no permissions.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/UsePermissionDiffCert/src/com/android/cts/usespermissiondiffcertapp/AccessPermissionWithDiffSigTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.usespermissiondiffcertapp.AccessPermissionWithDiffSigTest"	"testRestrictingProviderMatchingPathDenied"	""	"1: permission"	"([1:/com/android/cts/usespermissiondiffcertapp/AccessPermissionWithDiffSigTest.java]:[permission]:[1]:method_text:[   }    /**     * Test that shady {@link Uri} are blocked by {@code path-permission}.     */   ]) :|: 
    public void testRestrictingProviderMatchingPathDenied() {
        // rejected by ""foo"" prefix
        final Uri test1 = PERM_URI_PATH_RESTRICTING.buildUpon().appendPath(""foo"").build();
        assertReadingContentUriNotAllowed(test1, null);
        assertWritingContentUriNotAllowed(test1, null);

        // rejected by ""foo"" prefix
        final Uri test2 = PERM_URI_PATH_RESTRICTING.buildUpon()
                .appendPath(""foo"").appendPath(""ba"").build();
        assertReadingContentUriNotAllowed(test2, null);
        assertWritingContentUriNotAllowed(test2, null);
    }

    /**
     * Test that shady {@link Uri} are blocked by {@code path-permission}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/UsePermissionDiffCert/src/com/android/cts/usespermissiondiffcertapp/AccessPermissionWithDiffSigTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.usespermissiondiffcertapp.AccessPermissionWithDiffSigTest"	"testRestrictingProviderMatchingShadyPaths"	""	"1: permission"	"([9:/com/android/cts/usespermissiondiffcertapp/AccessPermissionWithDiffSigTest.java]:[permission]:[9]:method_text:[access,     * even if the caller doesn't hold another matching {@code path-permission}.     */   ]) :|: 
    public void testRestrictingProviderMatchingShadyPaths() {
        assertContentUriAllowed(
                Uri.parse(""content://ctspermissionwithsignaturepathrestricting/""));
        assertContentUriAllowed(
                Uri.parse(""content://ctspermissionwithsignaturepathrestricting//""));
        assertContentUriAllowed(
                Uri.parse(""content://ctspermissionwithsignaturepathrestricting///""));
        assertContentUriNotAllowed(
                Uri.parse(""content://ctspermissionwithsignaturepathrestricting/foo""), null);
        assertContentUriNotAllowed(
                Uri.parse(""content://ctspermissionwithsignaturepathrestricting//foo""), null);
        assertContentUriNotAllowed(
                Uri.parse(""content://ctspermissionwithsignaturepathrestricting///foo""), null);
        assertContentUriNotAllowed(
                Uri.parse(""content://ctspermissionwithsignaturepathrestricting/foo//baz""), null);
    }

    /**
     * Verify that at least one {@code path-permission} rule will grant access,
     * even if the caller doesn't hold another matching {@code path-permission}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/UsePermissionDiffCert/src/com/android/cts/usespermissiondiffcertapp/AccessPermissionWithDiffSigTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.usespermissiondiffcertapp.AccessPermissionWithDiffSigTest"	"testGetMimeTypePermission"	""	"1: permission"	"([2:/com/android/cts/usespermissiondiffcertapp/AccessPermissionWithDiffSigTest.java]:[permission]:[2]:method_text:[   assertEquals(getContext().getContentResolver().getType(PERM_URI), EXPECTED_MIME_TYPE);    }   ]) :|: 
    public void testGetMimeTypePermission() {
        // Precondition: no current access.
        assertReadingContentUriNotAllowed(PERM_URI, ""shouldn't read when starting test"");
        assertWritingContentUriNotAllowed(PERM_URI, ""shouldn't write when starting test"");
        
        // All apps should be able to get MIME type regardless of permission.
        assertEquals(getContext().getContentResolver().getType(PERM_URI), EXPECTED_MIME_TYPE);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/UsePermissionDiffCert/src/com/android/cts/usespermissiondiffcertapp/AccessPermissionWithDiffSigTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.escalatepermission.PermissionEscalationTest"	"testCannotEscalateNonRuntimePermissionsToRuntime"	""	"1: permission"	"([19:/com/android/cts/escalatepermission/PermissionEscalationTest.java]:[permission]:[19]:method_text:[ission2.protectionLevel                        & PermissionInfo.PROTECTION_MASK_BASE));     }   ]) :|: 
    public void testCannotEscalateNonRuntimePermissionsToRuntime() throws Exception {
        Context context = InstrumentationRegistry.getTargetContext();

        // Ensure normal permission cannot be made dangerous
        PermissionInfo stealAudio1Permission1 = context.getPackageManager()
                .getPermissionInfo(Manifest.permission.STEAL_AUDIO1, 0);
        assertSame(""Shouldn't be able to change normal permission to dangerous"",
                PermissionInfo.PROTECTION_NORMAL, (stealAudio1Permission1.protectionLevel
                        & PermissionInfo.PROTECTION_MASK_BASE));

        // Ensure signature permission cannot be made dangerous
        PermissionInfo stealAudio1Permission2 = context.getPackageManager()
                .getPermissionInfo(Manifest.permission.STEAL_AUDIO2, 0);
        assertSame(""Shouldn't be able to change signature permission to dangerous"",
                PermissionInfo.PROTECTION_SIGNATURE, (stealAudio1Permission2.protectionLevel
                        & PermissionInfo.PROTECTION_MASK_BASE));
     }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EscalateToRuntimePermissions/src/com/android/cts/escalatepermission/PermissionEscalationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.escalatepermission.PermissionEscalationTest"	"testRuntimePermissionsAreNotGranted"	""	"1: permission"	"([29:/com/android/cts/escalatepermission/PermissionEscalationTest.java]:[permission]:[29]:method_text:[ssion(Manifest.permission.STEAL_AUDIO2),                PackageManager.PERMISSION_DENIED);    } }]) :|: 
    public void testRuntimePermissionsAreNotGranted() throws Exception {
        // TODO (b/172366747): It is weird that the permission cannot become a runtime permission
        //                     during runtime but can become one during reboot.
        Context context = InstrumentationRegistry.getTargetContext();

        // Ensure permission is now dangerous but denied
        PermissionInfo stealAudio1Permission1 = context.getPackageManager()
                .getPermissionInfo(Manifest.permission.STEAL_AUDIO1, 0);
        assertSame(""Signature permission can become dangerous after reboot"",
                PermissionInfo.PROTECTION_DANGEROUS, (stealAudio1Permission1.protectionLevel
                        & PermissionInfo.PROTECTION_MASK_BASE));

        assertSame(""Permission should be denied"",
                context.checkSelfPermission(Manifest.permission.STEAL_AUDIO1),
                PackageManager.PERMISSION_DENIED);

        // Ensure permission is now dangerous but denied
        PermissionInfo stealAudio1Permission2 = context.getPackageManager()
                .getPermissionInfo(Manifest.permission.STEAL_AUDIO2, 0);
        assertSame(""Signature permission can become dangerous after reboot"",
                PermissionInfo.PROTECTION_DANGEROUS, (stealAudio1Permission2.protectionLevel
                        & PermissionInfo.PROTECTION_MASK_BASE));

        assertSame(""Permission should be denied"",
                context.checkSelfPermission(Manifest.permission.STEAL_AUDIO2),
                PackageManager.PERMISSION_DENIED);
    }
 }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EscalateToRuntimePermissions/src/com/android/cts/escalatepermission/PermissionEscalationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.normalapp.ClientTest"	"testGetChangedPackages"	""	"1: permission"	"([4:/com/android/cts/normalapp/ClientTest.java]:[permission]:[4]:method_text:[eNames()).contains(EPHEMERAL_1_PKG);        }, Manifest.permission.ACCESS_INSTANT_APPS);    }   ]) :|: 
    public void testGetChangedPackages() {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();

        // Query changed packages without permission, and we should only get normal apps.
        final ChangedPackages changedPackages = pm.getChangedPackages(0);
        assertThat(changedPackages.getPackageNames()).doesNotContain(EPHEMERAL_1_PKG);

        // Query changed packages with permission, and we should be able to get ephemeral apps.
        runWithShellPermissionIdentity(() -> {
            final ChangedPackages changesInstantApp = pm.getChangedPackages(0);
            assertThat(changesInstantApp.getPackageNames()).contains(EPHEMERAL_1_PKG);
        }, Manifest.permission.ACCESS_INSTANT_APPS);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/NormalApp/src/com/android/cts/normalapp/ClientTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.normalapp.ClientTest"	"isTrue"	""	"1: permission"	"([3:/com/android/cts/normalapp/ClientTest.java]:[permission]:[3]:method_text:[        }, Manifest.permission.DELETE_PACKAGES, Manifest.permission.ACCESS_INSTANT_APPS);    }   ]) :|: 
    public void uninstall_userInstalledApp_shouldBeUserInitiated() {
        runWithShellPermissionIdentity(() -> {
            final boolean userInitiated = uninstallAndWaitForExtraUserInitiated(
                    InstrumentationRegistry.getContext(), EPHEMERAL_1_PKG);

            assertThat(userInitiated).isTrue();
        }, Manifest.permission.DELETE_PACKAGES, Manifest.permission.ACCESS_INSTANT_APPS);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/NormalApp/src/com/android/cts/normalapp/ClientTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.normalapp.ClientTest"	"isFalse"	""	"1: permission"	"([3:/com/android/cts/normalapp/ClientTest.java]:[permission]:[3]:method_text:[rruptedException e) {                throw new RuntimeException(e);            }        }    }}]) :|: 
    public void uninstall_pruneInstantApp_shouldNotBeUserInitiated() {
        runWithShellPermissionIdentity(() -> {
            final boolean userInitiated = pruneInstantAppAndWaitForExtraUserInitiated(
                    InstrumentationRegistry.getContext(), EPHEMERAL_1_PKG);

            assertThat(userInitiated).isFalse();
        }, Manifest.permission.WRITE_SECURE_SETTINGS, Manifest.permission.ACCESS_INSTANT_APPS);
    }

    /**
     * Uninstall the package and wait for the package removed intent.
     *
     * @return The value of {@link Intent#EXTRA_USER_INITIATED} associated with the intent.
     */
    private boolean uninstallAndWaitForExtraUserInitiated(Context context, String packageName) {
        final Runnable uninstall = () -> {
            final PackageInstaller packageInstaller = context.getPackageManager()
                    .getPackageInstaller();
            packageInstaller.uninstall(packageName, null);
        };

        final Intent packageRemoved = executeAndWaitForPackageRemoved(
                context, packageName, uninstall);
        return packageRemoved.getBooleanExtra(Intent.EXTRA_USER_INITIATED, false);
    }

    /**
     * Runs the shell command {@code pm trim-caches} to invoke system to prune instant applications.
     * Waits for the package removed intent and returns the extra filed.
     *
     * @return The value of {@link Intent#EXTRA_USER_INITIATED} associated with the intent.
     */
    private boolean pruneInstantAppAndWaitForExtraUserInitiated(Context context,
            String packageName) {
        final String defaultPeriod = Settings.Global.getString(context.getContentResolver(),
                INSTALLED_INSTANT_APP_MIN_CACHE_PERIOD);
        final Runnable trimCaches = () -> {
            // Updates installed instant app minimum cache period to zero to ensure that system
            // could uninstall instant apps when trim-caches is invoked.
            Settings.Global.putInt(context.getContentResolver(),"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/NormalApp/src/com/android/cts/normalapp/ClientTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.ephemeralapp1.ClientTest"	"testInstallPermissionGranted"	""	"3: INTERNET permission.INTERNET permission"	"([4:/com/android/cts/ephemeralapp1/ClientTest.java]:[permission]:[4]:method_text:[on(Manifest.permission.INTERNET),                is(PackageManager.PERMISSION_GRANTED));    }   ]) :|: 
    public void testInstallPermissionGranted() throws Exception {
        assertThat(InstrumentationRegistry.getContext()
                    .checkCallingOrSelfPermission(Manifest.permission.INTERNET),
                is(PackageManager.PERMISSION_GRANTED));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/EphemeralApp1/src/com/android/cts/ephemeralapp1/ClientTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.ephemeralapp1.ClientTest"	"testInstallPermissionGrantedInPackageInfo"	""	"3: INTERNET permission.INTERNET permission"	"([13:/com/android/cts/ephemeralapp1/ClientTest.java]:[permission]:[13]:method_text:[sFlags[permissionIndex]                & PackageInfo.REQUESTED_PERMISSION_GRANTED) != 0;    }   ]) :|: 
    @AsbSecurityTest(cveBugId = 140256621)
    public void testInstallPermissionGrantedInPackageInfo() throws Exception {
        assertThat(isPermissionGrantedInPackageInfo(Manifest.permission.INTERNET), is(true));
    }

    private static boolean isPermissionGrantedInPackageInfo(String permissionName)
            throws Exception {
        final Context context = InstrumentationRegistry.getContext();
        final PackageInfo packageInfo = context.getPackageManager().getPackageInfo(
                context.getPackageName(), PackageManager.GET_PERMISSIONS);
        final int permissionIndex = Arrays.asList(packageInfo.requestedPermissions).indexOf(
                permissionName);
        assertThat(permissionIndex, is(not(-1)));
        return (packageInfo.requestedPermissionsFlags[permissionIndex]
                & PackageInfo.REQUESTED_PERMISSION_GRANTED) != 0;
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/EphemeralApp1/src/com/android/cts/ephemeralapp1/ClientTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.ephemeralapp1.ClientTest"	"testInternetPermission"	""	"2: INTERNET permission"	"([1:/com/android/cts/ephemeralapp1/ClientTest.java]:[permission]:[1]:method_text:[ce(Context.CONNECTIVITY_SERVICE);        manager.reportNetworkConnectivity(null, false);    }   ]) :|: 
    public void testInternetPermission() throws Throwable {
        final ConnectivityManager manager = (ConnectivityManager) InstrumentationRegistry.getContext()
                .getSystemService(Context.CONNECTIVITY_SERVICE);
        manager.reportNetworkConnectivity(null, false);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/EphemeralApp1/src/com/android/cts/ephemeralapp1/ClientTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.ephemeralapp1.ClientTest"	"testInstallPermissionNotGranted"	""	"1: permission"	"([4:/com/android/cts/ephemeralapp1/ClientTest.java]:[permission]:[4]:method_text:[on(Manifest.permission.SET_ALARM),                is(PackageManager.PERMISSION_DENIED));    }   ]) :|: 
    public void testInstallPermissionNotGranted() throws Exception {
        assertThat(InstrumentationRegistry.getContext()
                    .checkCallingOrSelfPermission(Manifest.permission.SET_ALARM),
                is(PackageManager.PERMISSION_DENIED));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/EphemeralApp1/src/com/android/cts/ephemeralapp1/ClientTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.ephemeralapp1.ClientTest"	"testInstallPermissionNotGrantedInPackageInfo"	""	"1: permission"	"([3:/com/android/cts/ephemeralapp1/ClientTest.java]:[permission]:[3]:method_text:[  assertThat(isPermissionGrantedInPackageInfo(Manifest.permission.SET_ALARM), is(false));    }   ]) :|: 
    @AsbSecurityTest(cveBugId = 140256621)
    public void testInstallPermissionNotGrantedInPackageInfo() throws Exception {
        assertThat(isPermissionGrantedInPackageInfo(Manifest.permission.SET_ALARM), is(false));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/EphemeralApp1/src/com/android/cts/ephemeralapp1/ClientTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.ephemeralapp1.ClientTest"	"testStartForegroundService"	""	"1: permission"	"([5:/com/android/cts/ephemeralapp1/ClientTest.java]:[permission]:[5]:method_text:[       context.startForegroundService(intent);        latch2.await(5, TimeUnit.SECONDS);    }   ]) :|: 
    public void testStartForegroundService() throws Exception {
        final Context context = InstrumentationRegistry.getContext();
        final Intent intent = new Intent(context, SomeService.class);

        // Create a notification channel for the foreground notification
        final NotificationChannel channel = new NotificationChannel(""foo"", ""foo"",
                NotificationManager.IMPORTANCE_DEFAULT);
        final NotificationManager notificationManager = context.getSystemService(
                NotificationManager.class);
        notificationManager.createNotificationChannel(channel);

        // Shouldn't be able to start without a permission
        final CountDownLatch latch1 = new CountDownLatch(1);
        SomeService.setOnStartCommandCallback((int result) -> {
            assertSame(""Shouldn't be able to start without ""
                    + "" INSTANT_APP_FOREGROUND_SERVICE permission"", 0, result);
            latch1.countDown();
        });
        context.startForegroundService(intent);
        latch1.await(5, TimeUnit.SECONDS);

        // Now grant ourselves INSTANT_APP_FOREGROUND_SERVICE
        grantInstantAppForegroundServicePermission();

        // Should be able to start with a permission
        final CountDownLatch latch2 = new CountDownLatch(1);
        SomeService.setOnStartCommandCallback((int result) -> {
            assertSame(""Should be able to start with ""
                    + "" INSTANT_APP_FOREGROUND_SERVICE permission"", 1, result);
            latch2.countDown();
        });
        context.startForegroundService(intent);
        latch2.await(5, TimeUnit.SECONDS);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/EphemeralApp1/src/com/android/cts/ephemeralapp1/ClientTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.ephemeralapp1.ClientTest"	"testRecordAudioPermission"	""	"1: permission"	"([1:/com/android/cts/ephemeralapp1/ClientTest.java]:[permission]:[1]:method_text:[ioRecord.STATE_INITIALIZED));        } finally {            record.release();        }    }   ]) :|: 
    public void testRecordAudioPermission() throws Throwable {
        final AudioRecord record =
                new AudioRecord(MIC, 8000, CHANNEL_IN_MONO, ENCODING_PCM_16BIT, 4096);
        try {
            assertThat(""audio record not initialized"",
                    record.getState(), is(AudioRecord.STATE_INITIALIZED));
        } finally {
            record.release();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/EphemeralApp1/src/com/android/cts/ephemeralapp1/ClientTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.ephemeralapp1.ClientTest"	"testReadPhoneNumbersPermission"	""	"1: permission"	"([2:/com/android/cts/ephemeralapp1/ClientTest.java]:[permission]:[2]:method_text:[    } catch (SecurityException e) {            fail(""Permission not granted"");        }    }   ]) :|: 
    public void testReadPhoneNumbersPermission() throws Throwable {
        final Context context = InstrumentationRegistry.getContext();
        if (!context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }

        try {
            final TelephonyManager telephonyManager =
                    (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
            final String nmbr = telephonyManager.getLine1Number();
        } catch (SecurityException e) {
            fail(""Permission not granted"");
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/EphemeralApp1/src/com/android/cts/ephemeralapp1/ClientTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.ephemeralapp1.ClientTest"	"testAccessCoarseLocationPermission"	""	"1: permission"	"([2:/com/android/cts/ephemeralapp1/ClientTest.java]:[permission]:[2]:method_text:[   } catch (SecurityException e) {            fail(""Permission not granted."");        }    }   ]) :|: 
    public void testAccessCoarseLocationPermission() {
        final Context context = InstrumentationRegistry.getContext();

        final LocationManager locationManager =
                (LocationManager) context.getSystemService(Context.LOCATION_SERVICE);

        final Criteria criteria = new Criteria();
        criteria.setAccuracy(Criteria.ACCURACY_COARSE);
        final String bestProvider = locationManager.getBestProvider(criteria, false);
        try {
            final String provider =
                    bestProvider == null ? LocationManager.NETWORK_PROVIDER : bestProvider;
            locationManager.getLastKnownLocation(provider);
        } catch (SecurityException e) {
            fail(""Permission not granted."");
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/EphemeralApp1/src/com/android/cts/ephemeralapp1/ClientTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.ephemeralapp1.ClientTest"	"testCameraPermission"	""	"1: permission"	"([1:/com/android/cts/ephemeralapp1/ClientTest.java]:[permission]:[1]:method_text:[ad.getLooper()));        assertThat(latch.await(1000, TimeUnit.MILLISECONDS), is(true));    }   ]) :|: 
    public void testCameraPermission() throws Throwable {
        final Context context = InstrumentationRegistry.getContext();
        final CameraManager manager =
                (CameraManager) context.getSystemService(Context.CAMERA_SERVICE);
        final String[] cameraIds = manager.getCameraIdList();
        if (cameraIds.length == 0) {
            return;
        }
        final CountDownLatch latch = new CountDownLatch(1);
        final HandlerThread backgroundThread = new HandlerThread(""camera_bg"");
        backgroundThread.start();
        final CameraDevice.StateCallback callback = new CameraDevice.StateCallback() {
            @Override
            public void onOpened(CameraDevice camera) {
                latch.countDown();
                camera.close();
            }
            @Override
            public void onDisconnected(CameraDevice camera) {
                camera.close();
            }
            @Override
            public void onError(CameraDevice camera, int error) {
                camera.close();
            }
        };
        manager.openCamera(cameraIds[0], callback, new Handler(backgroundThread.getLooper()));
        assertThat(latch.await(1000, TimeUnit.MILLISECONDS), is(true));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/EphemeralApp1/src/com/android/cts/ephemeralapp1/ClientTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.ephemeralapp1.ClientTest"	"testVibratePermission"	""	"1: permission"	"([1:/com/android/cts/ephemeralapp1/ClientTest.java]:[permission]:[1]:method_text:[.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE);        vibrator.vibrate(effect);    }   ]) :|: 
    public void testVibratePermission() throws Throwable {
        final Vibrator vibrator = (Vibrator) InstrumentationRegistry.getContext()
                .getSystemService(Context.VIBRATOR_SERVICE);
        final VibrationEffect effect =
                VibrationEffect.createOneShot(100, VibrationEffect.DEFAULT_AMPLITUDE);
        vibrator.vibrate(effect);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/EphemeralApp1/src/com/android/cts/ephemeralapp1/ClientTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.ephemeralapp1.ClientTest"	"testWakeLockPermission"	""	"1: permission"	"([1:/com/android/cts/ephemeralapp1/ClientTest.java]:[permission]:[1]:method_text:[null &&  wakeLock.isHeld()) {                wakeLock.release();            }        }    }   ]) :|: 
    public void testWakeLockPermission() throws Throwable {
        WakeLock wakeLock = null;
        try {
            final PowerManager powerManager = (PowerManager) InstrumentationRegistry.getContext()
                    .getSystemService(Context.POWER_SERVICE);
            wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""test"");
            wakeLock.acquire();
        }
        finally {
            if (wakeLock != null &&  wakeLock.isHeld()) {
                wakeLock.release();
            }
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/EphemeralApp1/src/com/android/cts/ephemeralapp1/ClientTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.ephemeralapp1.ClientTest"	"testGetChangedPackages"	""	"1: permission"	"([3:/com/android/cts/ephemeralapp1/ClientTest.java]:[permission]:[3]:method_text:[        @Override        public void onServiceDisconnected(ComponentName name) {        }    }}]) :|: 
    public void testGetChangedPackages() {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();

        // Instant apps can't get changed packages.
        final ChangedPackages changedPackages = pm.getChangedPackages(0);
        assertNull(changedPackages);
    }

    /** Returns {@code true} if the given filter handles all web URLs, regardless of host. */
    private boolean handlesAllWebData(IntentFilter filter) {
        return filter.hasCategory(Intent.CATEGORY_APP_BROWSER) ||
                (handlesWebUris(filter) && filter.countDataAuthorities() == 0);
    }

    /** Returns {@code true} if the given filter handles at least one web URL. */
    private boolean handlesWebUris(IntentFilter filter) {
        // Require ACTION_VIEW, CATEGORY_BROWSEABLE, and at least one scheme
        if (!filter.hasAction(Intent.ACTION_VIEW)
            || !filter.hasCategory(Intent.CATEGORY_BROWSABLE)
            || filter.countDataSchemes() == 0) {
            return false;
        }
        // Now allow only the schemes ""http"" and ""https""
        final Iterator<String> schemesIterator = filter.schemesIterator();
        while (schemesIterator.hasNext()) {
            final String scheme = schemesIterator.next();
            final boolean isWebScheme = ""http"".equals(scheme) || ""https"".equals(scheme);
            if (isWebScheme) {
                return true;
            }
        }
        return false;
    }

    private TestResult getResult() {
        final TestResult result;
        try {
            result = mResultQueue.poll(5, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        if (result == null) {
            throw new IllegalStateException(""Activity didn't receive a Result in 5 seconds"");
        }
        return result;
    }

    private static void grantInstantAppForegroundServicePermission() throws IOException {
        InstrumentationRegistry.getInstr"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/EphemeralApp1/src/com/android/cts/ephemeralapp1/ClientTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.AccessSerialLegacyTest"	"testAccessSerialNoPermissionNeeded"	""	"1: permission"	"([3:/android/os/cts/AccessSerialLegacyTest.java]:[permission]:[3]:method_text:[E permission"");        } catch (SecurityException e) {            /* expected */        }    }}]) :|: 
    public void testAccessSerialNoPermissionNeeded() throws Exception {
        // Build.SERIAL must no longer provide the device serial for legacy apps.
        assertTrue(""Build.SERIAL must not be visible to legacy apps"",
                Build.UNKNOWN.equals(Build.SERIAL));

        // We don't have the READ_PHONE_STATE permission, so this should throw
        try {
            Build.getSerial();
            fail(""getSerial() must be gated on the READ_PHONE_STATE permission"");
        } catch (SecurityException e) {
            /* expected */
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/AccessSerialLegacy/src/android/os/cts/AccessSerialLegacyTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.writeexternalstorageapp.ChangeDefaultUris"	"testResetDefaultUris"	""	"1: permission"	"([1:/com/android/cts/writeexternalstorageapp/ChangeDefaultUris.java]:[permission]:[1]:method_text:[eUnit.MILLISECONDS.sleep(500);            }        }        throw new TimeoutException();    }}]) :|: public void testResetDefaultUris() {
        mContext.getContentResolver()
                .delete(
                        MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
                        MediaStore.MediaColumns.TITLE + "" = ?"",
                        new String[] {RINGER_TITLE});

        Uri uri = RingtoneManager.getValidRingtoneUri(mContext);
        RingtoneManager.setActualDefaultRingtoneUri(mContext, RingtoneManager.TYPE_RINGTONE, uri);
        RingtoneManager.setActualDefaultRingtoneUri(mContext, RingtoneManager.TYPE_ALARM, uri);
        RingtoneManager.setActualDefaultRingtoneUri(
                mContext, RingtoneManager.TYPE_NOTIFICATION, uri);
    }

    /** After the apk installed in secondary user, it may take some time to update permissions. */
    private void copyToExternalStorage(int resId, File path)
            throws InterruptedException, TimeoutException {
        FileCopyHelper copier = new FileCopyHelper(mContext);
        int currentAttempt = 0;
        while (currentAttempt < MAX_NUMBER_OF_ATTEMPTS) {
            try {
                copier.copyToExternalStorage(resId, path);
                return;
            } catch (Exception e) {
                currentAttempt++;
                TimeUnit.MILLISECONDS.sleep(500);
            }
        }
        throw new TimeoutException();
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/WriteExternalStorageApp/src/com/android/cts/writeexternalstorageapp/ChangeDefaultUris.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.writeexternalstorageapp.WriteExternalStorageTest"	"assertExternalStorageMounted"	""	"1: permission"	"([1:/com/android/cts/writeexternalstorageapp/WriteExternalStorageTest.java]:[permission]:[1]:method_text:[{        assertEquals(Environment.MEDIA_MOUNTED, Environment.getExternalStorageState());    }   ]) :|: public void test/*
 *.
 */

package com.android.cts.writeexternalstorageapp;

import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;

import static com.android.cts.externalstorageapp.CommonExternalStorageTest.TAG;
import static com.android.cts.externalstorageapp.CommonExternalStorageTest.assertDirNoWriteAccess;
import static com.android.cts.externalstorageapp.CommonExternalStorageTest.assertDirReadWriteAccess;
import static com.android.cts.externalstorageapp.CommonExternalStorageTest.buildCommonChildDirs;
import static com.android.cts.externalstorageapp.CommonExternalStorageTest.buildProbeFile;
import static com.android.cts.externalstorageapp.CommonExternalStorageTest.deleteContents;
import static com.android.cts.externalstorageapp.CommonExternalStorageTest.getAllPackageSpecificPathsExceptMedia;
import static com.android.cts.externalstorageapp.CommonExternalStorageTest.getMountPaths;
import static com.android.cts.externalstorageapp.CommonExternalStorageTest.getPrimaryPackageSpecificPaths;
import static com.android.cts.externalstorageapp.CommonExternalStorageTest.getSecondaryPackageSpecificPaths;
import static com.android.cts.externalstorageapp.CommonExternalStorageTest.readInt;
import static com.android.cts.externalstorageapp.CommonExternalStorageTest.writeInt;

import android.os.Environment;
import android.os.ParcelFileDescriptor;
import android.provider.MediaStore;
import android.support.test.uiautomator.UiDevice;
import android.system.Os;
import android.test.AndroidTestCase;
import android.util.Log;

import androidx.core.os.BuildCompat;
import com.android.cts.externalstorageapp.CommonExternalStorageTest;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.List;
import java.util.Random;

/**
 * Test external storage from an application that has
 * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE}.
 */
public class WriteExternalStorageTest extends"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/WriteExternalStorageApp/src/com/android/cts/writeexternalstorageapp/WriteExternalStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.applicationvisibility.ApplicationVisibilityCrossUserTest"	"testPackageVisibility_currentUser"	""	"1: permission"	"([1:/com/android/cts/applicationvisibility/ApplicationVisibilityCrossUserTest.java]:[permission]:[1]:method_text:[}    /** Tests getting installed packages for all users, with cross user permission granted */   ]) :|: 
    public void testPackageVisibility_currentUser() throws Exception {
        final PackageManager pm = mContext.getPackageManager();
        final List<PackageInfo> packageList =
                pm.getInstalledPackagesAsUser(0, mContext.getUserId());
        assertFalse(isAppInPackageList(TINY_PKG, packageList));
    }

    /** Tests getting installed packages for all users, with cross user permission granted */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/ApplicationVisibilityCrossUserApp/src/com/android/cts/applicationvisibility/ApplicationVisibilityCrossUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.applicationvisibility.ApplicationVisibilityCrossUserTest"	"testPackageVisibility_anyUserCrossUserGrant"	""	"1: permission"	"([1:/com/android/cts/applicationvisibility/ApplicationVisibilityCrossUserTest.java]:[permission]:[1]:method_text:[}    /** Tests getting installed packages for all users, with cross user permission revoked */   ]) :|: 
    public void testPackageVisibility_anyUserCrossUserGrant() throws Exception {
        final PackageManager pm = mContext.getPackageManager();
        final List<PackageInfo> packageList =
                pm.getInstalledPackagesAsUser(MATCH_KNOWN_PACKAGES, mContext.getUserId());
        assertTrue(isAppInPackageList(TINY_PKG, packageList));
    }

    /** Tests getting installed packages for all users, with cross user permission revoked */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/ApplicationVisibilityCrossUserApp/src/com/android/cts/applicationvisibility/ApplicationVisibilityCrossUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.applicationvisibility.ApplicationVisibilityCrossUserTest"	"testPackageVisibility_anyUserCrossUserNoGrant"	""	"1: permission"	"([2:/com/android/cts/applicationvisibility/ApplicationVisibilityCrossUserTest.java]:[permission]:[2]:method_text:[    /** Tests getting installed packages for another user, with cross user permission granted */   ]) :|: 
    public void testPackageVisibility_anyUserCrossUserNoGrant() throws Exception {
        final PackageManager pm = mContext.getPackageManager();
        try {
            ungrantAcrossUsersPermission();
            final List<PackageInfo> packageList =
                    pm.getInstalledPackagesAsUser(MATCH_KNOWN_PACKAGES, mContext.getUserId());
            fail(""Should have received a security exception"");
        } catch (SecurityException ignore) {}
    }

    /** Tests getting installed packages for another user, with cross user permission granted */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/ApplicationVisibilityCrossUserApp/src/com/android/cts/applicationvisibility/ApplicationVisibilityCrossUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.applicationvisibility.ApplicationVisibilityCrossUserTest"	"testPackageVisibility_otherUserGrant"	""	"1: permission"	"([1:/com/android/cts/applicationvisibility/ApplicationVisibilityCrossUserTest.java]:[permission]:[1]:method_text:[    /** Tests getting installed packages for another user, with cross user permission revoked */   ]) :|: 
    public void testPackageVisibility_otherUserGrant() throws Exception {
        final PackageManager pm = mContext.getPackageManager();
        final List<PackageInfo> packageList =
                pm.getInstalledPackagesAsUser(0, getTestUser());
        assertTrue(isAppInPackageList(TINY_PKG, packageList));
    }

    /** Tests getting installed packages for another user, with cross user permission revoked */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/ApplicationVisibilityCrossUserApp/src/com/android/cts/applicationvisibility/ApplicationVisibilityCrossUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.applicationvisibility.ApplicationVisibilityCrossUserTest"	"testPackageVisibility_otherUserNoGrant"	""	"1: permission"	"([1:/com/android/cts/applicationvisibility/ApplicationVisibilityCrossUserTest.java]:[permission]:[1]:method_text:[Exception ignore) {}    }    /** Tests getting installed applications for the current user */   ]) :|: 
    public void testPackageVisibility_otherUserNoGrant() throws Exception {
        final PackageManager pm = mContext.getPackageManager();
        try {
            ungrantAcrossUsersPermission();
            final List<PackageInfo> packageList =
                    pm.getInstalledPackagesAsUser(0, getTestUser());
            fail(""Should have received a security exception"");
        } catch (SecurityException ignore) {}
    }

    /** Tests getting installed applications for the current user */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/ApplicationVisibilityCrossUserApp/src/com/android/cts/applicationvisibility/ApplicationVisibilityCrossUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.applicationvisibility.ApplicationVisibilityCrossUserTest"	"testApplicationVisibility_currentUser"	""	"1: permission"	"([1:/com/android/cts/applicationvisibility/ApplicationVisibilityCrossUserTest.java]:[permission]:[1]:method_text:[   /** Tests getting installed applications for all users, with cross user permission granted */   ]) :|: 
    public void testApplicationVisibility_currentUser() throws Exception {
        final PackageManager pm = mContext.getPackageManager();
        final List<ApplicationInfo> applicationList =
                pm.getInstalledApplicationsAsUser(0, mContext.getUserId());
        assertFalse(isAppInApplicationList(TINY_PKG, applicationList));
    }

    /** Tests getting installed applications for all users, with cross user permission granted */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/ApplicationVisibilityCrossUserApp/src/com/android/cts/applicationvisibility/ApplicationVisibilityCrossUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.applicationvisibility.ApplicationVisibilityCrossUserTest"	"testApplicationVisibility_anyUserCrossUserGrant"	""	"1: permission"	"([1:/com/android/cts/applicationvisibility/ApplicationVisibilityCrossUserTest.java]:[permission]:[1]:method_text:[   /** Tests getting installed applications for all users, with cross user permission revoked */   ]) :|: 
    public void testApplicationVisibility_anyUserCrossUserGrant() throws Exception {
        final PackageManager pm = mContext.getPackageManager();
        final List<ApplicationInfo> applicationList =
                pm.getInstalledApplicationsAsUser(MATCH_KNOWN_PACKAGES, mContext.getUserId());
        assertTrue(isAppInApplicationList(TINY_PKG, applicationList));
    }

    /** Tests getting installed applications for all users, with cross user permission revoked */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/ApplicationVisibilityCrossUserApp/src/com/android/cts/applicationvisibility/ApplicationVisibilityCrossUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.applicationvisibility.ApplicationVisibilityCrossUserTest"	"testApplicationVisibility_anyUserCrossUserNoGrant"	""	"1: permission"	"([2:/com/android/cts/applicationvisibility/ApplicationVisibilityCrossUserTest.java]:[permission]:[2]:method_text:[/** Tests getting installed applications for another user, with cross user permission granted */   ]) :|: 
    public void testApplicationVisibility_anyUserCrossUserNoGrant() throws Exception {
        final PackageManager pm = mContext.getPackageManager();
        try {
            ungrantAcrossUsersPermission();
            final List<ApplicationInfo> applicationList =
                    pm.getInstalledApplicationsAsUser(MATCH_KNOWN_PACKAGES, mContext.getUserId());
            fail(""Should have received a security exception"");
        } catch (SecurityException ignore) {}
    }

    /** Tests getting installed applications for another user, with cross user permission granted */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/ApplicationVisibilityCrossUserApp/src/com/android/cts/applicationvisibility/ApplicationVisibilityCrossUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.applicationvisibility.ApplicationVisibilityCrossUserTest"	"testApplicationVisibility_otherUserGrant"	""	"1: permission"	"([1:/com/android/cts/applicationvisibility/ApplicationVisibilityCrossUserTest.java]:[permission]:[1]:method_text:[/** Tests getting installed applications for another user, with cross user permission revoked */   ]) :|: 
    public void testApplicationVisibility_otherUserGrant() throws Exception {
        final PackageManager pm = mContext.getPackageManager();
        final List<ApplicationInfo> applicationList =
                pm.getInstalledApplicationsAsUser(0, getTestUser());
        assertTrue(isAppInApplicationList(TINY_PKG, applicationList));
    }

    /** Tests getting installed applications for another user, with cross user permission revoked */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/ApplicationVisibilityCrossUserApp/src/com/android/cts/applicationvisibility/ApplicationVisibilityCrossUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.applicationvisibility.ApplicationVisibilityCrossUserTest"	"testApplicationVisibility_otherUserNoGrant"	""	"1: permission"	"([1:/com/android/cts/applicationvisibility/ApplicationVisibilityCrossUserTest.java]:[permission]:[1]:method_text:[rityException ignore) {}    }    /** Tests getting installed packages for the current user */   ]) :|: 
    public void testApplicationVisibility_otherUserNoGrant() throws Exception {
        final PackageManager pm = mContext.getPackageManager();
        try {
            ungrantAcrossUsersPermission();
            final List<ApplicationInfo> applicationList =
                    pm.getInstalledApplicationsAsUser(0, getTestUser());
            fail(""Should have received a security exception"");
        } catch (SecurityException ignore) {}
    }

    /** Tests getting installed packages for the current user */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/ApplicationVisibilityCrossUserApp/src/com/android/cts/applicationvisibility/ApplicationVisibilityCrossUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.applicationvisibility.ApplicationVisibilityCrossUserTest"	"testGetPackagesForUidVisibility_currentUser"	""	"1: permission"	"([1:/com/android/cts/applicationvisibility/ApplicationVisibilityCrossUserTest.java]:[permission]:[1]:method_text:[    /** Tests getting installed packages for primary user, with cross user permission granted */   ]) :|: 
    public void testGetPackagesForUidVisibility_currentUser() throws Exception {
        final PackageManager pm = mContext.getPackageManager();
        final int userId = mContext.getUserId();
        final int firstAppUid = UserHandle.getUid(userId, Process.FIRST_APPLICATION_UID);
        final int lastAppUid = UserHandle.getUid(userId, Process.LAST_APPLICATION_UID);
        boolean found = false;
        for (int appUid = firstAppUid; appUid < lastAppUid; appUid++) {
            found = isAppInPackageNamesArray(TINY_PKG, pm.getPackagesForUid(appUid));
            if (found) break;
        }
        assertFalse(found);
    }

    /** Tests getting installed packages for primary user, with cross user permission granted */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/ApplicationVisibilityCrossUserApp/src/com/android/cts/applicationvisibility/ApplicationVisibilityCrossUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.applicationvisibility.ApplicationVisibilityCrossUserTest"	"testGetPackagesForUidVisibility_anotherUserCrossUserGrant"	""	"1: permission"	"([1:/com/android/cts/applicationvisibility/ApplicationVisibilityCrossUserTest.java]:[permission]:[1]:method_text:[    /** Tests getting installed packages for primary user, with cross user permission revoked */   ]) :|: 
    public void testGetPackagesForUidVisibility_anotherUserCrossUserGrant() throws Exception {
        final PackageManager pm = mContext.getPackageManager();
        boolean found = false;
        for (int appUid = Process.FIRST_APPLICATION_UID; appUid < Process.LAST_APPLICATION_UID;
                appUid++) {
            found = isAppInPackageNamesArray(TINY_PKG, pm.getPackagesForUid(appUid));
            if (found) break;
        }
        assertTrue(found);
    }

    /** Tests getting installed packages for primary user, with cross user permission revoked */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/ApplicationVisibilityCrossUserApp/src/com/android/cts/applicationvisibility/ApplicationVisibilityCrossUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.applicationvisibility.ApplicationVisibilityCrossUserTest"	"testGetPackagesForUidVisibility_anotherUserCrossUserNoGrant"	""	"1: permission"	"([6:/com/android/cts/applicationvisibility/ApplicationVisibilityCrossUserTest.java]:[permission]:[6]:method_text:[le());        } finally {            uiAutomation.dropShellPermissionIdentity();        }    }}]) :|: 
    public void testGetPackagesForUidVisibility_anotherUserCrossUserNoGrant() throws Exception {
        final PackageManager pm = mContext.getPackageManager();
        ungrantAcrossUsersPermission();
        try {
            for (int appUid = Process.FIRST_APPLICATION_UID; appUid < Process.LAST_APPLICATION_UID;
                    appUid++) {
                isAppInPackageNamesArray(TINY_PKG, pm.getPackagesForUid(appUid));
            }
            fail(""Should have received a security exception"");
        } catch (SecurityException e) {}
    }

    private boolean isAppInPackageList(String packageName,
            List<PackageInfo> packageList) {
        for (PackageInfo pkgInfo : packageList) {
            if (pkgInfo.packageName.equals(packageName)) {
                return true;
            }
        }
        return false;
    }

    private boolean isAppInApplicationList(
            String packageName, List<ApplicationInfo> applicationList) {
        for (ApplicationInfo appInfo : applicationList) {
            if (appInfo.packageName.equals(packageName)) {
                return true;
            }
        }
        return false;
    }

    private boolean isAppInPackageNamesArray(String packageName, String[] packageNames) {
        return packageNames != null && Stream.of(packageNames).anyMatch(
                name -> name.equals(packageName));
    }

    private int getTestUser() {
        final Bundle testArguments = InstrumentationRegistry.getArguments();
        if (testArguments.containsKey(""testUser"")) {
            try {
                return Integer.parseInt(testArguments.getString(""testUser""));
            } catch (NumberFormatException ignore) {}
        }
        return mContext.getUserId();
    }

    private static void ungrantAcrossUsersPermission() {
        final Context context = InstrumentationRegistry.getContext();
        final PackageManager pm = context.getPackageManager();
        final UiAutomation uiAutomation ="	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/ApplicationVisibilityCrossUserApp/src/com/android/cts/applicationvisibility/ApplicationVisibilityCrossUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.deviceids.DeviceIdentifierAppOpTest"	"testAccessToDeviceIdentifiersWithAppOp"	""	"1: permission"	"([8:/android/appsecurity/cts/deviceids/DeviceIdentifierAppOpTest.java]:[permission]:[8]:method_text:[ device identifiers; caught SecurityException instead: ""                    + e);        }    }}]) :|: 
    @AsbSecurityTest(cveBugId = 173421434)
    public void testAccessToDeviceIdentifiersWithAppOp() throws Exception {
        Context context = InstrumentationRegistry.getContext();
        TelephonyManager telephonyManager =
                (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
        try {
            assertEquals(String.format(DEVICE_ID_WITH_APPOP_ERROR_MESSAGE, ""getDeviceId""),
                    ShellIdentityUtils.invokeMethodWithShellPermissions(telephonyManager,
                            (tm) -> tm.getDeviceId()), telephonyManager.getDeviceId());
            assertEquals(String.format(DEVICE_ID_WITH_APPOP_ERROR_MESSAGE, ""getImei""),
                    ShellIdentityUtils.invokeMethodWithShellPermissions(telephonyManager,
                            (tm) -> tm.getImei()), telephonyManager.getImei());
            assertEquals(String.format(DEVICE_ID_WITH_APPOP_ERROR_MESSAGE, ""getMeid""),
                    ShellIdentityUtils.invokeMethodWithShellPermissions(telephonyManager,
                            (tm) -> tm.getMeid()), telephonyManager.getMeid());
            assertEquals(String.format(DEVICE_ID_WITH_APPOP_ERROR_MESSAGE, ""getSubscriberId""),
                    ShellIdentityUtils.invokeMethodWithShellPermissions(telephonyManager,
                            (tm) -> tm.getSubscriberId()), telephonyManager.getSubscriberId());
            assertEquals(
                    String.format(DEVICE_ID_WITH_APPOP_ERROR_MESSAGE, ""getSimSerialNumber""),
                    ShellIdentityUtils.invokeMethodWithShellPermissions(telephonyManager,
                            (tm) -> tm.getSimSerialNumber()),
                    telephonyManager.getSimSerialNumber());
            assertEquals(String.format(DEVICE_ID_WITH_APPOP_ERROR_MESSAGE, ""getNai""),
                    ShellIdentityUtils.invokeMethodWithShellPermissions(telephonyManager,
                            (tm) -> tm.getNai()), telephonyManager.getNai());
            assertEqu"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/DeviceIdentifiers/src/android/appsecurity/cts/deviceids/DeviceIdentifierAppOpTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.AccessSerialModernTest"	"testAccessSerialPermissionNeeded"	""	"1: permission"	"([11:/android/os/cts/AccessSerialModernTest.java]:[permission]:[11]:method_text:[etContext().getPackageName(),                android.Manifest.permission.READ_PHONE_STATE);    }}]) :|: 
    public void testAccessSerialPermissionNeeded() throws Exception {
        // Build.SERIAL should not provide the device serial for modern apps.
        // We don't know the serial but know that it should be the dummy
        // value returned to unauthorized callers, so make sure that value
        assertTrue(""Build.SERIAL must not work for modern apps"",
                Build.UNKNOWN.equals(Build.SERIAL));

        // We don't have the read phone state permission, so this should throw
        try {
            Build.getSerial();
            fail(""getSerial() must be gated on the READ_PHONE_STATE permission"");
        } catch (SecurityException e) {
            /* expected */
        }

        // Now grant ourselves READ_PHONE_STATE
        grantReadPhoneStatePermission();

        // Build.SERIAL should not provide the device serial for modern apps.
        assertTrue(""Build.SERIAL must not work for modern apps"",
                Build.UNKNOWN.equals(Build.SERIAL));

        // To prevent breakage an app targeting pre-Q with the READ_PHONE_STATE permission will
        // receive Build.UNKNOWN; once the app is targeting Q+ a SecurityException will be thrown
        // even if the app has the READ_PHONE_STATE permission.
        try {
            assertEquals(""Build.getSerial() must return "" + Build.UNKNOWN
                            + "" for an app targeting pre-Q with the READ_PHONE_STATE permission"",
                    Build.UNKNOWN, Build.getSerial());
        } catch (SecurityException e) {
            fail(""Build.getSerial() must return "" + Build.UNKNOWN
                    + "" for an app targeting pre-Q with the READ_PHONE_STATE permission, caught ""
                    + ""SecurityException: ""
                    + e);
        }
    }

    private void grantReadPhoneStatePermission() {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                InstrumentationRegistry.getContext().getPackageName(),"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/AccessSerialModern/src/android/os/cts/AccessSerialModernTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.locationpolicy.LocationPolicyTest"	"testLocationPolicyPermissions"	""	"1: permission"	"([8:/android/appsecurity/cts/locationpolicy/LocationPolicyTest.java]:[permission]:[8]:method_text:[h (SecurityException ignore) {              // That's what we want!            }        }    }}]) :|: 
    @AsbSecurityTest(cveBugId = 148414207)
    public void testLocationPolicyPermissions() throws Exception {
        assertNotNull(mContext);
        PackageManager pm = mContext.getPackageManager();
        assertNotNull(pm);
        assertNotEquals(
            PackageManager.PERMISSION_GRANTED,
            pm.checkPermission(Manifest.permission.ACCESS_FINE_LOCATION,
            mContext.getPackageName()));
        assertNotEquals(
            PackageManager.PERMISSION_GRANTED,
            pm.checkPermission(Manifest.permission.ACCESS_COARSE_LOCATION,
            mContext.getPackageName()));
        UserManager manager = mContext.getSystemService(UserManager.class);
        if (manager.isSystemUser()) {
            return;
        }
        if (pm.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            TelephonyManager tele = mContext.getSystemService(TelephonyManager.class);
            try {
                tele.getCellLocation();
            fail(
                ""ACCESS_FINE_LOCATION and ACCESS_COARSE_LOCATION Permissions not granted. Should""
                  + "" have received a security exception when invoking getCellLocation()."");
            } catch (SecurityException ignore) {
              // That's what we want!
            }
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/LocationPolicyApp/src/android/appsecurity/cts/locationpolicy/LocationPolicyTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.storageapp.StorageTest"	"testVerifySpaceApi"	""	"1: permission"	"([1:/com/android/cts/storageapp/StorageTest.java]:[permission]:[1]:method_text:[      fail(""Unexpected access"");        } catch (SecurityException expected) {        }    }   ]) :|: public void testVerifySpaceApi() throws Exception {
        final StorageManager sm = getContext().getSystemService(StorageManager.class);
        final StorageStatsManager stats = getContext().getSystemService(StorageStatsManager.class);

        final long cacheSize = sm.getCacheSizeBytes(
                sm.getUuidForPath(getContext().getCacheDir()));
        final long extCacheSize = sm.getCacheSizeBytes(
                sm.getUuidForPath(getContext().getExternalCacheDir()));
        if (cacheSize == extCacheSize) {
            assertMostlyEquals(CACHE_ALL, cacheSize);
        } else {
            assertMostlyEquals(CACHE_INT, cacheSize);
            assertMostlyEquals(CACHE_EXT, extCacheSize);
        }

        // Verify APIs that don't require any special permissions
        assertTrue(stats.getTotalBytes(StorageManager.UUID_DEFAULT) >= Environment
                .getDataDirectory().getTotalSpace());
        assertTrue(stats.getFreeBytes(StorageManager.UUID_DEFAULT) >= Environment
                .getDataDirectory().getUsableSpace());

        // Verify that we can see our own stats, and that they look sane
        ApplicationInfo ai = getContext().getApplicationInfo();
        final StorageStats pstats = stats.queryStatsForPackage(ai.storageUuid, ai.packageName,
                UserHandle.getUserHandleForUid(ai.uid));
        final StorageStats ustats = stats.queryStatsForUid(ai.storageUuid, ai.uid);
        assertEquals(cacheSize, pstats.getCacheBytes());
        assertEquals(cacheSize, ustats.getCacheBytes());

        // Verify that other packages are off-limits
        ai = getContext().getPackageManager().getApplicationInfo(PKG_B, 0);
        try {
            stats.queryStatsForPackage(ai.storageUuid, ai.packageName,
                    UserHandle.getUserHandleForUid(ai.uid));
            fail(""Unexpected access"");
        } catch (SecurityException expected) {
        }
        try {
            stats.queryStatsForUid(ai.storageUuid, ai.uid);"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/StorageApp/src/com/android/cts/storageapp/StorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.documentclient.DocumentsClientTest"	"findRootListSelector"	""	"1: permission"	"([4:/com/android/cts/documentclient/DocumentsClientTest.java]:[permission]:[4]:method_text:[id tearDown() throws Exception {        super.tearDown();        deleteTestDirectory();    }   ]) :|: public void test/*
 *.
 */

package com.android.cts.documentclient;

import static android.content.Intent.FLAG_GRANT_READ_URI_PERMISSION;
import static android.content.Intent.FLAG_GRANT_WRITE_URI_PERMISSION;

import android.app.Activity;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentSender;
import android.content.pm.PackageManager;
import android.database.Cursor;
import android.graphics.Rect;
import android.net.Uri;
import android.os.Bundle;
import android.os.Environment;
import android.os.SystemClock;
import android.provider.DocumentsContract;
import android.provider.DocumentsContract.Document;
import android.provider.DocumentsContract.Path;
import android.provider.DocumentsProvider;
import android.provider.Settings;
import android.support.test.uiautomator.UiObject;
import android.support.test.uiautomator.UiObjectNotFoundException;
import android.support.test.uiautomator.UiScrollable;
import android.support.test.uiautomator.UiSelector;
import android.test.MoreAsserts;
import android.text.TextUtils;
import android.util.Log;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.android.cts.documentclient.MyActivity.Result;

import java.io.File;
import java.util.List;

/**
 * Tests for {@link DocumentsProvider} and interaction with platform intents
 * like {@link Intent#ACTION_OPEN_DOCUMENT}.
 */
public class DocumentsClientTest extends DocumentsClientTestCase {
    private static final String TAG = ""DocumentsClientTest"";
    private static final String DOWNLOAD_PATH =
            Environment.getExternalStorageDirectory().getAbsolutePath() + File.separatorChar
                    + Environment.DIRECTORY_DOWNLOADS;
    private static final String TEST_DESTINATION_DIRECTORY_NAME = ""TEST_PERMISSION_DESTINATION"";
    private static final String TEST_DESTINATION_DIRECTORY_PATH =
            DOWNLOAD_PATH + File.separatorChar + TEST_DESTINATION_DIRECTORY_NAM"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/DocumentClient/src/com/android/cts/documentclient/DocumentsClientTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.documentclient.DocumentsClientTest"	"testOpenSimple"	""	"1: permission"	"([2:/com/android/cts/documentclient/DocumentsClientTest.java]:[permission]:[2]:method_text:[ock.sleep(500);        MoreAsserts.assertEquals(""replaced!"".getBytes(), readFully(uri));    }   ]) :|: public void testOpenSimple() throws Exception {
        if (!supportedHardware()) return;

        try {
            // Opening without permission should fail
            readFully(Uri.parse(""content://com.android.cts.documentprovider/document/doc:file1""));
            fail(""Able to read data before opened!"");
        } catch (SecurityException expected) {
        }

        final Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        intent.setType(""*/*"");
        mActivity.startActivityForResult(intent, REQUEST_CODE);

        // Ensure that we see both of our roots
        mDevice.waitForIdle();
        assertTrue(""CtsLocal root"", findRoot(""CtsLocal"").exists());
        assertTrue(""CtsCreate root"", findRoot(""CtsCreate"").exists());
        assertFalse(""CtsGetContent root"", findRoot(""CtsGetContent"").exists());

        // Choose the local root.
        mDevice.waitForIdle();
        findRoot(""CtsLocal"").click();

        // Try picking a virtual file. Virtual files must not be returned for CATEGORY_OPENABLE
        // though, so the click should be ignored.
        mDevice.waitForIdle();
        findDocument(""VIRTUAL_FILE"").click();
        mDevice.waitForIdle();

        // Pick a regular file.
        mDevice.waitForIdle();
        findDocument(""FILE1"").click();

        // Confirm that the returned file is a regular file caused by the second click.
        final Result result = mActivity.getResult();
        final Uri uri = result.data.getData();
        assertEquals(""doc:file1"", DocumentsContract.getDocumentId(uri));

        // We should now have permission to read/write
        MoreAsserts.assertEquals(""fileone"".getBytes(), readFully(uri));

        writeFully(uri, ""replaced!"".getBytes());
        SystemClock.sleep(500);
        MoreAsserts.assertEquals(""replaced!"".getBytes(), readFully(uri));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/DocumentClient/src/com/android/cts/documentclient/DocumentsClientTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.documentclient.DocumentsClientTest"	"testGetContent_returnsResultToCallingActivity"	""	"1: permission"	"([1:/com/android/cts/documentclient/DocumentsClientTest.java]:[permission]:[1]:method_text:[ermission to read        MoreAsserts.assertEquals(""filetwo"".getBytes(), readFully(uri));    }   ]) :|: public void testGetContent_returnsResultToCallingActivity() throws Exception {
        if (!supportedHardware()) return;

        final Intent intent = new Intent(Intent.ACTION_GET_CONTENT);
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        intent.setType(""*/*"");
        mActivity.startActivityForResult(intent, REQUEST_CODE);

        mDevice.waitForIdle();
        findRoot(""CtsCreate"").click();

        // Pick the file.
        mDevice.waitForIdle();
        findDocument(""FILE2"").click();

        // Confirm that the returned file is a regular file caused by the click.
        final Result result = mActivity.getResult();
        final Uri uri = result.data.getData();
        assertEquals(""doc:file2"", DocumentsContract.getDocumentId(uri));

        // We should now have permission to read
        MoreAsserts.assertEquals(""filetwo"".getBytes(), readFully(uri));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/DocumentClient/src/com/android/cts/documentclient/DocumentsClientTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.documentclient.DocumentsClientTest"	"testTransferDocument"	""	"1: permission"	"([1:/com/android/cts/documentclient/DocumentsClientTest.java]:[permission]:[1]:method_text:[ls(0, cursorDst.getCount());        } finally {            cursorDst.close();        }    }   ]) :|: public void testTransferDocument() throws Exception {
        if (!supportedHardware()) return;

        try {
            // Opening without permission should fail.
            readFully(Uri.parse(""content://com.android.cts.documentprovider/document/doc:file1""));
            fail(""Able to read data before opened!"");
        } catch (SecurityException expected) {
        }

        final Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT_TREE);
        mActivity.startActivityForResult(intent, REQUEST_CODE);

        mDevice.waitForIdle();
        findRoot(""CtsCreate"").click();

        findDocument(""DIR2"").click();
        mDevice.waitForIdle();
        findSaveButton().click();
        mDevice.waitForIdle();
        findPositiveButton().click();

        final Result result = mActivity.getResult();
        final Uri uri = result.data.getData();

        // We should have selected DIR2.
        final Uri docUri = DocumentsContract.buildDocumentUriUsingTree(uri,
                DocumentsContract.getTreeDocumentId(uri));

        assertEquals(""DIR2"", getColumn(docUri, Document.COLUMN_DISPLAY_NAME));

        final ContentResolver resolver = getInstrumentation().getContext().getContentResolver();
        final Cursor cursor = resolver.query(
                DocumentsContract.buildChildDocumentsUriUsingTree(
                        docUri, DocumentsContract.getDocumentId(docUri)),
                new String[] { Document.COLUMN_DOCUMENT_ID, Document.COLUMN_DISPLAY_NAME,
                        Document.COLUMN_FLAGS },
                null, null, null);

        Uri sourceFileUri = null;
        Uri targetDirUri = null;

        try {
            assertEquals(2, cursor.getCount());
            assertTrue(cursor.moveToFirst());
            sourceFileUri = DocumentsContract.buildDocumentUriUsingTree(
                    docUri, cursor.getString(0));
            assertEquals(""FILE4"", cursor.getString(1));
            assertEquals(Document.FLAG_SUPPORTS_WRITE |"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/DocumentClient/src/com/android/cts/documentclient/DocumentsClientTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.documentclient.DocumentsClientTest"	"testCreateWebLink"	""	"1: permission"	"([1:/com/android/cts/documentclient/DocumentsClientTest.java]:[permission]:[1]:method_text:[       assertEquals(""http://www.foobar.com/shared/SW33TCH3RR13S"", webLinkUri.toString());    }   ]) :|: public void testCreateWebLink() throws Exception {
        if (!supportedHardware()) return;

        final Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);
        intent.setType(""*/*"");
        mActivity.startActivityForResult(intent, REQUEST_CODE);

        // Pick a virtual file from the local root.
        mDevice.waitForIdle();
        findRoot(""CtsLocal"").click();

        mDevice.waitForIdle();
        findDocument(""WEB_LINKABLE_FILE"").click();

        // Confirm that the returned file is actually the selected one.
        final Result result = mActivity.getResult();
        final Uri uri = result.data.getData();
        assertEquals(""doc:web-linkable-file"", DocumentsContract.getDocumentId(uri));

        final ContentResolver resolver = getInstrumentation().getContext().getContentResolver();

        Bundle bundle = new Bundle();
        bundle.putStringArray(Intent.EXTRA_EMAIL, new String[] { ""x@x.com"" });
        final IntentSender intentSender = DocumentsContract.createWebLinkIntent(resolver,
                uri, bundle);

        final int WEB_LINK_REQUEST_CODE = 1;
        mActivity.startIntentSenderForResult(intentSender, WEB_LINK_REQUEST_CODE,
                null, 0, 0, 0);
        mDevice.waitForIdle();

        // Confirm the permissions dialog. The dialog is provided by the stub
        // provider.
        UiObject okButton = new UiObject(new UiSelector().resourceId(""android:id/button1""));
        assertNotNull(okButton);
        assertTrue(okButton.waitForExists(TIMEOUT));
        okButton.click();

        final Result webLinkResult = mActivity.getResult();
        assertEquals(WEB_LINK_REQUEST_CODE, webLinkResult.requestCode);
        assertEquals(Activity.RESULT_OK, webLinkResult.resultCode);

        final Uri webLinkUri = webLinkResult.data.getData();
        assertEquals(""http://www.foobar.com/shared/SW33TCH3RR13S"", webLinkUri.toString());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/DocumentClient/src/com/android/cts/documentclient/DocumentsClientTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.documentclient.DocumentsClientTest"	"testAfterMoveDocumentInStorage_revokeUriPermission"	""	"1: permission"	"([16:/com/android/cts/documentclient/DocumentsClientTest.java]:[permission]:[16]:method_text:[NATION_DIRECTORY_PATH);        executeShellCommand(""rm -rf "" + TEST_SOURCE_DIRECTORY_PATH);    }}]) :|: public void testAfterMoveDocumentInStorage_revokeUriPermission() throws Exception {
        if (!supportedHardware()) return;

        final Context context = getInstrumentation().getContext();
        final Uri initUri = DocumentsContract.buildDocumentUri(STORAGE_AUTHORITY,
                ""primary:"" + Environment.DIRECTORY_DOWNLOADS);

        // create the source directory
        final Uri sourceUri = assertCreateDocumentSuccess(initUri, TEST_SOURCE_DIRECTORY_NAME,
                Document.MIME_TYPE_DIR);

        // create the target directory
        final Uri targetUri = assertCreateDocumentSuccess(sourceUri, TEST_TARGET_DIRECTORY_NAME,
                Document.MIME_TYPE_DIR);
        final int permissionFlag = FLAG_GRANT_READ_URI_PERMISSION | FLAG_GRANT_WRITE_URI_PERMISSION;

        // check permission for the target uri
        assertEquals(PackageManager.PERMISSION_GRANTED,
                context.checkCallingOrSelfUriPermission(targetUri, permissionFlag));

        // create the destination directory
        final Uri destinationUri = assertCreateDocumentSuccess(initUri,
                TEST_DESTINATION_DIRECTORY_NAME, Document.MIME_TYPE_DIR);

        final ContentResolver resolver = context.getContentResolver();
        final Uri movedFileUri = DocumentsContract.moveDocument(resolver, targetUri, sourceUri,
                destinationUri);
        assertTrue(movedFileUri != null);

        // after moving the document,  the permission of targetUri is revoked
        assertEquals(PackageManager.PERMISSION_DENIED,
                context.checkCallingOrSelfUriPermission(targetUri, permissionFlag));

        // create the target directory again, it still has no permission for targetUri
        executeShellCommand(""mkdir "" + TEST_TARGET_DIRECTORY_PATH);

        assertEquals(PackageManager.PERMISSION_DENIED,
                context.checkCallingOrSelfUriPermission(targetUri, permissionFlag));
    }

    private Uri assertCreateDocumentSuccess(@Nullable Uri in"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/DocumentClient/src/com/android/cts/documentclient/DocumentsClientTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.mediastorageapp.MediaStorageTest"	"testMediaNone"	""	"1: permission"	"([5:/com/android/cts/mediastorageapp/MediaStorageTest.java]:[permission]:[5]:method_text:[ }        }    }    /**     * Test prefix and non-prefix uri grant for all packages     */   ]) :|: 
    public void testMediaNone() throws Exception {
        doMediaNone(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, MediaStorageTest::createAudio);
        doMediaNone(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, MediaStorageTest::createVideo);
        doMediaNone(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, MediaStorageTest::createImage);

        // But since we don't hold the Music permission, we can't read the
        // indexed metadata
        try (Cursor c = mContentResolver.query(MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI,
                null, null, null)) {
            assertEquals(0, c.getCount());
        }
        try (Cursor c = mContentResolver.query(MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI,
                null, null, null)) {
            assertEquals(0, c.getCount());
        }
        try (Cursor c = mContentResolver.query(MediaStore.Audio.Genres.EXTERNAL_CONTENT_URI,
                null, null, null)) {
            assertEquals(0, c.getCount());
        }
    }

    private void doMediaNone(Uri collection, Callable<Uri> create) throws Exception {
        final Uri red = create.call();
        final Uri blue = create.call();

        clearMediaOwner(blue, mUserId);

        // Since we have no permissions, we should only be able to see media
        // that we've contributed
        final HashSet<Long> seen = new HashSet<>();
        try (Cursor c = mContentResolver.query(collection,
                new String[] { MediaColumns._ID }, null, null)) {
            while (c.moveToNext()) {
                seen.add(c.getLong(0));
            }
        }

        assertTrue(seen.contains(ContentUris.parseId(red)));
        assertFalse(seen.contains(ContentUris.parseId(blue)));

        try (ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(red, ""rw"")) {
        }
        try (ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(blue, ""r"")) {
            fail(""Expected read access to be blocked"");
        } catch (SecurityEx"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/MediaStorageApp/src/com/android/cts/mediastorageapp/MediaStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.mediastorageapp.MediaStorageTest"	"testGrantUriPermission"	""	"1: permission"	"([14:/com/android/cts/mediastorageapp/MediaStorageTest.java]:[permission]:[14]:method_text:[String(mode));            } catch (SecurityException expected) {            }        }    }   ]) :|: 
    public void testGrantUriPermission() {
        final int flagGrantRead = Intent.FLAG_GRANT_READ_URI_PERMISSION;
        final int flagGrantWrite = Intent.FLAG_GRANT_WRITE_URI_PERMISSION;
        final int flagGrantReadPrefix =
                Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION;
        final int flagGrantWritePrefix =
                Intent.FLAG_GRANT_WRITE_URI_PERMISSION | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION;

        for (Uri uri : new Uri[] {
                MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
                MediaStore.Video.Media.EXTERNAL_CONTENT_URI,
                MediaStore.Audio.Media.EXTERNAL_CONTENT_URI,
                MediaStore.Downloads.EXTERNAL_CONTENT_URI,
                MediaStore.Files.getContentUri(MediaStore.VOLUME_EXTERNAL)
        }) {
            // Non-prefix grant
            checkGrantUriPermission(uri, flagGrantRead, true);
            checkGrantUriPermission(uri, flagGrantWrite, true);

            // Prefix grant
            checkGrantUriPermission(uri, flagGrantReadPrefix, false);
            checkGrantUriPermission(uri, flagGrantWritePrefix, false);
        }
    }

    private void checkGrantUriPermission(Uri uri, int mode, boolean isGrantAllowed) {
        if (isGrantAllowed) {
            mContext.grantUriPermission(mContext.getPackageName(), uri, mode);
        } else {
            try {
                mContext.grantUriPermission(mContext.getPackageName(), uri, mode);
                fail(""Expected granting to be blocked for flag 0x"" + Integer.toHexString(mode));
            } catch (SecurityException expected) {
            }
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/MediaStorageApp/src/com/android/cts/mediastorageapp/MediaStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.mediastorageapp.MediaStorageTest"	"testMediaRead"	""	"1: permission"	"([1:/com/android/cts/mediastorageapp/MediaStorageTest.java]:[permission]:[1]:method_text:[ocked"");        } catch (SecurityException | FileNotFoundException expected) {        }    }   ]) :|: 
    public void testMediaRead() throws Exception {
        doMediaRead(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, MediaStorageTest::createAudio);
        doMediaRead(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, MediaStorageTest::createVideo);
        doMediaRead(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, MediaStorageTest::createImage);
    }

    private void doMediaRead(Uri collection, Callable<Uri> create) throws Exception {
        final Uri red = create.call();
        final Uri blue = create.call();

        clearMediaOwner(blue, mUserId);

        // Holding read permission we can see items we don't own
        final HashSet<Long> seen = new HashSet<>();
        try (Cursor c = mContentResolver.query(collection,
                new String[] { MediaColumns._ID }, null, null)) {
            while (c.moveToNext()) {
                seen.add(c.getLong(0));
            }
        }

        assertTrue(seen.contains(ContentUris.parseId(red)));
        assertTrue(seen.contains(ContentUris.parseId(blue)));

        try (ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(red, ""rw"")) {
        }
        try (ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(blue, ""r"")) {
        }
        try (ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(blue, ""w"")) {
            fail(""Expected write access to be blocked"");
        } catch (SecurityException | FileNotFoundException expected) {
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/MediaStorageApp/src/com/android/cts/mediastorageapp/MediaStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.mediastorageapp.MediaStorageTest"	"testMediaWrite"	""	"1: permission"	"([1:/com/android/cts/mediastorageapp/MediaStorageTest.java]:[permission]:[1]:method_text:[   } catch (SecurityException | FileNotFoundException expected) {            }        }    }   ]) :|: 
    public void testMediaWrite() throws Exception {
        doMediaWrite(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, MediaStorageTest::createAudio);
        doMediaWrite(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, MediaStorageTest::createVideo);
        doMediaWrite(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, MediaStorageTest::createImage);
    }

    private void doMediaWrite(Uri collection, Callable<Uri> create) throws Exception {
        final Uri red = create.call();
        final Uri blue = create.call();

        clearMediaOwner(blue, mUserId);

        // Holding read permission we can see items we don't own
        final HashSet<Long> seen = new HashSet<>();
        try (Cursor c = mContentResolver.query(collection,
                new String[] { MediaColumns._ID }, null, null)) {
            while (c.moveToNext()) {
                seen.add(c.getLong(0));
            }
        }

        assertTrue(seen.contains(ContentUris.parseId(red)));
        assertTrue(seen.contains(ContentUris.parseId(blue)));

        try (ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(red, ""rw"")) {
        }
        try (ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(blue, ""r"")) {
        }
        if (Environment.isExternalStorageLegacy()) {
            try (ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(blue, ""w"")) {
            }
        } else {
            try (ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(blue, ""w"")) {
                fail(""Expected write access to be blocked"");
            } catch (SecurityException | FileNotFoundException expected) {
            }
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/MediaStorageApp/src/com/android/cts/mediastorageapp/MediaStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.mediastorageapp.MediaStorageTest"	"testMediaEscalation_RequestDelete_notShowConfirmDialog"	""	"1: permission"	"([2:/com/android/cts/mediastorageapp/MediaStorageTest.java]:[permission]:[2]:method_text:[ure(String feature) {        return mContext.getPackageManager().hasSystemFeature(feature);    }}]) :|: 
    public void testMediaEscalation_RequestDelete_notShowConfirmDialog() throws Exception {
        doMediaEscalation_RequestDelete(true /* allowAccess */,
                true /* shouldCheckDialogShownValue */, false /* isDialogShownExpected */);
    }

    private void doMediaEscalation_RequestDelete(boolean allowAccess,
            boolean shouldCheckDialogShownValue, boolean isDialogShownExpected) throws Exception {
        doMediaEscalation_RequestDelete(MediaStorageTest::createAudio, allowAccess,
                shouldCheckDialogShownValue, isDialogShownExpected);
        doMediaEscalation_RequestDelete(MediaStorageTest::createVideo, allowAccess,
                shouldCheckDialogShownValue, isDialogShownExpected);
        doMediaEscalation_RequestDelete(MediaStorageTest::createImage, allowAccess,
                shouldCheckDialogShownValue, isDialogShownExpected);
        doMediaEscalation_RequestDelete(MediaStorageTest::createPlaylist, allowAccess,
                shouldCheckDialogShownValue, isDialogShownExpected);
        doMediaEscalation_RequestDelete(MediaStorageTest::createSubtitle, allowAccess,
                shouldCheckDialogShownValue, isDialogShownExpected);
    }

    private void doMediaEscalation_RequestDelete(Callable<Uri> create, boolean allowAccess,
            boolean shouldCheckDialogShownValue, boolean isDialogShownExpected) throws Exception {
        final Uri red = create.call();
        clearMediaOwner(red, mUserId);

        try (Cursor c = mContentResolver.query(red, null, null, null)) {
            assertEquals(1, c.getCount());
        }

        if (allowAccess) {
            doEscalation(MediaStore.createDeleteRequest(mContentResolver, Arrays.asList(red)),
                    true /* allowAccess */, shouldCheckDialogShownValue, isDialogShownExpected);
            try (Cursor c = mContentResolver.query(red, null, null, null)) {
                assertEquals(0, c.getCount());
            }
        } else {
            doEscalation(M"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/MediaStorageApp/src/com/android/cts/mediastorageapp/MediaStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.splitapp.SplitAppTest"	"testFeatureWarmBase"	""	"3: INTERNET permission.INTERNET permission"	"([7:/com/android/cts/splitapp/SplitAppTest.java]:[permission]:[7]:method_text:[);            i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);            return i;        }    }   ]) :|: 
    public void testFeatureWarmBase() throws Exception {
        final Resources r = getContext().getResources();
        final PackageManager pm = getContext().getPackageManager();

        // Should have untouched resources from base
        assertEquals(false, r.getBoolean(R.bool.my_receiver_enabled));

        assertEquals(""blue"", r.getString(R.string.my_string1));
        assertEquals(""purple"", r.getString(R.string.my_string2));

        assertEquals(0xff00ff00, r.getColor(R.color.my_color));
        assertEquals(123, r.getInteger(R.integer.my_integer));

        assertEquals(""base"", getXmlTestValue(r.getXml(R.xml.my_activity_meta)));

        // And that we can access resources from feature
        assertEquals(""red"", r.getString(r.getIdentifier(
                ""com.android.cts.splitapp.feature_warm:feature_string"", ""string"", PKG)));
        assertEquals(123, r.getInteger(r.getIdentifier(
                ""com.android.cts.splitapp.feature_warm:feature_integer"", ""integer"", PKG)));

        final Class<?> featR = Class.forName(""com.android.cts.splitapp.FeatureR"");
        final int boolId = (int) featR.getDeclaredField(""feature_receiver_enabled"").get(null);
        final int intId = (int) featR.getDeclaredField(""feature_integer"").get(null);
        final int stringId = (int) featR.getDeclaredField(""feature_string"").get(null);
        assertEquals(true, r.getBoolean(boolId));
        assertEquals(123, r.getInteger(intId));
        assertEquals(""red"", r.getString(stringId));

        // Should have both base and feature assets
        assertAssetContents(r, ""file1.txt"", ""FILE1"");
        assertAssetContents(r, ""file2.txt"", ""FILE2"");
        assertAssetContents(r, ""dir/dirfile1.txt"", ""DIRFILE1"");
        assertAssetContents(r, ""dir/dirfile2.txt"", ""DIRFILE2"");

        // Should have both base and feature components
        Intent intent = new Intent(Intent.ACTION_MAIN);
        intent.addCategory(Intent.CATEGORY_LAUNCHER);
        intent.setPackage(PKG);
        L"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/SplitApp/src/com/android/cts/splitapp/SplitAppTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.splitapp.SplitAppTest"	"testInheritUpdatedBase_withRevisionA"	""	"1: permission"	"([6:/com/android/cts/splitapp/SplitAppTest.java]:[permission]:[6]:method_text:[  getContext().enforceCallingOrSelfPermission(android.Manifest.permission.VIBRATE, null);    }   ]) :|: 
    public void testInheritUpdatedBase_withRevisionA() throws Exception {
        final Resources r = getContext().getResources();
        final PackageManager pm = getContext().getPackageManager();

        // Resources should have been updated
        assertEquals(true, r.getBoolean(R.bool.my_receiver_enabled));

        assertEquals(""blue-revision"", r.getString(R.string.my_string1));
        assertEquals(""purple-revision"", r.getString(R.string.my_string2));

        assertEquals(0xff00ffff, r.getColor(R.color.my_color));
        assertEquals(456, r.getInteger(R.integer.my_integer));

        // Also, new resources could be found
        assertEquals(""new string"", r.getString(r.getIdentifier(
                ""my_new_string"", ""string"", PKG)));

        assertAssetContents(r, ""fileA.txt"", ""FILEA"");
        assertAssetContents(r, ""dir/dirfileA.txt"", ""DIRFILEA"");

        // Activity of ACTION_MAIN should have been updated to .revision_a.MyActivity
        Intent intent = new Intent(Intent.ACTION_MAIN);
        intent.addCategory(Intent.CATEGORY_LAUNCHER);
        intent.setPackage(PKG);
        final List<String> activityNames = pm.queryIntentActivities(intent, 0).stream()
                .map(info -> info.activityInfo.name).collect(Collectors.toList());
        assertThat(activityNames).contains(""com.android.cts.splitapp.revision_a.MyActivity"");

        // Receiver of DATE_CHANGED should have been updated to .revision_a.MyReceiver
        intent = new Intent(Intent.ACTION_DATE_CHANGED);
        intent.setPackage(PKG);
        final List<String> receiverNames = pm.queryBroadcastReceivers(intent, 0).stream()
                .map(info -> info.activityInfo.name).collect(Collectors.toList());
        assertThat(receiverNames).contains(""com.android.cts.splitapp.revision_a.MyReceiver"");

        // Provider should have been updated to .revision_a.MyProvider
        final ProviderInfo info = pm.resolveContentProvider(""com.android.cts.splitapp"", 0);
        assertEquals(""c"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/SplitApp/src/com/android/cts/splitapp/SplitAppTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.splitapp.SplitAppTest"	"testPrimaryOnSameVolume"	""	"1: permission"	"([1:/com/android/cts/splitapp/SplitAppTest.java]:[permission]:[1]:method_text:[00) {            fail(""Expected primary storage to be on same volume as app"");        }    }   ]) :|: 
    public void testPrimaryOnSameVolume() throws Exception {
        final File current = getContext().getFilesDir();
        final File primary = Environment.getExternalStorageDirectory();

        // Shared storage may jump through another filesystem for permission
        // enforcement, so we verify that total/free space are identical.
        final long totalDelta = Math.abs(current.getTotalSpace() - primary.getTotalSpace());
        final long freeDelta = Math.abs(current.getFreeSpace() - primary.getFreeSpace());
        if (totalDelta > MB_IN_BYTES * 300 || freeDelta > MB_IN_BYTES * 300) {
            fail(""Expected primary storage to be on same volume as app"");
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/SplitApp/src/com/android/cts/splitapp/SplitAppTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.readsettingsfieldsapp.ReadSettingsFieldsTest"	"testGlobalHiddenSettingsKeysNotReadableWithoutAnnotation"	""	"1: permission"	"([1:/com/android/cts/readsettingsfieldsapp/ReadSettingsFieldsTest.java]:[permission]:[1]:method_text:[d with readable annotation but access should be    // protected by additional permission check.   ]) :|: public void testGlobalHiddenSettingsKeysNotReadableWithoutAnnotation() {
        final ArraySet<String> publicSettingsKeys = getNonHiddenSettingsKeys(Settings.Global.class);
        final String[] hiddenSettingsKeys = {""restricted_networking_mode"",
                ""people_space_conversation_type""};
        testHiddenSettingsKeysNotReadableWithoutAnnotation(Settings.Global.class,
                publicSettingsKeys, hiddenSettingsKeys);
    }

    // test the cases that hidden keys are marked with readable annotation but access should be
    // protected by additional permission check."	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/ReadSettingsFieldsApp/src/com/android/cts/readsettingsfieldsapp/ReadSettingsFieldsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.readsettingsfieldsapp.ReadSettingsFieldsTest"	"testGlobalHiddenSettingsKeyNotReadableWithoutPermissions"	""	"1: permission"	"([6:/com/android/cts/readsettingsfieldsapp/ReadSettingsFieldsTest.java]:[permission]:[6]:method_text:[    }    /** Test hidden keys are readable if the app is test only, even without annotation */   ]) :|: public void testGlobalHiddenSettingsKeyNotReadableWithoutPermissions() {
        final String[] hiddenSettingsKeysRequiresPermissions = {""multi_sim_data_call""};
        for (String key : hiddenSettingsKeysRequiresPermissions) {
            try {
                // Verify that the hidden keys can't be accessed due to lack of permissions.
                callGetStringMethod(Settings.Global.class, key);
            } catch (SecurityException ex) {
                assertTrue(ex.getMessage().contains(""permission""));
                continue;
            }
            fail(""Reading hidden "" + Settings.Global.class.getSimpleName() + "" settings key <"" + key
                    + ""> should be protected with permission!"");
        }
    }

    private <T extends Settings.NameValueTable>
    void testHiddenSettingsKeysNotReadableWithoutAnnotation(
            Class<T> settingsClass, ArraySet<String> publicKeys, String[] targetKeys) {
        for (String key : targetKeys) {
            // Verify that the hidden keys are not visible to the test app
            assertFalse(""Settings key <"" + key + ""> should not be visible"",
                    publicKeys.contains(key));
            try {
                // Verify that the hidden keys cannot be read
                callGetStringMethod(settingsClass, key);
                fail(""Reading hidden "" + settingsClass.getSimpleName() + "" settings key <"" + key
                        + ""> should raise!"");
            } catch (SecurityException ex) {
                assertTrue(ex.getMessage().contains(
                        ""Settings key: <"" + key + ""> is not readable.""));
            }
        }
    }

    /** Test hidden keys are readable if the app is test only, even without annotation */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/ReadSettingsFieldsApp/src/com/android/cts/readsettingsfieldsapp/ReadSettingsFieldsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.v3rotationtests.V3RotationTest"	"testHasPerm"	""	"1: permission"	"([4:/android/appsecurity/cts/v3rotationtests/V3RotationTest.java]:[permission]:[4]:method_text:[SSION_NAME, COMPANION_PKG)                        == PackageManager.PERMISSION_GRANTED);    }   ]) :|: public void testHasPerm() throws Exception {
        PackageManager pm = getContext().getPackageManager();
        assertTrue(PERMISSION_NAME + "" not granted to "" + COMPANION_PKG,
                pm.checkPermission(PERMISSION_NAME, COMPANION_PKG)
                        == PackageManager.PERMISSION_GRANTED);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/V3SigningSchemeRotation/src/android/appsecurity/cts/v3rotationtests/V3RotationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.v3rotationtests.V3RotationTest"	"testHasNoPerm"	""	"1: permission"	"([4:/android/appsecurity/cts/v3rotationtests/V3RotationTest.java]:[permission]:[4]:method_text:[SSION_NAME, COMPANION_PKG)                        == PackageManager.PERMISSION_GRANTED);    }   ]) :|: public void testHasNoPerm() throws Exception {
        PackageManager pm = getContext().getPackageManager();
        assertFalse(PERMISSION_NAME + "" granted to "" + COMPANION_PKG,
                pm.checkPermission(PERMISSION_NAME, COMPANION_PKG)
                        == PackageManager.PERMISSION_GRANTED);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/V3SigningSchemeRotation/src/android/appsecurity/cts/v3rotationtests/V3RotationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ListeningPortsTest"	"testNoRemotelyAccessibleListeningUdp6Ports"	"CtsAppSecurityHostTestCases"	"1: permission"	"([1:/android/appsecurity/cts/ListeningPortsTest.java]:[permission]:[1]:method_text:[our socket.     *     * Please convert loopback IP connections to unix domain sockets.     */   ]) :|: public void testNoRemotelyAccessibleListeningUdp6Ports() throws Exception {
        assertNoRemotelyAccessibleListeningUdpPorts(""/proc/net/udp6"", false);
    }
    */

    /**
     * Locally accessible ports are often targeted by malicious locally
     * installed programs to gain unauthorized access to program data or
     * cause system corruption.
     *
     * In all cases, a local listening IP port can be replaced by a UNIX domain
     * socket. Unix domain sockets can be protected with unix filesystem
     * permission. Alternatively, you can use getsockopt(SO_PEERCRED) to
     * determine if a program is authorized to connect to your socket.
     *
     * Please convert loopback IP connections to unix domain sockets.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ListeningPortsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ListeningPortsTest"	"testNoListeningLoopbackTcpPorts"	"CtsAppSecurityHostTestCases"	"1: permission"	"([1:/android/appsecurity/cts/ListeningPortsTest.java]:[permission]:[1]:method_text:[our socket.     *     * Please convert loopback IP connections to unix domain sockets.     */   ]) :|: public void testNoListeningLoopbackTcpPorts() throws Exception {
        assertNoAccessibleListeningPorts(""/proc/net/tcp"", true, true);
    }

    /**
     * Locally accessible ports are often targeted by malicious locally
     * installed programs to gain unauthorized access to program data or
     * cause system corruption.
     *
     * In all cases, a local listening IP port can be replaced by a UNIX domain
     * socket. Unix domain sockets can be protected with unix filesystem
     * permission. Alternatively, you can use getsockopt(SO_PEERCRED) to
     * determine if a program is authorized to connect to your socket.
     *
     * Please convert loopback IP connections to unix domain sockets.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ListeningPortsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ListeningPortsTest"	"testNoListeningLoopbackTcp6Ports"	"CtsAppSecurityHostTestCases"	"1: permission"	"([1:/android/appsecurity/cts/ListeningPortsTest.java]:[permission]:[1]:method_text:[redentials.     *     * Please convert loopback IP connections to unix domain sockets.     */   ]) :|: public void testNoListeningLoopbackTcp6Ports() throws Exception {
        assertNoAccessibleListeningPorts(""/proc/net/tcp6"", true, true);
    }

    /**
     * Locally accessible ports are often targeted by malicious locally
     * installed programs to gain unauthorized access to program data or
     * cause system corruption.
     *
     * In all cases, a local listening IP port can be replaced by a UNIX domain
     * socket. Unix domain sockets can be protected with unix filesystem
     * permission.  Alternately, or you can use setsockopt(SO_PASSCRED) to
     * send credentials, and recvmsg to retrieve the passed credentials.
     *
     * Please convert loopback IP connections to unix domain sockets.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ListeningPortsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ListeningPortsTest"	"testNoListeningLoopbackUdpPorts"	"CtsAppSecurityHostTestCases"	"1: permission"	"([1:/android/appsecurity/cts/ListeningPortsTest.java]:[permission]:[1]:method_text:[redentials.     *     * Please convert loopback IP connections to unix domain sockets.     */   ]) :|: public void testNoListeningLoopbackUdpPorts() throws Exception {
        assertNoAccessibleListeningPorts(""/proc/net/udp"", false, true);
    }

    /**
     * Locally accessible ports are often targeted by malicious locally
     * installed programs to gain unauthorized access to program data or
     * cause system corruption.
     *
     * In all cases, a local listening IP port can be replaced by a UNIX domain
     * socket. Unix domain sockets can be protected with unix filesystem
     * permission.  Alternately, or you can use setsockopt(SO_PASSCRED) to
     * send credentials, and recvmsg to retrieve the passed credentials.
     *
     * Please convert loopback IP connections to unix domain sockets.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ListeningPortsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.KeySetHostTest"	"isRunFailure"	"CtsAppSecurityHostTestCases"	"1: permission"	"([3:/android/appsecurity/cts/KeySetHostTest.java]:[permission]:[3]:method_text:[k which does not specify an upgrade-key-set may be upgraded     * to an apk which does.     */   ]) :|: public void test/*
 *.
 */

package android.appsecurity.cts;

import com.android.compatibility.common.tradefed.build.CompatibilityBuildHelper;
import com.android.ddmlib.testrunner.RemoteAndroidTestRunner;
import com.android.ddmlib.testrunner.TestResult.TestStatus;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.result.CollectingTestListener;
import com.android.tradefed.result.TestDescription;
import com.android.tradefed.result.TestResult;
import com.android.tradefed.result.TestRunResult;
import com.android.tradefed.testtype.DeviceTestCase;
import com.android.tradefed.testtype.IBuildReceiver;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Map;

/**
 * Tests for Keyset based features.
 */
public class KeySetHostTest extends DeviceTestCase implements IBuildReceiver {

    private static final String RUNNER = ""androidx.test.runner.AndroidJUnitRunner"";

    /* package with device-side tests */
    private static final String KEYSET_TEST_PKG = ""com.android.cts.keysets.testapp"";
    private static final String KEYSET_TEST_APP_APK = ""CtsKeySetTestApp.apk"";

    /* plain test apks with different signing and upgrade keysets */
    private static final String KEYSET_PKG = ""com.android.cts.keysets"";
    private static final String A_SIGNED_NO_UPGRADE =
            ""CtsKeySetSigningAUpgradeNone.apk"";
    private static final String A_SIGNED_A_UPGRADE =
            ""CtsKeySetSigningAUpgradeA.apk"";
    private static final String A_SIGNED_B_UPGRADE =
            ""CtsKeySetSigningAUpgradeB.apk"";
    private static final String A_SIGNED_A_OR_B_UPGRADE =
            ""CtsKeySetSigningAUpgradeAOrB.apk"";
    private static final String B_SIGNED_A_UPGRADE =
            ""CtsKeySetSigningBUpgradeA.apk"";
    private static final String B_SIGNED_B_UPGRADE =
            ""CtsKeySetSigningBUpgradeB.apk"";
    private static final"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/KeySetHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.KeySetHostTest"	"testUpgradeKSWithMultipleUpgradeKeySetsFirstKey"	"CtsAppSecurityHostTestCases"	"1: permission"	"([11:/android/appsecurity/cts/KeySetHostTest.java]:[permission]:[11]:method_text:[sion after changing to a new     * signature, for which a permission should be granted.     */   ]) :|: public void testUpgradeKSWithMultipleUpgradeKeySetsFirstKey() throws Exception {
        String installResult = testPackageUpgrade(KEYSET_PKG, A_SIGNED_A_OR_B_UPGRADE,
                A_SIGNED_A_UPGRADE);
        assertNull(String.format(""failed to upgrade keyset app from one signed by key-a""
                + ""to one signed by first upgrade keyset key-a, Reason: %s"", installResult),
                installResult);
        installResult = testPackageUpgrade(KEYSET_PKG, A_SIGNED_A_OR_B_UPGRADE,
                B_SIGNED_B_UPGRADE);
        assertNull(String.format(""failed to upgrade keyset app from one signed by key-a""
                + ""to one signed by second upgrade keyset key-b, Reason: %s"", installResult),
                installResult);
    }

    /**
     * Helper method which installs a package defining a permission and a package
     * using the permission, and then rotates the signing keys for one of them.
     * A device-side test is then used to ascertain whether or not the permission
     * was appropriately gained or lost.
     *
     * @param permDefApk - apk to install which defines the sig-permissoin
     * @param permUseApk - apk to install which declares it uses the permission
     * @param upgradeApk - apk to install which upgrades one of the first two
     * @param hasPermBeforeUpgrade - whether we expect the consuming app to have
     *        the permission before the upgrade takes place.
     * @param hasPermAfterUpgrade - whether we expect the consuming app to have
     *        the permission after the upgrade takes place.
     */
    private void testKeyRotationPerm(String permDefApk, String permUseApk,
            String upgradeApk, boolean hasPermBeforeUpgrade,
            boolean hasPermAfterUpgrade) throws Exception {
        try {

            /* cleanup test apps that might be installed from previous partial test run */
            mDevice.uninstallPackage(KEYSET_PKG);
            mDevice.uninstallPackage(KEYSET_PERM_DEF_PKG);"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/KeySetHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.KeySetHostTest"	"testUpgradeSigPermGained"	"CtsAppSecurityHostTestCases"	"1: permission"	"([2:/android/appsecurity/cts/KeySetHostTest.java]:[permission]:[2]:method_text:[nging to a new     * signature, from one for which a permission was previously granted.     */   ]) :|: public void testUpgradeSigPermGained() throws Exception {
        testKeyRotationPerm(PERM_DEF_A_SIGNED, PERM_USE_B_SIGNED, PERM_USE_A_SIGNED,
                false, true);
    }

    /*
     * Check if an apk loses signature-level permission after changing to a new
     * signature, from one for which a permission was previously granted.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/KeySetHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.KeySetHostTest"	"testUpgradeSigPermLost"	"CtsAppSecurityHostTestCases"	"1: permission"	"([1:/android/appsecurity/cts/KeySetHostTest.java]:[permission]:[1]:method_text:[gnature-level permission after the app defining     * it rotates to the same signature.     */   ]) :|: public void testUpgradeSigPermLost() throws Exception {
        testKeyRotationPerm(PERM_DEF_A_SIGNED, PERM_USE_A_SIGNED, PERM_USE_B_SIGNED,
                true, false);
    }

    /*
     * Check if an apk gains signature-level permission after the app defining
     * it rotates to the same signature.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/KeySetHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.KeySetHostTest"	"testUpgradeDefinerSigPermGained"	"CtsAppSecurityHostTestCases"	"1: permission"	"([1:/android/appsecurity/cts/KeySetHostTest.java]:[permission]:[1]:method_text:[ture-level permission after the app defining     * it rotates to a different signature.     */   ]) :|: public void testUpgradeDefinerSigPermGained() throws Exception {
        testKeyRotationPerm(PERM_DEF_A_SIGNED, PERM_USE_B_SIGNED, PERM_DEF_B_SIGNED,
                false, true);
    }

    /*
     * Check if an apk loses signature-level permission after the app defining
     * it rotates to a different signature.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/KeySetHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.PermissionEscalationTest"	"testNoPermissionEscalation"	"CtsAppSecurityHostTestCases"	"1: permission"	"([7:/android/appsecurity/cts/PermissionEscalationTest.java]:[permission]:[7]:method_text:[NonRuntimePermissionsToRuntime"");    }    @AsbSecurityTest(cveBugId = {154505240, 168319670})   ]) :|: public void testNoPermissionEscalation() throws Exception {
        assertNull(getDevice().installPackage(mBuildHelper.getTestFile(
                APK_DECLARE_NON_RUNTIME_PERMISSIONS), false, false));
        assertNull(getDevice().installPackage(mBuildHelper.getTestFile(
                APK_ESCLATE_TO_RUNTIME_PERMISSIONS), true, false));
        runDeviceTests(ESCALATE_PERMISSION_PKG,
                ""com.android.cts.escalatepermission.PermissionEscalationTest"",
                ""testCannotEscalateNonRuntimePermissionsToRuntime"");
    }

    @AsbSecurityTest(cveBugId = {154505240, 168319670})"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PermissionEscalationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.PermissionEscalationTest"	"testNoPermissionEscalationAfterReboot"	"CtsAppSecurityHostTestCases"	"1: permission"	"([7:/android/appsecurity/cts/PermissionEscalationTest.java]:[permission]:[7]:method_text:[ Utils.runDeviceTestsAsCurrentUser(getDevice(), packageName, testClassName, testMethodName);    }}]) :|: public void testNoPermissionEscalationAfterReboot() throws Exception {
        assertNull(getDevice().installPackage(mBuildHelper.getTestFile(
                APK_DECLARE_NON_RUNTIME_PERMISSIONS), false, false));
        assertNull(getDevice().installPackage(mBuildHelper.getTestFile(
                APK_ESCLATE_TO_RUNTIME_PERMISSIONS), true, false));
        getDevice().reboot();
        runDeviceTests(ESCALATE_PERMISSION_PKG,
                ""com.android.cts.escalatepermission.PermissionEscalationTest"",
                ""testRuntimePermissionsAreNotGranted"");
    }

    private void runDeviceTests(String packageName, String testClassName, String testMethodName)
            throws DeviceNotAvailableException {
        Utils.runDeviceTestsAsCurrentUser(getDevice(), packageName, testClassName, testMethodName);
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PermissionEscalationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ApkVerityInstallTest"	"isIncrementalDeliveryV2Feature"	"CtsAppSecurityHostTestCases"	"1: 9.1 9.1"	"([1:/android/appsecurity/cts/ApkVerityInstallTest.java]:[9.1]:[1]:method_text:[();        install.run(expectingSuccess);    }    @CddTest(requirement = ""9.10/C-0-3,C-0-5"")   ]) :|: 
    @Parameters(method = ""installAndUpdate"")
    public void testInstallSplitOnlyMissingSignature(boolean installIncremental,
            boolean updateIncremental, boolean isSupported) throws Exception {
        assumePreconditions(installIncremental || updateIncremental);
        new InstallMultiple(installIncremental)
                .addFile(BASE_APK)
                .addFile(BASE_APK + FSV_SIG_SUFFIX)
                .run();
        verifyFsverityInstall(installIncremental, BASE_APK);

        InstallMultiple install = new InstallMultiple(updateIncremental)
                .inheritFrom(PACKAGE_NAME)
                .addFile(SPLIT_APK);

        // S with IncFsV1 silently skips fs-verity signatures.
        boolean expectingSuccess =
                isSupported && installIncremental && !isIncrementalDeliveryV2Feature();
        install.run(expectingSuccess);
    }

    @CddTest(requirement = ""9.10/C-0-3,C-0-5"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ApkVerityInstallTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.EphemeralTest"	"testInstallPermissionNotGranted"	"CtsAppSecurityHostTestCases"	"1: permission"	"([2:/android/appsecurity/cts/EphemeralTest.java]:[permission]:[2]:method_text:[evice(), EPHEMERAL_1_PKG, TEST_CLASS,                ""testInstallPermissionNotGranted"");    }   ]) :|: 
    public void testInstallPermissionNotGranted() throws Exception {
        if (mIsUnsupportedDevice) {
            return;
        }
        Utils.runDeviceTestsAsCurrentUser(getDevice(), EPHEMERAL_1_PKG, TEST_CLASS,
                ""testInstallPermissionNotGranted"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/EphemeralTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.EphemeralTest"	"testInstallPermissionGranted"	"CtsAppSecurityHostTestCases"	"1: permission"	"([2:/android/appsecurity/cts/EphemeralTest.java]:[permission]:[2]:method_text:[etDevice(), EPHEMERAL_1_PKG, TEST_CLASS,                ""testInstallPermissionGranted"");    }   ]) :|: 
    public void testInstallPermissionGranted() throws Exception {
        if (mIsUnsupportedDevice) {
            return;
        }
        Utils.runDeviceTestsAsCurrentUser(getDevice(), EPHEMERAL_1_PKG, TEST_CLASS,
                ""testInstallPermissionGranted"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/EphemeralTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.EphemeralTest"	"testInstallPermissionNotGrantedInPackageInfo"	"CtsAppSecurityHostTestCases"	"1: permission"	"([2:/android/appsecurity/cts/EphemeralTest.java]:[permission]:[2]:method_text:[MERAL_1_PKG, TEST_CLASS,                ""testInstallPermissionNotGrantedInPackageInfo"");    }   ]) :|: 
    @AsbSecurityTest(cveBugId = 140256621)
    public void testInstallPermissionNotGrantedInPackageInfo() throws Exception {
        if (mIsUnsupportedDevice) {
            return;
        }
        Utils.runDeviceTestsAsCurrentUser(getDevice(), EPHEMERAL_1_PKG, TEST_CLASS,
                ""testInstallPermissionNotGrantedInPackageInfo"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/EphemeralTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.EphemeralTest"	"testInstallPermissionGrantedInPackageInfo"	"CtsAppSecurityHostTestCases"	"1: permission"	"([3:/android/appsecurity/cts/EphemeralTest.java]:[permission]:[3]:method_text:[tedInPackageInfo"");    }    /** Test for android.permission.INSTANT_APP_FOREGROUND_SERVICE */   ]) :|: 
    @AsbSecurityTest(cveBugId = 140256621)
    public void testInstallPermissionGrantedInPackageInfo() throws Exception {
        if (mIsUnsupportedDevice) {
            return;
        }
        Utils.runDeviceTestsAsCurrentUser(getDevice(), EPHEMERAL_1_PKG, TEST_CLASS,
                ""testInstallPermissionGrantedInPackageInfo"");
    }

    /** Test for android.permission.INSTANT_APP_FOREGROUND_SERVICE */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/EphemeralTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.EphemeralTest"	"testStartForegroundService"	"CtsAppSecurityHostTestCases"	"1: permission"	"([2:/android/appsecurity/cts/EphemeralTest.java]:[permission]:[2]:method_text:[       ""testStartForegroundService"");    }    /** Test for android.permission.RECORD_AUDIO */   ]) :|: 
    public void testStartForegroundService() throws Exception {
        if (mIsUnsupportedDevice) {
            return;
        }
        // Make sure the test package does not have INSTANT_APP_FOREGROUND_SERVICE
        getDevice().executeShellCommand(""cmd package revoke "" + EPHEMERAL_1_PKG
                + "" android.permission.INSTANT_APP_FOREGROUND_SERVICE"");
        Utils.runDeviceTestsAsCurrentUser(getDevice(), EPHEMERAL_1_PKG, TEST_CLASS,
                ""testStartForegroundService"");
    }

    /** Test for android.permission.RECORD_AUDIO */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/EphemeralTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.EphemeralTest"	"testRecordAudioPermission"	"CtsAppSecurityHostTestCases"	"1: permission"	"([3:/android/appsecurity/cts/EphemeralTest.java]:[permission]:[3]:method_text:[              ""testRecordAudioPermission"");    }    /** Test for android.permission.CAMERA */   ]) :|: 
    public void testRecordAudioPermission() throws Exception {
        if (mIsUnsupportedDevice) {
            return;
        }
        Utils.runDeviceTestsAsCurrentUser(getDevice(), EPHEMERAL_1_PKG, TEST_CLASS,
                ""testRecordAudioPermission"");
    }

    /** Test for android.permission.CAMERA */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/EphemeralTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.EphemeralTest"	"testCameraPermission"	"CtsAppSecurityHostTestCases"	"1: permission"	"([3:/android/appsecurity/cts/EphemeralTest.java]:[permission]:[3]:method_text:[       ""testCameraPermission"");    }    /** Test for android.permission.READ_PHONE_NUMBERS */   ]) :|: 
    public void testCameraPermission() throws Exception {
        if (mIsUnsupportedDevice) {
            return;
        }
        Utils.runDeviceTestsAsCurrentUser(getDevice(), EPHEMERAL_1_PKG, TEST_CLASS,
                ""testCameraPermission"");
    }

    /** Test for android.permission.READ_PHONE_NUMBERS */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/EphemeralTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.EphemeralTest"	"testReadPhoneNumbersPermission"	"CtsAppSecurityHostTestCases"	"1: permission"	"([3:/android/appsecurity/cts/EphemeralTest.java]:[permission]:[3]:method_text:[adPhoneNumbersPermission"");    }    /** Test for android.permission.ACCESS_COARSE_LOCATION */   ]) :|: 
    public void testReadPhoneNumbersPermission() throws Exception {
        if (mIsUnsupportedDevice) {
            return;
        }
        Utils.runDeviceTestsAsCurrentUser(getDevice(), EPHEMERAL_1_PKG, TEST_CLASS,
                ""testReadPhoneNumbersPermission"");
    }

    /** Test for android.permission.ACCESS_COARSE_LOCATION */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/EphemeralTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.EphemeralTest"	"testAccessCoarseLocationPermission"	"CtsAppSecurityHostTestCases"	"1: permission"	"([3:/android/appsecurity/cts/EphemeralTest.java]:[permission]:[3]:method_text:[    ""testAccessCoarseLocationPermission"");    }    /** Test for android.permission.NETWORK */   ]) :|: 
    public void testAccessCoarseLocationPermission() throws Throwable {
        if (mIsUnsupportedDevice) {
            return;
        }
        Utils.runDeviceTestsAsCurrentUser(getDevice(), EPHEMERAL_1_PKG, TEST_CLASS,
                ""testAccessCoarseLocationPermission"");
    }

    /** Test for android.permission.NETWORK */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/EphemeralTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.EphemeralTest"	"testInternetPermission"	"CtsAppSecurityHostTestCases"	"1: permission"	"([3:/android/appsecurity/cts/EphemeralTest.java]:[permission]:[3]:method_text:[                ""testInternetPermission"");    }    /** Test for android.permission.VIBRATE */   ]) :|: 
    public void testInternetPermission() throws Throwable {
        if (mIsUnsupportedDevice) {
            return;
        }
        Utils.runDeviceTestsAsCurrentUser(getDevice(), EPHEMERAL_1_PKG, TEST_CLASS,
                ""testInternetPermission"");
    }

    /** Test for android.permission.VIBRATE */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/EphemeralTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.EphemeralTest"	"testVibratePermission"	"CtsAppSecurityHostTestCases"	"1: permission"	"([3:/android/appsecurity/cts/EphemeralTest.java]:[permission]:[3]:method_text:[               ""testVibratePermission"");    }    /** Test for android.permission.WAKE_LOCK */   ]) :|: 
    public void testVibratePermission() throws Throwable {
        if (mIsUnsupportedDevice) {
            return;
        }
        Utils.runDeviceTestsAsCurrentUser(getDevice(), EPHEMERAL_1_PKG, TEST_CLASS,
                ""testVibratePermission"");
    }

    /** Test for android.permission.WAKE_LOCK */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/EphemeralTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.EphemeralTest"	"testWakeLockPermission"	"CtsAppSecurityHostTestCases"	"1: permission"	"([2:/android/appsecurity/cts/EphemeralTest.java]:[permission]:[2]:method_text:[TEST_CLASS,                ""testWakeLockPermission"");    }    /** Test for search manager */   ]) :|: 
    public void testWakeLockPermission() throws Throwable {
        if (mIsUnsupportedDevice) {
            return;
        }
        Utils.runDeviceTestsAsCurrentUser(getDevice(), EPHEMERAL_1_PKG, TEST_CLASS,
                ""testWakeLockPermission"");
    }

    /** Test for search manager */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/EphemeralTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.AppSecurityTests"	"testInstrumentationDiffCert_instant"	"CtsAppSecurityHostTestCases"	"1: permission"	"([2:/android/appsecurity/cts/AppSecurityTests.java]:[permission]:[2]:method_text:[is signed with a different     * certificate than the app that declared the permission.     */   ]) :|: 
    @AppModeInstant(reason = ""'instant' portion of the hostside test"")
    public void testInstrumentationDiffCert_instant() throws Exception {
        testInstrumentationDiffCert(false, true);
        testInstrumentationDiffCert(true, false);
        testInstrumentationDiffCert(true, true);
    }
    private void testInstrumentationDiffCert(boolean targetInstant, boolean instrumentInstant)
            throws Exception {
        Log.i(LOG_TAG, ""installing app that attempts to instrument another app"");
        try {
            // cleanup test app that might be installed from previous partial test run
            getDevice().uninstallPackage(TARGET_INSTRUMENT_PKG);
            getDevice().uninstallPackage(INSTRUMENT_DIFF_CERT_PKG);

            new InstallMultiple(targetInstant).addFile(TARGET_INSTRUMENT_APK).run();
            new InstallMultiple(instrumentInstant).addFile(INSTRUMENT_DIFF_CERT_APK).run();

            // if we've installed either the instrumentation or target as an instant application,
            // starting an instrumentation will just fail instead of throwing a security exception
            // because neither the target nor instrumentation packages can see one another
            final String methodName = (targetInstant|instrumentInstant)
                    ? ""testInstrumentationNotAllowed_fail""
                    : ""testInstrumentationNotAllowed_exception"";
            runDeviceTests(INSTRUMENT_DIFF_CERT_PKG, INSTRUMENT_DIFF_CERT_CLASS, methodName);
        } finally {
            getDevice().uninstallPackage(TARGET_INSTRUMENT_PKG);
            getDevice().uninstallPackage(INSTRUMENT_DIFF_CERT_PKG);
        }
    }

    /**
     * Test that an app cannot use a signature-enforced permission if it is signed with a different
     * certificate than the app that declared the permission.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/AppSecurityTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.AppSecurityTests"	"testPermissionDiffCert"	"CtsAppSecurityHostTestCases"	"1: permission"	"([15:/android/appsecurity/cts/AppSecurityTests.java]:[permission]:[15]:method_text:[at an app cannot set the installer package for an app with a different     * signature.     */   ]) :|: 
    @AppModeFull(reason = ""Only the platform can define permissions obtainable by instant applications"")
    @AsbSecurityTest(cveBugId = 111934948)
    public void testPermissionDiffCert() throws Exception {
        Log.i(LOG_TAG, ""installing app that attempts to use permission of another app"");
        try {
            // cleanup test app that might be installed from previous partial test run
            getDevice().uninstallPackage(DECLARE_PERMISSION_PKG);
            getDevice().uninstallPackage(DECLARE_PERMISSION_COMPAT_PKG);
            getDevice().uninstallPackage(PERMISSION_DIFF_CERT_PKG);

            new InstallMultiple().addFile(DECLARE_PERMISSION_APK).run();
            new InstallMultiple().addFile(DECLARE_PERMISSION_COMPAT_APK).run();

            new InstallMultiple().addFile(PERMISSION_DIFF_CERT_APK).run();

            // Enable alert window permission so it can start activity in background
            enableAlertWindowAppOp(DECLARE_PERMISSION_PKG);

            runDeviceTests(PERMISSION_DIFF_CERT_PKG, null);
        } finally {
            getDevice().uninstallPackage(DECLARE_PERMISSION_PKG);
            getDevice().uninstallPackage(DECLARE_PERMISSION_COMPAT_PKG);
            getDevice().uninstallPackage(PERMISSION_DIFF_CERT_PKG);
        }
    }

    /**
     * Test that an app cannot set the installer package for an app with a different
     * signature.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/AppSecurityTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.AppSecurityTests"	"testCrossPackageDiffCertSetInstaller"	"CtsAppSecurityHostTestCases"	"1: permission"	"([18:/android/appsecurity/cts/AppSecurityTests.java]:[permission]:[18]:method_text:[    /**     * Test what happens if an app tried to take a permission away from another     */   ]) :|: 
    @AppModeFull(reason = ""Only full apps can hold INSTALL_PACKAGES"")
    @AsbSecurityTest(cveBugId = 150857253)
    public void testCrossPackageDiffCertSetInstaller() throws Exception {
        Log.i(LOG_TAG, ""installing app that attempts to use permission of another app"");
        try {
            // cleanup test app that might be installed from previous partial test run
            getDevice().uninstallPackage(DECLARE_PERMISSION_PKG);
            getDevice().uninstallPackage(DECLARE_PERMISSION_COMPAT_PKG);
            getDevice().uninstallPackage(PERMISSION_DIFF_CERT_PKG);

            new InstallMultiple().addFile(DECLARE_PERMISSION_APK).run();
            new InstallMultiple().addFile(DECLARE_PERMISSION_COMPAT_APK).run();
            new InstallMultiple().addFile(PERMISSION_DIFF_CERT_APK).run();

            // Enable alert window permission so it can start activity in background
            enableAlertWindowAppOp(DECLARE_PERMISSION_PKG);

            runCrossPackageInstallerDeviceTest(PERMISSION_DIFF_CERT_PKG, ""assertBefore"");
            runCrossPackageInstallerDeviceTest(DECLARE_PERMISSION_PKG, ""takeInstaller"");
            runCrossPackageInstallerDeviceTest(PERMISSION_DIFF_CERT_PKG, ""attemptTakeOver"");
            runCrossPackageInstallerDeviceTest(DECLARE_PERMISSION_PKG, ""clearInstaller"");
            runCrossPackageInstallerDeviceTest(PERMISSION_DIFF_CERT_PKG, ""assertAfter"");
        } finally {
            getDevice().uninstallPackage(DECLARE_PERMISSION_PKG);
            getDevice().uninstallPackage(DECLARE_PERMISSION_COMPAT_PKG);
            getDevice().uninstallPackage(PERMISSION_DIFF_CERT_PKG);
        }
    }

    /**
     * Utility method to make actual test method easier to read.
     */
    private void runCrossPackageInstallerDeviceTest(String pkgName, String testMethodName)
            throws DeviceNotAvailableException {
        Map<String, String> arguments = new HashMap<>();
        arguments.put(""runExplicit"", ""true"");
        runDeviceTes"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/AppSecurityTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.AppSecurityTests"	"rebootWithDuplicatePermission"	"CtsAppSecurityHostTestCases"	"1: permission"	"([9:/android/appsecurity/cts/AppSecurityTests.java]:[permission]:[9]:method_text:[    /**     * Tests that an arbitrary file cannot be installed using the 'cmd' command.     */   ]) :|: 
    public void rebootWithDuplicatePermission() throws Exception {
        try {
            new InstallMultiple(false).addFile(DECLARE_PERMISSION_APK).run();
            new InstallMultiple(false).addFile(DUPLICATE_DECLARE_PERMISSION_APK).run();

            // Enable alert window permission so it can start activity in background
            enableAlertWindowAppOp(DECLARE_PERMISSION_PKG);

            runDeviceTests(DUPLICATE_DECLARE_PERMISSION_PKG, null);

            // make sure behavior is preserved after reboot
            getDevice().reboot();
            waitForBootCompleted(getDevice());
            runDeviceTests(DUPLICATE_DECLARE_PERMISSION_PKG, null);
        } finally {
            getDevice().uninstallPackage(DECLARE_PERMISSION_PKG);
            getDevice().uninstallPackage(DUPLICATE_DECLARE_PERMISSION_PKG);
        }
    }

    /**
     * Tests that an arbitrary file cannot be installed using the 'cmd' command.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/AppSecurityTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV1OneSignerMD5withRSA"	"CtsAppSecurityHostTestCases"	"1: 9.1"	"([2:/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java]:[9.1]:[2]:method_text:[                ""v1-only-with-rsa-pkcs1-md5-1.2.840.113549.1.1.4-%s.apk"", RSA_KEY_NAMES);    }   ]) :|: public void testInstallV1OneSignerMD5withRSA() throws Exception {
        // APK signed with v1 scheme only, one signer.
        assertInstallSucceedsForEach(
                ""v1-only-with-rsa-pkcs1-md5-1.2.840.113549.1.1.1-%s.apk"", RSA_KEY_NAMES);
        assertInstallSucceedsForEach(
                ""v1-only-with-rsa-pkcs1-md5-1.2.840.113549.1.1.4-%s.apk"", RSA_KEY_NAMES);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV1OneSignerSHA1withRSA"	"CtsAppSecurityHostTestCases"	"1: 9.1"	"([2:/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java]:[9.1]:[2]:method_text:[               ""v1-only-with-rsa-pkcs1-sha1-1.2.840.113549.1.1.5-%s.apk"", RSA_KEY_NAMES);    }   ]) :|: public void testInstallV1OneSignerSHA1withRSA() throws Exception {
        // APK signed with v1 scheme only, one signer.
        assertInstallSucceedsForEach(
                ""v1-only-with-rsa-pkcs1-sha1-1.2.840.113549.1.1.1-%s.apk"", RSA_KEY_NAMES);
        assertInstallSucceedsForEach(
                ""v1-only-with-rsa-pkcs1-sha1-1.2.840.113549.1.1.5-%s.apk"", RSA_KEY_NAMES);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV1OneSignerSHA224withRSA"	"CtsAppSecurityHostTestCases"	"1: 9.1"	"([2:/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java]:[9.1]:[2]:method_text:[            ""v1-only-with-rsa-pkcs1-sha224-1.2.840.113549.1.1.14-%s.apk"", RSA_KEY_NAMES);    }   ]) :|: public void testInstallV1OneSignerSHA224withRSA() throws Exception {
        // APK signed with v1 scheme only, one signer.
        assertInstallSucceedsForEach(
                ""v1-only-with-rsa-pkcs1-sha224-1.2.840.113549.1.1.1-%s.apk"", RSA_KEY_NAMES);
        assertInstallSucceedsForEach(
                ""v1-only-with-rsa-pkcs1-sha224-1.2.840.113549.1.1.14-%s.apk"", RSA_KEY_NAMES);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV1OneSignerSHA256withRSA"	"CtsAppSecurityHostTestCases"	"1: 9.1"	"([2:/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java]:[9.1]:[2]:method_text:[            ""v1-only-with-rsa-pkcs1-sha256-1.2.840.113549.1.1.11-%s.apk"", RSA_KEY_NAMES);    }   ]) :|: public void testInstallV1OneSignerSHA256withRSA() throws Exception {
        // APK signed with v1 scheme only, one signer.
        assertInstallSucceedsForEach(
                ""v1-only-with-rsa-pkcs1-sha256-1.2.840.113549.1.1.1-%s.apk"", RSA_KEY_NAMES);
        assertInstallSucceedsForEach(
                ""v1-only-with-rsa-pkcs1-sha256-1.2.840.113549.1.1.11-%s.apk"", RSA_KEY_NAMES);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV1OneSignerSHA384withRSA"	"CtsAppSecurityHostTestCases"	"1: 9.1"	"([2:/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java]:[9.1]:[2]:method_text:[            ""v1-only-with-rsa-pkcs1-sha384-1.2.840.113549.1.1.12-%s.apk"", RSA_KEY_NAMES);    }   ]) :|: public void testInstallV1OneSignerSHA384withRSA() throws Exception {
        // APK signed with v1 scheme only, one signer.
        assertInstallSucceedsForEach(
                ""v1-only-with-rsa-pkcs1-sha384-1.2.840.113549.1.1.1-%s.apk"", RSA_KEY_NAMES);
        assertInstallSucceedsForEach(
                ""v1-only-with-rsa-pkcs1-sha384-1.2.840.113549.1.1.12-%s.apk"", RSA_KEY_NAMES);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV1OneSignerSHA512withRSA"	"CtsAppSecurityHostTestCases"	"1: 9.1"	"([2:/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java]:[9.1]:[2]:method_text:[            ""v1-only-with-rsa-pkcs1-sha512-1.2.840.113549.1.1.13-%s.apk"", RSA_KEY_NAMES);    }   ]) :|: public void testInstallV1OneSignerSHA512withRSA() throws Exception {
        // APK signed with v1 scheme only, one signer.
        assertInstallSucceedsForEach(
                ""v1-only-with-rsa-pkcs1-sha512-1.2.840.113549.1.1.1-%s.apk"", RSA_KEY_NAMES);
        assertInstallSucceedsForEach(
                ""v1-only-with-rsa-pkcs1-sha512-1.2.840.113549.1.1.13-%s.apk"", RSA_KEY_NAMES);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testCorrectCertUsedFromPkcs7SignedDataCertsSet"	"CtsAppSecurityHostTestCases"	"1: 9.1"	"([3:/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java]:[9.1]:[3]:method_text:[      assertInstallSucceeds(""v1-only-with-rsa-pkcs1-sha1-1.2.840.113549.1.1.1-2048.apk"");    }   ]) :|: public void testCorrectCertUsedFromPkcs7SignedDataCertsSet() throws Exception {
        // Obtained by prepending the rsa-1024 certificate to the PKCS#7 SignedData certificates set
        // of v1-only-with-rsa-pkcs1-sha1-1.2.840.113549.1.1.1-2048.apk META-INF/CERT.RSA. The certs
        // (in the order of appearance in the file) are thus: rsa-1024, rsa-2048. The package's
        // signing cert is rsa-2048.
        assertInstallSucceeds(""v1-only-pkcs7-cert-bag-first-cert-not-used.apk"");

        // Check that rsa-1024 was not used as the previously installed package's signing cert.
        assertInstallFailsWithError(
                ""v1-only-with-rsa-pkcs1-sha1-1.2.840.113549.1.1.1-1024.apk"",
                ""signatures do not match"");

        // Check that rsa-2048 was used as the previously installed package's signing cert.
        assertInstallSucceeds(""v1-only-with-rsa-pkcs1-sha1-1.2.840.113549.1.1.1-2048.apk"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3KeyRotationSigPerm"	"CtsAppSecurityHostTestCases"	"1: permission"	"([1:/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java]:[permission]:[1]:method_text:[  Utils.runDeviceTests(getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS, ""testHasPerm"");    }   ]) :|: public void testInstallV3KeyRotationSigPerm() throws Exception {
        // tests that a v3 signed APK can still get a signature permission from an app with its
        // older signing certificate.
        assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-1-permdef.apk"");
        assertInstallSucceeds(
                ""v3-rsa-pkcs1-sha256-2048-2-with-por_1_2-full-caps-permcli-companion.apk"");
        Utils.runDeviceTests(getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS, ""testHasPerm"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3KeyRotationOlderSigPerm"	"CtsAppSecurityHostTestCases"	"1: permission"	"([2:/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java]:[permission]:[2]:method_text:[  Utils.runDeviceTests(getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS, ""testHasPerm"");    }   ]) :|: public void testInstallV3KeyRotationOlderSigPerm() throws Exception {
        // tests that an apk with an older signing certificate than the one which defines a
        // signature permission it wants gets the permission if the defining APK grants the
        // capability
        assertInstallSucceeds(
                ""v3-rsa-pkcs1-sha256-2048-2-with-por_1_2-full-caps-permdef.apk"");
        assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-1-permcli-companion.apk"");
        Utils.runDeviceTests(getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS, ""testHasPerm"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3KeyRotationSigPermNoCap"	"CtsAppSecurityHostTestCases"	"1: permission"	"([2:/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java]:[permission]:[2]:method_text:[Utils.runDeviceTests(getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS, ""testHasNoPerm"");    }   ]) :|: public void testInstallV3KeyRotationSigPermNoCap() throws Exception {
        // tests that an APK signed by an older signing certificate is unable to get a requested
        // signature permission when the defining APK has rotated to a newer signing certificiate
        // and does not grant the permission capability to the older cert
        assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-2-with-por_1_2-no-perm-cap-permdef.apk"");
        assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-1-permcli-companion.apk"");
        Utils.runDeviceTests(getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS, ""testHasNoPerm"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3KeyRotationOlderSigPermNoCap"	"CtsAppSecurityHostTestCases"	"1: permission"	"([3:/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java]:[permission]:[3]:method_text:[  Utils.runDeviceTests(getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS, ""testHasPerm"");    }   ]) :|: public void testInstallV3KeyRotationOlderSigPermNoCap() throws Exception {
        // tests that an APK signed by a newer signing certificate than the APK which defines a
        // signature permission is able to get that permission, even if the newer APK does not
        // grant the permission capability to the older signing certificate.
        assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-1-permdef.apk"");
        assertInstallSucceeds(
                ""v3-rsa-pkcs1-sha256-2048-2-with-por_1_2-no-perm-cap-permcli-companion.apk"");
        Utils.runDeviceTests(getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS, ""testHasPerm"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3NoRotationSigPerm"	"CtsAppSecurityHostTestCases"	"1: permission"	"([1:/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java]:[permission]:[1]:method_text:[  Utils.runDeviceTests(getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS, ""testHasPerm"");    }   ]) :|: public void testInstallV3NoRotationSigPerm() throws Exception {
        // make sure that an APK, which wants to use a signature permission defined by an APK, which
        // has not granted that capability to older signing certificates, can still install
        assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-2-with-por_1_2-no-perm-cap-permdef.apk"");
        assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-2-permcli-companion.apk"");
        Utils.runDeviceTests(getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS, ""testHasPerm"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3CommonSignerInLineageWithPermCap"	"CtsAppSecurityHostTestCases"	"1: permission"	"([4:/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java]:[permission]:[4]:method_text:[  Utils.runDeviceTests(getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS, ""testHasPerm"");    }   ]) :|: public void testInstallV3CommonSignerInLineageWithPermCap() throws Exception {
        // If an APK requesting a signature permission has a common signer in the lineage with the
        // APK declaring the permission, and that signer is granted the permission capability in
        // the declaring APK, then the permission should be granted to the requesting app even
        // if their signers have diverged.
        assertInstallFromBuildSucceeds(
                ""v3-ec-p256-with-por_1_2_3-1-no-caps-2-default-declperm.apk"");
        assertInstallFromBuildSucceeds(""v3-ec-p256-with-por_1_2_4-companion-usesperm.apk"");
        Utils.runDeviceTests(getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS, ""testHasPerm"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3CommonSignerInLineageNoCaps"	"CtsAppSecurityHostTestCases"	"1: permission"	"([4:/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java]:[permission]:[4]:method_text:[Utils.runDeviceTests(getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS, ""testHasNoPerm"");    }   ]) :|: public void testInstallV3CommonSignerInLineageNoCaps() throws Exception {
        // If an APK requesting a signature permission has a common signer in the lineage with the
        // APK declaring the permission, but the signer in the lineage has not been granted the
        // permission capability the permission should not be granted to the requesting app.
        assertInstallFromBuildSucceeds(""v3-ec-p256-with-por_1_2_3-no-caps-declperm.apk"");
        assertInstallFromBuildSucceeds(""v3-ec-p256-with-por_1_2_4-companion-usesperm.apk"");
        Utils.runDeviceTests(getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS, ""testHasNoPerm"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testKnownSignerPermGrantedWhenCurrentSignerInResource"	"CtsAppSecurityHostTestCases"	"1: permission"	"([3:/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java]:[permission]:[3]:method_text:[Utils.runDeviceTests(getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS, ""testHasNoPerm"");    }   ]) :|: public void testKnownSignerPermGrantedWhenCurrentSignerInResource() throws Exception {
        // The knownSigner protection flag allows an app to declare other trusted signing
        // certificates in an array resource; if a requesting app's current signer is in this array
        // of trusted certificates then the permission should be granted.
        assertInstallFromBuildSucceeds(""v3-rsa-2048-decl-knownSigner-ec-p256-1-3.apk"");
        assertInstallFromBuildSucceeds(""v3-ec-p256_3-companion-uses-knownSigner.apk"");
        Utils.runDeviceTests(getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS, ""testHasPerm"");

        // If the declaring app changes the trusted certificates on an update any requesting app
        // that no longer meets the requirements based on its signing identity should have the
        // permission revoked. This app update only trusts ec-p256_1 but the app that was previously
        // granted the permission based on its signing identity is signed by ec-p256_3.
        assertInstallFromBuildSucceeds(""v3-rsa-2048-decl-knownSigner-str-res-ec-p256-1.apk"");
        Utils.runDeviceTests(getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS, ""testHasNoPerm"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testKnownSignerPermCurrentSignerNotInResource"	"CtsAppSecurityHostTestCases"	"1: permission"	"([3:/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java]:[permission]:[3]:method_text:[Utils.runDeviceTests(getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS, ""testHasNoPerm"");    }   ]) :|: public void testKnownSignerPermCurrentSignerNotInResource() throws Exception {
        // If an app requesting a knownSigner permission does not meet the requirements for a
        // signature permission and is not signed by any of the trusted certificates then the
        // permission should not be granted.
        assertInstallFromBuildSucceeds(""v3-rsa-2048-decl-knownSigner-ec-p256-1-3.apk"");
        assertInstallFromBuildSucceeds(""v3-ec-p256_2-companion-uses-knownSigner.apk"");
        Utils.runDeviceTests(getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS, ""testHasNoPerm"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testKnownSignerPermGrantedWhenSignerInLineageInResource"	"CtsAppSecurityHostTestCases"	"1: permission"	"([5:/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java]:[permission]:[5]:method_text:[Utils.runDeviceTests(getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS, ""testHasNoPerm"");    }   ]) :|: public void testKnownSignerPermGrantedWhenSignerInLineageInResource() throws Exception {
        // If an app requesting a knownSigner permission was previously signed by a certificate
        // that is trusted by the declaring app then the permission should be granted.
        assertInstallFromBuildSucceeds(""v3-rsa-2048-decl-knownSigner-ec-p256-1-3.apk"");
        assertInstallFromBuildSucceeds(""v3-ec-p256-with-por_1_2-companion-uses-knownSigner.apk"");
        Utils.runDeviceTests(getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS, ""testHasPerm"");

        // If the declaring app changes the permission to no longer use the knownSigner flag then
        // any app granted the permission based on a signing identity from the set of trusted
        // certificates should have the permission revoked.
        assertInstallFromBuildSucceeds(""v3-rsa-2048-declperm.apk"");
        Utils.runDeviceTests(getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS, ""testHasNoPerm"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testKnownSignerPermSignerInLineageMatchesStringResource"	"CtsAppSecurityHostTestCases"	"1: permission"	"([1:/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java]:[permission]:[1]:method_text:[  Utils.runDeviceTests(getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS, ""testHasPerm"");    }   ]) :|: public void testKnownSignerPermSignerInLineageMatchesStringResource() throws Exception {
        // The knownSigner protection flag allows an app to declare a single known trusted
        // certificate digest using a string resource instead of a string-array resource. This test
        // verifies the knownSigner permission is granted to a requesting app if the single trusted
        // cert is in the requesting app's lineage.
        assertInstallFromBuildSucceeds(""v3-rsa-2048-decl-knownSigner-str-res-ec-p256-1.apk"");
        assertInstallFromBuildSucceeds(""v3-ec-p256-with-por_1_2-companion-uses-knownSigner.apk"");
        Utils.runDeviceTests(getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS, ""testHasPerm"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testKnownSignerPermSignerInLineageMatchesStringConst"	"CtsAppSecurityHostTestCases"	"1: permission"	"([1:/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java]:[permission]:[1]:method_text:[  Utils.runDeviceTests(getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS, ""testHasPerm"");    }   ]) :|: public void testKnownSignerPermSignerInLineageMatchesStringConst() throws Exception {
        // The knownSigner protection flag allows an app to declare a single known trusted
        // certificate digest using a string constant as the knownCerts attribute value instead of a
        // resource. This test verifies the knownSigner permission is granted to a requesting app if
        // the single trusted cert is in the requesting app's lineage.
        assertInstallFromBuildSucceeds(""v3-rsa-2048-decl-knownSigner-str-const-ec-p256-1.apk"");
        assertInstallFromBuildSucceeds(""v3-ec-p256-with-por_1_2-companion-uses-knownSigner.apk"");
        Utils.runDeviceTests(getDevice(), DEVICE_TESTS_PKG, DEVICE_TESTS_CLASS, ""testHasPerm"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3SigPermDoubleDefNewerSucceeds"	"CtsAppSecurityHostTestCases"	"1: permission"	"([2:/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java]:[permission]:[2]:method_text:[  assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-2-with_por_1_2-permdef-companion.apk"");    }   ]) :|: public void testInstallV3SigPermDoubleDefNewerSucceeds() throws Exception {
        // make sure that if an app defines a signature permission already defined by another app,
        // it successfully installs if the other app's signing cert is in its past signing certs and
        // the signature permission capability is granted
        assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-1-permdef.apk"");
        assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-2-with_por_1_2-permdef-companion.apk"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3SigPermDoubleDefOlderSucceeds"	"CtsAppSecurityHostTestCases"	"1: permission"	"([2:/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java]:[permission]:[2]:method_text:[companion.apk"");        assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-1-permdef.apk"");    }   ]) :|: public void testInstallV3SigPermDoubleDefOlderSucceeds() throws Exception {
        // make sure that if an app defines a signature permission already defined by another app,
        // it successfully installs if it is in the other app's past signing certs and the signature
        // permission capability is granted
        assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-2-with_por_1_2-permdef-companion.apk"");
        assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-1-permdef.apk"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3SigPermDoubleDefNewerNoCapFails"	"CtsAppSecurityHostTestCases"	"1: permission"	"([2:/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java]:[permission]:[2]:method_text:[            ""v3-rsa-pkcs1-sha256-2048-2-with_por_1_2-no-perm-cap-permdef-companion.apk"");    }   ]) :|: public void testInstallV3SigPermDoubleDefNewerNoCapFails() throws Exception {
        // make sure that if an app defines a signature permission already defined by another app,
        // it fails to install if the other app's signing cert is in its past signing certs but the
        // signature permission capability is not granted
        assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-1-permdef.apk"");
        assertInstallFails(
                ""v3-rsa-pkcs1-sha256-2048-2-with_por_1_2-no-perm-cap-permdef-companion.apk"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3SigPermDoubleDefOlderNoCapFails"	"CtsAppSecurityHostTestCases"	"1: permission"	"([2:/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java]:[permission]:[2]:method_text:[ef-companion.apk"");        assertInstallFails(""v3-rsa-pkcs1-sha256-2048-1-permdef.apk"");    }   ]) :|: public void testInstallV3SigPermDoubleDefOlderNoCapFails() throws Exception {
        // make sure that if an app defines a signature permission already defined by another app,
        // it fails to install if it is in the other app's past signing certs but the signature
        // permission capability is not granted
        assertInstallSucceeds(
                ""v3-rsa-pkcs1-sha256-2048-2-with_por_1_2-no-perm-cap-permdef-companion.apk"");
        assertInstallFails(""v3-rsa-pkcs1-sha256-2048-1-permdef.apk"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.PkgInstallSignatureVerificationTest"	"testInstallV3SigPermDoubleDefSameNoCapSucceeds"	"CtsAppSecurityHostTestCases"	"1: permission"	"([1:/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java]:[permission]:[1]:method_text:[companion.apk"");        assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-2-permdef.apk"");    }   ]) :|: public void testInstallV3SigPermDoubleDefSameNoCapSucceeds() throws Exception {
        // make sure that if an app defines a signature permission already defined by another app,
        // it installs successfully when signed by the same certificate, even if the original app
        // does not grant signature capabilities to its past certs
        assertInstallSucceeds(
                ""v3-rsa-pkcs1-sha256-2048-2-with_por_1_2-no-perm-cap-permdef-companion.apk"");
        assertInstallSucceeds(""v3-rsa-pkcs1-sha256-2048-2-permdef.apk"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/PkgInstallSignatureVerificationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ExternalStorageHostTest"	"testExternalStorageRename"	"CtsAppSecurityHostTestCases"	"1: permission"	"([1:/android/appsecurity/cts/ExternalStorageHostTest.java]:[permission]:[1]:method_text:[ }    /**     * Verify that app with no external storage permissions works correctly.     */   ]) :|: 
    public void testExternalStorageRename() throws Exception {
        try {
            wipePrimaryExternalStorage();

            getDevice().uninstallPackage(WRITE_PKG);
            installPackage(WRITE_APK);

            // Make sure user initialization is complete before testing
            waitForBroadcastIdle();

            for (int user : mUsers) {
                runDeviceTests(WRITE_PKG, WRITE_CLASS, ""testExternalStorageRename"", user);
            }
        } finally {
            getDevice().uninstallPackage(WRITE_PKG);
        }
    }

    /**
     * Verify that app with no external storage permissions works correctly.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ExternalStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ExternalStorageHostTest"	"testExternalStorageNone29"	"CtsAppSecurityHostTestCases"	"1: permission"	"([1:/android/appsecurity/cts/ExternalStorageHostTest.java]:[permission]:[1]:method_text:[     * {@link android.Manifest.permission#READ_EXTERNAL_STORAGE} works     * correctly.     */   ]) :|: 
    public void testExternalStorageNone29() throws Exception {
        try {
            wipePrimaryExternalStorage();

            getDevice().uninstallPackage(NONE_PKG);
            String[] options = {AbiUtils.createAbiFlag(getAbi().getName())};
            assertNull(getDevice().installPackage(getTestAppFile(NONE_APK), false, options));

            for (int user : mUsers) {
                runDeviceTests(NONE_PKG, COMMON_CLASS, user);
                runDeviceTests(NONE_PKG, NONE_CLASS, user);
            }
        } finally {
            getDevice().uninstallPackage(NONE_PKG);
        }
    }

    /**
     * Verify that app with
     * {@link android.Manifest.permission#READ_EXTERNAL_STORAGE} works
     * correctly.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ExternalStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ExternalStorageHostTest"	"testExternalStorageRead29"	"CtsAppSecurityHostTestCases"	"1: permission"	"([1:/android/appsecurity/cts/ExternalStorageHostTest.java]:[permission]:[1]:method_text:[    * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} works     * correctly.     */   ]) :|: 
    public void testExternalStorageRead29() throws Exception {
        try {
            wipePrimaryExternalStorage();

            getDevice().uninstallPackage(READ_PKG);
            String[] options = {AbiUtils.createAbiFlag(getAbi().getName())};
            assertNull(getDevice().installPackage(getTestAppFile(READ_APK), false, options));

            for (int user : mUsers) {
                runDeviceTests(READ_PKG, COMMON_CLASS, user);
                runDeviceTests(READ_PKG, READ_CLASS, user);
            }
        } finally {
            getDevice().uninstallPackage(READ_PKG);
        }
    }

    /**
     * Verify that app with
     * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} works
     * correctly.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ExternalStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ExternalStorageHostTest"	"testCanAccessOtherObbDirs"	"CtsAppSecurityHostTestCases"	"1: permission"	"([1:/android/appsecurity/cts/ExternalStorageHostTest.java]:[permission]:[1]:method_text:[nstallPackage(WRITE_PKG_2);            getDevice().uninstallPackage(NONE_PKG);        }    }   ]) :|: 
    public void testCanAccessOtherObbDirs() throws Exception {
        try {
            wipePrimaryExternalStorage();

            getDevice().uninstallPackage(WRITE_PKG_2);
            getDevice().uninstallPackage(NONE_PKG);
            final String[] options = {AbiUtils.createAbiFlag(getAbi().getName())};

            // We purposefully delay the installation of the reading apps to
            // verify that the daemon correctly invalidates any caches.
            assertNull(getDevice().installPackage(getTestAppFile(WRITE_APK_2), false, options));
            for (int user : mUsers) {
                updateAppOp(WRITE_PKG_2, user, ""android:request_install_packages"", true);
                updatePermissions(WRITE_PKG_2, user, new String[] {
                        PERM_READ_EXTERNAL_STORAGE,
                        PERM_WRITE_EXTERNAL_STORAGE,
                }, true);
            }

            for (int user : mUsers) {
                runDeviceTests(WRITE_PKG_2, WRITE_PKG + "".WriteGiftTest"", ""testObbGifts"", user);
            }

            assertNull(getDevice().installPackage(getTestAppFile(NONE_APK), false, options));
            for (int user : mUsers) {
                runDeviceTests(NONE_PKG, NONE_PKG + "".GiftTest"", ""testObbGifts"", user);
            }

            for (int user : mUsers) {
                runDeviceTests(WRITE_PKG_2, WRITE_PKG + "".WriteGiftTest"",
                        ""testAccessObbGifts"", user);
                updateAppOp(WRITE_PKG_2, user, ""android:request_install_packages"", false);
                runDeviceTests(WRITE_PKG_2, WRITE_PKG + "".WriteGiftTest"",
                        ""testCantAccessObbGifts"", user);
            }
        } finally {
            getDevice().uninstallPackage(WRITE_PKG_2);
            getDevice().uninstallPackage(NONE_PKG);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ExternalStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ExternalStorageHostTest"	"testMultiUserStorageIsolated"	"CtsAppSecurityHostTestCases"	"1: permission"	"([2:/android/appsecurity/cts/ExternalStorageHostTest.java]:[permission]:[2]:method_text:[ }    /**     * Test that apps with read permissions see the appropriate permissions.     */   ]) :|: 
    public void testMultiUserStorageIsolated() throws Exception {
        try {
            if (mUsers.length == 1) {
                Log.d(TAG, ""Single user device; skipping isolated storage tests"");
                return;
            }

            final int owner = mUsers[0];
            final int secondary = mUsers[1];

            // Install our test app
            getDevice().uninstallPackage(MULTIUSER_PKG);
            String[] options = {AbiUtils.createAbiFlag(getAbi().getName())};
            final String installResult = getDevice()
                    .installPackage(getTestAppFile(MULTIUSER_APK), false, options);
            assertNull(""Failed to install: "" + installResult, installResult);

            // Clear data from previous tests
            runDeviceTests(MULTIUSER_PKG, MULTIUSER_CLASS, ""testCleanIsolatedStorage"", owner);
            runDeviceTests(MULTIUSER_PKG, MULTIUSER_CLASS, ""testCleanIsolatedStorage"", secondary);

            // Have both users try writing into isolated storage
            runDeviceTests(MULTIUSER_PKG, MULTIUSER_CLASS, ""testWriteIsolatedStorage"", owner);
            runDeviceTests(MULTIUSER_PKG, MULTIUSER_CLASS, ""testWriteIsolatedStorage"", secondary);

            // Verify they both have isolated view of storage
            runDeviceTests(MULTIUSER_PKG, MULTIUSER_CLASS, ""testReadIsolatedStorage"", owner);
            runDeviceTests(MULTIUSER_PKG, MULTIUSER_CLASS, ""testReadIsolatedStorage"", secondary);

            // Verify they can't poke at each other
            runDeviceTests(MULTIUSER_PKG, MULTIUSER_CLASS, ""testUserIsolation"", owner);
            runDeviceTests(MULTIUSER_PKG, MULTIUSER_CLASS, ""testUserIsolation"", secondary);

            // Verify they can't access other users' content using media provider
            runDeviceTests(MULTIUSER_PKG, MULTIUSER_CLASS, ""testMediaProviderUserIsolation"", owner);
            runDeviceTests(MULTIUSER_PKG, MULTIUSER_CLASS, ""testMediaProviderUserIsolation"", secondary);
        }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ExternalStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ExternalStorageHostTest"	"testMediaLegacy29"	"CtsAppSecurityHostTestCases"	"1: permission"	"([3:/android/appsecurity/cts/ExternalStorageHostTest.java]:[permission]:[3]:method_text:[         runDeviceTests(MEDIA_29.pkg, MEDIA_29.clazz, ""testClearFiles"", user);        }    }   ]) :|: 
    public void testMediaLegacy29() throws Exception {
        doMediaLegacy(MEDIA_29);
    }

    private void doMediaLegacy(Config config) throws Exception {
        installPackage(config.apk);
        installPackage(MEDIA_29.apk);
        // Make sure user initialization is complete before updating permission
        waitForBroadcastIdle();
        for (int user : mUsers) {
            updatePermissions(config.pkg, user, new String[] {
                    PERM_READ_EXTERNAL_STORAGE,
                    PERM_WRITE_EXTERNAL_STORAGE,
            }, true);
            updatePermissions(MEDIA_29.pkg, user, new String[] {
                    PERM_READ_EXTERNAL_STORAGE,
                    PERM_WRITE_EXTERNAL_STORAGE,
            }, true);

            // Create the files needed for the test from MEDIA_29 pkg since shell
            // can't access secondary user's storage.
            runDeviceTests(MEDIA_29.pkg, MEDIA_29.clazz, ""testStageFiles"", user);
            runDeviceTests(config.pkg, config.clazz, ""testLegacy"", user);
            runDeviceTests(MEDIA_29.pkg, MEDIA_29.clazz, ""testClearFiles"", user);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ExternalStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ExternalStorageHostTest"	"testGrantUriPermission"	"CtsAppSecurityHostTestCases"	"1: permission"	"([7:/android/appsecurity/cts/ExternalStorageHostTest.java]:[permission]:[7]:method_text:[,                new String[]{PERM_READ_EXTERNAL_STORAGE, PERM_WRITE_EXTERNAL_STORAGE});    }   ]) :|: 
    public void testGrantUriPermission() throws Exception {
        doGrantUriPermission(MEDIA, ""testGrantUriPermission"", new String[]{});
        doGrantUriPermission(MEDIA, ""testGrantUriPermission"",
                new String[]{PERM_READ_EXTERNAL_STORAGE});
        doGrantUriPermission(MEDIA, ""testGrantUriPermission"",
                new String[]{PERM_READ_EXTERNAL_STORAGE, PERM_WRITE_EXTERNAL_STORAGE});
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ExternalStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ExternalStorageHostTest"	"testGrantUriPermission29"	"CtsAppSecurityHostTestCases"	"1: permission"	"([14:/android/appsecurity/cts/ExternalStorageHostTest.java]:[permission]:[14]:method_text:[ons, true);            runDeviceTests(config.pkg, config.clazz, method, user);        }    }   ]) :|: 
    public void testGrantUriPermission29() throws Exception {
        doGrantUriPermission(MEDIA_29, ""testGrantUriPermission"", new String[]{});
        doGrantUriPermission(MEDIA_29, ""testGrantUriPermission"",
                new String[]{PERM_READ_EXTERNAL_STORAGE});
        doGrantUriPermission(MEDIA_29, ""testGrantUriPermission"",
                new String[]{PERM_READ_EXTERNAL_STORAGE, PERM_WRITE_EXTERNAL_STORAGE});
    }

    private void doGrantUriPermission(Config config, String method, String[] grantPermissions)
            throws Exception {
        uninstallPackage(config.apk);
        installPackage(config.apk);
        for (int user : mUsers) {
            // Over revoke all permissions and grant necessary permissions later.
            updatePermissions(config.pkg, user, new String[] {
                    PERM_READ_EXTERNAL_STORAGE,
                    PERM_WRITE_EXTERNAL_STORAGE,
            }, false);
            updatePermissions(config.pkg, user, grantPermissions, true);
            runDeviceTests(config.pkg, config.clazz, method, user);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ExternalStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ExternalStorageHostTest"	"testMediaNone29"	"CtsAppSecurityHostTestCases"	"1: permission"	"([1:/android/appsecurity/cts/ExternalStorageHostTest.java]:[permission]:[1]:method_text:[;            runDeviceTests(config.pkg, config.clazz, ""testMediaNone"", user);        }    }   ]) :|: 
    public void testMediaNone29() throws Exception {
        doMediaNone(MEDIA_29);
    }

    private void doMediaNone(Config config) throws Exception {
        installPackage(config.apk);
        for (int user : mUsers) {
            updatePermissions(config.pkg, user, new String[] {
                    PERM_READ_EXTERNAL_STORAGE,
                    PERM_WRITE_EXTERNAL_STORAGE,
            }, false);

            runDeviceTests(config.pkg, config.clazz, ""testMediaNone"", user);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ExternalStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ExternalStorageHostTest"	"testMediaRead29"	"CtsAppSecurityHostTestCases"	"1: permission"	"([2:/android/appsecurity/cts/ExternalStorageHostTest.java]:[permission]:[2]:method_text:[;            runDeviceTests(config.pkg, config.clazz, ""testMediaRead"", user);        }    }   ]) :|: 
    public void testMediaRead29() throws Exception {
        doMediaRead(MEDIA_29);
    }

    private void doMediaRead(Config config) throws Exception {
        installPackage(config.apk);
        for (int user : mUsers) {
            updatePermissions(config.pkg, user, new String[] {
                    PERM_READ_EXTERNAL_STORAGE,
            }, true);
            updatePermissions(config.pkg, user, new String[] {
                    PERM_WRITE_EXTERNAL_STORAGE,
            }, false);

            runDeviceTests(config.pkg, config.clazz, ""testMediaRead"", user);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ExternalStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ExternalStorageHostTest"	"testMediaWrite29"	"CtsAppSecurityHostTestCases"	"1: permission"	"([1:/android/appsecurity/cts/ExternalStorageHostTest.java]:[permission]:[1]:method_text:[            runDeviceTests(config.pkg, config.clazz, ""testMediaWrite"", user);        }    }   ]) :|: 
    public void testMediaWrite29() throws Exception {
        doMediaWrite(MEDIA_29);
    }

    private void doMediaWrite(Config config) throws Exception {
        installPackage(config.apk);
        for (int user : mUsers) {
            updatePermissions(config.pkg, user, new String[] {
                    PERM_READ_EXTERNAL_STORAGE,
                    PERM_WRITE_EXTERNAL_STORAGE,
            }, true);

            runDeviceTests(config.pkg, config.clazz, ""testMediaWrite"", user);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ExternalStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ExternalStorageHostTest"	"testMediaEscalation_RequestWriteFilePathSupport"	"CtsAppSecurityHostTestCases"	"1: permission"	"([2:/android/appsecurity/cts/ExternalStorageHostTest.java]:[permission]:[2]:method_text:[g, MEDIA.clazz, ""testMediaEscalation_RequestWriteFilePathSupport"",                user);    }   ]) :|: 
    public void testMediaEscalation_RequestWriteFilePathSupport() throws Exception {
        // Not adding tests for MEDIA_28 and MEDIA_29 as they need W_E_S for write access via file
        // path for shared files, and will always have access as they have W_E_S.
        installPackage(MEDIA.apk);

        int user = getDevice().getCurrentUser();
        updatePermissions(MEDIA.pkg, user, new String[] {
                PERM_READ_EXTERNAL_STORAGE,
        }, true);
        updatePermissions(MEDIA.pkg, user, new String[] {
                PERM_WRITE_EXTERNAL_STORAGE,
        }, false);

        runDeviceTests(MEDIA.pkg, MEDIA.clazz, ""testMediaEscalation_RequestWriteFilePathSupport"",
                user);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ExternalStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ExternalStorageHostTest"	"testMediaEscalation29"	"CtsAppSecurityHostTestCases"	"1: permission"	"([2:/android/appsecurity/cts/ExternalStorageHostTest.java]:[permission]:[2]:method_text:[     runDeviceTests(config.pkg, config.clazz, ""testMediaEscalation_RequestDelete"", user);    }   ]) :|: 
    public void testMediaEscalation29() throws Exception {
        doMediaEscalation(MEDIA_29);
    }

    private void doMediaEscalation(Config config) throws Exception {
        installPackage(config.apk);

        // TODO: extend test to exercise secondary users
        int user = getDevice().getCurrentUser();
        updatePermissions(config.pkg, user, new String[] {
                PERM_READ_EXTERNAL_STORAGE,
        }, true);
        updatePermissions(config.pkg, user, new String[] {
                PERM_WRITE_EXTERNAL_STORAGE,
        }, false);

        runDeviceTests(config.pkg, config.clazz, ""testMediaEscalation_Open"", user);
        runDeviceTests(config.pkg, config.clazz, ""testMediaEscalation_Update"", user);
        runDeviceTests(config.pkg, config.clazz, ""testMediaEscalation_Delete"", user);

        runDeviceTests(config.pkg, config.clazz, ""testMediaEscalation_RequestWrite"", user);
        runDeviceTests(config.pkg, config.clazz, ""testMediaEscalation_RequestTrash"", user);
        runDeviceTests(config.pkg, config.clazz, ""testMediaEscalation_RequestFavorite"", user);
        runDeviceTests(config.pkg, config.clazz, ""testMediaEscalation_RequestDelete"", user);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ExternalStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ExternalStorageHostTest"	"testIsExternalStorageLegacy"	"CtsAppSecurityHostTestCases"	"1: permission"	"([1:/android/appsecurity/cts/ExternalStorageHostTest.java]:[permission]:[1]:method_text:[ser     * click the deny button on confirmation dialog.     *     * @throws Exception     */   ]) :|: 
    public void testIsExternalStorageLegacy() throws Exception {
        String[] options = {AbiUtils.createAbiFlag(getAbi().getName())};

        try {
            getDevice().uninstallPackage(WRITE_PKG);
            getDevice().uninstallPackage(WRITE_PKG_2);
            assertNull(getDevice().installPackage(getTestAppFile(WRITE_APK), false, options));
            assertNull(getDevice().installPackage(getTestAppFile(WRITE_APK_2), false, options));
            for (int user : mUsers) {
                runDeviceTests(WRITE_PKG, WRITE_PKG + "".WriteGiftTest"",
                        ""testIsExternalStorageLegacy"", user);
                updatePermissions(WRITE_PKG, user, new String[] {
                        PERM_READ_EXTERNAL_STORAGE,
                        PERM_WRITE_EXTERNAL_STORAGE,
                }, false);
                runDeviceTests(WRITE_PKG, WRITE_PKG + "".WriteGiftTest"",
                        ""testIsExternalStorageLegacy"", user);

                runDeviceTests(WRITE_PKG_2, WRITE_PKG + "".WriteGiftTest"",
                        ""testNotIsExternalStorageLegacy"", user);
            }
        } finally {
            getDevice().uninstallPackage(WRITE_PKG);
            getDevice().uninstallPackage(WRITE_PKG_2);
        }
    }

    /**
     * Check the behavior when the app calls MediaStore#createTrashRequest,
     * MediaStore#createDeleteRequest or MediaStore#createWriteRequest, the user
     * click the deny button on confirmation dialog.
     *
     * @throws Exception
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ExternalStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ExternalStorageHostTest"	"testCreateRequest_userDenied"	"CtsAppSecurityHostTestCases"	"1: permission"	"([2:/android/appsecurity/cts/ExternalStorageHostTest.java]:[permission]:[2]:method_text:[    * the system will show the user confirmation dialog.     *     * @throws Exception     */   ]) :|: 
    public void testCreateRequest_userDenied() throws Exception {
        installPackage(MEDIA.apk);

        int user = getDevice().getCurrentUser();

        runDeviceTests(MEDIA.pkg, MEDIA.clazz,
                ""testMediaEscalationWithDenied_RequestWrite"", user);
        runDeviceTests(MEDIA.pkg, MEDIA.clazz,
                ""testMediaEscalationWithDenied_RequestDelete"", user);
        runDeviceTests(MEDIA.pkg, MEDIA.clazz,
                ""testMediaEscalationWithDenied_RequestTrash"", user);
        runDeviceTests(MEDIA.pkg, MEDIA.clazz,
                ""testMediaEscalationWithDenied_RequestUnTrash"", user);
    }

    /**
     * If the app is NOT granted {@link android.Manifest.permission#READ_EXTERNAL_STORAGE}
     * and {@link android.Manifest.permission#MANAGE_EXTERNAL_STORAGE}
     * when it calls MediaStore#createTrashRequest,
     * MediaStore#createDeleteRequest, or MediaStore#createWriteRequest,
     * the system will show the user confirmation dialog.
     *
     * @throws Exception
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ExternalStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ExternalStorageHostTest"	"testCreateRequest_noRESAndMES_showConfirmDialog"	"CtsAppSecurityHostTestCases"	"1: permission"	"([7:/android/appsecurity/cts/ExternalStorageHostTest.java]:[permission]:[7]:method_text:[    * the system will show the user confirmation dialog.     *     * @throws Exception     */   ]) :|: 
    public void testCreateRequest_noRESAndMES_showConfirmDialog() throws Exception {
        installPackage(MEDIA.apk);

        int user = getDevice().getCurrentUser();

        // grant permissions
        updatePermissions(MEDIA.pkg, user, new String[] {
                PERM_ACCESS_MEDIA_LOCATION,
        }, true);
        // revoke permissions
        updatePermissions(MEDIA.pkg, user, new String[] {
                PERM_READ_EXTERNAL_STORAGE,
                PERM_WRITE_EXTERNAL_STORAGE,
        }, false);


        // revoke the app ops permission
        updateAppOp(MEDIA.pkg, user, APP_OPS_MANAGE_EXTERNAL_STORAGE, false);

        // grant the app ops permission
        updateAppOp(MEDIA.pkg, user, APP_OPS_MANAGE_MEDIA, true);

        runDeviceTests(MEDIA.pkg, MEDIA.clazz,
                ""testMediaEscalation_RequestWrite_showConfirmDialog"", user);
    }

    /**
     * If the app is NOT granted {@link android.Manifest.permission#MANAGE_MEDIA},
     * when it calls MediaStore#createTrashRequest,
     * MediaStore#createDeleteRequest, or MediaStore#createWriteRequest,
     * the system will show the user confirmation dialog.
     *
     * @throws Exception
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ExternalStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ExternalStorageHostTest"	"testCreateRequest_noMANAGEMEDIA_showConfirmDialog"	"CtsAppSecurityHostTestCases"	"1: permission"	"([6:/android/appsecurity/cts/ExternalStorageHostTest.java]:[permission]:[6]:method_text:[he     * system will show the user confirmation dialog.     *     * @throws Exception     */   ]) :|: 
    public void testCreateRequest_noMANAGEMEDIA_showConfirmDialog() throws Exception {
        installPackage(MEDIA.apk);

        int user = getDevice().getCurrentUser();
        // grant permissions
        updatePermissions(MEDIA.pkg, user, new String[] {
                PERM_READ_EXTERNAL_STORAGE,
                PERM_ACCESS_MEDIA_LOCATION,
        }, true);

        // revoke the app ops permission
        updateAppOp(MEDIA.pkg, user, APP_OPS_MANAGE_MEDIA, false);

        runDeviceTests(MEDIA.pkg, MEDIA.clazz,
                ""testMediaEscalation_RequestWrite_showConfirmDialog"", user);
        runDeviceTests(MEDIA.pkg, MEDIA.clazz,
                ""testMediaEscalation_RequestTrash_showConfirmDialog"", user);
        runDeviceTests(MEDIA.pkg, MEDIA.clazz,
                ""testMediaEscalation_RequestDelete_showConfirmDialog"", user);
    }

    /**
     * If the app is granted {@link android.Manifest.permission#MANAGE_MEDIA},
     * {@link android.Manifest.permission#READ_EXTERNAL_STORAGE}, without
     * {@link android.Manifest.permission#ACCESS_MEDIA_LOCATION},
     * when it calls MediaStore#createTrashRequest or
     * MediaStore#createDeleteRequest, The system will NOT show the user
     * confirmation dialog. When it calls MediaStore#createWriteRequest, the
     * system will show the user confirmation dialog.
     *
     * @throws Exception
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ExternalStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ExternalStorageHostTest"	"testCreateRequest_withNoAML_showConfirmDialog"	"CtsAppSecurityHostTestCases"	"1: permission"	"([8:/android/appsecurity/cts/ExternalStorageHostTest.java]:[permission]:[8]:method_text:[, the system will NOT show the user confirmation dialog.     *     * @throws Exception     */   ]) :|: 
    public void testCreateRequest_withNoAML_showConfirmDialog() throws Exception {
        installPackage(MEDIA.apk);

        int user = getDevice().getCurrentUser();
        // grant permissions
        updatePermissions(MEDIA.pkg, user, new String[] {
                PERM_READ_EXTERNAL_STORAGE,
        }, true);
        // revoke permission
        updatePermissions(MEDIA.pkg, user, new String[] {
                PERM_ACCESS_MEDIA_LOCATION,
        }, false);

        // grant the app ops permission
        updateAppOp(MEDIA.pkg, user, APP_OPS_MANAGE_MEDIA, true);

        // show confirm dialog in requestWrite
        runDeviceTests(MEDIA.pkg, MEDIA.clazz,
                ""testMediaEscalation_RequestWrite_showConfirmDialog"", user);

        // not show confirm dialog in requestTrash and requestDelete
        runDeviceTests(MEDIA.pkg, MEDIA.clazz,
                ""testMediaEscalation_RequestTrash_notShowConfirmDialog"", user);
        runDeviceTests(MEDIA.pkg, MEDIA.clazz,
                ""testMediaEscalation_RequestDelete_notShowConfirmDialog"", user);
    }

    /**
     * If the app is granted {@link android.Manifest.permission#MANAGE_MEDIA},
     * {@link android.Manifest.permission#READ_EXTERNAL_STORAGE}, and
     * {@link android.Manifest.permission#ACCESS_MEDIA_LOCATION},
     * when it calls MediaStore#createWriteRequest, MediaStore#createTrashRequest or
     * MediaStore#createDeleteRequest, the system will NOT show the user confirmation dialog.
     *
     * @throws Exception
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ExternalStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ExternalStorageHostTest"	"testCreateRequest_withPermission_notShowConfirmDialog"	"CtsAppSecurityHostTestCases"	"1: permission"	"([4:/android/appsecurity/cts/ExternalStorageHostTest.java]:[permission]:[4]:method_text:[re : features) {            Assume.assumeFalse(featureList.contains(feature));        }    }   ]) :|: 
    public void testCreateRequest_withPermission_notShowConfirmDialog() throws Exception {
        installPackage(MEDIA.apk);

        int user = getDevice().getCurrentUser();
        // grant permissions
        updatePermissions(MEDIA.pkg, user, new String[] {
                PERM_READ_EXTERNAL_STORAGE,
                PERM_ACCESS_MEDIA_LOCATION,
        }, true);

        // revoke the app ops permission
        updateAppOp(MEDIA.pkg, user, APP_OPS_MANAGE_MEDIA, true);

        runDeviceTests(MEDIA.pkg, MEDIA.clazz,
                ""testMediaEscalation_RequestWrite_notShowConfirmDialog"", user);
        runDeviceTests(MEDIA.pkg, MEDIA.clazz,
                ""testMediaEscalation_RequestTrash_notShowConfirmDialog"", user);
        runDeviceTests(MEDIA.pkg, MEDIA.clazz,
                ""testMediaEscalation_RequestDelete_notShowConfirmDialog"", user);
    }

    private <T extends MessageLite> T getDump(Parser<T> parser, String command) throws Exception {
        final CollectingByteOutputReceiver receiver = new CollectingByteOutputReceiver();
        getDevice().executeShellCommand(command, receiver);
        return parser.parseFrom(receiver.getOutput());
    }

    private List<RoleUserStateProto> getAllUsersRoleStates() throws Exception {
        final RoleServiceDumpProto dumpProto =
                getDump(RoleServiceDumpProto.parser(), ""dumpsys role --proto"");
        final List<RoleUserStateProto> res = new ArrayList<>();
        for (RoleUserStateProto userState : dumpProto.getUserStatesList()) {
            for (int i : mUsers) {
                if (i == userState.getUserId()) {
                    res.add(userState);
                    break;
                }
            }
        }
        return res;
    }

    /**
     * Bypasses the calling test case if ANY of the given features is available in the device.
     */
    private void bypassTestForFeatures(String... features) throws DeviceNotAvailableException {
        final String featureList = getDevice("	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ExternalStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ExternalStorageHostTest"	"testSystemGalleryExists"	"CtsAppSecurityHostTestCases"	"1: permission"	"([5:/android/appsecurity/cts/ExternalStorageHostTest.java]:[permission]:[5]:method_text:[      runDeviceTests(getDevice(), packageName, testClassName, testMethodName, userId, null);    }}]) :|: 
    public void testSystemGalleryExists() throws Exception {
        // Watches, TVs and IoT devices are not obligated to have a system gallery
        bypassTestForFeatures(FEATURE_AUTOMOTIVE, FEATURE_EMBEDDED, FEATURE_LEANBACK_ONLY,
                FEATURE_WATCH);

        final List<RoleUserStateProto> usersRoleStates = getAllUsersRoleStates();

        assertEquals(""Unexpected number of users returned by dumpsys role"",
                mUsers.length, usersRoleStates.size());

        for (RoleUserStateProto userState : usersRoleStates) {
            final List<RoleProto> roles = userState.getRolesList();
            boolean systemGalleryRoleFound = false;

            // Iterate through the roles until we find the System Gallery role
            for (RoleProto roleProto : roles) {
                if (""android.app.role.SYSTEM_GALLERY"".equals(roleProto.getName())) {
                    assertEquals(1, roleProto.getHoldersList().size());
                    systemGalleryRoleFound = true;
                    break;
                }
            }
            assertTrue(""SYSTEM_GALLERY not defined for user "" + userState.getUserId(),
                    systemGalleryRoleFound);
        }
    }

    private boolean access(String path) throws DeviceNotAvailableException {
        final long nonce = System.nanoTime();
        return getDevice().executeShellCommand(""ls -la "" + path + "" && echo "" + nonce)
                .contains(Long.toString(nonce));
    }

    private void updatePermissions(String packageName, int userId, String[] permissions,
            boolean grant) throws Exception {
        final String verb = grant ? ""grant"" : ""revoke"";
        for (String permission : permissions) {
            getDevice().executeShellCommand(
                    ""cmd package "" + verb + "" --user "" + userId + "" --uid "" + packageName + "" ""
                            + permission);
        }
    }

    /** Wait until all broadcast queues are idle. */
    private void waitForBroad"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ExternalStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.DocumentsTest"	"testAfterMoveDocumentInStorage_revokeUriPermission"	"CtsAppSecurityHostTestCases"	"1: permission"	"([2:/android/appsecurity/cts/DocumentsTest.java]:[permission]:[2]:method_text:[ch (DeviceNotAvailableException e) {            return true;        }        return true;    }}]) :|: public void testAfterMoveDocumentInStorage_revokeUriPermission() throws Exception {
        if (isAtLeastS()) {
            runDeviceTests(CLIENT_PKG, "".DocumentsClientTest"",
                ""testAfterMoveDocumentInStorage_revokeUriPermission"");
        }
    }

    private boolean isAtLeastR() {
        try {
            return ApiLevelUtil.isAfter(getDevice(), 29 /* BUILD.VERSION_CODES.Q */);
        } catch (Exception e) {
            return false;
        }
    }

    private boolean isAtLeastS() {
        try {
            return ApiLevelUtil.isAfter(getDevice(), 30 /* BUILD.VERSION_CODES.R */)
                || ApiLevelUtil.codenameEquals(getDevice(), ""S"");
        } catch (Exception e) {
            return false;
        }
    }

    private boolean isSupportedHardware() {
        try {
            if (getDevice().hasFeature(""feature:android.hardware.type.television"")
                    || getDevice().hasFeature(""feature:android.hardware.type.watch"")
                    || getDevice().hasFeature(""feature:android.hardware.type.automotive"")) {
                return false;
            }
        } catch (DeviceNotAvailableException e) {
            return true;
        }
        return true;
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/DocumentsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.AccessSerialNumberTest"	"testSerialAccessPolicy"	"CtsAppSecurityHostTestCases"	"1: permission"	"([2:/android/appsecurity/cts/AccessSerialNumberTest.java]:[permission]:[2]:method_text:[android.os.cts.AccessSerialModernTest"",                ""testAccessSerialPermissionNeeded"");    }}]) :|: public void testSerialAccessPolicy() throws Exception {
        // Verify legacy app behavior
        assertNull(getDevice().installPackage(mBuildHelper.getTestFile(
                APK_ACCESS_SERIAL_LEGACY), false, false));
        runDeviceTests(ACCESS_SERIAL_PKG,
                ""android.os.cts.AccessSerialLegacyTest"",
                ""testAccessSerialNoPermissionNeeded"");

        // Verify modern app behavior
        assertNull(getDevice().installPackage(mBuildHelper.getTestFile(
                APK_ACCESS_SERIAL_MODERN), true, false));
        runDeviceTests(ACCESS_SERIAL_PKG,
                ""android.os.cts.AccessSerialModernTest"",
                ""testAccessSerialPermissionNeeded"");
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/AccessSerialNumberTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.LocationPolicyTest"	"testLocationPolicyPermissions"	"CtsAppSecurityHostTestCases"	"1: permission"	"([2:/android/appsecurity/cts/LocationPolicyTest.java]:[permission]:[2]:method_text:[            getDevice(), TEST_PKG, "".LocationPolicyTest"", ""testLocationPolicyPermissions"");    }}]) :|: 
    @AsbSecurityTest(cveBugId = 148414207)
    public void testLocationPolicyPermissions() throws Exception {
        new InstallMultiple(true).addFile(TEST_APK).run();
        Utils.runDeviceTests(
            getDevice(), TEST_PKG, "".LocationPolicyTest"", ""testLocationPolicyPermissions"");
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/LocationPolicyTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ApplicationVisibilityTest"	"testPackageListCrossUserGrant"	"CtsAppSecurityHostTestCases"	"1: permission"	"([3:/android/appsecurity/cts/ApplicationVisibilityTest.java]:[permission]:[3]:method_text:[              ""testPackageVisibility_anyUserCrossUserGrant"",                testUserId);    }   ]) :|: 
    @AppModeFull(reason = ""instant applications cannot be granted INTERACT_ACROSS_USERS"")
    public void testPackageListCrossUserGrant() throws Exception {
        if (!mSupportsMultiUser) {
            return;
        }

        final int installUserId = getInstallUserId();
        final int testUserId = getTestUserId();

        installTestAppForUser(TINY_APK, installUserId);
        installTestAppForUser(TEST_WITH_PERMISSION_APK, testUserId);

        Utils.runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".ApplicationVisibilityCrossUserTest"",
                ""testPackageVisibility_currentUser"",
                testUserId);
        Utils.runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".ApplicationVisibilityCrossUserTest"",
                ""testPackageVisibility_anyUserCrossUserGrant"",
                testUserId);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ApplicationVisibilityTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ApplicationVisibilityTest"	"testPackageListCrossUserNoGrant"	"CtsAppSecurityHostTestCases"	"1: permission"	"([3:/android/appsecurity/cts/ApplicationVisibilityTest.java]:[permission]:[3]:method_text:[            ""testPackageVisibility_anyUserCrossUserNoGrant"",                testUserId);    }   ]) :|: 
    @AppModeFull(reason = ""instant applications cannot see any other application"")
    public void testPackageListCrossUserNoGrant() throws Exception {
        if (!mSupportsMultiUser) {
            return;
        }

        final int installUserId = getInstallUserId();
        final int testUserId = getTestUserId();

        installTestAppForUser(TINY_APK, installUserId);
        installTestAppForUser(TEST_WITH_PERMISSION_APK, testUserId);

        Utils.runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".ApplicationVisibilityCrossUserTest"",
                ""testPackageVisibility_currentUser"",
                testUserId);
        Utils.runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".ApplicationVisibilityCrossUserTest"",
                ""testPackageVisibility_anyUserCrossUserNoGrant"",
                testUserId);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ApplicationVisibilityTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ApplicationVisibilityTest"	"testPackageListOtherUserCrossUserGrant"	"CtsAppSecurityHostTestCases"	"1: permission"	"([2:/android/appsecurity/cts/ApplicationVisibilityTest.java]:[permission]:[2]:method_text:[PackageVisibility_otherUserGrant"",                testUserId,                testArgs);    }   ]) :|: 
    @AppModeFull(reason = ""instant applications cannot be granted INTERACT_ACROSS_USERS"")
    public void testPackageListOtherUserCrossUserGrant() throws Exception {
        if (!mSupportsMultiUser) {
            return;
        }

        final int installUserId = getInstallUserId();
        final int testUserId = getTestUserId();
        final Map<String, String> testArgs = new HashMap<>();
        testArgs.put(""testUser"", Integer.toString(installUserId));

        installTestAppForUser(TINY_APK, installUserId);
        installTestAppForUser(TEST_WITH_PERMISSION_APK, testUserId);

        Utils.runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".ApplicationVisibilityCrossUserTest"",
                ""testPackageVisibility_otherUserGrant"",
                testUserId,
                testArgs);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ApplicationVisibilityTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ApplicationVisibilityTest"	"testPackageListOtherUserCrossUserNoGrant"	"CtsAppSecurityHostTestCases"	"1: permission"	"([2:/android/appsecurity/cts/ApplicationVisibilityTest.java]:[permission]:[2]:method_text:[ckageVisibility_otherUserNoGrant"",                testUserId,                testArgs);    }   ]) :|: 
    @AppModeFull(reason = ""instant applications cannot see any other application"")
    public void testPackageListOtherUserCrossUserNoGrant() throws Exception {
        if (!mSupportsMultiUser) {
            return;
        }

        final int installUserId = getInstallUserId();
        final int testUserId = getTestUserId();
        final Map<String, String> testArgs = new HashMap<>();
        testArgs.put(""testUser"", Integer.toString(installUserId));

        installTestAppForUser(TINY_APK, installUserId);
        installTestAppForUser(TEST_WITH_PERMISSION_APK, testUserId);

        Utils.runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".ApplicationVisibilityCrossUserTest"",
                ""testPackageVisibility_otherUserNoGrant"",
                testUserId,
                testArgs);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ApplicationVisibilityTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ApplicationVisibilityTest"	"testApplicationListCrossUserGrant"	"CtsAppSecurityHostTestCases"	"1: permission"	"([3:/android/appsecurity/cts/ApplicationVisibilityTest.java]:[permission]:[3]:method_text:[          ""testApplicationVisibility_anyUserCrossUserGrant"",                testUserId);    }   ]) :|: 
    @AppModeFull(reason = ""instant applications cannot be granted INTERACT_ACROSS_USERS"")
    public void testApplicationListCrossUserGrant() throws Exception {
        if (!mSupportsMultiUser) {
            return;
        }

        final int installUserId = getInstallUserId();
        final int testUserId = getTestUserId();

        installTestAppForUser(TINY_APK, installUserId);
        installTestAppForUser(TEST_WITH_PERMISSION_APK, testUserId);

        Utils.runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".ApplicationVisibilityCrossUserTest"",
                ""testApplicationVisibility_currentUser"",
                testUserId);
        Utils.runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".ApplicationVisibilityCrossUserTest"",
                ""testApplicationVisibility_anyUserCrossUserGrant"",
                testUserId);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ApplicationVisibilityTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ApplicationVisibilityTest"	"testApplicationListCrossUserNoGrant"	"CtsAppSecurityHostTestCases"	"1: permission"	"([3:/android/appsecurity/cts/ApplicationVisibilityTest.java]:[permission]:[3]:method_text:[        ""testApplicationVisibility_anyUserCrossUserNoGrant"",                testUserId);    }   ]) :|: 
    @AppModeFull(reason = ""instant applications cannot see any other application"")
    public void testApplicationListCrossUserNoGrant() throws Exception {
        if (!mSupportsMultiUser) {
            return;
        }

        final int installUserId = getInstallUserId();
        final int testUserId = getTestUserId();

        installTestAppForUser(TINY_APK, installUserId);
        installTestAppForUser(TEST_WITH_PERMISSION_APK, testUserId);

        Utils.runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".ApplicationVisibilityCrossUserTest"",
                ""testApplicationVisibility_currentUser"",
                testUserId);
        Utils.runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".ApplicationVisibilityCrossUserTest"",
                ""testApplicationVisibility_anyUserCrossUserNoGrant"",
                testUserId);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ApplicationVisibilityTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ApplicationVisibilityTest"	"testApplicationListOtherUserCrossUserGrant"	"CtsAppSecurityHostTestCases"	"1: permission"	"([2:/android/appsecurity/cts/ApplicationVisibilityTest.java]:[permission]:[2]:method_text:[icationVisibility_otherUserGrant"",                testUserId,                testArgs);    }   ]) :|: 
    @AppModeFull(reason = ""instant applications cannot be granted INTERACT_ACROSS_USERS"")
    public void testApplicationListOtherUserCrossUserGrant() throws Exception {
        if (!mSupportsMultiUser) {
            return;
        }

        final int installUserId = getInstallUserId();
        final int testUserId = getTestUserId();
        final Map<String, String> testArgs = new HashMap<>();
        testArgs.put(""testUser"", Integer.toString(installUserId));

        installTestAppForUser(TINY_APK, installUserId);
        installTestAppForUser(TEST_WITH_PERMISSION_APK, testUserId);

        Utils.runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".ApplicationVisibilityCrossUserTest"",
                ""testApplicationVisibility_otherUserGrant"",
                testUserId,
                testArgs);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ApplicationVisibilityTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ApplicationVisibilityTest"	"testApplicationListOtherUserCrossUserNoGrant"	"CtsAppSecurityHostTestCases"	"1: permission"	"([2:/android/appsecurity/cts/ApplicationVisibilityTest.java]:[permission]:[2]:method_text:[ationVisibility_otherUserNoGrant"",                testUserId,                testArgs);    }   ]) :|: 
    @AppModeFull(reason = ""instant applications cannot see any other application"")
    public void testApplicationListOtherUserCrossUserNoGrant() throws Exception {
        if (!mSupportsMultiUser) {
            return;
        }

        final int installUserId = getInstallUserId();
        final int testUserId = getTestUserId();
        final Map<String, String> testArgs = new HashMap<>();
        testArgs.put(""testUser"", Integer.toString(installUserId));

        installTestAppForUser(TINY_APK, installUserId);
        installTestAppForUser(TEST_WITH_PERMISSION_APK, testUserId);

        Utils.runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".ApplicationVisibilityCrossUserTest"",
                ""testApplicationVisibility_otherUserNoGrant"",
                testUserId,
                testArgs);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ApplicationVisibilityTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ApplicationVisibilityTest"	"testGetPackagesForUidCrossUserGrant"	"CtsAppSecurityHostTestCases"	"1: permission"	"([3:/android/appsecurity/cts/ApplicationVisibilityTest.java]:[permission]:[3]:method_text:[""testGetPackagesForUidVisibility_anotherUserCrossUserGrant"",                testUserId);    }   ]) :|: 
    @AppModeFull(reason = ""instant applications cannot be granted INTERACT_ACROSS_USERS"")
    public void testGetPackagesForUidCrossUserGrant() throws Exception {
        if (!mSupportsMultiUser) {
            return;
        }

        final int installUserId = getInstallUserId();
        final int testUserId = getTestUserId();

        installTestAppForUser(TINY_APK, installUserId);
        installTestAppForUser(TEST_WITH_PERMISSION_APK, testUserId);

        Utils.runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".ApplicationVisibilityCrossUserTest"",
                ""testGetPackagesForUidVisibility_currentUser"",
                testUserId);
        Utils.runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".ApplicationVisibilityCrossUserTest"",
                ""testGetPackagesForUidVisibility_anotherUserCrossUserGrant"",
                testUserId);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ApplicationVisibilityTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ApplicationVisibilityTest"	"testGetPackagesForUidCrossUserNoGrant"	"CtsAppSecurityHostTestCases"	"1: permission"	"([3:/android/appsecurity/cts/ApplicationVisibilityTest.java]:[permission]:[3]:method_text:[        return mUsers[0];    }    private int getTestUserId() {        return mUsers[1];    }}]) :|: 
    @AppModeFull(reason = ""instant applications cannot see any other application"")
    public void testGetPackagesForUidCrossUserNoGrant() throws Exception {
        if (!mSupportsMultiUser) {
            return;
        }

        final int installUserId = getInstallUserId();
        final int testUserId = getTestUserId();

        installTestAppForUser(TINY_APK, installUserId);
        installTestAppForUser(TEST_WITH_PERMISSION_APK, testUserId);

        Utils.runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".ApplicationVisibilityCrossUserTest"",
                ""testGetPackagesForUidVisibility_currentUser"",
                testUserId);
        Utils.runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".ApplicationVisibilityCrossUserTest"",
                ""testGetPackagesForUidVisibility_anotherUserCrossUserNoGrant"",
                testUserId);
    }

    private int getInstallUserId() {
        return mUsers[0];
    }

    private int getTestUserId() {
        return mUsers[1];
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ApplicationVisibilityTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsecurity.cts.ReadableSettingsFieldsTest"	"testGlobalHiddenSettingsKeyNotReadableWithoutPermissions"	"CtsAppSecurityHostTestCases"	"1: permission"	"([2:/android/appsecurity/cts/ReadableSettingsFieldsTest.java]:[permission]:[2]:method_text:[ TEST_CLASS,                ""testGlobalHiddenSettingsKeyNotReadableWithoutPermissions"");    }   ]) :|: 
    public void testGlobalHiddenSettingsKeyNotReadableWithoutPermissions() throws
            DeviceNotAvailableException {
        runDeviceTests(TEST_PACKAGE, TEST_CLASS,
                ""testGlobalHiddenSettingsKeyNotReadableWithoutPermissions"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ReadableSettingsFieldsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephonyprovider.cts.TelephonyProviderHostTest"	"testWithChangeEnabled"	""	"1: permission"	"([1:/android/telephonyprovider/cts/TelephonyProviderHostTest.java]:[permission]:[1]:method_text:[PN_READING_PERMISSION_CHANGE_ID),                /*disabledChanges*/ ImmutableSet.of());    }   ]) :|: public void testWithChangeEnabled() throws Exception {
        if (!getDevice().hasFeature(FEATURE_TELEPHONY)) {
            return;
        }
        runDeviceCompatTest(TEST_PKG, "".TelephonyProviderTest"", ""testAccessToApnsWithChangeEnabled"",
                /*enabledChanges*/ImmutableSet.of(APN_READING_PERMISSION_CHANGE_ID),
                /*disabledChanges*/ ImmutableSet.of());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/telephonyprovider/src/android/telephonyprovider/cts/TelephonyProviderHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephonyprovider.cts.TelephonyProviderHostTest"	"testWithChangeDisabled"	""	"1: permission"	"([1:/android/telephonyprovider/cts/TelephonyProviderHostTest.java]:[permission]:[1]:method_text:[f(),                /*disabledChanges*/ ImmutableSet.of(APN_READING_PERMISSION_CHANGE_ID));    }}]) :|: public void testWithChangeDisabled() throws Exception {
        if (!getDevice().hasFeature(FEATURE_TELEPHONY)) {
            return;
        }
        runDeviceCompatTest(TEST_PKG, "".TelephonyProviderTest"",
                ""testAccessToApnsWithChangeDisabled"",
                /*enabledChanges*/ImmutableSet.of(),
                /*disabledChanges*/ ImmutableSet.of(APN_READING_PERMISSION_CHANGE_ID));
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/telephonyprovider/src/android/telephonyprovider/cts/TelephonyProviderHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.hdmicec.cts.tv.HdmiCecSystemAudioControlTest"	"isTrue"	"CtsHdmiCecHostTestCases"	"1: permission"	"([1:/android/hdmicec/cts/tv/HdmiCecSystemAudioControlTest.java]:[permission]:[1]:method_text:[adcast {@code <Set System     * Audio Mode>} [""Off""] message     */    @Ignore(""b/174733146"")   ]) :|: 
    public void cect_11_1_15_7_DutMutesForSetSystemAudioModeOn() throws Exception {
        /*
         * TODO: Call HdmiCecLocalDeviceTv.setSystemAudioMode(false) instead to turn off system
         * audio mode after permission issue is sorted.
         */
        hdmiCecClient.sendCecMessage(
                hdmiCecClient.getSelfDevice(),
                LogicalAddress.BROADCAST,
                CecOperand.SET_SYSTEM_AUDIO_MODE,
                CecMessage.formatParams(OFF));
        hdmiCecClient.sendCecMessage(
                hdmiCecClient.getSelfDevice(),
                LogicalAddress.BROADCAST,
                CecOperand.SET_SYSTEM_AUDIO_MODE,
                CecMessage.formatParams(ON));
        assertWithMessage(""Device is not muted"")
                .that(AudioManagerHelper.isDeviceMuted(getDevice()))
                .isTrue();
    }

    /**
     * Test 11.1.15-8
     *
     * <p>Tests that the DUT unmutes its volume when the DUT receives a broadcast {@code <Set System
     * Audio Mode>} [""Off""] message
     */
    @Ignore(""b/174733146"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/hdmicec/src/android/hdmicec/cts/tv/HdmiCecSystemAudioControlTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.hdmicec.cts.tv.HdmiCecSystemAudioControlTest"	"isFalse"	"CtsHdmiCecHostTestCases"	"1: permission"	"([1:/android/hdmicec/cts/tv/HdmiCecSystemAudioControlTest.java]:[permission]:[1]:method_text:[ing(message).equals("""");        } catch (Exception e) {            return false;        }    }}]) :|: 
    public void cect_11_1_15_8_DutUnmutesForSetSystemAudioModeOff() throws Exception {
        /*
         * TODO: Call HdmiCecLocalDeviceTv.setSystemAudioMode(true) instead to turn off system
         * audio mode after permission issue is sorted.
         */
        hdmiCecClient.sendCecMessage(
                hdmiCecClient.getSelfDevice(),
                LogicalAddress.BROADCAST,
                CecOperand.SET_SYSTEM_AUDIO_MODE,
                CecMessage.formatParams(ON));
        hdmiCecClient.sendCecMessage(
                hdmiCecClient.getSelfDevice(),
                LogicalAddress.BROADCAST,
                CecOperand.SET_SYSTEM_AUDIO_MODE,
                CecMessage.formatParams(OFF));
        assertWithMessage(""Device is muted"")
                .that(AudioManagerHelper.isDeviceMuted(getDevice()))
                .isFalse();
    }

    private boolean setSystemAudioMode(boolean enabled) throws Exception {
        getDevice().executeShellCommand(""cmd hdmi_control setsam "" + (enabled ? ""on"" : ""off""));
        try {
            String message =
                    hdmiCecClient.checkExpectedOutput(
                            LogicalAddress.AUDIO_SYSTEM, CecOperand.SYSTEM_AUDIO_MODE_REQUEST);
            /*
             * When system audio mode is turned off. DUT should send <System Audio Mode Request>
             * message with no params. And when it is turned on, DUT should send the same message
             * with params.
             */
            return enabled ^ CecMessage.getParamsAsString(message).equals("""");
        } catch (Exception e) {
            return false;
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/hdmicec/src/android/hdmicec/cts/tv/HdmiCecSystemAudioControlTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsearch.cts.AppSearchPackageTest"	"testPackageUninstall_immediatelyReboot"	"CtsAppSearchHostTestCases"	"1: permission"	"([1:/android/appsearch/cts/AppSearchPackageTest.java]:[permission]:[1]:method_text:[maryUserId);        runDeviceTestAsUserInPkgA(""testGetDocuments_nonexist"", mPrimaryUserId);    }}]) :|: 
    public void testPackageUninstall_immediatelyReboot() throws Exception {
        runDeviceTestAsUserInPkgA(""testPutDocuments"", mPrimaryUserId);
        runDeviceTestAsUserInPkgA(""closeAndFlush"", mPrimaryUserId);
        runDeviceTestAsUserInPkgA(""testGetDocuments_exist"", mPrimaryUserId);
        uninstallPackage(TARGET_PKG_A);
        // When test locally, if your test device doesn't support rebootUserspace(), you need to
        // manually unlock your device screen after it got fully rebooted. Or remove your screen
        // lock pin before the test. Otherwise it will hang.
        rebootAndWaitUntilReady();
        installPackageAsUser(TARGET_APK_A, /* grantPermission= */true, mPrimaryUserId);
        runDeviceTestAsUserInPkgA(""testGetDocuments_nonexist"", mPrimaryUserId);
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsearch/src/android/appsearch/cts/AppSearchPackageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsearch.cts.AppSearchInstantAppTest"	"isTrue"	"CtsAppSearchHostTestCases"	"1: permission"	"([1:/android/appsearch/cts/AppSearchInstantAppTest.java]:[permission]:[1]:method_text:[ter    public void tearDown() throws Exception {        uninstallPackage(TARGET_PKG_A);    }   ]) :|: /*
 *.
 */

package android.appsearch.cts;

import static com.google.common.truth.Truth.assertWithMessage;

import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;
import com.android.tradefed.testtype.junit4.BaseHostJUnit4Test;
import com.android.tradefed.testtype.junit4.DeviceTestRunOptions;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.Map;

import javax.annotation.Nonnull;

/**
 * Test to cover instant app behavior with AppSearch.
 *
 * <p>This test is split into two distinct parts: The first part is the test-apps that runs on the
 * device and interactive with AppSearch. This class is the second part that runs on the host and
 * triggers tests in the first part for different users.
 *
 * <p>To trigger a device test, call runDeviceTestAsUser with a specific the test name and specific
 * user.
 *
 * <p>Unlock your device when testing locally.
 */
@RunWith(DeviceJUnit4ClassRunner.class)
public class AppSearchInstantAppTest extends BaseHostJUnit4Test {
    private static final String TARGET_APK_A = ""CtsAppSearchHostTestHelperA.apk"";
    private static final String TARGET_PKG_A = ""android.appsearch.app.a"";
    private static final String TEST_CLASS_A = TARGET_PKG_A + "".AppSearchInstantAppTest"";
    private static final long DEFAULT_INSTRUMENTATION_TIMEOUT_MS = 600_000; // 10min

    private int mPrimaryUserId;

    private void runDeviceTestAsUserInPkgA(@Nonnull String testMethod, int userId)
            throws Exception {
        assertWithMessage(testMethod + "" failed"").that(
                runDeviceTests(getDevice(), TARGET_PKG_A, TEST_CLASS_A, testMethod, userId,
                        DEFAULT_INSTRUMENTATION_TIMEOUT_MS)).isTrue();
    }

    @Before
    public void setUp() throws Exception {
        mPrimaryUserId = getDevice().getPrimaryUserId();
        uninstallPackage(TARGET_PKG_A);
        installPackageAsUser(TARGET_APK_A, /* grantPermission= */true, mPrimaryUserId, ""--in"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsearch/src/android/appsearch/cts/AppSearchInstantAppTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsearch.cts.AppSearchMultiUserTest"	"isMultiUserSupported"	"CtsAppSearchHostTestCases"	"1: permission"	"([2:/android/appsearch/cts/AppSearchMultiUserTest.java]:[permission]:[2]:method_text:[ (mSecondaryUserId > 0) {            getDevice().removeUser(mSecondaryUserId);        }    }   ]) :|: /*
 *.
 */

package android.appsearch.cts;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assume.assumeTrue;

import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.Collections;
import java.util.Map;

/**
 * Test to cover multi-user interacting with AppSearch.
 *
 * <p>This test is split into two distinct parts: The first part is the test-apps that runs on the
 * device and interactive with AppSearch. This class is the second part that runs on the host and
 * triggers tests in the first part for different users.
 *
 * <p>To trigger a device test, call runDeviceTestAsUser with a specific the test name and specific
 * user.
 *
 * <p>Unlock your device when test locally.
 */
@RunWith(DeviceJUnit4ClassRunner.class)
public class AppSearchMultiUserTest extends AppSearchHostTestBase {

    private int mInitialUserId;
    private int mSecondaryUserId;

    @Before
    public void setUp() throws Exception {
        assumeTrue(""Multi-user is not supported on this device"",
                getDevice().isMultiUserSupported());

        mInitialUserId = getDevice().getCurrentUser();
        mSecondaryUserId = getDevice().createUser(""Test_User"");
        assertThat(getDevice().startUser(mSecondaryUserId)).isTrue();

        installPackageAsUser(TARGET_APK_A, /* grantPermission= */true, mInitialUserId);
        installPackageAsUser(TARGET_APK_A, /* grantPermission= */true, mSecondaryUserId);

        runDeviceTestAsUserInPkgA(""clearTestData"", mInitialUserId);
        runDeviceTestAsUserInPkgA(""clearTestData"", mSecondaryUserId);
    }

    @After
    public void tearDown() throws Exception {
        if (getDevice().getInstalledPackageNames().contains(TARGET_PKG_A)) {
            runDeviceTestAsUserInPkgA(""clearTestData"", mInitialUserId);
        }
        if (mSecondaryUserId > 0) {
            getDevice().removeUser(mS"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsearch/src/android/appsearch/cts/AppSearchMultiUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appsearch.cts.AppSearchMultiUserTest"	"testPackageUninstall_onLockedUser"	"CtsAppSearchHostTestCases"	"1: permission"	"([1:/android/appsearch/cts/AppSearchMultiUserTest.java]:[permission]:[1]:method_text:[;        runDeviceTestAsUserInPkgB(""testGlobalGetDocuments_nonexist"", mSecondaryUserId);    }   ]) :|: 
    public void testPackageUninstall_onLockedUser() throws Exception {
        installPackageAsUser(TARGET_APK_B, /* grantPermission= */true, mSecondaryUserId);
        // package A grants visibility to package B.
        runDeviceTestAsUserInPkgA(""testPutDocuments"", mSecondaryUserId);
        // query the document from another package.
        runDeviceTestAsUserInPkgB(""testGlobalGetDocuments_exist"", mSecondaryUserId);
        getDevice().stopUser(mSecondaryUserId, /*waitFlag=*/true, /*forceFlag=*/true);
        uninstallPackage(TARGET_PKG_A);
        getDevice().startUser(mSecondaryUserId, /*waitFlag=*/true);
        runDeviceTestAsUserInPkgB(""testGlobalGetDocuments_nonexist"", mSecondaryUserId);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsearch/src/android/appsearch/cts/AppSearchMultiUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.cts.statsdatom.alarm.AlarmStatsTests"	"testAlarmScheduled"	"CtsStatsdAtomHostTestCases"	"1: permission"	"([1:/android/cts/statsdatom/alarm/AlarmStatsTests.java]:[permission]:[1]:method_text:[LE);            }            count++;        }        assertThat(count).isEqualTo(2);    }   ]) :|: public void testAlarmScheduled() throws Exception {
        if (DeviceUtils.hasFeature(getDevice(), FEATURE_AUTOMOTIVE)) return;

        final int atomId = AtomsProto.Atom.ALARM_SCHEDULED_FIELD_NUMBER;

        ConfigUtils.uploadConfigForPushedAtom(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                atomId);
        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", ""testAlarmScheduled"");

        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        assertThat(data.size()).isAtLeast(2);
        final int uid = DeviceUtils.getStatsdTestAppUid(getDevice());

        int count = 0;
        Predicate<AtomsProto.AlarmScheduled> alarm1 =
                as -> (!as.getIsRtc() && as.getIsExact() && as.getIsWakeup() && !as.getIsRepeating()
                        && !as.getIsAlarmClock() && !as.getIsAllowWhileIdle());
        Predicate<AtomsProto.AlarmScheduled> alarm2 =
                as -> (as.getIsRtc() && !as.getIsExact() && !as.getIsWakeup()
                        && !as.getIsRepeating() && !as.getIsAlarmClock()
                        && !as.getIsAllowWhileIdle());
        for (int i = 0; i < data.size(); i++) {
            AtomsProto.AlarmScheduled as = data.get(i).getAtom().getAlarmScheduled();
            if (as.getCallingUid() != uid) {
                continue;
            }
            assertThat(alarm1.test(as) != alarm2.test(as)).isTrue();
            assertThat(as.getCallingProcessState()).isNoneOf(ProcessStateEnum.PROCESS_STATE_UNKNOWN,
                    ProcessStateEnum.PROCESS_STATE_UNKNOWN_TO_PROTO);
            if (as.getIsExact()) {
                assertThat(as.getExactAlarmAllowedReason()).isAnyOf(
                        AtomsProto.AlarmScheduled.ReasonCode.PERMISSION,
                        AtomsProto.AlarmScheduled.ReasonCode.CHANGE_DISABLED);
            } else {
                assertThat(as.getExactAlarmAllowedReason()).isEqualTo(
                        AtomsProto.AlarmSche"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/alarm/AlarmStatsTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.cts.statsdatom.appexit.AppExitHostTest"	"isNotNull"	"CtsStatsdAtomHostTestCases"	"1: permission"	"([3:/android/cts/statsdatom/appexit/AppExitHostTest.java]:[permission]:[3]:method_text:[@Override    public void setBuild(IBuildInfo buildInfo) {        mCtsBuild = buildInfo;    }   ]) :|: public void test/*
 *.
 */

package android.cts.statsdatom.appexit;

import static android.app.AppExitReasonCode.REASON_OTHER;
import static android.app.AppExitReasonCode.REASON_PERMISSION_CHANGE;
import static android.app.AppExitSubReasonCode.SUBREASON_ISOLATED_NOT_NEEDED;
import static android.app.Importance.IMPORTANCE_CACHED;
import static android.app.Importance.IMPORTANCE_SERVICE;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import android.cts.statsdatom.lib.AtomTestUtils;
import android.cts.statsdatom.lib.ConfigUtils;
import android.cts.statsdatom.lib.DeviceUtils;
import android.cts.statsdatom.lib.ReportUtils;

import com.android.os.AtomsProto;
import com.android.os.StatsLog;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.testtype.DeviceTestCase;
import com.android.tradefed.testtype.IBuildReceiver;

import java.util.List;
import java.util.function.Consumer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class AppExitHostTest extends DeviceTestCase implements IBuildReceiver {
    private static final String TEST_PKG = ""android.app.cts.appexit"";
    private static final String HELPER_PKG1 = ""android.externalservice.service"";
    private static final String HELPER_PKG2 = ""com.android.cts.launcherapps.simpleapp"";
    private static final String TEST_APK = ""CtsAppExitTestCases.apk"";
    private static final String HELPER_APK1 = ""CtsExternalServiceService.apk"";
    private static final String HELPER_APK2 = ""CtsSimpleApp.apk"";
    private static final String TEST_CLASS = ""android.app.cts.ActivityManagerAppExitInfoTest"";
    private static final long APP_EXIT_INFO_STATSD_LOG_DEBOUNCE_MSEC = 15_000;
    private static final String PERM_PACKAGE_USAGE_STATS = ""android.permission.PACKAGE_USAGE_STATS"";
    private static final String PERM_READ_LOGS = ""android.permission.READ_LOGS"";

    private IBuildInfo mCtsBuild;

    @Override
    protected voi"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/appexit/AppExitHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.cts.statsdatom.appexit.AppExitHostTest"	"testLogStatsdPermChanged"	"CtsStatsdAtomHostTestCases"	"1: permission"	"([2:/android/cts/statsdatom/appexit/AppExitHostTest.java]:[permission]:[2]:method_text:[etPss()).isAtLeast(0);            assertThat(appDied.getRss()).isAtLeast(0);        });    }   ]) :|: public void testLogStatsdPermChanged() throws Exception {
        final String helperPackage = HELPER_PKG2;
        final int expectedUid = getAppUid(helperPackage);
        performLogStatsdTest(""testPermissionChange"", helperPackage, 1, appDied -> {
            assertThat(appDied.getUid()).isEqualTo(expectedUid);
            assertThat(appDied.getProcessName()).isEqualTo("""");
            assertThat(appDied.getReason()).isEqualTo(REASON_PERMISSION_CHANGE);
            assertThat(appDied.getImportance()).isEqualTo(IMPORTANCE_CACHED);
            assertThat(appDied.getPss()).isAtLeast(0);
            assertThat(appDied.getRss()).isAtLeast(0);
        });
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/appexit/AppExitHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.cts.statsdatom.permissionstate.DangerousPermissionStateTests"	"isNotNull"	"CtsStatsdAtomHostTestCases"	"1: permission"	"([3:/android/cts/statsdatom/permissionstate/DangerousPermissionStateTests.java]:[permission]:[3]:method_text:[@Override    public void setBuild(IBuildInfo buildInfo) {        mCtsBuild = buildInfo;    }   ]) :|: public void test/*
 *.
 */

package android.cts.statsdatom.permissionstate;

import static com.google.common.truth.Truth.assertThat;

import android.cts.statsdatom.lib.AtomTestUtils;
import android.cts.statsdatom.lib.ConfigUtils;
import android.cts.statsdatom.lib.DeviceUtils;
import android.cts.statsdatom.lib.ReportUtils;

import com.android.os.AtomsProto;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.testtype.DeviceTestCase;
import com.android.tradefed.testtype.IBuildReceiver;

import java.util.ArrayList;
import java.util.List;

public class DangerousPermissionStateTests extends DeviceTestCase implements IBuildReceiver {
    private static final int FLAG_PERMISSION_USER_SENSITIVE_WHEN_GRANTED = 1 << 8;

    private IBuildInfo mCtsBuild;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        assertThat(mCtsBuild).isNotNull();
        ConfigUtils.removeConfig(getDevice());
        ReportUtils.clearReports(getDevice());
        DeviceUtils.installStatsdTestApp(getDevice(), mCtsBuild);
        Thread.sleep(AtomTestUtils.WAIT_TIME_LONG);
    }

    @Override
    protected void tearDown() throws Exception {
        ConfigUtils.removeConfig(getDevice());
        ReportUtils.clearReports(getDevice());
        DeviceUtils.uninstallStatsdTestApp(getDevice());
        super.tearDown();
    }

    @Override
    public void setBuild(IBuildInfo buildInfo) {
        mCtsBuild = buildInfo;
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/permissionstate/DangerousPermissionStateTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.cts.statsdatom.permissionstate.DangerousPermissionStateTests"	"testDangerousPermissionState"	"CtsStatsdAtomHostTestCases"	"1: permission"	"([22:/android/cts/statsdatom/permissionstate/DangerousPermissionStateTests.java]:[permission]:[22]:method_text:[     }            }        }        assertThat(verifiedKnowPermissionState).isTrue();    }   ]) :|: public void testDangerousPermissionState() throws Exception {

        final int FLAG_PERMISSION_USER_SENSITIVE_WHEN_DENIED = 1 << 9;
        final int PROTECTION_FLAG_DANGEROUS = 1;
        final int PROTECTION_FLAG_INSTANT = 0x1000;

        // Set up what to collect
        ConfigUtils.uploadConfigForPulledAtom(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                AtomsProto.Atom.DANGEROUS_PERMISSION_STATE_FIELD_NUMBER);

        boolean verifiedKnowPermissionState = false;

        // Pull a report
        AtomTestUtils.sendAppBreadcrumbReportedAtom(getDevice());
        Thread.sleep(AtomTestUtils.WAIT_TIME_SHORT);

        int testAppId = getAppId(DeviceUtils.getStatsdTestAppUid(getDevice()));

        for (AtomsProto.Atom atom : ReportUtils.getGaugeMetricAtoms(getDevice())) {
            AtomsProto.DangerousPermissionState permissionState = atom.getDangerousPermissionState();

            assertThat(permissionState.getPermissionName()).isNotNull();
            assertThat(permissionState.getUid()).isAtLeast(0);
            assertThat(permissionState.getPackageName()).isNotNull();

            if (getAppId(permissionState.getUid()) == testAppId) {

                if (permissionState.getPermissionName().contains(
                        ""ACCESS_FINE_LOCATION"")) {
                    assertThat(permissionState.getIsGranted()).isTrue();
                    assertThat(permissionState.getPermissionFlags() & ~(
                            FLAG_PERMISSION_USER_SENSITIVE_WHEN_DENIED
                                    | FLAG_PERMISSION_USER_SENSITIVE_WHEN_GRANTED))
                            .isEqualTo(0);
                    assertThat(permissionState.getProtectionFlags()).isEqualTo(
                            PROTECTION_FLAG_DANGEROUS | PROTECTION_FLAG_INSTANT
                    );

                    verifiedKnowPermissionState = true;
                }
            }
        }

        assertThat(verifiedKnowPermissionState).isTrue();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/permissionstate/DangerousPermissionStateTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.cts.statsdatom.permissionstate.DangerousPermissionStateTests"	"testDangerousPermissionStateSampled"	"CtsStatsdAtomHostTestCases"	"1: permission"	"([26:/android/cts/statsdatom/permissionstate/DangerousPermissionStateTests.java]:[permission]:[26]:method_text:[dle#getAppId     */    private static int getAppId(int uid) {        return uid % 100000;    }}]) :|: public void testDangerousPermissionStateSampled() throws Exception {
        // get full atom for reference
        ConfigUtils.uploadConfigForPulledAtom(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                AtomsProto.Atom.DANGEROUS_PERMISSION_STATE_FIELD_NUMBER);

        AtomTestUtils.sendAppBreadcrumbReportedAtom(getDevice());
        Thread.sleep(AtomTestUtils.WAIT_TIME_SHORT);

        List<AtomsProto.DangerousPermissionState> fullDangerousPermissionState = new ArrayList<>();
        for (AtomsProto.Atom atom : ReportUtils.getGaugeMetricAtoms(getDevice())) {
            fullDangerousPermissionState.add(atom.getDangerousPermissionState());
        }

        ConfigUtils.removeConfig(getDevice());
        ReportUtils.clearReports(getDevice()); // Clears data.
        List<AtomsProto.Atom> gaugeMetricDataList = null;

        // retries in case sampling returns full list or empty list - which should be extremely rare
        for (int attempt = 0; attempt < 10; attempt++) {
            // Set up what to collect
            ConfigUtils.uploadConfigForPulledAtom(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                    AtomsProto.Atom.DANGEROUS_PERMISSION_STATE_SAMPLED_FIELD_NUMBER);

            // Pull a report
            AtomTestUtils.sendAppBreadcrumbReportedAtom(getDevice());
            Thread.sleep(AtomTestUtils.WAIT_TIME_SHORT);

            gaugeMetricDataList = ReportUtils.getGaugeMetricAtoms(getDevice());
            if (gaugeMetricDataList.size() > 0
                    && gaugeMetricDataList.size() < fullDangerousPermissionState.size()) {
                break;
            }
            ConfigUtils.removeConfig(getDevice());
            ReportUtils.clearReports(getDevice()); // Clears data.
        }
        assertThat(gaugeMetricDataList.size()).isGreaterThan(0);
        assertThat(gaugeMetricDataList.size()).isLessThan(fullDangerousPermissionState.size());

        long lastUid = -1;
        int fullIndex = 0;

        for (AtomsPro"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/permissionstate/DangerousPermissionStateTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.server.cts.device.statsdatom.AtomTests"	"testGenerateMobileTraffic"	""	"2: INTERNET permission"	"([2:/com/android/server/cts/device/statsdatom/AtomTests.java]:[permission]:[2]:method_text:[PORT_WIFI)) {                return true;            }        }        return false;    }   ]) :|: 
    public void testGenerateMobileTraffic() throws Exception {
        final Context context = InstrumentationRegistry.getContext();
        doGenerateNetworkTraffic(context, NetworkCapabilities.TRANSPORT_CELLULAR);
    }

    // Constants which are locally used by doGenerateNetworkTraffic.
    private static final int NETWORK_TIMEOUT_MILLIS = 15000;
    private static final String HTTPS_HOST_URL =
            ""https://connectivitycheck.gstatic.com/generate_204"";

    private void doGenerateNetworkTraffic(@NonNull Context context, int transport)
            throws InterruptedException {
        final ConnectivityManager cm = context.getSystemService(ConnectivityManager.class);
        final NetworkRequest request = new NetworkRequest.Builder().addCapability(
                NetworkCapabilities.NET_CAPABILITY_INTERNET).addTransportType(transport).build();
        final CtsNetUtils.TestNetworkCallback callback = new CtsNetUtils.TestNetworkCallback();

        // Request network, and make http query when the network is available.
        cm.requestNetwork(request, callback);

        // If network is not available, throws IllegalStateException.
        final Network network = callback.waitForAvailable();
        if (network == null) {
            throw new IllegalStateException(""network with transport "" + transport
                    + "" is not available."");
        }

        final long startTime = SystemClock.elapsedRealtime();
        try {
            exerciseRemoteHost(cm, network, new URL(HTTPS_HOST_URL));
            Log.i(TAG, ""exerciseRemoteHost successful in "" + (SystemClock.elapsedRealtime()
                    - startTime) + "" ms"");
        } catch (Exception e) {
            Log.e(TAG, ""exerciseRemoteHost failed in "" + (SystemClock.elapsedRealtime()
                    - startTime) + "" ms: "" + e);
        } finally {
            cm.unregisterNetworkCallback(callback);
        }
    }

    /**
     * Generate traffic on specified network.
     */
    priv"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/apps/statsdapp/src/com/android/server/cts/device/statsdatom/AtomTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.context.ContextCrossProfileDeviceTest"	"dropShellPermissionIdentity"	""	"1: permission"	"([8:/com/android/cts/context/ContextCrossProfileDeviceTest.java]:[permission]:[8]:method_text:[ignore) {            }        }        fail(""testUser not found."");        return -1;    }   ]) :|: /*
 *.
 */

package com.android.cts.context;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.fail;

import android.app.AppOpsManager;
import android.app.UiAutomation;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.os.Binder;
import android.os.Bundle;
import android.os.UserHandle;

import androidx.test.InstrumentationRegistry;

import org.junit.After;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

/**
 * This suite of test ensures that certain APIs in {@link Context} behaves correctly across users.
 */
@RunWith(JUnit4.class)
public class ContextCrossProfileDeviceTest {
    private static final String INTERACT_ACROSS_USERS_FULL_PERMISSION =
            ""android.permission.INTERACT_ACROSS_USERS_FULL"";
    private static final String INTERACT_ACROSS_USERS_PERMISSION =
            ""android.permission.INTERACT_ACROSS_USERS"";
    private static final String INTERACT_ACROSS_PROFILES_PERMISSION =
            ""android.permission.INTERACT_ACROSS_PROFILES"";
    private static final String MANAGE_APP_OPS_MODE = ""android.permission.MANAGE_APP_OPS_MODES"";

    private static final String TEST_SERVICE_PKG =
            ""com.android.cts.testService"";
    private static final String TEST_SERVICE_IN_DIFFERENT_PKG_CLASS =
            TEST_SERVICE_PKG + "".ContextCrossProfileTestService"";
    public static final ComponentName TEST_SERVICE_IN_DIFFERENT_PKG_COMPONENT_NAME =
            new ComponentName(TEST_SERVICE_PKG, TEST_SERVICE_IN_DIFFERENT_PKG_CLASS);

    private static final String TEST_SERVICE_IN_SAME_PKG_CLASS =
            InstrumentationRegistry.getContext().getPackageName()
                    + "".ContextCrossProfileSamePackageTestService"";
    public static final ComponentName TEST_SERVICE_IN_SAME_PKG_COMPONENT_NAME =
            new ComponentName(InstrumentationRegistry.getContext().getPackageName(),
                    TES"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/content/test-apps/ContextCrossProfileApps/ContextCrossProfileApp/src/com/android/cts/context/ContextCrossProfileDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.context.ContextCrossProfileDeviceTest"	"testBindServiceAsUser_differentUser_bindsServiceToCorrectUser"	""	"1: permission"	"([2:/com/android/cts/context/ContextCrossProfileDeviceTest.java]:[permission]:[2]:method_text:[ntextCrossProfileTestConnection(), Context.BIND_AUTO_CREATE))                .isFalse();    }   ]) :|: 
    public void testBindServiceAsUser_differentUser_bindsServiceToCorrectUser() {
        final Context context = InstrumentationRegistry.getContext();
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        int otherProfileId = getTestUser();
        UserHandle otherProfileHandle = UserHandle.of(otherProfileId);
        uiAutomation.adoptShellPermissionIdentity(INTERACT_ACROSS_USERS_PERMISSION);
        Intent bindIntent = new Intent();
        bindIntent.setComponent(TEST_SERVICE_IN_DIFFERENT_PKG_COMPONENT_NAME);

        assertThat(context.bindServiceAsUser(
                bindIntent, new ContextCrossProfileTestConnection(),
                Context.BIND_AUTO_CREATE, otherProfileHandle))
                .isTrue();
        assertThat(context.bindService(
                    bindIntent, new ContextCrossProfileTestConnection(), Context.BIND_AUTO_CREATE))
                .isFalse();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/content/test-apps/ContextCrossProfileApps/ContextCrossProfileApp/src/com/android/cts/context/ContextCrossProfileDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.context.ContextCrossProfileDeviceTest"	"testBindServiceAsUser_sameProfileGroup_samePackage_withAcrossUsersPermission_bindsService"	""	"1: permission"	"([3:/com/android/cts/context/ContextCrossProfileDeviceTest.java]:[permission]:[3]:method_text:[onnection(),                    Context.BIND_AUTO_CREATE, otherProfileHandle)).isTrue();    }   ]) :|: 
    public void testBindServiceAsUser_sameProfileGroup_samePackage_withAcrossUsersPermission_bindsService() {
        final Context context = InstrumentationRegistry.getContext();
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        int otherProfileId = getTestUser();
        UserHandle otherProfileHandle = UserHandle.of(otherProfileId);
        uiAutomation.adoptShellPermissionIdentity(INTERACT_ACROSS_USERS_PERMISSION);
        Intent bindIntent = new Intent();
        bindIntent.setComponent(TEST_SERVICE_IN_SAME_PKG_COMPONENT_NAME);

        assertThat(context.bindServiceAsUser(
                    bindIntent, new ContextCrossProfileTestConnection(),
                    Context.BIND_AUTO_CREATE, otherProfileHandle)).isTrue();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/content/test-apps/ContextCrossProfileApps/ContextCrossProfileApp/src/com/android/cts/context/ContextCrossProfileDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.context.ContextCrossProfileDeviceTest"	"testBindServiceAsUser_sameProfileGroup_differentPackage_withAcrossUsersPermission_bindsService"	""	"1: permission"	"([3:/com/android/cts/context/ContextCrossProfileDeviceTest.java]:[permission]:[3]:method_text:[estConnection(),                Context.BIND_AUTO_CREATE, otherProfileHandle)).isTrue();    }   ]) :|: 
    public void testBindServiceAsUser_sameProfileGroup_differentPackage_withAcrossUsersPermission_bindsService() {
        final Context context = InstrumentationRegistry.getContext();
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        int otherProfileId = getTestUser();
        UserHandle otherProfileHandle = UserHandle.of(otherProfileId);
        uiAutomation.adoptShellPermissionIdentity(INTERACT_ACROSS_USERS_PERMISSION);
        Intent bindIntent = new Intent();
        bindIntent.setComponent(TEST_SERVICE_IN_DIFFERENT_PKG_COMPONENT_NAME);

        assertThat(context.bindServiceAsUser(
                bindIntent, new ContextCrossProfileTestConnection(),
                Context.BIND_AUTO_CREATE, otherProfileHandle)).isTrue();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/content/test-apps/ContextCrossProfileApps/ContextCrossProfileApp/src/com/android/cts/context/ContextCrossProfileDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.context.ContextCrossProfileDeviceTest"	"testBindServiceAsUser_sameProfileGroup_samePackage_withAcrossProfilesPermission_bindsService"	""	"1: permission"	"([7:/com/android/cts/context/ContextCrossProfileDeviceTest.java]:[permission]:[7]:method_text:[estConnection(),                Context.BIND_AUTO_CREATE, otherProfileHandle)).isTrue();    }   ]) :|: 
    public void testBindServiceAsUser_sameProfileGroup_samePackage_withAcrossProfilesPermission_bindsService() {
        final Context context = InstrumentationRegistry.getContext();
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        final AppOpsManager appOpsManager = context.getSystemService(AppOpsManager.class);
        uiAutomation.adoptShellPermissionIdentity(MANAGE_APP_OPS_MODE);
        appOpsManager.setMode(AppOpsManager.permissionToOp(INTERACT_ACROSS_PROFILES_PERMISSION),
                Binder.getCallingUid(), context.getPackageName(), AppOpsManager.MODE_DEFAULT);
        uiAutomation.dropShellPermissionIdentity();
        int otherProfileId = getTestUser();
        UserHandle otherProfileHandle = UserHandle.of(otherProfileId);
        uiAutomation.adoptShellPermissionIdentity(INTERACT_ACROSS_PROFILES_PERMISSION);
        Intent bindIntent = new Intent();
        bindIntent.setComponent(TEST_SERVICE_IN_SAME_PKG_COMPONENT_NAME);

        assertThat(context.bindServiceAsUser(
                bindIntent, new ContextCrossProfileTestConnection(),
                Context.BIND_AUTO_CREATE, otherProfileHandle)).isTrue();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/content/test-apps/ContextCrossProfileApps/ContextCrossProfileApp/src/com/android/cts/context/ContextCrossProfileDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.context.ContextCrossProfileDeviceTest"	"testBindServiceAsUser_sameProfileGroup_differentPackage_withAcrossProfilesPermission_throwsException"	""	"1: permission"	"([3:/com/android/cts/context/ContextCrossProfileDeviceTest.java]:[permission]:[3]:method_text:[uld throw a Security Exception"");        } catch (SecurityException ignored) {        }    }   ]) :|: 
    public void testBindServiceAsUser_sameProfileGroup_differentPackage_withAcrossProfilesPermission_throwsException() {
        final Context context = InstrumentationRegistry.getContext();
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        int otherProfileId = getTestUser();
        UserHandle otherProfileHandle = UserHandle.of(otherProfileId);
        uiAutomation.adoptShellPermissionIdentity(INTERACT_ACROSS_PROFILES_PERMISSION);
        Intent bindIntent = new Intent();
        bindIntent.setComponent(TEST_SERVICE_IN_DIFFERENT_PKG_COMPONENT_NAME);

        try {
            context.bindServiceAsUser(
                    bindIntent, new ContextCrossProfileTestConnection(), Context.BIND_AUTO_CREATE,
                    otherProfileHandle);

            fail(""Should throw a Security Exception"");
        } catch (SecurityException ignored) {
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/content/test-apps/ContextCrossProfileApps/ContextCrossProfileApp/src/com/android/cts/context/ContextCrossProfileDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.context.ContextCrossProfileDeviceTest"	"testBindServiceAsUser_sameProfileGroup_samePackage_withAcrossProfilesAppOp_bindsService"	""	"1: permission"	"([4:/com/android/cts/context/ContextCrossProfileDeviceTest.java]:[permission]:[4]:method_text:[estConnection(),                Context.BIND_AUTO_CREATE, otherProfileHandle)).isTrue();    }   ]) :|: 
    public void testBindServiceAsUser_sameProfileGroup_samePackage_withAcrossProfilesAppOp_bindsService(){
        final Context context = InstrumentationRegistry.getContext();
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        final AppOpsManager appOpsManager = context.getSystemService(AppOpsManager.class);
        uiAutomation.adoptShellPermissionIdentity(MANAGE_APP_OPS_MODE);
        appOpsManager.setMode(AppOpsManager.permissionToOp(INTERACT_ACROSS_PROFILES_PERMISSION),
                Binder.getCallingUid(), context.getPackageName(), AppOpsManager.MODE_ALLOWED);
        uiAutomation.dropShellPermissionIdentity();
        int otherProfileId = getTestUser();
        UserHandle otherProfileHandle = UserHandle.of(otherProfileId);
        Intent bindIntent = new Intent();
        bindIntent.setComponent(TEST_SERVICE_IN_SAME_PKG_COMPONENT_NAME);

        assertThat(context.bindServiceAsUser(
                bindIntent, new ContextCrossProfileTestConnection(),
                Context.BIND_AUTO_CREATE, otherProfileHandle)).isTrue();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/content/test-apps/ContextCrossProfileApps/ContextCrossProfileApp/src/com/android/cts/context/ContextCrossProfileDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.context.ContextCrossProfileDeviceTest"	"testBindServiceAsUser_sameProfileGroup_differentPackage_withAcrossProfilesAppOp_throwsException"	""	"1: permission"	"([4:/com/android/cts/context/ContextCrossProfileDeviceTest.java]:[permission]:[4]:method_text:[uld throw a Security Exception"");        } catch (SecurityException ignored) {        }    }   ]) :|: 
    public void testBindServiceAsUser_sameProfileGroup_differentPackage_withAcrossProfilesAppOp_throwsException(){
        final Context context = InstrumentationRegistry.getContext();
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        final AppOpsManager appOpsManager = context.getSystemService(AppOpsManager.class);
        uiAutomation.adoptShellPermissionIdentity(MANAGE_APP_OPS_MODE);
        appOpsManager.setMode(AppOpsManager.permissionToOp(INTERACT_ACROSS_PROFILES_PERMISSION),
                Binder.getCallingUid(), context.getPackageName(), AppOpsManager.MODE_ALLOWED);
        uiAutomation.dropShellPermissionIdentity();
        int otherProfileId = getTestUser();
        UserHandle otherProfileHandle = UserHandle.of(otherProfileId);
        Intent bindIntent = new Intent();
        bindIntent.setComponent(TEST_SERVICE_IN_DIFFERENT_PKG_COMPONENT_NAME);

        try {
            context.bindServiceAsUser(
                    bindIntent, new ContextCrossProfileTestConnection(), Context.BIND_AUTO_CREATE,
                    otherProfileHandle);

            fail(""Should throw a Security Exception"");
        } catch (SecurityException ignored) {
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/content/test-apps/ContextCrossProfileApps/ContextCrossProfileApp/src/com/android/cts/context/ContextCrossProfileDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.context.ContextCrossProfileDeviceTest"	"testBindServiceAsUser_differentProfileGroup_withInteractAcrossUsersPermission_throwsException"	""	"1: permission"	"([3:/com/android/cts/context/ContextCrossProfileDeviceTest.java]:[permission]:[3]:method_text:[uld throw a Security Exception"");        } catch (SecurityException ignored) {        }    }   ]) :|: 
    public void testBindServiceAsUser_differentProfileGroup_withInteractAcrossUsersPermission_throwsException() {
        final Context context = InstrumentationRegistry.getContext();
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        int otherUserId = getTestUser();
        UserHandle otherUserHandle = UserHandle.of(otherUserId);
        uiAutomation.adoptShellPermissionIdentity(INTERACT_ACROSS_USERS_PERMISSION);
        try {
            Intent bindIntent = new Intent();
            bindIntent.setComponent(TEST_SERVICE_IN_SAME_PKG_COMPONENT_NAME);

            context.bindServiceAsUser(
                    bindIntent, new ContextCrossProfileTestConnection(), Context.BIND_AUTO_CREATE,
                    otherUserHandle);

            fail(""Should throw a Security Exception"");
        } catch (SecurityException ignored) {
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/content/test-apps/ContextCrossProfileApps/ContextCrossProfileApp/src/com/android/cts/context/ContextCrossProfileDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.context.ContextCrossProfileDeviceTest"	"testBindServiceAsUser_differentProfileGroup_withInteractAcrossProfilesPermission_throwsException"	""	"1: permission"	"([3:/com/android/cts/context/ContextCrossProfileDeviceTest.java]:[permission]:[3]:method_text:[uld throw a Security Exception"");        } catch (SecurityException ignored) {        }    }   ]) :|: 
    public void testBindServiceAsUser_differentProfileGroup_withInteractAcrossProfilesPermission_throwsException() {
        final Context context = InstrumentationRegistry.getContext();
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        int otherUserId = getTestUser();
        UserHandle otherUserHandle = UserHandle.of(otherUserId);
        uiAutomation.adoptShellPermissionIdentity(INTERACT_ACROSS_PROFILES_PERMISSION);
        try {
            Intent bindIntent = new Intent();
            bindIntent.setComponent(TEST_SERVICE_IN_SAME_PKG_COMPONENT_NAME);

            context.bindServiceAsUser(
                    bindIntent, new ContextCrossProfileTestConnection(), Context.BIND_AUTO_CREATE,
                    otherUserHandle);

            fail(""Should throw a Security Exception"");
        } catch (SecurityException ignored) {
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/content/test-apps/ContextCrossProfileApps/ContextCrossProfileApp/src/com/android/cts/context/ContextCrossProfileDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.context.ContextCrossProfileDeviceTest"	"testBindServiceAsUser_differentProfileGroup_withInteractAcrossProfilesAppOp_throwsException"	""	"1: permission"	"([4:/com/android/cts/context/ContextCrossProfileDeviceTest.java]:[permission]:[4]:method_text:[uld throw a Security Exception"");        } catch (SecurityException ignored) {        }    }   ]) :|: 
    public void testBindServiceAsUser_differentProfileGroup_withInteractAcrossProfilesAppOp_throwsException(){
        final Context context = InstrumentationRegistry.getContext();
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        final AppOpsManager appOpsManager = context.getSystemService(AppOpsManager.class);
        uiAutomation.adoptShellPermissionIdentity(MANAGE_APP_OPS_MODE);
        appOpsManager.setMode(AppOpsManager.permissionToOp(INTERACT_ACROSS_PROFILES_PERMISSION),
                Binder.getCallingUid(), context.getPackageName(), AppOpsManager.MODE_ALLOWED);
        uiAutomation.dropShellPermissionIdentity();
        int otherUserId = getTestUser();
        UserHandle otherUserHandle = UserHandle.of(otherUserId);
        try {
            Intent bindIntent = new Intent();
            bindIntent.setComponent(TEST_SERVICE_IN_SAME_PKG_COMPONENT_NAME);

            context.bindServiceAsUser(
                    bindIntent, new ContextCrossProfileTestConnection(),
                    Context.BIND_AUTO_CREATE, otherUserHandle);

            fail(""Should throw a Security Exception"");
        } catch (SecurityException ignored) {
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/content/test-apps/ContextCrossProfileApps/ContextCrossProfileApp/src/com/android/cts/context/ContextCrossProfileDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.context.ContextCrossProfileDeviceTest"	"testBindServiceAsUser_sameProfileGroup_withNoPermissions_throwsException"	""	"1: permission"	"([1:/com/android/cts/context/ContextCrossProfileDeviceTest.java]:[permission]:[1]:method_text:[uld throw a Security Exception"");        } catch (SecurityException ignored) {        }    }   ]) :|: 
    public void testBindServiceAsUser_sameProfileGroup_withNoPermissions_throwsException() {
        final Context context = InstrumentationRegistry.getContext();
        int otherProfileId = getTestUser();
        UserHandle otherProfileHandle = UserHandle.of(otherProfileId);
        try {
            Intent bindIntent = new Intent();
            bindIntent.setComponent(TEST_SERVICE_IN_SAME_PKG_COMPONENT_NAME);

            context.bindServiceAsUser(
                    bindIntent, new ContextCrossProfileTestConnection(), Context.BIND_AUTO_CREATE,
                    otherProfileHandle);

            fail(""Should throw a Security Exception"");
        } catch (SecurityException ignored) {
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/content/test-apps/ContextCrossProfileApps/ContextCrossProfileApp/src/com/android/cts/context/ContextCrossProfileDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.context.ContextCrossProfileDeviceTest"	"testBindServiceAsUser_withInteractAcrossProfilePermission_noAsserts"	""	"1: permission"	"([7:/com/android/cts/context/ContextCrossProfileDeviceTest.java]:[permission]:[7]:method_text:[ssProfileTestConnection(),                Context.BIND_AUTO_CREATE, otherProfileHandle);    }   ]) :|: 
    public void testBindServiceAsUser_withInteractAcrossProfilePermission_noAsserts() {
        final Context context = InstrumentationRegistry.getContext();
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        final AppOpsManager appOpsManager = context.getSystemService(AppOpsManager.class);
        uiAutomation.adoptShellPermissionIdentity(MANAGE_APP_OPS_MODE);
        appOpsManager.setMode(AppOpsManager.permissionToOp(INTERACT_ACROSS_PROFILES_PERMISSION),
                Binder.getCallingUid(), context.getPackageName(), AppOpsManager.MODE_DEFAULT);
        uiAutomation.dropShellPermissionIdentity();
        int otherProfileId = getTestUser();
        UserHandle otherProfileHandle = UserHandle.of(otherProfileId);
        uiAutomation.adoptShellPermissionIdentity(INTERACT_ACROSS_PROFILES_PERMISSION);
        Intent bindIntent = new Intent();
        bindIntent.setComponent(TEST_SERVICE_IN_SAME_PKG_COMPONENT_NAME);

        context.bindServiceAsUser(
                bindIntent, new ContextCrossProfileTestConnection(),
                Context.BIND_AUTO_CREATE, otherProfileHandle);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/content/test-apps/ContextCrossProfileApps/ContextCrossProfileApp/src/com/android/cts/context/ContextCrossProfileDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.context.ContextCrossProfileDeviceTest"	"testBindServiceAsUser_withInteractAcrossUsersFullPermission_noAsserts"	""	"1: permission"	"([4:/com/android/cts/context/ContextCrossProfileDeviceTest.java]:[permission]:[4]:method_text:[ssProfileTestConnection(),                Context.BIND_AUTO_CREATE, otherProfileHandle);    }   ]) :|: 
    public void testBindServiceAsUser_withInteractAcrossUsersFullPermission_noAsserts() {
        final Context context = InstrumentationRegistry.getContext();
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        int otherProfileId = getTestUser();
        UserHandle otherProfileHandle = UserHandle.of(otherProfileId);
        uiAutomation.adoptShellPermissionIdentity(
                INTERACT_ACROSS_USERS_FULL_PERMISSION, INTERACT_ACROSS_USERS_PERMISSION);
        Intent bindIntent = new Intent();
        bindIntent.setComponent(TEST_SERVICE_IN_SAME_PKG_COMPONENT_NAME);

        context.bindServiceAsUser(
                bindIntent, new ContextCrossProfileTestConnection(),
                Context.BIND_AUTO_CREATE, otherProfileHandle);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/content/test-apps/ContextCrossProfileApps/ContextCrossProfileApp/src/com/android/cts/context/ContextCrossProfileDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.context.ContextCrossProfileDeviceTest"	"testCreateContextAsUser_sameProfileGroup_withInteractAcrossProfilesPermission_throwsException"	""	"1: permission"	"([3:/com/android/cts/context/ContextCrossProfileDeviceTest.java]:[permission]:[3]:method_text:[uld throw a Security Exception"");        } catch (SecurityException ignored) {        }    }   ]) :|: 
    public void testCreateContextAsUser_sameProfileGroup_withInteractAcrossProfilesPermission_throwsException() {
        final Context context = InstrumentationRegistry.getContext();
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        int otherProfileId = getTestUser();
        UserHandle otherProfileHandle = UserHandle.of(otherProfileId);
        uiAutomation.adoptShellPermissionIdentity(INTERACT_ACROSS_PROFILES_PERMISSION);

        try {
            context.createContextAsUser(otherProfileHandle, /*flags= */0);

            fail(""Should throw a Security Exception"");
        } catch (SecurityException ignored) {
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/content/test-apps/ContextCrossProfileApps/ContextCrossProfileApp/src/com/android/cts/context/ContextCrossProfileDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.context.ContextCrossProfileDeviceTest"	"testCreateContextAsUser_sameProfileGroup_withInteractAcrossUsersPermission_createsContext"	""	"1: permission"	"([3:/com/android/cts/context/ContextCrossProfileDeviceTest.java]:[permission]:[3]:method_text:[flags= */0);        assertThat(otherProfileContext.getUserId()).isEqualTo(otherProfileId);    }}]) :|: 
    public void testCreateContextAsUser_sameProfileGroup_withInteractAcrossUsersPermission_createsContext() {
        final Context context = InstrumentationRegistry.getContext();
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        int otherProfileId = getTestUser();
        UserHandle otherProfileHandle = UserHandle.of(otherProfileId);
        uiAutomation.adoptShellPermissionIdentity(INTERACT_ACROSS_USERS_PERMISSION);

        Context otherProfileContext = context.createContextAsUser(
                otherProfileHandle, /*flags= */0);

        assertThat(otherProfileContext.getUserId()).isEqualTo(otherProfileId);
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/content/test-apps/ContextCrossProfileApps/ContextCrossProfileApp/src/com/android/cts/context/ContextCrossProfileDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextCrossProfileHostTest"	"testCreateContextAsUser_sameProfileGroup_withInteractAcrossUsersPermission_createsContext"	"CtsSyncContentHostTestCases"	"4: android.software.managed android.software.managed_users managed_users permission"	"([6:/android/content/cts/ContextCrossProfileHostTest.java]:[permission]:[6]:method_text:[ers"");        } catch (DeviceNotAvailableException e) {            return false;        }    }}]) :|: 
    public void testCreateContextAsUser_sameProfileGroup_withInteractAcrossUsersPermission_createsContext()
            throws Exception {
        assumeTrue(supportsManagedUsers());
        int userInSameProfileGroup = createProfile(mParentUserId);
        getDevice().startUser(userInSameProfileGroup, /* waitFlag= */true);
        mTestArgs.put(""testUser"", Integer.toString(userInSameProfileGroup));
        getDevice().installPackageForUser(
                mApkFile, /* reinstall= */true, /* grantPermissions= */true,
                userInSameProfileGroup, /* extraArgs= */""-t"", /* extraArgs= */""--force-queryable"");

        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);
        File testServiceApkFile = buildHelper.getTestFile(TEST_SERVICE_WITH_PERMISSION_APK);
        getDevice().installPackageForUser(
                testServiceApkFile, /* reinstall= */true, /* grantPermissions= */true,
                userInSameProfileGroup, /* extraArgs= */""-t"", /* extraArgs= */""--force-queryable"");

        runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".ContextCrossProfileDeviceTest"",
                ""testCreateContextAsUser_sameProfileGroup_withInteractAcrossUsersPermission_createsContext"",
                mParentUserId,
                mTestArgs,
                /* timeout= */60L,
                TimeUnit.SECONDS);
    }

    boolean supportsManagedUsers() {
        try {
            return getDevice().hasFeature(""feature:android.software.managed_users"");
        } catch (DeviceNotAvailableException e) {
            return false;
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/content/src/android/content/cts/ContextCrossProfileHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextCrossProfileHostTest"	"testBindServiceAsUser_differentUser_bindsServiceToCorrectUser"	"CtsSyncContentHostTestCases"	"1: permission"	"([4:/android/content/cts/ContextCrossProfileHostTest.java]:[permission]:[4]:method_text:[         mTestArgs,                /* timeout= */60L,                TimeUnit.SECONDS);    }   ]) :|: 
    public void testBindServiceAsUser_differentUser_bindsServiceToCorrectUser()
            throws Exception {
        assumeTrue(supportsManagedUsers());
        int userInSameProfileGroup = createProfile(mParentUserId);
        getDevice().startUser(userInSameProfileGroup, /* waitFlag= */true);
        mTestArgs.put(""testUser"", Integer.toString(userInSameProfileGroup));
        getDevice().installPackageForUser(
                mApkFile, /* reinstall= */true, /* grantPermissions= */true,
                userInSameProfileGroup, /* extraArgs= */""-t"", /* extraArgs= */""--force-queryable"");

        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);
        File testServiceApkFile = buildHelper.getTestFile(TEST_SERVICE_WITH_PERMISSION_APK);
        getDevice().installPackageForUser(
                testServiceApkFile, /* reinstall= */true, /* grantPermissions= */true,
                userInSameProfileGroup, /* extraArgs= */""-t"", /* extraArgs= */""--force-queryable"");

        runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".ContextCrossProfileDeviceTest"",
                ""testBindServiceAsUser_differentUser_bindsServiceToCorrectUser"",
                mParentUserId,
                mTestArgs,
                /* timeout= */60L,
                TimeUnit.SECONDS);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/content/src/android/content/cts/ContextCrossProfileHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextCrossProfileHostTest"	"testBindServiceAsUser_sameProfileGroup_samePackage_withAcrossUsersPermission_bindsService"	"CtsSyncContentHostTestCases"	"1: permission"	"([6:/android/content/cts/ContextCrossProfileHostTest.java]:[permission]:[6]:method_text:[         mTestArgs,                /* timeout= */60L,                TimeUnit.SECONDS);    }   ]) :|: 
    public void testBindServiceAsUser_sameProfileGroup_samePackage_withAcrossUsersPermission_bindsService()
            throws Exception {
        assumeTrue(supportsManagedUsers());
        int userInSameProfileGroup = createProfile(mParentUserId);
        getDevice().startUser(userInSameProfileGroup, /* waitFlag= */true);
        mTestArgs.put(""testUser"", Integer.toString(userInSameProfileGroup));
        getDevice().installPackageForUser(
                mApkFile, /* reinstall= */true, /* grantPermissions= */true,
                userInSameProfileGroup, /* extraArgs= */""-t"", /* extraArgs= */""--force-queryable"");

        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);
        File testServiceApkFile = buildHelper.getTestFile(TEST_SERVICE_WITH_PERMISSION_APK);
        getDevice().installPackageForUser(
                testServiceApkFile, /* reinstall= */true, /* grantPermissions= */true,
                userInSameProfileGroup, /* extraArgs= */""-t"", /* extraArgs= */""--force-queryable"");

        runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".ContextCrossProfileDeviceTest"",
                ""testBindServiceAsUser_sameProfileGroup_samePackage_withAcrossUsersPermission_bindsService"",
                mParentUserId,
                mTestArgs,
                /* timeout= */60L,
                TimeUnit.SECONDS);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/content/src/android/content/cts/ContextCrossProfileHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextCrossProfileHostTest"	"testBindServiceAsUser_sameProfileGroup_differentPackage_withAcrossUsersPermission_bindsService"	"CtsSyncContentHostTestCases"	"1: permission"	"([6:/android/content/cts/ContextCrossProfileHostTest.java]:[permission]:[6]:method_text:[         mTestArgs,                /* timeout= */60L,                TimeUnit.SECONDS);    }   ]) :|: 
    public void testBindServiceAsUser_sameProfileGroup_differentPackage_withAcrossUsersPermission_bindsService()
            throws Exception {
        assumeTrue(supportsManagedUsers());
        int userInSameProfileGroup = createProfile(mParentUserId);
        getDevice().startUser(userInSameProfileGroup, /* waitFlag= */true);
        mTestArgs.put(""testUser"", Integer.toString(userInSameProfileGroup));
        getDevice().installPackageForUser(
                mApkFile, /* reinstall= */true, /* grantPermissions= */true,
                userInSameProfileGroup, /* extraArgs= */""-t"", /* extraArgs= */""--force-queryable"");

        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);
        File testServiceApkFile = buildHelper.getTestFile(TEST_SERVICE_WITH_PERMISSION_APK);
        getDevice().installPackageForUser(
                testServiceApkFile, /* reinstall= */true, /* grantPermissions= */true,
                userInSameProfileGroup, /* extraArgs= */""-t"", /* extraArgs= */""--force-queryable"");

        runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".ContextCrossProfileDeviceTest"",
                ""testBindServiceAsUser_sameProfileGroup_differentPackage_withAcrossUsersPermission_bindsService"",
                mParentUserId,
                mTestArgs,
                /* timeout= */60L,
                TimeUnit.SECONDS);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/content/src/android/content/cts/ContextCrossProfileHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextCrossProfileHostTest"	"testBindServiceAsUser_sameProfileGroup_samePackage_withAcrossProfilesPermission_bindsService"	"CtsSyncContentHostTestCases"	"1: permission"	"([6:/android/content/cts/ContextCrossProfileHostTest.java]:[permission]:[6]:method_text:[         mTestArgs,                /* timeout= */60L,                TimeUnit.SECONDS);    }   ]) :|: 
    public void testBindServiceAsUser_sameProfileGroup_samePackage_withAcrossProfilesPermission_bindsService()
            throws Exception {
        assumeTrue(supportsManagedUsers());
        int userInSameProfileGroup = createProfile(mParentUserId);
        getDevice().startUser(userInSameProfileGroup, /* waitFlag= */true);
        mTestArgs.put(""testUser"", Integer.toString(userInSameProfileGroup));
        getDevice().installPackageForUser(
                mApkFile, /* reinstall= */true, /* grantPermissions= */true,
                userInSameProfileGroup, /* extraArgs= */""-t"", /* extraArgs= */""--force-queryable"");

        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);
        File testServiceApkFile = buildHelper.getTestFile(TEST_SERVICE_WITH_PERMISSION_APK);
        getDevice().installPackageForUser(
                testServiceApkFile, /* reinstall= */true, /* grantPermissions= */true,
                userInSameProfileGroup, /* extraArgs= */""-t"", /* extraArgs= */""--force-queryable"");

        runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".ContextCrossProfileDeviceTest"",
                ""testBindServiceAsUser_sameProfileGroup_samePackage_withAcrossProfilesPermission_bindsService"",
                mParentUserId,
                mTestArgs,
                /* timeout= */60L,
                TimeUnit.SECONDS);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/content/src/android/content/cts/ContextCrossProfileHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextCrossProfileHostTest"	"testBindServiceAsUser_sameProfileGroup_differentPackage_withAcrossProfilesPermission_throwsException"	"CtsSyncContentHostTestCases"	"1: permission"	"([6:/android/content/cts/ContextCrossProfileHostTest.java]:[permission]:[6]:method_text:[         mTestArgs,                /* timeout= */60L,                TimeUnit.SECONDS);    }   ]) :|: 
    public void testBindServiceAsUser_sameProfileGroup_differentPackage_withAcrossProfilesPermission_throwsException()
            throws Exception {
        assumeTrue(supportsManagedUsers());
        int userInSameProfileGroup = createProfile(mParentUserId);
        getDevice().startUser(userInSameProfileGroup, /* waitFlag= */true);
        mTestArgs.put(""testUser"", Integer.toString(userInSameProfileGroup));
        getDevice().installPackageForUser(
                mApkFile, /* reinstall= */true, /* grantPermissions= */true,
                userInSameProfileGroup, /* extraArgs= */""-t"", /* extraArgs= */""--force-queryable"");

        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);
        File testServiceApkFile = buildHelper.getTestFile(TEST_SERVICE_WITH_PERMISSION_APK);
        getDevice().installPackageForUser(
                testServiceApkFile, /* reinstall= */true, /* grantPermissions= */true,
                userInSameProfileGroup, /* extraArgs= */""-t"", /* extraArgs= */""--force-queryable"");

        runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".ContextCrossProfileDeviceTest"",
                ""testBindServiceAsUser_sameProfileGroup_differentPackage_withAcrossProfilesPermission_throwsException"",
                mParentUserId,
                mTestArgs,
                /* timeout= */60L,
                TimeUnit.SECONDS);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/content/src/android/content/cts/ContextCrossProfileHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextCrossProfileHostTest"	"testBindServiceAsUser_sameProfileGroup_samePackage_withAcrossProfilesAppOp_bindsService"	"CtsSyncContentHostTestCases"	"1: permission"	"([4:/android/content/cts/ContextCrossProfileHostTest.java]:[permission]:[4]:method_text:[         mTestArgs,                /* timeout= */60L,                TimeUnit.SECONDS);    }   ]) :|: 
    public void testBindServiceAsUser_sameProfileGroup_samePackage_withAcrossProfilesAppOp_bindsService()
            throws Exception {
        assumeTrue(supportsManagedUsers());
        int userInSameProfileGroup = createProfile(mParentUserId);
        getDevice().startUser(userInSameProfileGroup, /* waitFlag= */true);
        mTestArgs.put(""testUser"", Integer.toString(userInSameProfileGroup));
        getDevice().installPackageForUser(
                mApkFile, /* reinstall= */true, /* grantPermissions= */true,
                userInSameProfileGroup, /* extraArgs= */""-t"", /* extraArgs= */""--force-queryable"");

        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);
        File testServiceApkFile = buildHelper.getTestFile(TEST_SERVICE_WITH_PERMISSION_APK);
        getDevice().installPackageForUser(
                testServiceApkFile, /* reinstall= */true, /* grantPermissions= */true,
                userInSameProfileGroup, /* extraArgs= */""-t"", /* extraArgs= */""--force-queryable"");

        runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".ContextCrossProfileDeviceTest"",
                ""testBindServiceAsUser_sameProfileGroup_samePackage_withAcrossProfilesAppOp_bindsService"",
                mParentUserId,
                mTestArgs,
                /* timeout= */60L,
                TimeUnit.SECONDS);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/content/src/android/content/cts/ContextCrossProfileHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextCrossProfileHostTest"	"testBindServiceAsUser_sameProfileGroup_differentPackage_withAcrossProfilesAppOp_throwsException"	"CtsSyncContentHostTestCases"	"1: permission"	"([4:/android/content/cts/ContextCrossProfileHostTest.java]:[permission]:[4]:method_text:[         mTestArgs,                /* timeout= */60L,                TimeUnit.SECONDS);    }   ]) :|: 
    public void testBindServiceAsUser_sameProfileGroup_differentPackage_withAcrossProfilesAppOp_throwsException()
            throws Exception {
        assumeTrue(supportsManagedUsers());
        int userInSameProfileGroup = createProfile(mParentUserId);
        getDevice().startUser(userInSameProfileGroup, /* waitFlag= */true);
        mTestArgs.put(""testUser"", Integer.toString(userInSameProfileGroup));
        getDevice().installPackageForUser(
                mApkFile, /* reinstall= */true, /* grantPermissions= */true,
                userInSameProfileGroup, /* extraArgs= */""-t"", /* extraArgs= */""--force-queryable"");

        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);
        File testServiceApkFile = buildHelper.getTestFile(TEST_SERVICE_WITH_PERMISSION_APK);
        getDevice().installPackageForUser(
                testServiceApkFile, /* reinstall= */true, /* grantPermissions= */true,
                userInSameProfileGroup, /* extraArgs= */""-t"", /* extraArgs= */""--force-queryable"");

        runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".ContextCrossProfileDeviceTest"",
                ""testBindServiceAsUser_sameProfileGroup_differentPackage_withAcrossProfilesAppOp_throwsException"",
                mParentUserId,
                mTestArgs,
                /* timeout= */60L,
                TimeUnit.SECONDS);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/content/src/android/content/cts/ContextCrossProfileHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextCrossProfileHostTest"	"testBindServiceAsUser_differentProfileGroup_withInteractAcrossUsersPermission_throwsException"	"CtsSyncContentHostTestCases"	"1: permission"	"([6:/android/content/cts/ContextCrossProfileHostTest.java]:[permission]:[6]:method_text:[         mTestArgs,                /* timeout= */60L,                TimeUnit.SECONDS);    }   ]) :|: 
    public void testBindServiceAsUser_differentProfileGroup_withInteractAcrossUsersPermission_throwsException()
            throws Exception {
        int userInDifferentProfileGroup = createUser();
        getDevice().startUser(userInDifferentProfileGroup, /* waitFlag= */true);
        mTestArgs.put(""testUser"", Integer.toString(userInDifferentProfileGroup));
        getDevice().installPackageForUser(
                mApkFile, /* reinstall= */true, /* grantPermissions= */true,
                userInDifferentProfileGroup, /* extraArgs= */""-t"",
                /* extraArgs= */""--force-queryable"");

        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);
        File testServiceApkFile = buildHelper.getTestFile(TEST_SERVICE_WITH_PERMISSION_APK);
        getDevice().installPackageForUser(
                testServiceApkFile, /* reinstall= */true, /* grantPermissions= */true,
                userInDifferentProfileGroup, /* extraArgs= */""-t"",
                /* extraArgs= */""--force-queryable"");

        runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".ContextCrossProfileDeviceTest"",
                ""testBindServiceAsUser_differentProfileGroup_withInteractAcrossUsersPermission_throwsException"",
                mParentUserId,
                mTestArgs,
                /* timeout= */60L,
                TimeUnit.SECONDS);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/content/src/android/content/cts/ContextCrossProfileHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextCrossProfileHostTest"	"testBindServiceAsUser_differentProfileGroup_withInteractAcrossProfilesAppOp_throwsException"	"CtsSyncContentHostTestCases"	"1: permission"	"([4:/android/content/cts/ContextCrossProfileHostTest.java]:[permission]:[4]:method_text:[         mTestArgs,                /* timeout= */60L,                TimeUnit.SECONDS);    }   ]) :|: 
    public void testBindServiceAsUser_differentProfileGroup_withInteractAcrossProfilesAppOp_throwsException()
            throws Exception {
        int userInDifferentProfileGroup = createUser();
        getDevice().startUser(userInDifferentProfileGroup, /* waitFlag= */true);
        mTestArgs.put(""testUser"", Integer.toString(userInDifferentProfileGroup));
        getDevice().installPackageForUser(
                mApkFile, /* reinstall= */true, /* grantPermissions= */true,
                userInDifferentProfileGroup, /* extraArgs= */""-t"",
                /* extraArgs= */""--force-queryable"");

        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);
        File testServiceApkFile = buildHelper.getTestFile(TEST_SERVICE_WITH_PERMISSION_APK);
        getDevice().installPackageForUser(
                testServiceApkFile, /* reinstall= */true, /* grantPermissions= */true,
                userInDifferentProfileGroup, /* extraArgs= */""-t"",
                /* extraArgs= */""--force-queryable"");

        runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".ContextCrossProfileDeviceTest"",
                ""testBindServiceAsUser_differentProfileGroup_withInteractAcrossProfilesAppOp_throwsException"",
                mParentUserId,
                mTestArgs,
                /* timeout= */60L,
                TimeUnit.SECONDS);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/content/src/android/content/cts/ContextCrossProfileHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextCrossProfileHostTest"	"testBindServiceAsUser_differentProfileGroup_withInteractAcrossProfilesPermission_throwsException"	"CtsSyncContentHostTestCases"	"1: permission"	"([6:/android/content/cts/ContextCrossProfileHostTest.java]:[permission]:[6]:method_text:[         mTestArgs,                /* timeout= */60L,                TimeUnit.SECONDS);    }   ]) :|: 
    public void testBindServiceAsUser_differentProfileGroup_withInteractAcrossProfilesPermission_throwsException()
            throws Exception {
        int userInDifferentProfileGroup = createUser();
        getDevice().startUser(userInDifferentProfileGroup, /* waitFlag= */true);
        mTestArgs.put(""testUser"", Integer.toString(userInDifferentProfileGroup));
        getDevice().installPackageForUser(
                mApkFile, /* reinstall= */true, /* grantPermissions= */true,
                userInDifferentProfileGroup, /* extraArgs= */""-t"",
                /* extraArgs= */""--force-queryable"");

        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);
        File testServiceApkFile = buildHelper.getTestFile(TEST_SERVICE_WITH_PERMISSION_APK);
        getDevice().installPackageForUser(
                testServiceApkFile, /* reinstall= */true, /* grantPermissions= */true,
                userInDifferentProfileGroup, /* extraArgs= */""-t"",
                /* extraArgs= */""--force-queryable"");

        runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".ContextCrossProfileDeviceTest"",
                ""testBindServiceAsUser_differentProfileGroup_withInteractAcrossProfilesPermission_throwsException"",
                mParentUserId,
                mTestArgs,
                /* timeout= */60L,
                TimeUnit.SECONDS);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/content/src/android/content/cts/ContextCrossProfileHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextCrossProfileHostTest"	"testBindServiceAsUser_sameProfileGroup_withNoPermissions_throwsException"	"CtsSyncContentHostTestCases"	"1: permission"	"([6:/android/content/cts/ContextCrossProfileHostTest.java]:[permission]:[6]:method_text:[         mTestArgs,                /* timeout= */60L,                TimeUnit.SECONDS);    }   ]) :|: 
    public void testBindServiceAsUser_sameProfileGroup_withNoPermissions_throwsException()
            throws Exception {
        assumeTrue(supportsManagedUsers());
        int userInSameProfileGroup = createProfile(mParentUserId);
        getDevice().startUser(userInSameProfileGroup, /* waitFlag= */true);
        mTestArgs.put(""testUser"", Integer.toString(userInSameProfileGroup));
        getDevice().installPackageForUser(
                mApkFile, /* reinstall= */true, /* grantPermissions= */true,
                userInSameProfileGroup, /* extraArgs= */""-t"", /* extraArgs= */""--force-queryable"");

        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);
        File testServiceApkFile = buildHelper.getTestFile(TEST_SERVICE_WITH_PERMISSION_APK);
        getDevice().installPackageForUser(
                testServiceApkFile, /* reinstall= */true, /* grantPermissions= */true,
                userInSameProfileGroup, /* extraArgs= */""-t"", /* extraArgs= */""--force-queryable"");

        runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".ContextCrossProfileDeviceTest"",
                ""testBindServiceAsUser_sameProfileGroup_withNoPermissions_throwsException"",
                mParentUserId,
                mTestArgs,
                /* timeout= */60L,
                TimeUnit.SECONDS);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/content/src/android/content/cts/ContextCrossProfileHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextCrossProfileHostTest"	"testBindServiceAsUser_sameProfileGroup_reportsMetric"	"CtsSyncContentHostTestCases"	"1: permission"	"([6:/android/content/cts/ContextCrossProfileHostTest.java]:[permission]:[6]:method_text:[E_VALUE)                .setStrings(TEST_WITH_PERMISSION_PKG)                .build());    }   ]) :|: 
    public void testBindServiceAsUser_sameProfileGroup_reportsMetric()
            throws Exception {
        assumeTrue(supportsManagedUsers());
        int userInSameProfileGroup = createProfile(mParentUserId);
        getDevice().startUser(userInSameProfileGroup, /* waitFlag= */ true);
        mTestArgs.put(""testUser"", Integer.toString(userInSameProfileGroup));
        getDevice().installPackageForUser(
                mApkFile,
                /* reinstall= */ true,
                /* grantPermissions= */ true,
                userInSameProfileGroup,
                /* extraArgs= */ ""-t"",
                /* extraArgs= */ ""--force-queryable"");

        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);
        File testServiceApkFile = buildHelper.getTestFile(TEST_SERVICE_WITH_PERMISSION_APK);
        getDevice().installPackageForUser(
                testServiceApkFile,
                /* reinstall= */ true,
                /* grantPermissions= */ true,
                userInSameProfileGroup,
                /* extraArgs= */ ""-t"",
                /* extraArgs= */ ""--force-queryable"");

        assertMetricsLogged(getDevice(), () -> {
            runDeviceTests(
                    getDevice(),
                    TEST_WITH_PERMISSION_PKG,
                    "".ContextCrossProfileDeviceTest"",
                    ""testBindServiceAsUser_withInteractAcrossProfilePermission_noAsserts"",
                    mParentUserId,
                    mTestArgs,
                    /* timeout= */ 60L,
                    TimeUnit.SECONDS);
        }, new DevicePolicyEventWrapper.Builder(EventId.BIND_CROSS_PROFILE_SERVICE_VALUE)
                .setStrings(TEST_WITH_PERMISSION_PKG)
                .build());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/content/src/android/content/cts/ContextCrossProfileHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextCrossProfileHostTest"	"testBindServiceAsUser_differentProfileGroup_doesNotReportMetric"	"CtsSyncContentHostTestCases"	"1: permission"	"([6:/android/content/cts/ContextCrossProfileHostTest.java]:[permission]:[6]:method_text:[E_VALUE)                .setStrings(TEST_WITH_PERMISSION_PKG)                .build());    }   ]) :|: 
    public void testBindServiceAsUser_differentProfileGroup_doesNotReportMetric()
            throws Exception {
        int userInDifferentProfileGroup = createUser();
        getDevice().startUser(userInDifferentProfileGroup, /* waitFlag= */ true);
        mTestArgs.put(""testUser"", Integer.toString(userInDifferentProfileGroup));
        getDevice().installPackageForUser(
                mApkFile, /* reinstall= */ true, /* grantPermissions= */ true,
                userInDifferentProfileGroup, /* extraArgs= */ ""-t"",
                /* extraArgs= */ ""--force-queryable"");

        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);
        File testServiceApkFile = buildHelper.getTestFile(TEST_SERVICE_WITH_PERMISSION_APK);
        getDevice().installPackageForUser(
                testServiceApkFile,
                /* reinstall= */ true,
                /* grantPermissions= */ true,
                userInDifferentProfileGroup,
                /* extraArgs= */ ""-t"",
                /* extraArgs= */ ""--force-queryable"");

        assertMetricsNotLogged(getDevice(), () -> {
            runDeviceTests(
                    getDevice(),
                    TEST_WITH_PERMISSION_PKG,
                    "".ContextCrossProfileDeviceTest"",
                    ""testBindServiceAsUser_withInteractAcrossUsersFullPermission_noAsserts"",
                    mParentUserId,
                    mTestArgs,
                    /* timeout= */ 60L,
                    TimeUnit.SECONDS);
        }, new DevicePolicyEventWrapper.Builder(EventId.BIND_CROSS_PROFILE_SERVICE_VALUE)
                .setStrings(TEST_WITH_PERMISSION_PKG)
                .build());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/content/src/android/content/cts/ContextCrossProfileHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextCrossProfileHostTest"	"testBindServiceAsUser_sameUser_doesNotReportMetric"	"CtsSyncContentHostTestCases"	"1: permission"	"([3:/android/content/cts/ContextCrossProfileHostTest.java]:[permission]:[3]:method_text:[E_VALUE)                .setStrings(TEST_WITH_PERMISSION_PKG)                .build());    }   ]) :|: 
    public void testBindServiceAsUser_sameUser_doesNotReportMetric()
            throws Exception {
        mTestArgs.put(""testUser"", Integer.toString(mParentUserId));

        assertMetricsNotLogged(getDevice(), () -> {
            runDeviceTests(
                    getDevice(),
                    TEST_WITH_PERMISSION_PKG,
                    "".ContextCrossProfileDeviceTest"",
                    ""testBindServiceAsUser_withInteractAcrossProfilePermission_noAsserts"",
                    mParentUserId,
                    mTestArgs,
                    /* timeout= */ 60L,
                    TimeUnit.SECONDS);
        }, new DevicePolicyEventWrapper.Builder(EventId.BIND_CROSS_PROFILE_SERVICE_VALUE)
                .setStrings(TEST_WITH_PERMISSION_PKG)
                .build());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/content/src/android/content/cts/ContextCrossProfileHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextCrossProfileHostTest"	"testCreateContextAsUser_sameProfileGroup_withInteractAcrossProfilesPermission_throwsException"	"CtsSyncContentHostTestCases"	"1: permission"	"([6:/android/content/cts/ContextCrossProfileHostTest.java]:[permission]:[6]:method_text:[         mTestArgs,                /* timeout= */60L,                TimeUnit.SECONDS);    }   ]) :|: 
    public void testCreateContextAsUser_sameProfileGroup_withInteractAcrossProfilesPermission_throwsException()
            throws Exception {
        assumeTrue(supportsManagedUsers());
        int userInSameProfileGroup = createProfile(mParentUserId);
        getDevice().startUser(userInSameProfileGroup, /* waitFlag= */true);
        mTestArgs.put(""testUser"", Integer.toString(userInSameProfileGroup));
        getDevice().installPackageForUser(
                mApkFile, /* reinstall= */true, /* grantPermissions= */true,
                userInSameProfileGroup, /* extraArgs= */""-t"", /* extraArgs= */""--force-queryable"");

        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);
        File testServiceApkFile = buildHelper.getTestFile(TEST_SERVICE_WITH_PERMISSION_APK);
        getDevice().installPackageForUser(
                testServiceApkFile, /* reinstall= */true, /* grantPermissions= */true,
                userInSameProfileGroup, /* extraArgs= */""-t"", /* extraArgs= */""--force-queryable"");

        runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".ContextCrossProfileDeviceTest"",
                ""testCreateContextAsUser_sameProfileGroup_withInteractAcrossProfilesPermission_throwsException"",
                mParentUserId,
                mTestArgs,
                /* timeout= */60L,
                TimeUnit.SECONDS);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/content/src/android/content/cts/ContextCrossProfileHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.cts.backup.preservedsettingsapp.PreservedSettingsRestoreTest"	"adoptShellPermissionIdentity"	""	"1: permission"	"([2:/android/cts/backup/preservedsettingsapp/PreservedSettingsRestoreTest.java]:[permission]:[2]:method_text:[ @After    public void tearDown() {        mUiAutomation.dropShellPermissionIdentity();    }   ]) :|: /*
 *
 */

package android.cts.backup.preservedsettingsapp;

import static androidx.test.InstrumentationRegistry.getInstrumentation;

import static com.google.common.truth.Truth.assertThat;

import android.app.UiAutomation;
import android.content.ContentResolver;
import android.content.Context;
import android.content.SharedPreferences;
import android.platform.test.annotations.AppModeFull;
import android.provider.Settings;
import android.util.FeatureFlagUtils;

import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.SystemUtil;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.File;

/**
 * Device side routines to be invoked by the host side PreservedSettingsRestoreHostSideTest. These
 * are not designed to be called in any other way, as they rely on state set up by the host side
 * test.
 */
@AppModeFull
@RunWith(AndroidJUnit4.class)
public class PreservedSettingsRestoreTest {
    private static final String SHARED_PREFS_NAME = ""preserve_settings_restore_test_prefs"";
    private static final String OVERRIDEABLE_SETTING =
            Settings.Secure.ACCESSIBILITY_CAPTIONING_WINDOW_COLOR;
    private static final String NON_OVERRIDEABLE_SETTING =
            Settings.Secure.ACCESSIBILITY_CAPTIONING_FONT_SCALE;
    private static final String OVERRIDEABLE_SETTING_OLD_VALUE = ""121"";
    private static final String NON_OVERRIDEABLE_SETTING_OLD_VALUE = ""0.6"";
    private static final String OVERRIDEABLE_SETTING_NEW_VALUE = ""123"";
    private static final String NON_OVERRIDEABLE_SETTING_NEW_VALUE = ""0.7"";
    private static final String DEFAULT_SETTING_VALUE = """";

    private Context mContext;
    private ContentResolver mContentResolver;
    private File mSharedPreferencesFile;
    private SharedPreferences mSharedPreferences;
    private UiAutomation mUiAutomation;

    @Before
    public void setUp() throws Exception {
        mContext = getInstrumentation().getTarg"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/backup/PreservedSettingsApp/src/android/cts/backup/preservedsettingsapp/PreservedSettingsRestoreTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.cts.backup.othersoundssettingsapp.OtherSoundsSettingsTest"	"adoptShellPermissionIdentity"	""	"1: permission"	"([2:/android/cts/backup/othersoundssettingsapp/OtherSoundsSettingsTest.java]:[permission]:[2]:method_text:[Restore Settings.     * 5. Check restored Dial pad tones is the same with backup value.     */   ]) :|: /*
 *.
 */

package android.cts.backup.othersoundssettingsapp;

import static androidx.test.InstrumentationRegistry.getInstrumentation;

import static com.android.compatibility.common.util.BackupUtils.LOCAL_TRANSPORT_TOKEN;

import static org.junit.Assert.assertTrue;
import static org.junit.Assume.assumeTrue;

import android.app.UiAutomation;
import android.content.ContentResolver;
import android.content.Context;
import android.os.ParcelFileDescriptor;
import android.os.Vibrator;
import android.platform.test.annotations.AppModeFull;
import android.provider.Settings;

import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.BackupUtils;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;

/**
 * Device side routines to be invoked by the host side OtherSoundsSettingsHostSideTest. These
 * are not designed to be called in any other way, as they rely on state set up by the host side
 * test.
 */
@RunWith(AndroidJUnit4.class)
@AppModeFull
public class OtherSoundsSettingsTest {
    /** The name of the package for backup */
    private static final String SETTINGS_PACKAGE_NAME = ""com.android.providers.settings"";
    private static final int SETTING_ABSENT_VALUE = -1;

    private ContentResolver mContentResolver;
    private BackupUtils mBackupUtils;
    private Map<String, Integer> mOriginalSettingValues;
    private UiAutomation mUiAutomation;

    @Before
    public void setUp() throws Exception {
        mContentResolver = getInstrumentation().getTargetContext().getContentResolver();
        mBackupUtils =
                new BackupUtils() {
                    @Override
                    protected InputStream executeShellCommand(String command) throws IOException {
                        ParcelFileDescriptor pfd =
                                getInstrumentation().getUiAutoma"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/backup/OtherSoundsSettingsApp/src/android/cts/backup/othersoundssettingsapp/OtherSoundsSettingsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.cts.backup.profileserialnumberapp.ProfileSerialNumberTest"	"testSetAndGetAncestralSerialNumber"	""	"1: permission"	"([1:/android/cts/backup/profileserialnumberapp/ProfileSerialNumberTest.java]:[permission]:[1]:method_text:[e(),                mBackupManager.getUserForAncestralSerialNumber(USER_SERIAL_NUMBER));    }   ]) :|: 
    public void testSetAndGetAncestralSerialNumber() {
        SystemUtil.runWithShellPermissionIdentity(() -> {
            mBackupManager.setAncestralSerialNumber(USER_SERIAL_NUMBER);
        });

        assertEquals(Binder.getCallingUserHandle(),
                mBackupManager.getUserForAncestralSerialNumber(USER_SERIAL_NUMBER));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/backup/ProfileSerialNumberApp/src/android/cts/backup/profileserialnumberapp/ProfileSerialNumberTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.cts.backup.restoresessionapp.RestoreSessionTest"	"adoptShellPermissionIdentity"	""	"1: permission"	"([2:/android/cts/backup/restoresessionapp/RestoreSessionTest.java]:[permission]:[2]:method_text:[ are restored. Use     * {@link RestoreSession#restorePackage(String, RestoreObserver)}     */   ]) :|: /*
 *.
 */

package android.cts.backup.restoresessionapp;

import static androidx.test.InstrumentationRegistry.getTargetContext;
import static androidx.test.InstrumentationRegistry.getInstrumentation;

import static junit.framework.Assert.assertEquals;
import static junit.framework.Assert.assertTrue;

import static org.junit.Assert.assertNotEquals;

import android.app.UiAutomation;
import android.app.backup.BackupManager;
import android.app.backup.BackupManagerMonitor;
import android.app.backup.RestoreObserver;
import android.app.backup.RestoreSession;
import android.app.backup.RestoreSet;
import android.content.Context;
import android.os.Bundle;

import androidx.annotation.Nullable;
import android.platform.test.annotations.AppModeFull;
import androidx.test.runner.AndroidJUnit4;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * Device side routines to be invoked by the host side RestoreSessionHostSideTest. These are not
 * designed to be called in any other way, as they rely on state set up by the host side test.
 */
@RunWith(AndroidJUnit4.class)
@AppModeFull
public class RestoreSessionTest {
    private static final String[] PACKAGES = new String[] {
        ""android.cts.backup.restoresessionapp1"",
        ""android.cts.backup.restoresessionapp2"",
    };

    private static final int PACKAGES_COUNT = 2;
    private static final int RESTORE_TIMEOUT_SECONDS = 10;

    private BackupManager mBackupManager;
    private Set<String> mRestorePackages;
    private Set<String> mNonRestorePackages;
    private CountDownLatch mRestoreSetsLatch;
    private CountDownLatch mRestoreObserverLatch;
    private RestoreSession mRestoreSession;
    private UiAutomation mUiAutomation;
    private long mRestoreToken;

    private final RestoreObserver mRestoreObserver =
            new RestoreOb"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/backup/RestoreSessionTest/src/android/cts/backup/restoresessionapp/RestoreSessionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.cts.backup.autorestoreapp.AutoRestoreTest"	"disableAutoRestore"	""	"1: permission"	"([1:/android/cts/backup/autorestoreapp/AutoRestoreTest.java]:[permission]:[1]:method_text:[     () -> {                    mBackupManager.setAutoRestore(enabled);                });    }}]) :|: 
    public void disableAutoRestore() {
        setAutoRestoreEnabled(false);
    }

    private void setAutoRestoreEnabled(boolean enabled) {
        SystemUtil.runWithShellPermissionIdentity(
                () -> {
                    mBackupManager.setAutoRestore(enabled);
                });
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/backup/AutoRestoreApp/src/android/cts/backup/autorestoreapp/AutoRestoreTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.tests.stagedinstall.host.StagedInstallTest"	"testFailInstallIfNoPermission"	""	"1: permission"	"([2:/com/android/tests/stagedinstall/host/StagedInstallTest.java]:[permission]:[2]:method_text:[allIfNoPermission() throws Exception {        runPhase(""testFailInstallIfNoPermission"");    }   ]) :|: 
    public void testFailInstallIfNoPermission() throws Exception {
        runPhase(""testFailInstallIfNoPermission"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/stagedinstall/src/com/android/tests/stagedinstall/host/StagedInstallTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.tests.stagedinstall.ApexShimValidationTest"	"adoptShellPermissions"	""	"1: permission"	"([6:/com/android/tests/stagedinstall/ApexShimValidationTest.java]:[permission]:[6]:method_text:[tion()                .getUiAutomation()                .dropShellPermissionIdentity();    }   ]) :|: /*
 *
 */

package com.android.tests.stagedinstall;

import static com.android.cts.shim.lib.ShimPackage.SHIM_APEX_PACKAGE_NAME;
import static com.android.tests.stagedinstall.PackageInstallerSessionInfoSubject.assertThat;

import static com.google.common.truth.Truth.assertThat;

import android.Manifest;
import android.content.Intent;
import android.content.pm.PackageInstaller;

import androidx.test.platform.app.InstrumentationRegistry;

import com.android.cts.install.lib.Install;
import com.android.cts.install.lib.InstallUtils;
import com.android.cts.install.lib.LocalIntentSender;
import com.android.cts.install.lib.TestApp;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

/**
 * These tests use a similar structure to {@link StagedInstallTest}. See
 * {@link StagedInstallTest} documentation for reference.
 *
 * @see StagedInstallTest
 */
@RunWith(JUnit4.class)
public class ApexShimValidationTest {

    @Before
    public void adoptShellPermissions() {
        InstrumentationRegistry
                .getInstrumentation()
                .getUiAutomation()
                .adoptShellPermissionIdentity(
                        Manifest.permission.INSTALL_PACKAGES,
                        Manifest.permission.DELETE_PACKAGES);
    }

    @After
    public void dropShellPermissions() {
        InstrumentationRegistry
                .getInstrumentation()
                .getUiAutomation()
                .dropShellPermissionIdentity();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/stagedinstall/app/src/com/android/tests/stagedinstall/ApexShimValidationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.tests.stagedinstall.StagedInstallTest"	"testInstallStagedApk_VerifyPostReboot"	""	"1: permission"	"([6:/com/android/tests/stagedinstall/StagedInstallTest.java]:[permission]:[6]:method_text:[  .getUiAutomation()                .dropShellPermissionIdentity();    }    // This is marked as]) :|:  public void testInstallStagedApk_VerifyPostReboot() throws Exception;
 */
@RunWith(JUnit4.class)
public class StagedInstallTest {

    private static final String TAG = ""StagedInstallTest"";

    private File mTestStateFile = new File(
            InstrumentationRegistry.getInstrumentation().getContext().getFilesDir(),
            ""ctsstagedinstall_state"");

    private static final Duration WAIT_FOR_SESSION_REMOVED_TTL = Duration.ofSeconds(10);
    private static final Duration SLEEP_DURATION = Duration.ofMillis(200);

    private static final TestApp TESTAPP_SAME_NAME_AS_APEX = new TestApp(
            ""TestAppSamePackageNameAsApex"", SHIM_APEX_PACKAGE_NAME, 1, /*isApex*/ false,
            ""StagedInstallTestAppSamePackageNameAsApex.apk"");
    private static final TestApp Apex2DifferentCertificate = new TestApp(
            ""Apex2DifferentCertificate"", SHIM_APEX_PACKAGE_NAME, 2, /*isApex*/true,
            ""com.android.apex.cts.shim.v2_different_certificate.apex"");
    private static final TestApp Apex2DifferentPackageName = new TestApp(
            ""Apex2DifferentPackageName"", DIFFERENT_APEX_PACKAGE_NAME, 2, /*isApex*/true,
            ""com.android.apex.cts.shim.v2_different_package_name.apex"");
    private static final TestApp Apex2SignedBob = new TestApp(
            ""Apex2SignedBob"", SHIM_APEX_PACKAGE_NAME, 2, /*isApex*/true,
            ""com.android.apex.cts.shim.v2_signed_bob.apex"");
    private static final TestApp Apex2SignedBobRot = new TestApp(
            ""Apex2SignedBobRot"", SHIM_APEX_PACKAGE_NAME, 2, /*isApex*/true,
            ""com.android.apex.cts.shim.v2_signed_bob_rot.apex"");
    private static final TestApp Apex2SignedBobRotRollback = new TestApp(
            ""Apex2SignedBobRotRollback"", SHIM_APEX_PACKAGE_NAME, 2, /*isApex*/true,
            ""com.android.apex.cts.shim.v2_signed_bob_rot_rollback.apex"");
    private static final TestApp ApexNoHashtree2 = new TestApp(
            ""Apex2"", SHIM_APEX_PACKAGE_NAME, 2, /*isApex*/true,
            ""com.an"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/stagedinstall/app/src/com/android/tests/stagedinstall/StagedInstallTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.tests.stagedinstall.StagedInstallTest"	"testFailInstallIfNoPermission"	""	"1: permission"	"([3:/com/android/tests/stagedinstall/StagedInstallTest.java]:[permission]:[3]:method_text:[ent process has ""                    + ""android.permission.INSTALL_PACKAGES"");        }    }   ]) :|: 
    public void testFailInstallIfNoPermission() throws Exception {
        dropShellPermissions();
        try {
            createStagedSession();
            fail(); // Should have thrown SecurityException.
        } catch (SecurityException e) {
            // This would be a better version, but it requires a version of truth not present in the
            // tree yet.
            // assertThat(e).hasMessageThat().containsMatch(...);
            assertThat(e.getMessage()).containsMatch(
                    ""Neither user [0-9]+ nor current process has ""
                    + ""android.permission.INSTALL_PACKAGES"");
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/stagedinstall/app/src/com/android/tests/stagedinstall/StagedInstallTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.security.cts.CVE_2021_0523"	"testPocCVE_2021_0523"	"CtsSecurityBulletinHostTestCases"	"1: permission"	"([2:/android/security/cts/CVE_2021_0523.java]:[permission]:[2]:method_text:[;            assertThat(crashPattern, pattern.matcher(logcat).find(), is(false));        }    }}]) :|: 
    @AsbSecurityTest(cveBugId = 174047492)
    public void testPocCVE_2021_0523() throws Exception {
        final int SLEEP_INTERVAL_MILLISEC = 30 * 1000;
        String apkName = ""CVE-2021-0523.apk"";
        String appPath = AdbUtils.TMP_PATH + apkName;
        String packageName = ""android.security.cts.cve_2021_0523"";
        String crashPattern =
            ""Device is vulnerable to b/174047492 hence any app with "" +
            ""SYSTEM_ALERT_WINDOW can overlay the WifiScanModeActivity screen"";
        ITestDevice device = getDevice();

        try {
            /* Push the app to /data/local/tmp */
            pocPusher.appendBitness(false);
            pocPusher.pushFile(apkName, appPath);

            /* Wake up the screen */
            AdbUtils.runCommandLine(""input keyevent KEYCODE_WAKEUP"", device);
            AdbUtils.runCommandLine(""input keyevent KEYCODE_MENU"", device);
            AdbUtils.runCommandLine(""input keyevent KEYCODE_HOME"", device);

            /* Install the application */
            AdbUtils.runCommandLine(""pm install "" + appPath, device);

            /* Grant ""Draw over other apps"" permission */
            AdbUtils.runCommandLine(
                    ""pm grant "" + packageName + "" android.permission.SYSTEM_ALERT_WINDOW"", device);

            /* Start the application */
            AdbUtils.runCommandLine(""am start -n "" + packageName + ""/.PocActivity"", getDevice());
            Thread.sleep(SLEEP_INTERVAL_MILLISEC);

            /* Get screen width and height */
            int[] displaySize = new int[2];
            extractInt(AdbUtils.runCommandLine(""wm size"", device), displaySize);
            int width = displaySize[0];
            int height = displaySize[1];

            /* Give a tap command for center of screen */
            AdbUtils.runCommandLine(""input tap "" + width / 2 + "" "" + height / 2, device);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            /* Un-install the app after"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/securitybulletin/src/android/security/cts/CVE_2021_0523.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.security.cts.Poc20_06"	"testPocCVE_2020_3626"	"CtsSecurityBulletinHostTestCases"	"1: permission"	"([1:/android/security/cts/Poc20_06.java]:[permission]:[1]:method_text:[com.qti.permission.USE_UIM_LPA_SERVICE""));        }    }    /**     * CVE-2020-3628     */   ]) :|: 
    @AsbSecurityTest(cveBugId = 150697952)
    public void testPocCVE_2020_3626() throws Exception {
        String isApplicable =
                AdbUtils.runCommandLine(""pm list package com.qualcomm.qti.lpa"", getDevice());
        if (!isApplicable.isEmpty()) {
            String result =
                    AdbUtils.runCommandLine(""dumpsys package com.qualcomm.qti.lpa"", getDevice());
            assertTrue(result.contains(""com.qti.permission.USE_UIM_LPA_SERVICE""));
        }
    }

    /**
     * CVE-2020-3628
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/securitybulletin/src/android/security/cts/Poc20_06.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.security.cts.Poc19_05"	"testPocCVE_2019_2257"	"CtsSecurityBulletinHostTestCases"	"1: permission"	"([2:/android/security/cts/Poc19_05.java]:[permission]:[2]:method_text:[                           ""permission com.qualcomm.permission.USE_QTI_TELEPHONY_SERVICE""));    }}]) :|: 
    @AsbSecurityTest(cveBugId = 112303441)
    public void testPocCVE_2019_2257() throws Exception {
        String result = AdbUtils.runCommandLine(
                                ""dumpsys package com.qualcomm.qti.telephonyservice"", getDevice());
        assertFalse(result.contains(
                            ""permission com.qualcomm.permission.USE_QTI_TELEPHONY_SERVICE""));
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/securitybulletin/src/android/security/cts/Poc19_05.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.inputmethodservice.cts.hostside.MultiUserTest"	"testProfileUserInstant"	"CtsInputMethodServiceHostTestCases"	"3: android.software.managed android.software.managed_users managed_users"	"([1:/android/inputmethodservice/cts/hostside/MultiUserTest.java]:[managed_users]:[1]:method_text:[                .setTestMethodName(testInfo.testMethod)                .setUserId(userId));    }}]) :|: 
    public void testProfileUserInstant() throws Exception {
        testProfileUser(true);
    }

    private void testProfileUser(boolean instant) throws Exception {
        assumeTrue(getDevice().hasFeature(""android.software.managed_users""));

        final int primaryUserId = getDevice().getPrimaryUserId();
        final int profileUserId = createProfile(primaryUserId);

        getDevice().startUser(profileUserId, true /* waitFlag */);

        installPossibleInstantPackage(DeviceTestConstants.APK, primaryUserId, instant);
        installPossibleInstantPackage(DeviceTestConstants.APK, profileUserId, instant);

        // Work around b/31009094.
        assertTestApkIsReadyAfterInstallation(profileUserId);

        assertIme1NotExistInApiResult(primaryUserId);
        assertIme1NotExistInApiResult(profileUserId);
        assertIme1ImplicitlyEnabledSubtypeNotExist(primaryUserId);
        assertIme1ImplicitlyEnabledSubtypeNotExist(profileUserId);

        // Install IME1 then enable/set it as the current IME for the primary user.
        installPackageAsUser(Ime1Constants.APK, true, primaryUserId, ""-r"");
        waitUntilImeIsInShellCommandResult(Ime1Constants.IME_ID, primaryUserId);
        shell(ShellCommandUtils.enableIme(Ime1Constants.IME_ID, primaryUserId));
        shell(ShellCommandUtils.setCurrentImeSync(Ime1Constants.IME_ID, primaryUserId));

        // Install IME2 then enable/set it as the current IME for the profile user.
        installPackageAsUser(Ime2Constants.APK, true, profileUserId, ""-r"");
        waitUntilImeIsInShellCommandResult(Ime2Constants.IME_ID, profileUserId);
        shell(ShellCommandUtils.enableIme(Ime2Constants.IME_ID, profileUserId));
        shell(ShellCommandUtils.setCurrentImeSync(Ime2Constants.IME_ID, profileUserId));

        // Primary User: IME1:enabled, IME2:N/A
        assertIme1ExistsInApiResult(primaryUserId);
        assertIme1EnabledInApiResult(primaryUserId);
        assertIme2NotExistInApiResult(primaryUserId);"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/inputmethodservice/hostside/src/android/inputmethodservice/cts/hostside/MultiUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.appbinding.AppBindingHostTest"	"isSmsCapable"	"CtsAppBindingHostTestCases"	"1: permission"	"([2:/com/android/cts/appbinding/AppBindingHostTest.java]:[permission]:[2]:method_text:[   * Install APK 1 and make it the default SMS app and make sure the service gets bound.     */   ]) :|: /*
 *.
 */
package com.android.cts.appbinding;


import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.fail;

import com.android.compatibility.common.tradefed.build.CompatibilityBuildHelper;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.log.LogUtil.CLog;
import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;
import com.android.tradefed.testtype.IBuildReceiver;
import com.android.tradefed.testtype.junit4.BaseHostJUnit4Test;
import com.android.tradefed.testtype.junit4.DeviceTestRunOptions;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

@RunWith(DeviceJUnit4ClassRunner.class)
public class AppBindingHostTest extends BaseHostJUnit4Test implements IBuildReceiver {

    private static final boolean SKIP_UNINSTALL = false;

    private static final String APK_1 = ""CtsAppBindingService1.apk"";
    private static final String APK_2 = ""CtsAppBindingService2.apk"";
    private static final String APK_3 = ""CtsAppBindingService3.apk"";
    private static final String APK_4 = ""CtsAppBindingService4.apk"";
    private static final String APK_5 = ""CtsAppBindingService5.apk"";
    private static final String APK_6 = ""CtsAppBindingService6.apk"";
    private static final String APK_7 = ""CtsAppBindingService7.apk"";
    private static final String APK_B = ""CtsAppBindingServiceB.apk"";

    private static final String PACKAGE_A = ""com.android.cts.appbinding.app"";
    private static final String PACKAGE_B = ""com.android.cts.appbinding.app.b"";

    private static final String PACKAGE_A_PROC = PACKAGE_A + "":persistent"";

    private static final String APP_BINDING_SETTING = ""app_binding_constants"";

    private static final String SERVICE_1 = ""com.android.cts.appbinding.app.MyService"";
    private static final Str"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appbinding/hostside/src/com/android/cts/appbinding/AppBindingHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.appbinding.AppBindingHostTest"	"testSimpleNotBound3"	"CtsAppBindingHostTestCases"	"1: permission"	"([1:/com/android/cts/appbinding/AppBindingHostTest.java]:[permission]:[1]:method_text:[_CLIENT_SERVICE"");    }    /**     * APK 4 doesn't have a valid service to be bound.     */   ]) :|: 
    public void testSimpleNotBound3() throws Throwable {
        if (!isSmsCapable()) {
            // device not supporting sms. cannot run the test.
            return;
        }

        installAndCheckNotBound(APK_3, PACKAGE_A, mCurrentUserId,
                ""must be protected with android.permission.BIND_CARRIER_MESSAGING_CLIENT_SERVICE"");
    }

    /**
     * APK 4 doesn't have a valid service to be bound.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appbinding/hostside/src/com/android/cts/appbinding/AppBindingHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.appbinding.AppBindingHostTest"	"testUpgrade"	"CtsAppBindingHostTestCases"	"1: permission"	"([1:/com/android/cts/appbinding/AppBindingHostTest.java]:[permission]:[1]:method_text:[ntUserId));    }    /**     * Make sure the service responds to setComponentEnabled.     */   ]) :|: 
    public void testUpgrade() throws Throwable {
        if (!isSmsCapable()) {
            // device not supporting sms. cannot run the test.
            return;
        }

        // Replace existing package without uninstalling.
        installAndCheckBound(APK_1, PACKAGE_A, SERVICE_1, mCurrentUserId);
        installAndCheckBound(APK_2, PACKAGE_A, SERVICE_2, mCurrentUserId);
        installAndCheckNotBound(APK_3, PACKAGE_A, mCurrentUserId,
                ""must be protected with android.permission.BIND_CARRIER_MESSAGING_CLIENT_SERVICE"");
        installAndCheckBound(APK_1, PACKAGE_A, SERVICE_1, mCurrentUserId);
        installAndCheckNotBound(APK_4, PACKAGE_A, mCurrentUserId, ""More than one"");
    }

    private void enableTargetService(boolean enable) throws DeviceNotAvailableException {
        runDeviceTests(new DeviceTestRunOptions(PACKAGE_A)
                .setTestClassName(""com.android.cts.appbinding.app.MyEnabler"")
                .setTestMethodName(enable ? ""enableService"" : ""disableService"")
                .setUserId(mCurrentUserId));
    }

    /**
     * Make sure the service responds to setComponentEnabled.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appbinding/hostside/src/com/android/cts/appbinding/AppBindingHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.appbinding.AppBindingHostTest"	"testSecondaryUser"	"CtsAppBindingHostTestCases"	"1: permission"	"([1:/com/android/cts/appbinding/AppBindingHostTest.java]:[permission]:[1]:method_text:[      }        assertUserHasNoConnection(userId);        assertUserHasNoFinder(userId);    }   ]) :|: 
    public void testSecondaryUser() throws Throwable {
        if (!isSmsCapable()) {
            // device not supporting sms. cannot run the test.
            return;
        }

        if (!getDevice().isMultiUserSupported()) {
            // device do not support multi-user.
            return;
        }

        installAndCheckBound(APK_1, PACKAGE_A, SERVICE_1, mCurrentUserId);

        final int userId = getDevice().createUser(""test-user"");
        try {
            getDevice().startUser(userId);

            // Install SMS app on the secondary user.
            installAndCheckBound(APK_B, PACKAGE_B, SERVICE_1, userId);

            // Package A should still be bound on user-0.
            checkBound(PACKAGE_A, SERVICE_1, mCurrentUserId);

            // Replace the app on the primary user with an invalid one.
            installAndCheckNotBound(APK_3, PACKAGE_A, mCurrentUserId,
                    ""must be protected with android.permission.BIND_CARRIER_MESSAGING_CLIENT_SERVICE"");

            // Secondary user should still have a valid connection.
            checkBound(PACKAGE_B, SERVICE_1, userId);

            // Upgrade test: Try with apk 1, and then upgrade to apk 2.
            installAndCheckBound(APK_1, PACKAGE_A, SERVICE_1, userId);
            installAndCheckBound(APK_2, PACKAGE_A, SERVICE_2, userId);

            // Stop the secondary user, now the binding should be gone.
            getDevice().stopUser(userId);

            // Now the connection should be removed.
            assertUserHasNoConnection(userId);

            // Start the secondary user again.
            getDevice().startUser(userId);

            // Now the binding should recover.
            runWithRetries(DEFAULT_TIMEOUT_SEC, () -> {
                checkBound(PACKAGE_A, SERVICE_2, userId);
            });

        } finally {
            getDevice().removeUser(userId);
        }
        assertUserHasNoConnection(userId);
        assertUserHasNoFinder(userId);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/appbinding/hostside/src/com/android/cts/appbinding/AppBindingHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.graphics.framerateoverride.FrameRateOverrideTest"	"dropShellPermissionIdentity"	""	"1: permission"	"([6:/com/android/cts/graphics/framerateoverride/FrameRateOverrideTest.java]:[permission]:[6]:method_text:[ FrameRateOverrideHostTest.testBackpressureDisplayModeReturnsPhysicalRefreshRateDisabled     */   ]) :|: /*
 *.
 */

package com.android.cts.graphics.framerateoverride;

import android.Manifest;
import android.app.compat.CompatChanges;
import android.hardware.display.DisplayManager;
import android.os.Handler;
import android.os.Looper;
import android.support.test.uiautomator.UiDevice;
import android.sysprop.SurfaceFlingerProperties;
import android.util.Log;
import android.view.Display;
import android.view.Window;
import android.view.WindowManager;

import androidx.test.InstrumentationRegistry;
import androidx.test.rule.ActivityTestRule;
import androidx.test.runner.AndroidJUnit4;

import com.android.cts.graphics.framerateoverride.FrameRateOverrideTestActivity.FrameRateObserver;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.ArrayList;
import java.util.List;

/**
 * Tests for frame rate override and the behaviour of {@link Display#getRefreshRate()} and
 * {@link Display.Mode#getRefreshRate()} Api.
 */
@RunWith(AndroidJUnit4.class)
public final class FrameRateOverrideTest {
    private static final String TAG = ""FrameRateOverrideTest"";
    // See b/170503758 for more details
    private static final long DISPLAY_MODE_RETURNS_PHYSICAL_REFRESH_RATE_CHANGEID = 170503758;

    // The tolerance within which we consider refresh rates are equal
    private static final float REFRESH_RATE_TOLERANCE = 0.01f;

    private int mInitialMatchContentFrameRate;
    private DisplayManager mDisplayManager;


    @Rule
    public ActivityTestRule<FrameRateOverrideTestActivity> mActivityRule =
            new ActivityTestRule<>(FrameRateOverrideTestActivity.class);

    @Before
    public void setUp() throws Exception {
        final UiDevice uiDevice =
                UiDevice.getInstance(
                        androidx.test.platform.app.InstrumentationRegistry.getInstrumentation());
        uiDevice.wakeUp();
        uiDevice.executeShellCommand(""wm dismiss-keyguard"");

        Instrumenta"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/graphics/framerateoverride/app/src/com/android/cts/graphics/framerateoverride/FrameRateOverrideTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.rollback.host.app2.HostTestHelper"	"dropShellPermissionIdentity"	""	"1: permission"	"([7:/com/android/cts/rollback/host/app2/HostTestHelper.java]:[permission]:[7]:method_text:[s InterruptedException, IOException {        InstallUtils.dropShellPermissionIdentity();    }   ]) :|: /*
 *.
 */

package com.android.cts.rollback.host.app2;

import static com.android.cts.rollback.lib.RollbackInfoSubject.assertThat;

import static com.google.common.truth.Truth.assertThat;

import android.Manifest;
import android.content.rollback.RollbackInfo;

import com.android.cts.install.lib.InstallUtils;
import com.android.cts.install.lib.TestApp;
import com.android.cts.rollback.lib.Rollback;
import com.android.cts.rollback.lib.RollbackUtils;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

import java.io.IOException;

/**
 * On-device helper test methods used for host-driven rollback tests.
 */
@RunWith(JUnit4.class)
public class HostTestHelper {
    /**
     * Adopts common permissions needed to test rollbacks.
     */
    @Before
    public void setup() throws InterruptedException, IOException {
        InstallUtils.adoptShellPermissionIdentity(
                    Manifest.permission.INSTALL_PACKAGES,
                    Manifest.permission.DELETE_PACKAGES,
                    Manifest.permission.TEST_MANAGE_ROLLBACKS);
    }

    /**
     * Drops adopted shell permissions.
     */
    @After
    public void teardown() throws InterruptedException, IOException {
        InstallUtils.dropShellPermissionIdentity();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/rollback/app2/src/com/android/cts/rollback/host/app2/HostTestHelper.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.rollback.host.app.HostTestHelper"	"dropShellPermissionIdentity"	""	"1: permission"	"([7:/com/android/cts/rollback/host/app/HostTestHelper.java]:[permission]:[7]:method_text:[s InterruptedException, IOException {        InstallUtils.dropShellPermissionIdentity();    }   ]) :|: /*
 *.
 */

package com.android.cts.rollback.host.app;

import static com.android.cts.shim.lib.ShimPackage.PRIVILEGED_SHIM_PACKAGE_NAME;
import static com.android.cts.shim.lib.ShimPackage.SHIM_APEX_PACKAGE_NAME;
import static com.android.cts.shim.lib.ShimPackage.SHIM_PACKAGE_NAME;
import static com.android.cts.rollback.lib.RollbackInfoSubject.assertThat;

import static com.google.common.truth.Truth.assertThat;

import android.Manifest;
import android.content.Context;
import android.content.pm.PackageInstaller;
import android.content.rollback.RollbackInfo;
import android.content.rollback.RollbackManager;
import android.os.storage.StorageManager;

import androidx.test.platform.app.InstrumentationRegistry;

import com.android.cts.install.lib.Install;
import com.android.cts.install.lib.InstallUtils;
import com.android.cts.install.lib.TestApp;
import com.android.cts.rollback.lib.Rollback;
import com.android.cts.rollback.lib.RollbackUtils;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;

/**
 * On-device helper test methods used for host-driven rollback tests.
 */
@RunWith(JUnit4.class)
public class HostTestHelper {
    private static final String TAG = ""RollbackTest"";

    private static final TestApp Apex2SignedBobRotRollback = new TestApp(
            ""Apex2SignedBobRotRollback"", SHIM_APEX_PACKAGE_NAME, 2, /*isApex*/true,
            ""com.android.apex.cts.shim.v2_signed_bob_rot_rollback.apex"");
    private static final String APK_VERSION_FILENAME = ""ctsrollback_apkversion"";
    private static final String APK_VERSION_SEPARATOR = "","";

    /**
     * Adopts common permissions needed to test rollbacks.
     */
    @Before
    public void setup() throws InterruptedException, IOException {"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/rollback/app/src/com/android/cts/rollback/host/app/HostTestHelper.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.host.LegacyStorageHostTest"	"isTrue"	""	"1: permission"	"([10:/android/scopedstorage/cts/host/LegacyStorageHostTest.java]:[permission]:[10]:method_text:[ion.WRITE_EXTERNAL_STORAGE"",                ""android.permission.READ_EXTERNAL_STORAGE"");    }   ]) :|: /*
 *.
 */

package android.scopedstorage.cts.host;

import static com.google.common.truth.Truth.assertThat;

import android.platform.test.annotations.AppModeFull;

import com.android.tradefed.device.contentprovider.ContentProviderHandler;
import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Runs the legacy file path access tests.
 */
@RunWith(DeviceJUnit4ClassRunner.class)
@AppModeFull
public class LegacyStorageHostTest extends BaseHostTestCase {

    private boolean mIsExternalStorageSetup;

    private ContentProviderHandler mContentProviderHandler;

    /**
     * Runs the given phase of LegacyFileAccessTest by calling into the device.
     * Throws an exception if the test phase fails.
     */
    void runDeviceTest(String phase) throws Exception {
        assertThat(runDeviceTests(""android.scopedstorage.cts.legacy"",
                ""android.scopedstorage.cts.legacy.LegacyStorageTest"", phase)).isTrue();
    }

    /**
     * <p> Keep in mind that granting WRITE_EXTERNAL_STORAGE also grants READ_EXTERNAL_STORAGE,
     * so in order to test a case where the reader has only WRITE, we must explicitly revoke READ.
     */
    private void grantPermissions(String... perms) throws Exception {
        int currentUserId = getCurrentUserId();
        for (String perm : perms) {
            executeShellCommand(""pm grant --user %d android.scopedstorage.cts.legacy %s"",
                    currentUserId, perm);
        }
    }

    private void revokePermissions(String... perms) throws Exception {
        int currentUserId = getCurrentUserId();
        for (String perm : perms) {
            executeShellCommand(""pm revoke --user %d android.scopedstorage.cts.legacy %s"",
                    currentUserId, perm);
        }
    }

    /**
     * Creates a file {@code filePath} in shell and may bypass Media Provider restrictions for
     * creating file."	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/LegacyStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.host.LegacyStorageHostTest"	"testCreateFilesInRandomPlaces_hasW"	""	"1: permission"	"([2:/android/scopedstorage/cts/host/LegacyStorageHostTest.java]:[permission]:[2]:method_text:[com.android.shell -m 2770"");        runDeviceTest(""testCreateFilesInRandomPlaces_hasW"");    }   ]) :|: 
    public void testCreateFilesInRandomPlaces_hasW() throws Exception {
        revokePermissions(""android.permission.READ_EXTERNAL_STORAGE"");
        executeShellCommand(""mkdir -p /sdcard/Android/data/com.android.shell -m 2770"");
        runDeviceTest(""testCreateFilesInRandomPlaces_hasW"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/LegacyStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.host.LegacyStorageHostTest"	"testMkdirInRandomPlaces_hasW"	""	"1: permission"	"([2:/android/scopedstorage/cts/host/LegacyStorageHostTest.java]:[permission]:[2]:method_text:[/data/com.android.shell -m 2770"");        runDeviceTest(""testMkdirInRandomPlaces_hasW"");    }   ]) :|: 
    public void testMkdirInRandomPlaces_hasW() throws Exception {
        revokePermissions(""android.permission.READ_EXTERNAL_STORAGE"");
        executeShellCommand(""mkdir -p /sdcard/Android/data/com.android.shell -m 2770"");
        runDeviceTest(""testMkdirInRandomPlaces_hasW"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/LegacyStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.host.LegacyStorageHostTest"	"testReadOnlyExternalStorage_hasR"	""	"1: permission"	"([2:/android/scopedstorage/cts/host/LegacyStorageHostTest.java]:[permission]:[2]:method_text:[sion.WRITE_EXTERNAL_STORAGE"");        runDeviceTest(""testReadOnlyExternalStorage_hasR"");    }   ]) :|: 
    public void testReadOnlyExternalStorage_hasR() throws Exception {
        revokePermissions(""android.permission.WRITE_EXTERNAL_STORAGE"");
        runDeviceTest(""testReadOnlyExternalStorage_hasR"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/LegacyStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.host.LegacyStorageHostTest"	"testCantAccessExternalStorage"	""	"1: permission"	"([3:/android/scopedstorage/cts/host/LegacyStorageHostTest.java]:[permission]:[3]:method_text:[rmission.READ_EXTERNAL_STORAGE"");        runDeviceTest(""testCantAccessExternalStorage"");    }   ]) :|: 
    public void testCantAccessExternalStorage() throws Exception {
        revokePermissions(""android.permission.WRITE_EXTERNAL_STORAGE"",
                ""android.permission.READ_EXTERNAL_STORAGE"");
        runDeviceTest(""testCantAccessExternalStorage"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/LegacyStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.host.LegacyStorageHostTest"	"testListFiles_hasR"	""	"1: permission"	"([2:/android/scopedstorage/cts/host/LegacyStorageHostTest.java]:[permission]:[2]:method_text:[android.permission.WRITE_EXTERNAL_STORAGE"");        runDeviceTest(""testListFiles_hasR"");    }   ]) :|: 
    public void testListFiles_hasR() throws Exception {
        revokePermissions(""android.permission.WRITE_EXTERNAL_STORAGE"");
        runDeviceTest(""testListFiles_hasR"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/LegacyStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.host.LegacyStorageHostTest"	"testCantRename_hasR"	""	"1: permission"	"([2:/android/scopedstorage/cts/host/LegacyStorageHostTest.java]:[permission]:[2]:method_text:[ndroid.permission.WRITE_EXTERNAL_STORAGE"");        runDeviceTest(""testCantRename_hasR"");    }   ]) :|: 
    public void testCantRename_hasR() throws Exception {
        revokePermissions(""android.permission.WRITE_EXTERNAL_STORAGE"");
        runDeviceTest(""testCantRename_hasR"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/LegacyStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.host.LegacyStorageHostTest"	"testCantRename_noStoragePermission"	""	"1: permission"	"([5:/android/scopedstorage/cts/host/LegacyStorageHostTest.java]:[permission]:[5]:method_text:[ion.READ_EXTERNAL_STORAGE"");        runDeviceTest(""testCantRename_noStoragePermission"");    }   ]) :|: 
    public void testCantRename_noStoragePermission() throws Exception {
        revokePermissions(""android.permission.WRITE_EXTERNAL_STORAGE"",
                ""android.permission.READ_EXTERNAL_STORAGE"");
        runDeviceTest(""testCantRename_noStoragePermission"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/LegacyStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.host.LegacyStorageHostTest"	"testLegacySystemGalleryWithoutWESCannotRename"	""	"1: permission"	"([2:/android/scopedstorage/cts/host/LegacyStorageHostTest.java]:[permission]:[2]:method_text:[TERNAL_STORAGE"");        runDeviceTest(""testLegacySystemGalleryWithoutWESCannotRename"");    }   ]) :|: 
    public void testLegacySystemGalleryWithoutWESCannotRename() throws Exception {
        revokePermissions(""android.permission.WRITE_EXTERNAL_STORAGE"");
        runDeviceTest(""testLegacySystemGalleryWithoutWESCannotRename"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/LegacyStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.host.ScopedStorageCoreHostTest"	"revokeStoragePermissions"	""	"1: permission"	"([4:/android/scopedstorage/cts/host/ScopedStorageCoreHostTest.java]:[permission]:[4]:method_text:[ Exception {        executeShellCommand(""rm -r /sdcard/Android/data/com.android.shell"");    }   ]) :|: /*
 *.
 */

package android.scopedstorage.cts.host;

import static org.junit.Assert.assertTrue;

import android.platform.test.annotations.AppModeFull;

import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Runs the core ScopedStorageTest tests.
 */
@RunWith(DeviceJUnit4ClassRunner.class)
@AppModeFull
public class ScopedStorageCoreHostTest extends BaseHostTestCase {
    private boolean mIsExternalStorageSetup = false;

    /**
     * Runs the given phase of ScopedStorageTest by calling into the device.
     * Throws an exception if the test phase fails.
     */
    void runDeviceTest(String phase) throws Exception {
        assertTrue(runDeviceTests(""android.scopedstorage.cts"",
                ""android.scopedstorage.cts.ScopedStorageTest"", phase));

    }

    private void setupExternalStorage() throws Exception {
        if (!mIsExternalStorageSetup) {
            runDeviceTest(""setupExternalStorage"");
            mIsExternalStorageSetup = true;
        }
    }

    @Before
    public void setup() throws Exception {
        setupExternalStorage();
        executeShellCommand(""mkdir /sdcard/Android/data/com.android.shell -m 2770"");
        executeShellCommand(""mkdir /sdcard/Android/data/com.android.shell/files -m 2770"");
    }

    @Before
    public void revokeStoragePermissions() throws Exception {
        revokePermissions(""android.permission.WRITE_EXTERNAL_STORAGE"",
                ""android.permission.READ_EXTERNAL_STORAGE"");
    }

    @After
    public void tearDown() throws Exception {
        executeShellCommand(""rm -r /sdcard/Android/data/com.android.shell"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/ScopedStorageCoreHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.host.ScopedStorageCoreHostTest"	"testAccess_file"	""	"1: permission"	"([4:/android/scopedstorage/cts/host/ScopedStorageCoreHostTest.java]:[permission]:[4]:method_text:[ly {            revokePermissions(""android.permission.READ_EXTERNAL_STORAGE"");        }    }   ]) :|: 
    public void testAccess_file() throws Exception {
        grantPermissions(""android.permission.READ_EXTERNAL_STORAGE"");
        try {
            runDeviceTest(""testAccess_file"");
        } finally {
            revokePermissions(""android.permission.READ_EXTERNAL_STORAGE"");
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/ScopedStorageCoreHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.host.ScopedStorageCoreHostTest"	"testAccess_directory"	""	"1: permission"	"([8:/android/scopedstorage/cts/host/ScopedStorageCoreHostTest.java]:[permission]:[8]:method_text:[executeShellCommand(""cmd appops set --uid android.scopedstorage.cts %s deny"", op);        }    }}]) :|: 
    public void testAccess_directory() throws Exception {
        grantPermissions(""android.permission.READ_EXTERNAL_STORAGE"",
                ""android.permission.WRITE_EXTERNAL_STORAGE"");
        try {
            runDeviceTest(""testAccess_directory"");
        } finally {
            revokePermissions(""android.permission.READ_EXTERNAL_STORAGE"",
                    ""android.permission.WRITE_EXTERNAL_STORAGE"");
        }
    }

    private void grantPermissions(String... perms) throws Exception {
        int currentUserId = getCurrentUserId();
        for (String perm : perms) {
            executeShellCommand(""pm grant --user %d android.scopedstorage.cts %s"",
                    currentUserId, perm);
        }
    }

    private void revokePermissions(String... perms) throws Exception {
        int currentUserId = getCurrentUserId();
        for (String perm : perms) {
            executeShellCommand(""pm revoke --user %d android.scopedstorage.cts %s"",
                    currentUserId, perm);
        }
    }

    private void allowAppOps(String... ops) throws Exception {
        for (String op : ops) {
            executeShellCommand(""cmd appops set --uid android.scopedstorage.cts %s allow"", op);
        }
    }

    private void denyAppOps(String... ops) throws Exception {
        for (String op : ops) {
            executeShellCommand(""cmd appops set --uid android.scopedstorage.cts %s deny"", op);
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/ScopedStorageCoreHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.host.ScopedStorageHostTest"	"isTrue"	""	"1: permission"	"([4:/android/scopedstorage/cts/host/ScopedStorageHostTest.java]:[permission]:[4]:method_text:[ Exception {        executeShellCommand(""rm -r /sdcard/Android/data/com.android.shell"");    }   ]) :|: /*
 *.
 */

package android.scopedstorage.cts.host;

import static com.google.common.truth.Truth.assertThat;

import android.platform.test.annotations.AppModeFull;

import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;
import com.android.tradefed.testtype.junit4.DeviceTestRunOptions;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Runs the ScopedStorageTest tests.
 */
@RunWith(DeviceJUnit4ClassRunner.class)
@AppModeFull
public class ScopedStorageHostTest extends BaseHostTestCase {
    private boolean mIsExternalStorageSetup;

    /**
     * Runs the given phase of ScopedStorageTest by calling into the device.
     * Throws an exception if the test phase fails.
     */
    void runDeviceTest(String phase) throws Exception {
        assertThat(runDeviceTests(""android.scopedstorage.cts"",
                ""android.scopedstorage.cts.ScopedStorageTest"", phase)).isTrue();
    }

    /**
     * Runs the given phase of ScopedStorageTest by calling into the device with {@code
     * --no-isolated-storage} flag.
     * Throws an exception if the test phase fails.
     */
    void runDeviceTestWithDisabledIsolatedStorage(String phase) throws Exception {
        runDeviceTests(new DeviceTestRunOptions(""android.scopedstorage.cts"")
            .setDevice(getDevice())
            .setTestClassName(""android.scopedstorage.cts.ScopedStorageTest"")
            .setTestMethodName(phase)
            .setDisableIsolatedStorage(true));
    }

    private void setupExternalStorage() throws Exception {
        if (!mIsExternalStorageSetup) {
            runDeviceTest(""setupExternalStorage"");
            mIsExternalStorageSetup = true;
        }
    }

    @Before
    public void setup() throws Exception {
        setupExternalStorage();
        executeShellCommand(""mkdir /sdcard/Android/data/com.android.shell -m 2770"");
        executeShellCommand(""mkdir /sdcard/Android/dat"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/ScopedStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.host.ScopedStorageHostTest"	"testCheckInstallerAppAccessToObbDirs"	""	"1: permission"	"([4:/android/scopedstorage/cts/host/ScopedStorageHostTest.java]:[permission]:[4]:method_text:["");            revokePermissions(""android.permission.WRITE_EXTERNAL_STORAGE"");        }    }   ]) :|: 
    public void testCheckInstallerAppAccessToObbDirs() throws Exception {
        allowAppOps(""android:request_install_packages"");
        grantPermissions(""android.permission.WRITE_EXTERNAL_STORAGE"");
        try {
            runDeviceTest(""testCheckInstallerAppAccessToObbDirs"");
        } finally {
            denyAppOps(""android:request_install_packages"");
            revokePermissions(""android.permission.WRITE_EXTERNAL_STORAGE"");
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/ScopedStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.host.ScopedStorageHostTest"	"testCheckInstallerAppCannotAccessDataDirs"	""	"1: permission"	"([4:/android/scopedstorage/cts/host/ScopedStorageHostTest.java]:[permission]:[4]:method_text:["");            revokePermissions(""android.permission.WRITE_EXTERNAL_STORAGE"");        }    }   ]) :|: 
    public void testCheckInstallerAppCannotAccessDataDirs() throws Exception {
        allowAppOps(""android:request_install_packages"");
        grantPermissions(""android.permission.WRITE_EXTERNAL_STORAGE"");
        try {
            runDeviceTest(""testCheckInstallerAppCannotAccessDataDirs"");
        } finally {
            denyAppOps(""android:request_install_packages"");
            revokePermissions(""android.permission.WRITE_EXTERNAL_STORAGE"");
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/ScopedStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.host.ScopedStorageHostTest"	"testOpenOtherPendingFilesFromFuse"	""	"1: permission"	"([4:/android/scopedstorage/cts/host/ScopedStorageHostTest.java]:[permission]:[4]:method_text:[ly {            revokePermissions(""android.permission.READ_EXTERNAL_STORAGE"");        }    }   ]) :|: 
    public void testOpenOtherPendingFilesFromFuse() throws Exception {
        grantPermissions(""android.permission.READ_EXTERNAL_STORAGE"");
        try {
            runDeviceTest(""testOpenOtherPendingFilesFromFuse"");
        } finally {
            revokePermissions(""android.permission.READ_EXTERNAL_STORAGE"");
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/ScopedStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.host.ScopedStorageHostTest"	"testAndroidMedia"	""	"1: permission"	"([4:/android/scopedstorage/cts/host/ScopedStorageHostTest.java]:[permission]:[4]:method_text:[ly {            revokePermissions(""android.permission.READ_EXTERNAL_STORAGE"");        }    }   ]) :|: 
    public void testAndroidMedia() throws Exception {
        grantPermissions(""android.permission.READ_EXTERNAL_STORAGE"");
        try {
            runDeviceTest(""testAndroidMedia"");
        } finally {
            revokePermissions(""android.permission.READ_EXTERNAL_STORAGE"");
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/ScopedStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.host.ScopedStorageHostTest"	"testWallpaperApisReadExternalStorage"	""	"1: permission"	"([6:/android/scopedstorage/cts/host/ScopedStorageHostTest.java]:[permission]:[6]:method_text:[ly {            revokePermissions(""android.permission.READ_EXTERNAL_STORAGE"");        }    }   ]) :|: 
    public void testWallpaperApisReadExternalStorage() throws Exception {
        // First run without any permission
        runDeviceTest(""testWallpaperApisNoPermission"");

        // Then with RES.
        grantPermissions(""android.permission.READ_EXTERNAL_STORAGE"");
        try {
            runDeviceTest(""testWallpaperApisReadExternalStorage"");
        } finally {
            revokePermissions(""android.permission.READ_EXTERNAL_STORAGE"");
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/ScopedStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.host.ScopedStorageHostTest"	"testNoIsolatedStorageInstrumentationFlag"	""	"1: permission"	"([6:/android/scopedstorage/cts/host/ScopedStorageHostTest.java]:[permission]:[6]:method_text:[NAL_STORAGE"",                    ""android.permission.WRITE_EXTERNAL_STORAGE"");        }    }   ]) :|: 
    public void testNoIsolatedStorageInstrumentationFlag() throws Exception {
        grantPermissions(""android.permission.READ_EXTERNAL_STORAGE"",
                ""android.permission.WRITE_EXTERNAL_STORAGE"");
        try {
            runDeviceTestWithDisabledIsolatedStorage(""testNoIsolatedStorageCanCreateFilesAnywhere"");
            runDeviceTestWithDisabledIsolatedStorage(
                    ""testNoIsolatedStorageCantReadWriteOtherAppExternalDir"");
            runDeviceTestWithDisabledIsolatedStorage(""testNoIsolatedStorageStorageReaddir"");
            runDeviceTestWithDisabledIsolatedStorage(""testNoIsolatedStorageQueryOtherAppsFile"");
        } finally {
            revokePermissions(""android.permission.READ_EXTERNAL_STORAGE"",
                    ""android.permission.WRITE_EXTERNAL_STORAGE"");
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/ScopedStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.host.ScopedStorageHostTest"	"testClearPackageData"	""	"1: permission"	"([4:/android/scopedstorage/cts/host/ScopedStorageHostTest.java]:[permission]:[4]:method_text:[ly {            revokePermissions(""android.permission.READ_EXTERNAL_STORAGE"");        }    }   ]) :|: 
    public void testClearPackageData() throws Exception {
        grantPermissions(""android.permission.READ_EXTERNAL_STORAGE"");
        try {
            runDeviceTest(""testClearPackageData"");
        } finally {
            revokePermissions(""android.permission.READ_EXTERNAL_STORAGE"");
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/ScopedStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.host.ScopedStorageHostTest"	"testUpdateExternalFilesViaRelativePathAsFileManager"	""	"1: permission"	"([4:/android/scopedstorage/cts/host/ScopedStorageHostTest.java]:[permission]:[4]:method_text:[uteShellCommand(""cmd appops set --uid android.scopedstorage.cts "" + op + "" deny"");        }    }}]) :|: 
    public void testUpdateExternalFilesViaRelativePathAsFileManager() throws Exception {
        allowAppOps(""android:manage_external_storage"");
        try {
            runDeviceTest(""testUpdateExternalFilesViaRelativePath"");
        } finally {
            denyAppOps(""android:manage_external_storage"");
        }
    }

    private void grantPermissionsToPackage(String packageName, String... perms) throws Exception {
        int currentUserId = getCurrentUserId();
        for (String perm : perms) {
            executeShellCommand(""pm grant --user %d %s %s"",
                    currentUserId, packageName, perm);
        }
    }

    private void grantPermissions(String... perms) throws Exception {
        grantPermissionsToPackage(""android.scopedstorage.cts"", perms);
    }

    private void revokePermissions(String... perms) throws Exception {
        int currentUserId = getCurrentUserId();
        for (String perm : perms) {
            executeShellCommand(""pm revoke --user %d android.scopedstorage.cts %s"",
                    currentUserId, perm);
        }
    }

    private void allowAppOps(String... ops) throws Exception {
        for (String op : ops) {
            executeShellCommand(""cmd appops set --uid android.scopedstorage.cts "" + op + "" allow"");
        }
    }

    private void denyAppOps(String... ops) throws Exception {
        for (String op : ops) {
            executeShellCommand(""cmd appops set --uid android.scopedstorage.cts "" + op + "" deny"");
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/ScopedStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.host.PreserveLegacyStorageHostTest"	"testPreserveLegacy"	""	"1: permission"	"([1:/android/scopedstorage/cts/host/PreserveLegacyStorageHostTest.java]:[permission]:[1]:method_text:[s get "" + PACKAGE_NAME + "" LEGACY_STORAGE"");        assertThat(result).contains("": allow"");    }}]) :|: 
    public void testPreserveLegacy() throws Exception {
        // This was broken on R, so only run the test on S+ devices
        DeviceSdkLevel deviceSdkLevel = new DeviceSdkLevel(getDevice());
        assumeTrue(deviceSdkLevel.isDeviceAtLeastS());

        // Most of these tests are done device-side; see RestrictedStoragePermissionTest.java
        // This test is done on the host, because we want to verify preserveLegacyExternalStorage
        // is sticky across a reboot.
        installApp(LEGACY_29_APK);
        String result = getDevice().executeShellCommand(
                                    ""appops get "" + PACKAGE_NAME + "" LEGACY_STORAGE"");
        assertThat(result).contains("": allow"");

        // Upgrade to targetSdk 30 with preserveLegacyExternalStorage
        installApp(PRESERVE_30_APK);
        result = getDevice().executeShellCommand(
                                    ""appops get "" + PACKAGE_NAME + "" LEGACY_STORAGE"");

        // And make sure we still have legacy
        assertThat(result).contains("": allow"");

        // Reboot, and again make sure we have legacy
        getDevice().reboot();
        result = getDevice().executeShellCommand(
                                    ""appops get "" + PACKAGE_NAME + "" LEGACY_STORAGE"");
        assertThat(result).contains("": allow"");
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/PreserveLegacyStorageHostTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"isTrue"	""	"1: permission"	"([4:/android/scopedstorage/cts/legacy/LegacyStorageTest.java]:[permission]:[4]:method_text:[estrictions imposed by     * MediaProvider. <p> Assumes we have WRITE_EXTERNAL_STORAGE.     */   ]) :|: 
    public void setupExternalStorage() {
        setupDefaultDirectories();
    }

    @Before
    public void setup() throws Exception {
        pollForExternalStorageState();

        assertThat(checkPermission(APP_A_HAS_RES,
                Manifest.permission.READ_EXTERNAL_STORAGE)).isTrue();
        assertThat(checkPermission(APP_B_NO_PERMS,
                Manifest.permission.READ_EXTERNAL_STORAGE)).isFalse();
    }

    @After
    public void teardown() throws Exception {
        deleteFileInExternalDir(getShellFile());
        try {
            MediaStore.scanFile(getContentResolver(), getShellFile());
        } catch (Exception ignored) {
            //ignore MediaScanner exceptions
        }
    }

    /**
     * Tests that legacy apps bypass the type-path conformity restrictions imposed by
     * MediaProvider. <p> Assumes we have WRITE_EXTERNAL_STORAGE.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testCreateFilesInRandomPlaces_hasW"	""	"1: permission"	"([4:/android/scopedstorage/cts/legacy/LegacyStorageTest.java]:[permission]:[4]:method_text:[estrictions imposed by MediaProvider.     * <p> Assumes we have WRITE_EXTERNAL_STORAGE.     */   ]) :|: 
    public void testCreateFilesInRandomPlaces_hasW() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ false);
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ true);
        // Can create file under root dir
        assertCanCreateFile(new File(TestUtils.getExternalStorageDir(), ""LegacyFileAccessTest.txt""));

        // Can create music file under DCIM
        assertCanCreateFile(new File(TestUtils.getDcimDir(), ""LegacyFileAccessTest.mp3""));

        // Can create random file under external files dir
        assertCanCreateFile(new File(TestUtils.getExternalFilesDir(),
                ""LegacyFileAccessTest""));

        // However, even legacy apps can't create files under other app's directories
        final File otherAppDir = new File(TestUtils.getAndroidDataDir(), ""com.android.shell"");
        final File file = new File(otherAppDir, ""LegacyFileAccessTest.txt"");

        // otherAppDir was already created by the host test
        try {
            file.createNewFile();
            fail(""File creation expected to fail: "" + file);
        } catch (IOException expected) {
        }
    }

    /**
     * Tests that legacy apps bypass dir creation/deletion restrictions imposed by MediaProvider.
     * <p> Assumes we have WRITE_EXTERNAL_STORAGE.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testMkdirInRandomPlaces_hasW"	""	"1: permission"	"([6:/android/scopedstorage/cts/legacy/LegacyStorageTest.java]:[permission]:[6]:method_text:[  }    /**     * Tests that an app can't access external storage without permissions.     */   ]) :|: 
    public void testMkdirInRandomPlaces_hasW() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ false);
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ true);
        // Can create a top-level direcotry
        final File topLevelDir = new File(TestUtils.getExternalStorageDir(), ""LegacyFileAccessTest"");
        assertCanCreateDir(topLevelDir);

        final File otherAppDir = new File(TestUtils.getAndroidDataDir(), ""com.android.shell"");

        // However, even legacy apps can't create dirs under other app's directories
        final File subDir = new File(otherAppDir, ""LegacyFileAccessTest"");
        // otherAppDir was already created by the host test
        assertThat(subDir.mkdir()).isFalse();

        // Try to list a directory and fail because it requires READ permission
        assertThat(TestUtils.getMusicDir().list()).isNull();
    }

    /**
     * Tests that an app can't access external storage without permissions.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testCantAccessExternalStorage"	""	"1: permission"	"([7:/android/scopedstorage/cts/legacy/LegacyStorageTest.java]:[permission]:[7]:method_text:[ally {            fileInMediaDir.delete();        }    }    // test read storage permission   ]) :|: 
    public void testCantAccessExternalStorage() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ false);
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ false);
        // Can't create file under root dir
        final File newTxtFile = new File(TestUtils.getExternalStorageDir(),
                ""LegacyFileAccessTest.txt"");
        try {
            newTxtFile.createNewFile();
            fail(""File creation expected to fail: "" + newTxtFile);
        } catch (IOException expected) {
        }

        // Can't create music file under /MUSIC
        final File newMusicFile = new File(TestUtils.getMusicDir(), ""LegacyFileAccessTest.mp3"");
        try {
            newMusicFile.createNewFile();
            fail(""File creation expected to fail: "" + newMusicFile);
        } catch (IOException expected) {
        }

        // Can't create a top-level direcotry
        final File topLevelDir = new File(TestUtils.getExternalStorageDir(), ""LegacyFileAccessTest"");
        assertThat(topLevelDir.mkdir()).isFalse();

        // Can't read existing file
        final File existingFile = getShellFile();

        try {
            createFileInExternalDir(existingFile);
            MediaStore.scanFile(getContentResolver(), existingFile);
            Os.open(existingFile.getPath(), OsConstants.O_RDONLY, /*mode*/ 0);
            fail(""Opening file for read expected to fail: "" + existingFile);
        } catch (ErrnoException expected) {
        }

        // Can't delete file
        assertThat(existingFile.delete()).isFalse();

        // try to list a directory and fail
        assertThat(TestUtils.getMusicDir().list()).isNull();
        assertThat(TestUtils.getExternalStorageDir().list()).isNull();

        // However, even without permissions, we can access our own external dir
        final File fileInDataDir =
                new File(TestUtils.getExternalFilesDir(),
                        ""Le"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testReadOnlyExternalStorage_hasR"	""	"1: permission"	"([5:/android/scopedstorage/cts/legacy/LegacyStorageTest.java]:[permission]:[5]:method_text:[ }    }    /**     * Test that legacy app with storage permission can list all files     */   ]) :|: 
    public void testReadOnlyExternalStorage_hasR() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ true);
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ false);
        // can list directory content
        assertThat(TestUtils.getMusicDir().list()).isNotNull();

        // try to write a file and fail
        final File existingFile = getShellFile();

        // can open file for read
        FileDescriptor fd = null;
        try {
            createFileInExternalDir(existingFile);
            MediaStore.scanFile(getContentResolver(), existingFile);
            fd = Os.open(existingFile.getPath(), OsConstants.O_RDONLY, /*mode*/ 0);
        } finally {
            if (fd != null) {
                Os.close(fd);
            }
        }

        try {
            fd = Os.open(existingFile.getPath(), OsConstants.O_WRONLY, /*mode*/ 0);
            Os.close(fd);
            fail(""Opening file for write expected to fail: "" + existingFile);
        } catch (ErrnoException expected) {
        }

        // try to create file and fail, because it requires WRITE
        final File newFile = new File(TestUtils.getMusicDir(), ""LegacyFileAccessTest.mp3"");
        try {
            newFile.createNewFile();
            fail(""Creating file expected to fail: "" + newFile);
        } catch (IOException expected) {
        }

        // try to mkdir and fail, because it requires WRITE
        final File newDir = new File(TestUtils.getExternalStorageDir(), ""LegacyFileAccessTest"");
        try {
            assertThat(newDir.mkdir()).isFalse();
        } finally {
            newDir.delete();
        }
    }

    /**
     * Test that legacy app with storage permission can list all files
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testListFiles_hasR"	""	"1: permission"	"([4:/android/scopedstorage/cts/legacy/LegacyStorageTest.java]:[permission]:[4]:method_text:[  }    /**     * Test that URI returned on inserting hidden file is valid after scan.     */   ]) :|: 
    public void testListFiles_hasR() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ true);
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ false);
        final File shellFile = getShellFile();

        createFileInExternalDir(shellFile);
        MediaStore.scanFile(getContentResolver(), getShellFile());
        // can list a non-media file created by other package.
        assertThat(Arrays.asList(shellFile.getParentFile().list()))
                .contains(shellFile.getName());
    }

    /**
     * Test that URI returned on inserting hidden file is valid after scan.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testInsertHiddenFile"	""	"1: permission"	"([3:/android/scopedstorage/cts/legacy/LegacyStorageTest.java]:[permission]:[3]:method_text:[EXTERNAL_STORAGE permission bypasses rename     * restrictions imposed by MediaProvider     */   ]) :|: 
    public void testInsertHiddenFile() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ true);
        final File dcimDir = getDcimDir();
        final String hiddenImageFileName = "".hidden"" + IMAGE_FILE_NAME;
        final File hiddenImageFile = new File(dcimDir, hiddenImageFileName);
        try {
            ContentValues values = new ContentValues();
            values.put(MediaStore.MediaColumns.DATA, hiddenImageFile.getAbsolutePath());
            Uri uri = getContentResolver().insert(getImageContentUri(), values);
            try (OutputStream fos = getContentResolver().openOutputStream(uri, ""rw"")) {
                fos.write(BYTES_DATA1);
            }
            MediaStore.scanFile(getContentResolver(), hiddenImageFile);
            final String[] projection = {MediaStore.MediaColumns.DISPLAY_NAME};
            try (Cursor c = getContentResolver().query(uri, projection, null, null, null)) {
                assertThat(c.moveToFirst()).isTrue();
                assertThat(c.getString(0)).isEqualTo(hiddenImageFileName);
            }
        } finally {
            hiddenImageFile.delete();
        }
    }

    /**
     * Test that rename for legacy app with WRITE_EXTERNAL_STORAGE permission bypasses rename
     * restrictions imposed by MediaProvider
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testCanRename_hasRW"	""	"1: permission"	"([4:/android/scopedstorage/cts/legacy/LegacyStorageTest.java]:[permission]:[4]:method_text:[ith only READ_EXTERNAL_STORAGE can only rename files in app external     * directories.     */   ]) :|: 
    public void testCanRename_hasRW() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ true);
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ true);

        final File musicFile1 = new File(TestUtils.getDcimDir(), ""LegacyFileAccessTest.mp3"");
        final File musicFile2 = new File(TestUtils.getExternalStorageDir(),
                ""LegacyFileAccessTest.mp3"");
        final File musicFile3 = new File(TestUtils.getMoviesDir(), ""LegacyFileAccessTest.mp3"");
        final File nonMediaDir1 = new File(TestUtils.getDcimDir(), ""LegacyFileAccessTest"");
        final File nonMediaDir2 = new File(TestUtils.getExternalStorageDir(),
                ""LegacyFileAccessTest"");
        final File pdfFile1 = new File(nonMediaDir1, ""LegacyFileAccessTest.pdf"");
        final File pdfFile2 = new File(nonMediaDir2, ""LegacyFileAccessTest.pdf"");
        try {
            // can rename a file to root directory.
            assertThat(musicFile1.createNewFile()).isTrue();
            assertCanRenameFile(musicFile1, musicFile2);

            // can rename a music file to Movies directory.
            assertCanRenameFile(musicFile2, musicFile3);

            assertThat(nonMediaDir1.mkdir()).isTrue();
            assertThat(pdfFile1.createNewFile()).isTrue();
            // can rename directory to root directory.
            assertCanRenameDirectory(
                    nonMediaDir1, nonMediaDir2, new File[] {pdfFile1}, new File[] {pdfFile2});
        } finally {
            musicFile1.delete();
            musicFile2.delete();
            musicFile3.delete();

            pdfFile1.delete();
            pdfFile2.delete();
            nonMediaDir1.delete();
            nonMediaDir2.delete();
        }
    }

    /**
     * Test that legacy app with only READ_EXTERNAL_STORAGE can only rename files in app external
     * directories.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testCantRename_hasR"	""	"1: permission"	"([6:/android/scopedstorage/cts/legacy/LegacyStorageTest.java]:[permission]:[6]:method_text:[app with no storage permission can only rename files in app external     * directories.     */   ]) :|: 
    public void testCantRename_hasR() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ true);
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ false);

        final File shellFile1 = getShellFile();
        final File shellFile2 = new File(TestUtils.getDownloadDir(), ""LegacyFileAccessTest_shell"");
        final File mediaFile1 =
                new File(TestUtils.getExternalMediaDir(),
                        ""LegacyFileAccessTest1"");
        final File mediaFile2 =
                new File(TestUtils.getExternalMediaDir(),
                        ""LegacyFileAccessTest2"");
        try {
            createFileInExternalDir(shellFile1);
            MediaStore.scanFile(getContentResolver(), shellFile1);
            // app can't rename shell file.
            assertCantRenameFile(shellFile1, shellFile2);
            // app can't move shell file to its media directory.
            assertCantRenameFile(shellFile1, mediaFile1);
            // However, even without permissions, app can rename files in its own external media
            // directory.
            assertThat(mediaFile1.createNewFile()).isTrue();
            assertThat(mediaFile1.renameTo(mediaFile2)).isTrue();
            assertThat(mediaFile2.exists()).isTrue();
        } finally {
            mediaFile1.delete();
            mediaFile2.delete();
        }
    }

    /**
     * Test that legacy app with no storage permission can only rename files in app external
     * directories.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testCantRename_noStoragePermission"	""	"1: permission"	"([6:/android/scopedstorage/cts/legacy/LegacyStorageTest.java]:[permission]:[6]:method_text:[NIQUE constraint error while updating db     * rows corresponding to renamed directory.     */   ]) :|: 
    public void testCantRename_noStoragePermission() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ false);
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ false);

        final File shellFile1 = getShellFile();
        final File shellFile2 = new File(TestUtils.getDownloadDir(), ""LegacyFileAccessTest_shell"");
        final File mediaFile1 =
                new File(TestUtils.getExternalMediaDir(),
                        ""LegacyFileAccessTest1"");
        final File mediaFile2 =
                new File(TestUtils.getExternalMediaDir(),
                        ""LegacyFileAccessTest2"");
        try {
            createFileInExternalDir(shellFile1);
            MediaStore.scanFile(getContentResolver(), shellFile1);
            // app can't rename shell file.
            assertCantRenameFile(shellFile1, shellFile2);
            // app can't move shell file to its media directory.
            assertCantRenameFile(shellFile1, mediaFile1);
            // However, even without permissions, app can rename files in its own external media
            // directory.
            assertThat(mediaFile1.createNewFile()).isTrue();
            assertThat(mediaFile1.renameTo(mediaFile2)).isTrue();
            assertThat(mediaFile2.exists()).isTrue();
        } finally {
            mediaFile1.delete();
            mediaFile2.delete();
        }
    }

    /**
     * b/156046098, Test that MediaProvider doesn't throw UNIQUE constraint error while updating db
     * rows corresponding to renamed directory.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testCanDeleteAllFiles_hasRW"	""	"1: permission"	"([5:/android/scopedstorage/cts/legacy/LegacyStorageTest.java]:[permission]:[5]:method_text:[ase. And,     * MediaColumns.OWNER_PACKAGE_NAME is updated with calling package's name.     */   ]) :|: 
    public void testCanDeleteAllFiles_hasRW() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ true);
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ true);

        final File videoFile = new File(TestUtils.getExternalStorageDir(), VIDEO_FILE_NAME);
        final File otherAppPdfFile = new File(TestUtils.getDownloadDir(), NONMEDIA_FILE_NAME);

        try {
            assertThat(videoFile.createNewFile()).isTrue();
            assertDirectoryContains(videoFile.getParentFile(), videoFile);

            assertThat(getFileRowIdFromDatabase(videoFile)).isNotEqualTo(-1);
            // Legacy app can delete its own file.
            assertThat(videoFile.delete()).isTrue();
            // Deleting the file will remove videoFile entry from database.
            assertThat(getFileRowIdFromDatabase(videoFile)).isEqualTo(-1);

            assertThat(createFileAs(APP_B_NO_PERMS, otherAppPdfFile.getAbsolutePath())).isTrue();
            assertThat(getFileRowIdFromDatabase(otherAppPdfFile)).isNotEqualTo(-1);
            // Legacy app with write permission can delete the pdfFile owned by TestApp.
            assertThat(otherAppPdfFile.delete()).isTrue();
            // Deleting the pdfFile also removes pdfFile from database.
            //TODO(b/148841336): W_E_S doesn't grant legacy apps write access to other apps' files
            // on a public volume, which is different from the behaviour on a primary external.
//            assertThat(getFileRowIdFromDatabase(otherAppPdfFile)).isEqualTo(-1);
        } finally {
            deleteFileAsNoThrow(APP_B_NO_PERMS, otherAppPdfFile.getAbsolutePath());
            videoFile.delete();
        }
    }

    /**
     * Test that file created by legacy app is inserted to MediaProvider database. And,
     * MediaColumns.OWNER_PACKAGE_NAME is updated with calling package's name.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testLegacyAppCanOwnAFile_hasW"	""	"1: permission"	"([4:/android/scopedstorage/cts/legacy/LegacyStorageTest.java]:[permission]:[4]:method_text:[IdFromDatabase(videoFile));        } finally {            videoFile.delete();        }    }   ]) :|: 
    public void testLegacyAppCanOwnAFile_hasW() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ true);
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ true);

        final File videoFile = new File(TestUtils.getExternalStorageDir(), VIDEO_FILE_NAME);
        try {
            assertThat(videoFile.createNewFile()).isTrue();

            // videoFile is inserted to database, non-legacy app can see this videoFile on 'ls'.
            assertThat(listAs(APP_A_HAS_RES, TestUtils.getExternalStorageDir().getAbsolutePath()))
                    .contains(VIDEO_FILE_NAME);

            // videoFile is in database, row ID for videoFile can not be -1.
            assertNotEquals(-1, getFileRowIdFromDatabase(videoFile));
            assertEquals(THIS_PACKAGE_NAME, getFileOwnerPackageFromDatabase(videoFile));

            assertTrue(videoFile.delete());
            // videoFile is removed from database on delete, hence row ID is -1.
            assertEquals(-1, getFileRowIdFromDatabase(videoFile));
        } finally {
            videoFile.delete();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testCreateAndRenameDoesntLeaveStaleDBRow_hasRW"	""	"1: permission"	"([4:/android/scopedstorage/cts/legacy/LegacyStorageTest.java]:[permission]:[4]:method_text:[*     * b/150147690,b/150193381: Test that file rename doesn't delete any existing Uri.     */   ]) :|: 
    public void testCreateAndRenameDoesntLeaveStaleDBRow_hasRW() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ true);
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ true);

        final File videoFile = new File(TestUtils.getDcimDir(), VIDEO_FILE_NAME);
        final File renamedVideoFile = new File(TestUtils.getDcimDir(), ""Renamed_"" + VIDEO_FILE_NAME);
        final ContentResolver cr = getContentResolver();

        try {
            assertThat(videoFile.createNewFile()).isTrue();
            assertThat(videoFile.renameTo(renamedVideoFile)).isTrue();

            // Insert new renamedVideoFile to database
            final Uri uri = TestUtils.insertFileUsingDataColumn(renamedVideoFile);
            assertNotNull(uri);

            // Query for all images/videos in the device.
            // This shouldn't list videoFile which was renamed to renamedVideoFile.
            final ArrayList<String> imageAndVideoFiles = getImageAndVideoFilesFromDatabase();
            assertThat(imageAndVideoFiles).contains(renamedVideoFile.getName());
            assertThat(imageAndVideoFiles).doesNotContain(videoFile.getName());
        } finally {
            videoFile.delete();
            renamedVideoFile.delete();
        }
    }

    /**
     * b/150147690,b/150193381: Test that file rename doesn't delete any existing Uri.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testRenameDoesntInvalidateUri_hasRW"	""	"1: permission"	"([4:/android/scopedstorage/cts/legacy/LegacyStorageTest.java]:[permission]:[4]:method_text:[    * b/150498564,b/150274099: Test that apps can rename files that are not in database.     */   ]) :|: 
    public void testRenameDoesntInvalidateUri_hasRW() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ true);
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ true);

        final File imageFile = new File(TestUtils.getDcimDir(), IMAGE_FILE_NAME);
        final File temporaryImageFile = new File(TestUtils.getDcimDir(), IMAGE_FILE_NAME + ""_.tmp"");
        final ContentResolver cr = getContentResolver();

        try {
            assertThat(imageFile.createNewFile()).isTrue();
            try (final FileOutputStream fos = new FileOutputStream(imageFile)) {
                fos.write(BYTES_DATA1);
            }
            // Insert this file to database.
            final Uri uri = TestUtils.insertFileUsingDataColumn(imageFile);
            assertNotNull(uri);

            Files.copy(imageFile, temporaryImageFile);
            // Write more bytes to temporaryImageFile
            try (final FileOutputStream fos = new FileOutputStream(temporaryImageFile, true)) {
                fos.write(BYTES_DATA2);
            }
            assertThat(imageFile.delete()).isTrue();
            temporaryImageFile.renameTo(imageFile);

            // Previous uri of imageFile is unaltered after delete & rename.
            final Uri scannedUri = MediaStore.scanFile(cr, imageFile);
            assertThat(scannedUri.getLastPathSegment()).isEqualTo(uri.getLastPathSegment());

            final byte[] expected = (STR_DATA1 + STR_DATA2).getBytes();
            assertFileContent(imageFile, expected);
        } finally {
            imageFile.delete();
            temporaryImageFile.delete();
        }
    }

    /**
     * b/150498564,b/150274099: Test that apps can rename files that are not in database.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testCanRenameAFileWithNoDBRow_hasRW"	""	"1: permission"	"([4:/android/scopedstorage/cts/legacy/LegacyStorageTest.java]:[permission]:[4]:method_text:[st that legacy apps creating files for existing db row doesn't upsert and set IS_PENDING     */   ]) :|: 
    public void testCanRenameAFileWithNoDBRow_hasRW() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ true);
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ true);

        final File directoryNoMedia = new File(TestUtils.getDcimDir(), "".directoryNoMedia"");
        final File imageInNoMediaDir = new File(directoryNoMedia, IMAGE_FILE_NAME);
        final File renamedImageInDCIM = new File(TestUtils.getDcimDir(), IMAGE_FILE_NAME);
        final File noMediaFile = new File(directoryNoMedia, "".nomedia"");
        final ContentResolver cr = getContentResolver();

        try {
            if (!directoryNoMedia.exists()) {
                assertThat(directoryNoMedia.mkdirs()).isTrue();
            }
            assertThat(noMediaFile.createNewFile()).isTrue();
            assertThat(imageInNoMediaDir.createNewFile()).isTrue();
            // Remove imageInNoMediaDir from database.
            MediaStore.scanFile(cr, directoryNoMedia);

            // Query for all images/videos in the device. This shouldn't list imageInNoMediaDir
            assertThat(getImageAndVideoFilesFromDatabase())
                    .doesNotContain(imageInNoMediaDir.getName());

            // Rename shouldn't throw error even if imageInNoMediaDir is not in database.
            assertThat(imageInNoMediaDir.renameTo(renamedImageInDCIM)).isTrue();
            // We can insert renamedImageInDCIM to database
            ContentValues values = new ContentValues();
            values.put(MediaStore.MediaColumns.DATA, renamedImageInDCIM.getAbsolutePath());
            final Uri uri = TestUtils.insertFileUsingDataColumn(renamedImageInDCIM);
            assertNotNull(uri);
        } finally {
            imageInNoMediaDir.delete();
            renamedImageInDCIM.delete();
            noMediaFile.delete();
            directoryNoMedia.delete();
        }
    }

    /**
     * Test that legacy apps creating files for exis"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testCreateDoesntUpsert"	""	"1: permission"	"([4:/android/scopedstorage/cts/legacy/LegacyStorageTest.java]:[permission]:[4]:method_text:[ld delete the inserted db row.            deleteWithMediaProviderNoThrow(uri);        }    }   ]) :|: 
    public void testCreateDoesntUpsert() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ true);
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ true);

        final File file = new File(TestUtils.getDcimDir(), IMAGE_FILE_NAME);
        Uri uri = null;
        try {
            uri = TestUtils.insertFileUsingDataColumn(file);
            assertNotNull(uri);

            assertTrue(file.createNewFile());

            try (Cursor c = TestUtils.queryFile(file,
                    new String[] {MediaStore.MediaColumns.IS_PENDING})) {
                // This file will not have IS_PENDING=1 because create didn't set IS_PENDING.
                assertTrue(c.moveToFirst());
                assertEquals(c.getInt(0), 0);
            }
        } finally {
            file.delete();
            // If create file fails, we should delete the inserted db row.
            deleteWithMediaProviderNoThrow(uri);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testLegacyAppUpdatingOwnershipOfExistingEntry"	""	"1: permission"	"([4:/android/scopedstorage/cts/legacy/LegacyStorageTest.java]:[permission]:[4]:method_text:[ediaProvider doesn't throw error on usage of unsupported     * or empty/null MIME type.     */   ]) :|: 
    public void testLegacyAppUpdatingOwnershipOfExistingEntry() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ true);
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ true);

        final File fullPath = new File(TestUtils.getDcimDir(),
                ""OwnershipChange"" + IMAGE_FILE_NAME);
        final String relativePath = ""DCIM/OwnershipChange"" + IMAGE_FILE_NAME;
        try {
            createImageEntryAs(APP_B_NO_PERMS, relativePath);
            assertThat(fullPath.createNewFile()).isTrue();

            // We have transferred ownership away from APP_B_NO_PERMS so reads / writes
            // should no longer work.
            assertThat(canOpenFileAs(APP_B_NO_PERMS, fullPath, false /* forWrite */)).isFalse();
            assertThat(canOpenFileAs(APP_B_NO_PERMS, fullPath, true /* forWrite */)).isFalse();
        } finally {
            deleteFileAsNoThrow(APP_B_NO_PERMS, fullPath.getAbsolutePath());
            fullPath.delete();
        }
    }

    /**
     * b/156717256,b/156336269: Test that MediaProvider doesn't throw error on usage of unsupported
     * or empty/null MIME type.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testInsertWithUnsupportedMimeType"	""	"1: permission"	"([4:/android/scopedstorage/cts/legacy/LegacyStorageTest.java]:[permission]:[4]:method_text:[ } finally {                deleteWithMediaProviderNoThrow(uri);            }        }    }   ]) :|: 
    public void testInsertWithUnsupportedMimeType() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ true);
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ true);

        final String IMAGE_FILE_DISPLAY_NAME = ""LegacyStorageTest_file_"" + NONCE;
        final File imageFile = new File(TestUtils.getDcimDir(), IMAGE_FILE_DISPLAY_NAME + "".jpg"");

        for (String mimeType : new String[] {
            ""image/*"", """", null, ""foo/bar""
        }) {
            Uri uri = null;
            try {
                ContentValues values = new ContentValues();
                values.put(MediaStore.MediaColumns.RELATIVE_PATH, Environment.DIRECTORY_DCIM);
                if (TextUtils.isEmpty(mimeType)) {
                    values.put(MediaStore.MediaColumns.DISPLAY_NAME, imageFile.getName());
                } else {
                    values.put(MediaStore.MediaColumns.DISPLAY_NAME, IMAGE_FILE_DISPLAY_NAME);
                }
                values.put(MediaStore.MediaColumns.MIME_TYPE, mimeType);

                uri = getContentResolver().insert(getImageContentUri(), values, Bundle.EMPTY);
                assertNotNull(uri);

                try (final OutputStream fos = getContentResolver().openOutputStream(uri, ""rw"")) {
                    fos.write(BYTES_DATA1);
                }

                // Closing the file should trigger a scan, we still scan again to ensure MIME type
                // is extracted from file extension
                assertNotNull(MediaStore.scanFile(getContentResolver(), imageFile));

                final String[] projection = {MediaStore.MediaColumns.DISPLAY_NAME,
                        MediaStore.MediaColumns.MIME_TYPE};
                try (Cursor c = getContentResolver().query(uri, projection, null, null, null)) {
                    assertTrue(c.moveToFirst());
                    assertEquals(c.getCount(), 1);
                    assertEquals(c.getStr"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testLegacySystemGalleryCanRenameImagesAndVideosWithoutDbUpdates"	""	"1: permission"	"([2:/android/scopedstorage/cts/legacy/LegacyStorageTest.java]:[permission]:[2]:method_text:[e.delete();            denyAppOpsToUid(Process.myUid(), SYSTEM_GALERY_APPOPS);        }    }   ]) :|: 
    public void testLegacySystemGalleryCanRenameImagesAndVideosWithoutDbUpdates() throws Exception {
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ true);

        final File otherAppVideoFile = new File(getDcimDir(), ""other_"" + VIDEO_FILE_NAME);
        final File videoFile = new File(getPicturesDir(), VIDEO_FILE_NAME);

        try {
            allowAppOpsToUid(Process.myUid(), SYSTEM_GALERY_APPOPS);

            // Create and write some data to the file
            assertThat(createFileAs(APP_B_NO_PERMS, otherAppVideoFile.getPath())).isTrue();
            try (FileOutputStream fos = new FileOutputStream(otherAppVideoFile)) {
                fos.write(BYTES_DATA1);
            }

            // Assert legacy system gallery can rename the file.
            assertCanRenameFile(otherAppVideoFile, videoFile, false /* checkDatabase */);
            assertFileContent(videoFile, BYTES_DATA1);
            // Database was not updated.
            assertThat(getFileRowIdFromDatabase(otherAppVideoFile)).isNotEqualTo(-1);
            assertThat(getFileRowIdFromDatabase(videoFile)).isEqualTo(-1);
        } finally {
            otherAppVideoFile.delete();
            videoFile.delete();
            denyAppOpsToUid(Process.myUid(), SYSTEM_GALERY_APPOPS);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testLegacySystemGalleryWithoutWESCannotRename"	""	"1: permission"	"([2:/android/scopedstorage/cts/legacy/LegacyStorageTest.java]:[permission]:[2]:method_text:[e.delete();            denyAppOpsToUid(Process.myUid(), SYSTEM_GALERY_APPOPS);        }    }   ]) :|: 
    public void testLegacySystemGalleryWithoutWESCannotRename() throws Exception {
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ false);

        final File otherAppVideoFile = new File(getDcimDir(), ""other_"" + VIDEO_FILE_NAME);
        final File videoFile = new File(getPicturesDir(), VIDEO_FILE_NAME);

        try {
            allowAppOpsToUid(Process.myUid(), SYSTEM_GALERY_APPOPS);

            // Create file of other app.
            assertThat(createFileAs(APP_B_NO_PERMS, otherAppVideoFile.getPath())).isTrue();

            // Check we cannot rename it.
            assertThat(otherAppVideoFile.renameTo(videoFile)).isFalse();
        } finally {
            otherAppVideoFile.delete();
            videoFile.delete();
            denyAppOpsToUid(Process.myUid(), SYSTEM_GALERY_APPOPS);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testLegacyWESCanRenameImagesAndVideosWithDbUpdates_hasW"	""	"1: permission"	"([2:/android/scopedstorage/cts/legacy/LegacyStorageTest.java]:[permission]:[2]:method_text:[nally {            otherAppVideoFile.delete();            videoFile.delete();        }    }   ]) :|: 
    public void testLegacyWESCanRenameImagesAndVideosWithDbUpdates_hasW() throws Exception {
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ true);

        final File otherAppVideoFile = new File(getDcimDir(), ""other_"" + VIDEO_FILE_NAME);
        final File videoFile = new File(getPicturesDir(), VIDEO_FILE_NAME);

        try {
            // Create and write some data to the file
            assertThat(createFileAs(APP_B_NO_PERMS, otherAppVideoFile.getPath())).isTrue();
            try (FileOutputStream fos = new FileOutputStream(otherAppVideoFile)) {
                fos.write(BYTES_DATA1);
            }

            // Assert legacy WES can rename the file (including database updated).
            assertCanRenameFile(otherAppVideoFile, videoFile);
            assertFileContent(videoFile, BYTES_DATA1);
        } finally {
            otherAppVideoFile.delete();
            videoFile.delete();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.legacy.LegacyStorageTest"	"testScanUpdatesMetadataForNewlyAddedFile_hasRW"	""	"1: permission"	"([4:/android/scopedstorage/cts/legacy/LegacyStorageTest.java]:[permission]:[4]:method_text:[ke sure inserting files from app private directories in legacy apps is allowed via DATA.     */   ]) :|: 
    public void testScanUpdatesMetadataForNewlyAddedFile_hasRW() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ true);
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ true);

        final File jpgFile = new File(getPicturesDir(), IMAGE_FILE_NAME);
        try {
            // Copy the image content to jpgFile
            try (InputStream in =
                         getContext().getResources().openRawResource(R.raw.img_with_metadata);
                 FileOutputStream out = new FileOutputStream(jpgFile)) {
                FileUtils.copy(in, out);
                out.getFD().sync();
            }
            // Insert a new row for jpgFile.
            ContentValues values = new ContentValues();
            values.put(MediaStore.MediaColumns.DATA, jpgFile.getAbsolutePath());
            final Uri targetUri =
                    getContentResolver().insert(getImageContentUri(), values, Bundle.EMPTY);
            assertNotNull(targetUri);

            try (Cursor c = TestUtils.queryFile(jpgFile, MediaStore.MediaColumns.DATE_TAKEN)) {
                // Since the file is not yet scanned, no metadata is available
                assertThat(c.moveToFirst()).isTrue();
                assertThat(c.getString(0)).isNull();
            }

            // Scan the file to update the metadata. This scan shouldn't no-op
            final Uri scanUri = MediaStore.scanFile(getContentResolver(), jpgFile);
            assertNotNull(scanUri);

            // ScanFile was able to update the metadata hence we should see DATE_TAKEN value.
            try (Cursor c = TestUtils.queryFile(jpgFile, MediaStore.MediaColumns.DATE_TAKEN)) {
                assertThat(c.moveToFirst()).isTrue();
                assertThat(c.getString(0)).isNotNull();
            }
        } finally {
            jpgFile.delete();
        }
    }

    /**
     * Make sure inserting files from app private directories in legacy a"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/legacy/src/android/scopedstorage/cts/legacy/LegacyStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.ScopedStorageTest"	"isInstantApp"	""	"1: permission"	"([6:/android/scopedstorage/cts/ScopedStorageTest.java]:[permission]:[6]:method_text:[    }    /**     * This method needs to be called once before running the whole test.     */   ]) :|: /*
 *.
 */

package android.scopedstorage.cts;

import static android.scopedstorage.cts.lib.TestUtils.BYTES_DATA1;
import static android.scopedstorage.cts.lib.TestUtils.adoptShellPermissionIdentity;
import static android.scopedstorage.cts.lib.TestUtils.assertCanAccessPrivateAppAndroidDataDir;
import static android.scopedstorage.cts.lib.TestUtils.assertCanAccessPrivateAppAndroidObbDir;
import static android.scopedstorage.cts.lib.TestUtils.assertCanRenameFile;
import static android.scopedstorage.cts.lib.TestUtils.assertDirectoryContains;
import static android.scopedstorage.cts.lib.TestUtils.assertFileContent;
import static android.scopedstorage.cts.lib.TestUtils.assertMountMode;
import static android.scopedstorage.cts.lib.TestUtils.assertThrows;
import static android.scopedstorage.cts.lib.TestUtils.canOpen;
import static android.scopedstorage.cts.lib.TestUtils.canReadAndWriteAs;
import static android.scopedstorage.cts.lib.TestUtils.createFileAs;
import static android.scopedstorage.cts.lib.TestUtils.deleteFileAs;
import static android.scopedstorage.cts.lib.TestUtils.deleteFileAsNoThrow;
import static android.scopedstorage.cts.lib.TestUtils.dropShellPermissionIdentity;
import static android.scopedstorage.cts.lib.TestUtils.executeShellCommand;
import static android.scopedstorage.cts.lib.TestUtils.getAndroidDir;
import static android.scopedstorage.cts.lib.TestUtils.getAndroidMediaDir;
import static android.scopedstorage.cts.lib.TestUtils.getContentResolver;
import static android.scopedstorage.cts.lib.TestUtils.getDcimDir;
import static android.scopedstorage.cts.lib.TestUtils.getDefaultTopLevelDirs;
import static android.scopedstorage.cts.lib.TestUtils.getDownloadDir;
import static android.scopedstorage.cts.lib.TestUtils.getExternalFilesDir;
import static android.scopedstorage.cts.lib.TestUtils.getExternalMediaDir;
import static android.scopedstorage.cts.lib.TestUtils.getExternalStorageDir;
import static android.scopedstorage.cts.lib.TestUtils.getFileOwnerPackageFromDataba"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/src/android/scopedstorage/cts/ScopedStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.ScopedStorageTest"	"testManageExternalStorageCantReadWriteOtherAppExternalDir"	""	"1: permission"	"([1:/android/scopedstorage/cts/ScopedStorageTest.java]:[permission]:[1]:method_text:[() -> {                    otherAppExternalDataFile.createNewFile();                });    }   ]) :|: 
    public void testManageExternalStorageCantReadWriteOtherAppExternalDir() throws Exception {
        pollForManageExternalStorageAllowed();

        // Let app A create a file in its data dir
        final File otherAppExternalDataDir = new File(getExternalFilesDir().getPath().replace(
                THIS_PACKAGE_NAME, APP_A_HAS_RES.getPackageName()));
        final File otherAppExternalDataFile = new File(otherAppExternalDataDir,
                NONMEDIA_FILE_NAME);
        assertCreateFilesAs(APP_A_HAS_RES, otherAppExternalDataFile);

        // File Manager app gets global access with MANAGE_EXTERNAL_STORAGE permission, however,
        // file manager app doesn't have access to other app's external files directory
        assertThat(canOpen(otherAppExternalDataFile, /* forWrite */ false)).isFalse();
        assertThat(canOpen(otherAppExternalDataFile, /* forWrite */ true)).isFalse();
        assertThat(otherAppExternalDataFile.delete()).isFalse();

        assertThat(deleteFileAs(APP_A_HAS_RES, otherAppExternalDataFile.getPath())).isTrue();

        assertThrows(IOException.class,
                () -> {
                    otherAppExternalDataFile.createNewFile();
                });
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/src/android/scopedstorage/cts/ScopedStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.ScopedStorageTest"	"testAccess_file"	""	"1: permission"	"([2:/android/scopedstorage/cts/ScopedStorageTest.java]:[permission]:[2]:method_text:[.scanFile(getContentResolver(), shellPdfAtRoot);            myAppPdf.delete();        }    }   ]) :|: 
    public void testAccess_file() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ true);

        final File downloadDir = getDownloadDir();
        final File otherAppPdf = new File(downloadDir, ""other-"" + NONMEDIA_FILE_NAME);
        final File shellPdfAtRoot = new File(getExternalStorageDir(),
                ""shell-"" + NONMEDIA_FILE_NAME);
        final File otherAppImage = new File(getDcimDir(), ""other-"" + IMAGE_FILE_NAME);
        final File myAppPdf = new File(downloadDir, ""my-"" + NONMEDIA_FILE_NAME);
        final File doesntExistPdf = new File(downloadDir, ""nada-"" + NONMEDIA_FILE_NAME);

        try {
            assertThat(createFileAs(APP_B_NO_PERMS, otherAppPdf.getPath())).isTrue();
            assertThat(createFileAs(APP_B_NO_PERMS, otherAppImage.getPath())).isTrue();

            // We can read our image and pdf files.
            assertThat(myAppPdf.createNewFile()).isTrue();
            assertFileAccess_readWrite(myAppPdf);

            // We can read the other app's image file because we hold R_E_S, but we can
            // check only exists for the pdf files.
            assertFileAccess_readOnly(otherAppImage);
            assertFileAccess_existsOnly(otherAppPdf);
            assertAccess(doesntExistPdf, false, false, false);

            // We can check only exists for another app's files on root.
            createFileAsLegacyApp(shellPdfAtRoot);
            MediaStore.scanFile(getContentResolver(), shellPdfAtRoot);
            assertFileAccess_existsOnly(shellPdfAtRoot);
        } finally {
            deleteFileAsNoThrow(APP_B_NO_PERMS, otherAppPdf.getAbsolutePath());
            deleteFileAsNoThrow(APP_B_NO_PERMS, otherAppImage.getAbsolutePath());
            deleteAsLegacyApp(shellPdfAtRoot);
            MediaStore.scanFile(getContentResolver(), shellPdfAtRoot);
            myAppPdf.delete();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/src/android/scopedstorage/cts/ScopedStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.ScopedStorageTest"	"testAccess_directory"	""	"1: permission"	"([4:/android/scopedstorage/cts/ScopedStorageTest.java]:[permission]:[4]:method_text:[ false, false);        } finally {            deleteAsLegacyApp(topLevelDir);        }    }   ]) :|: 
    public void testAccess_directory() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ true);
        pollForPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE, /*granted*/ true);
        File topLevelDir = new File(getExternalStorageDir(), ""Test"");
        try {
            // Let app B create a file in its data dir
            final File otherAppExternalDataDir = new File(getExternalFilesDir().getPath().replace(
                    THIS_PACKAGE_NAME, APP_B_NO_PERMS.getPackageName()));
            final File otherAppExternalDataSubDir = new File(otherAppExternalDataDir, ""subdir"");
            final File otherAppExternalDataFile = new File(otherAppExternalDataSubDir, ""abc.jpg"");
            assertThat(createFileAs(APP_B_NO_PERMS, otherAppExternalDataFile.getAbsolutePath()))
                    .isTrue();

            // We cannot read or write the file, but app B can.
            assertThat(canReadAndWriteAs(APP_B_NO_PERMS,
                    otherAppExternalDataFile.getAbsolutePath())).isTrue();
            assertCannotReadOrWrite(otherAppExternalDataFile);

            // We cannot read or write the dir, but app B can.
            assertThat(canReadAndWriteAs(APP_B_NO_PERMS,
                    otherAppExternalDataDir.getAbsolutePath())).isTrue();
            assertCannotReadOrWrite(otherAppExternalDataDir);

            // We cannot read or write the sub dir, but app B can.
            assertThat(canReadAndWriteAs(APP_B_NO_PERMS,
                    otherAppExternalDataSubDir.getAbsolutePath())).isTrue();
            assertCannotReadOrWrite(otherAppExternalDataSubDir);

            // We can read and write our own app dir, but app B cannot.
            assertThat(canReadAndWriteAs(APP_B_NO_PERMS,
                    getExternalFilesDir().getAbsolutePath())).isFalse();
            assertCanAccessMyAppFile(getExternalFilesDir());

            assertDirectoryAccess(getDcimDir(), /* exists */ true, /* canWrite"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/src/android/scopedstorage/cts/ScopedStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.ScopedStorageTest"	"testAndroidMedia"	""	"1: permission"	"([2:/android/scopedstorage/cts/ScopedStorageTest.java]:[permission]:[2]:method_text:[ERMS);        assertSharedStorageAccess(getDcimDir(), getDownloadDir(), APP_B_NO_PERMS);    }   ]) :|: 
    public void testAndroidMedia() throws Exception {
        // Check that the app does not have legacy external storage access
        if (isAtLeastS()) {
            assertThat(Environment.isExternalStorageLegacy()).isFalse();
        }

        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ true);

        final File myMediaDir = getExternalMediaDir();
        final File otherAppMediaDir = new File(myMediaDir.getAbsolutePath()
                .replace(THIS_PACKAGE_NAME, APP_B_NO_PERMS.getPackageName()));

        // Verify that accessing other app's /sdcard/Android/media behaves exactly like DCIM for
        // image files and exactly like Downloads for documents.
        assertSharedStorageAccess(otherAppMediaDir, otherAppMediaDir, APP_B_NO_PERMS);
        assertSharedStorageAccess(getDcimDir(), getDownloadDir(), APP_B_NO_PERMS);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/src/android/scopedstorage/cts/ScopedStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.ScopedStorageTest"	"testWallpaperApisNoPermission"	""	"1: permission"	"([1:/android/scopedstorage/cts/ScopedStorageTest.java]:[permission]:[1]:method_text:[,                () -> wallpaperManager.getWallpaperFile(WallpaperManager.FLAG_SYSTEM));    }   ]) :|: 
    public void testWallpaperApisNoPermission() throws Exception {
        WallpaperManager wallpaperManager = WallpaperManager.getInstance(getContext());
        assumeTrue(""Test skipped as wallpaper is not supported."",
                wallpaperManager.isWallpaperSupported());
        assertThrows(SecurityException.class, () -> wallpaperManager.getFastDrawable());
        assertThrows(SecurityException.class, () -> wallpaperManager.peekFastDrawable());
        assertThrows(SecurityException.class,
                () -> wallpaperManager.getWallpaperFile(WallpaperManager.FLAG_SYSTEM));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/src/android/scopedstorage/cts/ScopedStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.ScopedStorageTest"	"testWallpaperApisReadExternalStorage"	""	"1: permission"	"([2:/android/scopedstorage/cts/ScopedStorageTest.java]:[permission]:[2]:method_text:[kFastDrawable();        wallpaperManager.getWallpaperFile(WallpaperManager.FLAG_SYSTEM);    }   ]) :|: 
    public void testWallpaperApisReadExternalStorage() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ true);
        WallpaperManager wallpaperManager = WallpaperManager.getInstance(getContext());
        wallpaperManager.getFastDrawable();
        wallpaperManager.peekFastDrawable();
        wallpaperManager.getWallpaperFile(WallpaperManager.FLAG_SYSTEM);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/src/android/scopedstorage/cts/ScopedStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.ScopedStorageTest"	"testWallpaperApisManageExternalStoragePrivileged"	""	"1: permission"	"([3:/android/scopedstorage/cts/ScopedStorageTest.java]:[permission]:[3]:method_text:[   }    /**     * Test that File Manager can't insert files from private directories.     */   ]) :|: 
    public void testWallpaperApisManageExternalStoragePrivileged() throws Exception {
        adoptShellPermissionIdentity(Manifest.permission.MANAGE_EXTERNAL_STORAGE);
        try {
            WallpaperManager wallpaperManager = WallpaperManager.getInstance(getContext());
            wallpaperManager.getFastDrawable();
            wallpaperManager.peekFastDrawable();
            wallpaperManager.getWallpaperFile(WallpaperManager.FLAG_SYSTEM);
        } finally {
            dropShellPermissionIdentity();
        }
    }

    /**
     * Test that File Manager can't insert files from private directories.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/src/android/scopedstorage/cts/ScopedStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.ScopedStorageTest"	"testOpenOtherPendingFilesFromFuse"	""	"1: permission"	"([2:/android/scopedstorage/cts/ScopedStorageTest.java]:[permission]:[2]:method_text:[       deleteFileAsNoThrow(APP_B_NO_PERMS, otherPendingFile.getAbsolutePath());        }    }   ]) :|: 
    public void testOpenOtherPendingFilesFromFuse() throws Exception {
        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ true);
        final File otherPendingFile = new File(getDcimDir(), IMAGE_FILE_NAME);
        try {
            assertCreateFilesAs(APP_B_NO_PERMS, otherPendingFile);

            // We can read other app's pending file from FUSE via filePath
            assertCanQueryAndOpenFile(otherPendingFile, ""r"");

            // We can also read other app's pending file via MediaStore API
            assertNotNull(openWithMediaProvider(otherPendingFile, ""r""));
        } finally {
            deleteFileAsNoThrow(APP_B_NO_PERMS, otherPendingFile.getAbsolutePath());
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/src/android/scopedstorage/cts/ScopedStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.ScopedStorageTest"	"testNoIsolatedStorageCantReadWriteOtherAppExternalDir"	""	"1: permission"	"([1:/android/scopedstorage/cts/ScopedStorageTest.java]:[permission]:[1]:method_text:[() -> {                    otherAppExternalDataFile.createNewFile();                });    }   ]) :|: 
    public void testNoIsolatedStorageCantReadWriteOtherAppExternalDir() throws Exception {
        if (isAtLeastS()) {
            assertThat(Environment.isExternalStorageLegacy()).isTrue();
        }
        // Let app A create a file in its data dir
        final File otherAppExternalDataDir = new File(getExternalFilesDir().getPath().replace(
                THIS_PACKAGE_NAME, APP_A_HAS_RES.getPackageName()));
        final File otherAppExternalDataFile = new File(otherAppExternalDataDir,
                NONMEDIA_FILE_NAME);
        assertCreateFilesAs(APP_A_HAS_RES, otherAppExternalDataFile);

        // File Manager app gets global access with MANAGE_EXTERNAL_STORAGE permission, however,
        // file manager app doesn't have access to other app's external files directory
        assertThat(canOpen(otherAppExternalDataFile, /* forWrite */ false)).isFalse();
        assertThat(canOpen(otherAppExternalDataFile, /* forWrite */ true)).isFalse();
        assertThat(otherAppExternalDataFile.delete()).isFalse();

        assertThat(deleteFileAs(APP_A_HAS_RES, otherAppExternalDataFile.getPath())).isTrue();

        assertThrows(IOException.class,
                () -> {
                    otherAppExternalDataFile.createNewFile();
                });
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/src/android/scopedstorage/cts/ScopedStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.ScopedStorageTest"	"testClearPackageData"	""	"1: permission"	"([2:/android/scopedstorage/cts/ScopedStorageTest.java]:[permission]:[2]:method_text:[        }    }    /**     * Tests that an instant app can't access external storage.     */   ]) :|: 
    public void testClearPackageData() throws Exception {
        // Check that the app does not have legacy external storage access
        if (isAtLeastS()) {
            assertThat(Environment.isExternalStorageLegacy()).isFalse();
        }

        pollForPermission(Manifest.permission.READ_EXTERNAL_STORAGE, /*granted*/ true);

        File fileToRemain = new File(getPicturesDir(), IMAGE_FILE_NAME);
        String testAppPackageName = APP_B_NO_PERMS.getPackageName();
        File fileToBeDeleted =
                new File(
                        getAndroidMediaDir(),
                        String.format(""%s/%s"", testAppPackageName, IMAGE_FILE_NAME));
        File nestedFileToBeDeleted =
                new File(
                        getAndroidMediaDir(),
                        String.format(""%s/nesteddir/%s"", testAppPackageName, IMAGE_FILE_NAME));

        try {
            createAndCheckFileAsApp(APP_B_NO_PERMS, fileToRemain);
            createAndCheckFileAsApp(APP_B_NO_PERMS, fileToBeDeleted);
            createAndCheckFileAsApp(APP_B_NO_PERMS, nestedFileToBeDeleted);

            executeShellCommand(""pm clear --user "" + getCurrentUser() + "" "" + testAppPackageName);

            // Wait a max of 5 seconds for the cleaning after ""pm clear"" command to complete.
            int i = 0;
            while(i < 10 && getFileRowIdFromDatabase(fileToBeDeleted) != -1
                && getFileRowIdFromDatabase(nestedFileToBeDeleted) != -1) {
                Thread.sleep(500);
                i++;
            }

            assertThat(getFileOwnerPackageFromDatabase(fileToRemain)).isNull();
            assertThat(getFileRowIdFromDatabase(fileToRemain)).isNotEqualTo(-1);

            assertThat(getFileOwnerPackageFromDatabase(fileToBeDeleted)).isNull();
            assertThat(getFileRowIdFromDatabase(fileToBeDeleted)).isEqualTo(-1);

            assertThat(getFileOwnerPackageFromDatabase(nestedFileToBeDeleted)).isNull();
            assertThat(getFileRowIdFromDatab"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/src/android/scopedstorage/cts/ScopedStorageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.BypassDatabaseOperationsTest"	"getTestParameters"	""	"1: permission"	"([12:/android/scopedstorage/cts/device/BypassDatabaseOperationsTest.java]:[permission]:[12]:method_text:[ targeting     * targetSDK=31 or higher will not bypass database operations by default.     */   ]) :|: /*
 *.
 */

package android.scopedstorage.cts.device;

import static android.app.AppOpsManager.permissionToOp;
import static android.scopedstorage.cts.lib.TestUtils.allowAppOpsToUid;
import static android.scopedstorage.cts.lib.TestUtils.createFileAs;
import static android.scopedstorage.cts.lib.TestUtils.deleteFileAs;
import static android.scopedstorage.cts.lib.TestUtils.deleteFileAsNoThrow;
import static android.scopedstorage.cts.lib.TestUtils.denyAppOpsToUid;
import static android.scopedstorage.cts.lib.TestUtils.getContentResolver;
import static android.scopedstorage.cts.lib.TestUtils.getDcimDir;
import static android.scopedstorage.cts.lib.TestUtils.getPicturesDir;
import static android.scopedstorage.cts.lib.TestUtils.installApp;
import static android.scopedstorage.cts.lib.TestUtils.installAppWithStoragePermissions;
import static android.scopedstorage.cts.lib.TestUtils.renameFileAs;
import static android.scopedstorage.cts.lib.TestUtils.uninstallAppNoThrow;

import static androidx.test.InstrumentationRegistry.getContext;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;

import android.Manifest;
import android.app.AppOpsManager;
import android.provider.MediaStore;
import android.scopedstorage.cts.lib.TestUtils;
import android.util.Log;

import androidx.test.filters.SdkSuppress;

import com.android.cts.install.lib.TestApp;

import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameter;
import org.junit.runners.Parameterized.Parameters;

import java.io.File;

/**
 * Device-side test suite to verify file path operations optionally bypassing database operations.
 */
@RunWith(Parameterized.class)
public class BypassDatabaseOperationsTest extends ScopedStorageBaseDeviceTest {
    static final String TAG = ""BypassDatabaseOperationsTest"";"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/BypassDatabaseOperationsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.BypassDatabaseOperationsTest"	"testManageExternalStorage_DoesntBypassDatabase_afterS"	""	"1: permission"	"([1:/android/scopedstorage/cts/device/BypassDatabaseOperationsTest.java]:[permission]:[1]:method_text:[er and with requestRawExternalStorageAccess=true     * will bypass database operations.     */   ]) :|: 
    @SdkSuppress(minSdkVersion = 31, codeName = ""S"")
    public void testManageExternalStorage_DoesntBypassDatabase_afterS() throws Exception {
        testAppDoesntBypassDatabaseOps(APP_FM_DEFAULT);
    }

    /**
     * Test that app with MANAGE_EXTERNAL_STORAGE permission, targeting
     * targetSDK=31 or higher and with requestRawExternalStorageAccess=true
     * will bypass database operations.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/BypassDatabaseOperationsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.BypassDatabaseOperationsTest"	"testManageExternalStorage_WithBypassFlag_BypassesDatabase"	""	"1: permission"	"([1:/android/scopedstorage/cts/device/BypassDatabaseOperationsTest.java]:[permission]:[1]:method_text:[n and targeting     * targetSDK=30 or lower will bypass database operations by default.     */   ]) :|: 
    @SdkSuppress(minSdkVersion = 31, codeName = ""S"")
    public void testManageExternalStorage_WithBypassFlag_BypassesDatabase() throws Exception {
        installApp(APP_FM_BYPASS_DATABASE_OPS);
        try {
            final int fmUid =
                    getContext().getPackageManager().getPackageUid(
                            APP_FM_BYPASS_DATABASE_OPS.getPackageName(), 0);
            allowAppOpsToUid(fmUid, OPSTR_MANAGE_EXTERNAL_STORAGE);
            testAppBypassesDatabaseOps(APP_FM_BYPASS_DATABASE_OPS);
        } finally {
            uninstallAppNoThrow(APP_FM_BYPASS_DATABASE_OPS);
        }
    }

    /**
     * Test that app with MANAGE_EXTERNAL_STORAGE permission and targeting
     * targetSDK=30 or lower will bypass database operations by default.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/BypassDatabaseOperationsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.BypassDatabaseOperationsTest"	"testSystemGallery_WithBypassFlag_BypassesDatabase"	""	"1: permission"	"([1:/android/scopedstorage/cts/device/BypassDatabaseOperationsTest.java]:[permission]:[1]:method_text:[ targeting     * targetSDK=30 or higher will not bypass database operations by default.     */   ]) :|: 
    @SdkSuppress(minSdkVersion = 31, codeName = ""S"")
    public void testSystemGallery_WithBypassFlag_BypassesDatabase() throws Exception {
        installAppWithStoragePermissions(APP_SYSTEM_GALLERY_BYPASS_DB);
        try {
            final int sgUid =
                    getContext().getPackageManager().getPackageUid(
                            APP_SYSTEM_GALLERY_BYPASS_DB.getPackageName(), 0);
            allowAppOpsToUid(sgUid, SYSTEM_GALLERY_APPOPS);
            testAppBypassesDatabaseOps(APP_SYSTEM_GALLERY_BYPASS_DB);
        } finally {
            uninstallAppNoThrow(APP_SYSTEM_GALLERY_BYPASS_DB);
        }
    }

    /**
     * Test that app with SYSTEM_GALLERY role and targeting
     * targetSDK=30 or higher will not bypass database operations by default.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/BypassDatabaseOperationsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.BypassDatabaseOperationsTest"	"testSystemGallery_targets30_DoesntBypassDatabase"	""	"1: permission"	"([1:/android/scopedstorage/cts/device/BypassDatabaseOperationsTest.java]:[permission]:[1]:method_text:[nd with requestOptimizedSystemGalleryAccess=true     * will bypass database operations.     */   ]) :|: 
    public void testSystemGallery_targets30_DoesntBypassDatabase() throws Exception {
        installAppWithStoragePermissions(APP_SYSTEM_GALLERY_30);
        try {
            final int sgUid =
                    getContext().getPackageManager().getPackageUid(
                            APP_SYSTEM_GALLERY_30.getPackageName(), 0);
            allowAppOpsToUid(sgUid, SYSTEM_GALLERY_APPOPS);
            testAppDoesntBypassDatabaseOps(APP_SYSTEM_GALLERY_30);
        } finally {
            uninstallAppNoThrow(APP_SYSTEM_GALLERY_30);
        }
    }

    /**
     * Test that app with SYSTEM_GALLERY role, targeting
     * targetSDK=30 or higher and with requestOptimizedSystemGalleryAccess=true
     * will bypass database operations.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/BypassDatabaseOperationsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.BypassDatabaseOperationsTest"	"testSystemGallery_targets30_WithBypassFlag_BypassesDatabase"	""	"1: permission"	"([1:/android/scopedstorage/cts/device/BypassDatabaseOperationsTest.java]:[permission]:[1]:method_text:[lver(), file);            MediaStore.scanFile(getContentResolver(), renamedFile);        }    }}]) :|: 
    @SdkSuppress(minSdkVersion = 31, codeName = ""S"")
    public void testSystemGallery_targets30_WithBypassFlag_BypassesDatabase() throws Exception {
        installAppWithStoragePermissions(APP_SYSTEM_GALLERY_30_BYPASS_DB);
        try {
            final int sgUid =
                    getContext().getPackageManager().getPackageUid(
                            APP_SYSTEM_GALLERY_30_BYPASS_DB.getPackageName(), 0);
            allowAppOpsToUid(sgUid, SYSTEM_GALLERY_APPOPS);
            testAppBypassesDatabaseOps(APP_SYSTEM_GALLERY_30_BYPASS_DB);
        } finally {
            uninstallAppNoThrow(APP_SYSTEM_GALLERY_30_BYPASS_DB);
        }
    }

    private void testAppDoesntBypassDatabaseOps(TestApp app) throws Exception {
        final File file = new File(getDcimDir(), IMAGE_FILE_NAME);
        final File renamedFile = new File(getPicturesDir(), IMAGE_FILE_NAME);
        try {
            assertThat(createFileAs(app, file.getAbsolutePath())).isTrue();
            // File path create() added file to database.
            assertThat(TestUtils.checkDatabaseRowExistsAs(app, file)).isTrue();

            assertThat(renameFileAs(app, file, renamedFile)).isTrue();
            // File path rename() also updates the database row
            assertThat(TestUtils.checkDatabaseRowExistsAs(app, file)).isFalse();
            assertThat(TestUtils.checkDatabaseRowExistsAs(app, renamedFile)).isTrue();

            assertThat(deleteFileAs(app, renamedFile.getAbsolutePath())).isTrue();
            // File path delete() removes database row.
            assertThat(TestUtils.checkDatabaseRowExistsAs(app, renamedFile)).isFalse();
        } finally {
            if (file.exists()) {
                deleteFileAsNoThrow(app, file.getAbsolutePath());
            }
            if (renamedFile.exists()) {
                deleteFileAsNoThrow(app, renamedFile.getAbsolutePath());
            }
        }
    }

    private void testAppBypassesDatabaseOps(TestApp app) throws Exception {"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/BypassDatabaseOperationsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.RedactUriDeviceTest"	"getTestParameters"	""	"1: permission"	"([7:/android/scopedstorage/cts/device/RedactUriDeviceTest.java]:[permission]:[7]:method_text:[  @AfterClass    public static void destroy() {        setShouldForceStopTestApp(true);    }   ]) :|: /*
 *.
 */

package android.scopedstorage.cts.device;


import static android.content.Intent.FLAG_GRANT_READ_URI_PERMISSION;
import static android.database.Cursor.FIELD_TYPE_BLOB;
import static android.scopedstorage.cts.lib.TestUtils.assertThrows;
import static android.scopedstorage.cts.lib.TestUtils.canOpenRedactedUriForWrite;
import static android.scopedstorage.cts.lib.TestUtils.canQueryOnUri;
import static android.scopedstorage.cts.lib.TestUtils.checkPermission;
import static android.scopedstorage.cts.lib.TestUtils.forceStopApp;
import static android.scopedstorage.cts.lib.TestUtils.getContentResolver;
import static android.scopedstorage.cts.lib.TestUtils.grantPermission;
import static android.scopedstorage.cts.lib.TestUtils.installAppWithStoragePermissions;
import static android.scopedstorage.cts.lib.TestUtils.isFileDescriptorRedacted;
import static android.scopedstorage.cts.lib.TestUtils.isFileOpenRedacted;
import static android.scopedstorage.cts.lib.TestUtils.setShouldForceStopTestApp;
import static android.scopedstorage.cts.lib.TestUtils.uninstallAppNoThrow;

import static androidx.test.InstrumentationRegistry.getContext;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;

import android.Manifest;
import android.content.ContentValues;
import android.content.Intent;
import android.database.Cursor;
import android.media.ExifInterface;
import android.net.Uri;
import android.os.Bundle;
import android.os.Environment;
import android.os.FileUtils;
import android.provider.MediaStore;

import androidx.test.filters.SdkSuppress;

import com.android.cts.install.lib.TestApp;

import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;

import java.io.File;
import java.io.FileDescriptor;
import j"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/RedactUriDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.RedactUriDeviceTest"	"testSharedRedactedUri_openFdForWrite"	""	"1: permission"	"([1:/android/scopedstorage/cts/device/RedactUriDeviceTest.java]:[permission]:[1]:method_text:[h correct permission can open the shared redacted URI for read in     * redacted mode.     **/   ]) :|: 
    public void testSharedRedactedUri_openFdForWrite() throws Exception {
        forceStopApp(APP_B_NO_PERMS.getPackageName());
        final File img = stageImageFileWithMetadata(IMAGE_FILE_NAME);
        try {
            Uri redactedUri = shareAndGetRedactedUri(img, APP_B_NO_PERMS);
            assertThrows(UnsupportedOperationException.class,
                    () -> canOpenRedactedUriForWrite(APP_B_NO_PERMS, redactedUri));
        } finally {
            img.delete();
        }
    }

    /*
     * Verify that app with correct permission can open the shared redacted URI for read in
     * redacted mode.
     **/"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/RedactUriDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.RedactUriDeviceTest"	"testSharedRedactedUri_openFdForRead"	""	"1: permission"	"([1:/android/scopedstorage/cts/device/RedactUriDeviceTest.java]:[permission]:[1]:method_text:[h correct permission can open the shared redacted URI for read in     * redacted mode.     **/   ]) :|: 
    public void testSharedRedactedUri_openFdForRead() throws Exception {
        forceStopApp(APP_B_NO_PERMS.getPackageName());
        final File img = stageImageFileWithMetadata(IMAGE_FILE_NAME);
        try {
            final Uri redactedUri = shareAndGetRedactedUri(img, APP_B_NO_PERMS);
            assertThat(isFileDescriptorRedacted(APP_B_NO_PERMS, redactedUri)).isTrue();
        } finally {
            img.delete();
        }
    }

    /*
     * Verify that app with correct permission can open the shared redacted URI for read in
     * redacted mode.
     **/"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/RedactUriDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.RedactUriDeviceTest"	"testSharedRedactedUri_query"	""	"1: permission"	"([1:/android/scopedstorage/cts/device/RedactUriDeviceTest.java]:[permission]:[1]:method_text:[y that for app with AML permission shared redacted URI opens for read in redacted mode.     **/   ]) :|: 
    public void testSharedRedactedUri_query() throws Exception {
        forceStopApp(APP_B_NO_PERMS.getPackageName());
        final File img = stageImageFileWithMetadata(IMAGE_FILE_NAME);
        try {
            Uri redactedUri = shareAndGetRedactedUri(img, APP_B_NO_PERMS);
            assertThat(canQueryOnUri(APP_B_NO_PERMS, redactedUri)).isTrue();
        } finally {
            img.delete();
        }
    }

    /*
     * Verify that for app with AML permission shared redacted URI opens for read in redacted mode.
     **/"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/RedactUriDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.RedactUriDeviceTest"	"testSharedRedactedUri_openFileForRead_withLocationPerm"	""	"1: permission"	"([4:/android/scopedstorage/cts/device/RedactUriDeviceTest.java]:[permission]:[4]:method_text:[y that for app with AML permission shared redacted URI opens for read in redacted mode.     **/   ]) :|: 
    public void testSharedRedactedUri_openFileForRead_withLocationPerm() throws Exception {
        final File img = stageImageFileWithMetadata(IMAGE_FILE_NAME);
        try {
            // Install test app
            installAppWithStoragePermissions(APP_C);
            grantPermission(APP_C.getPackageName(), Manifest.permission.ACCESS_MEDIA_LOCATION);

            Uri redactedUri = shareAndGetRedactedUri(img, APP_C);
            assertThat(isFileOpenRedacted(APP_C, redactedUri)).isTrue();
        } finally {
            img.delete();
            uninstallAppNoThrow(APP_C);
        }
    }

    /*
     * Verify that for app with AML permission shared redacted URI opens for read in redacted mode.
     **/"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/RedactUriDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.RedactUriDeviceTest"	"testSharedRedactedUri_openFdForRead_withLocationPerm"	""	"1: permission"	"([3:/android/scopedstorage/cts/device/RedactUriDeviceTest.java]:[permission]:[3]:method_text:[     * Verify that the test app can't access unshared redacted uri via file descriptor     **/   ]) :|: 
    public void testSharedRedactedUri_openFdForRead_withLocationPerm() throws Exception {
        final File img = stageImageFileWithMetadata(IMAGE_FILE_NAME);
        try {
            // Install test app
            installAppWithStoragePermissions(APP_C);
            grantPermission(APP_C.getPackageName(), Manifest.permission.ACCESS_MEDIA_LOCATION);

            Uri redactedUri = shareAndGetRedactedUri(img, APP_C);
            assertThat(isFileDescriptorRedacted(APP_C, redactedUri)).isTrue();
        } finally {
            img.delete();
            uninstallAppNoThrow(APP_C);
        }
    }

    /*
     * Verify that the test app can't access unshared redacted uri via file descriptor
     **/"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/RedactUriDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.RedactUriDeviceTest"	"testUnsharedRedactedUri_openFdForRead"	""	"1: permission"	"([1:/android/scopedstorage/cts/device/RedactUriDeviceTest.java]:[permission]:[1]:method_text:[    /*     * Verify that the test app can't access unshared redacted uri via file path     **/   ]) :|: 
    public void testUnsharedRedactedUri_openFdForRead() throws Exception {
        forceStopApp(APP_B_NO_PERMS.getPackageName());
        final File img = stageImageFileWithMetadata(IMAGE_FILE_NAME);
        try {
            // Install test app
            installAppWithStoragePermissions(APP_C);

            final Uri redactedUri = getRedactedUri(img);
            // APP_C has R_E_S, so should have access to redactedUri
            assertThat(isFileDescriptorRedacted(APP_C, redactedUri)).isTrue();
            assertThrows(SecurityException.class,
                    () -> isFileDescriptorRedacted(APP_B_NO_PERMS, redactedUri));
        } finally {
            img.delete();
            uninstallAppNoThrow(APP_C);
        }
    }

    /*
     * Verify that the test app can't access unshared redacted uri via file path
     **/"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/RedactUriDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.RedactUriDeviceTest"	"testUnsharedRedactedUri_openFileForRead"	""	"1: permission"	"([1:/android/scopedstorage/cts/device/RedactUriDeviceTest.java]:[permission]:[1]:method_text:[  } finally {            img.delete();            uninstallAppNoThrow(APP_C);        }    }   ]) :|: 
    public void testUnsharedRedactedUri_openFileForRead() throws Exception {
        forceStopApp(APP_B_NO_PERMS.getPackageName());
        final File img = stageImageFileWithMetadata(IMAGE_FILE_NAME);
        try {
            // Install test app
            installAppWithStoragePermissions(APP_C);

            final Uri redactedUri = getRedactedUri(img);
            // APP_C has R_E_S
            assertThat(isFileOpenRedacted(APP_C, redactedUri)).isTrue();
            assertThrows(IOException.class, () -> isFileOpenRedacted(APP_B_NO_PERMS, redactedUri));
        } finally {
            img.delete();
            uninstallAppNoThrow(APP_C);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/RedactUriDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.RedactUriDeviceTest"	"testGrantUriPermissionsForRedactedUri"	""	"1: permission"	"([5:/android/scopedstorage/cts/device/RedactUriDeviceTest.java]:[permission]:[5]:method_text:[LAG_GRANT_WRITE_URI_PERMISSION));        } finally {            img.delete();        }    }   ]) :|: 
    public void testGrantUriPermissionsForRedactedUri() throws Exception {
        final File img = stageImageFileWithMetadata(IMAGE_FILE_NAME);
        final Uri redactedUri = getRedactedUri(img);
        try {
            getContext().grantUriPermission(APP_B_NO_PERMS.getPackageName(), redactedUri,
                    FLAG_GRANT_READ_URI_PERMISSION);
            assertThrows(SecurityException.class, () ->
                    getContext().grantUriPermission(APP_B_NO_PERMS.getPackageName(), redactedUri,
                            Intent.FLAG_GRANT_WRITE_URI_PERMISSION));
        } finally {
            img.delete();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/RedactUriDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.RedactUriDeviceTest"	"testOpenOnRedactedUri_read"	""	"1: permission"	"([2:/android/scopedstorage/cts/device/RedactUriDeviceTest.java]:[permission]:[2]:method_text:[have to external storage            FileUtils.copy(in, out);        }        return img;    }}]) :|: 
    public void testOpenOnRedactedUri_read() throws Exception {
        final File img = stageImageFileWithMetadata(IMAGE_FILE_NAME);
        final Uri redactedUri = getRedactedUri(img);
        try {
            assertUriIsUnredacted(img);

            FileDescriptor fd = getContentResolver().openFileDescriptor(redactedUri,
                    ""r"").getFileDescriptor();
            ExifInterface redactedExifInf = new ExifInterface(fd);
            assertUriIsRedacted(redactedExifInf);
        } finally {
            img.delete();
        }
    }

    private void testRedactedUriCommon(Uri uri, Uri redactedUri) {
        assertEquals(redactedUri.getAuthority(), uri.getAuthority());
        assertEquals(redactedUri.getScheme(), uri.getScheme());
        assertNotEquals(redactedUri.getPath(), uri.getPath());
        assertNotEquals(redactedUri.getPathSegments(), uri.getPathSegments());

        final String uriId = redactedUri.getLastPathSegment();
        assertThat(uriId.startsWith(""RUID"")).isTrue();
        assertEquals(uriId.length(), 36);
    }

    private Uri shareAndGetRedactedUri(File file, TestApp testApp) {
        final Uri redactedUri = getRedactedUri(file);
        getContext().grantUriPermission(testApp.getPackageName(), redactedUri,
                FLAG_GRANT_READ_URI_PERMISSION);

        return redactedUri;
    }

    private Uri getRedactedUri(File file) {
        final Uri uri = MediaStore.scanFile(getContentResolver(), file);
        return MediaStore.getRedactedUri(getContentResolver(), uri);
    }

    private void assertUriIsUnredacted(File img) throws Exception {
        final ExifInterface exifInterface = new ExifInterface(img);
        assertNotEquals(exifInterface.getGpsDateTime(), -1);

        float[] latLong = new float[]{0, 0};
        exifInterface.getLatLong(latLong);
        assertNotEquals(latLong[0], 0);
        assertNotEquals(latLong[1], 0);
    }

    private void assertUriIsRedacted(ExifInterface redactedExifInf) {
        asse"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/RedactUriDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"getTestParameters"	""	"1: permission"	"([20:/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java]:[permission]:[20]:method_text:[  * Test that we enforce certain media types can only be created in certain directories.     */   ]) :|: /*
 *.
 */

package android.scopedstorage.cts.device;

import static android.app.AppOpsManager.permissionToOp;
import static android.os.ParcelFileDescriptor.MODE_CREATE;
import static android.os.ParcelFileDescriptor.MODE_READ_WRITE;
import static android.os.SystemProperties.getBoolean;
import static android.scopedstorage.cts.lib.RedactionTestHelper.assertExifMetadataMatch;
import static android.scopedstorage.cts.lib.RedactionTestHelper.assertExifMetadataMismatch;
import static android.scopedstorage.cts.lib.RedactionTestHelper.getExifMetadata;
import static android.scopedstorage.cts.lib.RedactionTestHelper.getExifMetadataFromRawResource;
import static android.scopedstorage.cts.lib.TestUtils.BYTES_DATA2;
import static android.scopedstorage.cts.lib.TestUtils.STR_DATA2;
import static android.scopedstorage.cts.lib.TestUtils.allowAppOpsToUid;
import static android.scopedstorage.cts.lib.TestUtils.assertCanRenameDirectory;
import static android.scopedstorage.cts.lib.TestUtils.assertCanRenameFile;
import static android.scopedstorage.cts.lib.TestUtils.assertCantRenameDirectory;
import static android.scopedstorage.cts.lib.TestUtils.assertCantRenameFile;
import static android.scopedstorage.cts.lib.TestUtils.assertDirectoryContains;
import static android.scopedstorage.cts.lib.TestUtils.assertFileContent;
import static android.scopedstorage.cts.lib.TestUtils.assertMountMode;
import static android.scopedstorage.cts.lib.TestUtils.assertThrows;
import static android.scopedstorage.cts.lib.TestUtils.canOpen;
import static android.scopedstorage.cts.lib.TestUtils.canOpenFileAs;
import static android.scopedstorage.cts.lib.TestUtils.canQueryOnUri;
import static android.scopedstorage.cts.lib.TestUtils.checkPermission;
import static android.scopedstorage.cts.lib.TestUtils.createFileAs;
import static android.scopedstorage.cts.lib.TestUtils.deleteFileAs;
import static android.scopedstorage.cts.lib.TestUtils.deleteFileAsNoThrow;
import static android.scopedstorage.cts.lib.TestUtils.deleteRecur"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testReadWriteFilesInOtherAppExternalDir"	""	"1: permission"	"([1:/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java]:[permission]:[1]:method_text:[      }    }    /**     * Test that we can contribute media without any permissions.     */   ]) :|: 
    public void testReadWriteFilesInOtherAppExternalDir() throws Exception {
        final File videoFile = new File(getExternalFilesDir(), VIDEO_FILE_NAME);

        try {
            // Create a file in app's external files directory
            if (!videoFile.exists()) {
                assertThat(videoFile.createNewFile()).isTrue();
            }

            // App A should not be able to read/write to other app's external files directory.
            assertThat(canOpenFileAs(APP_A_HAS_RES, videoFile, false /* forWrite */)).isFalse();
            assertThat(canOpenFileAs(APP_A_HAS_RES, videoFile, true /* forWrite */)).isFalse();
            // App A should not be able to delete files in other app's external files
            // directory.
            assertThat(deleteFileAs(APP_A_HAS_RES, videoFile.getPath())).isFalse();

            // Apps should have read/write access in their own app's external files directory.
            assertThat(canOpen(videoFile, false /* forWrite */)).isTrue();
            assertThat(canOpen(videoFile, true /* forWrite */)).isTrue();
            // Apps should be able to delete files in their own app's external files directory.
            assertThat(videoFile.delete()).isTrue();
        } finally {
            videoFile.delete();
        }
    }

    /**
     * Test that we can contribute media without any permissions.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testLowLevelFileIO"	""	"1: permission"	"([1:/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java]:[permission]:[1]:method_text:[t that media files from other packages are only visible to apps with storage permission.     */   ]) :|: 
    public void testLowLevelFileIO() throws Exception {
        String filePath = new File(getDownloadDir(), NONMEDIA_FILE_NAME).toString();
        try {
            int createFlags = O_CREAT | O_RDWR;
            int createExclFlags = createFlags | O_EXCL;

            FileDescriptor fd = Os.open(filePath, createExclFlags, S_IRWXU);
            Os.close(fd);
            assertThrows(
                    ErrnoException.class, () -> {
                        Os.open(filePath, createExclFlags, S_IRWXU);
                    });

            fd = Os.open(filePath, createFlags, S_IRWXU);
            try {
                assertThat(Os.write(fd,
                        ByteBuffer.wrap(BYTES_DATA1))).isEqualTo(BYTES_DATA1.length);
                assertFileContent(fd, BYTES_DATA1);
            } finally {
                Os.close(fd);
            }
            // should just append the data
            fd = Os.open(filePath, createFlags | O_APPEND, S_IRWXU);
            try {
                assertThat(Os.write(fd,
                        ByteBuffer.wrap(BYTES_DATA2))).isEqualTo(BYTES_DATA2.length);
                final byte[] expected = (STR_DATA1 + STR_DATA2).getBytes();
                assertFileContent(fd, expected);
            } finally {
                Os.close(fd);
            }
            // should overwrite everything
            fd = Os.open(filePath, createFlags | O_TRUNC, S_IRWXU);
            try {
                final byte[] otherData = ""this is different data"".getBytes();
                assertThat(Os.write(fd, ByteBuffer.wrap(otherData))).isEqualTo(otherData.length);
                assertFileContent(fd, otherData);
            } finally {
                Os.close(fd);
            }
        } finally {
            new File(filePath).delete();
        }
    }

    /**
     * Test that media files from other packages are only visible to apps with storage permission.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testListDirectoriesWithMediaFiles"	""	"1: permission"	"([2:/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java]:[permission]:[2]:method_text:[    }    /**     * Test that app can't see non-media files created by other packages     */   ]) :|: 
    public void testListDirectoriesWithMediaFiles() throws Exception {
        final File dcimDir = getDcimDir();
        final File dir = new File(dcimDir, TEST_DIRECTORY_NAME);
        final File videoFile = new File(dir, VIDEO_FILE_NAME);
        final String videoFileName = videoFile.getName();
        try {
            if (!dir.exists()) {
                assertThat(dir.mkdir()).isTrue();
            }

            assertThat(createFileAs(APP_B_NO_PERMS, videoFile.getPath())).isTrue();
            // App B should see TEST_DIRECTORY in DCIM and new file in TEST_DIRECTORY.
            assertThat(listAs(APP_B_NO_PERMS, dcimDir.getPath())).contains(TEST_DIRECTORY_NAME);
            assertThat(listAs(APP_B_NO_PERMS, dir.getPath())).containsExactly(videoFileName);

            // App A has storage permission, so should see TEST_DIRECTORY in DCIM and new file
            // in TEST_DIRECTORY.
            assertThat(listAs(APP_A_HAS_RES, dcimDir.getPath())).contains(TEST_DIRECTORY_NAME);
            assertThat(listAs(APP_A_HAS_RES, dir.getPath())).containsExactly(videoFileName);

            // We are an app without storage permission; should see TEST_DIRECTORY in DCIM and
            // should not see new file in new TEST_DIRECTORY.
            assertThat(dcimDir.list()).asList().contains(TEST_DIRECTORY_NAME);
            assertThat(dir.list()).asList().doesNotContain(videoFileName);
        } finally {
            deleteFileAsNoThrow(APP_B_NO_PERMS, videoFile.getPath());
            dir.delete();
        }
    }

    /**
     * Test that app can't see non-media files created by other packages
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testListDirectoriesWithNonMediaFiles"	""	"1: permission"	"([1:/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java]:[permission]:[1]:method_text:[       }    }    /**     * Test that app can only see its directory in Android/data.     */   ]) :|: 
    public void testListDirectoriesWithNonMediaFiles() throws Exception {
        final File downloadDir = getDownloadDir();
        final File dir = new File(downloadDir, TEST_DIRECTORY_NAME);
        final File pdfFile = new File(dir, NONMEDIA_FILE_NAME);
        final String pdfFileName = pdfFile.getName();
        try {
            if (!dir.exists()) {
                assertThat(dir.mkdir()).isTrue();
            }

            // Have App B create non media file in the new directory.
            assertThat(createFileAs(APP_B_NO_PERMS, pdfFile.getPath())).isTrue();

            // App B should see TEST_DIRECTORY in downloadDir and new non media file in
            // TEST_DIRECTORY.
            assertThat(listAs(APP_B_NO_PERMS, downloadDir.getPath())).contains(TEST_DIRECTORY_NAME);
            assertThat(listAs(APP_B_NO_PERMS, dir.getPath())).containsExactly(pdfFileName);

            // APP A with storage permission should see TEST_DIRECTORY in downloadDir
            // and should not see non media file in TEST_DIRECTORY.
            assertThat(listAs(APP_A_HAS_RES, downloadDir.getPath())).contains(TEST_DIRECTORY_NAME);
            assertThat(listAs(APP_A_HAS_RES, dir.getPath())).doesNotContain(pdfFileName);
        } finally {
            deleteFileAsNoThrow(APP_B_NO_PERMS, pdfFile.getPath());
            dir.delete();
        }
    }

    /**
     * Test that app can only see its directory in Android/data.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testListFilesFromExternalMediaDirectory"	""	"1: permission"	"([1:/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java]:[permission]:[1]:method_text:[actly(videoFile.getName());        } finally {            videoFile.delete();        }    }   ]) :|: 
    public void testListFilesFromExternalMediaDirectory() throws Exception {
        final File videoFile = new File(getExternalMediaDir(), VIDEO_FILE_NAME);

        try {
            // Create a file in app's external media directory
            if (!videoFile.exists()) {
                assertThat(videoFile.createNewFile()).isTrue();
            }

            // App should see its directory and other app's external media directories with media
            // files.
            assertDirectoryContains(videoFile.getParentFile(), videoFile);

            // App A with storage permission should see other app's external media directory.
            // Apps with READ_EXTERNAL_STORAGE can list files in other app's external media
            // directory.
            assertThat(listAs(APP_A_HAS_RES, getAndroidMediaDir().getPath()))
                    .contains(THIS_PACKAGE_NAME);
            assertThat(listAs(APP_A_HAS_RES, getExternalMediaDir().getPath()))
                    .containsExactly(videoFile.getName());
        } finally {
            videoFile.delete();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testMetaDataRedaction"	""	"1: permission"	"([1:/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java]:[permission]:[1]:method_text:[FS cache from both file opens        } finally {            jpgFile.delete();        }    }   ]) :|: 
    public void testMetaDataRedaction() throws Exception {
        File jpgFile = new File(getPicturesDir(), ""img_metadata.jpg"");
        try {
            if (jpgFile.exists()) {
                assertThat(jpgFile.delete()).isTrue();
            }

            HashMap<String, String> originalExif =
                    getExifMetadataFromRawResource(R.raw.img_with_metadata);

            try (InputStream in =
                         getContext().getResources().openRawResource(R.raw.img_with_metadata);
                FileOutputStream out = new FileOutputStream(jpgFile)) {
                // Dump the image we have to external storage
                FileUtils.copy(in, out);
                // Sync file to disk to ensure file is fully written to the lower fs attempting to
                // open for redaction. Otherwise, the FUSE daemon might not accurately parse the
                // EXIF tags and might misleadingly think there are not tags to redact
                out.getFD().sync();

                HashMap<String, String> exif = getExifMetadata(jpgFile);
                assertExifMetadataMatch(exif, originalExif);

                HashMap<String, String> exifFromTestApp =
                        readExifMetadataFromTestApp(APP_A_HAS_RES, jpgFile.getPath());
                // App does not have AML; shouldn't have access to the same metadata.
                assertExifMetadataMismatch(exifFromTestApp, originalExif);

                // TODO(b/146346138): Test that if we give APP_A write URI permission,
                //  it would be able to access the metadata.
            } // Intentionally keep the original streams open during the test so bytes are more
            // likely to be in the VFS cache from both file opens
        } finally {
            jpgFile.delete();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testReadStorageInvalidation"	""	"1: permission"	"([1:/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java]:[permission]:[1]:method_text:[TORAGE,                AppOpsManager.OPSTR_READ_EXTERNAL_STORAGE, /* forWrite */ false);    }   ]) :|: 
    public void testReadStorageInvalidation() throws Exception {
        testAppOpInvalidation(APP_C, new File(getDcimDir(), ""read_storage.jpg""),
                Manifest.permission.READ_EXTERNAL_STORAGE,
                AppOpsManager.OPSTR_READ_EXTERNAL_STORAGE, /* forWrite */ false);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testWriteStorageInvalidation"	""	"1: permission"	"([1:/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java]:[permission]:[1]:method_text:[TORAGE,                AppOpsManager.OPSTR_WRITE_EXTERNAL_STORAGE, /* forWrite */ true);    }   ]) :|: 
    public void testWriteStorageInvalidation() throws Exception {
        testAppOpInvalidation(APP_C_LEGACY, new File(getDcimDir(), ""write_storage.jpg""),
                Manifest.permission.WRITE_EXTERNAL_STORAGE,
                AppOpsManager.OPSTR_WRITE_EXTERNAL_STORAGE, /* forWrite */ true);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testManageStorageInvalidation"	""	"1: permission"	"([1:/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java]:[permission]:[1]:method_text:[              /* permission */ null, OPSTR_MANAGE_EXTERNAL_STORAGE, /* forWrite */ true);    }   ]) :|: 
    public void testManageStorageInvalidation() throws Exception {
        testAppOpInvalidation(APP_C, new File(getDownloadDir(), ""manage_storage.pdf""),
                /* permission */ null, OPSTR_MANAGE_EXTERNAL_STORAGE, /* forWrite */ true);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testWriteImagesInvalidation"	""	"1: permission"	"([1:/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java]:[permission]:[1]:method_text:[     /* permission */ null, AppOpsManager.OPSTR_WRITE_MEDIA_IMAGES, /* forWrite */ true);    }   ]) :|: 
    public void testWriteImagesInvalidation() throws Exception {
        testAppOpInvalidation(APP_C, new File(getDcimDir(), ""write_images.jpg""),
                /* permission */ null, AppOpsManager.OPSTR_WRITE_MEDIA_IMAGES, /* forWrite */ true);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testWriteVideoInvalidation"	""	"1: permission"	"([1:/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java]:[permission]:[1]:method_text:[      /* permission */ null, AppOpsManager.OPSTR_WRITE_MEDIA_VIDEO, /* forWrite */ true);    }   ]) :|: 
    public void testWriteVideoInvalidation() throws Exception {
        testAppOpInvalidation(APP_C, new File(getDcimDir(), ""write_video.mp4""),
                /* permission */ null, AppOpsManager.OPSTR_WRITE_MEDIA_VIDEO, /* forWrite */ true);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testAccessMediaLocationInvalidation"	""	"1: permission"	"([15:/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java]:[permission]:[15]:method_text:[finally {            imgFile.delete();            uninstallAppNoThrow(APP_C);        }    }   ]) :|: 
    public void testAccessMediaLocationInvalidation() throws Exception {
        File imgFile = new File(getDcimDir(), ""access_media_location.jpg"");

        try {
            // Setup image with sensitive data on external storage
            HashMap<String, String> originalExif =
                    getExifMetadataFromRawResource(R.raw.img_with_metadata);
            try (InputStream in =
                         getContext().getResources().openRawResource(R.raw.img_with_metadata);
                FileOutputStream out = new FileOutputStream(imgFile)) {
                // Dump the image we have to external storage
                FileUtils.copy(in, out);
                // Sync file to disk to ensure file is fully written to the lower fs.
                out.getFD().sync();
            }
            HashMap<String, String> exif = getExifMetadata(imgFile);
            assertExifMetadataMatch(exif, originalExif);

            // Install test app
            installAppWithStoragePermissions(APP_C);

            // Grant A_M_L and verify access to sensitive data
            grantPermission(APP_C.getPackageName(), Manifest.permission.ACCESS_MEDIA_LOCATION);
            HashMap<String, String> exifFromTestApp =
                    readExifMetadataFromTestApp(APP_C, imgFile.getPath());
            assertExifMetadataMatch(exifFromTestApp, originalExif);

            // Revoke A_M_L and verify sensitive data redaction
            revokePermission(
                    APP_C.getPackageName(), Manifest.permission.ACCESS_MEDIA_LOCATION);
            // revokePermission waits for permission status to be updated, but MediaProvider still
            // needs to get permission change callback and clear its permission cache.
            Thread.sleep(500);
            exifFromTestApp = readExifMetadataFromTestApp(APP_C, imgFile.getPath());
            assertExifMetadataMismatch(exifFromTestApp, originalExif);

            // Re-grant A_M_L and verify access to sensitive data"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testAppUpdateInvalidation"	""	"1: permission"	"([6:/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java]:[permission]:[6]:method_text:[ } finally {            file.delete();            uninstallAppNoThrow(APP_C);        }    }   ]) :|: 
    public void testAppUpdateInvalidation() throws Exception {
        File file = new File(getDcimDir(), ""app_update.jpg"");
        try {
            assertThat(file.createNewFile()).isTrue();

            // Install legacy
            installAppWithStoragePermissions(APP_C_LEGACY);
            grantPermission(APP_C_LEGACY.getPackageName(),
                    Manifest.permission.WRITE_EXTERNAL_STORAGE); // Grants write access for legacy

            // Legacy app can read and write media files contributed by others
            assertThat(canOpenFileAs(APP_C_LEGACY, file, /* forWrite */ false)).isTrue();
            assertThat(canOpenFileAs(APP_C_LEGACY, file, /* forWrite */ true)).isTrue();

            // Update to non-legacy
            installAppWithStoragePermissions(APP_C);
            grantPermission(APP_C_LEGACY.getPackageName(),
                    Manifest.permission.WRITE_EXTERNAL_STORAGE); // No effect for non-legacy

            // Non-legacy app can read media files contributed by others
            assertThat(canOpenFileAs(APP_C, file, /* forWrite */ false)).isTrue();
            // But cannot write
            assertThat(canOpenFileAs(APP_C, file, /* forWrite */ true)).isFalse();
        } finally {
            file.delete();
            uninstallAppNoThrow(APP_C);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testAppReinstallInvalidation"	""	"1: permission"	"([15:/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java]:[permission]:[15]:method_text:[d.sleep(200);        }        assertThat(canOpenFileAs(app, file, forWrite)).isFalse();    }   ]) :|: 
    public void testAppReinstallInvalidation() throws Exception {
        File file = new File(getDcimDir(), ""app_reinstall.jpg"");

        try {
            assertThat(file.createNewFile()).isTrue();

            // Install
            installAppWithStoragePermissions(APP_C);
            assertThat(canOpenFileAs(APP_C, file, /* forWrite */ false)).isTrue();

            // Re-install
            uninstallAppNoThrow(APP_C);
            installApp(APP_C);
            assertThat(canOpenFileAs(APP_C, file, /* forWrite */ false)).isFalse();
        } finally {
            file.delete();
            uninstallAppNoThrow(APP_C);
        }
    }

    private void testAppOpInvalidation(TestApp app, File file, @Nullable String permission,
            String opstr, boolean forWrite) throws Exception {
        boolean alreadyInstalled = true;
        try {
            if (!isAppInstalled(app)) {
                alreadyInstalled = false;
                installApp(app);
            }
            assertThat(file.createNewFile()).isTrue();
            assertAppOpInvalidation(app, file, permission, opstr, forWrite);
        } finally {
            file.delete();
            if (!alreadyInstalled) {
                // only uninstall if we installed this app here
                uninstallApp(app);
            }
        }
    }

    /** If {@code permission} is null, appops are flipped, otherwise permissions are flipped */
    private void assertAppOpInvalidation(TestApp app, File file, @Nullable String permission,
            String opstr, boolean forWrite) throws Exception {
        String packageName = app.getPackageName();
        int uid = getContext().getPackageManager().getPackageUid(packageName, 0);

        // Deny
        if (permission != null) {
            revokePermission(packageName, permission);
        } else {
            denyAppOpsToUid(uid, opstr);
            // TODO(191724755): Poll for AppOp state change instead
            Thread.sleep(200);
        }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testScanUpdatesMimeTypeForRenameFileExtension"	""	"1: permission"	"([1:/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java]:[permission]:[1]:method_text:[}    /**     * Test that app without write permission for file can't update the file.     */   ]) :|: 
    public void testScanUpdatesMimeTypeForRenameFileExtension() throws Exception {
        final String audioFileName = ""ScopedStorageDeviceTest_"" + NONCE;
        final File mpegFile = new File(getMusicDir(), audioFileName + "".mp3"");
        final File nonMpegFile = new File(getMusicDir(), audioFileName + "".snd"");
        try {
            // Copy audio content to mpegFile
            try (InputStream in =
                         getContext().getResources().openRawResource(R.raw.test_audio);
                 FileOutputStream out = new FileOutputStream(mpegFile)) {
                FileUtils.copy(in, out);
                out.getFD().sync();
            }
            assertThat(MediaStore.scanFile(getContentResolver(), mpegFile)).isNotNull();
            assertThat(getFileMimeTypeFromDatabase(mpegFile)).isEqualTo(""audio/mpeg"");

            // This rename changes MIME type from audio/mpeg to audio/basic
            assertCanRenameFile(mpegFile, nonMpegFile);
            assertThat(getFileMimeTypeFromDatabase(nonMpegFile)).isNotEqualTo(""audio/mpeg"");

            assertThat(MediaStore.scanFile(getContentResolver(), nonMpegFile)).isNotNull();
            // Above scan should read file metadata and update the MIME type to audio/mpeg
            assertThat(getFileMimeTypeFromDatabase(nonMpegFile)).isEqualTo(""audio/mpeg"");
        } finally {
            mpegFile.delete();
            nonMpegFile.delete();
        }
    }

    /**
     * Test that app without write permission for file can't update the file.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testRenameFileNotOwned"	""	"1: permission"	"([1:/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java]:[permission]:[1]:method_text:[ Test that renaming directories is allowed and aligns to default directory restrictions.     */   ]) :|: 
    public void testRenameFileNotOwned() throws Exception {
        final File videoFile1 = new File(getDcimDir(), VIDEO_FILE_NAME);
        final File videoFile2 = new File(getMoviesDir(), VIDEO_FILE_NAME);
        try {
            assertThat(createFileAs(APP_B_NO_PERMS, videoFile1.getAbsolutePath())).isTrue();
            // App can't rename a file owned by APP B.
            assertCantRenameFile(videoFile1, videoFile2);

            assertThat(videoFile2.createNewFile()).isTrue();
            // App can't rename a file to videoFile1 which is owned by APP B.
            assertCantRenameFile(videoFile2, videoFile1);
            // TODO(b/146346138): Test that app with right URI permission should be able to rename
            // the corresponding file
        } finally {
            deleteFileAsNoThrow(APP_B_NO_PERMS, videoFile1.getAbsolutePath());
            videoFile2.delete();
        }
    }

    /**
     * Test that renaming directories is allowed and aligns to default directory restrictions.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testRenameDirectory"	""	"1: permission"	"([1:/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java]:[permission]:[1]:method_text:[ }    }    /**     * Test that renaming directory checks file ownership permissions.     */   ]) :|: 
    public void testRenameDirectory() throws Exception {
        final File dcimDir = getDcimDir();
        final File downloadDir = getDownloadDir();
        final String nonMediaDirectoryName = TEST_DIRECTORY_NAME + ""NonMedia"";
        final File nonMediaDirectory = new File(downloadDir, nonMediaDirectoryName);
        final File pdfFile = new File(nonMediaDirectory, NONMEDIA_FILE_NAME);

        final String mediaDirectoryName = TEST_DIRECTORY_NAME + ""Media"";
        final File mediaDirectory1 = new File(dcimDir, mediaDirectoryName);
        final File videoFile1 = new File(mediaDirectory1, VIDEO_FILE_NAME);
        final File mediaDirectory2 = new File(downloadDir, mediaDirectoryName);
        final File videoFile2 = new File(mediaDirectory2, VIDEO_FILE_NAME);
        final File mediaDirectory3 = new File(getMoviesDir(), TEST_DIRECTORY_NAME);
        final File videoFile3 = new File(mediaDirectory3, VIDEO_FILE_NAME);
        final File mediaDirectory4 = new File(mediaDirectory3, mediaDirectoryName);

        try {
            if (!nonMediaDirectory.exists()) {
                assertThat(nonMediaDirectory.mkdirs()).isTrue();
            }
            assertThat(pdfFile.createNewFile()).isTrue();
            // Move directory with pdf file to DCIM directory is not allowed.
            assertThat(nonMediaDirectory.renameTo(new File(dcimDir, nonMediaDirectoryName)))
                    .isFalse();

            if (!mediaDirectory1.exists()) {
                assertThat(mediaDirectory1.mkdirs()).isTrue();
            }
            assertThat(videoFile1.createNewFile()).isTrue();
            // Renaming to and from default directories is not allowed.
            assertThat(mediaDirectory1.renameTo(dcimDir)).isFalse();
            // Moving top level default directories is not allowed.
            assertCantRenameDirectory(downloadDir, new File(dcimDir, TEST_DIRECTORY_NAME), null);

            // Moving media directory to Download directory is allowed.
            as"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testListHiddenFile"	""	"1: permission"	"([1:/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java]:[permission]:[1]:method_text:[PPOPS);            }        } finally {            hiddenImageFile.delete();        }    }   ]) :|: 
    public void testListHiddenFile() throws Exception {
        final File dcimDir = getDcimDir();
        final String hiddenImageFileName = "".hidden"" + IMAGE_FILE_NAME;
        final File hiddenImageFile = new File(dcimDir, hiddenImageFileName);
        try {
            assertThat(hiddenImageFile.createNewFile()).isTrue();
            assertNotMediaTypeImage(hiddenImageFile);

            assertDirectoryContains(dcimDir, hiddenImageFile);

            // TestApp with read permissions can't see the hidden image file created by other app
            assertThat(listAs(APP_A_HAS_RES, dcimDir.getAbsolutePath()))
                    .doesNotContain(hiddenImageFileName);

            // But file manager can
            assertThat(listAs(APP_FM, dcimDir.getAbsolutePath()))
                    .contains(hiddenImageFileName);

            // Gallery cannot see the hidden image file created by other app
            final int resAppUid =
                    getContext().getPackageManager().getPackageUid(APP_A_HAS_RES.getPackageName(),
                            0);
            try {
                allowAppOpsToUid(resAppUid, SYSTEM_GALERY_APPOPS);
                assertThat(listAs(APP_A_HAS_RES, dcimDir.getAbsolutePath()))
                        .doesNotContain(hiddenImageFileName);
            } finally {
                denyAppOpsToUid(resAppUid, SYSTEM_GALERY_APPOPS);
            }
        } finally {
            hiddenImageFile.delete();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testQueryOtherAppsFiles"	""	"1: permission"	"([1:/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java]:[permission]:[1]:method_text:[esAs(APP_B_NO_PERMS, otherAppImg, otherAppMusic, otherAppPdf, otherHiddenFile);        }    }   ]) :|: 
    public void testQueryOtherAppsFiles() throws Exception {
        final File otherAppPdf = new File(getDownloadDir(), ""other"" + NONMEDIA_FILE_NAME);
        final File otherAppImg = new File(getDcimDir(), ""other"" + IMAGE_FILE_NAME);
        final File otherAppMusic = new File(getMusicDir(), ""other"" + AUDIO_FILE_NAME);
        final File otherHiddenFile = new File(getPicturesDir(), "".otherHiddenFile.jpg"");
        try {
            // Apps can't query other app's pending file, hence create file and publish it.
            assertCreatePublishedFilesAs(
                    APP_B_NO_PERMS, otherAppImg, otherAppMusic, otherAppPdf, otherHiddenFile);

            // Since the test doesn't have READ_EXTERNAL_STORAGE nor any other special permissions,
            // it can't query for another app's contents.
            assertCantQueryFile(otherAppImg);
            assertCantQueryFile(otherAppMusic);
            assertCantQueryFile(otherAppPdf);
            assertCantQueryFile(otherHiddenFile);
        } finally {
            deleteFilesAs(APP_B_NO_PERMS, otherAppImg, otherAppMusic, otherAppPdf, otherHiddenFile);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testListUnsupportedFileType"	""	"1: permission"	"([2:/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java]:[permission]:[2]:method_text:[   * Test that normal apps cannot access Android/data and Android/obb dirs of other apps     */   ]) :|: 
    public void testListUnsupportedFileType() throws Exception {
        final File pdfFile = new File(getDcimDir(), NONMEDIA_FILE_NAME);
        final File videoFile = new File(getMusicDir(), VIDEO_FILE_NAME);
        try {
            // TEST_APP_A with storage permission should not see pdf file in DCIM
            createFileAsLegacyApp(pdfFile);
            assertThat(pdfFile.exists()).isTrue();
            assertThat(MediaStore.scanFile(getContentResolver(), pdfFile)).isNotNull();

            assertThat(listAs(APP_A_HAS_RES, getDcimDir().getPath()))
                    .doesNotContain(NONMEDIA_FILE_NAME);

            createFileAsLegacyApp(videoFile);
            // We don't insert files to db for files created by shell.
            assertThat(MediaStore.scanFile(getContentResolver(), videoFile)).isNotNull();
            // TEST_APP_A with storage permission should see video file in Music directory.
            assertThat(listAs(APP_A_HAS_RES, getMusicDir().getPath())).contains(VIDEO_FILE_NAME);
        } finally {
            deleteAsLegacyApp(pdfFile);
            deleteAsLegacyApp(videoFile);
            MediaStore.scanFile(getContentResolver(), pdfFile);
            MediaStore.scanFile(getContentResolver(), videoFile);
        }
    }

    /**
     * Test that normal apps cannot access Android/data and Android/obb dirs of other apps
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testCantSetAttrOtherAppsFile"	""	"1: permission"	"([1:/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java]:[permission]:[1]:method_text:[}    /**     * b/171768780: Test that scan doesn't skip scanning renamed hidden file.     */   ]) :|: 
    public void testCantSetAttrOtherAppsFile() throws Exception {
        // This path's permission is checked in MediaProvider (directory/external media dir)
        final File externalMediaPath = new File(getExternalMediaDir(), VIDEO_FILE_NAME);

        try {
            // Create the files
            if (!externalMediaPath.exists()) {
                assertThat(externalMediaPath.createNewFile()).isTrue();
            }

            // APP A should not be able to setattr to other app's files.
            assertWithMessage(
                    ""setattr on directory/external media path [%s]"", externalMediaPath.getPath())
                    .that(setAttrAs(APP_A_HAS_RES, externalMediaPath.getPath()))
                    .isFalse();
        } finally {
            externalMediaPath.delete();
        }
    }

    /**
     * b/171768780: Test that scan doesn't skip scanning renamed hidden file.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testTransformsTranscodeDirFileOperations"	""	"1: permission"	"([1:/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java]:[permission]:[1]:method_text:[    /**     * Test mount modes for a platform signed app with ACCESS_MTP permission.     */   ]) :|: 
    @SdkSuppress(minSdkVersion = 31, codeName = ""S"")
    public void testTransformsTranscodeDirFileOperations() throws Exception {
        final String path =
                Environment.getExternalStorageDirectory() + ""/"" + TRANSFORMS_TRANSCODE_DIR;
        final File file = new File(path);
        assertThat(file.exists()).isFalse();
        testTransformsDirCommon(file);
    }


    /**
     * Test mount modes for a platform signed app with ACCESS_MTP permission.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.scopedstorage.cts.device.ScopedStorageDeviceTest"	"testExternalStorageProviderAndDownloadsProvider"	""	"1: permission"	"([1:/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java]:[permission]:[1]:method_text:[""Deleting file "" + file);        deleteFileAs(APP_D_LEGACY_HAS_RW, file.getAbsolutePath());    }}]) :|: 
    @SdkSuppress(minSdkVersion = 31, codeName = ""S"")
    public void testExternalStorageProviderAndDownloadsProvider() throws Exception {
        assertWritableMountModeForProvider(DocumentsContract.EXTERNAL_STORAGE_PROVIDER_AUTHORITY);
        assertWritableMountModeForProvider(DocumentsContract.DOWNLOADS_PROVIDER_AUTHORITY);
    }

    private void assertWritableMountModeForProvider(String auth) {
        final ProviderInfo provider = getContext().getPackageManager()
                .resolveContentProvider(auth, 0);
        int uid = provider.applicationInfo.uid;
        final String packageName = provider.applicationInfo.packageName;

        assertMountMode(packageName, uid, StorageManager.MOUNT_MODE_EXTERNAL_ANDROID_WRITABLE);
    }

    private boolean canRenameFile(File file) {
        return file.renameTo(new File(file.getAbsolutePath() + ""test""));
    }

    private void testTransformsDirCommon(File file) throws Exception {
        assertThat(file.delete()).isFalse();
        assertThat(canRenameFile(file)).isFalse();

        final File newFile = new File(file.getAbsolutePath(), ""test"");
        assertThat(newFile.mkdir()).isFalse();
        assertThrows(IOException.class, () -> newFile.createNewFile());
    }

    private void assertCanWriteAndRead(File file, byte[] data) throws Exception {
        // Assert we can write to images/videos
        try (FileOutputStream fos = new FileOutputStream(file)) {
            fos.write(data);
        }
        assertFileContent(file, data);
    }

    /**
     * Checks restrictions for opening pending and trashed files by different apps. Assumes that
     * given {@code testApp} is already installed and has READ_EXTERNAL_STORAGE permission. This
     * method doesn't uninstall given {@code testApp} at the end.
     */
    private void assertOpenPendingOrTrashed(Uri uri, boolean isImageOrVideo)
            throws Exception {
        final File pendingOrTrashedFile = new File(getFilePathFromUri(uri));

        // App"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/device/src/android/scopedstorage/cts/device/ScopedStorageDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.host.multiuser.EphemeralTest"	"testRebootAndRemoveEphemeralUser_withAccount"	"CtsMultiUserHostTestCases"	"1: permission"	"([1:/android/host/multiuser/EphemeralTest.java]:[permission]:[1]:method_text:[  * <p>Indirectly executed by means of the --set-ephemeral-if-in-use flag     */    @Presubmit   ]) :|: 
    public void testRebootAndRemoveEphemeralUser_withAccount() throws Exception {
        final int ephemeralUserId = createEphemeralUser();
        assertSwitchToNewUser(ephemeralUserId);

        installPackageAsUser(
                TEST_APP_PKG_APK, /* grantPermissions= */true, ephemeralUserId, /* options= */""-t"");
        assertTrue(getDevice().isPackageInstalled(TEST_APP_PKG_NAME,
                String.valueOf(ephemeralUserId)));

        final boolean appResult = runDeviceTests(getDevice(),
                TEST_APP_PKG_NAME,
                TEST_APP_PKG_NAME + "".AccountCreator"",
                ""addMockAccountForCurrentUser"",
                ephemeralUserId,
                5 * 60 * 1000L /* ms */);
        assertTrue(""Failed to successfully run app"", appResult);

        getDevice().reboot();
        assertUserNotPresent(ephemeralUserId);
    }

    /**
     * Test to verify that {@link android.os.UserManager#removeUserOrSetEphemeral(int)} immediately
     * removes a user that isn't running.
     *
     * <p>Indirectly executed by means of the --set-ephemeral-if-in-use flag
     */
    @Presubmit"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/multiuser/src/android/host/multiuser/EphemeralTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.host.multiuser.SetUsersRestrictionsTest"	"testCantSetUserRestriction"	"CtsMultiUserHostTestCases"	"1: permission"	"([1:/android/host/multiuser/SetUsersRestrictionsTest.java]:[permission]:[1]:method_text:[tyException. ""                + ""command output: %s"", output).that(isErrorOutput).isTrue();    }}]) :|: 
    public void testCantSetUserRestriction() throws Exception {
        assumeNotRoot();

        final String setRestriction = ""pm set-user-restriction no_fun "";
        final String output = getDevice().executeShellCommand(setRestriction + ""1"");
        final boolean isErrorOutput = output.contains(""SecurityException"")
                && output.contains(""You need MANAGE_USERS permission"");
        assertWithMessage(""Trying to set user restriction should fail with SecurityException. ""
                + ""command output: %s"", output).that(isErrorOutput).isTrue();
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/multiuser/src/android/host/multiuser/SetUsersRestrictionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.accountmanager.AccountManagerCrossUserTest"	"dropShellPermissionIdentity"	""	"1: permission"	"([1:/com/android/cts/accountmanager/AccountManagerCrossUserTest.java]:[permission]:[1]:method_text:[mberFormatException ignore) {            }        }        return numAccountsExpected;    }   ]) :|: /*
 *.
 */
package com.android.cts.accountmanager;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.fail;

import android.accounts.Account;
import android.accounts.AccountManager;
import android.accounts.AccountManagerFuture;
import android.app.UiAutomation;
import android.content.Context;
import android.content.pm.PackageManager;
import android.os.Bundle;
import android.os.UserHandle;

import androidx.test.InstrumentationRegistry;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

@RunWith(JUnit4.class)
public class AccountManagerCrossUserTest {

    private static final Account TEST_ACCOUNT = new Account(MockAuthenticator.ACCOUNT_NAME,
            MockAuthenticator.ACCOUNT_TYPE);
    private static final String AUTH_TOKEN_TYPE = ""testAuthTokenType"";
    private static final String[] REQUIRED_FEATURES =
            new String[]{""testRequiredFeature1"", ""testRequiredFeature2""};

    private Context mContext;
    private UiAutomation uiAutomation;

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getContext();

        uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
    }

    @After
    public void tearDown(){
        uiAutomation.dropShellPermissionIdentity();
    }

    private int getTestUser() {
        final Bundle testArguments = InstrumentationRegistry.getArguments();
        if (testArguments.containsKey(""testUser"")) {
            try {
                return Integer.parseInt(testArguments.getString(""testUser""));
            } catch (NumberFormatException ignore) {
            }
        }
        return mContext.getUserId();
    }

    private int getNumAccountsExpected() {
        int numAccountsExpected = 1;
        final Bundle testArguments = InstrumentationRegistry.getArguments();"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/accounts/test-apps/AccountManagerCrossUserApp/src/com/android/cts/accountmanager/AccountManagerCrossUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.accountmanager.AccountManagerCrossUserTest"	"testAccountManager_addMockAccount"	""	"1: permission"	"([2:/com/android/cts/accountmanager/AccountManagerCrossUserTest.java]:[permission]:[2]:method_text:[accounts = accountManagerAsUser.getAccounts();        assertThat(accounts).hasLength(1);    }   ]) :|: 
    public void testAccountManager_addMockAccount() throws Exception {
        UserHandle profileHandle = UserHandle.of(getTestUser());

        uiAutomation.adoptShellPermissionIdentity(
                ""android.permission.INTERACT_ACROSS_USERS_FULL"");

        AccountManager accountManagerAsUser = (AccountManager) mContext.createContextAsUser(
                profileHandle, 0).getSystemService(Context.ACCOUNT_SERVICE);

        AccountManagerFuture<Bundle> future = accountManagerAsUser.addAccount(
                MockAuthenticator.ACCOUNT_TYPE,
                null, null, null, null, null, null);

        Bundle result = future.getResult();
        assertThat(result.getString(AccountManager.KEY_ACCOUNT_TYPE)).isEqualTo(
                MockAuthenticator.ACCOUNT_TYPE);
        assertThat(result.getString(AccountManager.KEY_ACCOUNT_NAME)).isEqualTo(
                MockAuthenticator.ACCOUNT_NAME);

        Account[] accounts = accountManagerAsUser.getAccounts();
        assertThat(accounts).hasLength(1);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/accounts/test-apps/AccountManagerCrossUserApp/src/com/android/cts/accountmanager/AccountManagerCrossUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.accountmanager.AccountManagerCrossUserTest"	"testAccountManager_getAccountsForTestUser"	""	"1: permission"	"([2:/com/android/cts/accountmanager/AccountManagerCrossUserTest.java]:[permission]:[2]:method_text:[            assertThat(accounts).hasLength(1);        } catch (Exception e) {        }    }   ]) :|: 
    public void testAccountManager_getAccountsForTestUser() throws Exception {
        UserHandle profileHandle = UserHandle.of(getTestUser());

        try {
            uiAutomation.adoptShellPermissionIdentity(
                    ""android.permission.INTERACT_ACROSS_USERS_FULL"");

            AccountManager accountManagerAsUser = (AccountManager) mContext.createContextAsUser(
                    profileHandle, 0).getSystemService(Context.ACCOUNT_SERVICE);

            assertWithMessage(""No accounts for user "" + profileHandle
                    + "". Make sure testAccountManager_addAccountExplicitly is executed ""
                    + ""before this test"").that(
                    accountManagerAsUser.getAccountsByType(MockAuthenticator.ACCOUNT_TYPE))
                    .hasLength(1);

            Account[] accounts = accountManagerAsUser.getAccounts();
            assertThat(accounts).hasLength(1);
        } catch (Exception e) {
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/accounts/test-apps/AccountManagerCrossUserApp/src/com/android/cts/accountmanager/AccountManagerCrossUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.accountmanager.AccountManagerCrossUserTest"	"testAccountManager_failCreateContextAsUserRevokePermissions"	""	"1: permission"	"([3:/com/android/cts/accountmanager/AccountManagerCrossUserTest.java]:[permission]:[3]:method_text:[d have received a security exception"");        } catch (SecurityException e) {        }    }   ]) :|: 
    public void testAccountManager_failCreateContextAsUserRevokePermissions() throws Exception {
        UserHandle profileHandle = UserHandle.of(getTestUser());

        try {
            assertPermissionRevoked(""android.permission.INTERACT_ACROSS_USERS"");
            AccountManager accountManagerAsUser = (AccountManager) mContext.createContextAsUser(
                    profileHandle, 0).getSystemService(Context.ACCOUNT_SERVICE);

            fail(""Should have received a security exception"");
        } catch (SecurityException e) {
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/accounts/test-apps/AccountManagerCrossUserApp/src/com/android/cts/accountmanager/AccountManagerCrossUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.accountmanager.AccountManagerCrossUserTest"	"testAccountManager_createContextAsUserForCurrentUserRevokePermissions"	""	"1: permission"	"([3:/com/android/cts/accountmanager/AccountManagerCrossUserTest.java]:[permission]:[3]:method_text:[mService(Context.ACCOUNT_SERVICE);        assertThat(accountManagerAsUser).isNotNull();    }   ]) :|: 
    public void testAccountManager_createContextAsUserForCurrentUserRevokePermissions()
            throws Exception {
        UserHandle profileHandle = UserHandle.of(getTestUser());

        assertPermissionRevoked(""android.permission.INTERACT_ACROSS_USERS"");

        AccountManager accountManagerAsUser = (AccountManager) mContext.createContextAsUser(
                profileHandle, 0).getSystemService(Context.ACCOUNT_SERVICE);

        assertThat(accountManagerAsUser).isNotNull();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/accounts/test-apps/AccountManagerCrossUserApp/src/com/android/cts/accountmanager/AccountManagerCrossUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.accountmanager.AccountManagerCrossUserTest"	"testAccountManager_startAddAccountSessionForCurrentUser"	""	"1: permission"	"([5:/com/android/cts/accountmanager/AccountManagerCrossUserTest.java]:[permission]:[5]:method_text:[n,                mContext.getPackageName())).isEqualTo(PackageManager.PERMISSION_DENIED);    }}]) :|: 
    public void testAccountManager_startAddAccountSessionForCurrentUser() throws Exception {
        AccountManager accountManager = mContext.getSystemService(AccountManager.class);
        accountManager.startAddAccountSession(
                MockAuthenticator.ACCOUNT_TYPE,
                AUTH_TOKEN_TYPE,
                REQUIRED_FEATURES,
                /* options= */ null,
                /* activity= */ null,
                /* callback= */ null,
                /* handler= */ null);
    }

    private void assertPermissionRevoked(String permission) throws Exception {
        assertThat(mContext.getPackageManager().checkPermission(permission,
                mContext.getPackageName())).isEqualTo(PackageManager.PERMISSION_DENIED);
    }

}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/accounts/test-apps/AccountManagerCrossUserApp/src/com/android/cts/accountmanager/AccountManagerCrossUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.host.accounts.AccountManagerHostSideTest"	"testStartAddAccountSession_logsMetrics"	"CtsAccountsHostTestCases"	"1: permission"	"([2:/android/host/accounts/AccountManagerHostSideTest.java]:[permission]:[2]:method_text:[UTH_TOKEN_TYPE,                        REQUIRED_FEATURES_STR)                .build());    }   ]) :|: 
    public void testStartAddAccountSession_logsMetrics() throws Exception {
        assertMetricsLogged(getDevice(), () -> {
            runDeviceTests(
                    getDevice(),
                    TEST_WITH_PERMISSION_PKG,
                    "".AccountManagerCrossUserTest"",
                    ""testAccountManager_startAddAccountSessionForCurrentUser"",
                    mCurrentUser,
                    /* testArgs= */ null,
                    /* timeout= */ 60L,
                    TimeUnit.SECONDS);
        }, new DevicePolicyEventWrapper.Builder(EventId.ADD_ACCOUNT_VALUE)
                .setStrings(ACCOUNT_TYPE,
                        TEST_WITH_PERMISSION_PKG,
                        AUTH_TOKEN_TYPE,
                        REQUIRED_FEATURES_STR)
                .build());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/accounts/src/android/host/accounts/AccountManagerHostSideTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.host.accounts.AccountManagerXUserTest"	"testAddMockAccountForUserProfile"	"CtsAccountsHostTestCases"	"1: permission"	"([3:/android/host/accounts/AccountManagerXUserTest.java]:[permission]:[3]:method_text:[erId,                mTestArgs,                60L,                TimeUnit.SECONDS);    }   ]) :|: 
    public void testAddMockAccountForUserProfile() throws Exception {
        // add account from parentUserId for profileUserId
        runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".AccountManagerCrossUserTest"",
                ""testAccountManager_addMockAccount"",
                mParentUserId,
                mTestArgs,
                60L,
                TimeUnit.SECONDS);

        // get accounts as parentUserId (should fail) => 0 accounts
        mTestArgs.put(""numAccountsExpected"", Integer.toString(0));
        runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".AccountManagerCrossUserTest"",
                ""testAccountManager_getAccountsForCurrentUser"",
                mParentUserId,
                mTestArgs,
                60L,
                TimeUnit.SECONDS);

        // get accounts as profileUserId (should succeed) => 1 account
        mTestArgs.put(""numAccountsExpected"", Integer.toString(1));
        runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".AccountManagerCrossUserTest"",
                ""testAccountManager_getAccountsForCurrentUser"",
                mProfileUserId,
                mTestArgs,
                60L,
                TimeUnit.SECONDS);

    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/accounts/src/android/host/accounts/AccountManagerXUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.host.accounts.AccountManagerXUserTest"	"testGetAccountsForUserProfile"	"CtsAccountsHostTestCases"	"1: permission"	"([2:/android/host/accounts/AccountManagerXUserTest.java]:[permission]:[2]:method_text:[serId,                mTestArgs,                60L,                TimeUnit.SECONDS);    }   ]) :|: 
    public void testGetAccountsForUserProfile() throws Exception {
        // need to run addAccountExplicitly from profile user
        runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".AccountManagerCrossUserTest"",
                ""testAccountManager_addAccountExplicitlyForCurrentUser"",
                mProfileUserId,
                mTestArgs,
                60L,
                TimeUnit.SECONDS);

        // run getAccounts from initial user
        runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".AccountManagerCrossUserTest"",
                ""testAccountManager_getAccountsForTestUser"",
                mParentUserId,
                mTestArgs,
                60L,
                TimeUnit.SECONDS);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/accounts/src/android/host/accounts/AccountManagerXUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.host.accounts.AccountManagerXUserTest"	"testCreateContextAsUser_revokePermissions"	"CtsAccountsHostTestCases"	"1: permission"	"([3:/android/host/accounts/AccountManagerXUserTest.java]:[permission]:[3]:method_text:[serId,                mTestArgs,                60L,                TimeUnit.SECONDS);    }   ]) :|: 
    public void testCreateContextAsUser_revokePermissions() throws Exception {
        // should throw SecurityException when INTERACT_ACROSS_USERS is revoked
        runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".AccountManagerCrossUserTest"",
                ""testAccountManager_failCreateContextAsUserRevokePermissions"",
                mParentUserId,
                mTestArgs,
                60L,
                TimeUnit.SECONDS);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/accounts/src/android/host/accounts/AccountManagerXUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.host.accounts.AccountManagerXUserTest"	"testCreateContextAsUserForSameUser_revokePermissions"	"CtsAccountsHostTestCases"	"1: permission"	"([3:/android/host/accounts/AccountManagerXUserTest.java]:[permission]:[3]:method_text:[   }            }            throw new AssertionError(errorBuilder.toString());        }    }}]) :|: 
    public void testCreateContextAsUserForSameUser_revokePermissions() throws Exception {
        // should create context even if INTERACT_ACROSS_USERS is revoked (same user)
        runDeviceTests(
                getDevice(),
                TEST_WITH_PERMISSION_PKG,
                "".AccountManagerCrossUserTest"",
                ""testAccountManager_createContextAsUserForCurrentUserRevokePermissions"",
                mProfileUserId,
                mTestArgs,
                60L,
                TimeUnit.SECONDS);
    }

    public static void runDeviceTests(ITestDevice device, String packageName, String testClassName,
            String testMethodName, int userId, Map<String, String> testArgs, long timeout,
            TimeUnit unit)
            throws DeviceNotAvailableException {
        if (testClassName != null && testClassName.startsWith(""."")) {
            testClassName = packageName + testClassName;
        }
        RemoteAndroidTestRunner testRunner = new RemoteAndroidTestRunner(packageName,
                ""androidx.test.runner.AndroidJUnitRunner"", device.getIDevice());
        // timeout_msec is the timeout per test for instrumentation
        testRunner.addInstrumentationArg(""timeout_msec"", Long.toString(unit.toMillis(timeout)));
        if (testClassName != null && testMethodName != null) {
            testRunner.setMethodName(testClassName, testMethodName);
        } else if (testClassName != null) {
            testRunner.setClassName(testClassName);
        }

        if (testArgs != null && testArgs.size() > 0) {
            for (String name : testArgs.keySet()) {
                final String value = testArgs.get(name);
                testRunner.addInstrumentationArg(name, value);
            }
        }
        final CollectingTestListener listener = new CollectingTestListener();
        device.runInstrumentationTestsAsUser(testRunner, userId, listener);

        final TestRunResult result = listener.getCurrentRunResults();
        if (result"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/accounts/src/android/host/accounts/AccountManagerXUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.tests.packagemanager.multiuser.app.PackageManagerMultiUserTest"	"dropShellPermissionIdentity"	""	"1: permission"	"([1:/com/android/tests/packagemanager/multiuser/app/PackageManagerMultiUserTest.java]:[permission]:[1]:method_text:[ry.getInstrumentation().getUiAutomation()                .dropShellPermissionIdentity();    }   ]) :|: /*
 *.
 */

package com.android.tests.packagemanager.multiuser.app;

import android.Manifest;
import android.content.Context;
import android.content.pm.ModuleInfo;
import android.content.pm.PackageInstaller;
import android.content.pm.PackageManager;
import android.os.Bundle;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import org.junit.After;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@RunWith(AndroidJUnit4.class)
public class PackageManagerMultiUserTest {
    private static final String ARG_PACKAGE_NAME = ""pkgName"";

    @After
    public void tearDown() throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .dropShellPermissionIdentity();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/packagemanager/multiuser/app/src/com/android/tests/packagemanager/multiuser/app/PackageManagerMultiUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.tests.packagemanager.multiuser.app.PackageManagerMultiUserTest"	"testUninstallExistingPackage"	""	"1: permission"	"([2:/com/android/tests/packagemanager/multiuser/app/PackageManagerMultiUserTest.java]:[permission]:[2]:method_text:[Name, null);    }    /**     * Returns a list of installed modules to the host-side.     */   ]) :|: 
    public void testUninstallExistingPackage() throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().adoptShellPermissionIdentity(
                Manifest.permission.DELETE_PACKAGES);
        String pkgName = InstrumentationRegistry.getArguments().getString(ARG_PACKAGE_NAME);
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        PackageManager packageManager = context.getPackageManager();
        PackageInstaller packageInstaller = packageManager.getPackageInstaller();

        packageInstaller.uninstallExistingPackage(pkgName, null);
    }

    /**
     * Returns a list of installed modules to the host-side.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/packagemanager/multiuser/app/src/com/android/tests/packagemanager/multiuser/app/PackageManagerMultiUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.packagemanager.preferredactivity.app.PreferredActivityDeviceTests"	"testAddOnePreferredActivity"	""	"1: permission"	"([2:/com/android/cts/packagemanager/preferredactivity/app/PreferredActivityDeviceTests.java]:[permission]:[2]:method_text:[eption e) {            fail(""addPreferredActivity failed: "" + e.getMessage());        }    }   ]) :|: 
    public void testAddOnePreferredActivity() {
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(Manifest.permission.SET_PREFERRED_APPLICATIONS);
        final IntentFilter intentFilter = new IntentFilter(ACTIVITY_ACTION_NAME);
        final ComponentName[] componentName = {new ComponentName(PACKAGE_NAME, ACTIVITY_NAME)};
        try {
            mPackageManager.addPreferredActivity(intentFilter, IntentFilter.MATCH_CATEGORY_HOST,
                    componentName, componentName[0]);
        } catch (SecurityException e) {
            fail(""addPreferredActivity failed: "" + e.getMessage());
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/hostsidetests/packagemanager/preferredactivity/apps/testapp/src/com/android/cts/packagemanager/preferredactivity/app/PreferredActivityDeviceTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.compatibility.common.util.BaseDefaultPermissionGrantPolicyTest"	"isCnBuild"	""	"1: permission"	"([18:/com/android/compatibility/common/util/BaseDefaultPermissionGrantPolicyTest.java]:[permission]:[18]:method_text:[ion.     */    public abstract boolean isSplitPermissionNameViolation(String permissionName);   ]) :|: public void test/*
 *.
 */

package com.android.compatibility.common.util;

import static android.content.pm.PermissionInfo.PROTECTION_DANGEROUS;

import static com.android.compatibility.common.util.SystemUtil.callWithShellPermissionIdentity;

import static org.junit.Assert.fail;

import android.Manifest;
import android.content.Context;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.PermissionInfo;
import android.content.pm.Signature;
import android.os.Build;
import android.os.UserHandle;
import android.permission.PermissionManager;
import android.util.ArrayMap;
import android.util.ArraySet;
import android.util.Log;
import android.util.SparseArray;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

public abstract class BaseDefaultPermissionGrantPolicyTest extends BusinessLogicTestCase {
    public static final String LOG_TAG = ""DefaultPermissionGrantPolicy"";
    private static final String PLATFORM_PACKAGE_NAME = ""android"";

    private static final String BRAND_PROPERTY = ""ro.product.brand"";
    private static final char[] HEX_ARRAY = ""0123456789ABCDEF"".toCharArray();

    private Set<DefaultPermissionGrantException> mRemoteExceptions = new HashSet<>();

    /**
     * Returns whether this build is a CN build.
     */
    public abstract boolean isCnBuild();

    /**
     * Returns whether this build is a CN build with GMS.
     */
    public abstract boolean isCnGmsBuild();

    /**
     * Add default permissions for all applicable apps.
     */
    public abstract void addDefaultSystemHandlerPermissions(
            ArrayMap<String, PackageInfo> packagesToVerify,
            SparseArray<UidState> pregran"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/common/device-side/util-axt/src/com/android/compatibility/common/util/BaseDefaultPermissionGrantPolicyTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.compatibility.common.util.BaseDefaultPermissionGrantPolicyTest"	"isEmpty"	""	"1: permission"	"([233:/com/android/compatibility/common/util/BaseDefaultPermissionGrantPolicyTest.java]:[permission]:[233]:method_text:[f brand vs. SHA256 hash            }            this.permissions = permissions;        }    }}]) :|: public void testDefaultGrantsWithRemoteExceptions(boolean preGrantsOnly) throws Exception {
        List<PackageInfo> allPackages = getAllPackages();
        Set<String> runtimePermNames = getRuntimePermissionNames(allPackages);
        ArrayMap<String, PackageInfo> packagesToVerify =
                getMsdkTargetingPackagesUsingRuntimePerms(allPackages, runtimePermNames);

        // Ignore CTS infrastructure
        packagesToVerify.remove(""android.tradefed.contentprovider"");

        SparseArray<UidState> pregrantUidStates = new SparseArray<>();

        addDefaultSystemHandlerPermissions(packagesToVerify, pregrantUidStates);

        // Add split permissions that were split from non-runtime permissions
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.Q)) {
            addSplitFromNonDangerousPermissions(packagesToVerify, pregrantUidStates);
        }

        // Add exceptions
        addExceptionsDefaultPermissions(packagesToVerify, runtimePermNames, pregrantUidStates);

        // packageName -> message -> [permission]
        ArrayMap<String, ArrayMap<String, ArraySet<String>>> violations = new ArrayMap();

        // Enforce default grants in the right state
        checkDefaultGrantsInCorrectState(packagesToVerify, pregrantUidStates, violations);

        // Nothing else should have default grants
        checkPackagesForUnexpectedGrants(packagesToVerify, runtimePermNames, violations,
                preGrantsOnly);

        logPregrantUidStates(pregrantUidStates);

        // Bail if we found any violations
        if (!violations.isEmpty()) {
            fail(createViolationsErrorString(violations));
        }
    }


    /**
     * Primarily invoked by business logic, set default permission grant exceptions for this
     * instance of the test class. This is an alternative to downloading the encrypted xml
     * file, a process which is now deprecated.
     *
     * @param pkg         the package name
     * @param sha256      the sha256 cert diges"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/common/device-side/util-axt/src/com/android/compatibility/common/util/BaseDefaultPermissionGrantPolicyTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"main.library.java.com.android.bedstead.testapp.TestAppActivityReference"	"TestApis"	""	"1: permission"	"([9:/main/library/java/com/android/bedstead/testapp/TestAppActivityReference.java]:[permission]:[9]:method_text:[rap(                TestAppActivity.class, new TestAppActivityImpl(mInstance, mComponent));    }}]) :|: public void test/*
 *.
 */

package com.android.bedstead.testapp;

import static android.Manifest.permission.INTERACT_ACROSS_USERS_FULL;
import static android.content.Intent.FLAG_ACTIVITY_CLEAR_TASK;
import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;

import android.content.Intent;
import android.os.Bundle;
import android.util.Log;

import com.android.bedstead.nene.TestApis;
import com.android.bedstead.nene.activities.ActivityReference;
import com.android.bedstead.nene.packages.ComponentReference;
import com.android.bedstead.nene.permissions.PermissionContext;
import com.android.eventlib.events.activities.ActivityCreatedEvent;
import com.android.eventlib.events.activities.ActivityStartedEvent;

/**
 * A reference to an activity in a test app for which there may or may not be an instance.
 */
public abstract class TestAppActivityReference {

    static final TestApis sTestApis = new TestApis();

    final TestAppInstanceReference mInstance;
    final ComponentReference mComponent;

    TestAppActivityReference(
            TestAppInstanceReference instance,
            ComponentReference component) {
        mInstance = instance;
        mComponent = component;
    }

    /** Gets the {@link TestAppInstanceReference} this activity exists in. */
    public TestAppInstanceReference testAppInstance() {
        return mInstance;
    }

    /** Gets the {@link ComponentReference} for this activity. */
    public ComponentReference component() {
        return mComponent;
    }

    /**
     * Starts the activity.
     */
    public com.android.bedstead.nene.activities.Activity<TestAppActivity> start() {
        // TODO(scottjonathan): Use a connected call to ensure this succeeds cross-user
        Intent intent = new Intent();
        intent.setComponent(mComponent.componentName());
        intent.setFlags(FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK);

        try (PermissionContext p =
                     sTestApis.permissions().withPermission(INTERACT_A"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/testapp/src/main/library/java/com/android/bedstead/testapp/TestAppActivityReference.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"test.java.com.android.bedstead.testapp.TestAppInstanceReferenceTest"	"TestApis"	""	"1: permission"	"([3:/test/java/com/android/bedstead/testapp/TestAppInstanceReferenceTest.java]:[permission]:[3]:method_text:[    @Before    public void setup() {        mTestAppProvider = new TestAppProvider();    }   ]) :|: /*
 *.
 */

package com.android.bedstead.testapp;

import static android.Manifest.permission.INTERACT_ACROSS_USERS;

import static com.google.common.truth.Truth.assertThat;

import static org.testng.Assert.assertThrows;

import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;

import com.android.bedstead.harrier.BedsteadJUnit4;
import com.android.bedstead.harrier.DeviceState;
import com.android.bedstead.harrier.annotations.EnsureHasSecondaryUser;
import com.android.bedstead.harrier.annotations.RequireRunOnPrimaryUser;
import com.android.bedstead.nene.TestApis;
import com.android.bedstead.nene.packages.Package;
import com.android.bedstead.nene.permissions.PermissionContext;
import com.android.bedstead.nene.users.UserReference;
import com.android.compatibility.common.util.PollingCheck;
import com.android.eventlib.EventLogs;
import com.android.eventlib.events.broadcastreceivers.BroadcastReceivedEvent;

import org.junit.Before;
import org.junit.ClassRule;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

@RunWith(BedsteadJUnit4.class)
public class TestAppInstanceReferenceTest {

    @ClassRule @Rule
    public static final DeviceState sDeviceState = new DeviceState();

    private static final TestApis sTestApis = new TestApis();
    private static final Context sContext = sTestApis.context().instrumentedContext();
    private static final UserReference sUser = sTestApis.users().instrumented();

    private TestAppProvider mTestAppProvider;

    private static final String INTENT_ACTION = ""com.android.bedstead.testapp.test_action"";
    private static final IntentFilter INTENT_FILTER = new IntentFilter(INTENT_ACTION);
    private static final Intent INTENT = new Intent(INTENT_ACTION);
    private static final String INTENT_ACTION_2 = ""com.android.bedstead.testapp.test_action2"";
    private static final IntentFilter INTENT_FILTER_2 = new IntentFilter(INTENT_ACTION_2)"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/testapp/src/test/java/com/android/bedstead/testapp/TestAppInstanceReferenceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.verifier.net.MultiNetworkConnectivityTestActivity"	"testStarted"	""	"1: INTERNET"	"([4:/com/android/cts/verifier/net/MultiNetworkConnectivityTestActivity.java]:[INTERNET]:[4]:method_text:[stCallback =            new MultinetworkTestCallback() {                @Override               ]) :|: public void test/*
 *.
 */

package com.android.cts.verifier.net;

import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.TRANSPORT_CELLULAR;
import static android.net.NetworkCapabilities.TRANSPORT_WIFI;

import static com.android.cts.verifier.net.MultiNetworkConnectivityTestActivity.ValidatorState
        .COMPLETED;
import static com.android.cts.verifier.net.MultiNetworkConnectivityTestActivity.ValidatorState
        .NOT_STARTED;
import static com.android.cts.verifier.net.MultiNetworkConnectivityTestActivity.ValidatorState
        .STARTED;
import static com.android.cts.verifier.net.MultiNetworkConnectivityTestActivity.ValidatorState
        .WAITING_FOR_USER_INPUT;

import android.app.ActivityManager;
import android.app.AlertDialog;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.ConnectivityManager;
import android.net.ConnectivityManager.NetworkCallback;
import android.net.DhcpInfo;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkInfo;
import android.net.NetworkRequest;
import android.net.NetworkSpecifier;
import android.net.wifi.SupplicantState;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSpecifier;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.provider.Settings;
import android.telephony.TelephonyManager;
import android.text.Editable;
import android.text.TextUtils;
import android.text.TextWatcher;
import android.util.Log;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import java.util.ArrayList;
import java.util.Collections;
import java.u"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/net/MultiNetworkConnectivityTestActivity.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.verifier.net.MultiNetworkConnectivityTestActivity"	"startTest"	""	"2: INTERNET permission"	"([9:/com/android/cts/verifier/net/MultiNetworkConnectivityTestActivity.java]:[permission]:[9]:method_text:[}    }    private interface SetWifiCallback {        void onComplete(boolean isSuccess);    }}]) :|: public void testCompleted(MultiNetworkValidator validator) {
                    if (validator == mMultiNetworkValidators.get(mMultiNetworkValidators.size()
                            - 1)) {
                        // Done all tests.
                        boolean passed = true;
                        for (MultiNetworkValidator multiNetworkValidator :
                                mMultiNetworkValidators) {
                            passed = passed && multiNetworkValidator.mTestResult;
                        }
                        setTestResultAndFinish(passed);
                    } else if (!validator.mTestResult) {
                        setTestResultAndFinish(false);
                    } else {
                        for (int i = 0; i < mMultiNetworkValidators.size(); i++) {
                            if (mMultiNetworkValidators.get(i) == validator) {
                                mCurrentValidator = mMultiNetworkValidators.get(i + 1);
                                mTestNameView.setText(mCurrentValidator.mTestDescription);
                                mCurrentValidator.startTest();
                                break;
                            }
                        }
                    }
                }
            };
    private List<MultiNetworkValidator> mMultiNetworkValidators = Collections.emptyList();
    private final Runnable mTimeToCompletionRunnable = new Runnable() {
        @Override
        public void run() {
            mSecondsToCompletion--;
            if (mSecondsToCompletion > 0) {
                mStartButton.setText("""" + mSecondsToCompletion);
                mMainHandler.postDelayed(this, 1000);
            }
        }
    };

    // User interface elements.
    private Button mStartButton;
    private TextView mTestNameView;
    private TextView mTestInfoView;
    private EditText mAccessPointSsidEditText;
    private EditText mPskEditText;

    // Current state memebers.
    private MultiNetworkValidator"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/net/MultiNetworkConnectivityTestActivity.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.verifier.audio.RingerModeActivity"	"TestVolumeDndAffectedStream"	""	"1: permission"	"([1:/com/android/cts/verifier/audio/RingerModeActivity.java]:[permission]:[1]:method_text:[dioManager.getStreamVolume(AudioManager.STREAM_MUSIC));            status = PASS;        }    }]) :|: Api method to query the VolumPolicy
        //tests.add(new TestVolumeDndAffectedStream());
        tests.add(new TestVolume());
        tests.add(new TestMuteStreams());
        tests.add(new EnableSoundEffects());
        tests.add(new TestSoundEffects());
        return tests;
    }

    private int getVolumeDelta(int volume) {
        return 1;
    }

    private boolean hasAudioOutput() {
        return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUDIO_OUTPUT);
    }

    private void testStreamMuting(int stream) {
        if (stream == AudioManager.STREAM_VOICE_CALL) {
            // Voice call requires MODIFY_PHONE_STATE, so we should not be able to mute
            mAudioManager.adjustStreamVolume(stream, AudioManager.ADJUST_MUTE, 0);
            assertFalse(""Muting stream "" + stream + "" should require MODIFY_PHONE_STATE permission."",
                    mAudioManager.isStreamMute(stream));
        } else {
            mAudioManager.adjustStreamVolume(stream, AudioManager.ADJUST_MUTE, 0);
            assertTrue(""Muting stream "" + stream + "" failed."",
                    mAudioManager.isStreamMute(stream));

            mAudioManager.adjustStreamVolume(stream, AudioManager.ADJUST_UNMUTE, 0);
            assertFalse(""Unmuting stream "" + stream + "" failed."",
                    mAudioManager.isStreamMute(stream));

            mAudioManager.adjustStreamVolume(stream, AudioManager.ADJUST_TOGGLE_MUTE, 0);
            assertTrue(""Toggling mute on stream "" + stream + "" failed."",
                    mAudioManager.isStreamMute(stream));

            mAudioManager.adjustStreamVolume(stream, AudioManager.ADJUST_TOGGLE_MUTE, 0);
            assertFalse(""Toggling mute on stream "" + stream + "" failed."",
                    mAudioManager.isStreamMute(stream));

            mAudioManager.setStreamMute(stream, true);
            assertTrue(""Muting stream "" + stream + "" using setStreamMute failed"",
                    mAudioManager.isStreamMute(stream"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/audio/RingerModeActivity.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.verifier.usb.device.UsbDeviceTestActivity"	"getAccessoryList"	""	"1: permission"	"([24:/com/android/cts/verifier/usb/device/UsbDeviceTestActivity.java]:[permission]:[24]:method_text:[     unregisterReceiver(mUsbDevicePermissionReceiver);        }        super.onDestroy();    }}]) :|: public void test/*
 *.
 */

package com.android.cts.verifier.usb.device;

import static com.android.cts.verifier.usb.Util.runAndAssertException;

import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertTrue;

import android.app.PendingIntent;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.hardware.usb.UsbConfiguration;
import android.hardware.usb.UsbConstants;
import android.hardware.usb.UsbDevice;
import android.hardware.usb.UsbDeviceConnection;
import android.hardware.usb.UsbEndpoint;
import android.hardware.usb.UsbInterface;
import android.hardware.usb.UsbManager;
import android.hardware.usb.UsbRequest;
import android.os.Build;
import android.os.Bundle;
import android.util.ArraySet;
import android.util.Log;
import android.util.Pair;
import android.view.View;
import android.widget.ProgressBar;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import java.nio.BufferOverflowException;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicInteger;

public class UsbDeviceTestActivity extends PassFailButtons.Activity {
    private static final String ACTION_USB_PERMISSION ="	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/usb/device/UsbDeviceTestActivity.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.verifier.sensors.StepSensorPermissionTestActivity"	"StepSensorPermissionTestActivity"	""	"1: permission"	"([39:/com/android/cts/verifier/sensors/StepSensorPermissionTestActivity.java]:[permission]:[39]:method_text:[        @Override        public void onAccuracyChanged(Sensor sensor, int i) {        }    }}]) :|: public void test/*
 *.
 */

package com.android.cts.verifier.sensors;

import com.android.cts.verifier.sensors.base.SensorCtsVerifierTestActivity;

import android.Manifest;
import com.android.cts.verifier.R;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.net.Uri;
import android.provider.Settings;

import java.util.ArrayList;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

/**
 * Test cases to verify step sensor permissions
 */
public class StepSensorPermissionTestActivity extends SensorCtsVerifierTestActivity
        implements SensorEventListener {
    private static final int STEP_DETECT_DELAY_SECONDS = 30;
    private static final int STEP_COUNT_DELAY_SECONDS = 30;
    // Additional amount of time to give for receiving either a step detect or
    // count event in case the user hasn't started walking at the time the test
    // starts.
    private static final int ADDITIONAL_EVENT_DELAY_SECONDS = 2;

    private SensorManager mSensorManager;

    private boolean mHasAccelFeature = false;
    private boolean mHasStepCounterFeature = false;
    private boolean mHasStepDetectorFeature = false;
    private CountDownLatch mEventReceivedLatch = null;
    private Sensor mSensorUnderTest = null;
    private AccelRecorder mAccelRecorder = null;

    public StepSensorPermissionTestActivity() {
        super(StepSensorPermissionTestActivity.class);
    }

    @Override
    protected void activitySetUp() {
        mSensorManager = (SensorManager) getApplicationContext()
                .getSystemService(Context.SENSOR_SERVICE);

        mHasAccelFeature = getApplicationContext().getPackageManager().hasSystemFeature("	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/sensors/StepSensorPermissionTestActivity.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.uwb.cts.UwbManagerTest"	"isNotNull"	"CtsUwbTestCases"	"1: permission"	"([4:/android/uwb/cts/UwbManagerTest.java]:[permission]:[4]:method_text:[True(UwbTestUtils.isUwbSupported(mContext));        assertThat(mUwbManager).isNotNull();    }   ]) :|: /*
 *.
 */

package android.uwb.cts;

import static android.Manifest.permission.UWB_PRIVILEGED;
import static android.Manifest.permission.UWB_RANGING;

import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import android.annotation.NonNull;
import android.annotation.Nullable;
import android.app.UiAutomation;
import android.content.AttributionSource;
import android.content.Context;
import android.content.ContextParams;
import android.os.CancellationSignal;
import android.os.PersistableBundle;
import android.os.Process;
import android.permission.PermissionManager;
import android.util.Log;
import android.uwb.RangingReport;
import android.uwb.RangingSession;
import android.uwb.UwbManager;

import androidx.test.InstrumentationRegistry;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SmallTest;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/**
 * Test of {@link UwbManager}.
 */
@SmallTest
@RunWith(AndroidJUnit4.class)
public class UwbManagerTest {
    private static final String TAG = ""UwbManagerTest"";

    private final Context mContext = InstrumentationRegistry.getContext();
    private UwbManager mUwbManager;

    @Before
    public void setup() {
        mUwbManager = mContext.getSystemService(UwbManager.class);
        assumeTrue(UwbTestUtils.isUwbSupported(mContext));
        assertThat(mUwbManager).isNotNull();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/uwb/src/android/uwb/cts/UwbManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.uwb.cts.UwbManagerTest"	"testGetSpecificationInfo"	"CtsUwbTestCases"	"1: permission"	"([3:/android/uwb/cts/UwbManagerTest.java]:[permission]:[3]:method_text:[();        } finally {            uiAutomation.dropShellPermissionIdentity();        }    }   ]) :|: 
    public void testGetSpecificationInfo() {
        UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
        try {
            // Needs UWB_PRIVILEGED permission which is held by shell.
            uiAutomation.adoptShellPermissionIdentity();
            PersistableBundle persistableBundle = mUwbManager.getSpecificationInfo();
            assertThat(persistableBundle).isNotNull();
            assertThat(persistableBundle.isEmpty()).isFalse();
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/uwb/src/android/uwb/cts/UwbManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.uwb.cts.UwbManagerTest"	"testGetSpecificationInfoWithoutUwbPrivileged"	"CtsUwbTestCases"	"1: permission"	"([1:/android/uwb/cts/UwbManagerTest.java]:[permission]:[1]:method_text:[ss */            Log.i(TAG, ""Failed with expected security exception: "" + e);        }    }   ]) :|: 
    public void testGetSpecificationInfoWithoutUwbPrivileged() {
        try {
            mUwbManager.getSpecificationInfo();
            // should fail if the call was successful without UWB_PRIVILEGED permission.
            fail();
        } catch (SecurityException e) {
            /* pass */
            Log.i(TAG, ""Failed with expected security exception: "" + e);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/uwb/src/android/uwb/cts/UwbManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.uwb.cts.UwbManagerTest"	"testElapsedRealtimeResolutionNanos"	"CtsUwbTestCases"	"1: permission"	"([3:/android/uwb/cts/UwbManagerTest.java]:[permission]:[3]:method_text:[();        } finally {            uiAutomation.dropShellPermissionIdentity();        }    }   ]) :|: 
    public void testElapsedRealtimeResolutionNanos() {
        UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
        try {
            // Needs UWB_PRIVILEGED permission which is held by shell.
            uiAutomation.adoptShellPermissionIdentity();
            assertThat(mUwbManager.elapsedRealtimeResolutionNanos() >= 0L).isTrue();
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/uwb/src/android/uwb/cts/UwbManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.uwb.cts.UwbManagerTest"	"testElapsedRealtimeResolutionNanosWithoutUwbPrivileged"	"CtsUwbTestCases"	"1: permission"	"([1:/android/uwb/cts/UwbManagerTest.java]:[permission]:[1]:method_text:[ters) { }        public void onReportReceived(@NonNull RangingReport rangingReport) { }    }   ]) :|: 
    public void testElapsedRealtimeResolutionNanosWithoutUwbPrivileged() {
        try {
            mUwbManager.elapsedRealtimeResolutionNanos();
            // should fail if the call was successful without UWB_PRIVILEGED permission.
            fail();
        } catch (SecurityException e) {
            /* pass */
            Log.i(TAG, ""Failed with expected security exception: "" + e);
        }
    }

    private class RangingSessionCallback implements RangingSession.Callback {
        private final CountDownLatch mCountDownLatch;

        public boolean onOpenedCalled;
        public boolean onOpenFailedCalled;
        public RangingSession rangingSession;

        RangingSessionCallback(@NonNull CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        public void onOpened(@NonNull RangingSession session) {
            onOpenedCalled = true;
            rangingSession = session;
            mCountDownLatch.countDown();
        }

        public void onOpenFailed(@Reason int reason, @NonNull PersistableBundle params) {
            onOpenFailedCalled = true;
            mCountDownLatch.countDown();
        }

        public void onStarted(@NonNull PersistableBundle sessionInfo) { }

        public void onStartFailed(@Reason int reason, @NonNull PersistableBundle params) { }

        public void onReconfigured(@NonNull PersistableBundle params) { }

        public void onReconfigureFailed(@Reason int reason, @NonNull PersistableBundle params) { }

        public void onStopped(@Reason int reason, @NonNull PersistableBundle parameters) { }

        public void onStopFailed(@Reason int reason, @NonNull PersistableBundle params) { }

        public void onClosed(@Reason int reason, @NonNull PersistableBundle parameters) { }

        public void onReportReceived(@NonNull RangingReport rangingReport) { }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/uwb/src/android/uwb/cts/UwbManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.uwb.cts.UwbManagerTest"	"testOpenRangingSessionWithBadParams"	"CtsUwbTestCases"	"1: permission"	"([4:/android/uwb/cts/UwbManagerTest.java]:[permission]:[4]:method_text:[    /**     * Simulates the app holding UWB_RANGING permission, but not UWB_PRIVILEGED.     */   ]) :|: 
    public void testOpenRangingSessionWithBadParams() throws Exception {
        UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
        CancellationSignal cancellationSignal = null;
        CountDownLatch countDownLatch = new CountDownLatch(1);
        RangingSessionCallback rangingSessionCallback = new RangingSessionCallback(countDownLatch);
        try {
            // Needs UWB_PRIVILEGED & UWB_RANGING permission which is held by shell.
            uiAutomation.adoptShellPermissionIdentity();
            // Try to start a ranging session with invalid params, should fail.
            cancellationSignal = mUwbManager.openRangingSession(
                    new PersistableBundle(),
                    Executors.newSingleThreadExecutor(),
                    rangingSessionCallback);
            // Wait for the on start failed callback.
            assertThat(countDownLatch.await(1, TimeUnit.SECONDS)).isTrue();
            assertThat(rangingSessionCallback.onOpenedCalled).isFalse();
            assertThat(rangingSessionCallback.onOpenFailedCalled).isTrue();
        } finally {
            if (cancellationSignal != null) {
                cancellationSignal.cancel();
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Simulates the app holding UWB_RANGING permission, but not UWB_PRIVILEGED.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/uwb/src/android/uwb/cts/UwbManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.uwb.cts.UwbManagerTest"	"testOpenRangingSessionWithoutUwbPrivileged"	"CtsUwbTestCases"	"1: permission"	"([5:/android/uwb/cts/UwbManagerTest.java]:[permission]:[5]:method_text:[    /**     * Simulates the app holding UWB_PRIVILEGED permission, but not UWB_RANGING.     */   ]) :|: 
    public void testOpenRangingSessionWithoutUwbPrivileged() {
        UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
        try {
            // Only hold UWB_RANGING permission
            uiAutomation.adoptShellPermissionIdentity(UWB_RANGING);
            mUwbManager.openRangingSession(new PersistableBundle(),
                    Executors.newSingleThreadExecutor(),
                    new RangingSessionCallback(new CountDownLatch(1)));
            // should fail if the call was successful without UWB_PRIVILEGED permission.
            fail();
        } catch (SecurityException e) {
            /* pass */
            Log.i(TAG, ""Failed with expected security exception: "" + e);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Simulates the app holding UWB_PRIVILEGED permission, but not UWB_RANGING.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/uwb/src/android/uwb/cts/UwbManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.uwb.cts.UwbManagerTest"	"testOpenRangingSessionWithoutUwbRanging"	"CtsUwbTestCases"	"1: permission"	"([21:/android/uwb/cts/UwbManagerTest.java]:[permission]:[21]:method_text:[d UWB_RANGING permission, but     * the proxied app not holding UWB_RANGING permission.     */   ]) :|: 
    public void testOpenRangingSessionWithoutUwbRanging() {
        UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
        try {
            // Needs UWB_PRIVILEGED permission which is held by shell.
            uiAutomation.adoptShellPermissionIdentity(UWB_PRIVILEGED);
            mUwbManager.openRangingSession(new PersistableBundle(),
                    Executors.newSingleThreadExecutor(),
                    new RangingSessionCallback(new CountDownLatch(1)));
            // should fail if the call was successful without UWB_RANGING permission.
            fail();
        } catch (SecurityException e) {
            /* pass */
            Log.i(TAG, ""Failed with expected security exception: "" + e);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    private AttributionSource getShellAttributionSourceWithRenouncedPermissions(
            @Nullable Set<String> renouncedPermissions) {
        try {
            AttributionSource shellAttributionSource =
                    new AttributionSource.Builder(Process.SHELL_UID)
                            .setPackageName(""com.android.shell"")
                            .setRenouncedPermissions(renouncedPermissions)
                            .build();
            PermissionManager permissionManager =
                    mContext.getSystemService(PermissionManager.class);
            permissionManager.registerAttributionSource(shellAttributionSource);
            return shellAttributionSource;
        } catch (SecurityException e) {
            fail(""Failed to create shell attribution source"" + e);
            return null;
        }
    }

    private Context createShellContextWithRenouncedPermissionsAndAttributionSource(
            @Nullable Set<String> renouncedPermissions) {
        return mContext.createContext(new ContextParams.Builder()
                .setRenouncedPermissions(renouncedPermissions)
                .setNextAttributionSource("	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/uwb/src/android/uwb/cts/UwbManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.uwb.cts.UwbManagerTest"	"testOpenRangingSessionWithoutUwbRangingInNextAttributeSource"	"CtsUwbTestCases"	"1: permission"	"([5:/android/uwb/cts/UwbManagerTest.java]:[permission]:[5]:method_text:[ + e);        } finally {            uiAutomation.dropShellPermissionIdentity();        }    }}]) :|: 
    public void testOpenRangingSessionWithoutUwbRangingInNextAttributeSource() {
        UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
        try {
            // Only hold UWB_PRIVILEGED permission
            uiAutomation.adoptShellPermissionIdentity();
            Context shellContextWithUwbRangingRenounced =
                    createShellContextWithRenouncedPermissionsAndAttributionSource(
                            Set.of(UWB_RANGING));
            UwbManager uwbManagerWithUwbRangingRenounced =
                    shellContextWithUwbRangingRenounced.getSystemService(UwbManager.class);
            uwbManagerWithUwbRangingRenounced.openRangingSession(new PersistableBundle(),
                    Executors.newSingleThreadExecutor(),
                    new RangingSessionCallback(new CountDownLatch(1)));
            // should fail if the call was successful without UWB_RANGING permission.
            fail();
        } catch (SecurityException e) {
            /* pass */
            Log.i(TAG, ""Failed with expected security exception: "" + e);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/uwb/src/android/uwb/cts/UwbManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.jobscheduler.cts.IdleConstraintTest"	"testScreenOffDeviceOnDockNoChangeState"	"CtsJobSchedulerTestCases"	"1: permission"	"([4:/android/jobscheduler/cts/IdleConstraintTest.java]:[permission]:[4]:method_text:[d.sleep(2_000);    }    /**     * Ensure automotive projection is considered active.     */   ]) :|: public void testScreenOffDeviceOnDockNoChangeState() throws Exception {
        if (!isDockStateSupported()) {
            return;
        }
        toggleScreenOn(false);
        triggerIdleMaintenance();
        verifyIdleState();

        toggleFakeDeviceDockState(false /* active */);
        verifyIdleState();
    }

    private void setAutomotiveProjection(boolean on) throws Exception {
        UiModeManager uiModeManager = getContext().getSystemService(UiModeManager.class);
        if (on) {
            assertTrue(SystemUtil.callWithShellPermissionIdentity(
                    () -> uiModeManager.requestProjection(UiModeManager.PROJECTION_TYPE_AUTOMOTIVE),
                    Manifest.permission.TOGGLE_AUTOMOTIVE_PROJECTION));
        } else {
            SystemUtil.callWithShellPermissionIdentity(
                    () -> uiModeManager.releaseProjection(UiModeManager.PROJECTION_TYPE_AUTOMOTIVE),
                    Manifest.permission.TOGGLE_AUTOMOTIVE_PROJECTION);
        }
        Thread.sleep(2_000);
    }

    /**
     * Ensure automotive projection is considered active.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/IdleConstraintTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.jobscheduler.cts.JobThrottlingTest"	"testRestrictingStopReason_Doze"	"CtsJobSchedulerTestCases"	"1: permission"	"([4:/android/jobscheduler/cts/JobThrottlingTest.java]:[permission]:[4]:method_text:[sTrue();    }    private interface Condition {        boolean isTrue() throws Exception;    }}]) :|: 
    public void testRestrictingStopReason_Doze() throws Exception {
        assumeTrue(""device idle not enabled"", mDeviceIdleEnabled);

        toggleDozeState(false);
        mTestAppInterface.scheduleJob(false, NETWORK_TYPE_NONE, false);
        runJob();
        assertTrue(""Job did not start after scheduling"",
                mTestAppInterface.awaitJobStart(DEFAULT_WAIT_TIMEOUT));

        toggleDozeState(true);
        assertTrue(""Job did not stop on entering doze"",
                mTestAppInterface.awaitJobStop(DEFAULT_WAIT_TIMEOUT));
        assertEquals(JobParameters.STOP_REASON_DEVICE_STATE,
                mTestAppInterface.getLastParams().getStopReason());
    }

    @After
    public void tearDown() throws Exception {
        AppOpsUtils.reset(TEST_APP_PACKAGE);
        // Lock thermal service to not throttling
        ThermalUtils.overrideThermalNotThrottling();
        if (mDeviceIdleEnabled) {
            toggleDozeState(false);
        }
        mTestAppInterface.cleanup();
        BatteryUtils.runDumpsysBatteryReset();
        BatteryUtils.enableBatterySaver(false);
        removeTestAppFromTempWhitelist();

        // Ensure that we leave WiFi in its previous state.
        if (mHasWifi && mWifiManager.isWifiEnabled() != mInitialWiFiState) {
            try {
                setWifiState(mInitialWiFiState, mCm, mWifiManager);
            } catch (AssertionFailedError e) {
                // Don't fail the test just because wifi state wasn't set in tearDown.
                Log.e(TAG, ""Failed to return wifi state to "" + mInitialWiFiState, e);
            }
        }
        mDeviceConfigStateHelper.restoreOriginalValues();
        Settings.Global.putString(mContext.getContentResolver(),
                Settings.Global.ENABLE_RESTRICTED_BUCKET, mInitialRestrictedBucketEnabled);
        if (isAirplaneModeOn() != mInitialAirplaneModeState) {
            setAirplaneMode(mInitialAirplaneModeState);
        }
        mUiDevice.executeShellCommand("	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobThrottlingTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.jobscheduler.cts.JobInfoTest"	"testRequiredNetwork"	"CtsJobSchedulerTestCases"	"1: INTERNET"	"([1:/android/jobscheduler/cts/JobInfoTest.java]:[INTERNET]:[1]:method_text:[ JobInfo object.        mJobScheduler.schedule(ji);    }    @SuppressWarnings(""deprecation"")   ]) :|: public void testRequiredNetwork() {
        final NetworkRequest nr = new NetworkRequest.Builder()
                .addCapability(NET_CAPABILITY_INTERNET)
                .addCapability(NET_CAPABILITY_VALIDATED)
                .build();
        JobInfo ji = new JobInfo.Builder(JOB_ID, kJobServiceComponent)
                .setRequiredNetwork(nr)
                .build();
        assertEquals(nr, ji.getRequiredNetwork());
        // Confirm JobScheduler accepts the JobInfo object.
        mJobScheduler.schedule(ji);

        ji = new JobInfo.Builder(JOB_ID, kJobServiceComponent)
                .setRequiredNetwork(null)
                .build();
        assertNull(ji.getRequiredNetwork());
        // Confirm JobScheduler accepts the JobInfo object.
        mJobScheduler.schedule(ji);
    }

    @SuppressWarnings(""deprecation"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.jobscheduler.cts.JobInfoTest"	"testClipData"	"CtsJobSchedulerTestCases"	"1: permission"	"([2:/android/jobscheduler/cts/JobInfoTest.java]:[permission]:[2]:method_text:[  // Confirm JobScheduler accepts the JobInfo object.        mJobScheduler.schedule(ji);    }   ]) :|: public void testClipData() {
        final ClipData clipData = ClipData.newPlainText(""test"", ""testText"");
        JobInfo ji = new JobInfo.Builder(JOB_ID, kJobServiceComponent)
                .setClipData(clipData, Intent.FLAG_GRANT_READ_URI_PERMISSION)
                .build();
        assertEquals(clipData, ji.getClipData());
        assertEquals(Intent.FLAG_GRANT_READ_URI_PERMISSION, ji.getClipGrantFlags());
        // Confirm JobScheduler accepts the JobInfo object.
        mJobScheduler.schedule(ji);

        ji = new JobInfo.Builder(JOB_ID, kJobServiceComponent)
                .setClipData(null, 0)
                .build();
        assertNull(ji.getClipData());
        assertEquals(0, ji.getClipGrantFlags());
        // Confirm JobScheduler accepts the JobInfo object.
        mJobScheduler.schedule(ji);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.jobscheduler.cts.JobParametersTest"	"testClipData"	"CtsJobSchedulerTestCases"	"1: permission"	"([1:/android/jobscheduler/cts/JobParametersTest.java]:[permission]:[1]:method_text:[().getItemAt(0).getText());        assertEquals(grantFlags, params.getClipGrantFlags());    }   ]) :|: public void testClipData() throws Exception {
        final ClipData clipData = ClipData.newPlainText(""test"", ""testText"");
        final int grantFlags = Intent.FLAG_GRANT_READ_URI_PERMISSION;
        JobInfo ji = new JobInfo.Builder(JOB_ID, kJobServiceComponent)
                .setClipData(clipData, grantFlags)
                .build();

        kTestEnvironment.setExpectedExecutions(1);
        mJobScheduler.schedule(ji);
        runSatisfiedJob(JOB_ID);
        assertTrue(""Job didn't fire immediately"", kTestEnvironment.awaitExecution());

        JobParameters params = kTestEnvironment.getLastStartJobParameters();
        assertEquals(clipData.getItemCount(), params.getClipData().getItemCount());
        assertEquals(clipData.getItemAt(0).getText(), params.getClipData().getItemAt(0).getText());
        assertEquals(grantFlags, params.getClipGrantFlags());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/JobParametersTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.jobscheduler.cts.ConnectivityConstraintTest"	"isWifiEnabled"	"CtsJobSchedulerTestCases"	"1: INTERNET"	"([1:/android/jobscheduler/cts/ConnectivityConstraintTest.java]:[INTERNET]:[1]:method_text:[ device     * is connected to WiFi. This will fail if a wifi connection is unavailable.     */   ]) :|: public void test/*
 *.
 */
package android.jobscheduler.cts;

import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;
import static android.net.NetworkCapabilities.TRANSPORT_CELLULAR;
import static android.net.NetworkCapabilities.TRANSPORT_WIFI;

import static com.android.compatibility.common.util.TestUtils.waitUntil;

import android.Manifest;
import android.annotation.TargetApi;
import android.app.job.JobInfo;
import android.app.job.JobParameters;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.net.ConnectivityManager;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;
import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.platform.test.annotations.RequiresDevice;
import android.provider.Settings;
import android.util.Log;

import com.android.compatibility.common.util.AppStandbyUtils;
import com.android.compatibility.common.util.BatteryUtils;
import com.android.compatibility.common.util.CallbackAsserter;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

import junit.framework.AssertionFailedError;

import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Schedules jobs with the {@link android.app.job.JobScheduler} that have network connectivity
 * constraints.
 * Requires manipulating the {@link android.net.wifi.WifiManager} to ensure an unmetered network.
 * Similarly, requires that the phone be connected to a wifi hotspot, or else the test will fail.
 */
@TargetA"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/ConnectivityConstraintTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.jobscheduler.cts.ConnectivityConstraintTest"	"testJobParametersNetwork"	"CtsJobSchedulerTestCases"	"1: INTERNET"	"([1:/android/jobscheduler/cts/ConnectivityConstraintTest.java]:[INTERNET]:[1]:method_text:[device supports a mobile data connection, then this connection     * will be available.     */   ]) :|: public void testJobParametersNetwork() throws Exception {
        setAirplaneMode(false);

        // Everything good.
        final NetworkRequest nr = new NetworkRequest.Builder()
                .addCapability(NET_CAPABILITY_INTERNET)
                .addCapability(NET_CAPABILITY_VALIDATED)
                .build();
        JobInfo ji = mBuilder.setRequiredNetwork(nr).build();

        kTestEnvironment.setExpectedExecutions(1);
        mJobScheduler.schedule(ji);
        runSatisfiedJob(CONNECTIVITY_JOB_ID);
        assertTrue(""Job didn't fire immediately"", kTestEnvironment.awaitExecution());

        JobParameters params = kTestEnvironment.getLastStartJobParameters();
        assertNotNull(params.getNetwork());
        final NetworkCapabilities capabilities =
                getContext().getSystemService(ConnectivityManager.class)
                        .getNetworkCapabilities(params.getNetwork());
        assertTrue(nr.canBeSatisfiedBy(capabilities));

        // Deadline passed with no network satisfied.
        setAirplaneMode(true);
        ji = mBuilder
                .setRequiredNetwork(nr)
                .setOverrideDeadline(0)
                .build();

        kTestEnvironment.setExpectedExecutions(1);
        mJobScheduler.schedule(ji);
        runSatisfiedJob(CONNECTIVITY_JOB_ID);
        assertTrue(""Job didn't fire immediately"", kTestEnvironment.awaitExecution());

        params = kTestEnvironment.getLastStartJobParameters();
        assertNull(params.getNetwork());

        // No network requested
        setAirplaneMode(false);
        ji = mBuilder.setRequiredNetwork(null).build();
        kTestEnvironment.setExpectedExecutions(1);
        mJobScheduler.schedule(ji);
        runSatisfiedJob(CONNECTIVITY_JOB_ID);
        assertTrue(""Job didn't fire immediately"", kTestEnvironment.awaitExecution());

        params = kTestEnvironment.getLastStartJobParameters();
        assertNull(params.getNetwork());
    }

    // ------------------------------"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/ConnectivityConstraintTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.jobscheduler.cts.ConnectivityConstraintTest"	"testExpeditedJobDoesNotBypassSimultaneousFirewalls_withDataSaver"	"CtsJobSchedulerTestCases"	"1: permission"	"([5:/android/jobscheduler/cts/ConnectivityConstraintTest.java]:[permission]:[5]:method_text:[ptyMessageDelayed(MSG_CHECK_ACTIVE_NETWORK, 5000);                }            }        }    }}]) :|: public void testExpeditedJobDoesNotBypassSimultaneousFirewalls_withDataSaver()
            throws Exception {
        if (!BatteryUtils.isBatterySaverSupported()) {
            Log.d(TAG, ""Skipping test that requires battery saver support"");
            return;
        }
        if (mHasWifi) {
            setWifiMeteredState(true);
        } else if (checkDeviceSupportsMobileData()) {
            disconnectWifiToConnectToMobile();
        } else {
            Log.d(TAG, ""Skipping test that requires a metered network."");
            return;
        }
        if (!AppStandbyUtils.isAppStandbyEnabled()) {
            Log.d(TAG, ""App standby not enabled"");
            return;
        }

        Settings.Global.putString(mContext.getContentResolver(),
                Settings.Global.ENABLE_RESTRICTED_BUCKET, ""1"");
        mDeviceConfigStateHelper.set(""qc_max_session_count_restricted"", ""0"");
        SystemUtil.runShellCommand(""am set-standby-bucket ""
                + kJobServiceComponent.getPackageName() + "" restricted"");
        BatteryUtils.runDumpsysBatteryUnplug();
        BatteryUtils.enableBatterySaver(true);
        setDataSaverEnabled(true);

        mTestAppInterface = new TestAppInterface(mContext, CONNECTIVITY_JOB_ID);

        mTestAppInterface.scheduleJob(false,  JobInfo.NETWORK_TYPE_ANY, true);
        mTestAppInterface.runSatisfiedJob();

        assertFalse(""Expedited job fired with multiple firewalls, including data saver."",
                mTestAppInterface.awaitJobStart(DEFAULT_TIMEOUT_MILLIS));
    }

    // --------------------------------------------------------------------------------------------
    // Utility methods
    // --------------------------------------------------------------------------------------------

    /**
     * Determine whether the device running these CTS tests should be subject to tests involving
     * mobile data.
     * @return True if this device will support a mobile data connection.
     */
    private boolean checkD"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/ConnectivityConstraintTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.biometrics.fingerprint.FingerprintServiceTest"	"adoptShellPermissionIdentity"	"CtsBiometricsTestCases"	"1: permission"	"([2:/android/server/biometrics/fingerprint/FingerprintServiceTest.java]:[permission]:[2]:method_text:[   }        }        mInstrumentation.getUiAutomation().dropShellPermissionIdentity();    }   ]) :|: /*
 *.
 */

package android.server.biometrics.fingerprint;

import static android.server.biometrics.SensorStates.SensorState;
import static android.server.biometrics.SensorStates.UserState;
import static android.server.biometrics.fingerprint.Components.AUTH_ON_CREATE_ACTIVITY;

import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assume.assumeTrue;

import android.app.Instrumentation;
import android.hardware.biometrics.BiometricTestSession;
import android.hardware.biometrics.SensorProperties;
import android.hardware.fingerprint.FingerprintManager;
import android.os.Bundle;
import android.platform.test.annotations.Presubmit;
import android.server.biometrics.BiometricServiceState;
import android.server.biometrics.SensorStates;
import android.server.biometrics.Utils;
import android.server.wm.ActivityManagerTestBase;
import android.server.wm.TestJournalProvider.TestJournal;
import android.server.wm.TestJournalProvider.TestJournalContainer;
import android.server.wm.UiDeviceUtils;
import android.server.wm.WindowManagerState;
import android.util.Log;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.android.server.biometrics.nano.SensorServiceStateProto;
import com.android.server.biometrics.nano.SensorStateProto;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

@SuppressWarnings(""deprecation"")
@Presubmit
public class FingerprintServiceTest extends ActivityManagerTestBase {
    private static final String TAG = ""FingerprintServiceTest"";

    private static final String DUMPSYS_FINGERPRINT = ""dumpsys fingerprint --proto --state"";

    private SensorStates getSensorStates() throws Exception {
        final byte[]"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/biometrics/src/android/server/biometrics/fingerprint/FingerprintServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.BackgroundActivityLaunchTest"	"testStartBgActivity_usingStartActivitiesFromBackgroundPermission"	"CtsActivityManagerBackgroundActivityTestCases"	"1: permission"	"([4:/android/server/wm/BackgroundActivityLaunchTest.java]:[permission]:[4]:method_text:[ActivityName(APP_A_BACKGROUND_ACTIVITY),                mWmState.getTopActivityName(0));    }   ]) :|: 
    public void testStartBgActivity_usingStartActivitiesFromBackgroundPermission()
            throws Exception {
        // Disable SAW app op for shell, since that can also allow starting activities from bg.
        AppOpsUtils.setOpMode(SHELL_PACKAGE, ""android:system_alert_window"", MODE_ERRORED);

        // Launch the activity via a shell command, this way the system doesn't have info on which
        // app launched the activity and thus won't use instrumentation privileges to launch it. But
        // the shell has the START_ACTIVITIES_FROM_BACKGROUND permission, so we expect it to
        // succeed.
        // See testBackgroundActivityBlocked() for a case where an app without the
        // START_ACTIVITIES_FROM_BACKGROUND permission is blocked from launching the activity from
        // the background.
        launchActivity(APP_A_BACKGROUND_ACTIVITY);

        // If the activity launches, it means the START_ACTIVITIES_FROM_BACKGROUND permission works.
        assertEquals(""Launched activity should be at the top"",
                ComponentNameUtils.getActivityName(APP_A_BACKGROUND_ACTIVITY),
                mWmState.getTopActivityName(0));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/backgroundactivity/src/android/server/wm/BackgroundActivityLaunchTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.BackgroundActivityLaunchTest"	"testPendingIntentBroadcast_appBIsBackground"	"CtsActivityManagerBackgroundActivityTestCases"	"1: permission"	"([6:/android/server/wm/BackgroundActivityLaunchTest.java]:[permission]:[6]:method_text:[er(int userId) {        executeShellCommand(String.format(""pm remove-user %d"", userId));    }   ]) :|: 
    public void testPendingIntentBroadcast_appBIsBackground() throws Exception {
        EventReceiver receiver = new EventReceiver(
                Event.APP_A_START_BACKGROUND_ACTIVITY_BROADCAST_RECEIVED);

        // Send pendingIntent from AppA to AppB, and the AppB launch the pending intent to start
        // activity in App A
        sendPendingIntentBroadcast(0, receiver.getNotifier());

        // Waits for final hoop in AppA to start looking for activity, otherwise it could succeed
        // if the broadcast took long time to get executed (which may happen after boot).
        receiver.waitForEventOrThrow(BROADCAST_DELIVERY_TIMEOUT_MS);
        boolean result = waitForActivityFocused(APP_A_BACKGROUND_ACTIVITY);
        assertFalse(""Should not able to launch background activity"", result);
        assertTaskStack(null, APP_A_BACKGROUND_ACTIVITY);
    }

    /**
     * Returns a list of alive users on the device
     */
    private List<UserInfo> getAliveUsers() {
        // Setting the CREATE_USERS permission in AndroidManifest.xml has no effect when the test
        // is run through the CTS harness, so instead adopt it as a shell permission. We use
        // the CREATE_USERS permission instead of MANAGE_USERS because the shell can never use
        // MANAGE_USERS.
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        uiAutomation.adoptShellPermissionIdentity(Manifest.permission.CREATE_USERS);
        List<UserInfo> userList = mContext.getSystemService(UserManager.class)
                .getUsers(/* excludePartial= */ true,
                        /* excludeDying= */ true,
                        /* excludePreCreated= */ true);
        uiAutomation.dropShellPermissionIdentity();
        return userList;
    }

    /**
     * Removes the guest user from the device if present
     */
    private void removeGuestUser() {
        List<UserInfo> userList = getAliveUsers();
        for (UserInfo info : use"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/backgroundactivity/src/android/server/wm/BackgroundActivityLaunchTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.AddWindowAsUserTest"	"testAddWindowSecondaryUser"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/AddWindowAsUserTest.java]:[permission]:[1]:method_text:[ateContextAsUser(user, 0);        return userContext.getSystemService(WindowManager.class);    }}]) :|: 
    public void testAddWindowSecondaryUser() {
        // Get original userId from context first, not every platform use SYSTEM as default user.
        final int myUserId = mContext.getUserId();
        testAddWindowWithUser(UserHandle.of(myUserId), false /* shouldCatchException */);

        // Doesn't grant INTERACT_ACROSS_USERS_FULL permission, so any other user should not
        // able to add window.
        testAddWindowWithUser(UserHandle.ALL, true);
    }

    private void testAddWindowWithUser(UserHandle user, boolean shouldCatchException) {
        mInstrumentation.runOnMainSync(() -> {
            final View view = new View(mContext);
            final WindowManager wm = getWindowManagerForUser(user);
            boolean catchException = false;
            try {
                wm.addView(view, new WindowManager.LayoutParams(TYPE_APPLICATION_OVERLAY));
            } catch (WindowManager.BadTokenException exception) {
                catchException = true;
            } finally {
                if (!catchException) {
                    wm.removeViewImmediate(view);
                }
            }
            if (shouldCatchException) {
                assertTrue(""Should receive exception for user "" + user, catchException);
            } else {
                assertFalse(""Shouldn't receive exception for user "" + user, catchException);
            }
        });
    }

    private WindowManager getWindowManagerForUser(UserHandle user) {
        final Context userContext = mContext.createContextAsUser(user, 0);
        return userContext.getSystemService(WindowManager.class);
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/AddWindowAsUserTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.WindowFocusTests"	"getDisplayId"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/WindowFocusTests.java]:[permission]:[1]:method_text:[     * - The window which lost top-focus can receive display-unspecified cancel events.     */   ]) :|: /*
 *
 */

package android.server.wm;

import static android.hardware.display.DisplayManager.VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY;
import static android.hardware.display.DisplayManager.VIRTUAL_DISPLAY_FLAG_PUBLIC;
import static android.view.Display.DEFAULT_DISPLAY;
import static android.view.Display.INVALID_DISPLAY;
import static android.view.KeyEvent.ACTION_DOWN;
import static android.view.KeyEvent.ACTION_UP;
import static android.view.KeyEvent.FLAG_CANCELED;
import static android.view.KeyEvent.KEYCODE_0;
import static android.view.KeyEvent.KEYCODE_1;
import static android.view.KeyEvent.KEYCODE_2;
import static android.view.KeyEvent.KEYCODE_3;
import static android.view.KeyEvent.KEYCODE_4;
import static android.view.KeyEvent.KEYCODE_5;
import static android.view.KeyEvent.KEYCODE_6;
import static android.view.KeyEvent.KEYCODE_7;
import static android.view.KeyEvent.KEYCODE_8;
import static android.view.KeyEvent.keyCodeToString;

import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assume.assumeFalse;
import static org.junit.Assume.assumeTrue;

import android.app.Activity;
import android.content.Context;
import android.content.res.Configuration;
import android.graphics.Canvas;
import android.graphics.PixelFormat;
import android.graphics.Point;
import android.hardware.display.DisplayManager;
import android.hardware.display.VirtualDisplay;
import android.media.ImageReader;
import android.os.SystemClock;
import android.platform.test.annotations.Presubmit;
import android.view.Display;
import android.view.KeyEvent;
import android.view.MotionEvent;
import android.view.View;
import android.view.WindowManager.LayoutParams;

import androidx.annotation.NonNull;

import com.android.compatibility.common.util.SystemUtil;

import org.junit.Test;

import java.util.ArrayList;

import javax.anno"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowFocusTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.SurfaceViewSurfaceValidatorTest"	"TestName"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([3:/android/server/wm/SurfaceViewSurfaceValidatorTest.java]:[permission]:[3]:method_text:[hat showing a SurfaceView on top but not drawing in to it will not produce a background.     */   ]) :|: /*
 *.
 */
package android.server.wm;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import static android.server.wm.ActivityManagerTestBase.createFullscreenActivityScenarioRule;
import static android.server.wm.WindowManagerState.getLogicalDisplaySize;

import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Color;
import android.support.test.uiautomator.UiObjectNotFoundException;
import android.view.cts.surfacevalidator.AnimationFactory;
import android.view.cts.surfacevalidator.CapturedActivity;
import android.view.cts.surfacevalidator.PixelChecker;
import android.view.cts.surfacevalidator.PixelColor;
import android.view.cts.surfacevalidator.SurfaceControlTestCase;
import android.view.Gravity;
import android.view.SurfaceControl;
import android.view.SurfaceHolder;
import android.view.SurfaceView;
import android.widget.FrameLayout;

import androidx.test.ext.junit.rules.ActivityScenarioRule;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TestName;

public class SurfaceViewSurfaceValidatorTest {
    private static final int DEFAULT_LAYOUT_WIDTH = 100;
    private static final int DEFAULT_LAYOUT_HEIGHT = 100;
    private static final int DEFAULT_BUFFER_WIDTH = 640;
    private static final int DEFAULT_BUFFER_HEIGHT = 480;

    @Rule
    public final ActivityScenarioRule<CapturedActivity> mActivityRule =
                createFullscreenActivityScenarioRule(CapturedActivity.class);

    @Rule
    public TestName mName = new TestName();
    private CapturedActivity mActivity;

    @Before
    public void setup() {
        mActivityRule.getScenario().onActivity(activity -> mActivity = activity);
        mActivity.dismissPermissionDialog();
        mActivity.setLogicalDisplaySize(getLogicalDisplaySize());
    }

    /**
     * Want to be especially sure we don't leave up the permission dialog, so try and dismiss
     * after test."	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/SurfaceViewSurfaceValidatorTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.AppConfigurationTests"	"getDefaultDisplay"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/AppConfigurationTests.java]:[permission]:[1]:method_text:[lues reported in fullscreen should be larger than those reported in     * docked state.     */   ]) :|: /*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License""); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package android.server.wm;

import static android.app.WindowConfiguration.ACTIVITY_TYPE_STANDARD;
import static android.app.WindowConfiguration.WINDOWING_MODE_FREEFORM;
import static android.app.WindowConfiguration.WINDOWING_MODE_FULLSCREEN;
import static android.app.WindowConfiguration.WINDOWING_MODE_MULTI_WINDOW;
import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE;
import static android.content.pm.ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
import static android.content.res.Configuration.ORIENTATION_LANDSCAPE;
import static android.content.res.Configuration.ORIENTATION_PORTRAIT;
import static android.server.wm.StateLogger.logE;
import static android.server.wm.WindowManagerState.STATE_RESUMED;
import static android.server.wm.WindowManagerState.dpToPx;
import static android.server.wm.app.Components.BROADCAST_RECEIVER_ACTIVITY;
import static android.server.wm.app.Components.DIALOG_WHEN_LARGE_ACTIVITY;
import static android.server.wm.app.Components.LANDSCAPE_ORIENTATION_ACTIVITY;
import static android.server.wm.app.Components.LAUNCHING_ACTIVITY;
import static android.server.wm.app.Components.LandscapeOrientationActivity.EXTRA_APP_CONFIG_INFO;
import static android.server.wm.app.Components.LandscapeOrientationActivity.EXTRA_CONFIG_INFO_IN_ON_CREATE;
import static android.server.wm.app.Components.LandscapeOrientationActivity.EXTRA_DISPLAY_REAL_S"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/AppConfigurationTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.BlurTests"	"verifyOnlyBackgroundImageVisible"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([2:/android/server/wm/BlurTests.java]:[permission]:[2]:method_text:[urationScale);        });        setForceBlurDisabled(mSavedWindowBlurDisabledSetting);    }   ]) :|: /*
 *
 */

package android.server.wm;

import static android.app.ActivityTaskManager.INVALID_STACK_ID;
import static android.provider.Settings.Global.ANIMATOR_DURATION_SCALE;
import static android.server.wm.CliIntentExtra.extraInt;
import static android.server.wm.ComponentNameUtils.getWindowName;
import static android.server.wm.app.Components.BACKGROUND_IMAGE_ACTIVITY;
import static android.server.wm.app.Components.BAD_BLUR_ACTIVITY;
import static android.server.wm.app.Components.BLUR_ACTIVITY;
import static android.server.wm.app.Components.BLUR_ATTRIBUTES_ACTIVITY;
import static android.server.wm.app.Components.BlurActivity.EXTRA_BACKGROUND_BLUR_RADIUS_PX;
import static android.server.wm.app.Components.BlurActivity.EXTRA_BLUR_BEHIND_RADIUS_PX;
import static android.server.wm.app.Components.BlurActivity.EXTRA_NO_BLUR_BACKGROUND_COLOR;
import static android.view.Display.DEFAULT_DISPLAY;

import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;

import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.assertFalse;
import static org.junit.Assume.assumeTrue;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.spy;

import android.content.ComponentName;
import android.content.ContentResolver;
import android.graphics.Bitmap;
import android.graphics.Color;
import android.graphics.Rect;
import android.os.Bundle;
import android.platform.test.annotations.Presubmit;
import android.provider.Settings;
import android.view.View;
import android.view.WindowManager;
import android.widget.LinearLayout;

import androidx.test.filters.FlakyTest;

import com.android.compatibility.common.util.ColorUtils;
import com.android.compatibility.common.util.SystemUtil;

import java.util.function.Consumer;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;

@Presubmit
@FlakyTest(detail = ""Promote once confirmed non-flaky"")
public class"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/BlurTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.CrossAppDragAndDropTests"	"uptimeMillis"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([3:/android/server/wm/CrossAppDragAndDropTests.java]:[permission]:[3]:method_text:[result mismatch,"", expectedResult,                    results.get(resultKey));        }    }   ]) :|: /*
 *.
 */

package android.server.wm;

import static android.app.WindowConfiguration.WINDOWING_MODE_FREEFORM;
import static android.server.wm.CliIntentExtra.extraString;
import static android.server.wm.UiDeviceUtils.dragPointer;
import static android.server.wm.dndsourceapp.Components.DRAG_SOURCE;
import static android.server.wm.dndtargetapp.Components.DROP_TARGET;
import static android.server.wm.dndtargetappsdk23.Components.DROP_TARGET_SDK23;
import static android.view.Display.DEFAULT_DISPLAY;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import android.content.ComponentName;
import android.graphics.Point;
import android.graphics.Rect;
import android.os.SystemClock;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.Presubmit;
import android.server.wm.WindowManagerState.ActivityTask;
import android.util.Log;
import android.view.Display;

import com.google.common.collect.ImmutableSet;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.util.Map;

/**
 * Build/Install/Run:
 *     atest CtsWindowManagerDeviceTestCases:CrossAppDragAndDropTests
 */
@Presubmit
@AppModeFull(reason = ""Requires android.permission.MANAGE_ACTIVITY_TASKS"")
public class CrossAppDragAndDropTests extends ActivityManagerTestBase {
    private static final String TAG = ""CrossAppDragAndDrop"";

    private static final int SWIPE_STEPS = 100;

    private static final String FILE_GLOBAL = ""file_global"";
    private static final String FILE_LOCAL = ""file_local"";
    private static final String DISALLOW_GLOBAL = ""disallow_global"";
    private static final String CANCEL_SOON = ""cancel_soon"";
    private static final String GRANT_NONE = ""grant_none"";
    private static final String GRANT_READ = ""grant_read"";
    private static final String GRANT_WRITE = ""grant_w"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/CrossAppDragAndDropTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.CrossAppDragAndDropTests"	"testGrantNoneRequestRead"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/CrossAppDragAndDropTests.java]:[permission]:[1]:method_text:[ption {        assertDropResult(GRANT_NONE, REQUEST_READ, RESULT_NULL_DROP_PERMISSIONS);    }   ]) :|: 
    public void testGrantNoneRequestRead() throws Exception {
        assertDropResult(GRANT_NONE, REQUEST_READ, RESULT_NULL_DROP_PERMISSIONS);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/CrossAppDragAndDropTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.CrossAppDragAndDropTests"	"testGrantNoneRequestWrite"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/CrossAppDragAndDropTests.java]:[permission]:[1]:method_text:[tion {        assertDropResult(GRANT_NONE, REQUEST_WRITE, RESULT_NULL_DROP_PERMISSIONS);    }   ]) :|: 
    public void testGrantNoneRequestWrite() throws Exception {
        assertDropResult(GRANT_NONE, REQUEST_WRITE, RESULT_NULL_DROP_PERMISSIONS);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/CrossAppDragAndDropTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.SplashscreenTests"	"testShortcutChangeTheme"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/SplashscreenTests.java]:[permission]:[1]:method_text:[      }        mWmState.waitForActivityRemoved(activity);        separateTestJournal();    }   ]) :|: 
    public void testShortcutChangeTheme() {
        // TODO(b/192431448): Allow Automotive to skip this test until Splash Screen is properly
        // applied insets by system bars in AAOS.
        assumeFalse(isCar());

        final LauncherApps launcherApps = mContext.getSystemService(LauncherApps.class);
        final ShortcutManager shortcutManager = mContext.getSystemService(ShortcutManager.class);
        assumeTrue(launcherApps != null && shortcutManager != null);

        final String shortCutId = ""shortcut1"";
        final ShortcutInfo.Builder b = new ShortcutInfo.Builder(
                mContext, shortCutId);
        final Intent i = new Intent(ACTION_MAIN)
                .setComponent(SPLASHSCREEN_ACTIVITY);
        final ShortcutInfo shortcut = b.setShortLabel(""label"")
                .setLongLabel(""long label"")
                .setIntent(i)
                .setStartingTheme(android.R.style.Theme_Black_NoTitleBar_Fullscreen)
                .build();
        try {
            shortcutManager.addDynamicShortcuts(Collections.singletonList(shortcut));
            runWithShellPermission(() -> launcherApps.startShortcut(shortcut, null, null));
            testSplashScreenColor(SPLASHSCREEN_ACTIVITY, Color.BLACK, Color.WHITE);
        } finally {
            shortcutManager.removeDynamicShortcuts(Collections.singletonList(shortCutId));
        }
    }

    private void waitAndAssertOverrideThemeColor(int expectedColor) {
        final ComponentName activity = SPLASH_SCREEN_REPLACE_THEME_ACTIVITY;
        final Bundle resultExtras = Condition.waitForResult(
                new Condition<Bundle>(""splash screen theme color of "" + activity)
                        .setResultSupplier(() -> TestJournalProvider.TestJournalContainer.get(
                                OVERRIDE_THEME_COMPONENT).extras)
                        .setResultValidator(extras -> extras.containsKey(OVERRIDE_THEME_COLOR)));
        if (resultExtras == null) {
            fail(""No reported"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/SplashscreenTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.MultiWindowTests"	"testDisallowUpdateWindowingModeWhenInLockedTask"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([3:/android/server/wm/MultiWindowTests.java]:[permission]:[3]:method_text:[rmission(() -> {                mAtm.stopSystemLockTaskMode();            });        }    }   ]) :|: 
    public void testDisallowUpdateWindowingModeWhenInLockedTask() {
        launchActivity(TEST_ACTIVITY, WINDOWING_MODE_FULLSCREEN);
        final WindowManagerState.ActivityTask task =
                mWmState.getStandardRootTaskByWindowingMode(
                        WINDOWING_MODE_FULLSCREEN).getTopTask();

        try {
            // Lock the task
            runWithShellPermission(() -> mAtm.startSystemLockTaskMode(task.mTaskId));
            waitForOrFail(""Fail to enter locked task mode"", () ->
                    mAm.getLockTaskModeState() != LOCK_TASK_MODE_NONE);

            // Verify specifying non-fullscreen windowing mode will fail.
            boolean exceptionThrown = false;
            try {
                runWithShellPermission(() -> {
                    final WindowContainerTransaction wct = new WindowContainerTransaction()
                            .setWindowingMode(
                                    mTaskOrganizer.getTaskInfo(task.mTaskId).getToken(),
                                    WINDOWING_MODE_MULTI_WINDOW);
                    mTaskOrganizer.applyTransaction(wct);
                });
            } catch (UnsupportedOperationException e) {
                exceptionThrown = true;
            }
            assertTrue(""Not allowed to specify windowing mode while in locked task mode."",
                    exceptionThrown);
        } finally {
            runWithShellPermission(() -> {
                mAtm.stopSystemLockTaskMode();
            });
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiWindowTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.MultiWindowTests"	"testDisallowHierarchyOperationWhenInLockedTask"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([3:/android/server/wm/MultiWindowTests.java]:[permission]:[3]:method_text:[nd with another     * translucent activity on top while in split-screen-secondary task.     */   ]) :|: 
    public void testDisallowHierarchyOperationWhenInLockedTask() {
        launchActivity(TEST_ACTIVITY, WINDOWING_MODE_FULLSCREEN);
        launchActivity(LAUNCHING_ACTIVITY, WINDOWING_MODE_MULTI_WINDOW);
        final WindowManagerState.ActivityTask task = mWmState
                .getStandardRootTaskByWindowingMode(WINDOWING_MODE_FULLSCREEN).getTopTask();
        final WindowManagerState.ActivityTask root = mWmState
                .getStandardRootTaskByWindowingMode(WINDOWING_MODE_MULTI_WINDOW).getTopTask();

        try {
            // Lock the task
            runWithShellPermission(() -> {
                mAtm.startSystemLockTaskMode(task.mTaskId);
            });
            waitForOrFail(""Fail to enter locked task mode"", () ->
                    mAm.getLockTaskModeState() != LOCK_TASK_MODE_NONE);

            boolean gotAssertionError = false;
            try {
                runWithShellPermission(() -> {
                    // Fetch tokens of testing task and multi-window root.
                    final WindowContainerToken multiWindowRoot =
                            mTaskOrganizer.getTaskInfo(root.mTaskId).getToken();
                    final WindowContainerToken testChild =
                            mTaskOrganizer.getTaskInfo(task.mTaskId).getToken();

                    // Verify performing reparent operation is no operation.
                    final WindowContainerTransaction wct = new WindowContainerTransaction()
                            .reparent(testChild, multiWindowRoot, true /* onTop */);
                    mTaskOrganizer.applyTransaction(wct);
                    waitForOrFail(""Fail to reparent"", () ->
                            mTaskOrganizer.getTaskInfo(task.mTaskId).getParentTaskId()
                                    == root.mTaskId);
                });
            } catch (AssertionError e) {
                gotAssertionError = true;
            }
            assertTrue(""Not allowed to perform hierarchy operation while in"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiWindowTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.CompatChangeTests"	"testOverrideMinAspectRatioActivityMinAspectRatioLargerThanOverride"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([3:/android/server/wm/CompatChangeTests.java]:[permission]:[3]:method_text:[  }    public static class SupportsSizeChangesPortraitActivity extends FocusableActivity {    }}]) :|: 
    @EnableCompatChanges({ActivityInfo.OVERRIDE_MIN_ASPECT_RATIO,
            ActivityInfo.OVERRIDE_MIN_ASPECT_RATIO_MEDIUM})
    public void testOverrideMinAspectRatioActivityMinAspectRatioLargerThanOverride() {
        runMinAspectRatioTest(NON_RESIZEABLE_ASPECT_RATIO_ACTIVITY,
                /* expected= */ ACTIVITY_MIN_ASPECT_RATIO);
    }

    /**
     * Launches the provided activity into size compat mode twice. The first time, the display
     * is resized to be half the size. The second time, the display is resized to be twice the
     * original size.
     *
     * @param activity                    the activity under test.
     * @param inSizeCompatModeAfterResize if the activity should be in size compat mode after
     *                                    resizing the display
     */
    private void runSizeCompatTest(ComponentName activity, boolean inSizeCompatModeAfterResize) {
        runSizeCompatTest(activity, /* resizeRatio= */ 0.5, inSizeCompatModeAfterResize);
        restoreDisplay(activity);
        runSizeCompatTest(activity, /* resizeRatio= */ 2, inSizeCompatModeAfterResize);
    }

    /**
     * Launches the provided activity on the default display, initially not in size compat mode.
     * After resizing the display, verifies if activity is in size compat mode or not
     *
     * @param activity                    the activity under test
     * @param resizeRatio                 the ratio to resize the display
     * @param inSizeCompatModeAfterResize if the activity should be in size compat mode after
     *                                    resizing the display
     */
    private void runSizeCompatTest(ComponentName activity, double resizeRatio,
            boolean inSizeCompatModeAfterResize) {
        launchActivity(activity);

        assertSizeCompatMode(activity, /* expectedInSizeCompatMode= */ false);

        resizeDisplay(activity, resizeRatio);

        assertSizeCompatMode(activity, inSizeCompatModeAfterResize);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/CompatChangeTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.ActivityTransitionTests"	"testTaskTransitionOverride"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/ActivityTransitionTests.java]:[permission]:[1]:method_text:[ss), bundle);        }    }    public static class TransitionActivity extends Activity {    }}]) :|: 
    public void testTaskTransitionOverride() throws Exception {
        assumeTrue(customTaskAnimationDisabled());

        final long expectedDurationMs = CUSTOM_ANIMATION_DURATION - 100L;
        final long minDurationMs = expectedDurationMs;
        final long maxDurationMs = expectedDurationMs + 1000L;
        final Range<Long> durationRange = new Range<>(minDurationMs, maxDurationMs);

        final CountDownLatch latch = new CountDownLatch(1);
        long[] transitionStartTime = new long[1];
        long[] transitionEndTime = new long[1];

        final ActivityOptions.OnAnimationStartedListener startedListener = () -> {
            transitionStartTime[0] = System.currentTimeMillis();
        };

        final ActivityOptions.OnAnimationFinishedListener finishedListener = () -> {
            transitionEndTime[0] = System.currentTimeMillis();
            latch.countDown();
        };

        SystemUtil.runWithShellPermissionIdentity(() -> {
            // Overriding task transit animation is enabled, so custom animation is played.
            final Bundle bundle = ActivityOptions.makeCustomTaskAnimation(mContext,
                    R.anim.alpha, 0, new Handler(Looper.getMainLooper()), startedListener,
                    finishedListener).toBundle();
            final Intent intent = new Intent().setComponent(TEST_ACTIVITY)
                    .addFlags(FLAG_ACTIVITY_NEW_TASK);
            mContext.startActivity(intent, bundle);
            mWmState.waitForAppTransitionIdleOnDisplay(DEFAULT_DISPLAY);
            waitAndAssertTopResumedActivity(TEST_ACTIVITY, DEFAULT_DISPLAY,
                    ""Activity must be launched"");

            latch.await(2, TimeUnit.SECONDS);
            final long totalTime = transitionEndTime[0] - transitionStartTime[0];
            assertTrue(""Actual transition duration should be in the range ""
                    + ""<"" + minDurationMs + "", "" + maxDurationMs + ""> ms, ""
                    + ""actual="" + totalTime, durationRange"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/ActivityTransitionTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.AlertWindowsTests"	"testAlertWindowAllowed"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/AlertWindowsTests.java]:[permission]:[1]:method_text:[TEST_ACTIVITY, true /* hasAlertWindowPermission */,                true /* atLeastO */);    }   ]) :|: 
    public void testAlertWindowAllowed() throws Exception {
        runAlertWindowTest(ALERT_WINDOW_TEST_ACTIVITY, true /* hasAlertWindowPermission */,
                true /* atLeastO */);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/AlertWindowsTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.AlertWindowsTests"	"testAlertWindowDisallowed"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/AlertWindowsTests.java]:[permission]:[1]:method_text:[EST_ACTIVITY, false /* hasAlertWindowPermission */,                true /* atLeastO */);    }   ]) :|: 
    public void testAlertWindowDisallowed() throws Exception {
        runAlertWindowTest(ALERT_WINDOW_TEST_ACTIVITY, false /* hasAlertWindowPermission */,
                true /* atLeastO */);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/AlertWindowsTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.AlertWindowsTests"	"testAlertWindowAllowedSdk25"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/AlertWindowsTests.java]:[permission]:[1]:method_text:[EST_ACTIVITY, true /* hasAlertWindowPermission */,                false /* atLeastO */);    }   ]) :|: 
    public void testAlertWindowAllowedSdk25() throws Exception {
        runAlertWindowTest(SDK25_ALERT_WINDOW_TEST_ACTIVITY, true /* hasAlertWindowPermission */,
                false /* atLeastO */);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/AlertWindowsTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.AlertWindowsTests"	"testAlertWindowDisallowedSdk25"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([10:/android/server/wm/AlertWindowsTests.java]:[permission]:[10]:method_text:[      AppOpsUtils.setOpMode(activityName.getPackageName(), OPSTR_SYSTEM_ALERT_WINDOW, mode);    }}]) :|: 
    public void testAlertWindowDisallowedSdk25() throws Exception {
        runAlertWindowTest(SDK25_ALERT_WINDOW_TEST_ACTIVITY, false /* hasAlertWindowPermission */,
                false /* atLeastO */);
    }

    private void runAlertWindowTest(final ComponentName activityName,
            final boolean hasAlertWindowPermission, final boolean atLeastO) throws Exception {
        setAlertWindowPermission(activityName, hasAlertWindowPermission);

        executeShellCommand(getAmStartCmd(activityName));
        mWmState.computeState(new WaitForValidActivityState(activityName));
        mWmState.assertVisibility(activityName, true);

        assertAlertWindows(activityName, hasAlertWindowPermission, atLeastO);
    }

    private boolean allWindowsHidden(List<WindowManagerState.WindowState> windows) {
        for (WindowManagerState.WindowState ws : windows) {
            if (ws.isSurfaceShown()) {
                return false;
            }
        }
        return true;
    }

    private void assertAlertWindows(final ComponentName activityName,
            final boolean hasAlertWindowPermission, final boolean atLeastO) throws Exception {
        final String packageName = activityName.getPackageName();
        final WindowManagerState wmState = mWmState;

        final List<WindowManagerState.WindowState> alertWindows =
                wmState.getWindowsByPackageName(packageName, ALERT_WINDOW_TYPES);

        if (!hasAlertWindowPermission) {
            // When running in VR Mode, an App Op restriction is
            // in place for SYSTEM_ALERT_WINDOW, which allows the window
            // to be created, but will be hidden instead.
            if (isUiModeLockedToVrHeadset()) {
                assertThat(""Should not be empty alertWindows"",
                        alertWindows, hasSize(greaterThan(0)));
                assertTrue(""All alert windows should be hidden"",
                        allWindowsHidden(alertWindows));
            } else {
                a"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/AlertWindowsTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.PinnedStackTests"	"testDisallowEnterPipActivityLocked"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/PinnedStackTests.java]:[permission]:[1]:method_text:[     } finally {                mAtm.stopSystemLockTaskMode();            }        });    }   ]) :|: 
    public void testDisallowEnterPipActivityLocked() {
        launchActivity(PIP_ACTIVITY, extraString(EXTRA_ENTER_PIP_ON_PAUSE, ""true""));
        ActivityTask task = mWmState.getStackByActivity(PIP_ACTIVITY);

        // Lock the task and ensure that we can't enter picture-in-picture both explicitly and
        // when paused
        SystemUtil.runWithShellPermissionIdentity(() -> {
            try {
                mAtm.startSystemLockTaskMode(task.mTaskId);
                waitForOrFail(""Task in lock mode"", () -> {
                    return mAm.getLockTaskModeState() != LOCK_TASK_MODE_NONE;
                });
                mBroadcastActionTrigger.doAction(ACTION_ENTER_PIP);
                waitForEnterPip(PIP_ACTIVITY);
                assertPinnedStackDoesNotExist();
                launchHomeActivityNoWait();
                mWmState.computeState();
                assertPinnedStackDoesNotExist();
            } finally {
                mAtm.stopSystemLockTaskMode();
            }
        });
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/PinnedStackTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.PinnedStackTests"	"testPictureInPictureStateChangeCallback"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([2:/android/server/wm/PinnedStackTests.java]:[permission]:[2]:method_text:[inned stack."",                    WINDOWING_MODE_PINNED, ACTIVITY_TYPE_STANDARD);        }    }}]) :|: 
    public void testPictureInPictureStateChangeCallback() throws Exception {
        launchActivity(PIP_ACTIVITY);
        enterPipAndAssertPinnedTaskExists(PIP_ACTIVITY);
        waitForEnterPip(PIP_ACTIVITY);

        final CompletableFuture<Boolean> callbackReturn = new CompletableFuture<>();
        RemoteCallback cb = new RemoteCallback((Bundle result) ->
                callbackReturn.complete(result.getBoolean(PIP_CALLBACK_RESULT_KEY)));
        mBroadcastActionTrigger.sendPipStateUpdate(cb, true);
        Truth.assertThat(callbackReturn.get(5000, TimeUnit.MILLISECONDS)).isEqualTo(true);

        final CompletableFuture<Boolean> callbackReturnNotStashed = new CompletableFuture<>();
        RemoteCallback cbStashed = new RemoteCallback((Bundle result) ->
                callbackReturnNotStashed.complete(result.getBoolean(PIP_CALLBACK_RESULT_KEY)));
        mBroadcastActionTrigger.sendPipStateUpdate(cbStashed, false);
        Truth.assertThat(callbackReturnNotStashed.get(5000, TimeUnit.MILLISECONDS))
                .isEqualTo(false);
    }

    private void assertIsSeamlessResizeEnabled(ComponentName componentName, boolean expected) {
        runWithShellPermission(() -> {
            final ActivityTask task = mWmState.getTaskByActivity(componentName);
            final TaskInfo info = mTaskOrganizer.getTaskInfo(task.getTaskId());
            final PictureInPictureParams params = info.getPictureInPictureParams();

            assertEquals(expected, params.isSeamlessResizeEnabled());
        });
    }

    private void assertNumberOfActions(ComponentName componentName, int numberOfActions) {
        runWithShellPermission(() -> {
            final ActivityTask task = mWmState.getTaskByActivity(componentName);
            final TaskInfo info = mTaskOrganizer.getTaskInfo(task.getTaskId());
            final PictureInPictureParams params = info.getPictureInPictureParams();

            assertNotNull(params);
            assertNotNull(params.getActions());"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/PinnedStackTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.DreamManagerServiceTests"	"getIsDreaming"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([6:/android/server/wm/DreamManagerServiceTests.java]:[permission]:[6]:method_text:[ld be the top resumed activity"");        mWmState.assertVisibility(TEST_ACTIVITY, true);    }   ]) :|: /*
 *
 */

package android.server.wm;

import static android.app.WindowConfiguration.WINDOWING_MODE_FULLSCREEN;
import static android.server.wm.WindowManagerState.STATE_STOPPED;
import static android.server.wm.app.Components.TEST_ACTIVITY;
import static android.server.wm.app.Components.TEST_DREAM_SERVICE;
import static android.server.wm.app.Components.TEST_STUBBORN_DREAM_SERVICE;
import static android.server.wm.ComponentNameUtils.getWindowName;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static android.view.Display.DEFAULT_DISPLAY;

import static org.junit.Assume.assumeTrue;

import android.app.DreamManager;
import android.content.ComponentName;
import android.platform.test.annotations.Presubmit;
import android.provider.Settings;
import android.server.wm.app.Components;
import android.view.Surface;
import android.content.res.Resources;

import androidx.test.filters.FlakyTest;

import com.android.compatibility.common.util.SystemUtil;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

@Presubmit
@FlakyTest(detail = ""Promote once confirmed non-flaky"")
public class DreamManagerServiceTests extends ActivityManagerTestBase {

    // Timeout after which the dream should have finished willingly
    private static final long ACTIVITY_STOP_TIMEOUT = 3000;

    // Timeout after which the dream should have been forcefully stopped
    private static final long ACTIVITY_FORCE_STOP_TIMEOUT = 6500;

    private ComponentName mDreamActivityName;

    private boolean mDefaultDreamServiceEnabled = true;

    private static final ComponentName getDreamActivityName(ComponentName dream) {
        return new ComponentName(dream.getPackageName(),
                                 ""android.service.dreams.DreamActivity"");
    }

    @Before
    public void setup() {
        assumeTrue(""Skipping test: no dream support"", supportsDream());

        mDefaultDreamServiceEnabled =
                Settings.Secure.getInt(mConte"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DreamManagerServiceTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.WindowInsetsControllerTests"	"testDispatchApplyWindowInsetsCount_ime"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/WindowInsetsControllerTests.java]:[permission]:[1]:method_text:[    dialog.getWindow().addFlags(FLAG_ALT_FOCUSABLE_IM);            dialog.show();        }    }}]) :|: 
    public void testDispatchApplyWindowInsetsCount_ime() throws Exception {
        assumeFalse(""Automotive is to skip this test until showing and hiding certain insets ""
                + ""simultaneously in a single request is supported"", isAutomotive(mContext));
        assumeThat(MockImeSession.getUnavailabilityReason(getInstrumentation().getContext()),
                nullValue());

        MockImeHelper.createManagedMockImeSession(this);
        final TestActivity activity = startActivity(TestActivity.class);
        final View rootView = activity.getWindow().getDecorView();
        getInstrumentation().waitForIdleSync();

        final int[] dispatchApplyWindowInsetsCount = {0};
        rootView.setOnApplyWindowInsetsListener((v, insets) -> {
            dispatchApplyWindowInsetsCount[0]++;
            return v.onApplyWindowInsets(insets);
        });

        // One show-ime call...
        ANIMATION_CALLBACK.reset();
        getInstrumentation().runOnMainSync(() -> {
            rootView.setWindowInsetsAnimationCallback(ANIMATION_CALLBACK);
            rootView.getWindowInsetsController().show(ime());
        });
        ANIMATION_CALLBACK.waitForFinishing();

        // ... should only trigger one dispatchApplyWindowInsets
        assertEquals(1, dispatchApplyWindowInsetsCount[0]);

        // One hide-ime call...
        dispatchApplyWindowInsetsCount[0] = 0;
        ANIMATION_CALLBACK.reset();
        getInstrumentation().runOnMainSync(() -> {
            rootView.setWindowInsetsAnimationCallback(ANIMATION_CALLBACK);
            rootView.getWindowInsetsController().hide(ime());
        });
        ANIMATION_CALLBACK.waitForFinishing();

        // ... should only trigger one dispatchApplyWindowInsets
        assertEquals(1, dispatchApplyWindowInsetsCount[0]);
    }

    private static void broadcastCloseSystemDialogs() {
        executeShellCommand(AM_BROADCAST_CLOSE_SYSTEM_DIALOGS);
    }

    private static boolean isAutomotive(Context context) {"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowInsetsControllerTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.MultiDisplaySecurityTests"	"supportsMultiDisplay"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/MultiDisplaySecurityTests.java]:[permission]:[1]:method_text:[ an activity on a virtual display without special permission must not be     * allowed.     */   ]) :|: /*
 *
 */

package android.server.wm;

import static android.server.wm.WindowManagerState.STATE_RESUMED;
import static android.server.wm.ComponentNameUtils.getActivityName;
import static android.server.wm.MockImeHelper.createManagedMockImeSession;
import static android.server.wm.MultiDisplaySystemDecorationTests.ImeTestActivity;
import static android.server.wm.app.Components.DISPLAY_ACCESS_CHECK_EMBEDDING_ACTIVITY;
import static android.server.wm.app.Components.LAUNCHING_ACTIVITY;
import static android.server.wm.app.Components.LAUNCH_BROADCAST_RECEIVER;
import static android.server.wm.app.Components.LaunchBroadcastReceiver.ACTION_TEST_ACTIVITY_START;
import static android.server.wm.app.Components.LaunchBroadcastReceiver.EXTRA_COMPONENT_NAME;
import static android.server.wm.app.Components.LaunchBroadcastReceiver.EXTRA_TARGET_DISPLAY;
import static android.server.wm.app.Components.LaunchBroadcastReceiver.LAUNCH_BROADCAST_ACTION;
import static android.server.wm.app.Components.TEST_ACTIVITY;
import static android.server.wm.app.Components.VIRTUAL_DISPLAY_ACTIVITY;
import static android.server.wm.second.Components.EMBEDDING_ACTIVITY;
import static android.server.wm.second.Components.EmbeddingActivity.ACTION_EMBEDDING_TEST_ACTIVITY_START;
import static android.server.wm.second.Components.EmbeddingActivity.EXTRA_EMBEDDING_COMPONENT_NAME;
import static android.server.wm.second.Components.EmbeddingActivity.EXTRA_EMBEDDING_TARGET_DISPLAY;
import static android.server.wm.second.Components.SECOND_ACTIVITY;
import static android.server.wm.second.Components.SECOND_LAUNCH_BROADCAST_ACTION;
import static android.server.wm.second.Components.SECOND_LAUNCH_BROADCAST_RECEIVER;
import static android.server.wm.second.Components.SECOND_NO_EMBEDDING_ACTIVITY;
import static android.server.wm.second.Components.SecondActivity.EXTRA_DISPLAY_ACCESS_CHECK;
import static android.server.wm.third.Components.THIRD_ACTIVITY;
import static android.view.Display.DEFAULT_DISPLAY;
import static android.vie"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplaySecurityTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.MultiDisplaySecurityTests"	"testLaunchWithoutPermissionOnVirtualDisplayByOwner"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([2:/android/server/wm/MultiDisplaySecurityTests.java]:[permission]:[2]:method_text:[ an activity on a virtual display without special permission must not be     * allowed.     */   ]) :|: 
    public void testLaunchWithoutPermissionOnVirtualDisplayByOwner() {
        // Create new virtual display.
        final DisplayContent newDisplay = createManagedVirtualDisplaySession().createDisplay();

        separateTestJournal();

        // Try to launch an activity and check if security exception was triggered.
        getLaunchActivityBuilder()
                .setUseBroadcastReceiver(LAUNCH_BROADCAST_RECEIVER, LAUNCH_BROADCAST_ACTION)
                .setDisplayId(newDisplay.mId)
                .setTargetActivity(TEST_ACTIVITY)
                .execute();
        assertSecurityExceptionFromActivityLauncher();
        mWmState.computeState(TEST_ACTIVITY);
        assertFalse(""Restricted activity must not be launched"",
                mWmState.containsActivity(TEST_ACTIVITY));
    }

    /**
     * Tests launching an activity on a virtual display without special permission must not be
     * allowed.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplaySecurityTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.MultiDisplaySecurityTests"	"testLaunchWithoutPermissionOnVirtualDisplay"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/MultiDisplaySecurityTests.java]:[permission]:[1]:method_text:[r activity that     * doesn't allow embedding - it should fail with security exception.     */   ]) :|: 
    public void testLaunchWithoutPermissionOnVirtualDisplay() {
        // Create new virtual display.
        final DisplayContent newDisplay = createManagedVirtualDisplaySession().createDisplay();

        separateTestJournal();

        // Try to launch an activity and check it security exception was triggered.
        getLaunchActivityBuilder()
                .setUseBroadcastReceiver(SECOND_LAUNCH_BROADCAST_RECEIVER,
                        SECOND_LAUNCH_BROADCAST_ACTION)
                .setDisplayId(newDisplay.mId)
                .setTargetActivity(TEST_ACTIVITY)
                .execute();
        assertSecurityExceptionFromActivityLauncher();
        mWmState.computeState(TEST_ACTIVITY);
        assertFalse(""Restricted activity must not be launched"",
                mWmState.containsActivity(TEST_ACTIVITY));
    }

    /**
     * Tests launching an activity on virtual display and then launching another activity that
     * doesn't allow embedding - it should fail with security exception.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplaySecurityTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.MultiDisplaySecurityTests"	"testCanAccessPublicVirtualDisplayWithInternalPermission"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([3:/android/server/wm/MultiDisplaySecurityTests.java]:[permission]:[3]:method_text:[for a private virtual display and an activity that doesn't support embedding from shell.     */   ]) :|: 
    public void testCanAccessPublicVirtualDisplayWithInternalPermission() {
        final DisplayContent newDisplay = createManagedVirtualDisplaySession()
                .setPublicDisplay(true)
                .createDisplay();

        SystemUtil.runWithShellPermissionIdentity(
                () -> assertTrue(isActivityStartAllowedOnDisplay(
                        newDisplay.mId, SECOND_NO_EMBEDDING_ACTIVITY)),
                ""android.permission.INTERNAL_SYSTEM_WINDOW"");
    }

    /**
     * Tests
     * {@link android.app.ActivityManager#isActivityStartAllowedOnDisplay(Context, int, Intent)}
     * for a private virtual display and an activity that doesn't support embedding from shell.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplaySecurityTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.MultiDisplaySecurityTests"	"testCanAccessPrivateVirtualDisplayWithInternalPermission"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([4:/android/server/wm/MultiDisplaySecurityTests.java]:[permission]:[4]:method_text:[ing entity     * does not have required permission to embed an activity from other app.     */   ]) :|: 
    public void testCanAccessPrivateVirtualDisplayWithInternalPermission() {
        final DisplayContent newDisplay = createManagedVirtualDisplaySession()
                .setPublicDisplay(false)
                .createDisplay();

        SystemUtil.runWithShellPermissionIdentity(
                () -> assertTrue(isActivityStartAllowedOnDisplay(
                        newDisplay.mId, SECOND_NO_EMBEDDING_ACTIVITY)),
                ""android.permission.INTERNAL_SYSTEM_WINDOW"");
    }

    /**
     * Tests
     * {@link android.app.ActivityManager#isActivityStartAllowedOnDisplay(Context, int, Intent)}
     * for a public virtual display, an activity that supports embedding but the launching entity
     * does not have required permission to embed an activity from other app.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplaySecurityTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.MultiDisplaySecurityTests"	"testCantAccessPublicVirtualDisplayNoEmbeddingPermission"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/MultiDisplaySecurityTests.java]:[permission]:[1]:method_text:[t)}     * for a public virtual display and an activity that does not support embedding.     */   ]) :|: 
    public void testCantAccessPublicVirtualDisplayNoEmbeddingPermission() {
        final DisplayContent newDisplay = createManagedVirtualDisplaySession()
                .setPublicDisplay(true)
                .createDisplay();

        assertFalse(isActivityStartAllowedOnDisplay(newDisplay.mId, SECOND_ACTIVITY));
    }

    /**
     * Tests
     * {@link android.app.ActivityManager#isActivityStartAllowedOnDisplay(Context, int, Intent)}
     * for a public virtual display and an activity that does not support embedding.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplaySecurityTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.MultiDisplaySecurityTests"	"testCantAccessPublicVirtualDisplayActivityEmbeddingNotAllowed"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([2:/android/server/wm/MultiDisplaySecurityTests.java]:[permission]:[2]:method_text:[t, Intent)}     * for a public virtual display and an activity that supports embedding.     */   ]) :|: 
    public void testCantAccessPublicVirtualDisplayActivityEmbeddingNotAllowed() {
        final DisplayContent newDisplay = createManagedVirtualDisplaySession()
                .setPublicDisplay(true)
                .createDisplay();

        SystemUtil.runWithShellPermissionIdentity(
                () -> assertFalse(isActivityStartAllowedOnDisplay(
                        newDisplay.mId, SECOND_NO_EMBEDDING_ACTIVITY)),
                ""android.permission.ACTIVITY_EMBEDDING"");
    }

    /**
     * Tests
     * {@link android.app.ActivityManager#isActivityStartAllowedOnDisplay(Context, int, Intent)}
     * for a public virtual display and an activity that supports embedding.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplaySecurityTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.MultiDisplaySecurityTests"	"testCanAccessPublicVirtualDisplayActivityEmbeddingAllowed"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([2:/android/server/wm/MultiDisplaySecurityTests.java]:[permission]:[2]:method_text:[tivityStartAllowedOnDisplay(Context, int, Intent)}     * for a private virtual display.     */   ]) :|: 
    public void testCanAccessPublicVirtualDisplayActivityEmbeddingAllowed() {
        final DisplayContent newDisplay = createManagedVirtualDisplaySession()
                .setPublicDisplay(true)
                .createDisplay();

        SystemUtil.runWithShellPermissionIdentity(
                () -> assertTrue(isActivityStartAllowedOnDisplay(
                        newDisplay.mId, SECOND_ACTIVITY)),
                ""android.permission.ACTIVITY_EMBEDDING"");
    }

    /**
     * Tests
     * {@link android.app.ActivityManager#isActivityStartAllowedOnDisplay(Context, int, Intent)}
     * for a private virtual display.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplaySecurityTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.MultiDisplaySecurityTests"	"testDisplayHasAccess_UIDCanPresentOnPrivateDisplay"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([2:/android/server/wm/MultiDisplaySecurityTests.java]:[permission]:[2]:method_text:[accessible on private display"",                isUidAccesibleOnDisplay(session2), true);    }   ]) :|: 
    public void testDisplayHasAccess_UIDCanPresentOnPrivateDisplay() {
        final VirtualDisplayLauncher virtualDisplayLauncher =
                mObjectTracker.manage(new VirtualDisplayLauncher());
        // Create a virtual private display.
        final DisplayContent newDisplay = virtualDisplayLauncher
                .setPublicDisplay(false)
                .createDisplay();
        // Launch an embeddable activity into the private display.
        // Assert that the UID can present on display.
        final ActivitySession session1 = virtualDisplayLauncher.launchActivityOnDisplay(
                DISPLAY_ACCESS_CHECK_EMBEDDING_ACTIVITY, newDisplay);
        assertEquals(""Activity which the UID should accessible on private display"",
                isUidAccesibleOnDisplay(session1), true);

        // Launch another embeddable activity with a different UID, verify that it will be
        // able to access the display where it was put.
        // Note that set withShellPermission as true in launchActivityOnDisplay is to
        // make sure ACTIVITY_EMBEDDING can be granted by shell.
        final ActivitySession session2 = virtualDisplayLauncher.launchActivityOnDisplay(
                SECOND_ACTIVITY, newDisplay,
                bundle -> bundle.putBoolean(EXTRA_DISPLAY_ACCESS_CHECK, true),
                true /* withShellPermission */, true /* waitForLaunch */);

        // Verify SECOND_ACTIVITY's UID has access to this virtual private display.
        assertEquals(""Second activity which the UID should accessible on private display"",
                isUidAccesibleOnDisplay(session2), true);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplaySecurityTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.MultiDisplaySecurityTests"	"testDisplayHasAccess_NoAccessWhenUIDNotPresentOnPrivateDisplay"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([2:/android/server/wm/MultiDisplaySecurityTests.java]:[permission]:[2]:method_text:[ccessible on private display"",                isUidAccesibleOnDisplay(session2), false);    }   ]) :|: 
    public void testDisplayHasAccess_NoAccessWhenUIDNotPresentOnPrivateDisplay() {
        final VirtualDisplayLauncher virtualDisplayLauncher =
                mObjectTracker.manage(new VirtualDisplayLauncher());
        // Create a virtual private display.
        final DisplayContent newDisplay = virtualDisplayLauncher
                .setPublicDisplay(false)
                .createDisplay();
        // Launch an embeddable activity into the private display.
        // Assume that the UID can access on display.
        final ActivitySession session1 = virtualDisplayLauncher.launchActivityOnDisplay(
                DISPLAY_ACCESS_CHECK_EMBEDDING_ACTIVITY, newDisplay);
        assertEquals(""Activity which the UID should accessible on private display"",
                isUidAccesibleOnDisplay(session1), true);

        // Verify SECOND_NO_EMBEDDING_ACTIVITY's UID can't access this virtual private display
        // since there is no entity with this UID on this display.
        // Note that set withShellPermission as false in launchActivityOnDisplay is to
        // prevent activity can launch when INTERNAL_SYSTEM_WINDOW granted by shell case.
        separateTestJournal();
        final ActivitySession session2 = virtualDisplayLauncher.launchActivityOnDisplay(
                SECOND_NO_EMBEDDING_ACTIVITY, newDisplay, null /* extrasConsumer */,
                false /* withShellPermission */, false /* waitForLaunch */);
        assertEquals(""Second activity which the UID should not accessible on private display"",
                isUidAccesibleOnDisplay(session2), false);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplaySecurityTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.MultiDisplaySecurityTests"	"testPermissionLaunchFromShell"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/MultiDisplaySecurityTests.java]:[permission]:[1]:method_text:[TIVITY));    }    /** Test that launching from app that is on external display is allowed. */   ]) :|: 
    public void testPermissionLaunchFromShell(){
        // Create new virtual display.
        final DisplayContent newDisplay = createManagedVirtualDisplaySession().createDisplay();
        mWmState.assertVisibility(VIRTUAL_DISPLAY_ACTIVITY, true /* visible */);
        mWmState.assertFocusedActivity(""Virtual display activity must be on top"",
                VIRTUAL_DISPLAY_ACTIVITY);
        final int defaultDisplayFocusedStackId = mWmState.getFocusedStackId();
        ActivityTask frontStack = mWmState.getRootTask(
                defaultDisplayFocusedStackId);
        assertEquals(""Top stack must remain on primary display"",
                DEFAULT_DISPLAY, frontStack.mDisplayId);

        // Launch activity on new secondary display.
        launchActivityOnDisplay(TEST_ACTIVITY, newDisplay.mId);

        waitAndAssertActivityStateOnDisplay(TEST_ACTIVITY, STATE_RESUMED, newDisplay.mId,
                ""Test activity must be on secondary display"");
        assertBothDisplaysHaveResumedActivities(pair(DEFAULT_DISPLAY, VIRTUAL_DISPLAY_ACTIVITY),
                pair(newDisplay.mId, TEST_ACTIVITY));

        // Launch other activity with different uid and check it is launched on dynamic stack on
        // secondary display.
        final String startCmd = ""am start -n "" + getActivityName(SECOND_ACTIVITY)
                + "" --display "" + newDisplay.mId;
        executeShellCommand(startCmd);

        waitAndAssertActivityStateOnDisplay(SECOND_ACTIVITY, STATE_RESUMED, newDisplay.mId,
                ""Second activity must be on newly launched app"");
        assertBothDisplaysHaveResumedActivities(pair(DEFAULT_DISPLAY, VIRTUAL_DISPLAY_ACTIVITY),
                pair(newDisplay.mId, SECOND_ACTIVITY));
    }

    /** Test that launching from app that is on external display is allowed. */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplaySecurityTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.MultiDisplaySecurityTests"	"testPermissionLaunchFromAppOnSecondary"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/MultiDisplaySecurityTests.java]:[permission]:[1]:method_text:[    /** Tests that an activity can launch an activity from a different UID into its own task. */   ]) :|: 
    public void testPermissionLaunchFromAppOnSecondary() {
        // Create new simulated display.
        final DisplayContent newDisplay = createManagedVirtualDisplaySession()
                .setSimulateDisplay(true)
                .createDisplay();

        // Launch activity with different uid on secondary display.
        final String startCmd = ""am start -n "" + getActivityName(SECOND_ACTIVITY)
                + "" --display "" + newDisplay.mId;
        executeShellCommand(startCmd);

        waitAndAssertTopResumedActivity(SECOND_ACTIVITY, newDisplay.mId,
                ""Top activity must be the newly launched one"");

        // Launch another activity with third different uid from app on secondary display and
        // check it is launched on secondary display.
        getLaunchActivityBuilder()
                .setUseBroadcastReceiver(SECOND_LAUNCH_BROADCAST_RECEIVER,
                        SECOND_LAUNCH_BROADCAST_ACTION)
                .setDisplayId(newDisplay.mId)
                .setTargetActivity(THIRD_ACTIVITY)
                .execute();

        waitAndAssertTopResumedActivity(THIRD_ACTIVITY, newDisplay.mId,
                ""Top activity must be the newly launched one"");
    }

    /** Tests that an activity can launch an activity from a different UID into its own task. */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplaySecurityTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.MultiDisplaySecurityTests"	"testPermissionLaunchMultiUidTask"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/MultiDisplaySecurityTests.java]:[permission]:[1]:method_text:[t on external display and doesn't own it to     * that external display is not allowed.     */   ]) :|: 
    public void testPermissionLaunchMultiUidTask() {
        final DisplayContent newDisplay = createManagedVirtualDisplaySession()
                .setSimulateDisplay(true)
                .createDisplay();

        launchActivityOnDisplay(LAUNCHING_ACTIVITY, newDisplay.mId);
        mWmState.computeState(LAUNCHING_ACTIVITY);

        // Check that the first activity is launched onto the secondary display.
        final int frontStackId = mWmState.getFrontRootTaskId(newDisplay.mId);
        ActivityTask frontStack = mWmState.getRootTask(frontStackId);
        assertEquals(""Activity launched on secondary display must be resumed"",
                getActivityName(LAUNCHING_ACTIVITY), frontStack.mResumedActivity);
        mWmState.assertFocusedStack(""Top stack must be on secondary display"", frontStackId);

        // Launch an activity from a different UID into the first activity's task.
        getLaunchActivityBuilder().setTargetActivity(SECOND_ACTIVITY).execute();

        waitAndAssertTopResumedActivity(SECOND_ACTIVITY, newDisplay.mId,
                ""Top activity must be the newly launched one"");
        frontStack = mWmState.getRootTask(frontStackId);
        assertEquals(""Secondary display must contain 1 task"", 1,
                mWmState.getDisplay(newDisplay.mId).getRootTasks().size());
    }

    /**
     * Test that launching from app that is not present on external display and doesn't own it to
     * that external display is not allowed.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplaySecurityTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.MultiDisplaySecurityTests"	"testPermissionLaunchFromDifferentApp"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/MultiDisplaySecurityTests.java]:[permission]:[1]:method_text:[*     * Test that only private virtual display can show content with insecure keyguard.     */   ]) :|: 
    public void testPermissionLaunchFromDifferentApp() {
        // Create new virtual display.
        final DisplayContent newDisplay = createManagedVirtualDisplaySession().createDisplay();
        mWmState.assertVisibility(VIRTUAL_DISPLAY_ACTIVITY, true /* visible */);
        mWmState.assertFocusedActivity(""Virtual display activity must be focused"",
                VIRTUAL_DISPLAY_ACTIVITY);
        final int defaultDisplayFocusedStackId = mWmState.getFocusedStackId();
        ActivityTask frontStack = mWmState.getRootTask(
                defaultDisplayFocusedStackId);
        assertEquals(""Top stack must remain on primary display"",
                DEFAULT_DISPLAY, frontStack.mDisplayId);

        // Launch activity on new secondary display.
        launchActivityOnDisplay(TEST_ACTIVITY, newDisplay.mId);
        waitAndAssertActivityStateOnDisplay(TEST_ACTIVITY, STATE_RESUMED, newDisplay.mId,
                ""Test activity must be the newly launched one"");

        separateTestJournal();

        // Launch other activity with different uid and check security exception is triggered.
        getLaunchActivityBuilder()
                .setUseBroadcastReceiver(SECOND_LAUNCH_BROADCAST_RECEIVER,
                        SECOND_LAUNCH_BROADCAST_ACTION)
                .setDisplayId(newDisplay.mId)
                .setTargetActivity(THIRD_ACTIVITY)
                .execute();

        assertSecurityExceptionFromActivityLauncher();
    }

    /**
     * Test that only private virtual display can show content with insecure keyguard.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplaySecurityTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.MultiDisplaySecurityTests"	"testFlagShowWithInsecureKeyguardOnPublicVirtualDisplay"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/MultiDisplaySecurityTests.java]:[permission]:[1]:method_text:[ * Test setting system decoration flag and show IME flag without sufficient permissions.     */   ]) :|: 
    public void testFlagShowWithInsecureKeyguardOnPublicVirtualDisplay() {
        // Try to create new show-with-insecure-keyguard public virtual display.
        final DisplayContent newDisplay = createManagedVirtualDisplaySession()
                .setPublicDisplay(true)
                .setCanShowWithInsecureKeyguard(true)
                .createDisplay(false /* mustBeCreated */);

        // Check that the display is not created.
        assertNull(newDisplay);
    }

    /**
     * Test setting system decoration flag and show IME flag without sufficient permissions.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplaySecurityTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.MultiDisplaySecurityTests"	"testSettingFlagWithoutInternalSystemPermission"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([7:/android/server/wm/MultiDisplaySecurityTests.java]:[permission]:[7]:method_text:[ * Test getting system decoration flag and show IME flag without sufficient permissions.     */   ]) :|: 
    public void testSettingFlagWithoutInternalSystemPermission() throws Exception {
        // The reason to use a trusted display is that we can guarantee the security exception
        // is coming from lacking internal system permission.
        final DisplayContent trustedDisplay = createManagedVirtualDisplaySession()
                .setSimulateDisplay(true)
                .createDisplay();
        final WindowManager wm = mTargetContext.getSystemService(WindowManager.class);

        // Verify setting system decorations flag without internal system permission.
        try {
            wm.setShouldShowSystemDecors(trustedDisplay.mId, true);

            // Unexpected result, restore flag to avoid affecting other tests.
            wm.setShouldShowSystemDecors(trustedDisplay.mId, false);
            TestUtils.waitUntil(""Waiting for system decoration flag to be set"",
                    5 /* timeoutSecond */,
                    () -> !wm.shouldShowSystemDecors(trustedDisplay.mId));
            fail(""Should not allow setting system decoration flag without internal system ""
                    + ""permission"");
        } catch (SecurityException e) {
            // Expected security exception.
        }

        // Verify setting show IME flag without internal system permission.
        try {
            wm.setDisplayImePolicy(trustedDisplay.mId, DISPLAY_IME_POLICY_LOCAL);

            // Unexpected result, restore flag to avoid affecting other tests.
            wm.setDisplayImePolicy(trustedDisplay.mId, DISPLAY_IME_POLICY_FALLBACK_DISPLAY);
            TestUtils.waitUntil(""Waiting for show IME flag to be set"",
                    5 /* timeoutSecond */,
                    () -> (wm.getDisplayImePolicy(trustedDisplay.mId)
                            == DISPLAY_IME_POLICY_FALLBACK_DISPLAY));
            fail(""Should not allow setting show IME flag without internal system permission"");
        } catch (SecurityException e) {
            // Expected security excep"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplaySecurityTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.MultiDisplaySecurityTests"	"testGettingFlagWithoutInternalSystemPermission"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([4:/android/server/wm/MultiDisplaySecurityTests.java]:[permission]:[4]:method_text:[*     * Test setting system decoration flag and show IME flag to the untrusted display.     */   ]) :|: 
    public void testGettingFlagWithoutInternalSystemPermission() {
        // The reason to use a trusted display is that we can guarantee the security exception
        // is coming from lacking internal system permission.
        final DisplayContent trustedDisplay = createManagedVirtualDisplaySession()
                .setSimulateDisplay(true)
                .createDisplay();
        final WindowManager wm = mTargetContext.getSystemService(WindowManager.class);

        // Verify getting system decorations flag without internal system permission.
        try {
            wm.shouldShowSystemDecors(trustedDisplay.mId);
            fail(""Only allow internal system to get system decoration flag"");
        } catch (SecurityException e) {
            // Expected security exception.
        }

        // Verify getting show IME flag without internal system permission.
        try {
            wm.getDisplayImePolicy(trustedDisplay.mId);
            fail(""Only allow internal system to get show IME flag"");
        } catch (SecurityException e) {
            // Expected security exception.
        }
    }

    /**
     * Test setting system decoration flag and show IME flag to the untrusted display.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplaySecurityTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.MultiDisplaySecurityTests"	"testSettingFlagToUntrustedDisplay"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([4:/android/server/wm/MultiDisplaySecurityTests.java]:[permission]:[4]:method_text:[     * Test getting system decoration flag and show IME flag from the untrusted display.     */   ]) :|: 
    public void testSettingFlagToUntrustedDisplay() throws Exception {
        final DisplayContent untrustedDisplay = createManagedVirtualDisplaySession()
                .createDisplay();
        final WindowManager wm = mTargetContext.getSystemService(WindowManager.class);

        // Verify setting system decoration flag to an untrusted display.
        getInstrumentation().getUiAutomation().adoptShellPermissionIdentity();
        try {
            wm.setShouldShowSystemDecors(untrustedDisplay.mId, true);

            // Unexpected result, restore flag to avoid affecting other tests.
            wm.setShouldShowSystemDecors(untrustedDisplay.mId, false);
            TestUtils.waitUntil(""Waiting for system decoration flag to be set"",
                    5 /* timeoutSecond */,
                    () -> !wm.shouldShowSystemDecors(untrustedDisplay.mId));
            fail(""Should not allow setting system decoration flag to the untrusted virtual ""
                    + ""display"");
        } catch (SecurityException e) {
            // Expected security exception.
        } finally {
            getInstrumentation().getUiAutomation().dropShellPermissionIdentity();
        }

        // Verify setting show IME flag to an untrusted display.
        getInstrumentation().getUiAutomation().adoptShellPermissionIdentity();
        try {
            wm.setDisplayImePolicy(untrustedDisplay.mId, DISPLAY_IME_POLICY_LOCAL);

            // Unexpected result, restore flag to avoid affecting other tests.
            wm.setDisplayImePolicy(untrustedDisplay.mId, DISPLAY_IME_POLICY_FALLBACK_DISPLAY);
            TestUtils.waitUntil(""Waiting for show IME flag to be set"",
                    5 /* timeoutSecond */,
                    () -> (wm.getDisplayImePolicy(untrustedDisplay.mId)
                            == DISPLAY_IME_POLICY_FALLBACK_DISPLAY));
            fail(""Should not allow setting show IME flag to the untrusted virtual display"");
        } catch (SecurityException e) {"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplaySecurityTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.MultiDisplaySecurityTests"	"testGettingFlagFromUntrustedDisplay"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([2:/android/server/wm/MultiDisplaySecurityTests.java]:[permission]:[2]:method_text:[/**     * Test setting system decoration flag and show IME flag to the trusted display.     */   ]) :|: 
    public void testGettingFlagFromUntrustedDisplay() {
        final DisplayContent untrustedDisplay = createManagedVirtualDisplaySession()
                .createDisplay();
        final WindowManager wm = mTargetContext.getSystemService(WindowManager.class);

        // Verify getting system decoration flag from an untrusted display.
        SystemUtil.runWithShellPermissionIdentity(() -> assertFalse(
                ""Display should not support showing system decorations"",
                wm.shouldShowSystemDecors(untrustedDisplay.mId)));

        // Verify getting show IME flag from an untrusted display.
        SystemUtil.runWithShellPermissionIdentity(() -> assertEquals(
                ""Display should not support showing IME window"",
                wm.getDisplayImePolicy(untrustedDisplay.mId),
                DISPLAY_IME_POLICY_FALLBACK_DISPLAY));
    }

    /**
     * Test setting system decoration flag and show IME flag to the trusted display.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplaySecurityTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.MultiDisplaySecurityTests"	"testSettingFlagToTrustedDisplay"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([2:/android/server/wm/MultiDisplaySecurityTests.java]:[permission]:[2]:method_text:[                      == DISPLAY_IME_POLICY_FALLBACK_DISPLAY));            }        });    }   ]) :|: 
    public void testSettingFlagToTrustedDisplay() throws Exception {
        final DisplayContent trustedDisplay = createManagedVirtualDisplaySession()
                .setSimulateDisplay(true)
                .createDisplay();
        final WindowManager wm = mTargetContext.getSystemService(WindowManager.class);

        // Verify setting system decoration flag to a trusted display.
        SystemUtil.runWithShellPermissionIdentity(() -> {
            // Assume the display should not support system decorations by default.
            assertFalse(wm.shouldShowSystemDecors(trustedDisplay.mId));

            try {
                wm.setShouldShowSystemDecors(trustedDisplay.mId, true);
                TestUtils.waitUntil(""Waiting for system decoration flag to be set"",
                        5 /* timeoutSecond */,
                        () -> wm.shouldShowSystemDecors(trustedDisplay.mId));

                assertTrue(wm.shouldShowSystemDecors(trustedDisplay.mId));
            } finally {
                // Restore flag to avoid affecting other tests.
                wm.setShouldShowSystemDecors(trustedDisplay.mId, false);
                TestUtils.waitUntil(""Waiting for system decoration flag to be set"",
                        5 /* timeoutSecond */,
                        () -> !wm.shouldShowSystemDecors(trustedDisplay.mId));
            }
        });

        // Verify setting show IME flag to a trusted display.
        SystemUtil.runWithShellPermissionIdentity(() -> {
            // Assume the display should not show IME window by default.
            assertEquals(DISPLAY_IME_POLICY_FALLBACK_DISPLAY,
                    wm.getDisplayImePolicy(trustedDisplay.mId));

            try {
                wm.setDisplayImePolicy(trustedDisplay.mId, DISPLAY_IME_POLICY_LOCAL);
                TestUtils.waitUntil(""Waiting for show IME flag to be set"",
                        5 /* timeoutSecond */,
                        () -> (wm.getDisplayImePolicy(trustedDisplay.mId)"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplaySecurityTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.MultiDisplayActivityLaunchTests"	"testLaunchAssistantActivityOnSecondaryDisplay"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/MultiDisplayActivityLaunchTests.java]:[permission]:[1]:method_text:[.mId));    }    /**     * Tests launching an activity on primary display explicitly.     */   ]) :|: 
    public void testLaunchAssistantActivityOnSecondaryDisplay() {
        validateActivityLaunchOnNewDisplay(ACTIVITY_TYPE_ASSISTANT);
    }

    private void validateActivityLaunchOnNewDisplay(int activityType) {
        // Create new virtual display.
        final DisplayContent newDisplay = createManagedVirtualDisplaySession()
                .setSimulateDisplay(true).createDisplay();

        // Launch activity on new secondary display.
        separateTestJournal();
        getLaunchActivityBuilder().setUseInstrumentation().setWithShellPermission(true)
                .setTargetActivity(TEST_ACTIVITY).setNewTask(true)
                .setMultipleTask(true).setActivityType(activityType)
                .setDisplayId(newDisplay.mId).execute();
        waitAndAssertTopResumedActivity(TEST_ACTIVITY, newDisplay.mId,
                ""Activity launched on secondary display must be focused and on top"");

        // Check that activity config corresponds to display config.
        final SizeInfo reportedSizes = getLastReportedSizesForActivity(TEST_ACTIVITY);
        assertEquals(""Activity launched on secondary display must have proper configuration"",
                CUSTOM_DENSITY_DPI, reportedSizes.densityDpi);

        assertEquals(""Top activity must have correct activity type"", activityType,
                mWmState.getFrontStackActivityType(newDisplay.mId));
    }

    /**
     * Tests launching an activity on primary display explicitly.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplayActivityLaunchTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.MultiDisplayActivityLaunchTests"	"testTaskMatchOrderAcrossDisplays"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/MultiDisplayActivityLaunchTests.java]:[permission]:[1]:method_text:[   }    /**     * Tests that the task affinity search respects the launch display id.     */   ]) :|: 
    public void testTaskMatchOrderAcrossDisplays() {
        getLaunchActivityBuilder().setUseInstrumentation()
                .setTargetActivity(TEST_ACTIVITY).setNewTask(true)
                .setDisplayId(DEFAULT_DISPLAY).execute();
        final int stackId = mWmState.getFrontRootTaskId(DEFAULT_DISPLAY);

        getLaunchActivityBuilder().setUseInstrumentation()
                .setTargetActivity(BROADCAST_RECEIVER_ACTIVITY).setNewTask(true)
                .setDisplayId(DEFAULT_DISPLAY).execute();

        final DisplayContent newDisplay = createManagedVirtualDisplaySession().createDisplay();
        getLaunchActivityBuilder().setUseInstrumentation().setWithShellPermission(true)
                .setTargetActivity(TEST_ACTIVITY).setNewTask(true)
                .setDisplayId(newDisplay.mId).execute();
        assertNotEquals(""Top focus stack should not be on default display"",
                stackId, mWmState.getFocusedStackId());

        mBroadcastActionTrigger.launchActivityNewTask(getActivityName(TEST_ACTIVITY));
        waitAndAssertTopResumedActivity(TEST_ACTIVITY, DEFAULT_DISPLAY,
                ""Activity must be launched on default display"");
        mWmState.assertFocusedStack(""Top focus stack must be on the default display"", stackId);
    }

    /**
     * Tests that the task affinity search respects the launch display id.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplayActivityLaunchTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.MultiDisplayActivityLaunchTests"	"testLaunchPendingIntentActivity"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/MultiDisplayActivityLaunchTests.java]:[permission]:[1]:method_text:[displayContent.mId,                ""Activity launched on secondary display and on top"");    }   ]) :|: 
    public void testLaunchPendingIntentActivity() throws Exception {
        final DisplayContent displayContent = createManagedVirtualDisplaySession()
                .setSimulateDisplay(true)
                .createDisplay();

        // Activity should be launched on primary display by default.
        getPendingIntentActivity(TEST_ACTIVITY).send();
        waitAndAssertTopResumedActivity(TEST_ACTIVITY, DEFAULT_DISPLAY,
                ""Activity launched on primary display and on top"");

        final int resultCode = 1;
        // Activity should be launched on target display according to the caller context.
        final Context displayContext =
                mContext.createDisplayContext(mDm.getDisplay(displayContent.mId));
        getPendingIntentActivity(TOP_ACTIVITY).send(displayContext, resultCode, null /* intent */);
        waitAndAssertTopResumedActivity(TOP_ACTIVITY, displayContent.mId,
                ""Activity launched on secondary display and on top"");

        // Activity should be brought to front on the same display if it already existed.
        getPendingIntentActivity(TEST_ACTIVITY).send(displayContext, resultCode, null /* intent */);
        waitAndAssertTopResumedActivity(TEST_ACTIVITY, DEFAULT_DISPLAY,
                ""Activity launched on primary display and on top"");

        // Activity should be moved to target display.
        final ActivityOptions options = ActivityOptions.makeBasic();
        options.setLaunchDisplayId(displayContent.mId);
        getPendingIntentActivity(TEST_ACTIVITY).send(mContext, resultCode, null /* intent */,
                null /* onFinished */, null /* handler */, null /* requiredPermission */,
                options.toBundle());
        waitAndAssertTopResumedActivity(TEST_ACTIVITY, displayContent.mId,
                ""Activity launched on secondary display and on top"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplayActivityLaunchTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.MultiDisplayPrivateDisplayTests"	"supportsMultiDisplay"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([2:/android/server/wm/MultiDisplayPrivateDisplayTests.java]:[permission]:[2]:method_text:[ an activity on a private display without special permission must not be     * allowed.     */   ]) :|: /*
 *
 */

package android.server.wm;

import static android.server.wm.app.Components.TEST_ACTIVITY;
import static android.view.Display.FLAG_PRIVATE;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assume.assumeFalse;
import static org.junit.Assume.assumeTrue;

import android.app.ActivityManager;
import android.content.Context;
import android.content.Intent;
import android.platform.test.annotations.Presubmit;
import android.server.wm.WindowManagerState.DisplayContent;
import android.util.Log;

import com.android.compatibility.common.util.SystemUtil;

import java.util.ArrayList;

import org.junit.Before;
import org.junit.Test;

/**
 * Build/Install/Run:
 *     atest CtsWindowManagerDeviceTestCases:MultiDisplayPrivateDisplayTests
 *
 * Tests if be allowed to launch/access an activity on private display
 * in multi-display environment.
 */
@Presubmit
@android.server.wm.annotation.Group3
public class MultiDisplayPrivateDisplayTests extends MultiDisplayTestBase {
    private static final String TAG = ""MultiDisplayPrivateDisplayTests"";
    private static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);
    private static final String INTERNAL_SYSTEM_WINDOW =
            ""android.permission.INTERNAL_SYSTEM_WINDOW"";
    private ArrayList<Integer> mPrivateDisplayIds = new ArrayList<>();

    @Before
    @Override
    public void setUp() throws Exception {
        super.setUp();
        assumeTrue(supportsMultiDisplay());
        findPrivateDisplays();
        assumeFalse(""Skipping test: no physical private display found."",
                mPrivateDisplayIds.isEmpty());
    }

    /** Saves physical private displays in mPrivateDisplayIds */
    private void findPrivateDisplays() {
        mPrivateDisplayIds.clear();
        mWmState.computeState();

        for (DisplayContent displayContent: getDisplaysStates()) {
            int displayId = displayContent.mId;
            DisplayContent display = mWmState."	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplayPrivateDisplayTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.MultiDisplayPrivateDisplayTests"	"testCantLaunchOnPrivateDisplay"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/MultiDisplayPrivateDisplayTests.java]:[permission]:[1]:method_text:[* call to start an activity on private display is not allowed without special permission     */   ]) :|: 
    public void testCantLaunchOnPrivateDisplay() throws Exception {
        // try on each private display
        for (int displayId: mPrivateDisplayIds) {
            separateTestJournal();

            getLaunchActivityBuilder()
                .setDisplayId(displayId)
                .setTargetActivity(TEST_ACTIVITY)
                .execute();

            assertSecurityExceptionFromActivityLauncher();

            mWmState.computeState(TEST_ACTIVITY);
            assertFalse(""Activity must not be launched on a private display"",
                mWmState.containsActivity(TEST_ACTIVITY));
        }
    }

    /**
     * Tests
     * {@link android.app.ActivityManager#isActivityStartAllowedOnDisplay(Context, int, Intent)}
     * call to start an activity on private display is not allowed without special permission
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplayPrivateDisplayTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.MultiDisplayPrivateDisplayTests"	"testCantAccessPrivateDisplay"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/MultiDisplayPrivateDisplayTests.java]:[permission]:[1]:method_text:[text, int, Intent)}     * for a private display with INTERNAL_SYSTEM_WINDOW permission.     */   ]) :|: 
    public void testCantAccessPrivateDisplay() throws Exception {
        final ActivityManager activityManager =
            (ActivityManager) mTargetContext.getSystemService(Context.ACTIVITY_SERVICE);
        final Intent intent = new Intent(Intent.ACTION_VIEW).setComponent(TEST_ACTIVITY);

        for (int displayId: mPrivateDisplayIds) {
            assertFalse(activityManager.isActivityStartAllowedOnDisplay(mTargetContext,
                displayId, intent));
        }
    }

    /**
     * Tests
     * {@link android.app.ActivityManager#isActivityStartAllowedOnDisplay(Context, int, Intent)}
     * for a private display with INTERNAL_SYSTEM_WINDOW permission.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplayPrivateDisplayTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.MultiDisplayPrivateDisplayTests"	"testCanAccessPrivateDisplayWithInternalPermission"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([2:/android/server/wm/MultiDisplayPrivateDisplayTests.java]:[permission]:[2]:method_text:[(mTargetContext,                    displayId, intent)), INTERNAL_SYSTEM_WINDOW);        }    }}]) :|: 
    public void testCanAccessPrivateDisplayWithInternalPermission() throws Exception {
        final ActivityManager activityManager =
            (ActivityManager) mTargetContext.getSystemService(Context.ACTIVITY_SERVICE);
        final Intent intent = new Intent(Intent.ACTION_VIEW)
            .setComponent(TEST_ACTIVITY);

        for (int displayId: mPrivateDisplayIds) {
            SystemUtil.runWithShellPermissionIdentity(() ->
                assertTrue(activityManager.isActivityStartAllowedOnDisplay(mTargetContext,
                    displayId, intent)), INTERNAL_SYSTEM_WINDOW);
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplayPrivateDisplayTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.StartActivityTests"	"testNormalActivityCanNotSetActivityType"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([17:/android/server/wm/StartActivityTests.java]:[permission]:[17]:method_text:[@link Activity#startActivities} to start B1 and     * A2, the result should be 3 tasks.     */   ]) :|: 
    public void testNormalActivityCanNotSetActivityType() {
        // Activities should not be started if the launch activity type is set.
        boolean useShellPermission = false;
        startingActivityWithType(ACTIVITY_TYPE_STANDARD, useShellPermission);
        startingActivityWithType(ACTIVITY_TYPE_HOME, useShellPermission);
        startingActivityWithType(ACTIVITY_TYPE_RECENTS, useShellPermission);
        startingActivityWithType(ACTIVITY_TYPE_ASSISTANT, useShellPermission);
        startingActivityWithType(ACTIVITY_TYPE_DREAM, useShellPermission);

        // Activities can be started because they are started with shell permissions.
        useShellPermission = true;
        startingActivityWithType(ACTIVITY_TYPE_STANDARD, useShellPermission);
        startingActivityWithType(ACTIVITY_TYPE_HOME, useShellPermission);
        startingActivityWithType(ACTIVITY_TYPE_RECENTS, useShellPermission);
        startingActivityWithType(ACTIVITY_TYPE_ASSISTANT, useShellPermission);
        startingActivityWithType(ACTIVITY_TYPE_DREAM, useShellPermission);
    }

    private void startingActivityWithType(int type, boolean useShellPermission) {
        separateTestJournal();
        getLaunchActivityBuilder()
                .setTargetActivity(BROADCAST_RECEIVER_ACTIVITY)
                .setUseInstrumentation()
                .setWithShellPermission(useShellPermission)
                .setActivityType(type)
                .setWaitForLaunched(false)
                .setMultipleTask(true)
                .execute();

        mWmState.computeState();
        if (useShellPermission) {
            waitAndAssertResumedActivity(BROADCAST_RECEIVER_ACTIVITY,
                    ""Activity should be started and resumed"");
            mWmState.assertFrontStackActivityType(""The activity type should be same as requested."",
                    type);
            mBroadcastActionTrigger.finishBroadcastReceiverActivity();
            mWmState.waitAndAssertActivityRemoved(BROADCAST"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/StartActivityTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.StartActivityTests"	"testStartActivitiesTaskOverlayStayOnTop"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/StartActivityTests.java]:[permission]:[1]:method_text:[.getTaskByActivity(intents[i].getComponent()).getTaskId();        }        return taskIds;    }}]) :|: 
    public void testStartActivitiesTaskOverlayStayOnTop() {
        final Intent baseIntent = new Intent(mContext, Activities.RegularActivity.class);
        final String regularActivityName = Activities.RegularActivity.class.getName();
        final TestActivitySession<Activities.RegularActivity> activitySession =
                createManagedTestActivitySession();
        activitySession.launchTestActivityOnDisplaySync(regularActivityName, baseIntent,
                DEFAULT_DISPLAY);
        mWmState.computeState(baseIntent.getComponent());
        final int taskId = mWmState.getTaskByActivity(baseIntent.getComponent()).getTaskId();
        final Activity baseActivity = activitySession.getActivity();

        final ActivityOptions overlayOptions = ActivityOptions.makeBasic();
        overlayOptions.setTaskOverlay(true, true);
        overlayOptions.setLaunchTaskId(taskId);
        final Intent taskOverlay = new Intent().setComponent(SECOND_ACTIVITY);
        runWithShellPermission(() ->
                baseActivity.startActivity(taskOverlay, overlayOptions.toBundle()));

        waitAndAssertResumedActivity(taskOverlay.getComponent(),
                ""taskOverlay activity on top"");
        final Intent behindOverlay = new Intent().setComponent(TEST_ACTIVITY);
        baseActivity.startActivity(behindOverlay);

        waitAndAssertActivityState(TEST_ACTIVITY, STATE_INITIALIZING,
                ""Activity behind taskOverlay should not resumed"");
        // check order: SecondActivity(top) -> TestActivity -> RegularActivity(base)
        final List<String> activitiesOrder = mWmState.getTaskByActivity(baseIntent.getComponent())
                .mActivities
                .stream()
                .map(WindowManagerState.Activity::getName)
                .collect(Collectors.toList());

        final List<String> expectedOrder = Stream.of(
                SECOND_ACTIVITY,
                TEST_ACTIVITY,
                baseIntent.getComponent())
                .map"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/StartActivityTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.WindowUntrustedTouchTest"	"TestName"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([2:/android/server/wm/WindowUntrustedTouchTest.java]:[permission]:[2]:method_text:[);        AppOpsUtils.setOpMode(APP_SELF, OPSTR_SYSTEM_ALERT_WINDOW, mPreviousSawAppOp);    }   ]) :|: /*
 *.
 */

package android.server.wm;

import static android.app.AppOpsManager.MODE_ALLOWED;
import static android.app.AppOpsManager.OPSTR_SYSTEM_ALERT_WINDOW;
import static android.server.wm.UiDeviceUtils.pressUnlockButton;
import static android.server.wm.UiDeviceUtils.pressWakeupButton;
import static android.server.wm.WindowManagerState.STATE_RESUMED;
import static android.server.wm.overlay.Components.OverlayActivity.EXTRA_TOKEN;

import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;

import static com.google.common.truth.Truth.assertThat;

import static junit.framework.Assert.assertEquals;
import static junit.framework.Assert.assertTrue;
import static junit.framework.Assert.fail;

import android.app.Activity;
import android.app.ActivityManager;
import android.app.ActivityOptions;
import android.app.Instrumentation;
import android.app.NotificationManager;
import android.content.ComponentName;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.content.res.Resources;
import android.graphics.Rect;
import android.hardware.input.InputManager;
import android.os.Bundle;
import android.os.ConditionVariable;
import android.os.Handler;
import android.os.IBinder;
import android.os.Looper;
import android.os.SystemClock;
import android.platform.test.annotations.Presubmit;
import android.provider.Settings;
import android.server.wm.overlay.Components;
import android.server.wm.overlay.R;
import android.server.wm.shared.BlockingResultReceiver;
import android.server.wm.shared.IUntrustedTouchTestService;
import android.util.ArrayMap;
import android.util.ArraySet;
import android.view.Display;
import android.view.Gravity;
import android.view.MotionEvent;
import android.view.View;
import android.view.WindowManager;
import android.view.WindowManager.LayoutParams;
import android.widget.Toast;

import androidx.annotation.AnimRes;
import androidx.annotation.Nullable;
import androidx.test.rule"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowUntrustedTouchTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.WindowUntrustedTouchTest"	"testAfterSettingThresholdGreaterThan1ViaSettings_previousThresholdIsUsed"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/WindowUntrustedTouchTest.java]:[permission]:[1]:method_text:[hNotReceived();    }    /** This is testing what happens if setting is overridden manually */   ]) :|: 
    public void testAfterSettingThresholdGreaterThan1ViaSettings_previousThresholdIsUsed()
            throws Throwable {
        setMaximumObscuringOpacityForTouch(.8f);
        assertEquals(.8f, mInputManager.getMaximumObscuringOpacityForTouch());
        SystemUtil.runWithShellPermissionIdentity(() -> {
            Settings.Global.putFloat(mContentResolver, SETTING_MAXIMUM_OBSCURING_OPACITY, 1.5f);
        });
        addSawOverlay(APP_A, WINDOW_1, 9.f);

        mTouchHelper.tapOnViewCenter(mContainer);

        // Blocks because it's using previous maximum of .8
        assertTouchNotReceived();
    }

    /** This is testing what happens if setting is overridden manually */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowUntrustedTouchTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.WindowUntrustedTouchTest"	"testAfterSettingThresholdLessThan0ViaSettings_previousThresholdIsUsed"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/WindowUntrustedTouchTest.java]:[permission]:[1]:method_text:[because it's using previous maximum of .8        assertTouchReceived();    }    /** SAWs */   ]) :|: 
    public void testAfterSettingThresholdLessThan0ViaSettings_previousThresholdIsUsed()
            throws Throwable {
        setMaximumObscuringOpacityForTouch(.8f);
        assertEquals(.8f, mInputManager.getMaximumObscuringOpacityForTouch());
        SystemUtil.runWithShellPermissionIdentity(() -> {
            Settings.Global.putFloat(mContentResolver, SETTING_MAXIMUM_OBSCURING_OPACITY, -.5f);
        });
        addSawOverlay(APP_A, WINDOW_1, .7f);

        mTouchHelper.tapOnViewCenter(mContainer);

        // Allows because it's using previous maximum of .8
        assertTouchReceived();
    }

    /** SAWs */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowUntrustedTouchTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.WindowUntrustedTouchTest"	"testWhenOneSelfCustomToastWindowOneSelfActivityWindowAndOneSawBelowThreshold_allowsTouch"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([3:/android/server/wm/WindowUntrustedTouchTest.java]:[permission]:[3]:method_text:[        view.setBackgroundColor(ACTIVITY_COLOR);            setContentView(view);        }    }}]) :|: 
    public void testWhenOneSelfCustomToastWindowOneSelfActivityWindowAndOneSawBelowThreshold_allowsTouch()
            throws Throwable {
        addActivityOverlay(APP_SELF, /* opacity */ .9f);
        addSawOverlay(APP_A, WINDOW_1, .5f);
        addToastOverlay(APP_SELF, /* custom */ true);

        mTouchHelper.tapOnViewCenter(mContainer);

        assertTouchReceived();
    }

    private boolean onTouchEvent(View view, MotionEvent event) {
        if (event.getAction() == MotionEvent.ACTION_DOWN) {
            mTouchesReceived.incrementAndGet();
        }
        return true;
    }

    private void assertTouchReceived() {
        mInstrumentation.waitForIdleSync();
        assertThat(mTouchesReceived.get()).isEqualTo(1);
        mTouchesReceived.set(0);
    }

    private void assertTouchNotReceived() {
        mInstrumentation.waitForIdleSync();
        assertThat(mTouchesReceived.get()).isEqualTo(0);
        mTouchesReceived.set(0);
    }

    private void assertAnimationRunning() {
        assertThat(mWmState.getDisplay(Display.DEFAULT_DISPLAY).getAppTransitionState()).isEqualTo(
                WindowManagerStateHelper.APP_STATE_RUNNING);
    }

    private void addToastOverlay(String packageName, boolean custom) throws Exception {
        // Making sure there are no toasts currently since we can only check for the presence of
        // *any* toast afterwards and we don't want to be in a situation where this method returned
        // because another toast was being displayed.
        waitForNoToastOverlays();
        if (custom) {
            if (packageName.equals(APP_SELF)) {
                // We add the custom toast here because we already have foreground status due to
                // the activity rule, so no need to start another activity.
                addMyCustomToastOverlay();
            } else {
                // We have to use an activity that will display the toast then finish itself because
                // custom toasts cannot be p"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowUntrustedTouchTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.UnsupportedErrorDialogTests"	"testAnrIsNotShown"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([2:/android/server/wm/UnsupportedErrorDialogTests.java]:[permission]:[2]:method_text:[e.getUriFor(settingName),                Settings.Secure::getInt, Settings.Secure::putInt);    }}]) :|: 
    public void testAnrIsNotShown() {
        // leave the settings at their defaults
        // launch non responsive app
        executeShellCommand(getAmStartCmd(Components.UNRESPONSIVE_ACTIVITY) + "" --ei ""
                + Components.UnresponsiveActivity.EXTRA_ON_CREATE_DELAY_MS + "" 30000"");
        // wait for app to be focused
        mWmState.waitAndAssertAppFocus(Components.UNRESPONSIVE_ACTIVITY.getPackageName(),
                2_000 /* waitTime */);
        // queue up enough key events to trigger an ANR
        for (int i = 0; i < 14; i++) {
            injectKey(KeyEvent.KEYCODE_TAB, false /* longPress */, false /* sync */);
            SystemClock.sleep(500);
        }
        ensureNoCrashDialog(Components.UNRESPONSIVE_ACTIVITY);
        ensureActivityNotFocused(Components.UNRESPONSIVE_ACTIVITY);
    }

    private void findCrashDialogAndCloseApp() {
        UiObject2 closeAppButton = findCloseButton();
        assertNotNull(""Could not find crash dialog!"", closeAppButton);
        closeAppButton.click();
    }

    private void ensureNoCrashDialog(ComponentName activity) {
        UiObject2 closeButton = findCloseButton();
        if (closeButton != null) {
            closeButton.click();
            fail(""An unexpected crash dialog appeared!"");
        }
        final int numWindows = mWmState.getWindowsByPackageName(activity.getPackageName()).size();
        assertEquals(0, numWindows);
    }

    private void ensureActivityNotFocused(ComponentName activity) {
        mWmState.computeState();
        mWmState.assertNotFocusedActivity(""The activity should not be focused"", activity);
    }

    /** Attempt to find the close button of a crash or ANR dialog in at most 2 seconds. */
    private UiObject2 findCloseButton() {
        return mUiDevice.wait(
                Until.findObject(By.res(""android:id/aerr_close"")),
                2_000);
    }

    private void resetAppErrors() {
        SystemUtil.runWithShellPermissionIdentity(mAm::resetAppErro"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/UnsupportedErrorDialogTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.WindowInsetsAnimationSynchronicityTests"	"testControl_rendersSynchronouslyBetweenImeWindowAndAppContent"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/WindowInsetsAnimationSynchronicityTests.java]:[permission]:[1]:method_text:[Context context) {            return new ComponentName(context, SimpleIme.class);        }    }}]) :|: 
    public void testControl_rendersSynchronouslyBetweenImeWindowAndAppContent() throws Throwable {
        runTest(true /* useControlApi */);
    }

    private void runTest(boolean useControlApi) throws Exception {
        try (ImeSession imeSession = new ImeSession(SimpleIme.getName(mContext))) {
            TestActivity activity = launchActivity();
            activity.setUseControlApi(useControlApi);
            PollingCheck.waitFor(activity::hasWindowFocus);
            activity.setEvaluator(() -> {
                // This runs from time to time on the UI thread.
                Bitmap screenshot = getInstrumentation().getUiAutomation().takeScreenshot();
                final int center = screenshot.getWidth() / 2;
                int imePositionApp = lowestPixelWithColor(APP_COLOR, 1, screenshot);
                int contentBottomMiddle = lowestPixelWithColor(APP_COLOR, center, screenshot);
                int behindImeBottomMiddle =
                        lowestPixelWithColor(BEHIND_IME_COLOR, center, screenshot);
                int imePositionIme = Math.max(contentBottomMiddle, behindImeBottomMiddle);
                if (imePositionApp != imePositionIme) {
                    mErrorCollector.addError(new AssertionError(String.format(Locale.US,
                            ""IME is positioned at %d (max of %d, %d),""
                                    + "" app thinks it is positioned at %d"",
                            imePositionIme, contentBottomMiddle, behindImeBottomMiddle,
                            imePositionApp)));
                }
            });
            Thread.sleep(2000);
            activity.setEvaluator(null);
        }
    }

    private TestActivity launchActivity() {
        final ActivityOptions options= ActivityOptions.makeBasic();
        options.setLaunchWindowingMode(WINDOWING_MODE_FULLSCREEN);
        final TestActivity[] activity = (TestActivity[]) Array.newInstance(TestActivity.class, 1);
        SystemUtil.runWithShellPermission"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowInsetsAnimationSynchronicityTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.AlertWindowsImportanceTests"	"testAlertWindowOomAdj"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([6:/android/server/wm/AlertWindowsImportanceTests.java]:[permission]:[6]:method_text:[guration.UI_MODE_TYPE_VR_HEADSET) {            return true;        }        return false;    }}]) :|: 
    @AppModeFull(reason = ""Uses apps targeting older SDK"")
    public void testAlertWindowOomAdj() throws Exception {
        // Alert windows are always hidden when running in VR.
        if (isRunningInVR()) {
            return;
        }
        setAlertWindowPermission(true /* allow */);

        assertPackageImportance(IMPORTANCE_PERCEPTIBLE, IMPORTANCE_PERCEPTIBLE_PRE_26);

        // TODO AM.getUidImportance() sometimes return a different value from what
        // getPackageImportance() returns... b/37950472
        // assertUidImportance(IMPORTANCE_PERCEPTIBLE, IMPORTANCE_PERCEPTIBLE_PRE_26);

        addAlertWindow();
        // Process importance should be increased to visible when the service has an alert window.
        assertPackageImportance(IMPORTANCE_VISIBLE, IMPORTANCE_VISIBLE);

        addAlertWindow();
        assertPackageImportance(IMPORTANCE_VISIBLE, IMPORTANCE_VISIBLE);

        setAlertWindowPermission(false /* allow */);
        // Process importance should no longer be visible since its alert windows are not allowed to
        // be visible.
        assertPackageImportance(IMPORTANCE_PERCEPTIBLE, IMPORTANCE_PERCEPTIBLE_PRE_26);

        setAlertWindowPermission(true /* allow */);
        // They can show again so importance should be visible again.
        assertPackageImportance(IMPORTANCE_VISIBLE, IMPORTANCE_VISIBLE);

        removeAlertWindow();
        assertPackageImportance(IMPORTANCE_VISIBLE, IMPORTANCE_VISIBLE);

        removeAlertWindow();
        // Process importance should no longer be visible when the service no longer as alert
        // windows.
        assertPackageImportance(IMPORTANCE_PERCEPTIBLE, IMPORTANCE_PERCEPTIBLE_PRE_26);
    }

    private void addAlertWindow() throws Exception {
        mService.send(Message.obtain(null, AlertWindowService.MSG_ADD_ALERT_WINDOW));
        synchronized (mAddedLock) {
            // Wait for window addition confirmation before proceeding.
            mAddedLock.wait(WAIT_TIME_M"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/AlertWindowsImportanceTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.DisplayHashManagerTest"	"SyncDisplayHashResultCallback"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([2:/android/server/wm/DisplayHashManagerTest.java]:[permission]:[2]:method_text:[entity(                () -> mDisplayHashManager.setDisplayHashThrottlingEnabled(true));    }   ]) :|: /*
 *.
 */

package android.server.wm;

import static android.view.WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS;
import static android.view.displayhash.DisplayHashResultCallback.DISPLAY_HASH_ERROR_INVALID_BOUNDS;
import static android.view.displayhash.DisplayHashResultCallback.DISPLAY_HASH_ERROR_INVALID_HASH_ALGORITHM;
import static android.view.displayhash.DisplayHashResultCallback.DISPLAY_HASH_ERROR_NOT_VISIBLE_ON_SCREEN;
import static android.view.displayhash.DisplayHashResultCallback.DISPLAY_HASH_ERROR_TOO_MANY_REQUESTS;
import static android.widget.LinearLayout.VERTICAL;

import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;

import android.app.Activity;
import android.app.Instrumentation;
import android.content.Context;
import android.content.Intent;
import android.graphics.Color;
import android.graphics.Point;
import android.graphics.Rect;
import android.os.Bundle;
import android.platform.test.annotations.Presubmit;
import android.view.Gravity;
import android.view.View;
import android.view.ViewTreeObserver;
import android.view.WindowManager;
import android.view.displayhash.DisplayHash;
import android.view.displayhash.DisplayHashManager;
import android.view.displayhash.DisplayHashResultCallback;
import android.view.displayhash.VerifiedDisplayHash;
import android.widget.LinearLayout;
import android.widget.RelativeLayout;

import androidx.annotation.NonNull;
import androidx.test.platform.app.InstrumentationRegistry;
import androidx.test.rule.ActivityTestRule;

import com.android.compatibility.common.util.SystemUtil;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;

import java.util.ArrayList;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;

@Pre"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayHashManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.DisplayHashManagerTest"	"testGenerateDisplayHash_Throttle"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/DisplayHashManagerTest.java]:[permission]:[1]:method_text:[llback.getError();        assertEquals(DISPLAY_HASH_ERROR_TOO_MANY_REQUESTS, errorCode);    }   ]) :|: 
    public void testGenerateDisplayHash_Throttle() {
        SystemUtil.runWithShellPermissionIdentity(
                () -> mDisplayHashManager.setDisplayHashThrottlingEnabled(true));

        setupChildView();

        mTestView.generateDisplayHash(mPhashAlgorithm, null, mExecutor,
                mSyncDisplayHashResultCallback);
        mSyncDisplayHashResultCallback.getDisplayHash();
        mSyncDisplayHashResultCallback.reset();
        // Generate a second display hash right away.
        mTestView.generateDisplayHash(mPhashAlgorithm, null, mExecutor,
                mSyncDisplayHashResultCallback);
        int errorCode = mSyncDisplayHashResultCallback.getError();
        assertEquals(DISPLAY_HASH_ERROR_TOO_MANY_REQUESTS, errorCode);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DisplayHashManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.ConfigChangeTests"	"testUpdateApplicationInfo"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/ConfigChangeTests.java]:[permission]:[1]:method_text:[kages,                        android.os.Process.myUserHandle().getIdentifier())        );    }}]) :|: 
    public void testUpdateApplicationInfo() throws Exception {
        separateTestJournal();

        // Launch an activity that prints applied config.
        launchActivity(TEST_ACTIVITY);
        final int assetSeq = getAssetSeqNumber(TEST_ACTIVITY);

        separateTestJournal();
        // Update package info.
        updateApplicationInfo(Arrays.asList(TEST_ACTIVITY.getPackageName()));
        mWmState.waitForWithAmState((amState) -> {
            // Wait for activity to be resumed and asset seq number to be updated.
            try {
                return getAssetSeqNumber(TEST_ACTIVITY) == assetSeq + 1
                        && amState.hasActivityState(TEST_ACTIVITY, STATE_RESUMED);
            } catch (Exception e) {
                logE(""Error waiting for valid state: "" + e.getMessage());
                return false;
            }
        }, ""asset sequence number to be updated and for activity to be resumed."");

        // Check if activity is relaunched and asset seq is updated.
        assertRelaunchOrConfigChanged(TEST_ACTIVITY, 1 /* numRelaunch */,
                0 /* numConfigChange */);
        final int newAssetSeq = getAssetSeqNumber(TEST_ACTIVITY);
        assertTrue(""Asset sequence number must be incremented."", assetSeq < newAssetSeq);
    }

    private static int getAssetSeqNumber(ComponentName activityName) {
        return TestJournalContainer.get(activityName).extras.getInt(EXTRA_CONFIG_ASSETS_SEQ);
    }

    // Calculate the scaled pixel size just like the device is supposed to.
    private static int scaledPixelsToPixels(float sp, float fontScale, int densityDpi) {
        final int DEFAULT_DENSITY = 160;
        float f = densityDpi * (1.0f / DEFAULT_DENSITY) * fontScale * sp;
        return (int) ((f >= 0) ? (f + 0.5f) : (f - 0.5f));
    }

    private void updateApplicationInfo(List<String> packages) {
        SystemUtil.runWithShellPermissionIdentity(
                () -> mAm.scheduleApplicationInfoChanged(packages,"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/ConfigChangeTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.MultiDisplaySystemDecorationTests"	"testWallpaperShowOnSecondaryDisplays"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([3:/android/server/wm/MultiDisplaySystemDecorationTests.java]:[permission]:[3]:method_text:[.    /**     * Test that navigation bar should show on display with system decoration.     */   ]) :|: 
    public void testWallpaperShowOnSecondaryDisplays()  {
        final ChangeWallpaperSession wallpaperSession = createManagedChangeWallpaperSession();

        final DisplayContent untrustedDisplay = createManagedExternalDisplaySession()
                .setPublicDisplay(true).setShowSystemDecorations(true).createVirtualDisplay();

        final DisplayContent decoredSystemDisplay = createManagedVirtualDisplaySession()
                .setSimulateDisplay(true).setShowSystemDecorations(true).createDisplay();

        final Bitmap tmpWallpaper = wallpaperSession.getTestBitmap();
        wallpaperSession.setImageWallpaper(tmpWallpaper);

        assertTrue(""Wallpaper must be displayed on system owned display with system decor flag"",
                mWmState.waitForWithAmState(
                        state -> isWallpaperOnDisplay(state, decoredSystemDisplay.mId),
                        ""wallpaper window to show""));

        assertFalse(""Wallpaper must not be displayed on the untrusted display"",
                isWallpaperOnDisplay(mWmState, untrustedDisplay.mId));
    }

    private ChangeWallpaperSession createManagedChangeWallpaperSession() {
        return mObjectTracker.manage(new ChangeWallpaperSession());
    }

    private class ChangeWallpaperSession implements AutoCloseable {
        private final WallpaperManager mWallpaperManager;
        private Bitmap mTestBitmap;

        public ChangeWallpaperSession() {
            mWallpaperManager = WallpaperManager.getInstance(mContext);
        }

        public Bitmap getTestBitmap() {
            if (mTestBitmap == null) {
                mTestBitmap = Bitmap.createBitmap(100, 100, Bitmap.Config.ARGB_8888);
                final Canvas canvas = new Canvas(mTestBitmap);
                canvas.drawColor(Color.BLUE);
            }
            return mTestBitmap;
        }

        public void setImageWallpaper(Bitmap bitmap) {
            SystemUtil.runWithShellPermissionIdentity(() ->
                    mWallpa"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplaySystemDecorationTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.MultiDisplaySystemDecorationTests"	"testCrossDisplayBasicImeOperations"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/MultiDisplaySystemDecorationTests.java]:[permission]:[1]:method_text:[ that the IME can be hidden with the {@link WindowManager#DISPLAY_IME_POLICY_HIDE} flag.     */   ]) :|: 
    public void testCrossDisplayBasicImeOperations() throws Exception {
        assumeTrue(MSG_NO_MOCK_IME, supportsInstallableIme());

        final long TIMEOUT = TimeUnit.SECONDS.toMillis(5);

        final MockImeSession mockImeSession = createManagedMockImeSession(this);
        final TestActivitySession<ImeTestActivity> imeTestActivitySession =
                createManagedTestActivitySession();

        // Create a virtual display by app and assume the display should not show IME window.
        final DisplayContent newDisplay = createManagedVirtualDisplaySession()
                .setPublicDisplay(true)
                .createDisplay();
        SystemUtil.runWithShellPermissionIdentity(
                () -> assertTrue(""Display should not support showing IME window"",
                        mTargetContext.getSystemService(WindowManager.class)
                                .getDisplayImePolicy(newDisplay.mId)
                                == DISPLAY_IME_POLICY_FALLBACK_DISPLAY));

        // Launch Ime test activity in virtual display.
        imeTestActivitySession.launchTestActivityOnDisplay(ImeTestActivity.class,
                newDisplay.mId);

        // Expect onStartInput / showSoftInput would be executed when user tapping on the
        // non-system created display intentionally.
        final int[] location = new int[2];
        imeTestActivitySession.getActivity().mEditText.getLocationOnScreen(location);
        tapOnDisplaySync(location[0], location[1], newDisplay.mId);

        // Verify the activity to show soft input on the default display.
        final ImeEventStream stream = mockImeSession.openEventStream();
        final EditText editText = imeTestActivitySession.getActivity().mEditText;
        imeTestActivitySession.runOnMainSyncAndWait(
                imeTestActivitySession.getActivity()::showSoftInput);
        waitOrderedImeEventsThenAssertImeShown(stream, DEFAULT_DISPLAY,
                editorMatcher(""onStartInput"", editText.g"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplaySystemDecorationTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.MultiDisplaySystemDecorationTests"	"testDisplayPolicyImeHideImeNoSystemDecorations"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([1:/android/server/wm/MultiDisplaySystemDecorationTests.java]:[permission]:[1]:method_text:[             TIMEOUT);        InputMethodVisibilityVerifier.expectImeInvisible(TIMEOUT);    }   ]) :|: 
    public void testDisplayPolicyImeHideImeNoSystemDecorations() throws Exception {
        assumeTrue(MSG_NO_MOCK_IME, supportsInstallableIme());

        final MockImeSession mockImeSession = createManagedMockImeSession(this);
        final ImeEventStream stream = mockImeSession.openEventStream();

        // Create a virtual display with the policy to hide the IME.
        final DisplayContent newDisplay = createManagedVirtualDisplaySession()
                .setShowSystemDecorations(false)
                .setDisplayImePolicy(DISPLAY_IME_POLICY_HIDE)
                .setSimulateDisplay(true)
                .createDisplay();

        SystemUtil.runWithShellPermissionIdentity(
                () -> assertTrue(""Display should not support showing IME window"",
                        mTargetContext.getSystemService(WindowManager.class)
                                .getDisplayImePolicy(newDisplay.mId)
                                == DISPLAY_IME_POLICY_HIDE));

        final TestActivitySession<ImeTestActivity> imeTestActivitySession =
                createManagedTestActivitySession();

        // Launch Ime test activity in virtual display.
        imeTestActivitySession.launchTestActivityOnDisplay(ImeTestActivity.class,
                newDisplay.mId);

        // Tap the EditText on the virtual display.
        final int[] location = new int[2];
        EditText editText = imeTestActivitySession.getActivity().mEditText;
        tapOnDisplayCenter(newDisplay.mId);
        editText.getLocationOnScreen(location);
        tapOnDisplaySync(location[0], location[1], newDisplay.mId);

        final long TIMEOUT = TimeUnit.SECONDS.toMillis(5);

        // Verify the activity does not show soft input.
        notExpectEvent(stream, editorMatcher(""onStartInput"", editText.getPrivateImeOptions()),
                TIMEOUT);
        InputMethodVisibilityVerifier.expectImeInvisible(TIMEOUT);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplaySystemDecorationTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.HideOverlayWindowsTest"	"testApplicationOverlayHiddenWhenRequested"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([2:/android/server/wm/HideOverlayWindowsTest.java]:[permission]:[2]:method_text:[ndWaitForPong(false);        mWmState.waitAndAssertWindowSurfaceShown(windowName, true);    }   ]) :|: 
    public void testApplicationOverlayHiddenWhenRequested() {
        String windowName = ""SYSTEM_ALERT_WINDOW"";
        ComponentName componentName = new ComponentName(
                mContext, SystemWindowActivity.class);

        SystemUtil.runWithShellPermissionIdentity(() -> {
            launchActivity(componentName,
                    CliIntentExtra.extraString(WINDOW_NAME_EXTRA, windowName));
            mWmState.waitAndAssertWindowSurfaceShown(windowName, true);
        }, Manifest.permission.SYSTEM_ALERT_WINDOW);

        launchActivity(HIDE_OVERLAY_WINDOWS_ACTIVITY);
        mWmState.waitAndAssertWindowSurfaceShown(windowName, true);

        setHideOverlayWindowsAndWaitForPong(true);
        mWmState.waitAndAssertWindowSurfaceShown(windowName, false);

        setHideOverlayWindowsAndWaitForPong(false);
        mWmState.waitAndAssertWindowSurfaceShown(windowName, true);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/HideOverlayWindowsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.HideOverlayWindowsTest"	"testSystemApplicationOverlayFlagNoEffectWithoutPermission"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([3:/android/server/wm/HideOverlayWindowsTest.java]:[permission]:[3]:method_text:[ndWaitForPong(false);        mWmState.waitAndAssertWindowSurfaceShown(windowName, true);    }   ]) :|: 
    public void testSystemApplicationOverlayFlagNoEffectWithoutPermission() {
        String windowName = ""SYSTEM_ALERT_WINDOW"";
        ComponentName componentName = new ComponentName(
                mContext, SystemWindowActivity.class);

        SystemUtil.runWithShellPermissionIdentity(() -> {
            launchActivity(componentName,
                    CliIntentExtra.extraString(WINDOW_NAME_EXTRA, windowName),
                    CliIntentExtra.extraBool(SYSTEM_APPLICATION_OVERLAY_EXTRA, true));
            mWmState.waitAndAssertWindowSurfaceShown(windowName, true);
        }, Manifest.permission.SYSTEM_ALERT_WINDOW);

        launchActivity(HIDE_OVERLAY_WINDOWS_ACTIVITY);
        mWmState.waitAndAssertWindowSurfaceShown(windowName, true);

        setHideOverlayWindowsAndWaitForPong(true);
        mWmState.waitAndAssertWindowSurfaceShown(windowName, false);

        setHideOverlayWindowsAndWaitForPong(false);
        mWmState.waitAndAssertWindowSurfaceShown(windowName, true);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/HideOverlayWindowsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.HideOverlayWindowsTest"	"testInternalSystemApplicationOverlaysNotHidden"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([2:/android/server/wm/HideOverlayWindowsTest.java]:[permission]:[2]:method_text:[AndWaitForPong(true);        mWmState.waitAndAssertWindowSurfaceShown(windowName, true);    }   ]) :|: 
    public void testInternalSystemApplicationOverlaysNotHidden() {
        String windowName = ""INTERNAL_SYSTEM_WINDOW"";
        ComponentName componentName = new ComponentName(
                mContext, InternalSystemWindowActivity.class);

        SystemUtil.runWithShellPermissionIdentity(() -> {
            launchActivity(componentName,
                    CliIntentExtra.extraString(WINDOW_NAME_EXTRA, windowName));
            mWmState.waitAndAssertWindowSurfaceShown(windowName, true);
        }, Manifest.permission.INTERNAL_SYSTEM_WINDOW);

        launchActivity(HIDE_OVERLAY_WINDOWS_ACTIVITY);
        setHideOverlayWindowsAndWaitForPong(true);
        mWmState.waitAndAssertWindowSurfaceShown(windowName, true);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/HideOverlayWindowsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.HideOverlayWindowsTest"	"testSystemApplicationOverlaysNotHidden"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([2:/android/server/wm/HideOverlayWindowsTest.java]:[permission]:[2]:method_text:[AndWaitForPong(true);        mWmState.waitAndAssertWindowSurfaceShown(windowName, true);    }   ]) :|: 
    public void testSystemApplicationOverlaysNotHidden() {
        String windowName = ""SYSTEM_APPLICATION_OVERLAY"";
        ComponentName componentName = new ComponentName(
                mContext, SystemApplicationOverlayActivity.class);
        SystemUtil.runWithShellPermissionIdentity(() -> {
            launchActivity(componentName,
                    CliIntentExtra.extraString(WINDOW_NAME_EXTRA, windowName),
                    CliIntentExtra.extraBool(SYSTEM_APPLICATION_OVERLAY_EXTRA, true));
            mWmState.waitAndAssertWindowSurfaceShown(windowName, true);
        }, Manifest.permission.SYSTEM_APPLICATION_OVERLAY);

        launchActivity(HIDE_OVERLAY_WINDOWS_ACTIVITY);
        setHideOverlayWindowsAndWaitForPong(true);
        mWmState.waitAndAssertWindowSurfaceShown(windowName, true);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/HideOverlayWindowsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.server.wm.HideOverlayWindowsTest"	"testSystemApplicationOverlayHiddenWithoutFlag"	"CtsWindowManagerDeviceTestCases"	"1: permission"	"([5:/android/server/wm/HideOverlayWindowsTest.java]:[permission]:[5]:method_text:[lock(10000L)).isTrue();            mConditionVariable = new ConditionVariable();        }    }}]) :|: 
    public void testSystemApplicationOverlayHiddenWithoutFlag() {
        String windowName = ""SYSTEM_APPLICATION_OVERLAY"";
        ComponentName componentName = new ComponentName(
                mContext, SystemApplicationOverlayActivity.class);
        SystemUtil.runWithShellPermissionIdentity(() -> {
            launchActivity(componentName,
                    CliIntentExtra.extraString(WINDOW_NAME_EXTRA, windowName));
            mWmState.waitAndAssertWindowSurfaceShown(windowName, true);
        }, Manifest.permission.SYSTEM_APPLICATION_OVERLAY);

        launchActivity(HIDE_OVERLAY_WINDOWS_ACTIVITY);
        setHideOverlayWindowsAndWaitForPong(true);
        mWmState.waitAndAssertWindowSurfaceShown(windowName, false);
    }

    void setHideOverlayWindowsAndWaitForPong(boolean hide) {
        Intent intent = new Intent(ACTION);
        intent.putExtra(Components.HideOverlayWindowsActivity.SHOULD_HIDE, hide);
        mContext.sendBroadcast(intent);
        mPongReceiver.waitForPong();
    }

    public static class BaseSystemWindowActivity extends Activity {

        TextView mTextView;

        @Override
        protected void onCreate(@Nullable Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            String windowName = getIntent().getStringExtra(WINDOW_NAME_EXTRA);

            final Point size = new Point();
            getDisplay().getRealSize(size);

            WindowManager.LayoutParams params =
                    new WindowManager.LayoutParams(TYPE_APPLICATION_OVERLAY, 0);
            params.width = size.x / 3;
            params.height = size.y / 3;
            params.gravity = TOP | LEFT;
            params.setTitle(windowName);
            params.setSystemApplicationOverlay(
                    getIntent().getBooleanExtra(SYSTEM_APPLICATION_OVERLAY_EXTRA, false));

            mTextView = new TextView(this);
            mTextView.setText(windowName + ""   type="" + TYPE_APPLICATION_OVERLAY);
            mTextView.se"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/HideOverlayWindowsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.jobscheduler.cts.shareduidtests.ClipDataJobTest"	"testClipDataGrant"	"CtsJobSchedulerSharedUidTestCases"	"1: permission"	"([21:/android/jobscheduler/cts/shareduidtests/ClipDataJobTest.java]:[permission]:[21]:method_text:[orrectly fail when trying to grant permissions to things we don't     * have access to.     */   ]) :|: public void testClipDataGrant() throws Exception {
        // Start out with storage low, so job is enqueued but not executed yet.
        setStorageState(true);

        // We need to get a permission grant so that we can grant it to ourself.
        mProvider.call(""grant"", MY_PACKAGE, mFirstUriBundle);
        assertEquals(PackageManager.PERMISSION_GRANTED,
                getContext().checkUriPermission(mFirstUri, Process.myPid(),
                        Process.myUid(), Intent.FLAG_GRANT_READ_URI_PERMISSION));
        assertEquals(PackageManager.PERMISSION_GRANTED,
                getContext().checkUriPermission(mFirstUri, Process.myPid(),
                        Process.myUid(), Intent.FLAG_GRANT_WRITE_URI_PERMISSION));

        // Schedule the job, the system should now also be holding a URI grant for us.
        kTestEnvironment.setExpectedExecutions(1);
        mJobScheduler.schedule(mBuilder.setRequiresStorageNotLow(true)
                .setClipData(mFirstClipData, Intent.FLAG_GRANT_READ_URI_PERMISSION
                        | Intent.FLAG_GRANT_WRITE_URI_PERMISSION).build());

        // Remove the explicit grant, we should still have a grant due to the job.
        mProvider.call(""revoke"", MY_PACKAGE, mFirstUriBundle);
        assertEquals(PackageManager.PERMISSION_GRANTED,
                getContext().checkUriPermission(mFirstUri, Process.myPid(),
                        Process.myUid(), Intent.FLAG_GRANT_READ_URI_PERMISSION));
        assertEquals(PackageManager.PERMISSION_GRANTED,
                getContext().checkUriPermission(mFirstUri, Process.myPid(),
                        Process.myUid(), Intent.FLAG_GRANT_WRITE_URI_PERMISSION));

        // Now allow the job to run and wait for it.
        setStorageState(false);
        assertTrue(""Job with storage not low constraint did not fire when storage not low."",
                kTestEnvironment.awaitExecution());

        // Make sure the job still had the permission granted.
        assertEquals(Pack"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/JobSchedulerSharedUid/src/android/jobscheduler/cts/shareduidtests/ClipDataJobTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.jobscheduler.cts.shareduidtests.ClipDataJobTest"	"testClipDataGrant_Failed"	"CtsJobSchedulerSharedUidTestCases"	"1: permission"	"([3:/android/jobscheduler/cts/shareduidtests/ClipDataJobTest.java]:[permission]:[3]:method_text:[ssions associated with jobs and are correctly     * retained when rescheduling the job.     */   ]) :|: public void testClipDataGrant_Failed() throws Exception {
        try {
            mJobScheduler.schedule(mBuilder.setRequiresStorageNotLow(true)
                    .setClipData(mFirstClipData, Intent.FLAG_GRANT_READ_URI_PERMISSION
                            | Intent.FLAG_GRANT_WRITE_URI_PERMISSION).build());
        } catch (SecurityException e) {
            return;
        }

        fail(""Security exception not thrown"");
    }

    /**
     * Test basic granting of URI permissions associated with jobs and are correctly
     * retained when rescheduling the job.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/JobSchedulerSharedUid/src/android/jobscheduler/cts/shareduidtests/ClipDataJobTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.jobscheduler.cts.shareduidtests.ClipDataJobTest"	"testClipDataGrantReschedule"	"CtsJobSchedulerSharedUidTestCases"	"1: permission"	"([22:/android/jobscheduler/cts/shareduidtests/ClipDataJobTest.java]:[permission]:[22]:method_text:[d up.        waitPermissionRevoke(mFirstUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION, 5000);    }}]) :|: public void testClipDataGrantReschedule() throws Exception {
        // We need to get a permission grant so that we can grant it to ourself.
        mProvider.call(""grant"", MY_PACKAGE, mFirstUriBundle);
        assertEquals(PackageManager.PERMISSION_GRANTED,
                getContext().checkUriPermission(mFirstUri, Process.myPid(),
                        Process.myUid(), Intent.FLAG_GRANT_READ_URI_PERMISSION));
        assertEquals(PackageManager.PERMISSION_GRANTED,
                getContext().checkUriPermission(mFirstUri, Process.myPid(),
                        Process.myUid(), Intent.FLAG_GRANT_WRITE_URI_PERMISSION));

        // Schedule the job, the system should now also be holding a URI grant for us.
        kTestEnvironment.setExpectedExecutions(1);
        mJobScheduler.schedule(mBuilder.setMinimumLatency(60*60*1000)
                .setClipData(mFirstClipData, Intent.FLAG_GRANT_READ_URI_PERMISSION
                        | Intent.FLAG_GRANT_WRITE_URI_PERMISSION).build());

        // Remove the explicit grant, we should still have a grant due to the job.
        mProvider.call(""revoke"", MY_PACKAGE, mFirstUriBundle);
        assertEquals(PackageManager.PERMISSION_GRANTED,
                getContext().checkUriPermission(mFirstUri, Process.myPid(),
                        Process.myUid(), Intent.FLAG_GRANT_READ_URI_PERMISSION));
        assertEquals(PackageManager.PERMISSION_GRANTED,
                getContext().checkUriPermission(mFirstUri, Process.myPid(),
                        Process.myUid(), Intent.FLAG_GRANT_WRITE_URI_PERMISSION));

        // Now reschedule the job to have it happen right now.
        mJobScheduler.schedule(mBuilder.setMinimumLatency(0)
                .setClipData(mFirstClipData, Intent.FLAG_GRANT_READ_URI_PERMISSION
                        | Intent.FLAG_GRANT_WRITE_URI_PERMISSION).build());
        assertTrue(""Job with storage not low constraint did not fire when storage not low."",
                kTestEnvironment.awaitExecutio"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/JobSchedulerSharedUid/src/android/jobscheduler/cts/shareduidtests/ClipDataJobTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.jobscheduler.cts.shareduidtests.EnqueueJobWorkTest"	"testEnqueueMultipleUriGrantWork"	"CtsJobSchedulerSharedUidTestCases"	"1: permission"	"([21:/android/jobscheduler/cts/shareduidtests/EnqueueJobWorkTest.java]:[permission]:[21]:method_text:[tic int getCurrentUser() {        return android.os.Process.myUserHandle().getIdentifier();    }}]) :|: public void testEnqueueMultipleUriGrantWork() throws Exception {
        // Start out with storage low, so job is enqueued but not executed yet.
        setStorageState(true);

        // We need to get a permission grant so that we can grant it to ourself.
        mProvider.call(""grant"", MY_PACKAGE, mFirstUriBundle);
        mProvider.call(""grant"", MY_PACKAGE, mSecondUriBundle);
        assertHasUriPermission(mFirstUri, Intent.FLAG_GRANT_READ_URI_PERMISSION
                | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
        assertHasUriPermission(mSecondUri, Intent.FLAG_GRANT_READ_URI_PERMISSION
                | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);

        Intent work1 = new Intent(""work1"");
        work1.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION
                | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
        work1.setData(mFirstUri);
        work1.setClipData(mSecondClipData);

        Intent work2 = new Intent(""work2"");
        work2.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION
                | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
        work2.setData(mFirstUri);

        TestWorkItem[] work = new TestWorkItem[] {
                new TestWorkItem(work1, new Uri[] { mFirstUri, mSecondUri}, new Uri[0]),
                new TestWorkItem(work2, new Uri[] { mFirstUri }, new Uri[] { mSecondUri}) };
        kTestEnvironment.setExpectedExecutions(1);
        kTestEnvironment.setExpectedWork(work);
        JobInfo ji = mBuilder.setOverrideDeadline(0).setRequiresStorageNotLow(true).build();
        mJobScheduler.enqueue(ji, new JobWorkItem(work1));
        mJobScheduler.enqueue(ji, new JobWorkItem(work2));

        // Remove the explicit grant, we should still have a grant due to the job.
        mProvider.call(""revoke"", MY_PACKAGE, mFirstUriBundle);
        mProvider.call(""revoke"", MY_PACKAGE, mSecondUriBundle);
        assertHasUriPermission(mFirstUri, Intent.FLAG_GRANT_READ_URI_PERMISSION
                | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/JobSchedulerSharedUid/src/android/jobscheduler/cts/shareduidtests/EnqueueJobWorkTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.leanbackjank.cts.CtsDeviceLeanback"	"runTest"	"CtsLeanbackJankTestCases"	"1: permission"	"([1:/android/leanbackjank/cts/CtsDeviceLeanback.java]:[permission]:[1]:method_text:[erationCount = 2)    @GfxMonitor(processName = APP_PACKAGE)    @WindowContentFrameStatsMonitor   ]) :|: public void test/*
 * Copyright (C) 2015 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package android.leanbackjank.cts;

import android.content.ComponentName;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.leanbackjank.app.IntentKeys;
import android.os.SystemClock;
import android.support.test.uiautomator.By;
import android.support.test.uiautomator.Until;

import androidx.test.jank.GfxMonitor;
import androidx.test.jank.JankTest;
import androidx.test.jank.WindowContentFrameStatsMonitor;

public class CtsDeviceLeanback extends CtsJankTestBase {
    private static final String TAG = ""CtsDeviceLeanback"";
    private static final int MILLIS_PER_SECOND = 1000;
    private static final long WAIT_TIMEOUT = 5 * MILLIS_PER_SECOND;
    private static final int SCROLL_COUNT = 100;
    private static final int SCROLL_INTERVAL_MILLIS = 200;
    private static final int PRE_SCROLL_DELAY_MILLIS = 500;
    private static final int PRE_SCROLL_IDLE_TIME = 2 * MILLIS_PER_SECOND;
    private static final int SAMPLING_DURATION_SECONDS = 2;
    private static final int SAMPLING_DURATION_MILLIS =
            SAMPLING_DURATION_SECONDS * MILLIS_PER_SECOND;
    private final static String APP_PACKAGE = ""android.leanbackjank.app"";
    private final static String JAVA_PACKAGE = ""android.leanbackjank.app.ui"";
    private final static String CLASS = JAVA_PACKAGE + "".MainActivity"";

    private boolean shouldSkip() {
 PackageMan"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/leanbackjank/src/android/leanbackjank/cts/CtsDeviceLeanback.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.suspendapps.cts.DistractingPackageTest"	"isEmpty"	"CtsSuspendAppsTestCases"	"1: permission"	"([1:/android/suspendapps/cts/DistractingPackageTest.java]:[permission]:[1]:method_text:[           failed) + ""; expected to fail: "" + Arrays.toString(expectedToFail));        }    }   ]) :|: /*
 *.
 */

package android.suspendapps.cts;

import static android.content.Intent.EXTRA_PACKAGE_NAME;
import static android.content.pm.PackageManager.RESTRICTION_HIDE_FROM_SUGGESTIONS;
import static android.content.pm.PackageManager.RESTRICTION_HIDE_NOTIFICATIONS;
import static android.suspendapps.cts.Constants.ALL_TEST_PACKAGES;
import static android.suspendapps.cts.Constants.DEVICE_ADMIN_COMPONENT;
import static android.suspendapps.cts.Constants.TEST_APP_PACKAGE_NAME;
import static android.suspendapps.cts.Constants.TEST_PACKAGE_ARRAY;
import static android.suspendapps.cts.SuspendTestUtils.addAndAssertProfileOwner;
import static android.suspendapps.cts.SuspendTestUtils.createSingleKeyBundle;
import static android.suspendapps.cts.SuspendTestUtils.removeDeviceAdmin;
import static android.suspendapps.cts.SuspendTestUtils.requestDpmAction;

import static com.android.suspendapps.testdeviceadmin.TestCommsReceiver.ACTION_ADD_USER_RESTRICTION;
import static com.android.suspendapps.testdeviceadmin.TestCommsReceiver.ACTION_BLOCK_UNINSTALL;
import static com.android.suspendapps.testdeviceadmin.TestCommsReceiver.ACTION_UNBLOCK_UNINSTALL;
import static com.android.suspendapps.testdeviceadmin.TestCommsReceiver.EXTRA_USER_RESTRICTION;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import android.annotation.NonNull;
import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.pm.LauncherApps;
import android.content.pm.PackageManager;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.os.UserHandle;
import android.os.UserManager;

import androidx.test.InstrumentationRegistry;
import androidx.test.filters.SmallTest;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.FeatureUtil;
import com.android.compatib"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/suspendapps/tests/src/android/suspendapps/cts/DistractingPackageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.suspendapps.cts.SuspendPackagesTest"	"testTestAppsSuspendable"	"CtsSuspendAppsTestCases"	"1: permission"	"([1:/android/suspendapps/cts/SuspendPackagesTest.java]:[permission]:[1]:method_text:[: "" + Arrays.toString(unsuspendablePkgs),                unsuspendablePkgs.length == 0);    }   ]) :|: 
    public void testTestAppsSuspendable() throws Exception {
        final String[] unsuspendablePkgs = SystemUtil.callWithShellPermissionIdentity(() ->
                mPackageManager.getUnsuspendablePackages(ALL_TEST_PACKAGES));
        assertTrue(""Normal test apps unsuspendable: "" + Arrays.toString(unsuspendablePkgs),
                unsuspendablePkgs.length == 0);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/suspendapps/tests/src/android/suspendapps/cts/SuspendPackagesTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.suspendapps.cts.SuspendPackagesTest"	"testDeviceAdminUnsuspendable"	"CtsSuspendAppsTestCases"	"1: permission"	"([2:/android/suspendapps/cts/SuspendPackagesTest.java]:[permission]:[2]:method_text:[pToName(op) + "" allowed while package is suspended"",                MODE_ALLOWED, mode);    }   ]) :|: 
    public void testDeviceAdminUnsuspendable() throws Exception {
        assumeTrue(FeatureUtil.hasSystemFeature(PackageManager.FEATURE_DEVICE_ADMIN));
        addAndAssertDeviceAdmin();
        final String[] unsuspendablePkgs = SystemUtil.callWithShellPermissionIdentity(() ->
                mPackageManager.getUnsuspendablePackages(new String[]{DEVICE_ADMIN_PACKAGE}));
        assertTrue(""Device admin suspendable"", (unsuspendablePkgs.length == 1)
                && DEVICE_ADMIN_PACKAGE.equals(unsuspendablePkgs[0]));
    }

    private void assertOpDisallowed(int op) throws Exception {
        final int testUid = mPackageManager.getPackageUid(TEST_APP_PACKAGE_NAME, 0);
        final int mode = SystemUtil.callWithShellPermissionIdentity(
                () -> mAppOpsManager.checkOpNoThrow(op, testUid, TEST_APP_PACKAGE_NAME));
        assertNotEquals(""Op "" + AppOpsManager.opToName(op) + "" allowed while package is suspended"",
                MODE_ALLOWED, mode);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/suspendapps/tests/src/android/suspendapps/cts/SuspendPackagesTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.suspendapps.cts.SuspendPackagesTest"	"testOpRecordAudioOnSuspend"	"CtsSuspendAppsTestCases"	"1: permission"	"([2:/android/suspendapps/cts/SuspendPackagesTest.java]:[permission]:[2]:method_text:[   SuspendTestUtils.suspend(null, null, null);        assertOpDisallowed(recordAudioOp);    }   ]) :|: 
    public void testOpRecordAudioOnSuspend() throws Exception {
        final int recordAudioOp = AppOpsManager.permissionToOpCode(
                Manifest.permission.RECORD_AUDIO);
        SuspendTestUtils.suspend(null, null, null);
        assertOpDisallowed(recordAudioOp);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/suspendapps/tests/src/android/suspendapps/cts/SuspendPackagesTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.suspendapps.cts.SuspendPackagesTest"	"testOpCameraOnSuspend"	"CtsSuspendAppsTestCases"	"1: permission"	"([2:/android/suspendapps/cts/SuspendPackagesTest.java]:[permission]:[2]:method_text:[lable(String[] packageNames, UserHandle user,                boolean replacing) {        }    }}]) :|: 
    public void testOpCameraOnSuspend() throws Exception {
        final int cameraOp = AppOpsManager.permissionToOpCode(Manifest.permission.CAMERA);
        SuspendTestUtils.suspend(null, null, null);
        assertOpDisallowed(cameraOp);
    }

    @After
    public void tearDown() throws Exception {
        if (mTestAppInterface != null) {
            mTestAppInterface.disconnect();
        }
        removeDeviceAdmin();
        SuspendTestUtils.unsuspendAll();
    }

    private abstract static class StubbedCallback extends LauncherApps.Callback {
        @Override
        public void onPackageRemoved(String packageName, UserHandle user) {
        }

        @Override
        public void onPackageAdded(String packageName, UserHandle user) {
        }

        @Override
        public void onPackageChanged(String packageName, UserHandle user) {
        }

        @Override
        public void onPackagesAvailable(String[] packageNames, UserHandle user, boolean replacing) {
        }

        @Override
        public void onPackagesUnavailable(String[] packageNames, UserHandle user,
                boolean replacing) {
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/suspendapps/tests/src/android/suspendapps/cts/SuspendPackagesTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.mediaprovidertranscode.cts.TranscodeTest"	"disableTranscodingForAllPackages"	""	"1: permission"	"([6:/android/mediaprovidertranscode/cts/TranscodeTest.java]:[permission]:[6]:method_text:[   * Tests that we return FD of transcoded file for legacy apps     * @throws Exception     */   ]) :|: /*
 *.
 */

package android.mediaprovidertranscode.cts;

import static androidx.test.InstrumentationRegistry.getContext;

import static android.mediaprovidertranscode.cts.TranscodeTestUtils.assertFileContent;
import static android.mediaprovidertranscode.cts.TranscodeTestUtils.assertTranscode;
import static android.mediaprovidertranscode.cts.TranscodeTestUtils.executeShellCommand;
import static android.mediaprovidertranscode.cts.TranscodeTestUtils.installAppWithStoragePermissions;
import static android.mediaprovidertranscode.cts.TranscodeTestUtils.isAppIoBlocked;
import static android.mediaprovidertranscode.cts.TranscodeTestUtils.open;
import static android.mediaprovidertranscode.cts.TranscodeTestUtils.openFileAs;
import static android.mediaprovidertranscode.cts.TranscodeTestUtils.uninstallApp;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertThrows;
import static org.junit.Assert.assertTrue;

import android.Manifest;
import android.content.pm.PackageManager;
import android.media.ApplicationMediaCapabilities;
import android.media.MediaFormat;
import android.net.Uri;
import android.os.Bundle;
import android.os.Environment;
import android.os.ParcelFileDescriptor;
import android.os.Process;
import android.os.SystemProperties;
import android.os.storage.StorageManager;
import android.os.storage.StorageVolume;
import android.os.UserHandle;
import android.provider.MediaStore;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.android.cts.install.lib.TestApp;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.Random;
import java.util.UUID;

import org.junit.After;
import org.junit.Assume;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(AndroidJUnit4.cla"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/MediaProviderTranscode/src/android/mediaprovidertranscode/cts/TranscodeTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.mediaprovidertranscode.cts.TranscodeTest"	"testMediaCapabilitiesManifestHevc"	""	"1: permission"	"([1:/android/mediaprovidertranscode/cts/TranscodeTest.java]:[permission]:[1]:method_text:[    }            modernFile.delete();            uninstallApp(TEST_APP_HEVC);        }    }   ]) :|: 
    public void testMediaCapabilitiesManifestHevc()
            throws Exception {
        File modernFile = new File(DIR_CAMERA, HEVC_FILE_NAME);
        ParcelFileDescriptor pfdOriginal2 = null;
        try {
            installAppWithStoragePermissions(TEST_APP_HEVC);

            Uri uri = TranscodeTestUtils.stageHEVCVideoFile(modernFile);

            ParcelFileDescriptor pfdOriginal1 = open(modernFile, false);

            TranscodeTestUtils.enableTranscodingForPackage(TEST_APP_HEVC.getPackageName());

            pfdOriginal2 = openFileAs(TEST_APP_HEVC, modernFile);

            assertFileContent(modernFile, modernFile, pfdOriginal1, pfdOriginal2, true);
        } finally {
            // Explicitly close PFD otherwise instrumention might crash when test_app is uninstalled
            if (pfdOriginal2 != null) {
                pfdOriginal2.close();
            }
            modernFile.delete();
            uninstallApp(TEST_APP_HEVC);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/MediaProviderTranscode/src/android/mediaprovidertranscode/cts/TranscodeTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.mediaprovidertranscode.cts.TranscodeTest"	"testMediaCapabilitiesManifestSlowMotion"	""	"1: permission"	"([1:/android/mediaprovidertranscode/cts/TranscodeTest.java]:[permission]:[1]:method_text:[    }            modernFile.delete();            uninstallApp(TEST_APP_HEVC);        }    }   ]) :|: 
    public void testMediaCapabilitiesManifestSlowMotion()
            throws Exception {
        File modernFile = new File(DIR_CAMERA, HEVC_FILE_NAME);
        ParcelFileDescriptor pfdOriginal2 = null;
        try {
            installAppWithStoragePermissions(TEST_APP_SLOW_MOTION);

            Uri uri = TranscodeTestUtils.stageHEVCVideoFile(modernFile);

            ParcelFileDescriptor pfdOriginal1 = open(modernFile, false);

            TranscodeTestUtils.enableTranscodingForPackage(TEST_APP_SLOW_MOTION.getPackageName());

            pfdOriginal2 = openFileAs(TEST_APP_SLOW_MOTION, modernFile);

            assertFileContent(modernFile, modernFile, pfdOriginal1, pfdOriginal2, false);
        } finally {
            // Explicitly close PFD otherwise instrumention might crash when test_app is uninstalled
            if (pfdOriginal2 != null) {
                pfdOriginal2.close();
            }
            modernFile.delete();
            uninstallApp(TEST_APP_HEVC);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/MediaProviderTranscode/src/android/mediaprovidertranscode/cts/TranscodeTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.mediaprovidertranscode.cts.TranscodeTest"	"testAppCompatNoTranscodeHevc"	""	"1: permission"	"([1:/android/mediaprovidertranscode/cts/TranscodeTest.java]:[permission]:[1]:method_text:[TestUtils.resetAppCompat(packageName);            uninstallApp(TEST_APP_HEVC);        }    }   ]) :|: 
    public void testAppCompatNoTranscodeHevc() throws Exception {
        File modernFile = new File(DIR_CAMERA, HEVC_FILE_NAME);
        String packageName = TEST_APP_SLOW_MOTION.getPackageName();
        ParcelFileDescriptor pfdOriginal2 = null;
        try {
            installAppWithStoragePermissions(TEST_APP_SLOW_MOTION);

            Uri uri = TranscodeTestUtils.stageHEVCVideoFile(modernFile);

            ParcelFileDescriptor pfdOriginal1 = open(modernFile, false);

            TranscodeTestUtils.enableTranscodingForPackage(packageName);
            // App compat takes precedence
            TranscodeTestUtils.forceEnableAppCompatHevc(packageName);

            Thread.sleep(2000);

            pfdOriginal2 = openFileAs(TEST_APP_SLOW_MOTION, modernFile);

            assertFileContent(modernFile, modernFile, pfdOriginal1, pfdOriginal2, true);
        } finally {
            // Explicitly close PFD otherwise instrumention might crash when test_app is uninstalled
            if (pfdOriginal2 != null) {
                pfdOriginal2.close();
            }
            modernFile.delete();
            TranscodeTestUtils.resetAppCompat(packageName);
            uninstallApp(TEST_APP_HEVC);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/MediaProviderTranscode/src/android/mediaprovidertranscode/cts/TranscodeTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.mediaprovidertranscode.cts.TranscodeTest"	"testAppCompatTranscodeHevc"	""	"1: permission"	"([1:/android/mediaprovidertranscode/cts/TranscodeTest.java]:[permission]:[1]:method_text:[es read before and after enabling transcoding for the test app.     * @throws Exception     */   ]) :|: 
    public void testAppCompatTranscodeHevc() throws Exception {
        File modernFile = new File(DIR_CAMERA, HEVC_FILE_NAME);
        String packageName = TEST_APP_SLOW_MOTION.getPackageName();
        ParcelFileDescriptor pfdOriginal2 = null;
        try {
            installAppWithStoragePermissions(TEST_APP_SLOW_MOTION);

            Uri uri = TranscodeTestUtils.stageHEVCVideoFile(modernFile);

            ParcelFileDescriptor pfdOriginal1 = open(modernFile, false);

            // Transcoding is disabled but app compat enables it (disables hevc support)
            TranscodeTestUtils.forceDisableAppCompatHevc(packageName);

            pfdOriginal2 = openFileAs(TEST_APP_SLOW_MOTION, modernFile);

            assertFileContent(modernFile, modernFile, pfdOriginal1, pfdOriginal2, false);
        } finally {
            // Explicitly close PFD otherwise instrumention might crash when test_app is uninstalled
            if (pfdOriginal2 != null) {
                pfdOriginal2.close();
            }
            modernFile.delete();
            TranscodeTestUtils.resetAppCompat(packageName);
            uninstallApp(TEST_APP_HEVC);
        }
    }

    /**
     * Tests that we never initiate tanscoding for legacy formats.
     * This test compares the bytes read before and after enabling transcoding for the test app.
     * @throws Exception
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/MediaProviderTranscode/src/android/mediaprovidertranscode/cts/TranscodeTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.mediaprovidertranscode.cts.TranscodeTest"	"testOriginalCallingUid_modernAppPassLegacyAppUid"	""	"1: permission"	"([1:/android/mediaprovidertranscode/cts/TranscodeTest.java]:[permission]:[1]:method_text:[app passes the mediaCapabilitiesUid     * of a modern app that can handle an HEVC file.     */   ]) :|: 
    public void testOriginalCallingUid_modernAppPassLegacyAppUid()
            throws Exception {
        File modernFile = new File(DIR_CAMERA, HEVC_FILE_NAME);
        ParcelFileDescriptor pfdModernApp = null;
        ParcelFileDescriptor pfdModernAppPassingLegacyUid = null;
        try {
            installAppWithStoragePermissions(TEST_APP_SLOW_MOTION);
            Uri uri = TranscodeTestUtils.stageHEVCVideoFile(modernFile);

            // pfdModernApp is for original content (without transcoding) since this is a modern
            // app.
            pfdModernApp = open(modernFile, false);

            // pfdModernAppPassingLegacyUid is for transcoded content since this modern app is
            // passing the UID of a legacy app capable of handling HEVC files.
            Bundle bundle = new Bundle();
            bundle.putInt(MediaStore.EXTRA_MEDIA_CAPABILITIES_UID,
                    getContext().getPackageManager().getPackageUid(
                            TEST_APP_SLOW_MOTION.getPackageName(), 0));
            pfdModernAppPassingLegacyUid = open(uri, false, bundle);

            assertTranscode(pfdModernApp, false);
            assertTranscode(pfdModernAppPassingLegacyUid, true);

            // pfdModernApp and pfdModernAppPassingLegacyUid should be different.
            assertFileContent(modernFile, modernFile, pfdModernApp, pfdModernAppPassingLegacyUid,
                    false);
        } finally {
            if (pfdModernApp != null) {
                pfdModernApp.close();
            }

            if (pfdModernAppPassingLegacyUid != null) {
                pfdModernAppPassingLegacyUid.close();
            }
            modernFile.delete();
            uninstallApp(TEST_APP_SLOW_MOTION);
        }
    }

    /**
     * Tests that we don't transcode an HEVC file when a legacy app passes the mediaCapabilitiesUid
     * of a modern app that can handle an HEVC file.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/MediaProviderTranscode/src/android/mediaprovidertranscode/cts/TranscodeTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.mediaprovidertranscode.cts.TranscodeTest"	"testOriginalCallingUid_legacyAppPassModernAppUid"	""	"1: permission"	"([1:/android/mediaprovidertranscode/cts/TranscodeTest.java]:[permission]:[1]:method_text:[     * {@link MediaStore#getOriginalMediaFormatFileDescriptor}.     * @throws Exception     */   ]) :|: 
    public void testOriginalCallingUid_legacyAppPassModernAppUid()
            throws Exception {
        File modernFile = new File(DIR_CAMERA, HEVC_FILE_NAME);
        ParcelFileDescriptor pfdLegacyApp = null;
        ParcelFileDescriptor pfdLegacyAppPassingModernUid = null;
        try {
            installAppWithStoragePermissions(TEST_APP_HEVC);
            Uri uri = TranscodeTestUtils.stageHEVCVideoFile(modernFile);

            // pfdLegacyApp is for transcoded content since this is a legacy app.
            TranscodeTestUtils.enableTranscodingForPackage(getContext().getPackageName());
            pfdLegacyApp = open(modernFile, false);

            // pfdLegacyAppPassingModernUid is for original content (without transcoding) since this
            // legacy app is passing the UID of a modern app capable of handling HEVC files.
            Bundle bundle = new Bundle();
            bundle.putInt(MediaStore.EXTRA_MEDIA_CAPABILITIES_UID,
                    getContext().getPackageManager().getPackageUid(TEST_APP_HEVC.getPackageName(),
                            0));
            pfdLegacyAppPassingModernUid = open(uri, false, bundle);

            assertTranscode(pfdLegacyApp, true);
            assertTranscode(pfdLegacyAppPassingModernUid, false);

            // pfdLegacyApp and pfdLegacyAppPassingModernUid should be different.
            assertFileContent(modernFile, modernFile, pfdLegacyApp, pfdLegacyAppPassingModernUid,
                    false);
        } finally {
            if (pfdLegacyApp != null) {
                pfdLegacyApp.close();
            }

            if (pfdLegacyAppPassingModernUid != null) {
                pfdLegacyAppPassingModernUid.close();
            }
            modernFile.delete();
            uninstallApp(TEST_APP_HEVC);
        }
    }

    /**
     * Tests that we return FD of original file from
     * {@link MediaStore#getOriginalMediaFormatFileDescriptor}.
     * @throws Exception
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/MediaProviderTranscode/src/android/mediaprovidertranscode/cts/TranscodeTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.alarmmanager.cts.BasicApiTests"	"testSetExactWithWorkSource"	"CtsAlarmManagerTestCases"	"1: permission"	"([1:/android/alarmmanager/cts/BasicApiTests.java]:[permission]:[1]:method_text:[ver::isAlarmed,                ""Exact alarm with work source did not fire as expected"");    }   ]) :|: 
    public void testSetExactWithWorkSource() throws Exception {
        final int myUid = mContext.getPackageManager().getPackageUid(mContext.getOpPackageName(),
                0);
        final long futurityMs = 1000;
        mMockAlarmReceiver.reset();

        SystemUtil.runWithShellPermissionIdentity(
                () -> mAm.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP,
                        SystemClock.elapsedRealtime() + futurityMs, ""test-tag"", r -> r.run(),
                        new WorkSource(myUid), mMockAlarmReceiver));

        Thread.sleep(futurityMs);
        PollingCheck.waitFor(2000, mMockAlarmReceiver::isAlarmed,
                ""Exact alarm with work source did not fire as expected"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/AlarmManager/src/android/alarmmanager/cts/BasicApiTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.alarmmanager.cts.BasicApiTests"	"testSetPrioritizedWithoutPermission"	"CtsAlarmManagerTestCases"	"1: permission"	"([2:/android/alarmmanager/cts/BasicApiTests.java]:[permission]:[2]:method_text:[                ""testSetPrioritizedWithoutPermission"", r -> r.run(), mMockAlarmReceiver);    }   ]) :|: (expected = SecurityException.class)
    public void testSetPrioritizedWithoutPermission() {
        mAm.setPrioritized(AlarmManager.ELAPSED_REALTIME_WAKEUP, 20, 10,
                ""testSetPrioritizedWithoutPermission"", r -> r.run(), mMockAlarmReceiver);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/AlarmManager/src/android/alarmmanager/cts/BasicApiTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.alarmmanager.cts.BasicApiTests"	"testSetPrioritized"	"CtsAlarmManagerTestCases"	"1: permission"	"([4:/android/alarmmanager/cts/BasicApiTests.java]:[permission]:[4]:method_text:[               (secondAlarmTime - firstAlarmTime) > (PRIORITY_ALARM_DELAY - FAIL_DELTA));    }   ]) :|: 
    @Ignore(""Fails on cuttlefish"")  // TODO (b/182835530): Investigate and fix.
    public void testSetPrioritized() throws InterruptedException {
        mMockAlarmReceiver.reset();
        mMockAlarmReceiver2.reset();

        final long trigger1 = SystemClock.elapsedRealtime() + 1000;
        final long trigger2 = SystemClock.elapsedRealtime() + 2000;
        SystemUtil.runWithShellPermissionIdentity(
                () -> mAm.setPrioritized(AlarmManager.ELAPSED_REALTIME_WAKEUP, trigger1, 10,
                        ""test-1"", r -> r.run(), mMockAlarmReceiver));
        SystemUtil.runWithShellPermissionIdentity(
                () -> mAm.setPrioritized(AlarmManager.ELAPSED_REALTIME_WAKEUP, trigger2, 10,
                        ""test-2"", r -> r.run(), mMockAlarmReceiver2));

        Thread.sleep(2010);
        PollingCheck.waitFor(1000,
                () -> (mMockAlarmReceiver.isAlarmed() && mMockAlarmReceiver2.isAlarmed()));

        toggleIdleMode(true);
        // Ensure no previous alarm in doze throttles the next one.
        Thread.sleep(PRIORITY_ALARM_DELAY);
        mMockAlarmReceiver.reset();
        mMockAlarmReceiver2.reset();

        final long trigger3 = SystemClock.elapsedRealtime() + 1000;
        final long trigger4 = SystemClock.elapsedRealtime() + 2000;
        SystemUtil.runWithShellPermissionIdentity(
                () -> mAm.setPrioritized(AlarmManager.ELAPSED_REALTIME_WAKEUP, trigger3, 10,
                        ""test-3"", r -> r.run(), mMockAlarmReceiver));
        SystemUtil.runWithShellPermissionIdentity(
                () -> mAm.setPrioritized(AlarmManager.ELAPSED_REALTIME_WAKEUP, trigger4, 10,
                        ""test-4"", r -> r.run(), mMockAlarmReceiver2));
        Thread.sleep(1010);
        PollingCheck.waitFor(1000, mMockAlarmReceiver::isAlarmed,
                ""First alarm not received as expected in doze"");

        Thread.sleep(1000);
        assertFalse(""Second alarm fired prematurely while in doze"",
                mMo"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/AlarmManager/src/android/alarmmanager/cts/BasicApiTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.quickaccesswallet.cts.QuickAccessWalletClientTest"	"testGetWalletCards_failsIfServiceDoesNotRequirePermission"	"CtsQuickAccessWalletTestCases"	"1: permission"	"([2:/android/quickaccesswallet/cts/QuickAccessWalletClientTest.java]:[permission]:[2]:method_text:[assertThat(callback.mResponse).isNull();        assertThat(callback.mError).isNotNull();    }   ]) :|: 
    public void testGetWalletCards_failsIfServiceDoesNotRequirePermission() throws Exception {
        setServiceState(NoPermissionQuickAccessWalletService.class,
                PackageManager.COMPONENT_ENABLED_STATE_ENABLED);
        setServiceState(TestQuickAccessWalletService.class,
                PackageManager.COMPONENT_ENABLED_STATE_DISABLED);
        QuickAccessWalletClient client = QuickAccessWalletClient.create(mContext);
        assertThat(client.isWalletServiceAvailable()).isFalse();
        TestCallback callback = new TestCallback();

        client.getWalletCards(GET_WALLET_CARDS_REQUEST, callback);

        callback.await(3, TimeUnit.SECONDS);
        assertThat(callback.mResponse).isNull();
        assertThat(callback.mError).isNotNull();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/quickaccesswallet/src/android/quickaccesswallet/cts/QuickAccessWalletClientTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.runner.CtsTestRunListener"	"disableKeyguard"	""	"1: permission"	"([5:/com/android/cts/runner/CtsTestRunListener.java]:[permission]:[5]:method_text:[                    ""UI based tests may fail if keyguard is up"");        }    }    @Override   ]) :|: public void testRunStarted(Description description) throws Exception {
        mEnvironment = new TestEnvironment(getInstrumentation().getTargetContext());

        // We might want to move this to /sdcard, if is is mounted/writable.
        File cacheDir = getInstrumentation().getTargetContext().getCacheDir();
        System.setProperty(""java.io.tmpdir"", cacheDir.getAbsolutePath());

        // attempt to disable keyguard, if current test has permission to do so
        // TODO: move this to a better place, such as InstrumentationTestRunner
        // ?
        if (getInstrumentation().getContext().checkCallingOrSelfPermission(
                android.Manifest.permission.DISABLE_KEYGUARD)
                == PackageManager.PERMISSION_GRANTED) {
            Log.i(TAG, ""Disabling keyguard"");
            KeyguardManager keyguardManager =
                    (KeyguardManager) getInstrumentation().getContext().getSystemService(
                            Context.KEYGUARD_SERVICE);
            keyguardManager.newKeyguardLock(""cts"").disableKeyguard();
        } else {
            Log.i(TAG, ""Test lacks permission to disable keyguard. "" +
                    ""UI based tests may fail if keyguard is up"");
        }
    }

    @Override"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/core/runner-axt/src/com/android/cts/runner/CtsTestRunListener.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.view.inputmethod.cts.InputContentInfoTest"	"testRequestAndReleasePermission"	"CtsInputMethodTestCases"	"1: permission"	"([6:/android/view/inputmethod/cts/InputContentInfoTest.java]:[permission]:[6]:method_text:[fo.releasePermission();        info.requestPermission();        info.releasePermission();    }}]) :|: 
    public void testRequestAndReleasePermission() {
        InputContentInfo info = new InputContentInfo(
                Uri.parse(""content://com.example/path""),
                new ClipDescription(""sample content"", new String[]{""image/png""}),
                Uri.parse(""https://example.com""));

        // Here we only assert that {request, release}Permission() do not crash, because ensuring
        // the entire functionality of these methods requires end-to-end IME test environment, which
        // we do not have yet in CTS.
        // Note it is actually intentional that calling these methods here has no effect.  Those
        // methods would have effect only after the object is passed from the IME process to the
        // application process.
        // TODO: Create an end-to-end CTS test for this functionality.
        info.requestPermission();
        info.releasePermission();
        info.requestPermission();
        info.releasePermission();
    }

}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/InputContentInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.view.inputmethod.cts.FocusHandlingTest"	"testSetShowInputOnFocus"	"CtsInputMethodTestCases"	"1: permission"	"([1:/android/view/inputmethod/cts/FocusHandlingTest.java]:[permission]:[1]:method_text:[ }    @AppModeFull(reason = ""Instant apps cannot hold android.permission.SYSTEM_ALERT_WINDOW"")   ]) :|: 
    public void testSetShowInputOnFocus() throws Exception {
        try (MockImeSession imeSession = MockImeSession.create(
                InstrumentationRegistry.getInstrumentation().getContext(),
                InstrumentationRegistry.getInstrumentation().getUiAutomation(),
                new ImeSettings.Builder())) {
            final ImeEventStream stream = imeSession.openEventStream();

            final String marker = getTestMarker();
            final EditText editText = launchTestActivity(marker);
            runOnMainSync(() -> editText.setShowSoftInputOnFocus(false));

            // Wait until ""onStartInput"" gets called for the EditText.
            expectEvent(stream, editorMatcher(""onStartInput"", marker), TIMEOUT);

            // Emulate tap event
            CtsTouchUtils.emulateTapOnViewCenter(
                    InstrumentationRegistry.getInstrumentation(), null, editText);

            // ""showSoftInput"" must not happen when setShowSoftInputOnFocus(false) is called.
            notExpectEvent(stream, event -> ""showSoftInput"".equals(event.getEventName()),
                    NOT_EXPECT_TIMEOUT);
        }
    }

    @AppModeFull(reason = ""Instant apps cannot hold android.permission.SYSTEM_ALERT_WINDOW"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/FocusHandlingTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.view.inputmethod.cts.FocusHandlingTest"	"testKeyboardStateAfterImeFocusableFlagChanged"	"CtsInputMethodTestCases"	"1: permission"	"([1:/android/view/inputmethod/cts/FocusHandlingTest.java]:[permission]:[1]:method_text:[ }    @AppModeFull(reason = ""Instant apps cannot hold android.permission.SYSTEM_ALERT_WINDOW"")   ]) :|: 
    public void testKeyboardStateAfterImeFocusableFlagChanged() throws Exception {
        final Instrumentation instrumentation = InstrumentationRegistry.getInstrumentation();
        try (MockImeSession imeSession = MockImeSession.create(
                     instrumentation.getContext(), instrumentation.getUiAutomation(),
                     new ImeSettings.Builder())) {
            final ImeEventStream stream = imeSession.openEventStream();
            final AtomicReference<EditText> editTextRef = new AtomicReference<>();
            final String marker = getTestMarker();
            final TestActivity testActivity = TestActivity.startSync(activity-> {
                // Initially set activity window to not IME focusable.
                activity.getWindow().addFlags(FLAG_ALT_FOCUSABLE_IM);

                final LinearLayout layout = new LinearLayout(activity);
                layout.setOrientation(LinearLayout.VERTICAL);

                final EditText editText = new EditText(activity);
                editText.setPrivateImeOptions(marker);
                editText.setHint(""editText"");
                editTextRef.set(editText);
                editText.requestFocus();

                layout.addView(editText);
                return layout;
            });

            // Emulate tap event, expect there is no ""onStartInput"", and ""showSoftInput"" happened.
            final EditText editText = editTextRef.get();
            CtsTouchUtils.emulateTapOnViewCenter(instrumentation, null, editText);
            notExpectEvent(stream, editorMatcher(""onStartInput"", marker), NOT_EXPECT_TIMEOUT);
            notExpectEvent(stream, event -> ""showSoftInput"".equals(event.getEventName()),
                    NOT_EXPECT_TIMEOUT);

            // Set testActivity window to be IME focusable.
            testActivity.getWindow().getDecorView().post(() -> {
                final WindowManager.LayoutParams params = testActivity.getWindow().getAttributes();
                testAct"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/FocusHandlingTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.view.inputmethod.cts.InputConnectionBlockingMethodTest"	"testCommitContent"	"CtsInputMethodTestCases"	"1: permission"	"([1:/android/view/inputmethod/cts/InputConnectionBlockingMethodTest.java]:[permission]:[1]:method_text:[)} fails after a     * system-defined time-out even if the target app does not respond.     */   ]) :|: 
    public void testCommitContent() throws Exception {
        final InputContentInfo expectedInputContentInfo = new InputContentInfo(
                Uri.parse(""content://com.example/path""),
                new ClipDescription(""sample content"", new String[]{""image/png""}),
                Uri.parse(""https://example.com""));
        final Bundle expectedOpt = new Bundle();
        final String expectedOptKey = ""testKey"";
        final int expectedOptValue = 42;
        expectedOpt.putInt(expectedOptKey, expectedOptValue);
        final int expectedFlags = InputConnection.INPUT_CONTENT_GRANT_READ_URI_PERMISSION;
        final boolean expectedResult = true;

        final class Wrapper extends InputConnectionWrapper {
            private Wrapper(InputConnection target) {
                super(target, false);
            }

            @Override
            public boolean commitContent(InputContentInfo inputContentInfo, int flags,
                    Bundle opts) {
                assertEquals(expectedInputContentInfo.getContentUri(),
                        inputContentInfo.getContentUri());
                assertEquals(expectedFlags, flags);
                assertEquals(expectedOpt.getInt(expectedOptKey), opts.getInt(expectedOptKey));
                return expectedResult;
            }
        }

        testInputConnection(Wrapper::new, (MockImeSession session, ImeEventStream stream) -> {
            final ImeCommand command =
                    session.callCommitContent(expectedInputContentInfo, expectedFlags, expectedOpt);
            assertTrue(expectCommand(stream, command, TIMEOUT).getReturnBooleanValue());
        });
    }

    /**
     * Test {@link InputConnection#commitContent(InputContentInfo, int, Bundle)} fails after a
     * system-defined time-out even if the target app does not respond.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/InputConnectionBlockingMethodTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.view.inputmethod.cts.KeyboardVisibilityControlTest"	"getTestMarker"	"CtsInputMethodTestCases"	"1: permission"	"([1:/android/view/inputmethod/cts/KeyboardVisibilityControlTest.java]:[permission]:[1]:method_text:[onNull String marker) {        return launchTestActivity(marker, getTestMarker()).first;    }   ]) :|: /*
 *.
 */

package android.view.inputmethod.cts;

import static android.content.Intent.FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS;
import static android.inputmethodservice.InputMethodService.FINISH_INPUT_NO_FALLBACK_CONNECTION;
import static android.view.View.VISIBLE;
import static android.view.WindowInsets.Type.ime;
import static android.view.WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS;
import static android.view.WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN;
import static android.view.WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE;
import static android.view.WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN;
import static android.view.WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED;
import static android.view.WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE;
import static android.view.inputmethod.cts.util.InputMethodVisibilityVerifier.expectImeInvisible;
import static android.view.inputmethod.cts.util.InputMethodVisibilityVerifier.expectImeVisible;
import static android.view.inputmethod.cts.util.TestUtils.getOnMainSync;
import static android.view.inputmethod.cts.util.TestUtils.runOnMainSync;

import static com.android.compatibility.common.util.SystemUtil.runShellCommand;
import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;
import static com.android.cts.mockime.ImeEventStreamTestUtils.expectEvent;
import static com.android.cts.mockime.ImeEventStreamTestUtils.expectEventWithKeyValue;
import static com.android.cts.mockime.ImeEventStreamTestUtils.notExpectEvent;
import static com.android.cts.mockime.ImeEventStreamTestUtils.waitForInputViewLayoutStable;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assume.assumeTrue;

import android.app.AlertDialog;
import android.app.Instrumentation;
import android.content.ComponentName;
impor"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/KeyboardVisibilityControlTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.view.inputmethod.cts.KeyboardVisibilityControlTest"	"testRestoreImeVisibility_noRestoreForHiddenWithForwardNav"	"CtsInputMethodTestCases"	"1: permission"	"([2:/android/view/inputmethod/cts/KeyboardVisibilityControlTest.java]:[permission]:[2]:method_text:[nsure it.        builder.setNavigationBarColor(navigationBarColor);        return builder;    }}]) :|: 
    public void testRestoreImeVisibility_noRestoreForHiddenWithForwardNav() throws Exception {
        runRestoreImeVisibility(TestSoftInputMode.HIDDEN_WITH_FORWARD_NAV, false);
    }

    private enum TestSoftInputMode {
        UNCHANGED_WITH_BACKWARD_NAV,
        ALWAYS_HIDDEN_WITH_BACKWARD_NAV,
        HIDDEN_WITH_FORWARD_NAV
    }

    private void runRestoreImeVisibility(TestSoftInputMode mode, boolean expectImeVisible)
            throws Exception {
        final Instrumentation instrumentation = InstrumentationRegistry.getInstrumentation();
        final WindowManager wm = instrumentation.getContext().getSystemService(WindowManager.class);
        // As restoring IME visibility behavior is only available when TaskSnapshot mechanism
        // enabled, skip the test when TaskSnapshot is not supported.
        assumeTrue(""Restoring IME visibility not available when TaskSnapshot unsupported"",
                wm.isTaskSnapshotSupported());

        try (MockImeSession imeSession = MockImeSession.create(
                instrumentation.getContext(), instrumentation.getUiAutomation(),
                new ImeSettings.Builder())) {
            final ImeEventStream stream = imeSession.openEventStream();
            final String markerForActivity1 = getTestMarker();
            final AtomicReference<EditText> editTextRef = new AtomicReference<>();
            // Launch a test activity with focusing editText to show keyboard
            TestActivity.startSync(activity -> {
                final LinearLayout layout = new LinearLayout(activity);
                final EditText editText = new EditText(activity);
                editTextRef.set(editText);
                editText.setHint(""focused editText"");
                editText.setPrivateImeOptions(markerForActivity1);
                editText.requestFocus();
                layout.addView(editText);
                activity.getWindow().getDecorView().getWindowInsetsController().show(ime());
                if (mode ="	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/KeyboardVisibilityControlTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.view.inputmethod.cts.InputMethodInfoTest"	"testInputMethodSubtypeProperties"	"CtsInputMethodTestCases"	"1: permission"	"([2:/android/view/inputmethod/cts/InputMethodInfoTest.java]:[permission]:[2]:method_text:[quals(expectedId, info.getId());        assertEquals(mClassName, info.getServiceName());    }   ]) :|: 
    public void testInputMethodSubtypeProperties() {
        // TODO: Test InputMethodSubtype.getDisplayName()
        assertEquals(mSubtypeNameResId, mInputMethodSubtype.getNameResId());
        assertEquals(mSubtypeIconResId, mInputMethodSubtype.getIconResId());
        assertEquals(mSubtypeLocale, mInputMethodSubtype.getLocale());
        assertEquals(mSubtypeMode, mInputMethodSubtype.getMode());
        assertEquals(mSubtypeExtraValue, mInputMethodSubtype.getExtraValue());
        assertTrue(mInputMethodSubtype.containsExtraValueKey(mSubtypeExtraValueKey));
        assertEquals(mSubtypeExtraValueValue,
                mInputMethodSubtype.getExtraValueOf(mSubtypeExtraValueKey));
        assertEquals(mSubtypeIsAuxiliary, mInputMethodSubtype.isAuxiliary());
        assertEquals(mSubtypeOverridesImplicitlyEnabledSubtype,
                mInputMethodSubtype.overridesImplicitlyEnabledSubtype());
        assertEquals(mSubtypeId, mInputMethodSubtype.hashCode());
    }

    private void assertService(ServiceInfo expected, ServiceInfo actual) {
        assertEquals(expected.getIconResource(), actual.getIconResource());
        assertEquals(expected.labelRes, actual.labelRes);
        assertEquals(expected.nonLocalizedLabel, actual.nonLocalizedLabel);
        assertEquals(expected.icon, actual.icon);
        assertEquals(expected.permission, actual.permission);
    }

    private void assertInfo(InputMethodInfo info) {
        assertEquals(mPackageName, info.getPackageName());
        assertEquals(mSettingsActivity, info.getSettingsActivity());
        ComponentName component = info.getComponent();
        assertEquals(mClassName, component.getClassName());
        String expectedId = component.flattenToShortString();
        assertEquals(expectedId, info.getId());
        assertEquals(mClassName, info.getServiceName());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/InputMethodInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.translation.cts.UiTranslationManagerTest"	"testUiTranslation_customTextView"	"CtsTranslationTestCases"	"1: permission"	"([4:/android/translation/cts/UiTranslationManagerTest.java]:[permission]:[4]:method_text:[entResolver(),                            Settings.Secure.DEFAULT_INPUT_METHOD));        }    }}]) :|: 
    @FlakyTest(bugId = 192418800)
    public void testUiTranslation_customTextView() throws Throwable {
        // Enable CTS ContentCaptureService
        CtsContentCaptureService contentcaptureService = enableContentCaptureService();
        // Start Activity and get needed information
        final List<AutofillId> views = startCustomTextViewActivityAndGetViewsForTranslation();

        // Wait session created and get the ConttCaptureContext from ContentCaptureService
        final ContentCaptureContext contentCaptureContext =
                getContentCaptureContextFromContentCaptureService(contentcaptureService);

        // enable CTS TranslationService
        mTranslationServiceServiceWatcher = CtsTranslationService.setServiceWatcher();
        Helper.setTemporaryTranslationService(CtsTranslationService.SERVICE_NAME);

        final String translatedText = ""success"";
        // Set response
        final TranslationResponse expectedResponse =
                createViewsTranslationResponse(views, translatedText);
        sTranslationReplier.addResponse(expectedResponse);

        startUiTranslation(/* shouldPadContent */ false, views, contentCaptureContext);

        // Verify result.
        assertThat(mCustomTextView.isMyTagTranslationSupported()).isTrue();
        final UiObject2 customText = Helper.findObjectByResId(Helper.ACTIVITY_PACKAGE,
                CustomTextViewActivity.ID_CUSTOM_TEXT);
        assertThat(customText).isNotNull();
        assertThat(customText.getText()).isEqualTo(translatedText);

        finishUiTranslation(contentCaptureContext);

        assertThat(customText.getText()).isEqualTo(""Hello World 2"");
    }

    private void startUiTranslation(boolean shouldPadContent, List<AutofillId> views,
            ContentCaptureContext contentCaptureContext) {
        final UiTranslationManager manager = sContext.getSystemService(UiTranslationManager.class);
        runWithShellPermissionIdentity(() -> {
            // Call startTranslatio"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/translation/src/android/translation/cts/UiTranslationManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.hardware.multiprocess.camera.cts.CameraEvictionTest"	"testBasicCamera2ActivityEvictionOomScoreOffset"	"CtsCameraTestCases"	"1: permission"	"([3:/android/hardware/multiprocess/camera/cts/CameraEvictionTest.java]:[permission]:[3]:method_text:[es a security exception when     * trying to modify the oom score for camera framework.     */   ]) :|: public void testBasicCamera2ActivityEvictionOomScoreOffset() throws Throwable {
        testBasicCamera2ActivityEvictionInternal(/*lowerPriority*/ true);
    }
    /**
     * Test basic eviction scenarios for the Camera2 API.
     */
    private void testBasicCamera2ActivityEvictionInternal(boolean lowerPriority) throws Throwable {
        UiAutomation uiAutomation = null;
        if (lowerPriority && mUiAutomation != null) {
            mUiAutomation.adoptShellPermissionIdentity();
        }
        CameraManager manager = mContext.getSystemService(CameraManager.class);
        assertNotNull(manager);
        String[] cameraIds = manager.getCameraIdListNoLazy();

        if (cameraIds.length == 0) {
            Log.i(TAG, ""Skipping testBasicCamera2ActivityEviction, device has no cameras."");
            return;
        }

        assertTrue(mContext.getMainLooper() != null);

        // Setup camera manager
        String chosenCamera = cameraIds[0];
        Handler cameraHandler = new Handler(mContext.getMainLooper());
        final CameraManager.AvailabilityCallback mockAvailCb =
                mock(CameraManager.AvailabilityCallback.class);

        manager.registerAvailabilityCallback(mockAvailCb, cameraHandler);

        Thread.sleep(WAIT_TIME);

        verify(mockAvailCb, times(1)).onCameraAvailable(chosenCamera);
        verify(mockAvailCb, never()).onCameraUnavailable(chosenCamera);

        // Setup camera device
        final CameraDevice.StateCallback spyStateCb = spy(new StateCallbackImpl());
        manager.openCamera(chosenCamera, spyStateCb, cameraHandler);

        verify(spyStateCb, timeout(OPEN_TIMEOUT).times(1)).onOpened(any(CameraDevice.class));
        verify(spyStateCb, never()).onClosed(any(CameraDevice.class));
        verify(spyStateCb, never()).onDisconnected(any(CameraDevice.class));
        verify(spyStateCb, never()).onError(any(CameraDevice.class), anyInt());

        // Open camera from remote process
        startRemoteProcess(Camer"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/camera/src/android/hardware/multiprocess/camera/cts/CameraEvictionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.hardware.multiprocess.camera.cts.CameraEvictionTest"	"testCamera2OomScoreOffsetPermissions"	"CtsCameraTestCases"	"1: permission"	"([3:/android/hardware/multiprocess/camera/cts/CameraEvictionTest.java]:[permission]:[3]:method_text:[e            }        }    }    /**     * Test camera availability access callback.     */   ]) :|: public void testCamera2OomScoreOffsetPermissions() throws Throwable {
        CameraManager manager = mContext.getSystemService(CameraManager.class);
        assertNotNull(manager);
        String[] cameraIds = manager.getCameraIdListNoLazy();

        if (cameraIds.length == 0) {
            Log.i(TAG, ""Skipping testBasicCamera2OomScoreOffsetPermissions, no cameras present."");
            return;
        }

        assertTrue(mContext.getMainLooper() != null);
        for (String cameraId : cameraIds) {
            // Setup camera manager
            Handler cameraHandler = new Handler(mContext.getMainLooper());
            final CameraManager.AvailabilityCallback mockAvailCb =
                    mock(CameraManager.AvailabilityCallback.class);

            final CameraDevice.StateCallback spyStateCb = spy(new StateCallbackImpl());
            manager.registerAvailabilityCallback(mockAvailCb, cameraHandler);

            Thread.sleep(WAIT_TIME);

            verify(mockAvailCb, times(1)).onCameraAvailable(cameraId);
            verify(mockAvailCb, never()).onCameraUnavailable(cameraId);

            try {
                // Go to top again, try getting hold of camera with priority lowered, we should get
                // an exception
                Executor cameraExecutor = new HandlerExecutor(cameraHandler);
                manager.openCamera(cameraId, CACHED_APP_VS_FG_OOM_DELTA, cameraExecutor,
                        spyStateCb);
                fail(""Didn't receive security exception when trying to open camera with modifed"" +
                    ""oom score without SYSTEM_CAMERA permissions"");
            } catch(SecurityException e) {
                // fine
            }
        }
    }
    /**
     * Test camera availability access callback.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/camera/src/android/hardware/multiprocess/camera/cts/CameraEvictionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.hardware.multiprocess.camera.cts.CameraEvictionTest"	"testCamera2AccessCallback"	"CtsCameraTestCases"	"1: permission"	"([3:/android/hardware/multiprocess/camera/cts/CameraEvictionTest.java]:[permission]:[3]:method_text:[oritiesChanged();    }    /**     * Test native camera availability access callback.     */   ]) :|: public void testCamera2AccessCallback() throws Throwable {
        int PERMISSION_CALLBACK_TIMEOUT_MS = 2000;
        CameraManager manager = mContext.getSystemService(CameraManager.class);
        assertNotNull(manager);
        String[] cameraIds = manager.getCameraIdListNoLazy();

        if (cameraIds.length == 0) {
            Log.i(TAG, ""Skipping testCamera2AccessCallback, device has no cameras."");
            return;
        }

        assertTrue(mContext.getMainLooper() != null);

        // Setup camera manager
        Handler cameraHandler = new Handler(mContext.getMainLooper());

        final CameraManager.AvailabilityCallback mockAvailCb =
                mock(CameraManager.AvailabilityCallback.class);
        manager.registerAvailabilityCallback(mockAvailCb, cameraHandler);

        // Remove current task from top of stack. This will impact the camera access
        // pririorties.
        getActivity().moveTaskToBack(/*nonRoot*/true);

        verify(mockAvailCb, timeout(
                PERMISSION_CALLBACK_TIMEOUT_MS).atLeastOnce()).onCameraAccessPrioritiesChanged();

        forceCtsActivityToTop();

        verify(mockAvailCb, timeout(
                PERMISSION_CALLBACK_TIMEOUT_MS).atLeastOnce()).onCameraAccessPrioritiesChanged();
    }

    /**
     * Test native camera availability access callback.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/camera/src/android/hardware/multiprocess/camera/cts/CameraEvictionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.hardware.multiprocess.camera.cts.CameraEvictionTest"	"testCamera2NativeAccessCallback"	"CtsCameraTestCases"	"1: permission"	"([4:/android/hardware/multiprocess/camera/cts/CameraEvictionTest.java]:[permission]:[4]:method_text:[   }    }    /**     * Test basic eviction scenarios for camera used in MediaRecoder     */   ]) :|: public void testCamera2NativeAccessCallback() throws Throwable {
        int PERMISSION_CALLBACK_TIMEOUT_MS = 2000;
        CameraManager manager = mContext.getSystemService(CameraManager.class);
        assertNotNull(manager);
        String[] cameraIds = manager.getCameraIdListNoLazy();

        if (cameraIds.length == 0) {
            Log.i(TAG, ""Skipping testBasicCamera2AccessCallback, device has no cameras."");
            return;
        }

        // Setup camera manager
        long context = 0;
        try {
            context = initializeAvailabilityCallbacksNative();
            assertTrue(""Failed to initialize native availability callbacks"", (context != 0));

            // Remove current task from top of stack. This will impact the camera access
            // pririorties.
            getActivity().moveTaskToBack(/*nonRoot*/true);

            Thread.sleep(PERMISSION_CALLBACK_TIMEOUT_MS);
            assertTrue(""No camera permission access changed callback received"",
                    (getAccessCallbacksCountAndResetNative(context) > 0));

            forceCtsActivityToTop();

            assertTrue(""No camera permission access changed callback received"",
                    (getAccessCallbacksCountAndResetNative(context) > 0));
        } finally {
            if (context != 0) {
                releaseAvailabilityCallbacksNative(context);
            }
        }
    }

    /**
     * Test basic eviction scenarios for camera used in MediaRecoder
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/camera/src/android/hardware/multiprocess/camera/cts/CameraEvictionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.hardware.camera2.cts.CameraManagerTest"	"testCameraManagerListenerCallbacks"	"CtsCameraTestCases"	"1: permission"	"([5:/android/hardware/camera2/cts/CameraManagerTest.java]:[permission]:[5]:method_text:[    // Verify no LEGACY-level devices appear on devices first launched in the Q release or newer   ]) :|: 
    public void testCameraManagerListenerCallbacks() throws Exception {
        if (mOverrideCameraId != null) {
            // Testing is done for individual camera. Skip.
            return;
        }
        testCameraManagerListenerCallbacks(/*useExecutor*/ false);
        testCameraManagerListenerCallbacks(/*useExecutor*/ true);
    }

    private <T> void verifyAvailabilityCbsReceived(HashSet<T> expectedCameras,
            LinkedBlockingQueue<T> queue, LinkedBlockingQueue<T> otherQueue,
            boolean available) throws Exception {
        while (expectedCameras.size() > 0) {
            T id = queue.poll(AVAILABILITY_TIMEOUT_MS,
                    java.util.concurrent.TimeUnit.MILLISECONDS);
            assertTrue(""Did not receive initial "" + (available ? ""available"" : ""unavailable"")
                    + "" notices for some cameras"", id != null);
            expectedCameras.remove(id);
        }
        // Verify no unavailable/available cameras were reported
        assertTrue(""Some camera devices are initially "" + (available ? ""unavailable"" : ""available""),
                otherQueue.size() == 0);
    }

    private void verifySingleAvailabilityCbsReceived(LinkedBlockingQueue<String> expectedEventQueue,
            LinkedBlockingQueue<String> unExpectedEventQueue, String expectedId,
            String expectedStr, String unExpectedStr) throws Exception {
        String candidateId = expectedEventQueue.poll(AVAILABILITY_TIMEOUT_MS,
                java.util.concurrent.TimeUnit.MILLISECONDS);
        assertTrue(""Received "" + expectedStr + "" notice for wrong ID, "" +
                ""expected "" + expectedId + "", got "" + candidateId, expectedId.equals(candidateId));
        assertTrue(""Received >  1 "" + expectedStr + "" callback for id "" + expectedId,
                expectedEventQueue.size() == 0);
        assertTrue(unExpectedStr + "" events received unexpectedly"",
                unExpectedEventQueue.size() == 0);
    }

    private void testCameraManager"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/camera/src/android/hardware/camera2/cts/CameraManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.blob.BlobStoreManagerTest"	"testAcquireRelease_deleteAfterDelay"	"CtsBlobStoreTestCases"	"1: permission"	"([1:/com/android/cts/blob/BlobStoreManagerTest.java]:[permission]:[1]:method_text:[         Pair.create(KEY_DELETE_ON_LAST_LEASE_DELAY_MS, String.valueOf(waitDurationMs)));    }   ]) :|: 
    public void testAcquireRelease_deleteAfterDelay() throws Exception {
        final long waitDurationMs = TimeUnit.SECONDS.toMillis(1);
        runWithKeyValues(() -> {
            final FakeBlobData blobData = new FakeBlobData.Builder(mContext).build();
            blobData.prepare();
            try {
                commitBlob(blobData);

                acquireLease(mContext, blobData.getBlobHandle(), R.string.test_desc,
                        blobData.getExpiryTimeMillis());
                assertLeasedBlobs(mBlobStoreManager, blobData.getBlobHandle());

                SystemClock.sleep(waitDurationMs);

                releaseLease(mContext, blobData.getBlobHandle());
                assertNoLeasedBlobs(mBlobStoreManager);

                SystemClock.sleep(waitDurationMs);
                SystemUtil.runWithShellPermissionIdentity(() ->
                        mBlobStoreManager.waitForIdle(TIMEOUT_WAIT_FOR_IDLE_MS));

                assertThrows(SecurityException.class, () -> mBlobStoreManager.acquireLease(
                        blobData.getBlobHandle(), R.string.test_desc,
                        blobData.getExpiryTimeMillis()));
                assertNoLeasedBlobs(mBlobStoreManager);
            } finally {
                blobData.delete();
            }
        }, Pair.create(KEY_LEASE_ACQUISITION_WAIT_DURATION_MS, String.valueOf(waitDurationMs)),
                Pair.create(KEY_DELETE_ON_LAST_LEASE_DELAY_MS, String.valueOf(waitDurationMs)));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/BlobStore/src/com/android/cts/blob/BlobStoreManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.blob.BlobStoreManagerTest"	"testBlobHandleCreation"	"CtsBlobStoreTestCases"	"1: permission"	"([2:/com/android/cts/blob/BlobStoreManagerTest.java]:[permission]:[2]:method_text:[) {            mCommandReceiver = null;            mContext.unbindService(this);        }    }}]) :|: 
    public void testBlobHandleCreation() throws Exception {
        // Creating a BlobHandle with label > 100 chars will fail
        {
            final CharSequence label = String.join("""", Collections.nCopies(101, ""a""));
            assertThrows(IllegalArgumentException.class,
                    () -> BlobHandle.createWithSha256(""digest"".getBytes(), label, 1111L, ""tag""));
        }

        // Creating a BlobHandle with tag > 128 chars will fail
        {
            final String tag = String.join("""", Collections.nCopies(129, ""a""));
            assertThrows(IllegalArgumentException.class,
                    () -> BlobHandle.createWithSha256(""digest"".getBytes(), ""label"", 1111L, tag));
        }
    }

    private static void runWithKeyValues(ThrowingRunnable runnable,
            Pair<String, String>... keyValues) throws Exception {
        final Map<String, String> previousValues = new ArrayMap();
        SystemUtil.runWithShellPermissionIdentity(() -> {
            for (Pair<String, String> pair : keyValues) {
                final String key = pair.first;
                final String value = pair.second;
                final String previousValue = DeviceConfig.getProperty(NAMESPACE_BLOBSTORE, key);
                if (!Objects.equals(previousValue, value)) {
                    previousValues.put(key, previousValue);
                    Log.i(TAG, key + "" previous value: "" + previousValue);
                    assertThat(DeviceConfig.setProperty(NAMESPACE_BLOBSTORE, key, value,
                            false /* makeDefault */)).isTrue();
                }
                Log.i(TAG, key + "" value set: "" + value);
            }
        });
        try {
            runnable.run();
        } finally {
            SystemUtil.runWithShellPermissionIdentity(() -> {
                previousValues.forEach((key, previousValue) -> {
                    final String currentValue = DeviceConfig.getProperty(
                            NAMESPACE_BLOBSTORE, key);"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/BlobStore/src/com/android/cts/blob/BlobStoreManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.fragment.cts.FragmentLifecycleTest"	"isFinishing"	"CtsFragmentTestCases"	"1: permission"	"([2:/android/fragment/cts/FragmentLifecycleTest.java]:[permission]:[2]:method_text:[            super.onCreate(savedInstanceState);            onCreateCalled = true;        }    }}]) :|: 
    public void retainInstanceOneOnCreate() throws Throwable {
        mActivityRule.runOnUiThread(() -> {
            FragmentController fc = FragmentTestUtil.createController(mActivityRule);
            FragmentTestUtil.resume(mActivityRule, fc, null);
            FragmentManager fm = fc.getFragmentManager();

            OnCreateFragment fragment = new OnCreateFragment();

            fm.beginTransaction()
                    .add(fragment, ""fragment"")
                    .commit();
            fm.executePendingTransactions();

            fm.beginTransaction()
                    .remove(fragment)
                    .addToBackStack(null)
                    .commit();

            assertTrue(fragment.onCreateCalled);
            fragment.onCreateCalled = false;

            Pair<Parcelable, FragmentManagerNonConfig> savedState =
                    FragmentTestUtil.destroy(mActivityRule, fc);

            fc = FragmentTestUtil.createController(mActivityRule);
            FragmentTestUtil.resume(mActivityRule, fc, savedState);
            fm = fc.getFragmentManager();

            fm.popBackStackImmediate();
            assertFalse(fragment.onCreateCalled);
        });
    }

    private void executePendingTransactions(final FragmentManager fm) throws Throwable {
        mActivityRule.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                fm.executePendingTransactions();
            }
        });
    }

    /**
     * This tests a deliberately odd use of a child fragment, added in onCreateView instead
     * of elsewhere. It simulates creating a UI child fragment added to the view hierarchy
     * created by this fragment.
     */
    public static class ChildFragmentManagerFragment extends StrictFragment {
        private FragmentManager mSavedChildFragmentManager;
        private ChildFragmentManagerChildFragment mChildFragment;

        @Override
        public void onAttach(Context context) {
            super.o"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/fragment/src/android/fragment/cts/FragmentLifecycleTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.musicrecognition.cts.MusicRecognitionManagerTest"	"TestName"	"CtsMusicRecognitionTestCases"	"1: permission"	"([3:/android/musicrecognition/cts/MusicRecognitionManagerTest.java]:[permission]:[3]:method_text:[rWatcher();        getInstrumentation().getUiAutomation().dropShellPermissionIdentity();    }   ]) :|: /*
 *.
 */
package android.musicrecognition.cts;

import static androidx.test.InstrumentationRegistry.getContext;
import static androidx.test.InstrumentationRegistry.getInstrumentation;

import static com.android.compatibility.common.util.ShellUtils.runShellCommand;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.assertFalse;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyBoolean;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.reset;
import static org.mockito.Mockito.timeout;
import static org.mockito.Mockito.verify;

import android.app.AppOpsManager;

import android.content.Context;
import android.media.AudioAttributes;
import android.media.AudioFormat;
import android.media.AudioRecord;
import android.media.MediaMetadata;
import android.media.MediaRecorder;
import android.media.musicrecognition.MusicRecognitionManager;
import android.media.musicrecognition.RecognitionRequest;
import android.os.Binder;
import android.os.Bundle;
import android.os.ParcelFileDescriptor;
import android.os.Process;
import android.util.Log;

import androidx.annotation.NonNull;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.RequiredServiceRule;

import com.google.common.util.concurrent.MoreExecutors;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TestName;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

/**
 * Tests for {@link MusicRecognitionManager}.
 */
@RunWith(AndroidJUnit4.class)
public class MusicRecognitionManagerTest {
    private static final String TAG ="	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/musicrecognition/src/android/musicrecognition/cts/MusicRecognitionManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.musicrecognition.cts.MusicRecognitionManagerTest"	"testRecordAudioOpsAreTracked"	"CtsMusicRecognitionTestCases"	"1: permission"	"([3:/android/musicrecognition/cts/MusicRecognitionManagerTest.java]:[permission]:[3]:method_text:[doptShellPermissionIdentity(                ""android.permission.MANAGE_MUSIC_RECOGNITION"");    }}]) :|: 
    public void testRecordAudioOpsAreTracked() {
        mWatcher.result = new MediaMetadata.Builder()
                .putString(MediaMetadata.METADATA_KEY_ARTIST, ""artist"")
                .putString(MediaMetadata.METADATA_KEY_TITLE, ""title"")
                .build();

        final String packageName = CtsMusicRecognitionService.SERVICE_PACKAGE;
        final int uid = Process.myUid();


        final Context context = getInstrumentation().getContext();

        final AppOpsManager appOpsManager = context.getSystemService(AppOpsManager.class);
        final AppOpsManager.OnOpActiveChangedListener listener = mock(
                AppOpsManager.OnOpActiveChangedListener.class);

        // Assert the app op is not started
        assertFalse(appOpsManager.isOpActive(AppOpsManager.OPSTR_RECORD_AUDIO, uid, packageName));

        // Start watching for record audio op
        appOpsManager.startWatchingActive(new String[] { AppOpsManager.OPSTR_RECORD_AUDIO },
                context.getMainExecutor(), listener);

        // Invoke API
        RecognitionRequest request = invokeMusicRecognitionApi();

        // The app op should start
        String expectedAttributionTag = ""CtsMusicRecognitionAttributionTag"";
        verify(listener, timeout(VERIFY_APPOP_CHANGE_TIMEOUT_MS))
                .onOpActiveChanged(eq(AppOpsManager.OPSTR_RECORD_AUDIO),
                eq(uid), eq(packageName), eq(expectedAttributionTag), eq(true),
                        anyInt(), anyInt());

        // Wait for streaming to finish.
        reset(listener);
        try {
            Thread.sleep(10000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // The app op should finish
        verify(listener, timeout(VERIFY_APPOP_CHANGE_TIMEOUT_MS))
                .onOpActiveChanged(eq(AppOpsManager.OPSTR_RECORD_AUDIO),
                        eq(uid), eq(packageName), eq(expectedAttributionTag), eq(false),
                        anyInt(), anyInt()"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/musicrecognition/src/android/musicrecognition/cts/MusicRecognitionManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.appsearch.app.GlobalSearchSessionPlatformCtsTest"	"testGlobalSearch_withAccess"	"CtsAppSearchTestCases"	"1: permission"	"([1:/com/android/cts/appsearch/app/GlobalSearchSessionPlatformCtsTest.java]:[permission]:[1]:method_text:[nsExactly(PKG_A, PKG_B);                },                READ_GLOBAL_APP_SEARCH_DATA);    }   ]) :|: 
    public void testGlobalSearch_withAccess() throws Exception {
        indexGloballySearchableDocument(PKG_A);
        indexGloballySearchableDocument(PKG_B);

        SystemUtil.runWithShellPermissionIdentity(
                () -> {
                    mGlobalSearchSession =
                            GlobalSearchSessionShimImpl.createGlobalSearchSession(mContext).get();

                    SearchResultsShim searchResults =
                            mGlobalSearchSession.search(
                                    /*queryExpression=*/ """",
                                    new SearchSpec.Builder()
                                            .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
                                            .addFilterPackageNames(PKG_A, PKG_B)
                                            .build());
                    List<SearchResult> page = searchResults.getNextPage().get();
                    assertThat(page).hasSize(2);

                    Set<String> actualPackageNames =
                            ImmutableSet.of(
                                    page.get(0).getPackageName(), page.get(1).getPackageName());
                    assertThat(actualPackageNames).containsExactly(PKG_A, PKG_B);
                },
                READ_GLOBAL_APP_SEARCH_DATA);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/appsearch/src/com/android/cts/appsearch/app/GlobalSearchSessionPlatformCtsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.appsearch.app.GlobalSearchSessionPlatformCtsTest"	"testGlobalSearch_withPartialAccess"	"CtsAppSearchTestCases"	"1: permission"	"([1:/com/android/cts/appsearch/app/GlobalSearchSessionPlatformCtsTest.java]:[permission]:[1]:method_text:[ame()).isEqualTo(PKG_A);                },                READ_GLOBAL_APP_SEARCH_DATA);    }   ]) :|: 
    public void testGlobalSearch_withPartialAccess() throws Exception {
        indexGloballySearchableDocument(PKG_A);
        indexNotGloballySearchableDocument(PKG_B);

        SystemUtil.runWithShellPermissionIdentity(
                () -> {
                    mGlobalSearchSession =
                            GlobalSearchSessionShimImpl.createGlobalSearchSession(mContext).get();

                    SearchResultsShim searchResults =
                            mGlobalSearchSession.search(
                                    /*queryExpression=*/ """",
                                    new SearchSpec.Builder()
                                            .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
                                            .addFilterPackageNames(PKG_A, PKG_B)
                                            .build());
                    List<SearchResult> page = searchResults.getNextPage().get();
                    assertThat(page).hasSize(1);

                    assertThat(page.get(0).getPackageName()).isEqualTo(PKG_A);
                },
                READ_GLOBAL_APP_SEARCH_DATA);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/appsearch/src/com/android/cts/appsearch/app/GlobalSearchSessionPlatformCtsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.appsearch.app.GlobalSearchSessionPlatformCtsTest"	"testGlobalSearch_withPackageFilters"	"CtsAppSearchTestCases"	"1: permission"	"([1:/com/android/cts/appsearch/app/GlobalSearchSessionPlatformCtsTest.java]:[permission]:[1]:method_text:[ame()).isEqualTo(PKG_B);                },                READ_GLOBAL_APP_SEARCH_DATA);    }   ]) :|: 
    public void testGlobalSearch_withPackageFilters() throws Exception {
        indexGloballySearchableDocument(PKG_A);
        indexGloballySearchableDocument(PKG_B);

        SystemUtil.runWithShellPermissionIdentity(
                () -> {
                    mGlobalSearchSession =
                            GlobalSearchSessionShimImpl.createGlobalSearchSession(mContext).get();

                    SearchResultsShim searchResults =
                            mGlobalSearchSession.search(
                                    /*queryExpression=*/ """",
                                    new SearchSpec.Builder()
                                            .setTermMatch(SearchSpec.TERM_MATCH_EXACT_ONLY)
                                            .addFilterPackageNames(PKG_B)
                                            .build());
                    List<SearchResult> page = searchResults.getNextPage().get();
                    assertThat(page).hasSize(1);

                    assertThat(page.get(0).getPackageName()).isEqualTo(PKG_B);
                },
                READ_GLOBAL_APP_SEARCH_DATA);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/appsearch/src/com/android/cts/appsearch/app/GlobalSearchSessionPlatformCtsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.appsearch.app.GlobalSearchSessionPlatformCtsTest"	"testReportSystemUsage"	"CtsAppSearchTestCases"	"1: permission"	"([1:/com/android/cts/appsearch/app/GlobalSearchSessionPlatformCtsTest.java]:[permission]:[1]:method_text:[) {            mCommandReceiver = null;            mContext.unbindService(this);        }    }}]) :|: 
    public void testReportSystemUsage() throws Exception {
        // Insert schema
        mDb.setSchema(new SetSchemaRequest.Builder().addSchemas(AppSearchEmail.SCHEMA).build())
                .get();

        // Insert two docs
        GenericDocument document1 =
                new GenericDocument.Builder<>(""namespace"", ""id1"", AppSearchEmail.SCHEMA_TYPE)
                        .build();
        GenericDocument document2 =
                new GenericDocument.Builder<>(""namespace"", ""id2"", AppSearchEmail.SCHEMA_TYPE)
                        .build();
        mDb.put(new PutDocumentsRequest.Builder().addGenericDocuments(document1, document2).build())
                .get();

        // Report some usages. id1 has 2 app and 1 system usage, id2 has 1 app and 2 system usage.
        mDb.reportUsage(
                new ReportUsageRequest.Builder(""namespace"", ""id1"")
                        .setUsageTimestampMillis(10)
                        .build())
                .get();
        mDb.reportUsage(
                new ReportUsageRequest.Builder(""namespace"", ""id1"")
                        .setUsageTimestampMillis(20)
                        .build())
                .get();
        mDb.reportUsage(
                new ReportUsageRequest.Builder(""namespace"", ""id2"")
                        .setUsageTimestampMillis(100)
                        .build())
                .get();

        SystemUtil.runWithShellPermissionIdentity(() -> {
            mGlobalSearchSession =
                    GlobalSearchSessionShimImpl.createGlobalSearchSession(mContext).get();
            mGlobalSearchSession
                    .reportSystemUsage(
                            new ReportSystemUsageRequest.Builder(
                                    mContext.getPackageName(), DB_NAME, ""namespace"", ""id1"")
                                    .setUsageTimestampMillis(1000)
                                    .build())
                    .get();
            mGlobalSearchSession"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/appsearch/src/com/android/cts/appsearch/app/GlobalSearchSessionPlatformCtsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.backup.cts.PermissionTest"	"testGrantDeniedRuntimePermission"	"CtsBackupTestCases"	"1: permission"	"([7:/android/backup/cts/PermissionTest.java]:[permission]:[7]:method_text:[  });    }    /**     * Test backup and restore of pre-M regular runtime permission.     */   ]) :|: public void testGrantDeniedRuntimePermission() throws Exception {
        if (!isBackupSupported()) {
            return;
        }
        grantPermission(APP, ACCESS_FINE_LOCATION);

        mBackupUtils.backupNowAndAssertSuccess(ANDROID_PACKAGE);
        resetApp(APP);
        mBackupUtils.restoreAndAssertSuccess(LOCAL_TRANSPORT_TOKEN, ANDROID_PACKAGE);

        eventually(() -> {
            assertEquals(PERMISSION_GRANTED, checkPermission(APP, ACCESS_FINE_LOCATION));
            assertEquals(PERMISSION_DENIED, checkPermission(APP, READ_CONTACTS));
        });
    }

    /**
     * Test backup and restore of pre-M regular runtime permission.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/backup/src/android/backup/cts/PermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.backup.cts.PermissionTest"	"testGrantDeniedRuntimePermission22"	"CtsBackupTestCases"	"1: permission"	"([2:/android/backup/cts/PermissionTest.java]:[permission]:[2]:method_text:[     });    }    /**     * Test backup and restore of foreground runtime permission.     */   ]) :|: public void testGrantDeniedRuntimePermission22() throws Exception {
        if (!isBackupSupported()) {
            return;
        }
        setAppOp(APP22, READ_CONTACTS, MODE_IGNORED);

        mBackupUtils.backupNowAndAssertSuccess(ANDROID_PACKAGE);
        resetApp(APP22);
        mBackupUtils.restoreAndAssertSuccess(LOCAL_TRANSPORT_TOKEN, ANDROID_PACKAGE);

        eventually(() -> {
            assertEquals(MODE_IGNORED, getAppOp(APP22, READ_CONTACTS));
            assertEquals(MODE_ALLOWED, getAppOp(APP22, ACCESS_FINE_LOCATION));
        });
    }

    /**
     * Test backup and restore of foreground runtime permission.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/backup/src/android/backup/cts/PermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.backup.cts.PermissionTest"	"testNoTriStateRuntimePermission"	"CtsBackupTestCases"	"1: permission"	"([13:/android/backup/cts/PermissionTest.java]:[permission]:[13]:method_text:[     });    }    /**     * Test backup and restore of foreground runtime permission.     */   ]) :|: public void testNoTriStateRuntimePermission() throws Exception {
        if (!isBackupSupported()) {
            return;
        }
        // Set a marker
        grantPermission(APP, WRITE_CONTACTS);

        // revoked is the default state. Hence mark the permissions as user set, so the permissions
        // are even backed up
        setFlag(APP, ACCESS_FINE_LOCATION, FLAG_PERMISSION_USER_SET);
        setFlag(APP, ACCESS_BACKGROUND_LOCATION, FLAG_PERMISSION_USER_SET);

        mBackupUtils.backupNowAndAssertSuccess(ANDROID_PACKAGE);
        resetApp(APP);
        mBackupUtils.restoreAndAssertSuccess(LOCAL_TRANSPORT_TOKEN, ANDROID_PACKAGE);

        eventually(() -> {
            // Wait until marker is set
            assertEquals(PERMISSION_GRANTED, checkPermission(APP, WRITE_CONTACTS));

            assertEquals(PERMISSION_DENIED, checkPermission(APP, ACCESS_FINE_LOCATION));
            assertEquals(PERMISSION_DENIED, checkPermission(APP, ACCESS_BACKGROUND_LOCATION));
            assertEquals(MODE_IGNORED, getAppOp(APP, ACCESS_FINE_LOCATION));
        });
    }

    /**
     * Test backup and restore of foreground runtime permission.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/backup/src/android/backup/cts/PermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.backup.cts.PermissionTest"	"testNoTriStateRuntimePermission22"	"CtsBackupTestCases"	"1: permission"	"([2:/android/backup/cts/PermissionTest.java]:[permission]:[2]:method_text:[TION)));    }    /**     * Test backup and restore of foreground runtime permission.     */   ]) :|: public void testNoTriStateRuntimePermission22() throws Exception {
        if (!isBackupSupported()) {
            return;
        }
        setAppOp(APP22, ACCESS_FINE_LOCATION, MODE_IGNORED);

        mBackupUtils.backupNowAndAssertSuccess(ANDROID_PACKAGE);
        resetApp(APP22);
        mBackupUtils.restoreAndAssertSuccess(LOCAL_TRANSPORT_TOKEN, ANDROID_PACKAGE);

        eventually(() -> assertEquals(MODE_IGNORED, getAppOp(APP22, ACCESS_FINE_LOCATION)));
    }

    /**
     * Test backup and restore of foreground runtime permission.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/backup/src/android/backup/cts/PermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.backup.cts.PermissionTest"	"testGrantForegroundRuntimePermission"	"CtsBackupTestCases"	"1: permission"	"([10:/android/backup/cts/PermissionTest.java]:[permission]:[10]:method_text:[e     * TODO: b/178522459 to fix the test once the foundamental issue has been fixed.     *///   ]) :|: public void testGrantForegroundRuntimePermission() throws Exception {
        if (!isBackupSupported()) {
            return;
        }
        grantPermission(APP, ACCESS_FINE_LOCATION);

        // revoked is the default state. Hence mark the permission as user set, so the permissions
        // are even backed up
        setFlag(APP, ACCESS_BACKGROUND_LOCATION, FLAG_PERMISSION_USER_SET);

        mBackupUtils.backupNowAndAssertSuccess(ANDROID_PACKAGE);
        resetApp(APP);
        mBackupUtils.restoreAndAssertSuccess(LOCAL_TRANSPORT_TOKEN, ANDROID_PACKAGE);

        eventually(() -> {
            assertEquals(PERMISSION_GRANTED, checkPermission(APP, ACCESS_FINE_LOCATION));
            assertEquals(PERMISSION_DENIED, checkPermission(APP, ACCESS_BACKGROUND_LOCATION));
            assertEquals(MODE_FOREGROUND, getAppOp(APP, ACCESS_FINE_LOCATION));
        });
    }

    /**
     * Test backup and restore of foreground runtime permission.
     *
     * Comment out the test since it's a JUnit 3 test which doesn't support @Ignore
     * TODO: b/178522459 to fix the test once the foundamental issue has been fixed.
     */
//"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/backup/src/android/backup/cts/PermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.backup.cts.PermissionTest"	"testGrantForegroundRuntimePermission22"	"CtsBackupTestCases"	"1: permission"	"([2:/android/backup/cts/PermissionTest.java]:[permission]:[2]:method_text:[ON)));//    }    /**     * Test backup and restore of foreground runtime permission.     */   ]) :|: public void testGrantForegroundRuntimePermission22() throws Exception {
//        if (!isBackupSupported()) {
//            return;
//        }
//        setAppOp(APP22, ACCESS_FINE_LOCATION, MODE_FOREGROUND);
//
//        mBackupUtils.backupNowAndAssertSuccess(ANDROID_PACKAGE);
//        resetApp(APP22);
//        mBackupUtils.restoreAndAssertSuccess(LOCAL_TRANSPORT_TOKEN, ANDROID_PACKAGE);
//
//        eventually(() -> assertEquals(MODE_FOREGROUND, getAppOp(APP22, ACCESS_FINE_LOCATION)));
//    }

    /**
     * Test backup and restore of foreground runtime permission.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/backup/src/android/backup/cts/PermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.backup.cts.PermissionTest"	"testGrantForegroundAndBackgroundRuntimePermission"	"CtsBackupTestCases"	"1: permission"	"([8:/android/backup/cts/PermissionTest.java]:[permission]:[8]:method_text:[     });    }    /**     * Test backup and restore of foreground runtime permission.     */   ]) :|: public void testGrantForegroundAndBackgroundRuntimePermission() throws Exception {
        if (!isBackupSupported()) {
            return;
        }
        grantPermission(APP, ACCESS_FINE_LOCATION);
        grantPermission(APP, ACCESS_BACKGROUND_LOCATION);

        mBackupUtils.backupNowAndAssertSuccess(ANDROID_PACKAGE);
        resetApp(APP);
        mBackupUtils.restoreAndAssertSuccess(LOCAL_TRANSPORT_TOKEN, ANDROID_PACKAGE);

        eventually(() -> {
            assertEquals(PERMISSION_GRANTED, checkPermission(APP, ACCESS_FINE_LOCATION));
            assertEquals(PERMISSION_GRANTED, checkPermission(APP, ACCESS_BACKGROUND_LOCATION));
            assertEquals(MODE_ALLOWED, getAppOp(APP, ACCESS_FINE_LOCATION));
        });
    }

    /**
     * Test backup and restore of foreground runtime permission.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/backup/src/android/backup/cts/PermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.backup.cts.PermissionTest"	"testGrantForegroundAndBackgroundRuntimePermission22"	"CtsBackupTestCases"	"1: permission"	"([2:/android/backup/cts/PermissionTest.java]:[permission]:[2]:method_text:[INE_LOCATION));        });    }    /**     * Restore if the permission was reviewed     */   ]) :|: public void testGrantForegroundAndBackgroundRuntimePermission22() throws Exception {
        if (!isBackupSupported()) {
            return;
        }
        // Set a marker
        setAppOp(APP22, WRITE_CONTACTS, MODE_IGNORED);

        mBackupUtils.backupNowAndAssertSuccess(ANDROID_PACKAGE);
        resetApp(APP22);
        mBackupUtils.restoreAndAssertSuccess(LOCAL_TRANSPORT_TOKEN, ANDROID_PACKAGE);

        eventually(() -> {
            // Wait for marker
            assertEquals(MODE_IGNORED, getAppOp(APP22, WRITE_CONTACTS));

            assertEquals(MODE_ALLOWED, getAppOp(APP22, ACCESS_FINE_LOCATION));
        });
    }

    /**
     * Restore if the permission was reviewed
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/backup/src/android/backup/cts/PermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.backup.cts.PermissionTest"	"testRestorePermReviewed"	"CtsBackupTestCases"	"1: permission"	"([3:/android/backup/cts/PermissionTest.java]:[permission]:[3]:method_text:[MISSION_REVIEW_REQUIRED)));    }    /**     * Restore if the permission was user set     */   ]) :|: public void testRestorePermReviewed() throws Exception {
        if (!isBackupSupported()) {
            return;
        }
        clearFlag(APP22, WRITE_CONTACTS, FLAG_PERMISSION_REVIEW_REQUIRED);

        mBackupUtils.backupNowAndAssertSuccess(ANDROID_PACKAGE);
        resetApp(APP22);
        mBackupUtils.restoreAndAssertSuccess(LOCAL_TRANSPORT_TOKEN, ANDROID_PACKAGE);

        eventually(() -> assertFalse(
                isFlagSet(APP22, WRITE_CONTACTS, FLAG_PERMISSION_REVIEW_REQUIRED)));
    }

    /**
     * Restore if the permission was user set
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/backup/src/android/backup/cts/PermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.backup.cts.PermissionTest"	"testRestoreUserSet"	"CtsBackupTestCases"	"1: permission"	"([3:/android/backup/cts/PermissionTest.java]:[permission]:[3]:method_text:[G_PERMISSION_USER_SET)));    }    /**     * Restore if the permission was user fixed     */   ]) :|: public void testRestoreUserSet() throws Exception {
        if (!isBackupSupported()) {
            return;
        }
        setFlag(APP, WRITE_CONTACTS, FLAG_PERMISSION_USER_SET);

        mBackupUtils.backupNowAndAssertSuccess(ANDROID_PACKAGE);
        resetApp(APP);
        mBackupUtils.restoreAndAssertSuccess(LOCAL_TRANSPORT_TOKEN, ANDROID_PACKAGE);

        eventually(() -> assertTrue(isFlagSet(APP, WRITE_CONTACTS, FLAG_PERMISSION_USER_SET)));
    }

    /**
     * Restore if the permission was user fixed
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/backup/src/android/backup/cts/PermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.backup.cts.PermissionTest"	"testRestoreUserFixed"	"CtsBackupTestCases"	"1: permission"	"([3:/android/backup/cts/PermissionTest.java]:[permission]:[3]:method_text:[USER_FIXED)));    }    /**     * Restoring of a flag should not grant the permission     */   ]) :|: public void testRestoreUserFixed() throws Exception {
        if (!isBackupSupported()) {
            return;
        }
        setFlag(APP, WRITE_CONTACTS, FLAG_PERMISSION_USER_FIXED);

        mBackupUtils.backupNowAndAssertSuccess(ANDROID_PACKAGE);
        resetApp(APP);
        mBackupUtils.restoreAndAssertSuccess(LOCAL_TRANSPORT_TOKEN, ANDROID_PACKAGE);

        eventually(() -> assertTrue(isFlagSet(APP, WRITE_CONTACTS, FLAG_PERMISSION_USER_FIXED)));
    }

    /**
     * Restoring of a flag should not grant the permission
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/backup/src/android/backup/cts/PermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.backup.cts.PermissionTest"	"testRestoreOfFlagDoesNotGrantPermission"	"CtsBackupTestCases"	"1: permission"	"([5:/android/backup/cts/PermissionTest.java]:[permission]:[5]:method_text:[));    }    /**     * Test backup and delayed restore of regular runtime permission.     */   ]) :|: public void testRestoreOfFlagDoesNotGrantPermission() throws Exception {
        if (!isBackupSupported()) {
            return;
        }
        setFlag(APP, WRITE_CONTACTS, FLAG_PERMISSION_USER_FIXED);

        mBackupUtils.backupNowAndAssertSuccess(ANDROID_PACKAGE);
        resetApp(APP);
        mBackupUtils.restoreAndAssertSuccess(LOCAL_TRANSPORT_TOKEN, ANDROID_PACKAGE);

        eventually(() -> assertEquals(PERMISSION_DENIED, checkPermission(APP, WRITE_CONTACTS)));
    }

    /**
     * Test backup and delayed restore of regular runtime permission.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/backup/src/android/backup/cts/PermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.backup.cts.PermissionTest"	"testDelayedRestore"	"CtsBackupTestCases"	"1: permission"	"([27:/android/backup/cts/PermissionTest.java]:[permission]:[27]:method_text:[ app));        } catch (Exception e) {            throw new RuntimeException(e);        }    }}]) :|: public void testDelayedRestore() throws Exception {
        if (!isBackupSupported()) {
            return;
        }
        grantPermission(APP, ACCESS_FINE_LOCATION);

        setAppOp(APP22, READ_CONTACTS, MODE_IGNORED);

        mBackupUtils.backupNowAndAssertSuccess(ANDROID_PACKAGE);

        uninstall(APP);
        uninstall(APP22);

        try {
            mBackupUtils.restoreAndAssertSuccess(LOCAL_TRANSPORT_TOKEN, ANDROID_PACKAGE);

            install(APP_APK);

            eventually(() -> assertEquals(PERMISSION_GRANTED,
                    checkPermission(APP, ACCESS_FINE_LOCATION)));

            install(APP22_APK);

            eventually(() -> assertEquals(MODE_IGNORED, getAppOp(APP22, READ_CONTACTS)));
        } finally {
            install(APP_APK);
            install(APP22_APK);
        }
    }

    private void install(String apk) {
        ShellUtils.runShellCommand(""pm install -r "" + apk);
    }

    private void uninstall(String packageName) {
        ShellUtils.runShellCommand(""pm uninstall "" + packageName);
    }

    private void resetApp(String packageName) {
        ShellUtils.runShellCommand(""pm clear "" + packageName);
        ShellUtils.runShellCommand(""appops reset "" + packageName);
    }

    /**
     * Make sure that a {@link Runnable} eventually finishes without throwing a {@link
     * Exception}.
     *
     * @param r The {@link Runnable} to run.
     */
    public static void eventually(@NonNull Runnable r) {
        long start = System.currentTimeMillis();

        while (true) {
            try {
                r.run();
                return;
            } catch (Throwable e) {
                if (System.currentTimeMillis() - start < TIMEOUT_MILLIS) {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException ignored) {
                        throw new RuntimeException(e);
                    }
                } else {
                    throw e;"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/backup/src/android/backup/cts/PermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.view.accessibility.cts.AccessibilityShortcutTest"	"postTestTearDown"	"CtsAccessibilityTestCases"	"1: permission"	"([1:/android/view/accessibility/cts/AccessibilityShortcutTest.java]:[permission]:[1]:method_text:[        sInstrumentation.runOnMainSync(() -> mShortcutTargetActivity.finish());        }    }   ]) :|: /*
 *.
 */

package android.view.accessibility.cts;

import static android.accessibility.cts.common.AccessibilityShortcutSettingsRule.ACCESSIBILITY_BUTTON;
import static android.accessibility.cts.common.InstrumentedAccessibilityService.TIMEOUT_SERVICE_ENABLE;
import static android.app.UiAutomation.FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES;

import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import android.accessibility.cts.common.AccessibilityDumpOnFailureRule;
import android.accessibility.cts.common.AccessibilityShortcutSettingsRule;
import android.accessibility.cts.common.InstrumentedAccessibilityServiceTestRule;
import android.accessibilityservice.AccessibilityButtonController;
import android.accessibilityservice.AccessibilityButtonController.AccessibilityButtonCallback;
import android.accessibilityservice.AccessibilityService;
import android.app.Activity;
import android.app.Instrumentation;
import android.app.Instrumentation.ActivityMonitor;
import android.app.Service;
import android.app.UiAutomation;
import android.content.ComponentName;
import android.content.Context;
import android.platform.test.annotations.AppModeFull;
import android.view.accessibility.AccessibilityManager;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.TestUtils;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.RuleChain;
import org.junit.runner.RunWith;

import java.util.Arrays;
import java.util.Collections;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Tests accessibility shortcut related functionality
 */
@AppModeFull
@RunWith(AndroidJUnit4.class)
public class AccessibilityShortcutTest {
    private static Instrumentation sInstrumentation"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/accessibility/src/android/view/accessibility/cts/AccessibilityShortcutTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.view.accessibility.cts.AccessibilityShortcutTest"	"performAccessibilityShortcut_withoutPermission_throwsSecurityException"	"CtsAccessibilityTestCases"	"1: permission"	"([2:/android/view/accessibility/cts/AccessibilityShortcutTest.java]:[permission]:[2]:method_text:[t permission"");        } catch (SecurityException e) {            // Expected        }    }   ]) :|: 
    public void performAccessibilityShortcut_withoutPermission_throwsSecurityException() {
        try {
            mAccessibilityManager.performAccessibilityShortcut();
            fail(""No security exception thrown when performing shortcut without permission"");
        } catch (SecurityException e) {
            // Expected
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/accessibility/src/android/view/accessibility/cts/AccessibilityShortcutTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.view.accessibility.cts.AccessibilityShortcutTest"	"getAccessibilityShortcut_withoutPermission_throwsSecurityException"	"CtsAccessibilityTestCases"	"1: permission"	"([2:/android/view/accessibility/cts/AccessibilityShortcutTest.java]:[permission]:[2]:method_text:[t permission"");        } catch (SecurityException e) {            // Expected        }    }   ]) :|: 
    public void getAccessibilityShortcut_withoutPermission_throwsSecurityException() {
        try {
            mAccessibilityManager.getAccessibilityShortcutTargets(ACCESSIBILITY_BUTTON);
            fail(""No security exception thrown when get shortcut without permission"");
        } catch (SecurityException e) {
            // Expected
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/accessibility/src/android/view/accessibility/cts/AccessibilityShortcutTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.view.accessibility.cts.AccessibilityShortcutTest"	"testAccessibilityButtonService_disableSelf_shortcutRemoved"	"CtsAccessibilityTestCases"	"1: permission"	"([1:/android/view/accessibility/cts/AccessibilityShortcutTest.java]:[permission]:[1]:method_text:[Controller()                    .unregisterAccessibilityButtonCallback(callback);        }    }}]) :|: 
    public void testAccessibilityButtonService_disableSelf_shortcutRemoved() {
        mA11yButtonServiceRule.enableService();
        mShortcutSettingsRule.configureAccessibilityShortcut(
                sUiAutomation, mA11yButtonServiceName);
        mShortcutSettingsRule.waitForAccessibilityShortcutStateChange(
                sUiAutomation, Arrays.asList(mA11yButtonServiceName));

        mA11yButtonServiceRule.getService().disableSelfAndRemove();
        mShortcutSettingsRule.waitForAccessibilityShortcutStateChange(sUiAutomation,
                Collections.emptyList());
    }

    /**
     * Perform shortcut and wait for accessibility button clicked call back.
     *
     * @param service The accessibility service
     */
    private void performShortcutAndWaitForA11yButtonClicked(AccessibilityService service) {
        final AtomicBoolean clicked = new AtomicBoolean();
        final AccessibilityButtonCallback callback = new AccessibilityButtonCallback() {
            @Override
            public void onClicked(AccessibilityButtonController controller) {
                synchronized (clicked) {
                    clicked.set(true);
                    clicked.notifyAll();
                }
            }

            @Override
            public void onAvailabilityChanged(AccessibilityButtonController controller,
                    boolean available) {
                /* do nothing */
            }
        };
        try {
            service.getAccessibilityButtonController()
                    .registerAccessibilityButtonCallback(callback);
            runWithShellPermissionIdentity(sUiAutomation,
                    () -> mAccessibilityManager.performAccessibilityShortcut());
            TestUtils.waitOn(clicked, () -> clicked.get(), TIMEOUT_SERVICE_ENABLE,
                    ""Wait for a11y button clicked"");
        } finally {
            service.getAccessibilityButtonController()
                    .unregisterAccessibilityButtonCallback(callback);"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/accessibility/src/android/view/accessibility/cts/AccessibilityShortcutTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.hardware.devicestate.cts.DeviceStateManagerTests"	"testRequestStateTooLarge"	"CtsDeviceStateManagerTestCases"	"1: permission"	"([1:/android/hardware/devicestate/cts/DeviceStateManagerTests.java]:[permission]:[1]:method_text:[alArgumentException} if     * supplied with a state below {@link MINIMUM_DEVICE_STATE}.     */   ]) :|: (expected = IllegalArgumentException.class)
    public void testRequestStateTooLarge() throws Throwable {
        final DeviceStateManager manager = getDeviceStateManager();
        final DeviceStateRequest request
                = DeviceStateRequest.newBuilder(MAXIMUM_DEVICE_STATE + 1).build();
        runWithControlDeviceStatePermission(() -> manager.requestState(request, null, null));
    }

    /**
     * Tests that calling {@link DeviceStateManager#requestState(DeviceStateRequest, Executor,
     * DeviceStateRequest.Callback)} throws an {@link java.lang.IllegalArgumentException} if
     * supplied with a state below {@link MINIMUM_DEVICE_STATE}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/devicestate/src/android/hardware/devicestate/cts/DeviceStateManagerTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.hardware.devicestate.cts.DeviceStateManagerTests"	"testRequestStateTooSmall"	"CtsDeviceStateManagerTestCases"	"1: permission"	"([3:/android/hardware/devicestate/cts/DeviceStateManagerTests.java]:[permission]:[3]:method_text:[out the     * {@link android.Manifest.permission.CONTROL_DEVICE_STATE} permission held.     */   ]) :|: (expected = IllegalArgumentException.class)
    public void testRequestStateTooSmall() throws Throwable {
        final DeviceStateManager manager = getDeviceStateManager();
        final DeviceStateRequest request
                = DeviceStateRequest.newBuilder(MINIMUM_DEVICE_STATE - 1).build();
        runWithControlDeviceStatePermission(() -> manager.requestState(request, null, null));
    }

    /**
     * Tests that calling {@link DeviceStateManager#requestState()} throws a
     * {@link java.lang.SecurityException} without the
     * {@link android.Manifest.permission.CONTROL_DEVICE_STATE} permission held.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/devicestate/src/android/hardware/devicestate/cts/DeviceStateManagerTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.hardware.devicestate.cts.DeviceStateManagerTests"	"testRequestStateWithoutPermission"	"CtsDeviceStateManagerTestCases"	"1: permission"	"([3:/android/hardware/devicestate/cts/DeviceStateManagerTests.java]:[permission]:[3]:method_text:[out the     * {@link android.Manifest.permission.CONTROL_DEVICE_STATE} permission held.     */   ]) :|: (expected = SecurityException.class)
    public void testRequestStateWithoutPermission() {
        final DeviceStateManager manager = getDeviceStateManager();
        final int[] states = manager.getSupportedStates();
        final DeviceStateRequest request = DeviceStateRequest.newBuilder(states[0]).build();
        manager.requestState(request, null, null);
    }

    /**
     * Tests that calling {@link DeviceStateManager#cancelRequest()} throws a
     * {@link java.lang.SecurityException} without the
     * {@link android.Manifest.permission.CONTROL_DEVICE_STATE} permission held.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/devicestate/src/android/hardware/devicestate/cts/DeviceStateManagerTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.hardware.devicestate.cts.DeviceStateManagerTests"	"testCancelRequestWithoutPermission"	"CtsDeviceStateManagerTestCases"	"1: permission"	"([1:/android/hardware/devicestate/cts/DeviceStateManagerTests.java]:[permission]:[1]:method_text:[* supplied with an initial callback that contains the state at the time of registration.     */   ]) :|: (expected = SecurityException.class)
    public void testCancelRequestWithoutPermission() throws Throwable {
        final DeviceStateManager manager = getDeviceStateManager();
        final int[] states = manager.getSupportedStates();
        final DeviceStateRequest request = DeviceStateRequest.newBuilder(states[0]).build();
        runWithRequestActive(request, () -> {
            manager.cancelRequest(request);
        });
    }

    /**
     * Tests that callbacks added with {@link DeviceStateManager#registerDeviceStateCallback()} are
     * supplied with an initial callback that contains the state at the time of registration.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/devicestate/src/android/hardware/devicestate/cts/DeviceStateManagerTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.providerui.cts.MediaStoreUiTest"	"getPersistedUriPermissions"	"CtsProviderUiTestCases"	"1: permission"	"([8:/android/providerui/cts/MediaStoreUiTest.java]:[permission]:[8]:method_text:[FLAG_GRANT_WRITE_URI_PERMISSION);            }            mActivity.finish();        }    }   ]) :|: /*
 *.
 */

package android.providerui.cts;

import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import android.app.Activity;
import android.app.Instrumentation;
import android.app.UiAutomation;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.content.UriPermission;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.content.res.AssetFileDescriptor;
import android.database.Cursor;
import android.net.Uri;
import android.os.Environment;
import android.os.FileUtils;
import android.os.ParcelFileDescriptor;
import android.os.storage.StorageManager;
import android.os.storage.StorageVolume;
import android.os.UserManager;
import android.provider.DocumentsContract;
import android.provider.MediaStore;
import android.provider.cts.ProviderTestUtils;
import android.providerui.cts.GetResultActivity.Result;
import android.support.test.uiautomator.By;
import android.support.test.uiautomator.BySelector;
import android.support.test.uiautomator.UiDevice;
import android.support.test.uiautomator.UiObject;
import android.support.test.uiautomator.UiObject2;
import android.support.test.uiautomator.UiObjectNotFoundException;
import android.support.test.uiautomator.UiScrollable;
import android.support.test.uiautomator.UiSelector;
import android.support.test.uiautomator.Until;
import android.system.Os;
import android.text.format.DateUtils;
import android.util.Log;

import androidx.test.InstrumentationRegistry;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameter;
import org.junit.runners.Parameterized.Parameters;

import java.io.BufferedReader;
import java.io.File;
import jav"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/providerui/src/android/providerui/cts/MediaStoreUiTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.providerui.cts.MediaStoreUiTest"	"testGetDocumentUri_ThrowsWithoutPermission"	"CtsProviderUiTestCases"	"1: permission"	"([1:/android/providerui/cts/MediaStoreUiTest.java]:[permission]:[1]:method_text:[tyException."");        } catch (SecurityException e) {            // Expected        }    }   ]) :|: 
    public void testGetDocumentUri_ThrowsWithoutPermission() throws Exception {
        if (!supportsHardware()) return;

        prepareFile();

        try {
            MediaStore.getDocumentUri(mActivity, mMediaStoreUri);
            fail(""Expecting SecurityException."");
        } catch (SecurityException e) {
            // Expected
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/providerui/src/android/providerui/cts/MediaStoreUiTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.providerui.cts.MediaStoreUiTest"	"testGetMediaUriAccess_MediaDocumentsProvider"	"CtsProviderUiTestCases"	"1: permission"	"([4:/android/providerui/cts/MediaStoreUiTest.java]:[permission]:[4]:method_text:[                FileUtils.copy(source, target);            }        }        return file;    }}]) :|: 
    public void testGetMediaUriAccess_MediaDocumentsProvider() throws Exception {
        if (!supportsHardware()) return;

        prepareFile();
        clearDocumentsUi();
        final Intent intent = new Intent();
        intent.setAction(Intent.ACTION_OPEN_DOCUMENT);
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        intent.setType(""*/*"");
        mActivity.startActivityForResult(intent, REQUEST_CODE);
        mDevice.waitForIdle();

        findDocument(mFile.getName()).click();
        final Result result = mActivity.getResult();
        final Uri uri = result.data.getData();
        assertEquals(MEDIA_DOCUMENTS_PROVIDER_AUTHORITY, uri.getAuthority());
        final Uri mediaUri = MediaStore.getMediaUri(mActivity, uri);

        assertAccessToMediaUri(mediaUri, mFile);
    }

    private void assertAccessToMediaUri(Uri mediaUri, File file) {
        final String[] projection = {MediaStore.MediaColumns.DISPLAY_NAME};
        try (Cursor c = mContext.getContentResolver().query(
                mediaUri, projection, null, null, null)) {
            assertTrue(c.moveToFirst());
            assertEquals(file.getName(), c.getString(0));
        }
    }

    /**
     * Clears the DocumentsUI package data.
     */
    protected void clearDocumentsUi() throws Exception {
        executeShellCommand(""pm clear "" + getDocumentsUiPackageId());
    }

    private UiObject findDocument(String label) throws UiObjectNotFoundException {
        final UiSelector docList = new UiSelector().resourceId(getDocumentsUiPackageId()
                + "":id/dir_list"");

        // Wait for the first list item to appear
        assertTrue(""First list item"",
                new UiObject(docList.childSelector(new UiSelector()))
                        .waitForExists(TIMEOUT_MILLIS));

        try {
            //Enforce to set the list mode
            //Because UiScrollable can't reach the real bottom (when WEB_LINKABLE_FILE item)
            // in grid mode when screen landsc"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/providerui/src/android/providerui/cts/MediaStoreUiTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.apppredictionservice.cts.AppPredictionServiceTest"	"testFailureWithoutPermission"	"CtsAppPredictionServiceTestCases"	"1: permission"	"([3:/android/apppredictionservice/cts/AppPredictionServiceTest.java]:[permission]:[3]:method_text:[GE_STATS);        assertFails(() -> createTestPredictor(createTestPredictionContext()));    }   ]) :|: 
    public void testFailureWithoutPermission() {
        setService(null);
        InstrumentationRegistry.getInstrumentation().getUiAutomation().revokeRuntimePermission(
                InstrumentationRegistry.getTargetContext().getPackageName(),
                android.Manifest.permission.PACKAGE_USAGE_STATS);
        assertFails(() -> createTestPredictor(createTestPredictionContext()));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/apppredictionservice/src/android/apppredictionservice/cts/AppPredictionServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.apppredictionservice.cts.AppPredictionServiceTest"	"testSuccessWithPermission"	"CtsAppPredictionServiceTestCases"	"1: permission"	"([3:/android/apppredictionservice/cts/AppPredictionServiceTest.java]:[permission]:[3]:method_text:[{            throw new RuntimeException(""Command '"" + command + ""' failed: "", e);        }    }}]) :|: 
    public void testSuccessWithPermission() {
        setService(null);
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                InstrumentationRegistry.getTargetContext().getPackageName(),
                android.Manifest.permission.PACKAGE_USAGE_STATS);
        AppPredictor predictor = createTestPredictor(createTestPredictionContext());
        predictor.destroy();
    }

    private void assertFails(Runnable r) {
        try {
            r.run();
        } catch (Exception|Error e) {
            // Expected failure
            return;
        }
        fail(""Expected failure"");
    }

    /** Creates a random number of targets by increasing id */
    private List<AppTarget> createPredictions() {
        List<AppTarget> targets = new ArrayList<>();
        int n = (int) (Math.random() * 20);
        for (int i = 0; i < n; i++) {
            targets.add(new AppTarget.Builder(new AppTargetId(String.valueOf(i)), ""test.pkg"",
                    UserHandle.CURRENT)
                    .setClassName(""test.class."" + i)
                    .build());
        }
        return targets;
    }

    private AppPredictionContext createTestPredictionContext() {
        return new AppPredictionContext.Builder(InstrumentationRegistry.getTargetContext())
                .setExtras(mPredictionContextExtras)
                .setUiSurface(TEST_UI_SURFACE)
                .setPredictedTargetCount(TEST_NUM_PREDICTIONS)
                .build();
    }

    private AppPredictor createTestPredictor(AppPredictionContext context) {
        Context ctx = InstrumentationRegistry.getTargetContext();
        AppPredictionManager mgr = (AppPredictionManager) ctx.getSystemService(
                APP_PREDICTION_SERVICE);
        return mgr.createAppPredictionSession(context);
    }

    private void setService(String service) {
        Log.d(TAG, ""Setting app prediction service to "" + service);
        int userId = android.os.Process.myUserHa"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/apppredictionservice/src/android/apppredictionservice/cts/AppPredictionServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.controls.cts.CtsControlsServiceTest"	"testRequestAddControl"	"CtsControlsDeviceTestCases"	"1: permission"	"([3:/android/controls/cts/CtsControlsServiceTest.java]:[permission]:[3]:method_text:[on(), t2.getActionDescription());        assertRangeTemplate(t1.getRange(), t2.getRange());    }}]) :|: 
    public void testRequestAddControl() {
        Resources res = mock(Resources.class);
        when(res.getString(anyInt())).thenReturn("""");

        final ComponentName testComponent = new ComponentName(""TestPkg"", ""TestClass"");
        final Control control = new Control.StatelessBuilder(mControlsService.buildMower(false))
                .build();

        Context context = new MockContext() {
            public Resources getResources() {
                return res;
            }

            public void sendBroadcast(Intent intent, String receiverPermission) {
                assertEquals(intent.getAction(), ACTION_ADD_CONTROL);
                assertEquals((ComponentName) intent.getParcelableExtra(Intent.EXTRA_COMPONENT_NAME),
                        testComponent);
                assertEquals((Control) intent.getParcelableExtra(EXTRA_CONTROL), control);
                assertEquals(receiverPermission, ""android.permission.BIND_CONTROLS"");
            }
        };

        ControlsProviderService.requestAddControl(context, testComponent, control);
    }

    private Consumer<Integer> assertConsumer(int expectedStatus) {
        return (status) -> {
            ControlAction.isValidResponse(status);
            assertEquals((int) status, expectedStatus);
        };
    }

    private void subscribe(Publisher<Control> publisher, final int request,
            final List<Control> addToList) {
        publisher.subscribe(new Subscriber<Control>() {
                public void onSubscribe(Subscription s) {
                    s.request(request);
                }

                public void onNext(Control c) {
                    addToList.add(c);
                }

                public void onError(Throwable t) {
                    throw new IllegalStateException(""onError should not be called here"");
                }

                public void onComplete() {

                }
            });
    }

    private void assertControlsList(List<Control> actualC"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/controls/src/android/controls/cts/CtsControlsServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.rollback.RollbackManagerTest"	"dropShellPermissionIdentity"	"CtsRollbackManagerTestCases"	"1: permission"	"([9:/com/android/cts/rollback/RollbackManagerTest.java]:[permission]:[9]:method_text:[             .dropShellPermissionIdentity();    }    /**     * Test basic rollbacks.     */   ]) :|: /*
 *.
 */

package com.android.cts.rollback;

import static com.android.cts.rollback.lib.RollbackInfoSubject.assertThat;
import static com.android.cts.rollback.lib.RollbackUtils.getRollbackManager;

import static com.google.common.truth.Truth.assertThat;

import android.Manifest;
import android.content.rollback.RollbackInfo;
import android.provider.DeviceConfig;

import androidx.test.InstrumentationRegistry;

import com.android.cts.install.lib.Install;
import com.android.cts.install.lib.InstallUtils;
import com.android.cts.install.lib.TestApp;
import com.android.cts.install.lib.Uninstall;
import com.android.cts.rollback.lib.Rollback;
import com.android.cts.rollback.lib.RollbackUtils;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

import java.io.IOException;

/**
 * CTS Tests for RollbackManager APIs.
 */
@RunWith(JUnit4.class)
public class RollbackManagerTest {

    /**
     * Adopts common permissions needed to test rollbacks and uninstalls the
     * test apps.
     */
    @Before
    public void setup() throws InterruptedException, IOException {
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(
                    Manifest.permission.INSTALL_PACKAGES,
                    Manifest.permission.DELETE_PACKAGES,
                    Manifest.permission.TEST_MANAGE_ROLLBACKS,
                    Manifest.permission.READ_DEVICE_CONFIG,
                    Manifest.permission.WRITE_DEVICE_CONFIG);

        Uninstall.packages(TestApp.A);
    }

    /**
     * Drops adopted shell permissions and uninstalls the test apps.
     */
    @After
    public void teardown() throws InterruptedException, IOException {
        Uninstall.packages(TestApp.A);

        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .dropShellPermissionIdentity();
    }

    /**
     * Test basic rollbacks.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/rollback/src/com/android/cts/rollback/RollbackManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.accessibilityservice.cts.AccessibilityEndToEndTest"	"postTestTearDown"	"CtsAccessibilityServiceTestCases"	"1: permission"	"([2:/android/accessibilityservice/cts/AccessibilityEndToEndTest.java]:[permission]:[2]:method_text:[          sInstrumentation, sUiAutomation, mActivityRule);    }    @MediumTest    @Presubmit   ]) :|: /*
 *.
 */

package android.accessibilityservice.cts;

import static android.accessibility.cts.common.InstrumentedAccessibilityService.enableService;
import static android.accessibilityservice.cts.utils.AccessibilityEventFilterUtils.filterForEventType;
import static android.accessibilityservice.cts.utils.AccessibilityEventFilterUtils.filterForEventTypeWithAction;
import static android.accessibilityservice.cts.utils.AccessibilityEventFilterUtils.filterForEventTypeWithResource;
import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.findWindowByTitle;
import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.getActivityTitle;
import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.launchActivityAndWaitForItToBeOnscreen;
import static android.accessibilityservice.cts.utils.AsyncUtils.DEFAULT_TIMEOUT_MS;
import static android.accessibilityservice.cts.utils.RunOnMainUtils.getOnMain;
import static android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction.ACTION_HIDE_TOOLTIP;
import static android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction.ACTION_SHOW_TOOLTIP;

import static org.hamcrest.Matchers.in;
import static org.hamcrest.Matchers.not;
import static org.hamcrest.core.IsEqual.equalTo;
import static org.hamcrest.core.IsNull.notNullValue;
import static org.hamcrest.core.IsNull.nullValue;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.argThat;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.inOrder;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.timeout;
import static org.mockito.Mockito.verify;

import android.accessibility.cts.common.Acce"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityEndToEndTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.accessibilityservice.cts.AccessibilityEndToEndTest"	"testPackageNameCannotBeFakedAppWidget"	"CtsAccessibilityServiceTestCases"	"1: permission"	"([3:/android/accessibilityservice/cts/AccessibilityEndToEndTest.java]:[permission]:[3]:method_text:[();            revokeBindAppWidgetPermission();        }    }    @MediumTest    @Presubmit   ]) :|: 
    public void testPackageNameCannotBeFakedAppWidget() throws Exception {
        if (!hasAppWidgets()) {
            return;
        }

        sInstrumentation.runOnMainSync(() -> {
            // Set the activity to report fake package for events and nodes
            mActivity.setReportedPackageName(APP_WIDGET_PROVIDER_PACKAGE);

            // Make sure we cannot report nodes as if from the widget package
            AccessibilityNodeInfo root = sUiAutomation
                    .getRootInActiveWindow();
            assertPackageName(root, mActivity.getPackageName());
        });

        // Make sure we cannot send events as if from the widget package
        try {
            sUiAutomation.executeAndWaitForEvent(() ->
                sInstrumentation.runOnMainSync(() ->
                    mActivity.findViewById(R.id.button).requestFocus())
                , (AccessibilityEvent event) ->
                    event.getEventType() == AccessibilityEvent.TYPE_VIEW_FOCUSED
                            && event.getPackageName().equals(mActivity.getPackageName())
                , DEFAULT_TIMEOUT_MS);
        } catch (TimeoutException e) {
            fail(""Should not be able to send events from a widget package if no widget hosted"");
        }

        // Create a host and start listening.
        final AppWidgetHost host = new AppWidgetHost(sInstrumentation.getTargetContext(), 0);
        host.deleteHost();
        host.startListening();

        // Well, app do not have this permission unless explicitly granted
        // by the user. Now we will pretend for the user and grant it.
        grantBindAppWidgetPermission();

        // Allocate an app widget id to bind.
        final int appWidgetId = host.allocateAppWidgetId();
        try {
            // Grab a provider we defined to be bound.
            final AppWidgetProviderInfo provider = getAppWidgetProviderInfo();

            // Bind the widget.
            final boolean widgetBound = getAppWidgetManager()"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityEndToEndTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.accessibilityservice.cts.AccessibilityEndToEndTest"	"testTouchDelegateCoverParentWithEbt_HoverChildAndBack_FocusTargetAgain"	"CtsAccessibilityServiceTestCases"	"1: permission"	"([4:/android/accessibilityservice/cts/AccessibilityEndToEndTest.java]:[permission]:[4]:method_text:[tic int getCurrentUser() {        return android.os.Process.myUserHandle().getIdentifier();    }}]) :|: 
    public void testTouchDelegateCoverParentWithEbt_HoverChildAndBack_FocusTargetAgain()
            throws Throwable {
        mActivity.waitForEnterAnimationComplete();

        final int touchableSize = 48;
        final Resources resources = sInstrumentation.getTargetContext().getResources();
        final String targetResourceName = resources.getResourceName(R.id.buttonDelegated);
        final View textView = mActivity.findViewById(R.id.delegateText);
        final Button target = mActivity.findViewById(R.id.buttonDelegated);
        int[] location = new int[2];
        textView.getLocationOnScreen(location);
        final int textX = location[0] + touchableSize/2;
        final int textY = location[1] + textView.getHeight() / 2;
        final int delegateX = location[0] - touchableSize/2;
        final int targetX = target.getWidth() / 2;
        final int targetY = target.getHeight() / 2;
        final View.OnHoverListener listener = CtsMouseUtil.installHoverListener(target, false);
        enableTouchExploration(sInstrumentation, true);

        try {
            final long downTime = SystemClock.uptimeMillis();
            // Like switch bar, it has a text view, a button and a delegate covers parent layout.
            // hover the delegate, text and delegate again.
            sUiAutomation.executeAndWaitForEvent(
                    () -> injectHoverEvent(downTime, false, delegateX, textY),
                    filterForEventTypeWithResource(AccessibilityEvent.TYPE_VIEW_HOVER_ENTER,
                           targetResourceName), DEFAULT_TIMEOUT_MS);
            assertTrue(target.isHovered());
            sUiAutomation.executeAndWaitForEvent(
                    () -> injectHoverEvent(downTime, true, textX, textY),
                    filterForEventTypeWithResource(AccessibilityEvent.TYPE_VIEW_HOVER_EXIT,
                           targetResourceName), DEFAULT_TIMEOUT_MS);
            sUiAutomation.executeAndWaitForEvent(
                    () -> inject"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityEndToEndTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.accessibilityservice.cts.AccessibilitySystemActionTest"	"dropShellPermissionIdentity"	"CtsAccessibilityServiceTestCases"	"1: permission"	"([5:/android/accessibilityservice/cts/AccessibilitySystemActionTest.java]:[permission]:[5]:method_text:[    @After    public void tearDown() throws Exception {        mService.setLatch(null);    }   ]) :|: /*
 *.
 */

package android.accessibilityservice.cts;

import static android.accessibilityservice.cts.utils.AsyncUtils.DEFAULT_TIMEOUT_MS;
import static android.app.UiAutomation.FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES;
import static org.junit.Assert.fail;

import android.accessibility.cts.common.AccessibilityDumpOnFailureRule;
import android.accessibility.cts.common.InstrumentedAccessibilityServiceTestRule;
import android.accessibilityservice.AccessibilityService;
import android.app.Instrumentation;
import android.app.PendingIntent;
import android.app.RemoteAction;
import android.app.UiAutomation;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.graphics.drawable.Icon;
import android.platform.test.annotations.AppModeFull;
import android.view.accessibility.AccessibilityManager;
import android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction;

import androidx.test.platform.app.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.RuleChain;
import org.junit.runner.RunWith;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

@RunWith(AndroidJUnit4.class)
public class AccessibilitySystemActionTest {
    // intent actions to trigger system action callbacks
    private final static String INTENT_ACTION_SYSTEM_ACTION_CALLBACK_OVERRIDE_BACK = ""android.accessibility.cts.end2endtests.action.system_action_callback_override_back"";
    private final static String INTENT_ACTION_SYSTEM_ACTION_CALLBACK_NEW = ""android.accessibility.cts.end2endtests.action.system_action_callback_new"";

    private final static int NEW_ACTION_ID = 111;
    private final static String MANAGE_ACCESSIBILITY_PERMISSION = ""android.permission.MANAGE_ACCESSIBILITY"";"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilitySystemActionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.accessibilityservice.cts.AccessibilityWindowQueryTest"	"testShowInputMethodDialogWindow_resultIsApplicationType"	"CtsAccessibilityServiceTestCases"	"1: permission"	"([2:/android/accessibilityservice/cts/AccessibilityWindowQueryTest.java]:[permission]:[2]:method_text:[            return false;                }            }            return true;        }    }}]) :|: 
    public void testShowInputMethodDialogWindow_resultIsApplicationType()
            throws TimeoutException {
        final WindowManager wm =
                sInstrumentation.getContext().getSystemService(WindowManager.class);
        final View view = new View(sInstrumentation.getContext());
        final String windowTitle = ""Input Method Dialog"";

        try {
            sUiAutomation.executeAndWaitForEvent(() -> sInstrumentation.runOnMainSync(
                    () -> {
                        WindowManager.LayoutParams params = new WindowManager.LayoutParams(
                                WindowManager.LayoutParams.TYPE_INPUT_METHOD_DIALOG);
                        params.accessibilityTitle = windowTitle;

                        SystemUtil.runWithShellPermissionIdentity(
                                () -> wm.addView(view, params),
                                ""android.permission.INTERNAL_SYSTEM_WINDOW"");
                    }),
                    filterWindowsChangeTypesAndWindowTitle(sUiAutomation,
                            WINDOWS_CHANGE_ADDED, windowTitle), DEFAULT_TIMEOUT_MS);


            final List<AccessibilityWindowInfo> windows = sUiAutomation.getWindows();
            assertTrue(windows.stream().anyMatch(window -> window.getType()
                    == AccessibilityWindowInfo.TYPE_APPLICATION));
        } finally {
            try {
                wm.removeView(view);
            } catch (IllegalStateException e) {
                Log.e(LOG_TAG, ""remove view fail:"" + e.toString());
            }
        }
    }

    private AccessibilityWindowInfo findWindow(List<AccessibilityWindowInfo> windows,
            int btnTextRes) {
        return windows.stream()
                .filter(w -> w.getRoot()
                        .findAccessibilityNodeInfosByText(
                                sInstrumentation.getTargetContext().getString(btnTextRes))
                        .size() == 1)
                .findFirst()
                .ge"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityWindowQueryTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.accessibilityservice.cts.AccessibilityButtonSdk29Test"	"postTestTearDown"	"CtsAccessibilityServiceSdk29TestCases"	"1: permission"	"([1:/android/accessibilityservice/cts/AccessibilityButtonSdk29Test.java]:[permission]:[1]:method_text:[FLAG_REQUEST_ACCESSIBILITY_BUTTON)                == FLAG_REQUEST_ACCESSIBILITY_BUTTON);    }   ]) :|: /**
 *.
 */

package android.accessibilityservice.cts;

import static android.accessibility.cts.common.AccessibilityShortcutSettingsRule.ACCESSIBILITY_BUTTON;
import static android.accessibilityservice.AccessibilityServiceInfo.FLAG_REQUEST_ACCESSIBILITY_BUTTON;
import static android.app.UiAutomation.FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES;

import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;

import static org.junit.Assert.assertTrue;

import android.accessibility.cts.common.AccessibilityDumpOnFailureRule;
import android.accessibility.cts.common.InstrumentedAccessibilityServiceTestRule;
import android.accessibilityservice.AccessibilityServiceInfo;
import android.app.Instrumentation;
import android.app.Service;
import android.app.UiAutomation;
import android.content.ComponentName;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;
import android.text.TextUtils;
import android.view.accessibility.AccessibilityManager;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.RuleChain;
import org.junit.runner.RunWith;

import java.util.List;

/**
 * Test to verify accessibility button targeting sdk 29 APIs.
 */
@AppModeFull
@RunWith(AndroidJUnit4.class)
public class AccessibilityButtonSdk29Test {
    private static Instrumentation sInstrumentation;
    private static UiAutomation sUiAutomation;

    private InstrumentedAccessibilityServiceTestRule<StubAccessibilityButtonSdk29Service>
            mServiceRule = new InstrumentedAccessibilityServiceTestRule<>(
                    StubAccessibilityButtonSdk29Service.class);

    private AccessibilityDumpOnFailureRule mDumpOnFailureRule =
            new AccessibilityDumpOnFailureRule();

    @Rule
    public final RuleChain mRuleChain = RuleChain
            .outerRule"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/accessibilityservice/testsdk29/src/android/accessibilityservice/cts/AccessibilityButtonSdk29Test.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.sensorratepermission.cts.directreportapi30.DirectReportAPI30Test"	"testSamplingRateMicToggleOff"	""	"1: permission"	"([2:/android/sensorratepermission/cts/directreportapi30/DirectReportAPI30Test.java]:[permission]:[2]:method_text:[        obtainedRate > SensorRatePermissionDirectReportTestHelper.CAPPED_SAMPLE_RATE_HZ);    }   ]) :|: 
    public void testSamplingRateMicToggleOff() throws InterruptedException {
        // Only run this test if we know for sure that the highest direct report rate level of
        // corresponds to a sampling rate of > 200 Hz
        if (mDirectReportTestHelper.getSensor().getHighestDirectReportRateLevel()
                <= SensorDirectChannel.RATE_FAST) {
            return;
        }

        mDirectReportTestHelper.flipAndAssertMicToggleOff(mUserID, mSensorPrivacyManager);
        List<SensorDirectReportTest.DirectReportSensorEvent> events =
                mDirectReportTestHelper.getSensorEvents(SensorDirectChannel.RATE_VERY_FAST);

        double obtainedRate = SensorRatePermissionDirectReportTestHelper.computeAvgRate(events,
                Long.MIN_VALUE, Long.MAX_VALUE);

        Assert.assertTrue(mDirectReportTestHelper.errorWhenBelowExpectedRate(),
                obtainedRate > SensorRatePermissionDirectReportTestHelper.CAPPED_SAMPLE_RATE_HZ);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/sensor/sensorratepermission/DirectReportAPI30/src/android/sensorratepermission/cts/directreportapi30/DirectReportAPI30Test.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.sensorratepermission.cts.directreportapi30.DirectReportAPI30Test"	"testSamplingRateMicToggleOn"	""	"1: permission"	"([2:/android/sensorratepermission/cts/directreportapi30/DirectReportAPI30Test.java]:[permission]:[2]:method_text:[   * rate of ongoing direct sensor connections when the state of the mic toggle changes.     */   ]) :|: 
    public void testSamplingRateMicToggleOn() throws InterruptedException {
        mDirectReportTestHelper.flipAndAssertMicToggleOn(mUserID, mSensorPrivacyManager);
        List<SensorDirectReportTest.DirectReportSensorEvent> events =
                mDirectReportTestHelper.getSensorEvents(SensorDirectChannel.RATE_VERY_FAST);

        double obtainedRate = SensorRatePermissionDirectReportTestHelper.computeAvgRate(events,
                Long.MIN_VALUE, Long.MAX_VALUE);

        Assert.assertTrue(mDirectReportTestHelper.errorWhenExceedCappedRate(),
                obtainedRate <= SensorRatePermissionDirectReportTestHelper.CAPPED_SAMPLE_RATE_HZ);
    }

    /**
     * Test the case where a connection is ongoing while the mic toggle changes its state:
     * off -> on -> off. This test is to show that the sensor service is able to cap/uncap the
     * rate of ongoing direct sensor connections when the state of the mic toggle changes.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/sensor/sensorratepermission/DirectReportAPI30/src/android/sensorratepermission/cts/directreportapi30/DirectReportAPI30Test.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.sensorratepermission.cts.directreportapi30.DirectReportAPI30Test"	"testSamplingRateMicToggleOffOnOff"	""	"1: permission"	"([7:/android/sensorratepermission/cts/directreportapi30/DirectReportAPI30Test.java]:[permission]:[7]:method_text:[                        > SensorRatePermissionDirectReportTestHelper.CAPPED_SAMPLE_RATE_HZ);    }]) :|: 
    public void testSamplingRateMicToggleOffOnOff() throws InterruptedException {
        // Only run this test if we know for sure that the highest direct report rate level of
        // the sensor corresponds to a sampling rate of > 200 Hz and that the sensor supports
        // direct channel.
        Sensor s = mDirectReportTestHelper.getSensor();
        if (s.getHighestDirectReportRateLevel() <= SensorDirectChannel.RATE_FAST
                || !s.isDirectChannelTypeSupported(SensorDirectChannel.TYPE_HARDWARE_BUFFER)) {
            return;
        }
        // Start with the mic toggle off
        mDirectReportTestHelper.flipAndAssertMicToggleOff(mUserID, mSensorPrivacyManager);

        // Configure a direct channel.
        int sensorEventCount = 5500; // 800 Hz * 2.5s  + 200 Hz * 2.5s + extra
        int sharedMemorySize = sensorEventCount *
                SensorRatePermissionDirectReportTestHelper.SENSORS_EVENT_SIZE;
        HardwareBuffer hardwareBuffer = HardwareBuffer.create(
                sharedMemorySize, 1, HardwareBuffer.BLOB, 1,
                HardwareBuffer.USAGE_CPU_READ_OFTEN | HardwareBuffer.USAGE_GPU_DATA_BUFFER
                        | HardwareBuffer.USAGE_SENSOR_DIRECT_DATA);
        SensorDirectChannel channel = mSensorManager.createDirectChannel(hardwareBuffer);
        int token = channel.configure(s, SensorDirectChannel.RATE_VERY_FAST);

        // Flip the mic toggle on
        mDirectReportTestHelper.flipAndAssertMicToggleOn(mUserID, mSensorPrivacyManager);
        long startMicToggleOn = SystemClock.elapsedRealtimeNanos();
        SensorCtsHelper.sleep(
                SensorRatePermissionDirectReportTestHelper.TEST_RUN_TIME_PERIOD_MILLISEC / 2,
                TimeUnit.MILLISECONDS);
        long endMicToggleOn = SystemClock.elapsedRealtimeNanos();

        // Flip the mic toggle off
        mDirectReportTestHelper.flipAndAssertMicToggleOff(mUserID, mSensorPrivacyManager);
        long startMicToggleOff = SystemClock.elapsedReal"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/sensor/sensorratepermission/DirectReportAPI30/src/android/sensorratepermission/cts/directreportapi30/DirectReportAPI30Test.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.sensorratepermission.cts.eventconnectionapi30.EventConnectionAPI30Test"	"testSamplingRateMicToggleOff"	""	"1: permission"	"([2:/android/sensorratepermission/cts/eventconnectionapi30/EventConnectionAPI30Test.java]:[permission]:[2]:method_text:[                  > SensorRatePermissionEventConnectionTestHelper.CAPPED_SAMPLE_RATE_HZ);    }   ]) :|: 
    public void testSamplingRateMicToggleOff() throws InterruptedException {
        // Only run this test if minDelay of the sensor is smaller than the capped min delay
        if (mUncappedMinDelayMicros >= mCappedMinDelayMicros) {
            return;
        }

        mEventConnectionTestHelper.flipAndAssertMicToggleOff(mUserID, mSensorPrivacyManager);
        List<TestSensorEvent> events = mEventConnectionTestHelper.getSensorEvents(
                true,
                NUM_EVENTS_COUNT);
        double obtainedRate = SensorRatePermissionEventConnectionTestHelper.computeAvgRate(events,
                Long.MIN_VALUE, Long.MAX_VALUE);

        Assert.assertTrue(mEventConnectionTestHelper.errorWhenBelowExpectedRate(),
                obtainedRate
                        > SensorRatePermissionEventConnectionTestHelper.CAPPED_SAMPLE_RATE_HZ);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/sensor/sensorratepermission/EventConnectionAPI30/src/android/sensorratepermission/cts/eventconnectionapi30/EventConnectionAPI30Test.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.sensorratepermission.cts.eventconnectionapi30.EventConnectionAPI30Test"	"testSamplingRateMicToggleOn"	""	"1: permission"	"([2:/android/sensorratepermission/cts/eventconnectionapi30/EventConnectionAPI30Test.java]:[permission]:[2]:method_text:[     * rate of ongoing SensorEventConnections when the state of the mic toggle changes.     */   ]) :|: 
    public void testSamplingRateMicToggleOn() throws InterruptedException {
        mEventConnectionTestHelper.flipAndAssertMicToggleOn(mUserID, mSensorPrivacyManager);

        List<TestSensorEvent> events = mEventConnectionTestHelper.getSensorEvents(
                true,
                NUM_EVENTS_COUNT);
        double obtainedRate = SensorRatePermissionEventConnectionTestHelper.computeAvgRate(events,
                Long.MIN_VALUE, Long.MAX_VALUE);

        Assert.assertTrue(mEventConnectionTestHelper.errorWhenExceedCappedRate(),
                obtainedRate
                        <= SensorRatePermissionEventConnectionTestHelper.CAPPED_SAMPLE_RATE_HZ);
    }

    /**
     * Test the case where a connection is ongoing while the mic toggle changes its state:
     * off -> on -> off. This test is to show that the sensor service is able to cap/uncap the
     * rate of ongoing SensorEventConnections when the state of the mic toggle changes.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/sensor/sensorratepermission/EventConnectionAPI30/src/android/sensorratepermission/cts/eventconnectionapi30/EventConnectionAPI30Test.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.sensorratepermission.cts.eventconnectionapi30.EventConnectionAPI30Test"	"testSamplingRateMicToggleOffOnOff"	""	"1: permission"	"([4:/android/sensorratepermission/cts/eventconnectionapi30/EventConnectionAPI30Test.java]:[permission]:[4]:method_text:[LE_RATE_HZ);        listener.clearEvents();        testSensorManager.unregisterListener();    }]) :|: 
    public void testSamplingRateMicToggleOffOnOff() throws InterruptedException {
        // Only run this test if minDelay of the sensor is smaller than the capped min delay
        if (mUncappedMinDelayMicros >= mCappedMinDelayMicros) {
            return;
        }
        // Start with the mic toggle off
        mEventConnectionTestHelper.flipAndAssertMicToggleOff(mUserID, mSensorPrivacyManager);
        // Register a listener
        TestSensorEventListener listener = new TestSensorEventListener(mTestEnvironment);
        TestSensorManager testSensorManager = new TestSensorManager(mTestEnvironment);
        testSensorManager.registerListener(listener);

        // Flip the mic toggle on and clear all the events so far.
        mEventConnectionTestHelper.flipAndAssertMicToggleOn(mUserID, mSensorPrivacyManager);
        listener.clearEvents();

        // Wait for 1000 events and check the sampling rates.
        CountDownLatch eventLatch = listener.getLatchForSensorEvents(1000 /*numOfEvents*/);
        listener.waitForEvents(eventLatch, 1000 /*numOfEvents*/, false);
        List<TestSensorEvent> events = listener.getCollectedEvents();
        double rateWhenMicToggleOn =
                SensorRatePermissionEventConnectionTestHelper.computeAvgRate(events,
                        Long.MIN_VALUE, Long.MAX_VALUE);
        Assert.assertTrue(mEventConnectionTestHelper.errorWhenExceedCappedRate(),
                rateWhenMicToggleOn
                        <= SensorRatePermissionEventConnectionTestHelper.CAPPED_SAMPLE_RATE_HZ);

        // Flip the mic toggle off, clear all the events so far.
        mEventConnectionTestHelper.flipAndAssertMicToggleOff(mUserID, mSensorPrivacyManager);
        listener.clearEvents();

        // Wait for 2000 events and check the sampling rates.
        eventLatch = listener.getLatchForSensorEvents(2000 /*numOfEvents*/);
        listener.waitForEvents(eventLatch, 2000 /*numOfEvents*/, false);
        events = listener.getCollectedEvent"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/sensor/sensorratepermission/EventConnectionAPI30/src/android/sensorratepermission/cts/eventconnectionapi30/EventConnectionAPI30Test.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.sensorratepermission.cts.returnedrateinfo.ReturnedRateInfoTest"	"getSensorList"	""	"1: permission"	"([4:/android/sensorratepermission/cts/returnedrateinfo/ReturnedRateInfoTest.java]:[permission]:[4]:method_text:[n().getContext();        mSensorManager = context.getSystemService(SensorManager.class);    }   ]) :|: /*
 *.
 */

package android.sensorratepermission.cts.returnedrateinfo;

import android.content.Context;
import android.hardware.Sensor;
import android.hardware.SensorManager;
import android.hardware.cts.helpers.SensorRatePermissionDirectReportTestHelper;
import android.hardware.cts.helpers.SensorRatePermissionEventConnectionTestHelper;

import androidx.test.platform.app.InstrumentationRegistry;

import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;

import java.util.Collection;
import java.util.List;

/**
 * Test output of the following methods when the app targets API level >= S.
 * - getMinDelay()
 * - getSensorList()
 * - getHighestDirectReportRateLevel()
 */
@RunWith(Parameterized.class)
public class ReturnedRateInfoTest {
    private static SensorManager mSensorManager;

    private final int sensorType;

    public ReturnedRateInfoTest(int sensorType) {
        this.sensorType = sensorType;
    }

    @Parameterized.Parameters
    public static Collection cappedSensorTypeSet() {
        return SensorRatePermissionEventConnectionTestHelper.CAPPED_SENSOR_TYPE_SET;
    }

    @Before
    public void setUp() {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        mSensorManager = context.getSystemService(SensorManager.class);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/sensor/sensorratepermission/ReturnedRateInfo/src/android/sensorratepermission/cts/returnedrateinfo/ReturnedRateInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.sensorratepermission.cts.returnedrateinfo.ReturnedRateInfoTest"	"testGetMinDelayMethod"	""	"1: permission"	"([1:/android/sensorratepermission/cts/returnedrateinfo/ReturnedRateInfoTest.java]:[permission]:[1]:method_text:[ller than "" + cappedMinDelayUs + "" (Us)!"",                minDelay >= cappedMinDelayUs);    }   ]) :|: 
    public void testGetMinDelayMethod() {
        int cappedMinDelayUs = 1 * 1000 * 1000
                / SensorRatePermissionEventConnectionTestHelper.CAPPED_SAMPLE_RATE_HZ;

        Sensor s = mSensorManager.getDefaultSensor(sensorType);
        if (s == null) {
            return;
        }
        int minDelay = s.getMinDelay();

        Assert.assertTrue(""Min delay cannot be smaller than "" + cappedMinDelayUs + "" (Us)!"",
                minDelay >= cappedMinDelayUs);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/sensor/sensorratepermission/ReturnedRateInfo/src/android/sensorratepermission/cts/returnedrateinfo/ReturnedRateInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.sensorratepermission.cts.returnedrateinfo.ReturnedRateInfoTest"	"testGetSensorListMethod"	""	"1: permission"	"([1:/android/sensorratepermission/cts/returnedrateinfo/ReturnedRateInfoTest.java]:[permission]:[1]:method_text:[inDelayUs + "" (Us)!"",                    s.getMinDelay() >= cappedMinDelayUs);        }    }   ]) :|: 
    public void testGetSensorListMethod() {
        int cappedMinDelayUs = 1 * 1000 * 1000
                / SensorRatePermissionEventConnectionTestHelper.CAPPED_SAMPLE_RATE_HZ;

        List<Sensor> allSensorList = mSensorManager.getSensorList(sensorType);
        if (allSensorList == null) {
            return;
        }
        for (Sensor s : allSensorList) {
            Assert.assertTrue(""Min delay cannot be smaller than "" + cappedMinDelayUs + "" (Us)!"",
                    s.getMinDelay() >= cappedMinDelayUs);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/sensor/sensorratepermission/ReturnedRateInfo/src/android/sensorratepermission/cts/returnedrateinfo/ReturnedRateInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.sensorratepermission.cts.returnedrateinfo.ReturnedRateInfoTest"	"testGetHighestDirectReportRateLevelMethod"	""	"1: permission"	"([2:/android/sensorratepermission/cts/returnedrateinfo/ReturnedRateInfoTest.java]:[permission]:[2]:method_text:[              <= SensorRatePermissionDirectReportTestHelper.CAPPED_DIRECT_REPORT_RATE_LEVEL);    }]) :|: 
    public void testGetHighestDirectReportRateLevelMethod() {
        Sensor s = mSensorManager.getDefaultSensor(sensorType);
        if (s == null) {
            return;
        }
        int obtainedHighestRateLevel = s.getHighestDirectReportRateLevel();

        Assert.assertTrue(""Highest direct report rate level cannot be larger than ""
                        + SensorRatePermissionDirectReportTestHelper.CAPPED_DIRECT_REPORT_RATE_LEVEL,
                obtainedHighestRateLevel
                        <= SensorRatePermissionDirectReportTestHelper.CAPPED_DIRECT_REPORT_RATE_LEVEL);
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/sensor/sensorratepermission/ReturnedRateInfo/src/android/sensorratepermission/cts/returnedrateinfo/ReturnedRateInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.sensorratepermission.cts.directreportapi31.DirectReportAPI31Test"	"testSamplingRateMicToggleOn"	""	"1: permission"	"([2:/android/sensorratepermission/cts/directreportapi31/DirectReportAPI31Test.java]:[permission]:[2]:method_text:[       obtainedRate <= SensorRatePermissionDirectReportTestHelper.CAPPED_SAMPLE_RATE_HZ);    }   ]) :|: 
    public void testSamplingRateMicToggleOn() throws InterruptedException {
        mDirectReportTestHelper.flipAndAssertMicToggleOn(mUserID, mSensorPrivacyManager);
        List<SensorDirectReportTest.DirectReportSensorEvent> events =
                mDirectReportTestHelper.getSensorEvents(SensorDirectChannel.RATE_VERY_FAST);

        double obtainedRate = SensorRatePermissionDirectReportTestHelper.computeAvgRate(events,
                Long.MIN_VALUE, Long.MAX_VALUE);

        Assert.assertTrue(mDirectReportTestHelper.errorWhenExceedCappedRate(),
                obtainedRate <= SensorRatePermissionDirectReportTestHelper.CAPPED_SAMPLE_RATE_HZ);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/sensor/sensorratepermission/DirectReportAPI31/src/android/sensorratepermission/cts/directreportapi31/DirectReportAPI31Test.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.sensorratepermission.cts.directreportapi31.DirectReportAPI31Test"	"testSamplingRateMicToggleOff"	""	"1: permission"	"([2:/android/sensorratepermission/cts/directreportapi31/DirectReportAPI31Test.java]:[permission]:[2]:method_text:[           obtainedRate <= SensorRatePermissionDirectReportTestHelper.CAPPED_SAMPLE_RATE_HZ);    }]) :|: 
    public void testSamplingRateMicToggleOff() throws InterruptedException {
        mDirectReportTestHelper.flipAndAssertMicToggleOff(mUserID, mSensorPrivacyManager);
        List<SensorDirectReportTest.DirectReportSensorEvent> events =
                mDirectReportTestHelper.getSensorEvents(SensorDirectChannel.RATE_VERY_FAST);

        double obtainedRate = SensorRatePermissionDirectReportTestHelper.computeAvgRate(events,
                Long.MIN_VALUE, Long.MAX_VALUE);

        Assert.assertTrue(mDirectReportTestHelper.errorWhenExceedCappedRate(),
                obtainedRate <= SensorRatePermissionDirectReportTestHelper.CAPPED_SAMPLE_RATE_HZ);
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/sensor/sensorratepermission/DirectReportAPI31/src/android/sensorratepermission/cts/directreportapi31/DirectReportAPI31Test.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.sensorratepermission.cts.eventconnectionapi31.EventConnectionAPI31Test"	"testSamplingRateMicToggleOn"	""	"1: permission"	"([2:/android/sensorratepermission/cts/eventconnectionapi31/EventConnectionAPI31Test.java]:[permission]:[2]:method_text:[                 <= SensorRatePermissionEventConnectionTestHelper.CAPPED_SAMPLE_RATE_HZ);    }   ]) :|: 
    public void testSamplingRateMicToggleOn() throws InterruptedException {
        mEventConnectionTestHelper.flipAndAssertMicToggleOn(mUserID, mSensorPrivacyManager);

        List<TestSensorEvent> events = mEventConnectionTestHelper.getSensorEvents(true,
                NUM_EVENTS_COUNT);

        double obtainedRate = SensorRatePermissionEventConnectionTestHelper.computeAvgRate(events,
                Long.MIN_VALUE, Long.MAX_VALUE);

        Assert.assertTrue(mEventConnectionTestHelper.errorWhenExceedCappedRate(),
                obtainedRate
                        <= SensorRatePermissionEventConnectionTestHelper.CAPPED_SAMPLE_RATE_HZ);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/sensor/sensorratepermission/EventConnectionAPI31/src/android/sensorratepermission/cts/eventconnectionapi31/EventConnectionAPI31Test.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.sensorratepermission.cts.eventconnectionapi31.EventConnectionAPI31Test"	"testSamplingRateMicToggleOff"	""	"1: permission"	"([2:/android/sensorratepermission/cts/eventconnectionapi31/EventConnectionAPI31Test.java]:[permission]:[2]:method_text:[                     <= SensorRatePermissionEventConnectionTestHelper.CAPPED_SAMPLE_RATE_HZ);    }]) :|: 
    public void testSamplingRateMicToggleOff() throws InterruptedException {
        mEventConnectionTestHelper.flipAndAssertMicToggleOff(mUserID, mSensorPrivacyManager);

        List<TestSensorEvent> events = mEventConnectionTestHelper.getSensorEvents(true,
                NUM_EVENTS_COUNT);
        double obtainedRate = SensorRatePermissionEventConnectionTestHelper.computeAvgRate(events,
                Long.MIN_VALUE, Long.MAX_VALUE);

        Assert.assertTrue(mEventConnectionTestHelper.errorWhenExceedCappedRate(),
                obtainedRate
                        <= SensorRatePermissionEventConnectionTestHelper.CAPPED_SAMPLE_RATE_HZ);
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/sensor/sensorratepermission/EventConnectionAPI31/src/android/sensorratepermission/cts/eventconnectionapi31/EventConnectionAPI31Test.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.hardware.cts.SensorParameterRangeTest"	"testAccelerometerRange"	"CtsSensorTestCases"	"1: permission"	"([1:/android/hardware/cts/SensorParameterRangeTest.java]:[permission]:[1]:method_text:[ }    @AppModeFull(reason = ""Instant apps cannot have HIGH_SAMPLING_RATE_SENSORS permission."")   ]) :|: public void testAccelerometerRange() {
        double hifiMaxFrequency = ApiLevelUtil.isAtLeast(Build.VERSION_CODES.N) ?
                ACCELEROMETER_HIFI_MAX_FREQUENCY :
                ACCELEROMETER_HIFI_MAX_FREQUENCY_BEFORE_N;

        double accelerometerMaxFrequency = mIsAutomotive ?
                ACCELEROMETER_AUTOMOTIVE_MAX_FREQUENCY :
                ACCELEROMETER_MAX_FREQUENCY;

        checkSensorRangeAndFrequency(
                Sensor.TYPE_ACCELEROMETER,
                ACCELEROMETER_MAX_RANGE,
                accelerometerMaxFrequency,
                ACCELEROMETER_HIFI_MAX_RANGE,
                ACCELEROMETER_HIFI_MIN_FREQUENCY,
                hifiMaxFrequency);
    }

    @AppModeFull(reason = ""Instant apps cannot have HIGH_SAMPLING_RATE_SENSORS permission."")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/SensorParameterRangeTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.hardware.cts.SensorParameterRangeTest"	"testGyroscopeRange"	"CtsSensorTestCases"	"1: permission"	"([1:/android/hardware/cts/SensorParameterRangeTest.java]:[permission]:[1]:method_text:[ }    @AppModeFull(reason = ""Instant apps cannot have HIGH_SAMPLING_RATE_SENSORS permission."")   ]) :|: public void testGyroscopeRange() {
        double hifiMaxFrequency = ApiLevelUtil.isAtLeast(Build.VERSION_CODES.N) ?
                GYRO_HIFI_MAX_FREQUENCY :
                GYRO_HIFI_MAX_FREQUENCY_BEFORE_N;

        double gyroMaxRange = mIsAutomotive &&
                ApiLevelUtil.isAtLeast(Build.VERSION_CODES.Q) ?
                GYRO_AUTOMOTIVE_MAX_RANGE :
                GYRO_MAX_RANGE;

        double gyroMaxFrequency = mIsAutomotive ?
                GYRO_AUTOMOTIVE_MAX_FREQUENCY :
                GYRO_MAX_FREQUENCY;

        checkSensorRangeAndFrequency(
                Sensor.TYPE_GYROSCOPE,
                gyroMaxRange,
                gyroMaxFrequency,
                GYRO_HIFI_MAX_RANGE,
                GYRO_HIFI_MIN_FREQUENCY,
                hifiMaxFrequency);
    }

    @AppModeFull(reason = ""Instant apps cannot have HIGH_SAMPLING_RATE_SENSORS permission."")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/SensorParameterRangeTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.autofillservice.cts.MultiWindowLoginActivityTest"	"finishAndWaitDestroy"	"CtsAutoFillServiceTestCases"	"1: permission"	"([3:/android/autofillservice/cts/MultiWindowLoginActivityTest.java]:[permission]:[3]:method_text:[tent), have to go through shell command.        runAmStartActivity(activity2.getName());    }   ]) :|: /*
 *.
 */
package android.autofillservice.cts;

import static android.autofillservice.cts.testcore.Helper.ID_PASSWORD;
import static android.autofillservice.cts.testcore.Helper.ID_USERNAME;

import static com.android.compatibility.common.util.ShellUtils.runShellCommand;
import static com.android.compatibility.common.util.ShellUtils.tap;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assume.assumeTrue;

import android.app.Activity;
import android.app.ActivityTaskManager;
import android.autofillservice.cts.activities.LoginActivity;
import android.autofillservice.cts.activities.MultiWindowEmptyActivity;
import android.autofillservice.cts.activities.MultiWindowLoginActivity;
import android.autofillservice.cts.commontests.AutoFillServiceTestCase;
import android.autofillservice.cts.testcore.AutofillActivityTestRule;
import android.autofillservice.cts.testcore.CannedFillResponse;
import android.autofillservice.cts.testcore.Helper;
import android.graphics.Rect;
import android.platform.test.annotations.AppModeFull;
import android.server.wm.TestTaskOrganizer;
import android.view.View;

import com.android.compatibility.common.util.AdoptShellPermissionsRule;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.rules.RuleChain;
import org.junit.rules.TestRule;

import java.util.concurrent.TimeoutException;

@AppModeFull(reason = ""This test requires android.permission.MANAGE_ACTIVITY_TASKS"")
public class MultiWindowLoginActivityTest
        extends AutoFillServiceTestCase.AutoActivityLaunch<MultiWindowLoginActivity> {

    private LoginActivity mActivity;
    private TestTaskOrganizer mTaskOrganizer;

    @Override
    protected AutofillActivityTestRule<MultiWindowLoginActivity> getActivityRule() {
        return new AutofillActivityTestRule<MultiWindowLoginActivity>(
                MultiWindowLoginActivity.class) {
            @Override
            protected void afterActivityLaunched() {
                m"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/autofillservice/src/android/autofillservice/cts/MultiWindowLoginActivityTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.autofillservice.cts.SessionLifecycleTest"	"SessionLifecycleTest"	"CtsAutoFillServiceTestCases"	"1: permission"	"([1:/android/autofillservice/cts/SessionLifecycleTest.java]:[permission]:[1]:method_text:[ystemClock.sleep(WAIT_ACTIVITY_MS);        mUiBot.assertShownByRelativeId(ID_USERNAME);    }   ]) :|: /*
 *.
 */

package android.autofillservice.cts;

import static android.autofillservice.cts.activities.OutOfProcessLoginActivity.getDestroyedMarker;
import static android.autofillservice.cts.activities.OutOfProcessLoginActivity.getStartedMarker;
import static android.autofillservice.cts.activities.OutOfProcessLoginActivity.getStoppedMarker;
import static android.autofillservice.cts.testcore.Helper.ID_LOGIN;
import static android.autofillservice.cts.testcore.Helper.ID_PASSWORD;
import static android.autofillservice.cts.testcore.Helper.ID_USERNAME;
import static android.autofillservice.cts.testcore.Helper.assertTextAndValue;
import static android.autofillservice.cts.testcore.Helper.findNodeByResourceId;
import static android.autofillservice.cts.testcore.Helper.getContext;
import static android.autofillservice.cts.testcore.UiBot.LANDSCAPE;
import static android.autofillservice.cts.testcore.UiBot.PORTRAIT;
import static android.service.autofill.SaveInfo.SAVE_DATA_TYPE_PASSWORD;
import static android.service.autofill.SaveInfo.SAVE_DATA_TYPE_USERNAME;

import static com.android.compatibility.common.util.ShellUtils.runShellCommand;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeFalse;
import static org.junit.Assume.assumeTrue;

import android.app.ActivityManager;
import android.app.PendingIntent;
import android.app.assist.AssistStructure;
import android.autofillservice.cts.activities.EmptyActivity;
import android.autofillservice.cts.activities.LoginActivity;
import android.autofillservice.cts.activities.ManualAuthenticationActivity;
import android.autofillservice.cts.activities.OutOfProcessLoginActivity;
import android.autofillservice.cts.commontests.AutoFillServiceTestCase;
import android.autofillservice.cts.testcore.CannedFillResponse;
import android.autofillservice.cts.testcore.Helper;
import android.autofillservice.cts.testcore.InstrumentedAutoFillService;
imp"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/autofillservice/src/android/autofillservice/cts/SessionLifecycleTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.autofillservice.cts.inline.InlineAugmentedLoginActivityTest"	"testSwitchInputMethod"	"CtsAutoFillServiceTestCases"	"1: permission"	"([1:/android/autofillservice/cts/inline/InlineAugmentedLoginActivityTest.java]:[permission]:[1]:method_text:[FillRequest();        // Confirm new suggestion        mUiBot.assertDatasets(""dude2"");    }   ]) :|: 
    @AppModeFull(reason = ""WRITE_SECURE_SETTING permission can't be grant to instant apps"")
    public void testSwitchInputMethod() throws Exception {
        // Set services
        enableService();
        enableAugmentedService();

        // Set expectations
        final AutofillId usernameId = mActivity.getUsername().getAutofillId();
        sReplier.addResponse(NO_RESPONSE);
        sAugmentedReplier.addResponse(new CannedAugmentedFillResponse.Builder()
                .addInlineSuggestion(new CannedAugmentedFillResponse.Dataset.Builder(""Augment Me"")
                        .setField(usernameId, ""dude"", createInlinePresentation(""dude""))
                        .build())
                .setDataset(new CannedAugmentedFillResponse.Dataset.Builder(""req1"")
                        .build(), usernameId)
                .build());

        // Trigger auto-fill
        mUiBot.selectByRelativeId(ID_USERNAME);
        mUiBot.waitForIdle();
        sReplier.getNextFillRequest();
        sAugmentedReplier.getNextFillRequest();

        // Confirm suggestion
        mUiBot.assertDatasets(""dude"");

        // Trigger IME switch event
        Helper.mockSwitchInputMethod(sContext);
        mUiBot.waitForIdleSync();

        // Set new expectations
        sReplier.addResponse(NO_RESPONSE);
        sAugmentedReplier.addResponse(new CannedAugmentedFillResponse.Builder()
                .addInlineSuggestion(new CannedAugmentedFillResponse.Dataset.Builder(""Augment Me 2"")
                        .setField(usernameId, ""dude2"", createInlinePresentation(""dude2""))
                        .build())
                .setDataset(new CannedAugmentedFillResponse.Dataset.Builder(""req2"")
                        .build(), usernameId)
                .build());

        // Trigger auto-fill
        mUiBot.selectByRelativeId(ID_USERNAME);
        mUiBot.waitForIdle();
        sReplier.getNextFillRequest();
        sAugmentedReplier.getNextFillRequest();

        // Confirm new suggestion"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/autofillservice/src/android/autofillservice/cts/inline/InlineAugmentedLoginActivityTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.autofillservice.cts.inline.InlineAugmentedLoginActivityTest"	"testSwitchInputMethod_mainServiceDisabled"	"CtsAutoFillServiceTestCases"	"1: permission"	"([1:/android/autofillservice/cts/inline/InlineAugmentedLoginActivityTest.java]:[permission]:[1]:method_text:[extFillRequest();        // Confirm new suggestion        mUiBot.assertDatasets(""dude2"");    }}]) :|: 
    @AppModeFull(reason = ""WRITE_SECURE_SETTING permission can't be grant to instant apps"")
    public void testSwitchInputMethod_mainServiceDisabled() throws Exception {
        // Set services
        Helper.disableAutofillService(sContext);
        enableAugmentedService();

        // Set expectations
        final AutofillId usernameId = mActivity.getUsername().getAutofillId();
        sAugmentedReplier.addResponse(new CannedAugmentedFillResponse.Builder()
                .addInlineSuggestion(new CannedAugmentedFillResponse.Dataset.Builder(""Augment Me"")
                        .setField(usernameId, ""dude"", createInlinePresentation(""dude""))
                        .build())
                .setDataset(new CannedAugmentedFillResponse.Dataset.Builder(""req1"")
                        .build(), usernameId)
                .build());

        // Trigger auto-fill
        mUiBot.selectByRelativeId(ID_USERNAME);
        mUiBot.waitForIdle();
        sAugmentedReplier.getNextFillRequest();

        // Confirm suggestion
        mUiBot.assertDatasets(""dude"");

        // Trigger IME switch event
        Helper.mockSwitchInputMethod(sContext);
        mUiBot.waitForIdleSync();

        sAugmentedReplier.addResponse(new CannedAugmentedFillResponse.Builder()
                .addInlineSuggestion(new CannedAugmentedFillResponse.Dataset.Builder(""Augment Me 2"")
                        .setField(usernameId, ""dude2"", createInlinePresentation(""dude2""))
                        .build())
                .setDataset(new CannedAugmentedFillResponse.Dataset.Builder(""req2"")
                        .build(), usernameId)
                .build());

        // Trigger auto-fill
        mUiBot.selectByRelativeId(ID_USERNAME);
        mUiBot.waitForIdle();

        // Confirm new fill request
        sAugmentedReplier.getNextFillRequest();

        // Confirm new suggestion
        mUiBot.assertDatasets(""dude2"");
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/autofillservice/src/android/autofillservice/cts/inline/InlineAugmentedLoginActivityTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.autofillservice.cts.inline.InlineLoginActivityTest"	"testSwitchInputMethod"	"CtsAutoFillServiceTestCases"	"1: permission"	"([1:/android/autofillservice/cts/inline/InlineLoginActivityTest.java]:[permission]:[1]:method_text:[Username 2"");        // Confirm new fill request        sReplier.getNextFillRequest();    }   ]) :|: 
    @AppModeFull(reason = ""WRITE_SECURE_SETTING permission can't be grant to instant apps"")
    public void testSwitchInputMethod() throws Exception {
        // Set service
        enableService();

        final CannedFillResponse.Builder builder = new CannedFillResponse.Builder()
                .addDataset(new CannedFillResponse.CannedDataset.Builder()
                        .setField(ID_USERNAME, ""dude"")
                        .setPresentation(createPresentation(""The Username""))
                        .setInlinePresentation(createInlinePresentation(""The Username""))
                        .build());

        sReplier.addResponse(builder.build());

        // Trigger auto-fill
        mUiBot.selectByRelativeId(ID_USERNAME);
        mUiBot.waitForIdleSync();

        mUiBot.assertDatasets(""The Username"");

        sReplier.getNextFillRequest();

        // Trigger IME switch event
        Helper.mockSwitchInputMethod(sContext);
        mUiBot.waitForIdleSync();

        final CannedFillResponse.Builder builder2 = new CannedFillResponse.Builder()
                .addDataset(new CannedFillResponse.CannedDataset.Builder()
                        .setField(ID_USERNAME, ""dude2"")
                        .setPresentation(createPresentation(""The Username 2""))
                        .setInlinePresentation(createInlinePresentation(""The Username 2""))
                        .build());

        sReplier.addResponse(builder2.build());

        // Trigger auto-fill
        mUiBot.selectByRelativeId(ID_USERNAME);
        mUiBot.waitForIdleSync();

        // Confirm new suggestion
        mUiBot.assertDatasets(""The Username 2"");

        // Confirm new fill request
        sReplier.getNextFillRequest();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/autofillservice/src/android/autofillservice/cts/inline/InlineLoginActivityTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.autofillservice.cts.dropdown.LoginActivityTest"	"testPopupGoesAwayWhenServiceIsChanged"	"CtsAutoFillServiceTestCases"	"1: permission"	"([1:/android/autofillservice/cts/dropdown/LoginActivityTest.java]:[permission]:[1]:method_text:[0682223): add a new test to make sure service with BIND_AUTOFILL permission works    @Presubmit   ]) :|: 
    public void testPopupGoesAwayWhenServiceIsChanged() throws Exception {
        // Set service.
        enableService();

        // Set expectations.
        sReplier.addResponse(new CannedDataset.Builder()
                .setField(ID_USERNAME, ""dude"")
                .setField(ID_PASSWORD, ""sweet"")
                .setPresentation(createPresentation(""The Dude""))
                .build());
        mActivity.expectAutoFill(""dude"", ""sweet"");

        // Trigger auto-fill.
        requestFocusOnUsername();
        sReplier.getNextFillRequest();
        mUiBot.assertDatasets(""The Dude"");

        // Now disable service by setting another service
        Helper.enableAutofillService(mContext, NoOpAutofillService.SERVICE_NAME);

        // ...and make sure popup's gone
        mUiBot.assertNoDatasets();
    }

    // TODO(b/70682223): add a new test to make sure service with BIND_AUTOFILL permission works
    @Presubmit"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/autofillservice/src/android/autofillservice/cts/dropdown/LoginActivityTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.autofillservice.cts.dropdown.LoginActivityTest"	"testSwitchInputMethod_noNewFillRequest"	"CtsAutoFillServiceTestCases"	"1: permission"	"([1:/android/autofillservice/cts/dropdown/LoginActivityTest.java]:[permission]:[1]:method_text:[he Dude"");        // No new fill request        sReplier.assertNoUnhandledFillRequests();    }}]) :|: 
    @AppModeFull(reason = ""WRITE_SECURE_SETTING permission can't be grant to instant apps"")
    public void testSwitchInputMethod_noNewFillRequest() throws Exception {
        // TODO(b/187664861): Find better solution for small display device.
        mUiBot.assumeMinimumResolution(500);

        // Set service
        enableService();

        // Set expectations
        final CannedFillResponse.Builder builder = new CannedFillResponse.Builder()
                .addDataset(new CannedDataset.Builder()
                        .setField(ID_USERNAME, ""dude"")
                        .setField(ID_PASSWORD, ""sweet"")
                        .setPresentation(createPresentation(""The Dude""))
                        .build());
        sReplier.addResponse(builder.build());

        // Trigger auto-fill
        mActivity.onUsername(View::requestFocus);
        sReplier.getNextFillRequest();

        mUiBot.assertDatasetsContains(""The Dude"");

        // Trigger IME switch event
        Helper.mockSwitchInputMethod(sContext);
        mUiBot.waitForIdleSync();

        // Tap password field
        mUiBot.selectByRelativeId(ID_PASSWORD);
        mUiBot.waitForIdleSync();

        mUiBot.assertDatasetsContains(""The Dude"");

        // No new fill request
        sReplier.assertNoUnhandledFillRequests();
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/autofillservice/src/android/autofillservice/cts/dropdown/LoginActivityTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.DefaultDialerOperationsNoPermissionsTest"	"testShowInCallScreenPermissions"	"CtsTelecomTestCases"	"1: permission"	"([1:/android/telecom/cts/DefaultDialerOperationsNoPermissionsTest.java]:[permission]:[1]:method_text:[   mTelecomManager.showInCallScreen(false);            }        }, ""showInCallScreen"");    }   ]) :|: public void testShowInCallScreenPermissions() throws Exception {
        if (!TestUtils.shouldTestTelecom(mContext)) {
            return;
        }
        verifyForReadPhoneStateOrDefaultDialer(new Runnable() {
            @Override
            public void run() {
                mTelecomManager.showInCallScreen(false);
            }
        }, ""showInCallScreen"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom2/src/android/telecom/cts/DefaultDialerOperationsNoPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.DefaultDialerOperationsNoPermissionsTest"	"testGetCallCapableAccountsPermissions"	"CtsTelecomTestCases"	"1: permission"	"([1:/android/telecom/cts/DefaultDialerOperationsNoPermissionsTest.java]:[permission]:[1]:method_text:[anager.getCallCapablePhoneAccounts();            }        }, ""getCallCapableAccounts"");    }   ]) :|: public void testGetCallCapableAccountsPermissions() throws Exception {
        if (!TestUtils.shouldTestTelecom(mContext)) {
            return;
        }
        verifyForReadPhoneStateOrDefaultDialer(new Runnable() {
            @Override
            public void run() {
                mTelecomManager.getCallCapablePhoneAccounts();
            }
        }, ""getCallCapableAccounts"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom2/src/android/telecom/cts/DefaultDialerOperationsNoPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.DefaultDialerOperationsNoPermissionsTest"	"testIsInCall"	"CtsTelecomTestCases"	"1: permission"	"([1:/android/telecom/cts/DefaultDialerOperationsNoPermissionsTest.java]:[permission]:[1]:method_text:[TestUtils.setDefaultDialer(getInstrumentation(), TestUtils.PACKAGE);        runnable.run();    }}]) :|: public void testIsInCall() throws Exception {
        if (!TestUtils.shouldTestTelecom(mContext)) {
            return;
        }
        verifyForReadPhoneStateOrDefaultDialer(new Runnable() {
            @Override
            public void run() {
                mTelecomManager.isInCall();
            }
        }, ""isInCall"");
    }

    private void verifyForReadPhoneStateOrDefaultDialer(Runnable runnable, String methodName)
            throws Exception{
        try {
            runnable.run();
            fail(""TelecomManager."" + methodName + "" should throw SecurityException if no ""
                    + ""READ_PHONE_STATE permission"");
        } catch (SecurityException e) {
        }

        TestUtils.setDefaultDialer(getInstrumentation(), TestUtils.PACKAGE);
        runnable.run();
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom2/src/android/telecom/cts/DefaultDialerOperationsNoPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.TelecomManagerNoPermissionsTest"	"testCannotEndCall"	"CtsTelecomTestCases"	"1: permission"	"([1:/android/telecom/cts/TelecomManagerNoPermissionsTest.java]:[permission]:[1]:method_text:[l endCall without permission grant."");        } catch (SecurityException se) {        }    }   ]) :|: public void testCannotEndCall() throws Exception {
        if (!TestUtils.shouldTestTelecom(mContext)) {
            return;
        }
        try {
            mTelecomManager.endCall();
            fail(""Shouldn't be able to call endCall without permission grant."");
        } catch (SecurityException se) {
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom2/src/android/telecom/cts/TelecomManagerNoPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.TelecomManagerNoPermissionsTest"	"testCallStateCompatPermissions"	"CtsTelecomTestCases"	"1: permission"	"([4:/android/telecom/cts/TelecomManagerNoPermissionsTest.java]:[permission]:[4]:method_text:[                 TestUtils.ENABLE_GET_CALL_STATE_PERMISSION_PROTECTION_STRING);        }    }   ]) :|: public void testCallStateCompatPermissions() throws Exception {
        if (!TestUtils.shouldTestTelecom(mContext)) {
            return;
        }

        try {
            TelecomManager tm = mContext.getSystemService(TelecomManager.class);
            assertNotNull(tm);

            TestUtils.enableCompatCommand(getInstrumentation(),
                    TestUtils.ENABLE_GET_CALL_STATE_PERMISSION_PROTECTION_STRING);
            try {

                tm.getCallState();
                fail(""TelecomManager#getCallState must require READ_PHONE_STATE when ""
                        + ""TelecomManager#ENABLE_GET_CALL_STATE_PERMISSION_PROTECTION is enabled"");
            } catch (SecurityException e) {
                // expected
            }
        } finally {
            TestUtils.resetCompatCommand(getInstrumentation(),
                    TestUtils.ENABLE_GET_CALL_STATE_PERMISSION_PROTECTION_STRING);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom2/src/android/telecom/cts/TelecomManagerNoPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.TelecomManagerNoPermissionsTest"	"testGetPhoneAccountCompatPermissions"	"CtsTelecomTestCases"	"1: permission"	"([4:/android/telecom/cts/TelecomManagerNoPermissionsTest.java]:[permission]:[4]:method_text:[                 TestUtils.ENABLE_GET_PHONE_ACCOUNT_PERMISSION_PROTECTION_STRING);        }    }}]) :|: public void testGetPhoneAccountCompatPermissions() throws Exception {
        if (!TestUtils.shouldTestTelecom(mContext)) {
            return;
        }

        try {
            TestUtils.enableCompatCommand(getInstrumentation(),
                    TestUtils.ENABLE_GET_PHONE_ACCOUNT_PERMISSION_PROTECTION_STRING);

            try {
                mTelecomManager.getPhoneAccount(TestUtils.TEST_DEFAULT_PHONE_ACCOUNT_HANDLE_1);
                fail(""TelecomManager#getPhoneAccount should require READ_PHONE_NUMBERS or ""
                        + ""READ_PRIVILEGED_PHONE_STATE when ""
                        + ""ENABLE_GET_PHONE_ACCOUNT_PERMISSION_PROTECTION is enabled"");
            } catch (SecurityException e) {
                //expected
            }
        } finally {
            TestUtils.resetCompatCommand(getInstrumentation(),
                    TestUtils.ENABLE_GET_PHONE_ACCOUNT_PERMISSION_PROTECTION_STRING);
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom2/src/android/telecom/cts/TelecomManagerNoPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.security.SELinuxTargetSdkTest"	"testDex2oat"	"CtsSelinuxTargetSdkCurrentTestCases"	"1: permission permission permission permission"	"([1:/android/security/SELinuxTargetSdkTest.java]:[permission]:[1]:method_text:[opertyUtil.isVendorApiLevelNewerThan(28)) {            checkDex2oatAccess(false);        }    }}]) :|: public void testDex2oat() throws Exception {
        /*
         * Apps with a vendor image older than Q may access the dex2oat executable through
         * selinux policy on the vendor partition because the permission was granted in public
         * policy for appdomain.
         */
        if (PropertyUtil.isVendorApiLevelNewerThan(28)) {
            checkDex2oatAccess(false);
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/selinux/selinuxTargetSdkCurrent/src/android/security/SELinuxTargetSdkTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.systemintents.cts.TestManageOverlayPermissionIntents"	"testStartManageAppOverlayPermissionIntent_whenCallerHasPermission_succeedsOrThrowsActivityNotFound"	"CtsSystemIntentTestCases"	"1: permission"	"([8:/android/systemintents/cts/TestManageOverlayPermissionIntents.java]:[permission]:[8]:method_text:[nt            }        });        // ActivityNotFoundException or no exception thrown    }   ]) :|: 
    public void testStartManageAppOverlayPermissionIntent_whenCallerHasPermission_succeedsOrThrowsActivityNotFound() {
        Intent intent = new Intent(Settings.ACTION_MANAGE_APP_OVERLAY_PERMISSION);
        intent.setData(Uri.fromParts(""package"", mContext.getPackageName(), null));
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        SystemUtil.runWithShellPermissionIdentity(() -> {
            assertEquals(""Shell must have INTERNAL_SYSTEM_WINDOW permission to run test"",
                    PackageManager.PERMISSION_GRANTED,
                    mContext.checkSelfPermission(PERMISSION_INTERNAL_SYSTEM_WINDOW));

            try {
                mContext.startActivity(intent);
            } catch (ActivityNotFoundException e) {
                // Fall through - it's allowed to not handle the intent
            }
        });

        // ActivityNotFoundException or no exception thrown
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/systemintents/src/android/systemintents/cts/TestManageOverlayPermissionIntents.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.systemintents.cts.TestManageOverlayPermissionIntents"	"testStartManageAppOverlayPermissionIntent_whenCallerDoesNotHavePermission_throwsSecurityExceptionOrActivityNotFound"	"CtsSystemIntentTestCases"	"1: permission"	"([3:/android/systemintents/cts/TestManageOverlayPermissionIntents.java]:[permission]:[3]:method_text:[   assertTrue(e instanceof ActivityNotFoundException || e instanceof SecurityException);    }   ]) :|: 
    public void testStartManageAppOverlayPermissionIntent_whenCallerDoesNotHavePermission_throwsSecurityExceptionOrActivityNotFound() {
        Intent intent = new Intent(Settings.ACTION_MANAGE_APP_OVERLAY_PERMISSION);
        intent.setData(Uri.fromParts(""package"", mContext.getPackageName(), null));
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        RuntimeException e = expectThrows(RuntimeException.class,
                () -> mContext.startActivity(intent));

        assertTrue(e instanceof ActivityNotFoundException || e instanceof SecurityException);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/systemintents/src/android/systemintents/cts/TestManageOverlayPermissionIntents.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.systemintents.cts.TestManageOverlayPermissionIntents"	"testManageOverlayPermissionIntentWithDataResolvesToSameIntentWithoutData"	"CtsSystemIntentTestCases"	"1: permission"	"([4:/android/systemintents/cts/TestManageOverlayPermissionIntents.java]:[permission]:[4]:method_text:[ty.packageName);        assertEquals(errorMessage, genericActivity.name, appActivity.name);    }}]) :|: 
    public void testManageOverlayPermissionIntentWithDataResolvesToSameIntentWithoutData() {
        Intent genericIntent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION);
        Intent appSpecificIntent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION);
        appSpecificIntent.setData(Uri.fromParts(""package"", mContext.getPackageName(), null));

        ResolveInfo genericResolveInfo = mPackageManager.resolveActivity(genericIntent, 0);
        ResolveInfo appSpecificResolveInfo = mPackageManager.resolveActivity(appSpecificIntent, 0);

        String errorMessage =
                ""ACTION_MANAGE_OVERLAY_PERMISSION intent with data and without data should ""
                        + ""resolve to the same activity"";
        if (genericResolveInfo == null) {
            assertNull(errorMessage, appSpecificResolveInfo);
            return;
        }
        assertNotNull(errorMessage, appSpecificResolveInfo);
        ActivityInfo genericActivity = genericResolveInfo.activityInfo;
        ActivityInfo appActivity = appSpecificResolveInfo.activityInfo;
        assertEquals(errorMessage, genericActivity.packageName, appActivity.packageName);
        assertEquals(errorMessage, genericActivity.name, appActivity.name);
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/systemintents/src/android/systemintents/cts/TestManageOverlayPermissionIntents.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"testTargetingSdk22DefaultWhitelistedHasFullAccess"	"CtsPermission2TestCases"	"1: permission"	"([2:/android/permission2/cts/RestrictedStoragePermissionTest.java]:[permission]:[2]:method_text:[issions*/);        // Check expected storage mode        assertHasFullStorageAccess();    }   ]) :|: 
    @AppModeFull
    public void testTargetingSdk22DefaultWhitelistedHasFullAccess() throws Exception {
        // Install with whitelisted permissions.
        installApp(APK_USES_STORAGE_DEFAULT_22, null /*whitelistedPermissions*/);

        // Check expected storage mode
        assertHasFullStorageAccess();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"testTargetingSdk22OptInWhitelistedHasIsolatedAccess"	"CtsPermission2TestCases"	"1: permission"	"([2:/android/permission2/cts/RestrictedStoragePermissionTest.java]:[permission]:[2]:method_text:[ons*/);        // Check expected storage mode        assertHasIsolatedStorageAccess();    }   ]) :|: 
    @AppModeFull
    public void testTargetingSdk22OptInWhitelistedHasIsolatedAccess() throws Exception {
        // Install with whitelisted permissions.
        installApp(APK_USES_STORAGE_OPT_IN_22, null /*whitelistedPermissions*/);

        // Check expected storage mode
        assertHasIsolatedStorageAccess();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"testTargetingSdk28DefaultWhitelistedHasFullAccess"	"CtsPermission2TestCases"	"1: permission"	"([2:/android/permission2/cts/RestrictedStoragePermissionTest.java]:[permission]:[2]:method_text:[issions*/);        // Check expected storage mode        assertHasFullStorageAccess();    }   ]) :|: 
    @AppModeFull
    public void testTargetingSdk28DefaultWhitelistedHasFullAccess() throws Exception {
        // Install with whitelisted permissions.
        installApp(APK_USES_STORAGE_DEFAULT_28, null /*whitelistedPermissions*/);

        // Check expected storage mode
        assertHasFullStorageAccess();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"testTargetingSdk28OptInWhitelistedHasIsolatedAccess"	"CtsPermission2TestCases"	"1: permission"	"([2:/android/permission2/cts/RestrictedStoragePermissionTest.java]:[permission]:[2]:method_text:[ons*/);        // Check expected storage mode        assertHasIsolatedStorageAccess();    }   ]) :|: 
    @AppModeFull
    public void testTargetingSdk28OptInWhitelistedHasIsolatedAccess() throws Exception {
        // Install with whitelisted permissions.
        installApp(APK_USES_STORAGE_OPT_IN_28, null /*whitelistedPermissions*/);

        // Check expected storage mode
        assertHasIsolatedStorageAccess();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"testTargetingSdk29DefaultWhitelistedHasIsolatedAccess"	"CtsPermission2TestCases"	"1: permission"	"([1:/android/permission2/cts/RestrictedStoragePermissionTest.java]:[permission]:[1]:method_text:[Set());        // Check expected storage mode        assertHasIsolatedStorageAccess();    }   ]) :|: 
    @AppModeFull
    public void testTargetingSdk29DefaultWhitelistedHasIsolatedAccess() throws Exception {
        // Install with whitelisted permissions.
        installApp(APK_USES_STORAGE_DEFAULT_29, Collections.emptySet());

        // Check expected storage mode
        assertHasIsolatedStorageAccess();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"testTargetingSdk29DefaultNotWhitelistedHasIsolatedAccess"	"CtsPermission2TestCases"	"1: permission"	"([2:/android/permission2/cts/RestrictedStoragePermissionTest.java]:[permission]:[2]:method_text:[ons*/);        // Check expected storage mode        assertHasIsolatedStorageAccess();    }   ]) :|: 
    @AppModeFull
    public void testTargetingSdk29DefaultNotWhitelistedHasIsolatedAccess() throws Exception {
        // Install with no whitelisted permissions.
        installApp(APK_USES_STORAGE_DEFAULT_29, null /*whitelistedPermissions*/);

        // Check expected storage mode
        assertHasIsolatedStorageAccess();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"testTargetingSdk29OptOutWhitelistedHasFullAccess"	"CtsPermission2TestCases"	"1: permission"	"([2:/android/permission2/cts/RestrictedStoragePermissionTest.java]:[permission]:[2]:method_text:[issions*/);        // Check expected storage mode        assertHasFullStorageAccess();    }   ]) :|: 
    @AppModeFull
    public void testTargetingSdk29OptOutWhitelistedHasFullAccess() throws Exception {
        // Install with whitelisted permissions.
        installApp(APK_USES_STORAGE_OPT_OUT_29, null /*whitelistedPermissions*/);

        // Check expected storage mode
        assertHasFullStorageAccess();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"testTargetingSdk29OptOutNotWhitelistedHasIsolatedAccess"	"CtsPermission2TestCases"	"1: permission"	"([1:/android/permission2/cts/RestrictedStoragePermissionTest.java]:[permission]:[1]:method_text:[Set());        // Check expected storage mode        assertHasIsolatedStorageAccess();    }   ]) :|: 
    @AppModeFull
    public void testTargetingSdk29OptOutNotWhitelistedHasIsolatedAccess() throws Exception {
        // Install with no whitelisted permissions.
        installApp(APK_USES_STORAGE_OPT_OUT_29, Collections.emptySet());

        // Check expected storage mode
        assertHasIsolatedStorageAccess();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"testCannotControlStorageWhitelistPostInstall1"	"CtsPermission2TestCases"	"1: permission"	"([3:/android/permission2/cts/RestrictedStoragePermissionTest.java]:[permission]:[3]:method_text:[Check expected state of restricted permissions.        assertCannotUnWhitelistStorage();    }   ]) :|: 
    @AppModeFull
    public void testCannotControlStorageWhitelistPostInstall1() throws Exception {
        // Install with whitelisted permissions.
        installApp(APK_USES_STORAGE_DEFAULT_28, null /*whitelistedPermissions*/);

        // Check expected state of restricted permissions.
        assertCannotUnWhitelistStorage();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"testCannotControlStorageWhitelistPostInstall2"	"CtsPermission2TestCases"	"1: permission"	"([2:/android/permission2/cts/RestrictedStoragePermissionTest.java]:[permission]:[2]:method_text:[/ Check expected state of restricted permissions.        assertCannotWhitelistStorage();    }   ]) :|: 
    @AppModeFull
    public void testCannotControlStorageWhitelistPostInstall2() throws Exception {
        // Install with no whitelisted permissions.
        installApp(APK_USES_STORAGE_DEFAULT_28, Collections.emptySet());

        // Check expected state of restricted permissions.
        assertCannotWhitelistStorage();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"cannotGrantStorageTargetingSdk22NotWhitelisted"	"CtsPermission2TestCases"	"1: permission"	"([6:/android/permission2/cts/RestrictedStoragePermissionTest.java]:[permission]:[6]:method_text:[G, Manifest.permission.READ_EXTERNAL_STORAGE))                    .isTrue();        });    }   ]) :|: 
    @AppModeFull
    public void cannotGrantStorageTargetingSdk22NotWhitelisted() throws Exception {
        // Install with no whitelisted permissions.
        installApp(APK_USES_STORAGE_DEFAULT_22, Collections.emptySet());

        eventually(() -> {
            // Could not grant permission+app-op as targetSDK<29 and not whitelisted
            assertThat(isGranted(PKG, Manifest.permission.READ_EXTERNAL_STORAGE)).isFalse();

            // Permissions are always granted for pre-23 apps
            assertThat(isPermissionGranted(PKG, Manifest.permission.READ_EXTERNAL_STORAGE))
                    .isTrue();
        });
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"cannotGrantStorageTargetingSdk22OptInNotWhitelisted"	"CtsPermission2TestCases"	"1: permission"	"([6:/android/permission2/cts/RestrictedStoragePermissionTest.java]:[permission]:[6]:method_text:[G, Manifest.permission.READ_EXTERNAL_STORAGE))                    .isTrue();        });    }   ]) :|: 
    @AppModeFull
    public void cannotGrantStorageTargetingSdk22OptInNotWhitelisted() throws Exception {
        // Install with no whitelisted permissions.
        installApp(APK_USES_STORAGE_OPT_IN_22, Collections.emptySet());

        eventually(() -> {
            // Could not grant permission as targetSDK<29 and not whitelisted
            assertThat(isGranted(PKG, Manifest.permission.READ_EXTERNAL_STORAGE)).isFalse();

            // Permissions are always granted for pre-23 apps
            assertThat(isPermissionGranted(PKG, Manifest.permission.READ_EXTERNAL_STORAGE))
                    .isTrue();
        });
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"canGrantStorageTargetingSdk22Whitelisted"	"CtsPermission2TestCases"	"1: permission"	"([3:/android/permission2/cts/RestrictedStoragePermissionTest.java]:[permission]:[3]:method_text:[         assertThat(isGranted(PKG, Manifest.permission.READ_EXTERNAL_STORAGE)).isTrue());    }   ]) :|: 
    @AppModeFull
    public void canGrantStorageTargetingSdk22Whitelisted() throws Exception {
        // Install with whitelisted permissions.
        installApp(APK_USES_STORAGE_DEFAULT_22, null);

        // Could grant permission
        eventually(() ->
                assertThat(isGranted(PKG, Manifest.permission.READ_EXTERNAL_STORAGE)).isTrue());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"canGrantStorageTargetingSdk22OptInWhitelisted"	"CtsPermission2TestCases"	"1: permission"	"([3:/android/permission2/cts/RestrictedStoragePermissionTest.java]:[permission]:[3]:method_text:[         assertThat(isGranted(PKG, Manifest.permission.READ_EXTERNAL_STORAGE)).isTrue());    }   ]) :|: 
    @AppModeFull
    public void canGrantStorageTargetingSdk22OptInWhitelisted() throws Exception {
        // Install with whitelisted permissions.
        installApp(APK_USES_STORAGE_OPT_IN_22, null);

        // Could grant permission
        eventually(() ->
                assertThat(isGranted(PKG, Manifest.permission.READ_EXTERNAL_STORAGE)).isTrue());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"cannotGrantStorageTargetingSdk28NotWhitelisted"	"CtsPermission2TestCases"	"1: permission"	"([3:/android/permission2/cts/RestrictedStoragePermissionTest.java]:[permission]:[3]:method_text:[        assertThat(isGranted(PKG, Manifest.permission.READ_EXTERNAL_STORAGE)).isFalse());    }   ]) :|: 
    @AppModeFull
    public void cannotGrantStorageTargetingSdk28NotWhitelisted() throws Exception {
        // Install with no whitelisted permissions.
        installApp(APK_USES_STORAGE_DEFAULT_28, Collections.emptySet());

        // Could not grant permission as targetSDK<29 and not whitelisted
        eventually(() ->
                assertThat(isGranted(PKG, Manifest.permission.READ_EXTERNAL_STORAGE)).isFalse());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"cannotGrantStorageTargetingSdk28OptInNotWhitelisted"	"CtsPermission2TestCases"	"1: permission"	"([3:/android/permission2/cts/RestrictedStoragePermissionTest.java]:[permission]:[3]:method_text:[        assertThat(isGranted(PKG, Manifest.permission.READ_EXTERNAL_STORAGE)).isFalse());    }   ]) :|: 
    @AppModeFull
    public void cannotGrantStorageTargetingSdk28OptInNotWhitelisted() throws Exception {
        // Install with no whitelisted permissions.
        installApp(APK_USES_STORAGE_OPT_IN_28, Collections.emptySet());

        // Could not grant permission as targetSDK<29 and not whitelisted
        eventually(() ->
                assertThat(isGranted(PKG, Manifest.permission.READ_EXTERNAL_STORAGE)).isFalse());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"canGrantStorageTargetingSdk28Whitelisted"	"CtsPermission2TestCases"	"1: permission"	"([3:/android/permission2/cts/RestrictedStoragePermissionTest.java]:[permission]:[3]:method_text:[         assertThat(isGranted(PKG, Manifest.permission.READ_EXTERNAL_STORAGE)).isTrue());    }   ]) :|: 
    @AppModeFull
    public void canGrantStorageTargetingSdk28Whitelisted() throws Exception {
        // Install with whitelisted permissions.
        installApp(APK_USES_STORAGE_DEFAULT_28, null);

        // Could grant permission
        eventually(() ->
                assertThat(isGranted(PKG, Manifest.permission.READ_EXTERNAL_STORAGE)).isTrue());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"canGrantStorageTargetingSdk28OptInWhitelisted"	"CtsPermission2TestCases"	"1: permission"	"([3:/android/permission2/cts/RestrictedStoragePermissionTest.java]:[permission]:[3]:method_text:[         assertThat(isGranted(PKG, Manifest.permission.READ_EXTERNAL_STORAGE)).isTrue());    }   ]) :|: 
    @AppModeFull
    public void canGrantStorageTargetingSdk28OptInWhitelisted() throws Exception {
        // Install with whitelisted permissions.
        installApp(APK_USES_STORAGE_OPT_IN_28, null);

        // Could grant permission
        eventually(() ->
                assertThat(isGranted(PKG, Manifest.permission.READ_EXTERNAL_STORAGE)).isTrue());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"canGrantStorageTargetingSdk29NotWhitelisted"	"CtsPermission2TestCases"	"1: permission"	"([3:/android/permission2/cts/RestrictedStoragePermissionTest.java]:[permission]:[3]:method_text:[         assertThat(isGranted(PKG, Manifest.permission.READ_EXTERNAL_STORAGE)).isTrue());    }   ]) :|: 
    @AppModeFull
    public void canGrantStorageTargetingSdk29NotWhitelisted() throws Exception {
        // Install with no whitelisted permissions.
        installApp(APK_USES_STORAGE_DEFAULT_29, Collections.emptySet());

        // Could grant permission as targetSDK=29 apps can always grant
        eventually(() ->
                assertThat(isGranted(PKG, Manifest.permission.READ_EXTERNAL_STORAGE)).isTrue());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"canGrantStorageTargetingSdk29OptOutNotWhitelisted"	"CtsPermission2TestCases"	"1: permission"	"([3:/android/permission2/cts/RestrictedStoragePermissionTest.java]:[permission]:[3]:method_text:[         assertThat(isGranted(PKG, Manifest.permission.READ_EXTERNAL_STORAGE)).isTrue());    }   ]) :|: 
    @AppModeFull
    public void canGrantStorageTargetingSdk29OptOutNotWhitelisted() throws Exception {
        // Install with no whitelisted permissions.
        installApp(APK_USES_STORAGE_OPT_OUT_29, Collections.emptySet());

        // Could grant permission as targetSDK=29 apps can always grant
        eventually(() ->
                assertThat(isGranted(PKG, Manifest.permission.READ_EXTERNAL_STORAGE)).isTrue());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"canGrantStorageTargetingSdk29Whitelisted"	"CtsPermission2TestCases"	"1: permission"	"([3:/android/permission2/cts/RestrictedStoragePermissionTest.java]:[permission]:[3]:method_text:[         assertThat(isGranted(PKG, Manifest.permission.READ_EXTERNAL_STORAGE)).isTrue());    }   ]) :|: 
    @AppModeFull
    public void canGrantStorageTargetingSdk29Whitelisted() throws Exception {
        // Install with whitelisted permissions.
        installApp(APK_USES_STORAGE_DEFAULT_29, null);

        // Could grant permission as targetSDK=29 apps can always grant
        eventually(() ->
                assertThat(isGranted(PKG, Manifest.permission.READ_EXTERNAL_STORAGE)).isTrue());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"canGrantStorageTargetingSdk29OptOutWhitelisted"	"CtsPermission2TestCases"	"1: permission"	"([3:/android/permission2/cts/RestrictedStoragePermissionTest.java]:[permission]:[3]:method_text:[         assertThat(isGranted(PKG, Manifest.permission.READ_EXTERNAL_STORAGE)).isTrue());    }   ]) :|: 
    @AppModeFull
    public void canGrantStorageTargetingSdk29OptOutWhitelisted() throws Exception {
        // Install with whitelisted permissions.
        installApp(APK_USES_STORAGE_OPT_OUT_29, null);

        // Could grant permission as targetSDK=29 apps can always grant
        eventually(() ->
                assertThat(isGranted(PKG, Manifest.permission.READ_EXTERNAL_STORAGE)).isTrue());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"restrictedWritePermDoesNotImplyIsolatedStorageAccess"	"CtsPermission2TestCases"	"1: permission"	"([2:/android/permission2/cts/RestrictedStoragePermissionTest.java]:[permission]:[2]:method_text:[evel is only        // controlled by the read perm        assertHasFullStorageAccess();    }   ]) :|: 
    @AppModeFull
    public void restrictedWritePermDoesNotImplyIsolatedStorageAccess() throws Exception {
        // Install with whitelisted read permissions.
        installApp(
                APK_USES_STORAGE_OPT_OUT_29,
                Collections.singleton(Manifest.permission.READ_EXTERNAL_STORAGE));

        // It does not matter that write is restricted as the storage access level is only
        // controlled by the read perm
        assertHasFullStorageAccess();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"whitelistedWritePermDoesNotImplyFullStorageAccess"	"CtsPermission2TestCases"	"1: permission"	"([2:/android/permission2/cts/RestrictedStoragePermissionTest.java]:[permission]:[2]:method_text:[ is only        // controlled by the read perm        assertHasIsolatedStorageAccess();    }   ]) :|: 
    @AppModeFull
    public void whitelistedWritePermDoesNotImplyFullStorageAccess() throws Exception {
        // Install with whitelisted read permissions.
        installApp(
                APK_USES_STORAGE_OPT_OUT_29,
                Collections.singleton(Manifest.permission.WRITE_EXTERNAL_STORAGE));

        // It does not matter that write is white listed as the storage access level is only
        // controlled by the read perm
        assertHasIsolatedStorageAccess();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedStoragePermissionTest"	"testStorageTargetingSdk30CannotPreserveLegacyOnInstall"	"CtsPermission2TestCases"	"1: permission"	"([124:/android/permission2/cts/RestrictedStoragePermissionTest.java]:[permission]:[124]:method_text:[    @After    public void uninstallApp() {        runShellCommand(""pm uninstall "" + PKG);    }}]) :|: 
    @AppModeFull
    public void testStorageTargetingSdk30CannotPreserveLegacyOnInstall() throws Exception {
        installApp(APK_USES_STORAGE_PRESERVED_OPT_OUT_30, null);

        assertHasIsolatedStorageAccess();
    }

    private void assertHasFullStorageAccess() throws Exception {
        runWithShellPermissionIdentity(() -> {
            AppOpsManager appOpsManager = getContext().getSystemService(AppOpsManager.class);
            final int uid = getContext().getPackageManager().getPackageUid(PKG, 0);
            eventually(() -> assertThat(appOpsManager.unsafeCheckOpRawNoThrow(
                    AppOpsManager.OPSTR_LEGACY_STORAGE,
                    uid, PKG)).isEqualTo(AppOpsManager.MODE_ALLOWED));
        });
    }

    private void assertHasIsolatedStorageAccess() throws Exception {
        runWithShellPermissionIdentity(() -> {
            AppOpsManager appOpsManager = getContext().getSystemService(AppOpsManager.class);
            final int uid = getContext().getPackageManager().getPackageUid(PKG, 0);
            eventually(() -> assertThat(appOpsManager.unsafeCheckOpRawNoThrow(
                    AppOpsManager.OPSTR_LEGACY_STORAGE,
                    uid, PKG)).isNotEqualTo(AppOpsManager.MODE_ALLOWED));
        });
    }

    private void assertCannotWhitelistStorage() throws Exception {
        final PackageManager packageManager = getContext().getPackageManager();

        runWithShellPermissionIdentity(() -> {
            // Assert added only to none whitelist.
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM
                            | PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE
                            | PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER))
                    .doesNotContain(permission.READ_EXTERNAL_STORAGE);
            assertThat(packageManager.getWhitelistedRestrictedPermissions(PKG,
                    PackageManag"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedStoragePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.NoProcessOutgoingCallPermissionTest"	"testProcessOutgoingCall"	"CtsPermission2TestCases"	"1: permission"	"([1:/android/permission2/cts/NoProcessOutgoingCallPermissionTest.java]:[permission]:[1]:method_text:[);            Log.e(LOG_TAG, xtrs.toString());            callReceived = true;        }    }}]) :|: public void testProcessOutgoingCall() {
        final PackageManager pm = getContext().getPackageManager();
        if (!pm.hasSystemFeature(PackageManager.FEATURE_TELEPHONY) ||
                !pm.hasSystemFeature(PackageManager.FEATURE_SIP_VOIP)) {
            return;
        }

        Log.i(LOG_TAG, ""Beginning testProcessOutgoingCall"");
        OutgoingCallBroadcastReceiver rcvr = new OutgoingCallBroadcastReceiver();
        Intent ntnt = mContext.registerReceiver(rcvr,
            new IntentFilter(Intent.ACTION_NEW_OUTGOING_CALL));
        Log.i(LOG_TAG, ""registerReceiver --> "" + ntnt);
        if (null != ntnt) {
            Bundle xtrs = ntnt.getExtras();
            Log.i(LOG_TAG, ""extras --> "" + xtrs.toString());
        }

        callPhone();
        synchronized(rcvr) {
            try {
                rcvr.wait(WAIT_TIME);
            } catch (InterruptedException e) {
                Log.w(LOG_TAG, ""wait for phone call interrupted"");
            }
        }
        // TODO: Find a way to test that the call was made at all, and assertTrue.
        assertFalse(""Outgoing call processed without proper permissions"", rcvr.callReceived);
    }

    public class OutgoingCallBroadcastReceiver extends BroadcastReceiver {
        public boolean callReceived = false;

        public void onReceive(Context context, Intent intent) {
            Bundle xtrs = intent.getExtras();
            Log.e(LOG_TAG, xtrs.toString());
            callReceived = true;
        }
    }

}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/NoProcessOutgoingCallPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.NoCaptureAudioOutputPermissionTest"	"testCreateAudioRecord"	"CtsPermission2TestCases"	"1: permission"	"([2:/android/permission2/cts/NoCaptureAudioOutputPermissionTest.java]:[permission]:[2]:method_text:[ AudioRecord.STATE_INITIALIZED);        } finally {            record.release();        }    }}]) :|: public void testCreateAudioRecord() {
        int bufferSize = AudioRecord.getMinBufferSize(44100,
                AudioFormat.CHANNEL_IN_STEREO, AudioFormat.ENCODING_PCM_16BIT);

        if (bufferSize <= 0)
        {
            // getMinBufferSize() returns an invalid buffer size.
            // That could be because there is no microphone.  In that case,
            // use this buffer size to test AudioRecord creation.
            PackageManager packageManager = mContext.getPackageManager();
            if (!packageManager.hasSystemFeature(PackageManager.FEATURE_MICROPHONE)) {
                bufferSize = 44100;
            }
        }

        // The attempt to create the AudioRecord object succeeds even if the
        // app does not have permission, but the object is not usable.
        // The API should probably throw SecurityException but it was not originally
        // designed to do that and it's not clear we can change it now.
        AudioRecord record = new AudioRecord(AudioSource.REMOTE_SUBMIX, 44100,
                AudioFormat.CHANNEL_IN_STEREO, AudioFormat.ENCODING_PCM_16BIT, bufferSize);
        try {
            assertTrue(""AudioRecord state should not be INITIALIZED because the application""
                    + ""does not have permission to access the remote submix source"",
                    record.getState() != AudioRecord.STATE_INITIALIZED);
        } finally {
            record.release();
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/NoCaptureAudioOutputPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.ContactsProviderTest"	"testQueryContacts"	"CtsPermission2TestCases"	"1: permission"	"([2:/android/permission2/cts/ContactsProviderTest.java]:[permission]:[2]:method_text:[res     * permission {@link android.Manifest.permission#WRITE_CONTACTS}.     */    @SmallTest   ]) :|: public void testQueryContacts() {
        getContext().getContentResolver().query(ContactsContract.Contacts.CONTENT_URI,
                null, null, null, null);
    }

    /**
     * Verifies that insert(ContactsContract.Contacts.CONTENT_URI) only requires
     * permission {@link android.Manifest.permission#WRITE_CONTACTS}.
     */
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/ContactsProviderTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.ContactsProviderTest"	"testInsertContacts"	"CtsPermission2TestCases"	"1: permission"	"([2:/android/permission2/cts/ContactsProviderTest.java]:[permission]:[2]:method_text:[ires     * permission {@link android.Manifest.permission#READ_CONTACTS}.     */    @SmallTest   ]) :|: public void testInsertContacts() {
        try {
            getContext().getContentResolver().insert(ContactsContract.Contacts.CONTENT_URI,
                    new ContentValues());
        } catch (SecurityException e) {
            fail(""insert(ContactsContract.Contacts.CONTENT_URI) threw SecurityException"");
        } catch (UnsupportedOperationException e) {
            // It is okay for this fail in this manner.
        }
    }

    /**
     * Verifies that query(ContactsContract.Profile.CONTENT_URI) only requires
     * permission {@link android.Manifest.permission#READ_CONTACTS}.
     */
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/ContactsProviderTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.ContactsProviderTest"	"testQueryProfile"	"CtsPermission2TestCases"	"1: permission"	"([2:/android/permission2/cts/ContactsProviderTest.java]:[permission]:[2]:method_text:[et us execute this. But at least it shouldn't throw a security exception.     */    @SmallTest   ]) :|: public void testQueryProfile() {
        getContext().getContentResolver().query(ContactsContract.Profile.CONTENT_URI,
                null, null, null, null);
    }

    /**
     * Verifies that insert(ContactsContract.Profile.CONTENT_URI) only requires
     * permission {@link android.Manifest.permission#WRITE_CONTACTS}. The provider won't
     * actually let us execute this. But at least it shouldn't throw a security exception.
     */
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/ContactsProviderTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.ContactsProviderTest"	"testInsertProfile"	"CtsPermission2TestCases"	"1: permission"	"([2:/android/permission2/cts/ContactsProviderTest.java]:[permission]:[2]:method_text:[res     * permission {@link android.Manifest.permission#WRITE_CONTACTS}.     */    @SmallTest   ]) :|: public void testInsertProfile() {
     try {
         getContext().getContentResolver().insert(ContactsContract.Profile.CONTENT_URI,
                new ContentValues(0));
        } catch (SecurityException e) {
            fail(""insert(ContactsContract.Profile.CONTENT_URI) threw SecurityException"");
        } catch (UnsupportedOperationException e) {
            // It is okay for this fail in this manner.
        }
    }

    /**
     * Verifies that update(ContactsContract.Profile.CONTENT_URI) only requires
     * permission {@link android.Manifest.permission#WRITE_CONTACTS}.
     */
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/ContactsProviderTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.PermissionMaxSdkVersionTest"	"testMaxSdkInPast"	"CtsPermission2TestCases"	"1: permission"	"([5:/android/permission2/cts/PermissionMaxSdkVersionTest.java]:[permission]:[5]:method_text:[ersion set to a future API level,     * the permission is being granted.     */    @SmallTest   ]) :|: public void testMaxSdkInPast() {
        int result = mContext.checkPermission(UNGRANTABLE_PERMISSION,
                Process.myPid(), Process.myUid());
        assertEquals(""Permissions with maxSdkVersion in the past should not be granted"",
                result,
                PackageManager.PERMISSION_DENIED);
    }

    /**
     * Verify that with android:maxSdkVersion set to a future API level,
     * the permission is being granted.
     */
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/PermissionMaxSdkVersionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.PermissionMaxSdkVersionTest"	"testMaxSdkInFuture"	"CtsPermission2TestCases"	"1: permission"	"([4:/android/permission2/cts/PermissionMaxSdkVersionTest.java]:[permission]:[4]:method_text:[uld be granted"",                result,                PackageManager.PERMISSION_GRANTED);    }}]) :|: public void testMaxSdkInFuture() {
        int result = mContext.checkPermission(GRANTABLE_PERMISSION,
                Process.myPid(), Process.myUid());
        assertEquals(""Permissions with maxSdkVersion in the future should be granted"",
                result,
                PackageManager.PERMISSION_GRANTED);
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/PermissionMaxSdkVersionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.NoWriteSecureSettingsPermissionTest"	"testWriteSecureSettings"	"CtsPermission2TestCases"	"1: permission"	"([1:/android/permission2/cts/NoWriteSecureSettingsPermissionTest.java]:[permission]:[1]:method_text:[TINGS);        } catch (SecurityException expected) {           /* do nothing */        }    }}]) :|: public void testWriteSecureSettings() {
        try {
            ContentValues values = new ContentValues();
            values.put(Settings.Secure.NAME, Settings.Secure.ACCESSIBILITY_ENABLED);
            values.put(Settings.Secure.VALUE, Boolean.TRUE);
            getContext().getContentResolver().insert(Settings.Secure.CONTENT_URI, values);
            fail(""expected SecurityException requiring ""
                    + Manifest.permission.WRITE_SECURE_SETTINGS);
        } catch (SecurityException expected) {
           /* do nothing */
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/NoWriteSecureSettingsPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.NoReceiveSmsPermissionTest"	"testReceiveTextMessage"	"CtsPermission2TestCases"	"1: permission"	"([3:/android/permission2/cts/NoReceiveSmsPermissionTest.java]:[permission]:[3]:method_text:[ nonce from {@link SmsManager#createAppSpecificSmsToken} is delivered     * to the app.     */   ]) :|: public void testReceiveTextMessage() {
        PackageManager packageManager = mContext.getPackageManager();
        if (!packageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }

        // register our test receiver to receive SMSs. This won't throw a SecurityException,
        // so test needs to wait to determine if it actual receives an SMS
        // admittedly, this is a weak verification
        // this test should be used in conjunction with a test that verifies an SMS can be
        // received successfully using the same logic if all permissions are in place
        IllegalSmsReceiver receiver = new IllegalSmsReceiver();
        IntentFilter filter = new IntentFilter();
        filter.addAction(TELEPHONY_SMS_RECEIVED);
        filter.addAction(MESSAGE_SENT_ACTION);
        filter.addAction(MESSAGE_STATUS_RECEIVED_ACTION);

        getContext().registerReceiver(receiver, filter);
        sendSMSToSelf(""test"");
        synchronized(receiver) {
            try {
                receiver.wait(WAIT_TIME);
            } catch (InterruptedException e) {
                Log.w(LOG_TAG, ""wait for sms interrupted"");
            }
        }

        assertTrue(""[RERUN] Sms not sent successfully. Check signal."",
                receiver.isMessageSent());
        assertFalse(""Sms received without proper permissions"", receiver.isSmsReceived());
    }

    /**
     * Verify that without {@link android.Manifest.permission#RECEIVE_SMS} that an SMS sent
     * containing a nonce from {@link SmsManager#createAppSpecificSmsToken} is delivered
     * to the app.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/NoReceiveSmsPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.NoReceiveSmsPermissionTest"	"testAppSpecificSmsToken"	"CtsPermission2TestCases"	"1: permission"	"([2:/android/permission2/cts/NoReceiveSmsPermissionTest.java]:[permission]:[2]:method_text:[c boolean isAppSpecificSmsReceived() {            return mAppSpecificSmsReceived;        }    }}]) :|: public void testAppSpecificSmsToken() {
        PackageManager packageManager = mContext.getPackageManager();
        if (!packageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }

        AppSpecificSmsReceiver receiver = new AppSpecificSmsReceiver();
        IntentFilter filter = new IntentFilter();
        filter.addAction(TELEPHONY_SMS_RECEIVED);
        filter.addAction(MESSAGE_SENT_ACTION);
        filter.addAction(MESSAGE_STATUS_RECEIVED_ACTION);
        filter.addAction(APP_SPECIFIC_SMS_RECEIVED_ACTION);
        getContext().registerReceiver(receiver, filter);

        PendingIntent receivedIntent = PendingIntent.getBroadcast(getContext(), 0,
                new Intent(APP_SPECIFIC_SMS_RECEIVED_ACTION), PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_MUTABLE_UNAUDITED);

        String token = SmsManager.getDefault().createAppSpecificSmsToken(receivedIntent);
        String message = ""test message, token="" + token;
        sendSMSToSelf(message);
        synchronized(receiver) {
            try {
                receiver.wait(WAIT_TIME);
            } catch (InterruptedException e) {
                Log.w(LOG_TAG, ""wait for sms interrupted"");
            }
        }

        assertTrue(""[RERUN] Sms not sent successfully. Check signal."",
                receiver.isMessageSent());
        assertFalse(""Sms received without proper permissions"", receiver.isSmsReceived());
        assertTrue(""App specific SMS intent not triggered"", receiver.isAppSpecificSmsReceived());
    }

    private void sendSMSToSelf(String message) {
        PendingIntent sentIntent = PendingIntent.getBroadcast(getContext(), 0,
                new Intent(MESSAGE_SENT_ACTION), PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_MUTABLE_UNAUDITED);
        PendingIntent deliveryIntent = PendingIntent.getBroadcast(getContext(), 0,
                new Intent(MESSAGE_STATUS_RECEIVED_ACTION), PendingIntent.FLAG_ONE_SHOT | PendingIntent.FLAG_MUTABLE_UNAUDITE"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/NoReceiveSmsPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	Test Available	"android.permission2.cts.IntelligenceRolesPolicyTest"	"testNoInternetPermissionRequested"	"CtsPermission2TestCases"	"4: INTERNET Intelligence permission.INTERNET permission"	"([10:/android/permission2/cts/IntelligenceRolesPolicyTest.java]:[permission]:[10]:method_text:[geManager.GET_PERMISSIONS);        return Arrays.asList(packageInfo.requestedPermissions);    }}]) :|:
    public void testNoInternetPermissionRequested() throws Exception {
        assumeTrue(ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S));

        String packageName = sContext.getResources().getString(mConfigKey);
        assumeTrue(!Strings.isNullOrEmpty(packageName));

        List<String> requestedPermissions;

        try {
            requestedPermissions = getRequestedPermissions(sContext, packageName);
        } catch (PackageManager.NameNotFoundException e) {
            // A package is not found, despite overlay config pointing to it. Strictly speaking that
            // means that the policy for being an intelligence role is fulfilled.
            return;
        }

        assertWithMessage(""Package "" + packageName + ""MUST NOT request INTERNET permission. ""
                + ""Instead packages MUST access the internet through well-defined APIs in an open ""
                + ""source project."")
                .that(requestedPermissions)
                .doesNotContain(android.Manifest.permission.INTERNET);
    }

    private static List<String> getRequestedPermissions(Context context, String pkg)
            throws PackageManager.NameNotFoundException {
        PackageInfo packageInfo = context.getPackageManager()
                .getPackageInfo(pkg, PackageManager.GET_PERMISSIONS);

        return Arrays.asList(packageInfo.requestedPermissions);
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/IntelligenceRolesPolicyTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testDefaultAllRestrictedPermissionsWhitelistedAtInstall29"	"CtsPermission2TestCases"	"1: permission"	"([9:/android/permission2/cts/RestrictedPermissionsTest.java]:[permission]:[9]:method_text:[o restricted permission should be granted.        assertNoRestrictedPermissionGranted();    }   ]) :|: 
    @AppModeFull
    public void testDefaultAllRestrictedPermissionsWhitelistedAtInstall29() throws Exception {
        // Install with no changes to whitelisted permissions, not attempting to grant.
        installRestrictedPermissionUserApp(null /*whitelistedPermissions*/,
                Collections.EMPTY_SET /*grantedPermissions*/);

        // All restricted permission should be whitelisted.
        assertAllRestrictedPermissionWhitelisted();

        // No restricted permission should be granted.
        assertNoRestrictedPermissionGranted();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testSomeRestrictedPermissionsWhitelistedAtInstall29"	"CtsPermission2TestCases"	"1: permission"	"([16:/android/permission2/cts/RestrictedPermissionsTest.java]:[permission]:[16]:method_text:[o restricted permission should be granted.        assertNoRestrictedPermissionGranted();    }   ]) :|: 
    @AppModeFull
    public void testSomeRestrictedPermissionsWhitelistedAtInstall29() throws Exception {
        // Whitelist only these permissions.
        final Set<String> whitelistedPermissions = new ArraySet<>(2);
        whitelistedPermissions.add(Manifest.permission.SEND_SMS);
        whitelistedPermissions.add(Manifest.permission.READ_CALL_LOG);

        // Install with some whitelisted permissions, not attempting to grant.
        installRestrictedPermissionUserApp(whitelistedPermissions,
                Collections.EMPTY_SET /*grantedPermissions*/);

        // Some restricted permission should be whitelisted.
        assertRestrictedPermissionWhitelisted(whitelistedPermissions);

        // No restricted permission should be granted.
        assertNoRestrictedPermissionGranted();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testNoneRestrictedPermissionWhitelistedAtInstall29"	"CtsPermission2TestCases"	"1: permission"	"([8:/android/permission2/cts/RestrictedPermissionsTest.java]:[permission]:[8]:method_text:[o restricted permission should be granted.        assertNoRestrictedPermissionGranted();    }   ]) :|: 
    @AppModeFull
    public void testNoneRestrictedPermissionWhitelistedAtInstall29() throws Exception {
        // Install with all whitelisted permissions, not attempting to grant.
        installRestrictedPermissionUserApp(Collections.emptySet(),
                Collections.EMPTY_SET /*grantedPermissions*/);

        // No restricted permission should be whitelisted.
        assertNoRestrictedPermissionWhitelisted();

        // No restricted permission should be granted.
        assertNoRestrictedPermissionGranted();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testDefaultAllRestrictedPermissionsWhitelistedAtInstall22"	"CtsPermission2TestCases"	"1: permission"	"([4:/android/permission2/cts/RestrictedPermissionsTest.java]:[permission]:[4]:method_text:[ted permission should be whitelisted.        assertAllRestrictedPermissionWhitelisted();    }   ]) :|: 
    @AppModeFull
    @SystemUserOnly(reason = ""Secondary users have the DISALLOW_SMS user restriction"")
    public void testDefaultAllRestrictedPermissionsWhitelistedAtInstall22() throws Exception {
        // Install with no changes to whitelisted permissions
        runShellCommand(""pm install -g --force-queryable "" + APK_USES_SMS_CALL_LOG_22);

        // All restricted permission should be whitelisted.
        assertAllRestrictedPermissionWhitelisted();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testSomeRestrictedPermissionsWhitelistedAtInstall22"	"CtsPermission2TestCases"	"1: permission"	"([13:/android/permission2/cts/RestrictedPermissionsTest.java]:[permission]:[13]:method_text:[ld be whitelisted.        assertRestrictedPermissionWhitelisted(whitelistedPermissions);    }   ]) :|: 
    @AppModeFull
    @SystemUserOnly(reason = ""Secondary users have the DISALLOW_OUTGOING_CALLS user restriction"")
    public void testSomeRestrictedPermissionsWhitelistedAtInstall22() throws Exception {
        // Whitelist only these permissions.
        final Set<String> whitelistedPermissions = new ArraySet<>(2);
        whitelistedPermissions.add(Manifest.permission.SEND_SMS);
        whitelistedPermissions.add(Manifest.permission.READ_CALL_LOG);

        // Install with some whitelisted permissions
        installApp(APK_USES_SMS_CALL_LOG_22, whitelistedPermissions, null /*grantedPermissions*/);

        // Some restricted permission should be whitelisted.
        assertRestrictedPermissionWhitelisted(whitelistedPermissions);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testNoneRestrictedPermissionWhitelistedAtInstall22"	"CtsPermission2TestCases"	"1: permission"	"([5:/android/permission2/cts/RestrictedPermissionsTest.java]:[permission]:[5]:method_text:[cted permission should be whitelisted.        assertNoRestrictedPermissionWhitelisted();    }   ]) :|: 
    @AppModeFull
    public void testNoneRestrictedPermissionWhitelistedAtInstall22() throws Exception {
        // Install with all whitelisted permissions
        installApp(APK_USES_SMS_CALL_LOG_22, Collections.emptySet(),
                null /*grantedPermissions*/);

        // No restricted permission should be whitelisted.
        assertNoRestrictedPermissionWhitelisted();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testLocationBackgroundPermissionWhitelistedAtInstall29"	"CtsPermission2TestCases"	"1: permission"	"([2:/android/permission2/cts/RestrictedPermissionsTest.java]:[permission]:[2]:method_text:[       ACCESS_BACKGROUND_LOCATION)));        assertAllRestrictedPermissionWhitelisted();    }   ]) :|: 
    @AppModeFull
    public void testLocationBackgroundPermissionWhitelistedAtInstall29() throws Exception {
        installApp(APK_USES_LOCATION_29, null, new ArraySet<>(Arrays.asList(ACCESS_FINE_LOCATION,
                ACCESS_BACKGROUND_LOCATION)));
        assertAllRestrictedPermissionWhitelisted();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testLocationBackgroundPermissionNotWhitelistedAtInstall29"	"CtsPermission2TestCases"	"1: permission"	"([2:/android/permission2/cts/RestrictedPermissionsTest.java]:[permission]:[2]:method_text:[ions.singleton(ACCESS_FINE_LOCATION));        assertNoRestrictedPermissionWhitelisted();    }   ]) :|: 
    @AppModeFull
    public void testLocationBackgroundPermissionNotWhitelistedAtInstall29() throws Exception {
        installApp(APK_USES_LOCATION_29, Collections.emptySet(),
                Collections.singleton(ACCESS_FINE_LOCATION));
        assertNoRestrictedPermissionWhitelisted();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testLocationBackgroundPermissionWhitelistedAtInstall22"	"CtsPermission2TestCases"	"1: permission"	"([2:/android/permission2/cts/RestrictedPermissionsTest.java]:[permission]:[2]:method_text:[       ACCESS_BACKGROUND_LOCATION)));        assertAllRestrictedPermissionWhitelisted();    }   ]) :|: 
    @AppModeFull
    public void testLocationBackgroundPermissionWhitelistedAtInstall22() throws Exception {
        installApp(APK_USES_LOCATION_22, null, new ArraySet<>(Arrays.asList(ACCESS_FINE_LOCATION,
                ACCESS_BACKGROUND_LOCATION)));
        assertAllRestrictedPermissionWhitelisted();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testLocationBackgroundPermissionNotWhitelistedAtInstall22"	"CtsPermission2TestCases"	"1: permission"	"([2:/android/permission2/cts/RestrictedPermissionsTest.java]:[permission]:[2]:method_text:[ions.singleton(ACCESS_FINE_LOCATION));        assertNoRestrictedPermissionWhitelisted();    }   ]) :|: 
    @AppModeFull
    public void testLocationBackgroundPermissionNotWhitelistedAtInstall22() throws Exception {
        installApp(APK_USES_LOCATION_22, Collections.emptySet(),
                Collections.singleton(ACCESS_FINE_LOCATION));
        assertNoRestrictedPermissionWhitelisted();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testSomeRestrictedPermissionsGrantedAtInstall"	"CtsPermission2TestCases"	"1: permission"	"([16:/android/permission2/cts/RestrictedPermissionsTest.java]:[permission]:[16]:method_text:[mission should be granted.        assertRestrictedPermissionGranted(grantedPermissions);    }   ]) :|: 
    @AppModeFull
    @SystemUserOnly(reason = ""Secondary users have the DISALLOW_OUTGOING_CALLS user restriction"")
    public void testSomeRestrictedPermissionsGrantedAtInstall() throws Exception {
        // Grant only these permissions.
        final Set<String> grantedPermissions = new ArraySet<>(1);
        grantedPermissions.add(Manifest.permission.SEND_SMS);
        grantedPermissions.add(Manifest.permission.READ_CALL_LOG);

        // Install with no whitelisted permissions attempting to grant.
        installRestrictedPermissionUserApp(null /*whitelistedPermissions*/, grantedPermissions);

        // All restricted permission should be whitelisted.
        assertAllRestrictedPermissionWhitelisted();

        // Some restricted permission should be granted.
        assertRestrictedPermissionGranted(grantedPermissions);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testCanGrantSoftRestrictedNotWhitelistedPermissions"	"CtsPermission2TestCases"	"1: permission"	"([9:/android/permission2/cts/RestrictedPermissionsTest.java]:[permission]:[9]:method_text:[ionGranted(grantedPermissions);        } finally {            uninstallApp();        }    }   ]) :|: 
    @AppModeFull
    public void testCanGrantSoftRestrictedNotWhitelistedPermissions() throws Exception {
        try {
            final Set<String> grantedPermissions = new ArraySet<>();
            grantedPermissions.add(Manifest.permission.READ_EXTERNAL_STORAGE);
            grantedPermissions.add(permission.WRITE_EXTERNAL_STORAGE);

            installApp(APK_USES_STORAGE_DEFAULT_29, Collections.emptySet(), grantedPermissions);

            assertRestrictedPermissionGranted(grantedPermissions);
        } finally {
            uninstallApp();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testAllRestrictedPermissionsGrantedAtInstall"	"CtsPermission2TestCases"	"1: permission"	"([8:/android/permission2/cts/RestrictedPermissionsTest.java]:[permission]:[8]:method_text:[ restricted permission should be granted.        assertAllRestrictedPermissionGranted();    }   ]) :|: 
    @AppModeFull
    @SystemUserOnly(reason = ""Secondary users have the DISALLOW_SMS user restriction"")
    public void testAllRestrictedPermissionsGrantedAtInstall() throws Exception {
        // Install with whitelisted permissions attempting to grant.
        installRestrictedPermissionUserApp(null /*whitelistedPermissions*/,
                null);

        // All restricted permission should be whitelisted.
        assertAllRestrictedPermissionWhitelisted();

        // Some restricted permission should be granted.
        assertAllRestrictedPermissionGranted();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedPermissionsTest"	"testWhitelistAccessControl"	"CtsPermission2TestCases"	"1: permission"	"([5:/android/permission2/cts/RestrictedPermissionsTest.java]:[permission]:[5]:method_text:[hellCanReadAndWrite(                PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER);    }   ]) :|: 
    @AppModeFull
    public void testWhitelistAccessControl() throws Exception {
        // Install with no whitelisted permissions not attempting to grant.
        installRestrictedPermissionUserApp(Collections.emptySet(), null);

        assertWeCannotReadOrWriteWhileShellCanReadAndWrite(
                PackageManager.FLAG_PERMISSION_WHITELIST_SYSTEM);

        assertWeCannotReadOrWriteWhileShellCanReadAndWrite(
                PackageManager.FLAG_PERMISSION_WHITELIST_UPGRADE);

        assertWeCannotReadOrWriteWhileShellCanReadAndWrite(
                PackageManager.FLAG_PERMISSION_WHITELIST_INSTALLER);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedPermissionsTest"	"onSideLoadRestrictedPermissionsWhitelistingDefault"	"CtsPermission2TestCases"	"1: permission"	"([4:/android/permission2/cts/RestrictedPermissionsTest.java]:[permission]:[4]:method_text:[s whitelisted on side-load by default        assertAllRestrictedPermissionWhitelisted();    }   ]) :|: 
    @AppModeFull
    public void onSideLoadRestrictedPermissionsWhitelistingDefault() throws Exception {
        installRestrictedPermissionUserApp(new SessionParams(SessionParams.MODE_FULL_INSTALL));

        // All restricted permissions whitelisted on side-load by default
        assertAllRestrictedPermissionWhitelisted();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedPermissionsTest"	"onSideLoadAllRestrictedPermissionsWhitelisted"	"CtsPermission2TestCases"	"1: permission"	"([5:/android/permission2/cts/RestrictedPermissionsTest.java]:[permission]:[5]:method_text:[RestrictedPermissionUserApp(params);        assertAllRestrictedPermissionWhitelisted();    }   ]) :|: 
    @AppModeFull
    public void onSideLoadAllRestrictedPermissionsWhitelisted() throws Exception {
        SessionParams params = new SessionParams(SessionParams.MODE_FULL_INSTALL);
        params.setWhitelistedRestrictedPermissions(SessionParams.RESTRICTED_PERMISSIONS_ALL);

        installRestrictedPermissionUserApp(params);

        assertAllRestrictedPermissionWhitelisted();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedPermissionsTest"	"onSideLoadWhitelistSomePermissions"	"CtsPermission2TestCases"	"1: permission"	"([11:/android/permission2/cts/RestrictedPermissionsTest.java]:[permission]:[11]:method_text:[nUserApp(params);        assertRestrictedPermissionWhitelisted(whitelistedPermissions);    }   ]) :|: 
    @AppModeFull
    public void onSideLoadWhitelistSomePermissions() throws Exception {
        Set<String> whitelistedPermissions = new ArraySet<>();
        whitelistedPermissions.add(Manifest.permission.SEND_SMS);
        whitelistedPermissions.add(Manifest.permission.READ_CALL_LOG);

        SessionParams params = new SessionParams(SessionParams.MODE_FULL_INSTALL);
        params.setWhitelistedRestrictedPermissions(whitelistedPermissions);

        installRestrictedPermissionUserApp(params);

        assertRestrictedPermissionWhitelisted(whitelistedPermissions);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedPermissionsTest"	"onSideLoadWhitelistNoPermissions"	"CtsPermission2TestCases"	"1: permission"	"([4:/android/permission2/cts/RestrictedPermissionsTest.java]:[permission]:[4]:method_text:[lRestrictedPermissionUserApp(params);        assertNoRestrictedPermissionWhitelisted();    }   ]) :|: 
    @AppModeFull
    public void onSideLoadWhitelistNoPermissions() throws Exception {
        SessionParams params = new SessionParams(SessionParams.MODE_FULL_INSTALL);
        params.setWhitelistedRestrictedPermissions(Collections.emptySet());

        installRestrictedPermissionUserApp(params);

        assertNoRestrictedPermissionWhitelisted();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission2.cts.RestrictedPermissionsTest"	"isTrue"	"CtsPermission2TestCases"	"1: permission"	"([176:/android/permission2/cts/RestrictedPermissionsTest.java]:[permission]:[176]:method_text:[umentation().getUiAutomation()                    .dropShellPermissionIdentity();        }    }}]) :|: 
    @AppModeFull
    @SystemUserOnly(reason = ""Secondary users have the DISALLOW_SMS user restriction"")
    public void shareUidBetweenRestrictedAndNotRestrictedApp() throws Exception {
        runShellCommand(
                ""pm install -g --force-queryable --restrict-permissions ""
                + APK_USES_SMS_RESTRICTED_SHARED_UID);
        runShellCommand(""pm install -g --force-queryable ""
                + APK_USES_SMS_NOT_RESTRICTED_SHARED_UID);

        eventually(
                () -> assertThat(isGranted(PKG_USES_SMS_RESTRICTED_SHARED_UID, READ_SMS)).isTrue());
        // The apps share a UID, hence the whitelisting is shared too
        assertThat(isGranted(PKG_USES_SMS_NOT_RESTRICTED_SHARED_UID, READ_SMS)).isTrue();
    }

    private static void installRestrictedPermissionUserApp(@NonNull SessionParams params)
            throws Exception {
        final CountDownLatch installLatch = new CountDownLatch(1);

        // Create an install result receiver.
        final BroadcastReceiver installReceiver = new BroadcastReceiver() {
            public void onReceive(Context context, Intent intent) {
                if (intent.getIntExtra(PackageInstaller.EXTRA_STATUS,
                        PackageInstaller.STATUS_FAILURE_INVALID)
                            == PackageInstaller.STATUS_SUCCESS) {
                    installLatch.countDown();
                }
            }
        };

        // Register the result receiver.
        final String action = ""android.permission2.cts.ACTION_INSTALL_COMMIT"";
        final IntentFilter intentFilter = new IntentFilter(action);
        getContext().registerReceiver(installReceiver, intentFilter);

        try {
            // Create a session.
            final PackageInstaller packageInstaller = getContext()
                    .getPackageManager().getPackageInstaller();
            final int sessionId = packageInstaller.createSession(params);
            final Session session = packageInstaller.openSession(sessio"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission2/src/android/permission2/cts/RestrictedPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.keystore.cts.KeyAttestationTest"	"testVersionParser"	"CtsKeystoreTestCases"	"1: 9.1"	"([2:/android/keystore/cts/KeyAttestationTest.java]:[9.1]:[2]:method_text:[00.99""));        assertEquals(0, parseSystemOsVersion(""99.99.100""));    }    @RequiresDevice   ]) :|: 
    public void testVersionParser() throws Exception {
        // Non-numerics/empty give version 0
        assertEquals(0, parseSystemOsVersion(""""));
        assertEquals(0, parseSystemOsVersion(""N""));

        // Should support one, two or three version number values.
        assertEquals(10000, parseSystemOsVersion(""1""));
        assertEquals(10200, parseSystemOsVersion(""1.2""));
        assertEquals(10203, parseSystemOsVersion(""1.2.3""));

        // It's fine to append other stuff to the dotted numeric version.
        assertEquals(10000, parseSystemOsVersion(""1stuff""));
        assertEquals(10200, parseSystemOsVersion(""1.2garbage.32""));
        assertEquals(10203, parseSystemOsVersion(""1.2.3-stuff""));

        // Two digits per version field are supported
        assertEquals(152536, parseSystemOsVersion(""15.25.36""));
        assertEquals(999999, parseSystemOsVersion(""99.99.99""));
        assertEquals(0, parseSystemOsVersion(""100.99.99""));
        assertEquals(0, parseSystemOsVersion(""99.100.99""));
        assertEquals(0, parseSystemOsVersion(""99.99.100""));
    }

    @RequiresDevice"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/KeyAttestationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.keystore.cts.KeyAttestationTest"	"testEcAttestation_KeyStoreExceptionWhenRequestingUniqueId"	"CtsKeystoreTestCases"	"1: permission"	"([2:/android/keystore/cts/KeyAttestationTest.java]:[permission]:[2]:method_text:[oad(null);            keyStore.deleteEntry(keystoreAlias);        }    }    @RequiresDevice   ]) :|: 
    public void testEcAttestation_KeyStoreExceptionWhenRequestingUniqueId() throws Exception {
        String keystoreAlias = ""test_key"";
        KeyGenParameterSpec spec = new KeyGenParameterSpec.Builder(keystoreAlias, PURPOSE_SIGN)
                .setAlgorithmParameterSpec(new ECGenParameterSpec(""secp256r1""))
                .setDigests(DIGEST_NONE, DIGEST_SHA256, DIGEST_SHA512)
                .setAttestationChallenge(new byte[128])
                .setUniqueIdIncluded(true)
                .build();

        try {
            generateKeyPair(KEY_ALGORITHM_EC, spec);
            fail(""Attestation should have failed."");
        } catch (ProviderException e) {
            // Attestation is expected to fail because of lack of permissions.
            KeyStoreException cause = (KeyStoreException) e.getCause();
            assertEquals(KM_ERROR_PERMISSION_DENIED, cause.getErrorCode());
        } finally {
            KeyStore keyStore = KeyStore.getInstance(""AndroidKeyStore"");
            keyStore.load(null);
            keyStore.deleteEntry(keystoreAlias);
        }
    }

    @RequiresDevice"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/KeyAttestationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.keystore.cts.KeyAttestationTest"	"testDeviceIdAttestation"	"CtsKeystoreTestCases"	"1: permission"	"([1:/android/keystore/cts/KeyAttestationTest.java]:[permission]:[1]:method_text:[ionFailureMessage.equals(e.getMessage())) {                throw e;            }        }    }}]) :|: 
    public void testDeviceIdAttestation() throws Exception {
        testDeviceIdAttestationFailure(AttestationUtils.ID_TYPE_SERIAL, null);
        testDeviceIdAttestationFailure(AttestationUtils.ID_TYPE_IMEI, ""Unable to retrieve IMEI"");
        testDeviceIdAttestationFailure(AttestationUtils.ID_TYPE_MEID, ""Unable to retrieve MEID"");
    }

    @SuppressWarnings(""deprecation"")
    private void testRsaAttestation(byte[] challenge, boolean includeValidityDates, int keySize,
            int purposes, String[] paddingModes, boolean devicePropertiesAttestation)
            throws Exception {
        Log.i(TAG, ""RSA key attestation with: challenge "" + Arrays.toString(challenge) +
                "" / includeValidityDates "" + includeValidityDates + "" / keySize "" + keySize +
                "" / purposes "" + purposes + "" / paddingModes "" + Arrays.toString(paddingModes) +
                "" / devicePropertiesAttestation "" + devicePropertiesAttestation);

        String keystoreAlias = ""test_key"";
        Date startTime = new Date();
        Date originationEnd = new Date(startTime.getTime() + ORIGINATION_TIME_OFFSET);
        Date consumptionEnd = new Date(startTime.getTime() + CONSUMPTION_TIME_OFFSET);
        KeyGenParameterSpec.Builder builder =
            new KeyGenParameterSpec.Builder(keystoreAlias, purposes)
                        .setKeySize(keySize)
                        .setDigests(DIGEST_NONE, DIGEST_SHA256, DIGEST_SHA512)
                        .setAttestationChallenge(challenge)
                        .setDevicePropertiesAttestationIncluded(devicePropertiesAttestation);

        if (includeValidityDates) {
            builder.setKeyValidityStart(startTime)
                    .setKeyValidityForOriginationEnd(originationEnd)
                    .setKeyValidityForConsumptionEnd(consumptionEnd);
        }
        if (isEncryptionPurpose(purposes)) {
            builder.setEncryptionPaddings(paddingModes);
            // Because we sometimes set ""no padding"", al"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/KeyAttestationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.keystore.cts.KeyGenParameterSpecTest"	"testImmutabilityViaGetterReturnValues"	"CtsKeystoreTestCases"	"1: permission"	"([1:/android/keystore/cts/KeyGenParameterSpecTest.java]:[permission]:[1]:method_text:[ey with UID throws an exception since CTS doesn't have the necessary     * permissions.     */   ]) :|: 
    public void testImmutabilityViaGetterReturnValues() {
        // Assert that none of the mutable return values from getters modify the state of the spec.

        KeyGenParameterSpec spec = new KeyGenParameterSpec.Builder(
                ""arbitrary"", KeyProperties.PURPOSE_SIGN | KeyProperties.PURPOSE_ENCRYPT)
                .setBlockModes(KeyProperties.BLOCK_MODE_GCM, KeyProperties.BLOCK_MODE_CBC)
                .setCertificateNotBefore(new Date(System.currentTimeMillis()))
                .setCertificateNotAfter(new Date(System.currentTimeMillis() + 12345678))
                .setDigests(KeyProperties.DIGEST_MD5, KeyProperties.DIGEST_SHA512)
                .setEncryptionPaddings(
                        KeyProperties.ENCRYPTION_PADDING_RSA_OAEP,
                        KeyProperties.ENCRYPTION_PADDING_PKCS7)
                .setKeyValidityStart(new Date(System.currentTimeMillis() - 2222222))
                .setKeyValidityForOriginationEnd(new Date(System.currentTimeMillis() + 11111111))
                .setKeyValidityForConsumptionEnd(new Date(System.currentTimeMillis() + 33333333))
                .setSignaturePaddings(
                        KeyProperties.SIGNATURE_PADDING_RSA_PSS,
                        KeyProperties.SIGNATURE_PADDING_RSA_PKCS1)
                .build();

        String[] originalBlockModes = spec.getBlockModes().clone();
        spec.getBlockModes()[0] = null;
        assertEquals(Arrays.asList(originalBlockModes), Arrays.asList(spec.getBlockModes()));

        Date originalCertNotBeforeDate = (Date) spec.getCertificateNotBefore().clone();
        spec.getCertificateNotBefore().setTime(1234567890L);
        assertEquals(originalCertNotBeforeDate, spec.getCertificateNotBefore());

        Date originalCertNotAfterDate = (Date) spec.getCertificateNotAfter().clone();
        spec.getCertificateNotAfter().setTime(1234567890L);
        assertEquals(originalCertNotAfterDate, spec.getCertificateNotAfter());

        String[] originalDigest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/KeyGenParameterSpecTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.bluetooth.cts.BluetoothLeScanTest"	"isEnabled"	"CtsBluetoothTestCases"	"1: permission"	"([2:/android/bluetooth/cts/BluetoothLeScanTest.java]:[permission]:[2]:method_text:[t case for BLE scans. Checks BLE scan timestamp is within correct range.     */    @MediumTest   ]) :|: public void test/*
 *.
 */

package android.bluetooth.cts;

import android.app.PendingIntent;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothManager;
import android.bluetooth.le.BluetoothLeScanner;
import android.bluetooth.le.ScanCallback;
import android.bluetooth.le.ScanFilter;
import android.bluetooth.le.ScanRecord;
import android.bluetooth.le.ScanResult;
import android.bluetooth.le.ScanSettings;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.ParcelUuid;
import android.os.SystemClock;
import android.test.AndroidTestCase;
import android.test.suitebuilder.annotation.MediumTest;
import android.util.Log;
import android.util.SparseArray;

import androidx.test.InstrumentationRegistry;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * Test cases for Bluetooth LE scans.
 * <p>
 * To run the test, the device must be placed in an environment that has at least 3 beacons, all
 * placed less than 5 meters away from the DUT.
 * <p>
 * Run 'run cts --class android.bluetooth.cts.BluetoothLeScanTest' in cts-tradefed to run the test
 * cases.
 */
public class BluetoothLeScanTest extends AndroidTestCase {

    private static final String TAG = ""BluetoothLeScanTest"";

    private static final int SCAN_DURATION_MILLIS = 10000;
    private static final int BATCH_SCAN_REPORT_DELAY_MILLIS = 20000;
    private static final int SCAN_STOP_TIMEOUT = 2000;
    private CountDownLatch mFlushBatchScanLatch;

    private BluetoothAdapter mBluetoothAdapter;
    private BluetoothLeScanner mScanner;
    // Whether location is on before running the tests.
    private boolean mLocationOn;

    @Override
    public void setUp() {
        if (!TestUtils."	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/bluetooth/src/android/bluetooth/cts/BluetoothLeScanTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.bluetooth.cts.BluetoothDeviceTest"	"test_setAlias_getAlias"	"CtsBluetoothTestCases"	"1: permission"	"([2:/android/bluetooth/cts/BluetoothDeviceTest.java]:[permission]:[2]:method_text:[          ""cmd companiondevice disassociate %d %s %s"", userId, packageName, deviceAddress));    }}]) :|: public void test_setAlias_getAlias() {
        if (!mHasBluetooth || !mHasCompanionDevice) {
            // Skip the test if bluetooth or companion device are not present.
            return;
        }

        int userId = mContext.getUser().getIdentifier();
        String packageName = mContext.getOpPackageName();
        String deviceAddress = ""00:11:22:AA:BB:CC"";

        BluetoothDevice device = mAdapter.getRemoteDevice(deviceAddress);
        // Verifies that when there is no alias, we return the device name
        assertNull(device.getAlias());

        String testDeviceAlias = ""Test Device Alias"";

        // This should throw a SecurityException because there is no CDM association
        try {
            device.setAlias(testDeviceAlias);
            fail(""BluetoothDevice alias was able to be set without a CDM association or ""
                    + ""BLUETOOTH_PRIVILEGED permission"");
        } catch (SecurityException ex) {
            assertNull(device.getAlias());
        }

        runShellCommand(String.format(
                ""cmd companiondevice associate %d %s %s"", userId, packageName, deviceAddress));
        String output = runShellCommand(""dumpsys companiondevice"");
        assertTrue(""Package name missing from output"", output.contains(packageName));
        assertTrue(""Device address missing from output"", output.contains(deviceAddress));

        // Takes time to update the CDM cache, so sleep to ensure the association is cached
        try {
            Thread.sleep(1000);
        } catch (Exception e) {
            e.printStackTrace();
        }

        /*
         * Device properties don't exist for non-existent BluetoothDevice, so calling setAlias with
         * permissions should return false
         */
        assertEquals(BluetoothStatusCodes.ERROR_DEVICE_NOT_BONDED, device.setAlias(testDeviceAlias));
        runShellCommand(String.format(
                ""cmd companiondevice disassociate %d %s %s"", userId, packageName, deviceAddress)"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/bluetooth/src/android/bluetooth/cts/BluetoothDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.sensorprivacy.cts.SensorPrivacyMicrophoneTest.kt"	"testMicShownOnPhoneCall"	"CtsSensorPrivacyTestCases"	"1: permission"	"([2:/android/sensorprivacy/cts/SensorPrivacyMicrophoneTest.kt]:[permission]:[2]:method_text:[    context.getSystemService(TelecomManager::class.java)!!.endCall()            }        }    }}]) :|: 
    fun testMicShownOnPhoneCall() {
        try {
            Assume.assumeTrue(packageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY))
            setSensor(true)
            SystemUtil.runWithShellPermissionIdentity {
                val intent = Intent(Intent.ACTION_CALL, Uri.parse(""tel:"" + ""555-5555""))
                        .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                context.startActivity(intent)
            }

            unblockSensorWithDialogAndAssert()
        } finally {
            SystemUtil.runWithShellPermissionIdentity {
                context.getSystemService(TelecomManager::class.java)!!.endCall()
            }
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/sensorprivacy/src/android/sensorprivacy/cts/SensorPrivacyMicrophoneTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.sensorprivacy.cts.SensorPrivacyBaseTest.kt"	"isSensorPrivacyEnabled"	"CtsSensorPrivacyTestCases"	"1: permission"	"([2:/android/sensorprivacy/cts/SensorPrivacyBaseTest.kt]:[permission]:[2]:method_text:[arDown() {        finishTestApp()        Thread.sleep(3000)        setSensor(oldState)    }   ]) :|: /*
 *.
 */

package android.sensorprivacy.cts

import android.app.KeyguardManager
import android.app.AppOpsManager
import android.content.Intent
import android.content.pm.PackageManager
import android.hardware.SensorPrivacyManager
import android.hardware.SensorPrivacyManager.OnSensorPrivacyChangedListener
import android.os.PowerManager
import android.platform.test.annotations.AppModeFull
import android.hardware.SensorPrivacyManager.Sensors.CAMERA
import android.hardware.SensorPrivacyManager.Sensors.MICROPHONE
import android.hardware.SensorPrivacyManager.Sources.OTHER
import android.support.test.uiautomator.By
import android.view.KeyEvent
import androidx.test.platform.app.InstrumentationRegistry
import androidx.test.uiautomator.UiDevice
import com.android.compatibility.common.util.SystemUtil.callWithShellPermissionIdentity
import com.android.compatibility.common.util.SystemUtil.eventually
import com.android.compatibility.common.util.SystemUtil.runShellCommandOrThrow
import com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity
import com.android.compatibility.common.util.UiAutomatorUtils
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Assert.assertFalse
import org.junit.Assert.assertNull
import org.junit.Assert.assertTrue
import org.junit.Assume
import org.junit.Before
import org.junit.Test
import java.util.concurrent.CountDownLatch
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit
import java.util.regex.Pattern

abstract class SensorPrivacyBaseTest(
    val sensor: Int,
    vararg val extras: String
) {

    companion object {
        const val MIC_CAM_ACTIVITY_ACTION =
                ""android.sensorprivacy.cts.usemiccamera.action.USE_MIC_CAM""
        const val FINISH_MIC_CAM_ACTIVITY_ACTION =
                ""android.sensorprivacy.cts.usemiccamera.action.FINISH_USE_MIC_CAM""
        const val USE_MIC_EXTRA =
                ""android.sensorprivacy.cts.usemiccamera.extra.USE_MICROPHONE"""	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/sensorprivacy/src/android/sensorprivacy/cts/SensorPrivacyBaseTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.sensorprivacy.cts.SensorPrivacyBaseTest.kt"	"testListener"	"CtsSensorPrivacyTestCases"	"1: permission"	"([4:/android/sensorprivacy/cts/SensorPrivacyBaseTest.kt]:[permission]:[4]:method_text:[missionIdentity {            spm.removeSensorPrivacyListener(sensor, listener)        }    }   ]) :|: 
    fun testListener() {
        val executor = Executors.newSingleThreadExecutor()
        setSensor(false)
        val latchEnabled = CountDownLatch(1)
        var listener =
                OnSensorPrivacyChangedListener { _, enabled: Boolean ->
                    if (enabled) {
                        latchEnabled.countDown()
                    }
                }
        runWithShellPermissionIdentity {
            spm.addSensorPrivacyListener(sensor, executor, listener)
        }
        setSensor(true)
        latchEnabled.await(100, TimeUnit.MILLISECONDS)
        runWithShellPermissionIdentity {
            spm.removeSensorPrivacyListener(sensor, listener)
        }

        val latchDisabled = CountDownLatch(1)
        listener = OnSensorPrivacyChangedListener { _, enabled: Boolean ->
            if (!enabled) {
                latchDisabled.countDown()
            }
        }
        runWithShellPermissionIdentity {
            spm.addSensorPrivacyListener(sensor, executor, listener)
        }
        setSensor(false)
        latchEnabled.await(100, TimeUnit.MILLISECONDS)
        runWithShellPermissionIdentity {
            spm.removeSensorPrivacyListener(sensor, listener)
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/sensorprivacy/src/android/sensorprivacy/cts/SensorPrivacyBaseTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.sensorprivacy.cts.SensorPrivacyBaseTest.kt"	"testOpFinishedWhileToggleOn"	"CtsSensorPrivacyTestCases"	"1: permission"	"([5:/android/sensorprivacy/cts/SensorPrivacyBaseTest.kt]:[permission]:[5]:method_text:[             assertFalse(""Device isn't unlocked"", km.isDeviceLocked)            }        }    }}]) :|: 
    @AppModeFull(reason = ""Uses secondary app, instant apps have no visibility"")
    fun testOpFinishedWhileToggleOn() {
        setSensor(false)
        startTestApp()
        eventually {
            assertOpRunning(true)
        }
        setSensor(true)
        Thread.sleep(5000)
        eventually {
            assertOpRunning(false)
        }
        finishTestApp()
        Thread.sleep(1000)
        setSensor(false)
        Thread.sleep(1000)
        assertOpRunning(false)
    }

    private fun startTestApp() {
        val intent = Intent(MIC_CAM_ACTIVITY_ACTION)
                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                .addFlags(Intent.FLAG_ACTIVITY_MATCH_EXTERNAL)
        for (extra in extras) {
            intent.putExtra(extra, true)
        }
        context.startActivity(intent)
        // Wait for app to open
        UiAutomatorUtils.waitFindObject(By.textContains(ACTIVITY_TITLE_SNIP))
    }

    private fun finishTestApp() {
        // instant apps can't broadcast to other instant apps; use the shell
        runShellCommandOrThrow(""am broadcast"" +
                "" --user ${context.userId}"" +
                "" -a $FINISH_MIC_CAM_ACTIVITY_ACTION"" +
                "" -f ${Intent.FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS}"")
    }

    protected fun setSensor(enable: Boolean) {
        runWithShellPermissionIdentity {
            spm.setSensorPrivacy(OTHER, sensor, enable)
        }
    }

    private fun isSensorPrivacyEnabled(): Boolean {
        return callWithShellPermissionIdentity {
            spm.isSensorPrivacyEnabled(sensor)
        }
    }

    private fun getOpForSensor(sensor: Int): String? {
        return when (sensor) {
            CAMERA -> AppOpsManager.OPSTR_CAMERA
            MICROPHONE -> AppOpsManager.OPSTR_RECORD_AUDIO
            else -> null
        }
    }

    private fun getOpForPackage(): AppOpsManager.PackageOps {
        return callWithShellPermissionIdentity {
            val uid = try {
                package"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/sensorprivacy/src/android/sensorprivacy/cts/SensorPrivacyBaseTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.webkit.cts.GeolocationTest"	"GeolocationTest"	"CtsWebkitTestCases"	"1: permission"	"([6:/android/webkit/cts/GeolocationTest.java]:[permission]:[6]:method_text:[ept, mRetain);        }    }    // Test loading a page and accepting the domain for one load   ]) :|: public void test/*
 *.
 */

package android.webkit.cts;

import android.content.Context;
import android.graphics.Bitmap;
import android.location.Criteria;
import android.location.Location;
import android.location.LocationListener;
import android.location.LocationManager;
import android.location.LocationProvider;
import android.platform.test.annotations.AppModeFull;
import android.os.Bundle;
import android.os.Looper;
import android.os.SystemClock;
import android.test.ActivityInstrumentationTestCase2;
import android.webkit.CookieManager;
import android.webkit.CookieSyncManager;
import android.webkit.GeolocationPermissions;
import android.webkit.JavascriptInterface;
import android.webkit.WebChromeClient;
import android.webkit.WebResourceResponse;
import android.webkit.WebView;
import android.webkit.WebViewClient;
import android.webkit.cts.WebViewSyncLoader.WaitForLoadedClient;
import android.webkit.cts.WebViewSyncLoader.WaitForProgressClient;

import com.android.compatibility.common.util.LocationUtils;
import com.android.compatibility.common.util.NullWebViewUtils;
import com.android.compatibility.common.util.PollingCheck;

import java.io.ByteArrayInputStream;
import java.io.UnsupportedEncodingException;
import java.util.concurrent.Callable;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Random;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.Set;
import java.util.TreeSet;

import junit.framework.Assert;

@AppModeFull(reason = ""Instant apps do not have access to location information"")
public class GeolocationTest extends ActivityInstrumentationTestCase2<WebViewCtsActivity> {

    // TODO Write additional tests to cover:
    // - test that the errors are correct
    // - test that use of gps and network location is correct

    // The URLs does not matter since the tests will intercept the load, but it has to be a real
    // url, and different domains.
    private static final String URL_1 = ""htt"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/webkit/src/android/webkit/cts/GeolocationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.webkit.cts.GeolocationTest"	"testSimpleGeolocationRequestAcceptAlways"	"CtsWebkitTestCases"	"1: permission"	"([10:/android/webkit/cts/GeolocationTest.java]:[permission]:[10]:method_text:[igins(originCheck);        originCheck.run();    }    // Test the GeolocationPermissions API   ]) :|: public void testSimpleGeolocationRequestAcceptAlways() throws Exception {
        if (!NullWebViewUtils.isWebViewAvailable()) {
            return;
        }
        final TestSimpleGeolocationRequestWebChromeClient chromeClientAcceptAlways =
                new TestSimpleGeolocationRequestWebChromeClient(mOnUiThread, true, true);
        mOnUiThread.setWebChromeClient(chromeClientAcceptAlways);
        // Load url once, and the callback should accept the domain for all future loads
        loadUrlAndUpdateLocation(URL_1);
        Callable<Boolean> receivedRequest = new Callable<Boolean>() {
            @Override
            public Boolean call() {
                return chromeClientAcceptAlways.mReceivedRequest;
            }
        };
        PollingCheck.check(""Geolocation prompt not called"", POLLING_TIMEOUT, receivedRequest);
        Callable<Boolean> receivedLocation = new Callable<Boolean>() {
            @Override
            public Boolean call() {
                return mJavascriptStatusReceiver.mHasPosition;
            }
        };
        PollingCheck.check(""JS didn't get position"", POLLING_TIMEOUT, receivedLocation);
        chromeClientAcceptAlways.mReceivedRequest = false;
        mJavascriptStatusReceiver.clearState();
        // Load the same URL again
        loadUrlAndUpdateLocation(URL_1);
        PollingCheck.check(""JS didn't get position"", POLLING_TIMEOUT, receivedLocation);
        assertFalse(""Prompt for geolocation permission should not be called the second time"",
                chromeClientAcceptAlways.mReceivedRequest);
        // Check that the permission is in GeolocationPermissions
        BooleanCheck trueCheck = new BooleanCheck(true);
        GeolocationPermissions.getInstance().getAllowed(URL_1, trueCheck);
        trueCheck.run();
        Set<String> acceptedOrigins = new TreeSet<String>();
        acceptedOrigins.add(URL_1);
        OriginCheck originCheck = new OriginCheck(acceptedOrigins);
        GeolocationPermissions.getIns"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/webkit/src/android/webkit/cts/GeolocationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.webkit.cts.GeolocationTest"	"testGeolocationPermissions"	"CtsWebkitTestCases"	"1: permission"	"([17:/android/webkit/cts/GeolocationTest.java]:[permission]:[17]:method_text:[n();    }    // Test loading pages and checks rejecting once and rejecting the domain forever   ]) :|: public void testGeolocationPermissions() {
        if (!NullWebViewUtils.isWebViewAvailable()) {
            return;
        }
        Set<String> acceptedOrigins = new TreeSet<String>();
        BooleanCheck falseCheck = new BooleanCheck(false);
        GeolocationPermissions.getInstance().getAllowed(URL_2, falseCheck);
        falseCheck.run();
        OriginCheck originCheck = new OriginCheck(acceptedOrigins);
        GeolocationPermissions.getInstance().getOrigins(originCheck);
        originCheck.run();

        // Remove a domain that has not been allowed
        GeolocationPermissions.getInstance().clear(URL_2);
        acceptedOrigins.remove(URL_2);
        originCheck = new OriginCheck(acceptedOrigins);
        GeolocationPermissions.getInstance().getOrigins(originCheck);
        originCheck.run();

        // Add a domain
        acceptedOrigins.add(URL_2);
        GeolocationPermissions.getInstance().allow(URL_2);
        originCheck = new OriginCheck(acceptedOrigins);
        GeolocationPermissions.getInstance().getOrigins(originCheck);
        originCheck.run();
        BooleanCheck trueCheck = new BooleanCheck(true);
        GeolocationPermissions.getInstance().getAllowed(URL_2, trueCheck);
        trueCheck.run();

        // Add a domain
        acceptedOrigins.add(URL_1);
        GeolocationPermissions.getInstance().allow(URL_1);
        originCheck = new OriginCheck(acceptedOrigins);
        GeolocationPermissions.getInstance().getOrigins(originCheck);
        originCheck.run();

        // Remove a domain that has been allowed
        GeolocationPermissions.getInstance().clear(URL_2);
        acceptedOrigins.remove(URL_2);
        originCheck = new OriginCheck(acceptedOrigins);
        GeolocationPermissions.getInstance().getOrigins(originCheck);
        originCheck.run();
        falseCheck = new BooleanCheck(false);
        GeolocationPermissions.getInstance().getAllowed(URL_2, falseCheck);
        falseCheck.run();

        // Try to clear all"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/webkit/src/android/webkit/cts/GeolocationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.webkit.cts.GeolocationTest"	"testSimpleGeolocationRequestReject"	"CtsWebkitTestCases"	"1: permission"	"([2:/android/webkit/cts/GeolocationTest.java]:[permission]:[2]:method_text:[, falseCheck);        falseCheck.run();    }    // Test deny geolocation on insecure origins   ]) :|: public void testSimpleGeolocationRequestReject() throws Exception {
        if (!NullWebViewUtils.isWebViewAvailable()) {
            return;
        }
        final TestSimpleGeolocationRequestWebChromeClient chromeClientRejectOnce =
                new TestSimpleGeolocationRequestWebChromeClient(mOnUiThread, false, false);
        mOnUiThread.setWebChromeClient(chromeClientRejectOnce);
        // Load url once, and the callback should reject it once
        mOnUiThread.loadUrlAndWaitForCompletion(URL_1);
        Callable<Boolean> receivedRequest = new Callable<Boolean>() {
            @Override
            public Boolean call() {
                return chromeClientRejectOnce.mReceivedRequest;
            }
        };
        PollingCheck.check(""Geolocation prompt not called"", POLLING_TIMEOUT, receivedRequest);
        Callable<Boolean> locationDenied = new Callable<Boolean>() {
            @Override
            public Boolean call() {
                return mJavascriptStatusReceiver.mDenied;
            }
        };
        PollingCheck.check(""JS got position"", POLLING_TIMEOUT, locationDenied);
        // Same result should happen on next run
        chromeClientRejectOnce.mReceivedRequest = false;
        mOnUiThread.loadUrlAndWaitForCompletion(URL_1);
        PollingCheck.check(""Geolocation prompt not called"", POLLING_TIMEOUT, receivedRequest);
        PollingCheck.check(""JS got position"", POLLING_TIMEOUT, locationDenied);

        // Try to reject forever
        final TestSimpleGeolocationRequestWebChromeClient chromeClientRejectAlways =
            new TestSimpleGeolocationRequestWebChromeClient(mOnUiThread, false, true);
        mOnUiThread.setWebChromeClient(chromeClientRejectAlways);
        mOnUiThread.loadUrlAndWaitForCompletion(URL_2);
        PollingCheck.check(""Geolocation prompt not called"", POLLING_TIMEOUT, receivedRequest);
        PollingCheck.check(""JS didn't get position"", POLLING_TIMEOUT, locationDenied);
        // second load should now not g"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/webkit/src/android/webkit/cts/GeolocationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.webkit.cts.GeolocationTest"	"testGeolocationRequestDeniedOnInsecureOrigin"	"CtsWebkitTestCases"	"1: permission"	"([1:/android/webkit/cts/GeolocationTest.java]:[permission]:[1]:method_text:[riptInterface        public void gotLocation() {            mHasPosition = true;        }    }}]) :|: public void testGeolocationRequestDeniedOnInsecureOrigin() throws Exception {
        if (!NullWebViewUtils.isWebViewAvailable()) {
            return;
        }
        final TestSimpleGeolocationRequestWebChromeClient chromeClientAcceptAlways =
                new TestSimpleGeolocationRequestWebChromeClient(mOnUiThread, true, true);
        mOnUiThread.setWebChromeClient(chromeClientAcceptAlways);
        loadUrlAndUpdateLocation(URL_INSECURE);
        Callable<Boolean> locationDenied = new Callable<Boolean>() {
            @Override
            public Boolean call() {
                return mJavascriptStatusReceiver.mDenied;
            }
        };
        PollingCheck.check(""JS got position"", POLLING_TIMEOUT, locationDenied);
        assertFalse(""The geolocation permission prompt should not be called"",
                chromeClientAcceptAlways.mReceivedRequest);
    }

    // Object added to the page via AddJavascriptInterface() that is used by the test Javascript to
    // notify back to Java when a location or error is received.
    public final static class JavascriptStatusReceiver {
        public volatile boolean mHasPosition = false;
        public volatile boolean mDenied = false;
        public volatile boolean mUnavailable = false;
        public volatile boolean mTimeout = false;

        public void clearState() {
            mHasPosition = false;
            mDenied = false;
            mUnavailable = false;
            mTimeout = false;
        }

        @JavascriptInterface
        public void errorDenied() {
            mDenied = true;
        }

        @JavascriptInterface
        public void errorUnavailable() {
            mUnavailable = true;
        }

        @JavascriptInterface
        public void errorTimeout() {
            mTimeout = true;
        }

        @JavascriptInterface
        public void gotLocation() {
            mHasPosition = true;
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/webkit/src/android/webkit/cts/GeolocationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.webkit.cts.WebSettingsTest"	"testLocalImageLoads"	"CtsWebkitTestCases"	"1: permission"	"([1:/android/webkit/cts/WebSettingsTest.java]:[permission]:[1]:method_text:[that javascript cross-domain request permissions matches file domain settings    // for iframes   ]) :|: public void testLocalImageLoads() throws Throwable {
        if (!NullWebViewUtils.isWebViewAvailable()) {
            return;
        }

        mSettings.setJavaScriptEnabled(true);
        // Check that local images are loaded without issues regardless of domain checkings
        mSettings.setAllowUniversalAccessFromFileURLs(false);
        mSettings.setAllowFileAccessFromFileURLs(false);
        String url = TestHtmlConstants.getFileUrl(TestHtmlConstants.IMAGE_ACCESS_URL);
        mOnUiThread.loadUrlAndWaitForCompletion(url);
        waitForNonEmptyImage();
        assertEquals(NETWORK_IMAGE_HEIGHT, mOnUiThread.getTitle());
    }

    // Verify that javascript cross-domain request permissions matches file domain settings
    // for iframes"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/webkit/src/android/webkit/cts/WebSettingsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.webkit.cts.WebSettingsTest"	"testIframesWhenAccessFromFileURLsEnabled"	"CtsWebkitTestCases"	"1: permission"	"([1:/android/webkit/cts/WebSettingsTest.java]:[permission]:[1]:method_text:[that javascript cross-domain request permissions matches file domain settings    // for iframes   ]) :|: public void testIframesWhenAccessFromFileURLsEnabled() throws Throwable {
        if (!NullWebViewUtils.isWebViewAvailable()) {
            return;
        }

        mSettings.setJavaScriptEnabled(true);
        // disable universal access from files
        mSettings.setAllowUniversalAccessFromFileURLs(false);
        mSettings.setAllowFileAccessFromFileURLs(true);

        // when cross file scripting is enabled, make sure cross domain requests succeed
        String url = TestHtmlConstants.getFileUrl(TestHtmlConstants.IFRAME_ACCESS_URL);
        mOnUiThread.loadUrlAndWaitForCompletion(url);
        String iframeUrl = TestHtmlConstants.getFileUrl(TestHtmlConstants.HELLO_WORLD_URL);
        assertEquals(iframeUrl, mOnUiThread.getTitle());
    }

    // Verify that javascript cross-domain request permissions matches file domain settings
    // for iframes"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/webkit/src/android/webkit/cts/WebSettingsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.webkit.cts.ServiceWorkerWebSettingsTest"	"testBlockNetworkLoads"	"CtsWebkitTestCases"	"2: INTERNET permission"	"([3:/android/webkit/cts/ServiceWorkerWebSettingsTest.java]:[permission]:[3]:method_text:[ockNetworkLoads(b);            assertEquals(b, mSettings.getBlockNetworkLoads());        }    }}]) :|: public void testBlockNetworkLoads() {
        if (!NullWebViewUtils.isWebViewAvailable()) {
            return;
        }

        // Note: we cannot test this setter unless we provide the INTERNET permission, otherwise we
        // get a SecurityException when we pass 'false'.
        final boolean hasInternetPermission = true;

        assertEquals(mSettings.getBlockNetworkLoads(), !hasInternetPermission);
        for (boolean b : new boolean[]{false, true}) {
            mSettings.setBlockNetworkLoads(b);
            assertEquals(b, mSettings.getBlockNetworkLoads());
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/webkit/src/android/webkit/cts/ServiceWorkerWebSettingsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.ThirdPartyCallScreeningServiceTest"	"revokeReadContactPermission"	"CtsTelecomTestCases"	"1: permission"	"([2:/android/telecom/cts/ThirdPartyCallScreeningServiceTest.java]:[permission]:[2]:method_text:[s that the system logs the blocked call to the call log.     *     * @throws Exception     */   ]) :|: public void test/*
 *
 */

package android.telecom.cts;

import static android.telecom.cts.TestUtils.shouldTestTelecom;
import static android.telecom.cts.TestUtils.waitOnAllHandlers;

import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;

import android.Manifest;
import android.app.role.RoleManager;
import android.content.ComponentName;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.content.pm.PackageManager;
import android.database.Cursor;
import android.net.Uri;
import android.os.Bundle;
import android.os.IBinder;
import android.os.Process;
import android.os.UserHandle;

import android.provider.CallLog;
import android.telecom.Call;
import android.telecom.CallScreeningService;
import android.telecom.TelecomManager;
import android.telecom.cts.screeningtestapp.CallScreeningServiceControl;
import android.telecom.cts.screeningtestapp.CtsCallScreeningService;
import android.telecom.cts.screeningtestapp.ICallScreeningControl;
import android.text.TextUtils;

import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

public class ThirdPartyCallScreeningServiceTest extends BaseTelecomTestWithMockServices {
    public static final String EXTRA_NETWORK_IDENTIFIED_EMERGENCY_CALL = ""identifiedEmergencyCall"";
    private static final String TAG = ThirdPartyCallScreeningServiceTest.class.getSimpleName();
    private static final String TEST_APP_NAME = ""CTSCSTest"";
    private static final String TEST_APP_PACKAGE = ""android.telecom.cts.screeningtestapp"";
    private static final String TEST_APP_COMPONENT =
            ""android.telecom.cts.screeningtestapp/""
                    + ""android.telecom.cts.screeningtestapp.CtsCallScreeningService"";
    private static final int ASYNC_TIMEOUT = 10000;
    p"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/ThirdPartyCallScreeningServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.ThirdPartyCallScreeningServiceTest"	"testHasPermissionAndNoContactIncoming"	"CtsTelecomTestCases"	"1: permission"	"([3:/android/telecom/cts/ThirdPartyCallScreeningServiceTest.java]:[permission]:[3]:method_text:[ shouldSkipNotification */);        addIncomingAndVerifyBlocked(false /* addContact */);    }   ]) :|: public void testHasPermissionAndNoContactIncoming() throws Exception {
        if (!shouldTestTelecom(mContext)) {
            return;
        }

        grantReadContactPermission();
        verifyPermission(true);
        // Tell the test app to block the call.
        mCallScreeningControl.setCallResponse(true /* shouldDisallowCall */,
                true /* shouldRejectCall */, false /* shouldSilenceCall */,
                false /* shouldSkipCallLog */, true /* shouldSkipNotification */);
        addIncomingAndVerifyBlocked(false /* addContact */);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/ThirdPartyCallScreeningServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.ThirdPartyCallScreeningServiceTest"	"testNoPermissionAndNoContactIncoming"	"CtsTelecomTestCases"	"1: permission"	"([2:/android/telecom/cts/ThirdPartyCallScreeningServiceTest.java]:[permission]:[2]:method_text:[ shouldSkipNotification */);        addIncomingAndVerifyBlocked(false /* addContact */);    }   ]) :|: public void testNoPermissionAndNoContactIncoming() throws Exception {
        if (!shouldTestTelecom(mContext)) {
            return;
        }

        verifyPermission(false);
        // Tell the test app to block the call.
        mCallScreeningControl.setCallResponse(true /* shouldDisallowCall */,
                true /* shouldRejectCall */, false /* shouldSilenceCall */,
                false /* shouldSkipCallLog */, true /* shouldSkipNotification */);
        addIncomingAndVerifyBlocked(false /* addContact */);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/ThirdPartyCallScreeningServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.ThirdPartyCallScreeningServiceTest"	"testHasPermissionAndHasContactIncoming"	"CtsTelecomTestCases"	"1: permission"	"([3:/android/telecom/cts/ThirdPartyCallScreeningServiceTest.java]:[permission]:[3]:method_text:[* shouldSkipNotification */);        addIncomingAndVerifyBlocked(true /* addContact */);    }   ]) :|: public void testHasPermissionAndHasContactIncoming() throws Exception {
        if (!shouldTestTelecom(mContext)) {
            return;
        }

        grantReadContactPermission();
        verifyPermission(true);
        mCallScreeningControl.setCallResponse(true /* shouldDisallowCall */,
                true /* shouldRejectCall */, false /* shouldSilenceCall */,
                false /* shouldSkipCallLog */, true /* shouldSkipNotification */);
        addIncomingAndVerifyBlocked(true /* addContact */);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/ThirdPartyCallScreeningServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.ThirdPartyCallScreeningServiceTest"	"testNoPermissionAndHasContactIncoming"	"CtsTelecomTestCases"	"1: permission"	"([2:/android/telecom/cts/ThirdPartyCallScreeningServiceTest.java]:[permission]:[2]:method_text:[* shouldSkipNotification */);        addIncomingAndVerifyAllowed(true /* addContact */);    }   ]) :|: public void testNoPermissionAndHasContactIncoming() throws Exception {
        if (!shouldTestTelecom(mContext)) {
            return;
        }

        verifyPermission(false);
        mCallScreeningControl.setCallResponse(true /* shouldDisallowCall */,
                true /* shouldRejectCall */, false /* shouldSilenceCall */,
                false /* shouldSkipCallLog */, true /* shouldSkipNotification */);
        addIncomingAndVerifyAllowed(true /* addContact */);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/ThirdPartyCallScreeningServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.ThirdPartyCallScreeningServiceTest"	"testHasPermissionAndNoContactOutgoing"	"CtsTelecomTestCases"	"1: permission"	"([3:/android/telecom/cts/ThirdPartyCallScreeningServiceTest.java]:[permission]:[3]:method_text:[ingCall(false /* addContact */);        assertTrue(mCallScreeningControl.waitForBind());    }   ]) :|: public void testHasPermissionAndNoContactOutgoing() throws Exception {
        if (!shouldTestTelecom(mContext)) {
            return;
        }

        grantReadContactPermission();
        verifyPermission(true);
        placeOutgoingCall(false /* addContact */);
        assertTrue(mCallScreeningControl.waitForBind());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/ThirdPartyCallScreeningServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.ThirdPartyCallScreeningServiceTest"	"testNoPermissionAndNoContactOutgoing"	"CtsTelecomTestCases"	"1: permission"	"([2:/android/telecom/cts/ThirdPartyCallScreeningServiceTest.java]:[permission]:[2]:method_text:[ingCall(false /* addContact */);        assertTrue(mCallScreeningControl.waitForBind());    }   ]) :|: public void testNoPermissionAndNoContactOutgoing() throws Exception {
        if (!shouldTestTelecom(mContext)) {
            return;
        }

        verifyPermission(false);
        placeOutgoingCall(false /* addContact */);
        assertTrue(mCallScreeningControl.waitForBind());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/ThirdPartyCallScreeningServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.ThirdPartyCallScreeningServiceTest"	"testHasPermissionAndHasContactOutgoing"	"CtsTelecomTestCases"	"1: permission"	"([3:/android/telecom/cts/ThirdPartyCallScreeningServiceTest.java]:[permission]:[3]:method_text:[ingCall(true /* addCountact */);        assertTrue(mCallScreeningControl.waitForBind());    }   ]) :|: public void testHasPermissionAndHasContactOutgoing() throws Exception {
        if (!shouldTestTelecom(mContext)) {
            return;
        }

        grantReadContactPermission();
        verifyPermission(true);
        placeOutgoingCall(true /* addCountact */);
        assertTrue(mCallScreeningControl.waitForBind());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/ThirdPartyCallScreeningServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.ThirdPartyCallScreeningServiceTest"	"testNoPermissionAndHasContactOutgoing"	"CtsTelecomTestCases"	"1: permission"	"([2:/android/telecom/cts/ThirdPartyCallScreeningServiceTest.java]:[permission]:[2]:method_text:[ngCall(true /* addCountact */);        assertFalse(mCallScreeningControl.waitForBind());    }   ]) :|: public void testNoPermissionAndHasContactOutgoing() throws Exception {
        if (!shouldTestTelecom(mContext)) {
            return;
        }

        verifyPermission(false);
        placeOutgoingCall(true /* addCountact */);
        assertFalse(mCallScreeningControl.waitForBind());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/ThirdPartyCallScreeningServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.ThirdPartyCallScreeningServiceTest"	"testNoPostCallActivityForIncomingEmergencyCall"	"CtsTelecomTestCases"	"1: permission"	"([17:/android/telecom/cts/ThirdPartyCallScreeningServiceTest.java]:[permission]:[17]:method_text:[D_CONTACTS, TEST_APP_PACKAGE)                        == PackageManager.PERMISSION_GRANTED);    }}]) :|: public void testNoPostCallActivityForIncomingEmergencyCall() throws Exception {
        if (!shouldTestTelecom(mContext)) {
            return;
        }
        setupForEmergencyCalling(TEST_EMERGENCY_NUMBER);
        mCallScreeningControl.setCallResponse(false /* shouldDisallowCall */,
                false /* shouldRejectCall */, false /* shouldSilenceCall */,
                false /* shouldSkipCallLog */, false /* shouldSkipNotification */);
        Bundle extras = new Bundle();
        extras.putParcelable(TelecomManager.EXTRA_INCOMING_CALL_ADDRESS, TEST_EMERGENCY_URI);
        extras.putBoolean(EXTRA_NETWORK_IDENTIFIED_EMERGENCY_CALL, true);
        mTelecomManager.addNewIncomingCall(TestUtils.TEST_PHONE_ACCOUNT_HANDLE, extras);

        // Wait until the new incoming call is processed.
        waitOnAllHandlers(getInstrumentation());
        mInCallCallbacks.getService().disconnectAllCalls();

        assertFalse(mCallScreeningControl.waitForActivity());
    }

    private void placeOutgoingCall(boolean addContact) throws Exception {
        // Setup content observer to notify us when we call log entry is added.
        CountDownLatch callLogEntryLatch = getCallLogEntryLatch();

        Uri contactUri = null;
        if (addContact) {
            contactUri = TestUtils.insertContact(mContentResolver,
                    TEST_OUTGOING_NUMBER.getSchemeSpecificPart());
        }

        try {
            Bundle extras = new Bundle();
            extras.putParcelable(TestUtils.EXTRA_PHONE_NUMBER, TEST_OUTGOING_NUMBER);
            // Create a new outgoing call.
            placeAndVerifyCall(extras);

            mInCallCallbacks.getService().disconnectAllCalls();
            assertNumCalls(mInCallCallbacks.getService(), 0);

            // Wait for it to log.
            callLogEntryLatch.await(ASYNC_TIMEOUT, TimeUnit.MILLISECONDS);
        } finally {
            if (addContact) {
                assertEquals(1, TestUtils.deleteContact(mContentResolver, contac"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/ThirdPartyCallScreeningServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.OutgoingCallTest"	"testAccountSelectionAvailable"	"CtsTelecomTestCases"	"1: permission"	"([2:/android/telecom/cts/OutgoingCallTest.java]:[permission]:[2]:method_text:[mTelecomManager.setUserSelectedOutgoingPhoneAccount(cachedHandle);            });        }    }}]) :|: public void testAccountSelectionAvailable() throws Exception {
        if (!mShouldTestTelecom) {
            return;
        }

        CountDownLatch latch = new CountDownLatch(1);
        mInCallCallbacks = new MockInCallService.InCallServiceCallbacks() {
            @Override
            public void onCallAdded(Call call, int numCalls) {
                if (call.getState() == STATE_SELECT_PHONE_ACCOUNT) {
                    latch.countDown();
                }
            }
        };
        MockInCallService.setCallbacks(mInCallCallbacks);

        mTelecomManager.registerPhoneAccount(TestUtils.TEST_PHONE_ACCOUNT);
        TestUtils.enablePhoneAccount(getInstrumentation(), TestUtils.TEST_PHONE_ACCOUNT_HANDLE);
        mTelecomManager.registerPhoneAccount(TestUtils.TEST_PHONE_ACCOUNT_2);
        TestUtils.enablePhoneAccount(getInstrumentation(), TestUtils.TEST_PHONE_ACCOUNT_HANDLE_2);

        PhoneAccountHandle cachedHandle = mTelecomManager.getUserSelectedOutgoingPhoneAccount();
        SystemUtil.runWithShellPermissionIdentity(() -> {
            mTelecomManager.setUserSelectedOutgoingPhoneAccount(null);
        });

        try {
            Uri testNumber = createTestNumber();
            mTelecomManager.placeCall(testNumber, null);

            assertTrue(latch.await(TestUtils.WAIT_FOR_CALL_ADDED_TIMEOUT_S, TimeUnit.SECONDS));
        } finally {
            SystemUtil.runWithShellPermissionIdentity(() -> {
                mTelecomManager.setUserSelectedOutgoingPhoneAccount(cachedHandle);
            });
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/OutgoingCallTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.CallDiagnosticServiceTest"	"onDisconnect"	"CtsTelecomTestCases"	"1: permission"	"([2:/android/telecom/cts/CallDiagnosticServiceTest.java]:[permission]:[2]:method_text:[ adding a call binds to the call diagnostic service.     * @throws InterruptedException     */   ]) :|: public void test/*
 *.
 */

package android.telecom.cts;

import static android.telecom.cts.TestUtils.WAIT_FOR_STATE_CHANGE_TIMEOUT_MS;
import static android.telecom.cts.TestUtils.shouldTestTelecom;

import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;

import android.content.Context;
import android.os.Bundle;
import android.telecom.BluetoothCallQualityReport;
import android.telecom.Call;
import android.telecom.CallAudioState;
import android.telecom.CallDiagnostics;
import android.telecom.Connection;
import android.telecom.DisconnectCause;
import android.telecom.TelecomManager;
import android.telephony.CallQuality;
import android.telephony.TelephonyManager;

import java.util.concurrent.TimeUnit;

public class CallDiagnosticServiceTest extends BaseTelecomTestWithMockServices {
    private static final String POOR_CALL_MESSAGE = ""Can you hear me?"";
    private static final String OVERRIDE_MESSAGE = ""Whoopsie doodles; call dropped.  Oh well."";
    private static final int POOR_MESSAGE_ID = 90210;
    private TelecomManager mTelecomManager;
    private MockConnection mConnection;
    private android.telecom.Call mCall;
    private CtsCallDiagnosticService mService;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        if (!shouldTestTelecom(mContext)) {
            return;
        }
        mTelecomManager = (TelecomManager) mContext.getSystemService(Context.TELECOM_SERVICE);

        setupConnectionService(null, FLAG_REGISTER | FLAG_ENABLE);
        runWithShellPermissionIdentity(() -> {
                    // Make sure there is a sim account registered.
                    mTelecomManager.registerPhoneAccount(TestUtils.TEST_SIM_PHONE_ACCOUNT);
                });
        TestUtils.enablePhoneAccount(
                getInstrumentation(), TestUtils.TEST_SIM_PHONE_ACCOUNT_HANDLE);
        TestUtils.setCallDiagnosticService(getInstrumentation(), TestUtils.PACKAGE);
    }

    @Override
    pr"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/CallDiagnosticServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.ConferenceTest"	"testConferenceCreate"	"CtsTelecomTestCases"	"1: permission"	"([1:/android/telecom/cts/ConferenceTest.java]:[permission]:[1]:method_text:[ } catch (InterruptedException e) {            fail(""Couldn't get TTY mode."");        }    }   ]) :|: public void testConferenceCreate() {
        if (!mShouldTestTelecom) {
            return;
        }
        final Call conf = mInCallService.getLastConferenceCall();
        assertCallState(conf, Call.STATE_ACTIVE);

        if (mCall1.getParent() != conf || mCall2.getParent() != conf) {
            fail(""The 2 participating calls should contain the conference call as its parent"");
        }
        if (!(conf.getChildren().contains(mCall1) && conf.getChildren().contains(mCall2))) {
            fail(""The conference call should contain the 2 participating calls as its children"");
        }
        assertTrue(mConferenceObject.getConnections().contains(mConnection1));

        assertConnectionState(mConferenceObject.getConnections().get(0), Connection.STATE_ACTIVE);
        assertConnectionState(mConferenceObject.getConnections().get(1), Connection.STATE_ACTIVE);
        assertConferenceState(mConferenceObject, Connection.STATE_ACTIVE);

        LinkedBlockingQueue<Connection> queue = new LinkedBlockingQueue(1);
        runWithShellPermissionIdentity(() ->
                queue.put(mConferenceObject.getPrimaryConnection()));
        try {
            Connection primaryConnection = queue.poll(TestUtils.WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                    TimeUnit.MILLISECONDS);
            assertEquals(mConferenceObject.getConnections().get(0), primaryConnection);
        } catch (InterruptedException e) {
            fail(""Couldn't get TTY mode."");
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/ConferenceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.ConferenceTest"	"testConferenceSetters"	"CtsTelecomTestCases"	"1: permission"	"([4:/android/telecom/cts/ConferenceTest.java]:[permission]:[4]:method_text:[ propagation of the {@link Conference} properties to the associated     * {@link Call}.     */   ]) :|: public void testConferenceSetters() {
        if (!mShouldTestTelecom) {
            return;
        }
        final Call conf = mInCallService.getLastConferenceCall();
        assertCallState(conf, Call.STATE_ACTIVE);

        placeAndVerifyCall();
        MockConnection newConnection = verifyConnectionForOutgoingCall(2);
        final Call newCall = mInCallService.getLastCall();

        ArrayList<Connection> connectionList = new ArrayList<>();
        connectionList.add(newConnection);
        ArrayList<Call> callList = new ArrayList<>();
        callList.add(newCall);

        assertFalse(conf.getDetails().can(Call.Details.CAPABILITY_MUTE));
        int capabilities = mConferenceObject.getConnectionCapabilities() |
                Connection.CAPABILITY_MUTE;
        mConferenceObject.setConnectionCapabilities(capabilities);
        assertCallCapability(conf, Call.Details.CAPABILITY_MUTE);

        assertFalse(conf.getConferenceableCalls().contains(newCall));
        mConferenceObject.setConferenceableConnections(connectionList);
        assertCallConferenceableList(conf, callList);

        // Consumed internally in Telecom; no verifiable manner to see the end point of this data
        // through public APIs.
        mConferenceObject.setConnectionTime(0);
        mConferenceObject.setConnectionStartElapsedRealtimeMillis(0);

        Bundle extras = new Bundle();
        extras.putString(TelecomManager.EXTRA_CALL_DISCONNECT_MESSAGE, ""Test"");
        assertFalse(conf.getDetails().getExtras().containsKey(
                TelecomManager.EXTRA_CALL_DISCONNECT_MESSAGE));
        mConferenceObject.setExtras(extras);
        assertCallExtras(conf, TelecomManager.EXTRA_CALL_DISCONNECT_MESSAGE, ""Test"");

        StatusHints hints = new StatusHints(""Test"", null, null);
        assertNull(conf.getDetails().getStatusHints());
        mConferenceObject.setStatusHints(hints);
        assertCallStatusHints(conf, hints);

        assertFalse(conf.getChildren().contains(newCall"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/ConferenceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.PhoneAccountOperationsTest"	"createTestBundle"	"CtsTelecomTestCases"	"1: permission"	"([1:/android/telecom/cts/PhoneAccountOperationsTest.java]:[permission]:[1]:method_text:[Null(""Test account not deregistered."", retrievedPhoneAccount);        super.tearDown();    }   ]) :|: public void test/*
 *.
 */

package android.telecom.cts;

import static android.telecom.cts.TestUtils.*;

import android.content.ComponentName;
import android.content.Context;
import android.graphics.Color;
import android.net.Uri;
import android.os.Bundle;
import android.telecom.PhoneAccount;
import android.telecom.PhoneAccountHandle;
import android.telecom.TelecomManager;
import android.test.InstrumentationTestCase;
import android.text.TextUtils;

import com.android.compatibility.common.util.ShellIdentityUtils;

import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.List;


/**
 * Verifies some of the PhoneAccount registration related operations.
 */
public class PhoneAccountOperationsTest extends InstrumentationTestCase {
    public static final PhoneAccountHandle TEST_PHONE_ACCOUNT_HANDLE =
            new PhoneAccountHandle(new ComponentName(PACKAGE, COMPONENT), ACCOUNT_ID_1);
    public static final Bundle TEST_BUNDLE = createTestBundle();
    public static final int TEST_LENGTH = 10;
    public static final String TEST_ENCODING = ""enUS"";

    private TestUtils.InvokeCounter mPhoneAccountRegisteredLatch;
    private TestUtils.InvokeCounter mPhoneAccountUnRegisteredLatch;

    MockPhoneAccountChangedReceiver.IntentListener mPhoneAccountIntentListener =
            new MockPhoneAccountChangedReceiver.IntentListener() {
                @Override
                public void onPhoneAccountRegistered(PhoneAccountHandle handle) {
                    mPhoneAccountRegisteredLatch.invoke(handle);
                }

                @Override
                public void onPhoneAccountUnregistered(PhoneAccountHandle handle) {
                    mPhoneAccountUnRegisteredLatch.invoke(handle);
                }
            };

    private static Bundle createTestBundle() {
        Bundle testBundle = new Bundle();
        testBundle.putInt(PhoneAccount.EXTRA_CALL_SUBJECT_MAX_LENGTH, TEST_LENGTH);
        testBundle.putString(PhoneAccount.EXTRA_CALL_SUBJECT"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/PhoneAccountOperationsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.PhoneAccountOperationsTest"	"testRegisterPhoneAccount_correctlyThrowsSecurityException"	"CtsTelecomTestCases"	"1: permission"	"([1:/android/telecom/cts/PhoneAccountOperationsTest.java]:[permission]:[1]:method_text:[Of(                    ""android.permission.REGISTER_SIM_SUBSCRIPTION"") >= 0));        }    }   ]) :|: public void testRegisterPhoneAccount_correctlyThrowsSecurityException() throws Exception {
        if (!shouldTestTelecom(mContext)) {
            return;
        }
        try {
            mTelecomManager.registerPhoneAccount(TEST_SIM_PHONE_ACCOUNT);
            fail(""TelecomManager.registerPhoneAccount should throw SecurityException if ""
                    + ""not a system app."");
        } catch (SecurityException e) {
            assertTrue(""Unexpected security exception."", (e.getMessage().indexOf(
                    ""android.permission.REGISTER_SIM_SUBSCRIPTION"") >= 0));
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/PhoneAccountOperationsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.PhoneAccountOperationsTest"	"testRegisterPhoneAccount_ListEnabledAccounts"	"CtsTelecomTestCases"	"1: permission"	"([1:/android/telecom/cts/PhoneAccountOperationsTest.java]:[permission]:[1]:method_text:[ain the test account."",                newAccounts.contains(TEST_PHONE_ACCOUNT_HANDLE));    }   ]) :|: public void testRegisterPhoneAccount_ListEnabledAccounts() throws Exception {
        if (!shouldTestTelecom(mContext)) {
            return;
        }
        mTelecomManager.registerPhoneAccount(TEST_NO_SIM_PHONE_ACCOUNT);
        final List<PhoneAccountHandle> oldAccounts = mTelecomManager.getCallCapablePhoneAccounts();
        final int oldAccountsListSize = oldAccounts.size();
        if (oldAccountsListSize > 0) {
            assertFalse(""Enabled Phone accounts should not contain the test account."",
                    oldAccounts.contains(TEST_PHONE_ACCOUNT_HANDLE));
        }

        try {
            final List<PhoneAccountHandle> allAccounts =
                    mTelecomManager.getCallCapablePhoneAccounts(true);
            assertTrue(""No results expected without READ_PRIVILEGED_PHONE_STATE"",
                    allAccounts.isEmpty());
        } catch (SecurityException e) {
            // expected
        }

        final List<PhoneAccountHandle> allAccounts =
                ShellIdentityUtils.invokeMethodWithShellPermissions(mTelecomManager,
                        (telecomManager) -> telecomManager.getCallCapablePhoneAccounts(true));
        assertTrue(""All Phone accounts should contain the test account."",
                allAccounts.contains(TEST_PHONE_ACCOUNT_HANDLE));

        TestUtils.enablePhoneAccount(getInstrumentation(), TEST_PHONE_ACCOUNT_HANDLE);
        final List<PhoneAccountHandle> newAccounts = mTelecomManager.getCallCapablePhoneAccounts();
        assertNotNull(""No enabled Phone account found."", newAccounts);
        assertEquals(""1 new enabled Phone account expected."", newAccounts.size(),
                oldAccountsListSize + 1);
        assertTrue(""Enabled Phone accounts do not contain the test account."",
                newAccounts.contains(TEST_PHONE_ACCOUNT_HANDLE));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/PhoneAccountOperationsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.CarModeInCallServiceTest"	"dropShellPermissionIdentity"	"CtsTelecomTestCases"	"1: permission"	"([5:/android/telecom/cts/CarModeInCallServiceTest.java]:[permission]:[5]:method_text:[  * Verifies that a car mode InCallService can enter and exit car mode using a priority.     */   ]) :|: public void test/*
 *.
 */

package android.telecom.cts;

import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_DISABLED;
import static android.content.pm.PackageManager.COMPONENT_ENABLED_STATE_ENABLED;
import static android.content.pm.PackageManager.DONT_KILL_APP;

import android.app.UiModeManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.content.res.Configuration;
import android.content.pm.PackageManager;
import android.net.Uri;
import android.os.Bundle;
import android.os.IBinder;
import android.os.RemoteException;
import android.telecom.TelecomManager;
import android.telecom.cts.carmodetestapp.ICtsCarModeInCallServiceControl;
import android.util.Log;

import androidx.test.InstrumentationRegistry;

import junit.framework.AssertionFailedError;

import org.junit.Assert;
import org.junit.Test;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

public class CarModeInCallServiceTest extends BaseTelecomTestWithMockServices {
    private static final int ASYNC_TIMEOUT = 10000;
    private static final String CARMODE_APP1_PACKAGE = ""android.telecom.cts.carmodetestapp"";
    private static final String CARMODE_APP2_PACKAGE = ""android.telecom.cts.carmodetestapptwo"";
    private ICtsCarModeInCallServiceControl mCarModeIncallServiceControlOne;
    private ICtsCarModeInCallServiceControl mCarModeIncallServiceControlTwo;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        if (!mShouldTestTelecom) {
            return;
        }

        if (mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) {
            return;
        }

        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(""android.permission.ENTER_CAR_MODE_PRIORITIZED"","	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/CarModeInCallServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.ThirdPartyInCallServiceTest"	"isDialerRoleAvailable"	"CtsTelecomTestCases"	"1: permission"	"([3:/android/telecom/cts/ThirdPartyInCallServiceTest.java]:[permission]:[3]:method_text:[    * the app holding the {@link RoleManager#ROLE_DIALER} role.     * @throws Exception     */   ]) :|: public void test/*
 *.
 */

package android.telecom.cts;

import static android.telecom.cts.TestUtils.WAIT_FOR_STATE_CHANGE_TIMEOUT_MS;

import android.Manifest;
import android.app.UiModeManager;
import android.app.role.RoleManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.IBinder;
import android.os.RemoteException;
import android.telecom.TelecomManager;
import android.telecom.cts.thirdptydialer.CtsThirdPtyDialerInCallServiceControl;
import android.telecom.cts.thirdptyincallservice.CtsThirdPartyInCallService;
import android.telecom.cts.thirdptyincallservice.CtsThirdPartyInCallServiceControl;
import android.telecom.cts.thirdptyincallservice.ICtsThirdPartyInCallServiceControl;
import android.util.Log;

import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

public class ThirdPartyInCallServiceTest extends BaseTelecomTestWithMockServices {

    private static final String TAG = ThirdPartyInCallServiceTest.class.getSimpleName();
    private Context mContext;
    private CtsRoleManagerAdapter mCtsRoleManagerAdapter;
    ICtsThirdPartyInCallServiceControl mICtsThirdPartyInCallServiceControl;
    private boolean mSkipNullUnboundLatch;
    private String mPreviousRoleHolder;
    private String mThirdPartyPackageName;
    private boolean mIsDialerRoleAvailable;

    @Override
    public void setUp() throws Exception {
        super.setUp();
        mContext = getInstrumentation().getContext();
        mCtsRoleManagerAdapter = new CtsRoleManagerAdapter(getInstrumentation());

        // Do not continue with tests if the Dialer role is not available.
        mIsDialerRoleAvailable = mCtsRoleManagerAdapter.isDialerRoleAvailable();
        if (!mIsDialerRoleAvailable) return;

        setUpControl();
        mICtsThirdPartyInCallServiceControl.resetLatchForServiceBound(false);
        mThirdPartyPackageName = Ct"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/ThirdPartyInCallServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.ThirdPartyInCallServiceTest"	"testPermissionGranted"	"CtsTelecomTestCases"	"1: permission"	"([9:/android/telecom/cts/ThirdPartyInCallServiceTest.java]:[permission]:[9]:method_text:[        }        bindLatch.await(WAIT_FOR_STATE_CHANGE_TIMEOUT_MS, TimeUnit.MILLISECONDS);    }}]) :|: public void testPermissionGranted() throws Exception {
        if (!mIsDialerRoleAvailable) return;

        assertFalse(mICtsThirdPartyInCallServiceControl.checkPermissionGrant(
                Manifest.permission.READ_VOICEMAIL));
        assertFalse(mICtsThirdPartyInCallServiceControl.checkPermissionGrant(
                Manifest.permission.WRITE_VOICEMAIL));
        mCtsRoleManagerAdapter.setDialerRoleHolder(mThirdPartyPackageName);
        assertTrue(mICtsThirdPartyInCallServiceControl.checkPermissionGrant(
                Manifest.permission.READ_VOICEMAIL));
        assertTrue(mICtsThirdPartyInCallServiceControl.checkPermissionGrant(
                Manifest.permission.WRITE_VOICEMAIL));
    }

    private void setUpControl() throws InterruptedException {
        Intent bindIntent = new Intent(CtsThirdPartyInCallServiceControl.CONTROL_INTERFACE_ACTION);
        // mContext is android.telecom.cts, which doesn't include thirdptyincallservice.
        ComponentName controlComponentName =
                ComponentName.createRelative(
                        CtsThirdPtyDialerInCallServiceControl.class.getPackage().getName(),
                        CtsThirdPtyDialerInCallServiceControl.class.getName());

        bindIntent.setComponent(controlComponentName);
        final CountDownLatch bindLatch = new CountDownLatch(1);
        boolean success = mContext.bindService(bindIntent, new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                Log.i(TAG, ""Service Connected: "" + name);
                mICtsThirdPartyInCallServiceControl =
                        ICtsThirdPartyInCallServiceControl.Stub.asInterface(service);
                bindLatch.countDown();
            }

            @Override
            public void onServiceDisconnected(ComponentName name) {
                mICtsThirdPartyInCallServiceControl = null;
            }
        }, Context.BIND_AUTO_CREATE);
        if"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/ThirdPartyInCallServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.DefaultPhoneAccountTest"	"testSetUserSelectedOutgoingPhoneAccount"	"CtsTelecomTestCases"	"1: permission"	"([1:/android/telecom/cts/DefaultPhoneAccountTest.java]:[permission]:[1]:method_text:[ or more potential outgoing phone accounts with the TEL scheme.     * @throws Exception     */   ]) :|: public void testSetUserSelectedOutgoingPhoneAccount() throws Exception {
        if (!mShouldTestTelecom) {
            return;
        }
        // Make sure to set the default outgoing phone account to the new connection service
        setupConnectionService(null, FLAG_REGISTER | FLAG_ENABLE);

        PhoneAccountHandle previousOutgoingPhoneAccount =
                mTelecomManager.getUserSelectedOutgoingPhoneAccount();

        try {
            // Use TelecomManager API to set the outgoing phone account.
            runWithShellPermissionIdentity(() ->
                    mTelecomManager.setUserSelectedOutgoingPhoneAccount(
                            TestUtils.TEST_PHONE_ACCOUNT_HANDLE));

            PhoneAccountHandle handle = mTelecomManager.getUserSelectedOutgoingPhoneAccount();
            assertEquals(TestUtils.TEST_PHONE_ACCOUNT_HANDLE, handle);

            PhoneAccountHandle defaultOutgoing = mTelecomManager.getDefaultOutgoingPhoneAccount(
                    PhoneAccount.SCHEME_TEL);
            assertEquals(TestUtils.TEST_PHONE_ACCOUNT_HANDLE, defaultOutgoing);
        } finally {
            // Restore the default outgoing phone account.
            TestUtils.setDefaultOutgoingPhoneAccount(getInstrumentation(),
                    previousOutgoingPhoneAccount);
        }
    }

    /**
     * Verifies operation of the {@link TelecomManager#getDefaultOutgoingPhoneAccount(String)} API
     * where there is NO user selected default outgoing phone account.
     * In AOSP, this mimics the user having changed the
     * Phone --> Settings --> Call Settings --> Calling accounts --> Make Calls With
     * option to ""Ask first"".
     *
     * The test assumes that a device either has a single sim, or has multiple sims.
     * In either case, it registers another TEL outgoing calling account.
     *
     * We can expect two things:
     * 1. {@link TelecomManager#getUserSelectedOutgoingPhoneAccount()} returns null, since the
     *    ""ask first"" option was"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/DefaultPhoneAccountTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.BackgroundCallAudioTest"	"isCallScreeningModeSupported"	"CtsTelecomTestCases"	"1: permission"	"([1:/android/telecom/cts/BackgroundCallAudioTest.java]:[permission]:[1]:method_text:[   MockCallScreeningService.disableService(mContext);        }        super.tearDown();    }   ]) :|: public void testpackage android.telecom.cts;

import static android.app.role.RoleManager.ROLE_CALL_SCREENING;
import static android.telecom.cts.TestUtils.TEST_PHONE_ACCOUNT_HANDLE;
import static android.telecom.cts.TestUtils.waitOnAllHandlers;
import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;

import android.app.role.RoleManager;
import android.content.Context;
import android.content.ServiceConnection;
import android.media.AudioManager;
import android.os.Bundle;
import android.os.Process;
import android.os.UserHandle;
import android.provider.CallLog;
import android.telecom.Call;
import android.telecom.Call.Details;
import android.telecom.CallScreeningService.CallResponse;
import android.telecom.Connection;
import android.telecom.DisconnectCause;
import android.telecom.TelecomManager;
import android.telecom.VideoProfile;
import android.telecom.cts.MockCallScreeningService.CallScreeningServiceCallbacks;
import android.telecom.cts.api29incallservice.ICtsApi29InCallServiceControl;
import android.text.TextUtils;
import android.util.Pair;

import androidx.test.InstrumentationRegistry;

import java.util.concurrent.Executor;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

public class BackgroundCallAudioTest extends BaseTelecomTestWithMockServices {
    private static final String LOG_TAG = BackgroundCallAudioTest.class.getSimpleName();

    private static final int ASYNC_TIMEOUT = 10000;
    private RoleManager mRoleManager;
    private ServiceConnection mApiCompatControlServiceConnection;

    // copied from AudioSystem.java -- defined here because that change isn't in AOSP yet.
    private static final int MODE_CALL_SCREENING = 4;

    // true if there's platform support for call screening in the audio stack.
    private boolean doesAudioManagerSupportCallScreening = false;

    private String mPreviousDefaultDialer = null;

    @Override
    protected void setUp() throws Exception {"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/BackgroundCallAudioTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.BackgroundCallAudioTest"	"testEnterAudioProcessingWithoutPermission"	"CtsTelecomTestCases"	"1: permission"	"([1:/android/telecom/cts/BackgroundCallAudioTest.java]:[permission]:[1]:method_text:[ityException"");        } catch (SecurityException e) {            // expected        }    }   ]) :|: public void testEnterAudioProcessingWithoutPermission() {
        if (!mShouldTestTelecom) {
            return;
        }

        if (true) {
            // TODO: enable test
            return;
        }

        placeAndVerifyCall();
        final MockConnection connection = verifyConnectionForOutgoingCall();

        final MockInCallService inCallService = mInCallCallbacks.getService();

        connection.setActive();
        final Call call = inCallService.getLastCall();
        assertCallState(call, Call.STATE_ACTIVE);

        try {
            call.enterBackgroundAudioProcessing();
            fail(""Expected SecurityException"");
        } catch (SecurityException e) {
            // expected
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/BackgroundCallAudioTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.BackgroundCallAudioTest"	"testLowerApiLevelCompatibility1"	"CtsTelecomTestCases"	"1: permission"	"([3:/android/telecom/cts/BackgroundCallAudioTest.java]:[permission]:[3]:method_text:[ntation().getUiAutomation()                    .dropShellPermissionIdentity();        }    }   ]) :|: public void testLowerApiLevelCompatibility1() throws Exception {
        if (!mShouldTestTelecom) {
            return;
        }

        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(""android.permission.CONTROL_INCALL_EXPERIENCE"");
        try {
            ICtsApi29InCallServiceControl controlInterface = setUpControl();

            setupIncomingCallWithCallScreening();

            final MockConnection connection = verifyConnectionForIncomingCall();

            if (!mInCallCallbacks.lock.tryAcquire(TestUtils.WAIT_FOR_CALL_ADDED_TIMEOUT_S,
                    TimeUnit.SECONDS)) {
                fail(""No call added to InCallService."");
            }

            Call call = mInCallCallbacks.getService().getLastCall();
            assertCallState(call, Call.STATE_AUDIO_PROCESSING);
            assertConnectionState(connection, Connection.STATE_ACTIVE);
            // Make sure that the test app never got any calls
            assertEquals(0, controlInterface.getHistoricalCallCount());

            call.exitBackgroundAudioProcessing(true);
            assertCallState(call, Call.STATE_SIMULATED_RINGING);
            waitOnAllHandlers(getInstrumentation());
            assertConnectionState(connection, Connection.STATE_ACTIVE);
            // Make sure that the test app sees a ringing call.
            assertEquals(Call.STATE_RINGING,
                    controlInterface.getCallState(call.getDetails().getTelecomCallId()));

            call.answer(VideoProfile.STATE_AUDIO_ONLY);
            assertCallState(call, Call.STATE_ACTIVE);
            waitOnAllHandlers(getInstrumentation());
            assertConnectionState(connection, Connection.STATE_ACTIVE);
            // Make sure that the test app sees an active call.
            assertEquals(Call.STATE_ACTIVE,
                    controlInterface.getCallState(call.getDetails().getTelecomCallId()));

            tearDownControl();
        } finally {"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/BackgroundCallAudioTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.BackgroundCallAudioTest"	"testLowerApiLevelCompatibility2"	"CtsTelecomTestCases"	"1: permission"	"([4:/android/telecom/cts/BackgroundCallAudioTest.java]:[permission]:[4]:method_text:[olean result = queue.poll(ASYNC_TIMEOUT, TimeUnit.MILLISECONDS);        assertTrue(result);    }}]) :|: public void testLowerApiLevelCompatibility2() throws Exception {
        if (!mShouldTestTelecom) {
            return;
        }
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(""android.permission.CONTROL_INCALL_EXPERIENCE"");
        try {
            ICtsApi29InCallServiceControl controlInterface = setUpControl();

            setupIncomingCallWithCallScreening();

            final MockConnection connection = verifyConnectionForIncomingCall();

            if (!mInCallCallbacks.lock.tryAcquire(TestUtils.WAIT_FOR_CALL_ADDED_TIMEOUT_S,
                    TimeUnit.SECONDS)) {
                fail(""No call added to InCallService."");
            }

            Call call = mInCallCallbacks.getService().getLastCall();
            assertCallState(call, Call.STATE_AUDIO_PROCESSING);
            assertConnectionState(connection, Connection.STATE_ACTIVE);
            // Make sure that the test app never got any calls
            assertEquals(0, controlInterface.getHistoricalCallCount());

            call.disconnect();
            assertCallState(call, Call.STATE_DISCONNECTED);
            waitOnAllHandlers(getInstrumentation());
            assertConnectionState(connection, Connection.STATE_DISCONNECTED);
            // Under some rare circumstances, the test app might get a flash of the disconnection
            // call, so we won't do the call count check again.

            tearDownControl();
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                    .dropShellPermissionIdentity();
        }
    }

    private Connection placeActiveOutgoingCall() {
        placeAndVerifyCall();

        Call call = mInCallCallbacks.getService().getLastCall();
        assertCallState(call, Call.STATE_DIALING);

        final MockConnection connection = verifyConnectionForOutgoingCall();
        connection.setActive();
        assertCallState(call, Call.STATE_ACTIV"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/BackgroundCallAudioTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.IncomingCallTest"	"testRingOnIncomingCall"	"CtsTelecomTestCases"	"1: permission"	"([2:/android/telecom/cts/IncomingCallTest.java]:[permission]:[2]:method_text:[n registered for the PhoneAccountHandle, then     * a SecurityException will be thrown.     */   ]) :|: public void testRingOnIncomingCall() throws Exception {
        if (!mShouldTestTelecom) {
            return;
        }
        ShellIdentityUtils.invokeStaticMethodWithShellPermissions(
                (ShellIdentityUtils.StaticShellPermissionMethodHelper<Void>) () -> {
                    RingtoneManager.setActualDefaultRingtoneUri(mContext,
                            RingtoneManager.TYPE_RINGTONE,
                            Settings.System.DEFAULT_RINGTONE_URI);
                    return null;
                });
        LinkedBlockingQueue<Boolean> queue = new LinkedBlockingQueue(1);
        setupConnectionService(null, FLAG_REGISTER | FLAG_ENABLE);
        AudioManager audioManager = mContext.getSystemService(AudioManager.class);
        AudioManager.AudioPlaybackCallback callback = new AudioManager.AudioPlaybackCallback() {
            @Override
            public void onPlaybackConfigChanged(List<AudioPlaybackConfiguration> configs) {
                super.onPlaybackConfigChanged(configs);
                boolean isPlayingRingtone = configs.stream()
                        .anyMatch(c -> c.getAudioAttributes().getUsage()
                                == USAGE_NOTIFICATION_RINGTONE);
                if (isPlayingRingtone && queue.isEmpty()) {
                    queue.add(isPlayingRingtone);
                }
            }
        };
        audioManager.registerAudioPlaybackCallback(callback, new Handler(Looper.getMainLooper()));
        Uri testNumber = createTestNumber();
        addAndVerifyNewIncomingCall(testNumber, null);
        verifyConnectionForIncomingCall();
        verifyPhoneStateListenerCallbacksForCall(CALL_STATE_RINGING,
                testNumber.getSchemeSpecificPart());
        Boolean ringing = queue.poll(WAIT_FOR_STATE_CHANGE_TIMEOUT_MS, TimeUnit.MILLISECONDS);
        assertNotNull(""Telecom should have played a ringtone, timed out waiting for state change"",
                ringing);
        assertTrue(""Telecom should have played a"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/IncomingCallTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.TelecomManagerTest"	"testGetCurrentTtyMode"	"CtsTelecomTestCases"	"1: permission"	"([1:/android/telecom/cts/TelecomManagerTest.java]:[permission]:[1]:method_text:[ {            fail(""Couldn't get TTY mode."");            e.printStackTrace();        }    }   ]) :|: public void testGetCurrentTtyMode() {
        if (!mShouldTestTelecom) {
            return;
        }

        LinkedBlockingQueue<Integer> queue = new LinkedBlockingQueue(1);
        runWithShellPermissionIdentity(() ->
                queue.put(mTelecomManager.getCurrentTtyMode()));
        try {
            int currentTtyMode = queue.poll(TestUtils.WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                    TimeUnit.MILLISECONDS);
            assertEquals(TelecomManager.TTY_MODE_OFF, currentTtyMode);
            assertFalse(TelecomManager.TTY_MODE_FULL == currentTtyMode);
            assertFalse(TelecomManager.TTY_MODE_HCO == currentTtyMode);
            assertFalse(TelecomManager.TTY_MODE_VCO == currentTtyMode);
        } catch (InterruptedException e) {
            fail(""Couldn't get TTY mode."");
            e.printStackTrace();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/TelecomManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.TelecomManagerTest"	"testHasManageOngoingCallsPermission"	"CtsTelecomTestCases"	"1: permission"	"([5:/android/telecom/cts/TelecomManagerTest.java]:[permission]:[5]:method_text:[ndException ex) {            fail(""Couldn't get uid for android.telecom.cts"");        }    }   ]) :|: public void testHasManageOngoingCallsPermission() {
        if (!mShouldTestTelecom) {
            return;
        }
        AppOpsManager appOpsManager = mContext.getSystemService(AppOpsManager.class);
        PackageManager packageManager = mContext.getPackageManager();
        try {
            final int uid = packageManager.getApplicationInfo(CTS_TELECOM_PKG, 0).uid;
            invokeMethodWithShellPermissionsNoReturn(appOpsManager,
                    (appOpsMan) -> appOpsMan.setUidMode(AppOpsManager.OPSTR_MANAGE_ONGOING_CALLS,
                            uid, AppOpsManager.MODE_ALLOWED));
            assertTrue(mTelecomManager.hasManageOngoingCallsPermission());
            invokeMethodWithShellPermissionsNoReturn(appOpsManager,
                    (appOpsMan) -> appOpsMan.setUidMode(AppOpsManager.OPSTR_MANAGE_ONGOING_CALLS,
                            uid, AppOpsManager.opToDefaultMode(
                                    AppOpsManager.OPSTR_MANAGE_ONGOING_CALLS)));
            assertFalse(mTelecomManager.hasManageOngoingCallsPermission());
        } catch (PackageManager.NameNotFoundException ex) {
            fail(""Couldn't get uid for android.telecom.cts"");
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/TelecomManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.TelecomManagerTest"	"testTtyModeBroadcasts"	"CtsTelecomTestCases"	"1: permission"	"([2:/android/telecom/cts/TelecomManagerTest.java]:[permission]:[2]:method_text:[hShellPermissionIdentity(() -> mContext.sendBroadcast(revertPreferredTtyMode));        }    }   ]) :|: public void testTtyModeBroadcasts() {
        // We only expect the actual tty mode to change if there's a wired headset plugged in, so
        // don't do the test if there isn't one plugged in.
        if (!mShouldTestTelecom || !isWiredHeadsetPluggedIn()) {
            return;
        }
        LinkedBlockingQueue<Intent> ttyModeQueue = new LinkedBlockingQueue<>(1);
        BroadcastReceiver ttyModeReceiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                if (TelecomManager.ACTION_CURRENT_TTY_MODE_CHANGED.equals(intent.getAction())) {
                    ttyModeQueue.offer(intent);
                }
            }
        };
        mContext.registerReceiver(ttyModeReceiver,
                new IntentFilter(TelecomManager.ACTION_CURRENT_TTY_MODE_CHANGED));
        Intent changePreferredTtyMode =
                new Intent(TelecomManager.ACTION_TTY_PREFERRED_MODE_CHANGED);
        changePreferredTtyMode.putExtra(TelecomManager.EXTRA_TTY_PREFERRED_MODE,
                TelecomManager.TTY_MODE_FULL);

        try {
            runWithShellPermissionIdentity(() -> mContext.sendBroadcast(changePreferredTtyMode));
            Intent intent = ttyModeQueue.poll(
                    TestUtils.WAIT_FOR_STATE_CHANGE_TIMEOUT_MS, TimeUnit.MILLISECONDS);
            assertTrue(intent.hasExtra(TelecomManager.EXTRA_CURRENT_TTY_MODE));
            assertEquals(TelecomManager.TTY_MODE_FULL,
                    intent.getIntExtra(TelecomManager.EXTRA_CURRENT_TTY_MODE, -1));
        } catch (InterruptedException e) {
            fail(""interrupted"");
        } finally {
            Intent revertPreferredTtyMode =
                    new Intent(TelecomManager.ACTION_TTY_PREFERRED_MODE_CHANGED);
            revertPreferredTtyMode.putExtra(TelecomManager.EXTRA_TTY_PREFERRED_MODE,
                    TelecomManager.TTY_MODE_OFF);
            runWithShellPermissionIdentity(() -> mContext.sendBroadcast(reve"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/TelecomManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.TelecomManagerTest"	"testIsInEmergencyCall_noOngoingEmergencyCall"	"CtsTelecomTestCases"	"1: permission"	"([1:/android/telecom/cts/TelecomManagerTest.java]:[permission]:[1]:method_text:[ fail(""Couldn't check if in emergency call."");            e.printStackTrace();        }    }   ]) :|: public void testIsInEmergencyCall_noOngoingEmergencyCall() {
        if (!mShouldTestTelecom) {
            return;
        }

        LinkedBlockingQueue<Boolean> queue = new LinkedBlockingQueue(1);
        runWithShellPermissionIdentity(() ->
                queue.put(mTelecomManager.isInEmergencyCall()));
        try {
            boolean isInEmergencyCall = queue.poll(TestUtils.WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                    TimeUnit.MILLISECONDS);
            assertFalse(isInEmergencyCall);
        } catch (InterruptedException e) {
            fail(""Couldn't check if in emergency call."");
            e.printStackTrace();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/TelecomManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.TelecomManagerTest"	"testIsInEmergencyCall_ongoingEmergencyCall"	"CtsTelecomTestCases"	"1: permission"	"([1:/android/telecom/cts/TelecomManagerTest.java]:[permission]:[1]:method_text:[ (isPluggedIn) {                break;            }        }        return isPluggedIn;    }}]) :|: public void testIsInEmergencyCall_ongoingEmergencyCall() throws Exception {
        if (!mShouldTestTelecom) {
            return;
        }

        // Place an emergency call
        setupConnectionService(null, 0);
        setupForEmergencyCalling(TEST_EMERGENCY_NUMBER);
        Bundle extras = new Bundle();
        extras.putParcelable(TestUtils.EXTRA_PHONE_NUMBER, TEST_EMERGENCY_URI);
        placeAndVerifyCall(extras);
        verifyConnectionForOutgoingCall();
        assertIsInCall(true);
        assertIsInManagedCall(true);
        try {
            TestUtils.waitOnAllHandlers(getInstrumentation());
        } catch (Exception e) {
            fail(""Failed to wait on handlers "" + e);
        }

        LinkedBlockingQueue<Boolean> queue = new LinkedBlockingQueue(1);
        runWithShellPermissionIdentity(() ->
                queue.put(mTelecomManager.isInEmergencyCall()));
        try {
            boolean isInEmergencyCall = queue.poll(TestUtils.WAIT_FOR_STATE_CHANGE_TIMEOUT_MS,
                    TimeUnit.MILLISECONDS);
            assertTrue(isInEmergencyCall);
        } catch (InterruptedException e) {
            fail(""Couldn't check if in emergency call."");
            e.printStackTrace();
        }
    }

    private boolean isWiredHeadsetPluggedIn() {
        AudioManager audioManager = mContext.getSystemService(AudioManager.class);
        AudioDeviceInfo[] devices = audioManager.getDevices(AudioManager.GET_DEVICES_ALL);
        boolean isPluggedIn = false;
        for (AudioDeviceInfo device : devices) {
            switch (device.getType()) {
                case AudioDeviceInfo.TYPE_WIRED_HEADPHONES:
                case AudioDeviceInfo.TYPE_WIRED_HEADSET:
                case AudioDeviceInfo.TYPE_USB_HEADSET:
                case AudioDeviceInfo.TYPE_USB_DEVICE:
                    isPluggedIn = true;
            }
            if (isPluggedIn) {
                break;
            }
        }
        return isPluggedIn;
    }

}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/TelecomManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.PhoneAccountSuggestionServiceTest"	"disconnect"	"CtsTelecomTestCases"	"1: permission"	"([3:/android/telecom/cts/PhoneAccountSuggestionServiceTest.java]:[permission]:[3]:method_text:[oneAccountSuggestionService.disableService(mContext);        }        super.tearDown();    }   ]) :|: public void test/*
 *.
 */
package android.telecom.cts;

import static android.telecom.cts.TestUtils.TEST_PHONE_ACCOUNT_HANDLE;
import static android.telecom.cts.TestUtils.shouldTestTelecom;

import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;

import android.content.ComponentName;
import android.net.Uri;
import android.os.Bundle;
import android.telecom.Call;
import android.telecom.PhoneAccountHandle;
import android.telecom.PhoneAccountSuggestion;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

public class PhoneAccountSuggestionServiceTest extends BaseTelecomTestWithMockServices {
    private static final long TEST_TIMEOUT = 5000;
    private PhoneAccountHandle mCachedDefaultHandle;

    @Override
    public void setUp() throws Exception {
        super.setUp();

        if (shouldTestTelecom(mContext)) {
            TestUtils.setCtsPhoneAccountSuggestionService(getInstrumentation(),
                    new ComponentName(mContext, CtsPhoneAccountSuggestionService.class));
            mTelecomManager.registerPhoneAccount(TestUtils.TEST_PHONE_ACCOUNT);
            mTelecomManager.registerPhoneAccount(TestUtils.TEST_PHONE_ACCOUNT_2);
            mCachedDefaultHandle = mTelecomManager.getUserSelectedOutgoingPhoneAccount();
            runWithShellPermissionIdentity(
                    () -> mTelecomManager.setUserSelectedOutgoingPhoneAccount(null));
            TestUtils.enablePhoneAccount(getInstrumentation(), TestUtils.TEST_PHONE_ACCOUNT_HANDLE);
            TestUtils.enablePhoneAccount(
                    getInstrumentation(), TestUtils.TEST_PHONE_ACCOUNT_HANDLE_2);
            CtsPhoneAccountSuggestionService.enableService(mContext);
        }
    }

    @Override
    public void tearDown() throws Exception {
        if (shouldTestTelecom(mContext)) {
            if (mInCallCallbacks.getService().getLastCall() !="	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/PhoneAccountSuggestionServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.VideoCallTest"	"testReceiveCallSessionEvent"	"CtsTelecomTestCases"	"1: permission"	"([2:/android/telecom/cts/VideoCallTest.java]:[permission]:[2]:method_text:[     * Tests ability to receive changes to the peer dimensions from the video provider.     */   ]) :|: public void testReceiveCallSessionEvent() {
        if (!mShouldTestTelecom) {
            return;
        }

        placeAndVerifyCall(VideoProfile.STATE_BIDIRECTIONAL);
        final MockConnection connection = verifyConnectionForOutgoingCall();

        final MockInCallService inCallService = mInCallCallbacks.getService();
        final Call call = inCallService.getLastCall();
        assertVideoCallbackRegistered(inCallService, call, true);

        assertCallSessionEventReceived(inCallService.getVideoCallCallback(call),
                Connection.VideoProvider.SESSION_EVENT_CAMERA_READY,
                new Work() {
                    @Override
                    public void doWork() {
                        connection.sendMockCallSessionEvent(
                                Connection.VideoProvider.SESSION_EVENT_CAMERA_READY);
                    }
                });

        assertCallSessionEventReceived(inCallService.getVideoCallCallback(call),
                Connection.VideoProvider.SESSION_EVENT_CAMERA_FAILURE,
                new Work() {
                    @Override
                    public void doWork() {
                        connection.sendMockCallSessionEvent(
                                Connection.VideoProvider.SESSION_EVENT_CAMERA_FAILURE);
                    }
                });

        assertCallSessionEventReceived(inCallService.getVideoCallCallback(call),
                Connection.VideoProvider.SESSION_EVENT_TX_START,
                new Work() {
                    @Override
                    public void doWork() {
                        connection.sendMockCallSessionEvent(
                                Connection.VideoProvider.SESSION_EVENT_TX_START);
                    }
                });

        assertCallSessionEventReceived(inCallService.getVideoCallCallback(call),
                Connection.VideoProvider.SESSION_EVENT_TX_STOP,
                new Work() {
                    @Override
                    pub"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/VideoCallTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.NonUiInCallServiceTest"	"testMidCallComponentEnablement"	"CtsTelecomTestCases"	"1: permission"	"([4:/android/telecom/cts/NonUiInCallServiceTest.java]:[permission]:[4]:method_text:[ntation().getUiAutomation()                    .dropShellPermissionIdentity();        }    }   ]) :|: public void testMidCallComponentEnablement() throws Exception {
        if (!mShouldTestTelecom) {
            return;
        }
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(
                        ""android.permission.CONTROL_INCALL_EXPERIENCE"",
                        ""android.permission.CHANGE_COMPONENT_ENABLED_STATE"");
        try {
            mContext.getPackageManager().setComponentEnabledSetting(
                    ComponentName.createRelative(CtsApi29InCallService.PACKAGE_NAME,
                            ""."" + CtsApi29InCallService.class.getSimpleName()),
                    PackageManager.COMPONENT_ENABLED_STATE_DISABLED, 0);
            ICtsApi29InCallServiceControl controlInterface = setUpControl();

            addAndVerifyNewIncomingCall(createTestNumber(), new Bundle());
            waitOnAllHandlers(getInstrumentation());
            assertFalse(""Non-UI incall incorrectly bound to despite being disabled"",
                    controlInterface.hasReceivedBindRequest());

            mContext.getPackageManager().setComponentEnabledSetting(
                    ComponentName.createRelative(CtsApi29InCallService.PACKAGE_NAME,
                            ""."" + CtsApi29InCallService.class.getSimpleName()),
                    PackageManager.COMPONENT_ENABLED_STATE_ENABLED,
                    PackageManager.DONT_KILL_APP);

            boolean hasBound = controlInterface.waitForBindRequest();
            assertTrue(""InCall was not bound to"", hasBound);
            waitOnAllHandlers(getInstrumentation());

            assertEquals(""Call was not sent to incall"", 1, controlInterface.getLocalCallCount());

            try {
                controlInterface.kill();
            } catch (DeadObjectException e) {
                //expected
            }
            tearDownControl();
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/NonUiInCallServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.NonUiInCallServiceTest"	"testNullBinding"	"CtsTelecomTestCases"	"1: permission"	"([4:/android/telecom/cts/NonUiInCallServiceTest.java]:[permission]:[4]:method_text:[ion {        Api29InCallUtils.tearDownControl(mContext,                mServiceConnection);    }]) :|: public void testNullBinding() throws Exception {
        if (!mShouldTestTelecom) {
            return;
        }
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(
                        ""android.permission.CONTROL_INCALL_EXPERIENCE"",
                        ""android.permission.CHANGE_COMPONENT_ENABLED_STATE"");
        try {
            mContext.getPackageManager().setComponentEnabledSetting(
                    ComponentName.createRelative(CtsApi29InCallService.PACKAGE_NAME,
                            ""."" + CtsApi29InCallService.class.getSimpleName()),
                    PackageManager.COMPONENT_ENABLED_STATE_ENABLED, 0);
            ICtsApi29InCallServiceControl controlInterface = setUpControl();
            controlInterface.setShouldReturnNullBinding(true);

            int currentCallCount = addNewIncomingCall(createTestNumber(), new Bundle());
            // The test InCallService can be bound and unbound before this test gets a chance to
            // validate. Ensure that the test verifies it is bound before checking if onCallAdded
            // was called.
            assertTrue(""Non-UI incall incorrectly not bound to despite being enabled"",
                    controlInterface.waitForBindRequest());
            verifyNewIncomingCall(currentCallCount);

            assertEquals(""Call was sent to incall despite null binding"",
                    0, controlInterface.getLocalCallCount());

            try {
                controlInterface.kill();
            } catch (DeadObjectException e) {
                //expected
            }
            tearDownControl();
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                    .dropShellPermissionIdentity();
        }
    }
    private ICtsApi29InCallServiceControl setUpControl() throws Exception {
        Pair<ServiceConnection, ICtsApi29InCallServiceControl> setupResult ="	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/NonUiInCallServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.CallRedirectionServiceTest"	"testNotifyTimeout"	"CtsTelecomTestCases"	"1: permission"	"([3:/android/telecom/cts/CallRedirectionServiceTest.java]:[permission]:[3]:method_text:[olean result = queue.poll(ASYNC_TIMEOUT, TimeUnit.MILLISECONDS);        assertTrue(result);    }}]) :|: public void testNotifyTimeout() throws Exception {
        if (!shouldTestTelecom(mContext)) {
            return;
        }
        mCallRedirectionServiceController.setWaitForTimeout();
        try {
            placeAndVerifyCallByRedirection(false /* cancelledByCallRedirection */);
        } catch (AssertionFailedError e) {
            // Expected since we set the CallRedirectionService wait for timeout
        }
        assertTrue(mCallRedirectionServiceController.waitForTimeoutNotified());
    }

    /**
     * Sets up a binder used to control the CallRedirectionServiceCtsTestApp.
     * This app is a standalone APK so that it can reside in a package name outside of the one the
     * CTS test itself runs in.
     * @throws InterruptedException
     */
    private void setupControlBinder() throws InterruptedException {
        Intent bindIntent = new Intent(
                CtsCallRedirectionServiceController.CONTROL_INTERFACE_ACTION);
        bindIntent.setComponent(CtsCallRedirectionServiceController.CONTROL_INTERFACE_COMPONENT);
        final CountDownLatch bindLatch = new CountDownLatch(1);

        boolean success = mContext.bindService(bindIntent, new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                mCallRedirectionServiceController =
                        ICtsCallRedirectionServiceController.Stub.asInterface(service);
                bindLatch.countDown();
            }
            @Override
            public void onServiceDisconnected(ComponentName name) {
                mCallRedirectionServiceController = null;
            }
        }, Context.BIND_AUTO_CREATE);
        if (!success) {
            fail(""Failed to get control interface -- bind error"");
        }
        bindLatch.await(ASYNC_TIMEOUT, TimeUnit.MILLISECONDS);
    }

    /**
     * Use RoleManager to query the previous call redirection app so we can restore it later.
     */
    @CddTest(requi"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/CallRedirectionServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.ThirdPartyInCallServiceAppOpsPermissionTest"	"testWithoutAppOpsPermission"	"CtsTelecomTestCases"	"1: permission"	"([2:/android/telecom/cts/ThirdPartyInCallServiceAppOpsPermissionTest.java]:[permission]:[2]:method_text:[ unbound latch can be null when tearDown.        mExpectedTearDownBindingStatus = false;    }   ]) :|: public void testWithoutAppOpsPermission() throws Exception {
        if (!mShouldTestTelecom) {
            return;
        }
        setInCallServiceAppOpsPermission(false);
        int previousCallCount = mICtsThirdPartyInCallServiceControl.getLocalCallCount();
        addAndVerifyNewIncomingCall(TEST_URI, null);
        assertBindStatus(/* true: bind, false: unbind */true, /* expected result */false);
        assertCallCount(previousCallCount);
        // Third Party InCallService hasn't been bound yet, unbound latch can be null when tearDown.
        mExpectedTearDownBindingStatus = false;
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/ThirdPartyInCallServiceAppOpsPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.ThirdPartyInCallServiceAppOpsPermissionTest"	"testWithAppOpsPermission"	"CtsTelecomTestCases"	"1: permission"	"([7:/android/telecom/cts/ThirdPartyInCallServiceAppOpsPermissionTest.java]:[permission]:[7]:method_text:[.opToDefaultMode(                              AppOpsManager.OPSTR_MANAGE_ONGOING_CALLS)));    }}]) :|: public void testWithAppOpsPermission() throws Exception {
        if (!mShouldTestTelecom) {
            return;
        }
        // Grant App Ops Permission
        setInCallServiceAppOpsPermission(true);

        int previousCallCount = mICtsThirdPartyInCallServiceControl.getLocalCallCount();
        addAndVerifyNewIncomingCall(TEST_URI, null);
        assertBindStatus(/* true: bind, false: unbind */true, /* expected result */true);
        assertCallCount(previousCallCount + 1);
        mICtsThirdPartyInCallServiceControl.resetLatchForServiceBound(true);

        // Revoke App Ops Permission
        setInCallServiceAppOpsPermission(false);
    }

    /**
     *
     * @param bind: check the status of InCallService bind latches.
     *             Values: true (bound latch), false (unbound latch).
     * @param success: whether the latch should have counted down.
     */
    private void assertBindStatus(boolean bind, boolean success) {
        waitUntilConditionIsTrueOrTimeout(new Condition() {
            @Override
            public Object expected() {
                return success;
            }

            @Override
            public Object actual() {
                try {
                    return mICtsThirdPartyInCallServiceControl.checkBindStatus(bind);
                } catch (RemoteException re) {
                    Log.e(TAG, ""Remote exception when checking bind status: "" + re);
                    return false;
                }
            }
        }, WAIT_FOR_STATE_CHANGE_TIMEOUT_MS, ""Unable to "" + (bind ? ""Bind"" : ""Unbind"")
                + "" third party in call service"");
    }

    private void assertCallCount(int expected) {
        waitUntilConditionIsTrueOrTimeout(new Condition() {
            @Override
            public Object expected() {
                return expected;
            }

            @Override
            public Object actual() {
                try {
                    return mICtsThirdPartyInCallServiceControl.getLoc"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/ThirdPartyInCallServiceAppOpsPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.ConnectionServiceTest"	"testAddExistingConnection"	"CtsTelecomTestCases"	"1: permission"	"([3:/android/telecom/cts/ConnectionServiceTest.java]:[permission]:[3]:method_text:[ntation().getUiAutomation()                    .dropShellPermissionIdentity();        }    }   ]) :|: public void testAddExistingConnection() {
        if (!mShouldTestTelecom) {
            return;
        }

        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(""android.permission.MODIFY_PHONE_STATE"");
        try {
            placeAndVerifyCall();
            verifyConnectionForOutgoingCall();

            // Add second connection (add existing connection)
            final MockConnection connection = new MockConnection();
            connection.setOnHold();
            CtsConnectionService.addExistingConnectionToTelecom(TEST_PHONE_ACCOUNT_HANDLE,
                            connection);
            assertNumCalls(mInCallCallbacks.getService(), 2);
            mInCallCallbacks.lock.drainPermits();
            final Call call = mInCallCallbacks.getService().getLastCall();
            assertCallState(call, Call.STATE_HOLDING);
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                    .dropShellPermissionIdentity();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/ConnectionServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.ConnectionServiceTest"	"testAddExistingConnection_invalidPhoneAccountPackageName"	"CtsTelecomTestCases"	"1: permission"	"([1:/android/telecom/cts/ConnectionServiceTest.java]:[permission]:[1]:method_text:[lCallbacks.getService().getLastCall();        assertCallState(call, Call.STATE_DIALING);    }   ]) :|: public void testAddExistingConnection_invalidPhoneAccountPackageName() {
        if (!mShouldTestTelecom) {
            return;
        }

        placeAndVerifyCall();
        verifyConnectionForOutgoingCall();

        // Add second connection (add existing connection)
        final MockConnection connection = new MockConnection();
        connection.setOnHold();
        ComponentName invalidName = new ComponentName(""com.android.phone"",
                ""com.android.services.telephony.TelephonyConnectionService"");
        // This command will fail and a SecurityException will be thrown by Telecom. The Exception
        // will then be absorbed by the ConnectionServiceAdapter.
        runWithShellPermissionIdentity(() ->
                CtsConnectionService.addExistingConnectionToTelecom(
                        new PhoneAccountHandle(invalidName, ""Test""), connection));
        // Make sure that only the original Call exists.
        assertNumCalls(mInCallCallbacks.getService(), 1);
        mInCallCallbacks.lock.drainPermits();
        final Call call = mInCallCallbacks.getService().getLastCall();
        assertCallState(call, Call.STATE_DIALING);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/ConnectionServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.ConnectionServiceTest"	"testAddExistingConnection_invalidPhoneAccountAccountId"	"CtsTelecomTestCases"	"1: permission"	"([1:/android/telecom/cts/ConnectionServiceTest.java]:[permission]:[1]:method_text:[lCallbacks.getService().getLastCall();        assertCallState(call, Call.STATE_DIALING);    }   ]) :|: public void testAddExistingConnection_invalidPhoneAccountAccountId() {
        if (!mShouldTestTelecom) {
            return;
        }

        placeAndVerifyCall();
        verifyConnectionForOutgoingCall();

        // Add second connection (add existing connection)
        final MockConnection connection = new MockConnection();
        connection.setOnHold();
        ComponentName validName = new ComponentName(PACKAGE, COMPONENT);
        // This command will fail because the PhoneAccount is not registered to Telecom currently.
        runWithShellPermissionIdentity(() ->
                CtsConnectionService.addExistingConnectionToTelecom(
                        new PhoneAccountHandle(validName, ""Invalid Account Id""), connection));
        // Make sure that only the original Call exists.
        assertNumCalls(mInCallCallbacks.getService(), 1);
        mInCallCallbacks.lock.drainPermits();
        final Call call = mInCallCallbacks.getService().getLastCall();
        assertCallState(call, Call.STATE_DIALING);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/ConnectionServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.ConnectionServiceTest"	"testCallDirectionIncoming"	"CtsTelecomTestCases"	"1: permission"	"([3:/android/telecom/cts/ConnectionServiceTest.java]:[permission]:[3]:method_text:[tation().getUiAutomation()                    .dropShellPermissionIdentity();        }    }   ]) :|: public void testCallDirectionIncoming() {
        if (!mShouldTestTelecom) {
            return;
        }

        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(""android.permission.MODIFY_PHONE_STATE"");
        try {
            // Need to add a call to ensure ConnectionService is up and bound.
            placeAndVerifyCall();
            verifyConnectionForOutgoingCall().setActive();

            final MockConnection connection = new MockConnection();
            connection.setActive();
            connection.setCallDirection(Call.Details.DIRECTION_INCOMING);
            CtsConnectionService.addExistingConnectionToTelecom(TEST_PHONE_ACCOUNT_HANDLE,
                    connection);
            assertNumCalls(mInCallCallbacks.getService(), 2);
            mInCallCallbacks.lock.drainPermits();
            final Call call = mInCallCallbacks.getService().getLastCall();
            assertCallState(call, Call.STATE_ACTIVE);
            assertEquals(Call.Details.DIRECTION_INCOMING, call.getDetails().getCallDirection());
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                    .dropShellPermissionIdentity();
        }

    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/ConnectionServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.ConnectionServiceTest"	"testCallFilteringCompleteSignalNotInContacts"	"CtsTelecomTestCases"	"1: permission"	"([3:/android/telecom/cts/ConnectionServiceTest.java]:[permission]:[3]:method_text:[ssionIdentity();            MockCallScreeningService.disableService(mContext);        }    }   ]) :|: public void testCallFilteringCompleteSignalNotInContacts() throws Exception {
        if (!mShouldTestTelecom) {
            return;
        }
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(""android.permission.MODIFY_PHONE_STATE"");
        MockCallScreeningService.enableService(mContext);
        try {
            CallScreeningService.CallResponse response =
                    new CallScreeningService.CallResponse.Builder()
                            .setDisallowCall(false)
                            .setRejectCall(false)
                            .setSilenceCall(false)
                            .setSkipCallLog(false)
                            .setSkipNotification(false)
                            .setShouldScreenCallViaAudioProcessing(false)
                            .setCallComposerAttachmentsToShow(
                                    CallResponse.CALL_COMPOSER_ATTACHMENT_PRIORITY
                                            | CallResponse.CALL_COMPOSER_ATTACHMENT_SUBJECT)
                            .build();
            MockCallScreeningService.setCallbacks(createCallbackForCsTest(response));

            addAndVerifyNewIncomingCall(createTestNumber(), null);
            MockConnection connection = verifyConnectionForIncomingCall();

            Object[] callFilteringCompleteInvocations =
                    connection.getInvokeCounter(MockConnection.ON_CALL_FILTERING_COMPLETED)
                            .getArgs(0);
            Connection.CallFilteringCompletionInfo completionInfo =
                    (Connection.CallFilteringCompletionInfo) callFilteringCompleteInvocations[0];

            assertFalse(completionInfo.isBlocked());
            assertFalse(completionInfo.isInContacts());
            assertEquals(response, completionInfo.getCallResponse());
            assertEquals(PACKAGE, completionInfo.getCallScreeningComponent().getPackageName());
        } finally {"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/ConnectionServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.ConnectionServiceTest"	"testCallFilteringCompleteSignalInContacts"	"CtsTelecomTestCases"	"1: permission"	"([3:/android/telecom/cts/ConnectionServiceTest.java]:[permission]:[3]:method_text:[              getService().respondToCall(callDetails, response);            }        };    }   ]) :|: public void testCallFilteringCompleteSignalInContacts() throws Exception {
        if (!mShouldTestTelecom) {
            return;
        }
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(""android.permission.MODIFY_PHONE_STATE"");
        Uri testNumber = createTestNumber();
        Uri contactUri = TestUtils.insertContact(mContext.getContentResolver(),
                testNumber.getSchemeSpecificPart());
        MockCallScreeningService.enableService(mContext);
        try {
            CallScreeningService.CallResponse response =
                    new CallScreeningService.CallResponse.Builder()
                            .setDisallowCall(false)
                            .setRejectCall(false)
                            .setSilenceCall(false)
                            .setSkipCallLog(false)
                            .setSkipNotification(false)
                            .setShouldScreenCallViaAudioProcessing(false)
                            .setCallComposerAttachmentsToShow(
                                    CallResponse.CALL_COMPOSER_ATTACHMENT_PRIORITY
                                            | CallResponse.CALL_COMPOSER_ATTACHMENT_SUBJECT)
                            .build();
            MockCallScreeningService.setCallbacks(createCallbackForCsTest(response));

            assertEquals(CallResponse.CALL_COMPOSER_ATTACHMENT_PRIORITY
                    | CallResponse.CALL_COMPOSER_ATTACHMENT_SUBJECT,
                    response.getCallComposerAttachmentsToShow());
            addAndVerifyNewIncomingCall(testNumber, null);

            MockConnection connection = verifyConnectionForIncomingCall();

            Object[] callFilteringCompleteInvocations =
                    connection.getInvokeCounter(MockConnection.ON_CALL_FILTERING_COMPLETED)
                            .getArgs(0);
            Connection.CallFilteringCompletionInfo completionInfo =
                    (Connect"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/ConnectionServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.ConnectionServiceTest"	"testCallDirectionOutgoing"	"CtsTelecomTestCases"	"1: permission"	"([3:/android/telecom/cts/ConnectionServiceTest.java]:[permission]:[3]:method_text:[ntation().getUiAutomation()                    .dropShellPermissionIdentity();        }    }   ]) :|: public void testCallDirectionOutgoing() {
        if (!mShouldTestTelecom) {
            return;
        }

        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(""android.permission.MODIFY_PHONE_STATE"");
        try {
            // Ensure CS is up and bound.
            placeAndVerifyCall();
            verifyConnectionForOutgoingCall().setActive();

            final MockConnection connection = new MockConnection();
            connection.setActive();
            connection.setCallDirection(Call.Details.DIRECTION_OUTGOING);
            connection.setConnectTimeMillis(1000L);
            assertEquals(1000L, connection.getConnectTimeMillis());
            connection.setConnectionStartElapsedRealtimeMillis(100L);
            assertEquals(100L, connection.getConnectionStartElapsedRealtimeMillis());

            CtsConnectionService.addExistingConnectionToTelecom(TEST_PHONE_ACCOUNT_HANDLE,
                    connection);
            assertNumCalls(mInCallCallbacks.getService(), 2);
            mInCallCallbacks.lock.drainPermits();
            final Call call = mInCallCallbacks.getService().getLastCall();
            assertCallState(call, Call.STATE_ACTIVE);
            assertEquals(Call.Details.DIRECTION_OUTGOING, call.getDetails().getCallDirection());
            assertEquals(1000L, call.getDetails().getConnectTimeMillis());
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                    .dropShellPermissionIdentity();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/ConnectionServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.ConnectionServiceTest"	"testGetAllConnections"	"CtsTelecomTestCases"	"1: permission"	"([3:/android/telecom/cts/ConnectionServiceTest.java]:[permission]:[3]:method_text:[umentation().getUiAutomation()                    .dropShellPermissionIdentity();        }    }}]) :|: public void testGetAllConnections() {
        if (!mShouldTestTelecom) {
            return;
        }

        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(""android.permission.MODIFY_PHONE_STATE"");
        try {
            // Add first connection (outgoing call)
            placeAndVerifyCall();
            final Connection connection1 = verifyConnectionForOutgoingCall();

            Collection<Connection> connections =
                    CtsConnectionService.getAllConnectionsFromTelecom();
            assertEquals(1, connections.size());
            assertTrue(connections.contains(connection1));
            // Need to move this to active since we reject the 3rd incoming call below if this is in
            // dialing state (b/23428950).
            connection1.setActive();
            assertCallState(mInCallCallbacks.getService().getLastCall(), Call.STATE_ACTIVE);

            // Add second connection (add existing connection)
            final Connection connection2 = new MockConnection();
            connection2.setActive();
            CtsConnectionService.addExistingConnectionToTelecom(TEST_PHONE_ACCOUNT_HANDLE,
                            connection2);
            assertNumCalls(mInCallCallbacks.getService(), 2);
            mInCallCallbacks.lock.drainPermits();
            connections = CtsConnectionService.getAllConnectionsFromTelecom();
            assertEquals(2, connections.size());
            assertTrue(connections.contains(connection2));

            // Add third connection (incoming call)
            addAndVerifyNewIncomingCall(createTestNumber(), null);
            final Connection connection3 = verifyConnectionForIncomingCall();
            connections = CtsConnectionService.getAllConnectionsFromTelecom();
            assertEquals(3, connections.size());
            assertTrue(connections.contains(connection3));
        } finally {
            InstrumentationRegistry.getInstrumentat"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/ConnectionServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.DefaultDialerOperationsTest"	"testGetDefaultDialerPackage"	"CtsTelecomTestCases"	"1: permission"	"([1:/android/telecom/cts/DefaultDialerOperationsTest.java]:[permission]:[1]:method_text:[andle())));    }    /** Default dialer should be the default package handling ACTION_DIAL. */   ]) :|: public void testGetDefaultDialerPackage() throws Exception {
        if (!TestUtils.shouldTestTelecom(mContext)) {
            return;
        }
        assertEquals(mSystemDialer, mTelecomManager.getDefaultDialerPackage());
        TestUtils.setDefaultDialer(getInstrumentation(), TestUtils.PACKAGE);
        assertEquals(TestUtils.PACKAGE, mTelecomManager.getDefaultDialerPackage());
        assertEquals(mTelecomManager.getDefaultDialerPackage(),
                ShellIdentityUtils.invokeMethodWithShellPermissions(mTelecomManager,
                        tm -> tm.getDefaultDialerPackage(Process.myUserHandle())));
    }

    /** Default dialer should be the default package handling ACTION_DIAL. */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/DefaultDialerOperationsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.DefaultDialerOperationsTest"	"testVoicemailReadWritePermissions"	"CtsTelecomTestCases"	"1: permission"	"([1:/android/telecom/cts/DefaultDialerOperationsTest.java]:[permission]:[1]:method_text:[().delete(Voicemails.CONTENT_URI,                Voicemails._ID + ""=999 AND 1=2"", null);    }   ]) :|: public void testVoicemailReadWritePermissions() throws Exception {
        if (!TestUtils.shouldTestTelecom(mContext)) {
            return;
        }
        try {
            mContext.getContentResolver().query(Voicemails.CONTENT_URI, null, null, null, null);
            fail(""Reading voicemails should throw SecurityException if not default Dialer"");
        } catch (SecurityException e) {
        }

        try {
            mContext.getContentResolver().delete(Voicemails.CONTENT_URI,
                    Voicemails._ID + ""=999 AND 1=2"", null);
            fail(""Deleting voicemails should throw SecurityException if not default Dialer"");
        } catch (SecurityException e) {
        }

        try {
            mContext.getContentResolver().update(
                    Voicemails.CONTENT_URI.buildUpon().appendPath(""999"").build(),
                    new ContentValues(),
                    null,
                    null);
            fail(""Updating voicemails should throw SecurityException if not default Dialer"");
        } catch (SecurityException e) {
        }

        TestUtils.setDefaultDialer(getInstrumentation(), TestUtils.PACKAGE);
        // No exception if the calling package is the default dialer.
        mContext.getContentResolver().query(Voicemails.CONTENT_URI, null, null, null, null);
        mContext.getContentResolver().delete(Voicemails.CONTENT_URI,
                Voicemails._ID + ""=999 AND 1=2"", null);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/DefaultDialerOperationsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.DefaultDialerOperationsTest"	"testSilenceRingerPermissions"	"CtsTelecomTestCases"	"1: permission"	"([1:/android/telecom/cts/DefaultDialerOperationsTest.java]:[permission]:[1]:method_text:[on if the calling package is the default dialer.        mTelecomManager.silenceRinger();    }   ]) :|: public void testSilenceRingerPermissions() throws Exception {
        if (!TestUtils.shouldTestTelecom(mContext)) {
            return;
        }
        try {
            mTelecomManager.silenceRinger();
            fail(""TelecomManager.silenceRinger should throw SecurityException if not default ""
                    + ""dialer"");
        } catch (SecurityException e) {
        }

        TestUtils.setDefaultDialer(getInstrumentation(), TestUtils.PACKAGE);
        // No exception if the calling package is the default dialer.
        mTelecomManager.silenceRinger();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/DefaultDialerOperationsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.DefaultDialerOperationsTest"	"testCancelMissedCallsNotificationPermissions"	"CtsTelecomTestCases"	"1: permission"	"([1:/android/telecom/cts/DefaultDialerOperationsTest.java]:[permission]:[1]:method_text:[g package is the default dialer.        mTelecomManager.cancelMissedCallsNotification();    }   ]) :|: public void testCancelMissedCallsNotificationPermissions()
            throws Exception {
        if (!TestUtils.shouldTestTelecom(mContext)) {
            return;
        }
        try {
            mTelecomManager.cancelMissedCallsNotification();
            fail(""TelecomManager.cancelMissedCallsNotification should throw SecurityException if ""
                    + ""not default dialer"");
        } catch (SecurityException e) {
        }

        TestUtils.setDefaultDialer(getInstrumentation(), TestUtils.PACKAGE);
        // No exception if the calling package is the default dialer.
        mTelecomManager.cancelMissedCallsNotification();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/DefaultDialerOperationsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.DefaultDialerOperationsTest"	"testHandlePinMmPermissions"	"CtsTelecomTestCases"	"1: permission"	"([1:/android/telecom/cts/DefaultDialerOperationsTest.java]:[permission]:[1]:method_text:[lecomManager.handleMmi(""0"");        mTelecomManager.handleMmi(""0"", mPhoneAccountHandle);    }   ]) :|: public void testHandlePinMmPermissions()
            throws Exception {
        if (!TestUtils.shouldTestTelecom(mContext)) {
            return;
        }
        try {
            mTelecomManager.handleMmi(""0"");
            fail(""TelecomManager.handleMmi should throw SecurityException if not default dialer"");
        } catch (SecurityException e) {
        }

        try {
            mTelecomManager.handleMmi(""0"", mPhoneAccountHandle);
            fail(""TelecomManager.handleMmi should throw SecurityException if not default dialer"");
        } catch (SecurityException e) {
        }

        TestUtils.setDefaultDialer(getInstrumentation(), TestUtils.PACKAGE);
        // No exception if the calling package is the default dialer.
        mTelecomManager.handleMmi(""0"");
        mTelecomManager.handleMmi(""0"", mPhoneAccountHandle);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/DefaultDialerOperationsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.DefaultDialerOperationsTest"	"testGetAdnForPhoneAccountPermissions"	"CtsTelecomTestCases"	"1: permission"	"([1:/android/telecom/cts/DefaultDialerOperationsTest.java]:[permission]:[1]:method_text:[kage()} API returns the correct     * package name for the preloaded system dialer app.     */   ]) :|: public void testGetAdnForPhoneAccountPermissions() throws Exception {
        if (!TestUtils.shouldTestTelecom(mContext)) {
            return;
        }
        try {
            mTelecomManager.getAdnUriForPhoneAccount(mPhoneAccountHandle);
            fail(""TelecomManager.getAdnUriForPhoneAccount should throw SecurityException if ""
                    + ""not default dialer"");
        } catch (SecurityException e) {
        }

        TestUtils.setDefaultDialer(getInstrumentation(), TestUtils.PACKAGE);
        // No exception if the calling package is the default dialer.
        mTelecomManager.getAdnUriForPhoneAccount(mPhoneAccountHandle);
    }

    /**
     * TODO: Re-enable this test when CTS tests are refactored.
     * @throws Exception
     */
    public void donotTestSetDefaultDialerNoDialIntent_notSupported() throws Exception {
        if (!TestUtils.shouldTestTelecom(mContext)) {
            return;
        }
        final ComponentName name = new ComponentName(mContext,
                ""android.telecom.cts.MockDialerActivity"");
        try {
            mPackageManager.setComponentEnabledSetting(
                    name,
                    PackageManager.COMPONENT_ENABLED_STATE_DISABLED,
                    PackageManager.DONT_KILL_APP);
            TestUtils.setDefaultDialer(getInstrumentation(), TestUtils.PACKAGE);
            final String result = TestUtils.getDefaultDialer(getInstrumentation());
            assertNotSame(result, TestUtils.PACKAGE);
            assertTrue(""Expected failure indicating that this was not an installed dialer app"",
                    result.contains(""is not an installed Dialer app""));
        } finally {
            mPackageManager.setComponentEnabledSetting(
                    name,
                    PackageManager.COMPONENT_ENABLED_STATE_ENABLED,
                    PackageManager.DONT_KILL_APP);
        }

        // Now that the activity is present again in the package manager, this should succeed.
        TestU"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/DefaultDialerOperationsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.BasicInCallServiceTest"	"testResolveInCallIntent"	"CtsTelecomTestCases"	"1: permission"	"([2:/android/telecom/cts/BasicInCallServiceTest.java]:[permission]:[2]:method_text:[call to the number 7. It should still pass even if there is no     * SIM card inserted.     */   ]) :|: public void testResolveInCallIntent() {
        if (!shouldTestTelecom(mContext)) {
            return;
        }
        PackageManager packageManager = mContext.getPackageManager();
        Intent serviceIntent = new Intent(InCallService.SERVICE_INTERFACE);
        List<ResolveInfo> resolveInfo = packageManager.queryIntentServices(serviceIntent,
                PackageManager.GET_META_DATA);

        assertNotNull(resolveInfo);
        assertTrue(resolveInfo.size() >= 1);

        // Ensure at least one InCallService is able to handle the UI for calls.
        assertTrue(resolveInfo
                .stream()
                .filter(r -> r.serviceInfo != null
                        && r.serviceInfo.metaData != null
                        && r.serviceInfo.metaData.containsKey(
                                TelecomManager.METADATA_IN_CALL_SERVICE_UI)
                        && r.serviceInfo.permission.equals(
                                android.Manifest.permission.BIND_INCALL_SERVICE)
                        && r.serviceInfo.name != null)
                .count() >= 1);
    }

    /**
     * Tests that when sending a CALL intent via the Telecom -> Telephony stack, Telecom
     * binds to the registered {@link InCallService}s and adds a new call. This test will
     * actually place a phone call to the number 7. It should still pass even if there is no
     * SIM card inserted.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/BasicInCallServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.SelfManagedConnectionTest"	"testEnterCarMode"	"CtsTelecomTestCases"	"1: permission"	"([4:/android/telecom/cts/SelfManagedConnectionTest.java]:[permission]:[4]:method_text:[AndDestroy();        assertIsInCall(false);        mContext.unbindService(controlConn);    }   ]) :|: public void testEnterCarMode() throws Exception {
        if (!mShouldTestTelecom) {
            return;
        }
        TestServiceConnection controlConn = setUpControl(CAR_MODE_CONTROL,
                CAR_DIALER_1);
        mCarModeIncallServiceControlOne = ICtsCarModeInCallServiceControl.Stub
                .asInterface(controlConn.getService());
        mCarModeIncallServiceControlOne.reset();

        SelfManagedConnection connection = placeAndVerifySelfManagedCall();
        mUiAutomation.adoptShellPermissionIdentity(
                ""android.permission.ENTER_CAR_MODE_PRIORITIZED"",
                ""android.permission.CONTROL_INCALL_EXPERIENCE"");
        mCarModeIncallServiceControlOne.enableCarMode(1000);
        assertTrue(mCarModeIncallServiceControlOne.checkBindStatus(true /* bindStatus */));
        mCarModeIncallServiceControlOne.disableCarMode();
        mUiAutomation.dropShellPermissionIdentity();

        connection.disconnectAndDestroy();
        assertIsInCall(false);
        mContext.unbindService(controlConn);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/SelfManagedConnectionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.SelfManagedConnectionTest"	"testChangeCarModeApp"	"CtsTelecomTestCases"	"1: permission"	"([4:/android/telecom/cts/SelfManagedConnectionTest.java]:[permission]:[4]:method_text:[      mContext.unbindService(controlConn1);        mContext.unbindService(controlConn2);    }   ]) :|: public void testChangeCarModeApp() throws Exception {
        if (!mShouldTestTelecom) {
            return;
        }
        TestServiceConnection controlConn1 = setUpControl(CAR_MODE_CONTROL, CAR_DIALER_1);
        TestServiceConnection controlConn2 = setUpControl(CAR_MODE_CONTROL, CAR_DIALER_2);
        mCarModeIncallServiceControlOne = ICtsCarModeInCallServiceControl.Stub
                .asInterface(controlConn1.getService());
        mCarModeIncallServiceControlTwo = ICtsCarModeInCallServiceControl.Stub
                .asInterface(controlConn2.getService());
        mCarModeIncallServiceControlOne.reset();
        mCarModeIncallServiceControlTwo.reset();

        mUiAutomation.adoptShellPermissionIdentity(
                ""android.permission.ENTER_CAR_MODE_PRIORITIZED"",
                ""android.permission.CONTROL_INCALL_EXPERIENCE"");
        mCarModeIncallServiceControlOne.enableCarMode(999);

        SelfManagedConnection connection = placeAndVerifySelfManagedCall();
        assertTrue(mCarModeIncallServiceControlOne.checkBindStatus(true /* bindStatus */));
        mCarModeIncallServiceControlTwo.enableCarMode(1000);
        assertTrue(mCarModeIncallServiceControlOne.checkBindStatus(false /* bindStatus */));
        assertTrue(mCarModeIncallServiceControlTwo.checkBindStatus(true /* bindStatus */));

        mCarModeIncallServiceControlOne.disableCarMode();
        mCarModeIncallServiceControlTwo.disableCarMode();

        connection.disconnectAndDestroy();
        assertIsInCall(false);
        mUiAutomation.dropShellPermissionIdentity();
        mContext.unbindService(controlConn1);
        mContext.unbindService(controlConn2);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/SelfManagedConnectionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telecom.cts.SelfManagedConnectionTest"	"testExitCarMode"	"CtsTelecomTestCases"	"1: permission"	"([8:/android/telecom/cts/SelfManagedConnectionTest.java]:[permission]:[8]:method_text:[nnectionService"");        }        return TestUtils.waitForAndGetConnection(TEST_ADDRESS);    }}]) :|: public void testExitCarMode() throws Exception {
        if (!mShouldTestTelecom) {
            return;
        }
        TestServiceConnection controlConn = setUpControl(CAR_MODE_CONTROL, CAR_DIALER_1);
        mCarModeIncallServiceControlOne = ICtsCarModeInCallServiceControl.Stub
                .asInterface(controlConn.getService());
        mCarModeIncallServiceControlOne.reset();

        mUiAutomation.adoptShellPermissionIdentity(
                ""android.permission.ENTER_CAR_MODE_PRIORITIZED"",
                ""android.permission.CONTROL_INCALL_EXPERIENCE"");
        mCarModeIncallServiceControlOne.enableCarMode(1000);

        SelfManagedConnection connection = placeAndVerifySelfManagedCall();
        assertTrue(mCarModeIncallServiceControlOne.checkBindStatus(true /* bindStatus */));
        mCarModeIncallServiceControlOne.disableCarMode();
        assertTrue(mCarModeIncallServiceControlOne.checkBindStatus(false /* bindStatus */));
        mUiAutomation.dropShellPermissionIdentity();

        connection.disconnectAndDestroy();
        assertIsInCall(false);
        mContext.unbindService(controlConn);
    }

    private TestServiceConnection setUpControl(String action, ComponentName componentName) {
        Intent bindIntent = new Intent(action);
        bindIntent.setComponent(componentName);

        TestServiceConnection serviceConnection = new TestServiceConnection();
        mContext.bindService(bindIntent, serviceConnection, Context.BIND_AUTO_CREATE);
        if (!serviceConnection.waitBind()) {
            fail(""fail bind to service"");
        }
        return serviceConnection;
    }

    private boolean setDefaultDialer(String packageName) {
        mUiAutomation.adoptShellPermissionIdentity();
        try {
            CompletableFuture<Boolean> future = new CompletableFuture<>();
            Consumer<Boolean> callback = successful -> {
                future.complete(successful);
            };

            mRoleManager.addRoleHolderAsUser(RoleManag"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/SelfManagedConnectionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.PowerManagerTest"	"testPowerManager"	""	"1: permission"	"([1:/android/os/cts/PowerManagerTest.java]:[permission]:[1]:method_text:[          Global.DYNAMIC_POWER_SAVINGS_DISABLE_THRESHOLD, mInitialThreshold);        });    }   ]) :|: public void testPowerManager() throws InterruptedException {
        PowerManager pm = (PowerManager)getContext().getSystemService(Context.POWER_SERVICE);

        WakeLock wl = pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK, TAG);
        wl.acquire(TIME);
        assertTrue(wl.isHeld());
        Thread.sleep(TIME + MORE_TIME);
        assertFalse(wl.isHeld());

        try {
            pm.reboot(""Testing"");
            fail(""reboot should throw SecurityException"");
        } catch (SecurityException e) {
            // expected
        }
    }

    @Before
    public void setUp() {
        // store the current value so we can restore it
        ContentResolver resolver = getContext().getContentResolver();
        mInitialPowerSaverMode = Global.getInt(resolver, Global.AUTOMATIC_POWER_SAVE_MODE, 0);
        mInitialDynamicPowerSavingsEnabled =
                Global.getInt(resolver, Global.DYNAMIC_POWER_SAVINGS_ENABLED, 0);
        mInitialThreshold =
                Global.getInt(resolver, Global.DYNAMIC_POWER_SAVINGS_DISABLE_THRESHOLD, 0);

    }

    @After
    public void tearDown() {
        SystemUtil.runWithShellPermissionIdentity(() -> {
            ContentResolver resolver = getContext().getContentResolver();

            // Verify we can change it to dynamic.
            Global.putInt(resolver, Global.AUTOMATIC_POWER_SAVE_MODE, mInitialPowerSaverMode);
            Global.putInt(resolver,
                    Global.DYNAMIC_POWER_SAVINGS_ENABLED, mInitialDynamicPowerSavingsEnabled);
            Global.putInt(resolver,
                    Global.DYNAMIC_POWER_SAVINGS_DISABLE_THRESHOLD, mInitialThreshold);
        });
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/PowerManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.PowerManagerTest"	"testPowerManager_getPowerSaveMode"	""	"1: permission"	"([1:/android/os/cts/PowerManagerTest.java]:[permission]:[1]:method_text:[MODE_TRIGGER_DYNAMIC,                    manager.getPowerSaveModeTrigger());        });    }   ]) :|: public void testPowerManager_getPowerSaveMode() {
        SystemUtil.runWithShellPermissionIdentity(() -> {
            PowerManager manager = BatteryUtils.getPowerManager();
            ContentResolver resolver = getContext().getContentResolver();

            // Verify we can change it to percentage.
            Global.putInt(resolver, Global.AUTOMATIC_POWER_SAVE_MODE, 0);
            assertEquals(
                    PowerManager.POWER_SAVE_MODE_TRIGGER_PERCENTAGE,
                    manager.getPowerSaveModeTrigger());

            // Verify we can change it to dynamic.
            Global.putInt(resolver, Global.AUTOMATIC_POWER_SAVE_MODE, 1);
            assertEquals(
                    PowerManager.POWER_SAVE_MODE_TRIGGER_DYNAMIC,
                    manager.getPowerSaveModeTrigger());
        });
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/PowerManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.PowerManagerTest"	"testPowerManager_setDynamicPowerSavings"	""	"1: permission"	"([1:/android/os/cts/PowerManagerTest.java]:[permission]:[1]:method_text:[          Global.DYNAMIC_POWER_SAVINGS_DISABLE_THRESHOLD, 0));        });    }    @LargeTest   ]) :|: public void testPowerManager_setDynamicPowerSavings() {
        SystemUtil.runWithShellPermissionIdentity(() -> {
            PowerManager manager = BatteryUtils.getPowerManager();
            ContentResolver resolver = getContext().getContentResolver();

            // Verify settings are actually updated.
            manager.setDynamicPowerSaveHint(true, 80);
            assertEquals(1, Global.getInt(resolver, Global.DYNAMIC_POWER_SAVINGS_ENABLED, 0));
            assertEquals(80, Global.getInt(resolver,
                    Global.DYNAMIC_POWER_SAVINGS_DISABLE_THRESHOLD, 0));

            manager.setDynamicPowerSaveHint(false, 20);
            assertEquals(0, Global.getInt(resolver, Global.DYNAMIC_POWER_SAVINGS_ENABLED, 1));
            assertEquals(20, Global.getInt(resolver,
                    Global.DYNAMIC_POWER_SAVINGS_DISABLE_THRESHOLD, 0));
        });
    }

    @LargeTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/PowerManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.PowerManagerTest"	"testPowerManager_batteryDischargePrediction"	""	"1: permission"	"([2:/android/os/cts/PowerManagerTest.java]:[permission]:[2]:method_text:[);        assertEquals(isPersonalized, manager.isBatteryDischargePredictionPersonalized());    }}]) :|: public void testPowerManager_batteryDischargePrediction() throws Exception {
        final PowerManager manager = BatteryUtils.getPowerManager();

        if (!BatteryUtils.hasBattery()) {
            assertNull(manager.getBatteryDischargePrediction());
            return;
        }

        // Unplug to ensure the plugged in broadcast is sent.
        BatteryUtils.runDumpsysBatteryUnplug();

        // Plugged in. No prediction should be given.
        final CallbackAsserter pluggedBroadcastAsserter = CallbackAsserter.forBroadcast(
                new IntentFilter(Intent.ACTION_POWER_CONNECTED));
        BatteryUtils.runDumpsysBatterySetPluggedIn(true);
        pluggedBroadcastAsserter.assertCalled(""Didn't get power connected broadcast"",
                BROADCAST_TIMEOUT_SECONDS);
        // PowerManagerService may get the BATTERY_CHANGED broadcast after we get our broadcast,
        // so we have to have a little wait.
        waitUntil(""PowerManager doesn't think the device has connected power"",
                () -> manager.getBatteryDischargePrediction() == null);

        // Not plugged in. At the very least, the basic discharge estimation should be returned.
        final CallbackAsserter unpluggedBroadcastAsserter = CallbackAsserter.forBroadcast(
                new IntentFilter(Intent.ACTION_POWER_DISCONNECTED));
        BatteryUtils.runDumpsysBatteryUnplug();
        unpluggedBroadcastAsserter.assertCalled(""Didn't get power disconnected broadcast"",
                BROADCAST_TIMEOUT_SECONDS);
        // PowerManagerService may get the BATTERY_CHANGED broadcast after we get our broadcast,
        // so we have to have a little wait.
        waitUntil(""PowerManager still thinks the device has connected power"",
                () -> manager.getBatteryDischargePrediction() != null);

        CallbackAsserter predictionChangedBroadcastAsserter = CallbackAsserter.forBroadcast(
                new IntentFilter(PowerManager.ACTION_ENHANCED_DISCHARGE_PREDICTION_CHAN"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/PowerManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.CompanionDeviceManagerTest.kt"	"InstrumentationTestCase"	""	"1: permission"	"([7:/android/os/cts/CompanionDeviceManagerTest.kt]:[permission]:[7]:method_text:[$address"")        }    }    @AppModeFull(reason = ""Companion API for non-instant apps only"")   ]) :|: /*
 *.
 */

package android.os.cts

import android.companion.CompanionDeviceManager
import android.content.pm.PackageManager.FEATURE_AUTOMOTIVE
import android.content.pm.PackageManager.FEATURE_COMPANION_DEVICE_SETUP
import android.content.pm.PackageManager.PERMISSION_GRANTED
import android.net.MacAddress
import android.os.Binder
import android.os.Bundle
import android.os.Parcelable
import android.os.UserHandle
import android.platform.test.annotations.AppModeFull
import android.test.InstrumentationTestCase
import android.util.Size
import android.util.SizeF
import android.util.SparseArray
import android.view.accessibility.AccessibilityNodeInfo
import android.view.accessibility.AccessibilityNodeInfo.ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE
import android.view.accessibility.AccessibilityNodeInfo.ACTION_SET_TEXT
import android.widget.EditText
import android.widget.TextView
import androidx.test.InstrumentationRegistry
import androidx.test.runner.AndroidJUnit4
import com.android.compatibility.common.util.MatcherUtils
import com.android.compatibility.common.util.MatcherUtils.hasIdThat
import com.android.compatibility.common.util.SystemUtil.eventually
import com.android.compatibility.common.util.SystemUtil.getEventually
import com.android.compatibility.common.util.SystemUtil.runShellCommand
import com.android.compatibility.common.util.SystemUtil.runShellCommandOrThrow
import com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity
import com.android.compatibility.common.util.ThrowingSupplier
import com.android.compatibility.common.util.UiAutomatorUtils.waitFindObject
import com.android.compatibility.common.util.children
import com.android.compatibility.common.util.click
import org.hamcrest.CoreMatchers.`is`
import org.hamcrest.CoreMatchers.containsString
import org.hamcrest.CoreMatchers.equalTo
import org.hamcrest.Matcher
import org.hamcrest.Matchers.empty
import org.hamcrest.Matchers.not
import org.junit.Assert.assertThat
import org.junit.Assume.assumeFa"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/CompanionDeviceManagerTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.CompanionDeviceManagerTest.kt"	"testIsDeviceAssociatedWithCompanionApproveWifiConnectionsPermission"	""	"1: permission"	"([1:/android/os/cts/CompanionDeviceManagerTest.kt]:[permission]:[1]:method_text:[SHELL_PACKAGE_NAME))    }    @AppModeFull(reason = ""Companion API for non-instant apps only"")   ]) :|: 
    fun testIsDeviceAssociatedWithCompanionApproveWifiConnectionsPermission() {
        assertTrue(isCdmAssociated(
            DUMMY_MAC_ADDRESS, SHELL_PACKAGE_NAME, MANAGE_COMPANION_DEVICES,
            COMPANION_APPROVE_WIFI_CONNECTIONS))
        assertFalse(isShellAssociated(DUMMY_MAC_ADDRESS, SHELL_PACKAGE_NAME))
    }

    @AppModeFull(reason = ""Companion API for non-instant apps only"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/CompanionDeviceManagerTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.CompanionDeviceManagerTest.kt"	"testProfiles"	""	"1: permission"	"([6:/android/os/cts/CompanionDeviceManagerTest.kt]:[permission]:[6]:method_text:[ PERMISSION_GRANTED)    }    @AppModeFull(reason = ""Companion API for non-instant apps only"")   ]) :|: 
    fun testProfiles() {
        val packageName = ""android.os.cts.companiontestapp""
        installApk(
                ""--user ${UserHandle.myUserId()} /data/local/tmp/cts/os/CtsCompanionTestApp.apk"")
        startApp(packageName)

        waitFindNode(hasClassThat(`is`(equalTo(EditText::class.java.name))))
                .performAction(ACTION_SET_TEXT,
                        bundleOf(ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE to """"))
        waitForIdle()

        click(""Watch"")
        val device = getEventually({
            click(""Associate"")
            waitFindNode(hasIdThat(containsString(""device_list"")),
                    failMsg = ""Test requires a discoverable bluetooth device nearby"",
                    timeoutMs = 9_000)
                    .children
                    .find { it.className == TextView::class.java.name }
                    .assertNotNull { ""Empty device list"" }
        }, 90_000)
        device!!.click()

        eventually {
            assertThat(getAssociatedDevices(packageName), not(empty()))
        }
        val deviceAddress = getAssociatedDevices(packageName).last()

        runShellCommandOrThrow(""cmd companiondevice simulate_connect $deviceAddress"")
        assertPermission(packageName, ""android.permission.CALL_PHONE"", PERMISSION_GRANTED)

        runShellCommandOrThrow(""cmd companiondevice simulate_disconnect $deviceAddress"")
        assertPermission(packageName, ""android.permission.CALL_PHONE"", PERMISSION_GRANTED)
    }

    @AppModeFull(reason = ""Companion API for non-instant apps only"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/CompanionDeviceManagerTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.CrossProcessExceptionTest"	"isInstantApp"	""	"1: permission"	"([1:/android/os/cts/CrossProcessExceptionTest.java]:[permission]:[1]:method_text:[ITY_SERVICE);            am.killBackgroundProcesses(context.getPackageName());        }    }   ]) :|: public void test/*
 *.
 */

package android.os.cts;

import android.app.ActivityManager;
import android.app.AuthenticationRequiredException;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.IBinder;
import android.os.ParcelFileDescriptor;
import android.test.AndroidTestCase;

import com.google.common.util.concurrent.AbstractFuture;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

public class CrossProcessExceptionTest extends AndroidTestCase {

    private Intent greenIntent;
    private PeerConnection greenConn;
    private IBinder green;

    public static class PeerConnection extends AbstractFuture<IBinder>
            implements ServiceConnection {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            set(service);
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
        }

        @Override
        public IBinder get() throws InterruptedException, ExecutionException {
            try {
                return get(5, TimeUnit.SECONDS);
            } catch (TimeoutException e) {
                throw new RuntimeException(e);
            }
        }
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        final Context context = getContext();

        // Bring up both remote processes and wire them to each other
        greenIntent = new Intent();
        greenIntent.setComponent(new ComponentName(
                ""android.os.cts"", ""android.os.cts.CrossProcessExceptionService""));
        greenConn = new PeerConnection();
        context.startService(greenIntent);
        getContext().bindService(greenIntent, greenConn, 0);
        green = greenConn.get();
    }

    @Override
    protected void tearDown() throws Exception {
        sup"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/CrossProcessExceptionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.SystemClockTest"	"testSetCurrentTimeMillis"	""	"1: permission"	"([1:/android/os/cts/SystemClockTest.java]:[permission]:[1]:method_text:[);        assertFalse(actual);        // This test need to be done in permission test.    }   ]) :|: public void testSetCurrentTimeMillis() {

        long start = SystemClock.currentThreadTimeMillis();
        boolean actual = SystemClock.setCurrentTimeMillis(start + 10000);
        assertFalse(actual);
        // This test need to be done in permission test.

    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/SystemClockTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.SystemConfigTest"	"testGetDisabledUntilUsedPreinstalledCarrierApps"	""	"1: permission"	"([1:/android/os/cts/SystemConfigTest.java]:[permission]:[1]:method_text:[er apps contains an empty string"",                    TextUtils.isEmpty(app));        }    }   ]) :|: 
    @Ignore
    public void testGetDisabledUntilUsedPreinstalledCarrierApps() throws Exception {
        SystemConfigManager systemConfigManager =
                InstrumentationRegistry.getContext().getSystemService(SystemConfigManager.class);
        Set<String> carrierApps = SystemUtil.callWithShellPermissionIdentity(
                systemConfigManager::getDisabledUntilUsedPreinstalledCarrierApps);
        // We don't know which packages are going to be on the device, so just make sure it's not
        // null and any strings inside are nonempty.
        assertNotNull(carrierApps);
        for (String app : carrierApps) {
            assertFalse(""pre-installed carrier apps contains an empty string"",
                    TextUtils.isEmpty(app));
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/SystemConfigTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.SystemConfigTest"	"testGetDisabledUntilUsedPreinstalledCarrierAssociatedApps"	""	"1: permission"	"([1:/android/os/cts/SystemConfigTest.java]:[permission]:[1]:method_text:[mpty string"",                        TextUtils.isEmpty(helperApp));            }        }    }}]) :|: 
    @Ignore
    public void testGetDisabledUntilUsedPreinstalledCarrierAssociatedApps() throws Exception {
        SystemConfigManager systemConfigManager =
                InstrumentationRegistry.getContext().getSystemService(SystemConfigManager.class);
        Map<String, List<String>> helperApps = SystemUtil.callWithShellPermissionIdentity(
                systemConfigManager::getDisabledUntilUsedPreinstalledCarrierAssociatedApps);
        // We don't know which packages are going to be on the device, so just make sure it's not
        // null and any strings inside are nonempty.
        assertNotNull(helperApps);
        for (String app : helperApps.keySet()) {
            assertFalse(""pre-installed carrier apps contains an empty string"",
                    TextUtils.isEmpty(app));
            List<String> helperAppsForApp = helperApps.get(app);
            assertNotNull(helperAppsForApp);
            for (String helperApp : helperAppsForApp) {
                assertFalse(""pre-installed carrier helper apps contains an empty string"",
                        TextUtils.isEmpty(helperApp));
            }
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/SystemConfigTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.AutoRevokeTest.kt"	"DisableAnimationRule"	""	"1: permission"	"([9:/android/os/cts/AutoRevokeTest.kt]:[permission]:[9]:method_text:[ cleanUp() {        goHome()    }    @AppModeFull(reason = ""Uses separate apps for testing"")   ]) :|: /*
 *.
 */

package android.os.cts

import android.app.ActivityManager.RunningAppProcessInfo.IMPORTANCE_TOP_SLEEPING
import android.app.Instrumentation
import android.content.Context
import android.content.Intent
import android.content.Intent.ACTION_AUTO_REVOKE_PERMISSIONS
import android.content.Intent.FLAG_ACTIVITY_NEW_TASK
import android.content.pm.PackageManager
import android.content.pm.PackageManager.PERMISSION_DENIED
import android.content.pm.PackageManager.PERMISSION_GRANTED
import android.content.res.Resources
import android.net.Uri
import android.os.Build
import android.platform.test.annotations.AppModeFull
import android.support.test.uiautomator.By
import android.support.test.uiautomator.BySelector
import android.support.test.uiautomator.UiObject2
import android.support.test.uiautomator.UiObjectNotFoundException
import android.view.accessibility.AccessibilityNodeInfo
import android.widget.Switch
import androidx.test.InstrumentationRegistry
import androidx.test.filters.SdkSuppress
import androidx.test.runner.AndroidJUnit4
import com.android.compatibility.common.util.DisableAnimationRule
import com.android.compatibility.common.util.FreezeRotationRule
import com.android.compatibility.common.util.MatcherUtils.hasTextThat
import com.android.compatibility.common.util.SystemUtil
import com.android.compatibility.common.util.SystemUtil.callWithShellPermissionIdentity
import com.android.compatibility.common.util.SystemUtil.eventually
import com.android.compatibility.common.util.SystemUtil.getEventually
import com.android.compatibility.common.util.SystemUtil.runShellCommandOrThrow
import com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity
import com.android.compatibility.common.util.UI_ROOT
import com.android.compatibility.common.util.click
import com.android.compatibility.common.util.depthFirstSearch
import com.android.compatibility.common.util.uiDump
import com.android.modules.utils.build.SdkLevel
import org.hamcrest.CoreMatchers.contain"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/AutoRevokeTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.AutoRevokeTest.kt"	"testUnusedApp_getsPermissionRevoked"	""	"1: permission"	"([5:/android/os/cts/AutoRevokeTest.kt]:[permission]:[5]:method_text:[ack()            }        }    }    @AppModeFull(reason = ""Uses separate apps for testing"")   ]) :|: 
    @Ignore(""b/201545116"")
    fun testUnusedApp_getsPermissionRevoked() {
        assumeFalse(
                ""Watch doesn't provide a unified way to check notifications. it depends on UX"",
                hasFeatureWatch())
        withUnusedThresholdMs(3L) {
            withDummyApp {
                // Setup
                startAppAndAcceptPermission()
                killDummyApp()
                Thread.sleep(5) // wait longer than the unused threshold

                // Run
                runAppHibernationJob(context, LOG_TAG)

                // Verify
                assertPermission(PERMISSION_DENIED)
                openUnusedAppsNotification()

                waitFindObject(By.text(supportedAppPackageName))
                waitFindObject(By.text(""Calendar permission removed""))
                goBack()
            }
        }
    }

    @AppModeFull(reason = ""Uses separate apps for testing"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/AutoRevokeTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.AutoRevokeTest.kt"	"testUnusedApp_uninstallApp"	""	"1: permission"	"([1:/android/os/cts/AutoRevokeTest.kt]:[permission]:[1]:method_text:[arate apps for testing"")    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S, codeName = ""S"")   ]) :|: 
    fun testUnusedApp_uninstallApp() {
        withUnusedThresholdMs(3L) {
            withDummyAppNoUninstallAssertion {
                // Setup
                startAppAndAcceptPermission()
                killDummyApp()
                Thread.sleep(5) // wait longer than the unused threshold

                // Run
                runAppHibernationJob(context, LOG_TAG)

                // Verify
                openUnusedAppsNotification()
                waitFindObject(By.text(supportedAppPackageName))

                assertTrue(isPackageInstalled(supportedAppPackageName))
                clickUninstallIcon()
                clickUninstallOk()

                eventually {
                    assertFalse(isPackageInstalled(supportedAppPackageName))
                }

                goBack()
            }
        }
    }

    @AppModeFull(reason = ""Uses separate apps for testing"")
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S, codeName = ""S"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/AutoRevokeTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.AutoRevokeTest.kt"	"testUnusedApp_doesntGetSplitPermissionRevoked"	""	"1: permission"	"([5:/android/os/cts/AutoRevokeTest.kt]:[permission]:[5]:method_text:[NECT)            }        }    }    @AppModeFull(reason = ""Uses separate apps for testing"")   ]) :|: 
    fun testUnusedApp_doesntGetSplitPermissionRevoked() {
        assumeFalse(
            ""Auto doesn't support hibernation for pre-S apps"",
            isAutomotiveDevice())
        withUnusedThresholdMs(3L) {
            withDummyApp(APK_PATH_R_APP, APK_PACKAGE_NAME_R_APP) {
                // Setup
                startApp(APK_PACKAGE_NAME_R_APP)
                assertPermission(PERMISSION_GRANTED, APK_PACKAGE_NAME_R_APP, BLUETOOTH_CONNECT)
                killDummyApp(APK_PACKAGE_NAME_R_APP)
                Thread.sleep(500)

                // Run
                runAppHibernationJob(context, LOG_TAG)

                // Verify
                assertPermission(PERMISSION_GRANTED, APK_PACKAGE_NAME_R_APP, BLUETOOTH_CONNECT)
            }
        }
    }

    @AppModeFull(reason = ""Uses separate apps for testing"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/AutoRevokeTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.AutoRevokeTest.kt"	"testUsedApp_doesntGetPermissionRevoked"	""	"1: permission"	"([6:/android/os/cts/AutoRevokeTest.kt]:[permission]:[6]:method_text:[NTED)            }        }    }    @AppModeFull(reason = ""Uses separate apps for testing"")   ]) :|: 
    fun testUsedApp_doesntGetPermissionRevoked() {
        withUnusedThresholdMs(100_000L) {
            withDummyApp {
                // Setup
                startApp()
                clickPermissionAllow()
                assertPermission(PERMISSION_GRANTED)
                killDummyApp()
                Thread.sleep(5)

                // Run
                runAppHibernationJob(context, LOG_TAG)
                Thread.sleep(1000)

                // Verify
                assertPermission(PERMISSION_GRANTED)
            }
        }
    }

    @AppModeFull(reason = ""Uses separate apps for testing"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/AutoRevokeTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.AutoRevokeTest.kt"	"testPreMinAutoRevokeVersionUnusedApp_doesntGetPermissionRevoked"	""	"1: permission"	"([11:/android/os/cts/AutoRevokeTest.kt]:[permission]:[11]:method_text:[    }            }        }    }    @AppModeFull(reason = ""Uses separate apps for testing"")   ]) :|: 
    fun testPreMinAutoRevokeVersionUnusedApp_doesntGetPermissionRevoked() {
        withUnusedThresholdMs(3L) {
            withDummyApp(preMinVersionApkPath, preMinVersionAppPackageName) {
                withDummyApp {
                    startApp(preMinVersionAppPackageName)
                    clickPermissionAllow()
                    assertPermission(PERMISSION_GRANTED, preMinVersionAppPackageName)

                    killDummyApp(preMinVersionAppPackageName)

                    startApp()
                    clickPermissionAllow()
                    assertPermission(PERMISSION_GRANTED)

                    killDummyApp()
                    Thread.sleep(20)

                    // Run
                    runAppHibernationJob(context, LOG_TAG)
                    Thread.sleep(500)

                    // Verify
                    assertPermission(PERMISSION_DENIED)
                    assertPermission(PERMISSION_GRANTED, preMinVersionAppPackageName)
                }
            }
        }
    }

    @AppModeFull(reason = ""Uses separate apps for testing"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/AutoRevokeTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.AutoRevokeTest.kt"	"testAutoRevoke_userAllowlisting"	""	"1: permission"	"([4:/android/os/cts/AutoRevokeTest.kt]:[permission]:[4]:method_text:[NTED)            }        }    }    @AppModeFull(reason = ""Uses separate apps for testing"")   ]) :|: 
    fun testAutoRevoke_userAllowlisting() {
        assumeFalse(context.packageManager.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE))
        withUnusedThresholdMs(4L) {
            withDummyApp {
                // Setup
                startApp()
                clickPermissionAllow()
                assertAllowlistState(false)

                // Verify
                waitFindObject(byTextIgnoreCase(""Request allowlist"")).click()
                waitFindObject(byTextIgnoreCase(""Permissions"")).click()
                val autoRevokeEnabledToggle = getAllowlistToggle()
                assertTrue(autoRevokeEnabledToggle.isChecked())

                // Grant allowlist
                autoRevokeEnabledToggle.click()
                eventually {
                    assertFalse(getAllowlistToggle().isChecked())
                }

                // Run
                goBack()
                goBack()
                goBack()
                runAppHibernationJob(context, LOG_TAG)
                Thread.sleep(500L)

                // Verify
                startApp()
                assertAllowlistState(true)
                assertPermission(PERMISSION_GRANTED)
            }
        }
    }

    @AppModeFull(reason = ""Uses separate apps for testing"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/AutoRevokeTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.AutoRevokeTest.kt"	"testInstallGrants_notRevokedImmediately"	""	"1: permission"	"([3:/android/os/cts/AutoRevokeTest.kt]:[permission]:[3]:method_text:[NTED)            }        }    }    @AppModeFull(reason = ""Uses separate apps for testing"")   ]) :|: 
    fun testInstallGrants_notRevokedImmediately() {
        withUnusedThresholdMs(TimeUnit.DAYS.toMillis(30)) {
            withDummyApp {
                // Setup
                goToPermissions()
                click(""Calendar"")
                click(""Allow"")
                goBack()
                goBack()
                goBack()

                // Run
                runAppHibernationJob(context, LOG_TAG)
                Thread.sleep(500)

                // Verify
                assertPermission(PERMISSION_GRANTED)
            }
        }
    }

    @AppModeFull(reason = ""Uses separate apps for testing"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/AutoRevokeTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.AutoRevokeTest.kt"	"testAutoRevoke_allowlistingApis"	""	"1: permission"	"([36:/android/os/cts/AutoRevokeTest.kt]:[permission]:[36]:method_text:[rorMsg: () -> String): T {    return if (this == null) throw AssertionError(errorMsg()) else this}]) :|: 
    fun testAutoRevoke_allowlistingApis() {
        withDummyApp {
            val pm = context.packageManager
            runWithShellPermissionIdentity {
                assertFalse(pm.isAutoRevokeWhitelisted(supportedAppPackageName))
            }

            runWithShellPermissionIdentity {
                assertTrue(pm.setAutoRevokeWhitelisted(supportedAppPackageName, true))
            }
            eventually {
                runWithShellPermissionIdentity {
                    assertTrue(pm.isAutoRevokeWhitelisted(supportedAppPackageName))
                }
            }

            runWithShellPermissionIdentity {
                assertTrue(pm.setAutoRevokeWhitelisted(supportedAppPackageName, false))
            }
            eventually {
                runWithShellPermissionIdentity {
                    assertFalse(pm.isAutoRevokeWhitelisted(supportedAppPackageName))
                }
            }
        }
    }

    private fun isAutomotiveDevice(): Boolean {
        return context.packageManager.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE)
    }

    private fun installApp() {
        installApk(supportedApkPath)
    }

    private fun isPackageInstalled(packageName: String): Boolean {
        val pm = context.packageManager

        return callWithShellPermissionIdentity {
            try {
                pm.getPackageInfo(packageName, 0)
                true
            } catch (e: PackageManager.NameNotFoundException) {
                false
            }
        }
    }

    private fun uninstallApp() {
        uninstallApp(supportedAppPackageName)
    }

    private fun startApp() {
        startApp(supportedAppPackageName)
    }

    private fun startAppAndAcceptPermission() {
        startApp()
        clickPermissionAllow()
        assertPermission(PERMISSION_GRANTED)
    }

    private fun goBack() {
        runShellCommandOrThrow(""input keyevent KEYCODE_BACK"")
    }

    private fun killDummyApp(pkg: String = supportedAppPackage"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/AutoRevokeTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.StrictModeTest"	"testContentUriWithoutPermission"	""	"1: permission"	"([3:/android/os/cts/StrictModeTest.java]:[permission]:[3]:method_text:[                 getContext().startActivity(intent);                });    }    @AppModeFull   ]) :|: 
    public void testContentUriWithoutPermission() throws Exception {
        StrictMode.setVmPolicy(
                new StrictMode.VmPolicy.Builder()
                        .detectContentUriWithoutPermission()
                        .penaltyLog()
                        .build());

        final Uri uri = Uri.parse(""content://com.example/foobar"");
        inspectViolation(
                () -> {
                    Intent intent = new Intent(Intent.ACTION_VIEW);
                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    intent.setDataAndType(uri, ""image/jpeg"");
                    getContext().startActivity(intent);
                },
                info ->
                        assertThat(info.getStackTrace())
                                .contains(uri + "" exposed beyond app""));

        assertNoViolation(
                () -> {
                    Intent intent = new Intent(Intent.ACTION_VIEW);
                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    intent.setDataAndType(uri, ""image/jpeg"");
                    intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
                    getContext().startActivity(intent);
                });
    }

    @AppModeFull"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/StrictModeTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.StrictModeTest"	"testUntaggedSocketsRaw"	""	"1: permission"	"([1:/android/os/cts/StrictModeTest.java]:[permission]:[1]:method_text:[taggedSocketViolation.class));    }    private static final int PERMISSION_USER_ONLY = 0600;   ]) :|: 
    public void testUntaggedSocketsRaw() throws Exception {
        if (!hasInternetConnection()) {
            Log.i(TAG, ""testUntaggedSockets() ignored on device without Internet"");
            return;
        }

        StrictMode.setVmPolicy(
                new StrictMode.VmPolicy.Builder().detectUntaggedSockets().penaltyLog().build());

        assertNoViolation(
                () -> {
                    TrafficStats.setThreadStatsTag(0xDECAFBAD);
                    try (Socket socket = new Socket(""example.com"", 80)) {
                        socket.getOutputStream().close();
                    } finally {
                        TrafficStats.clearThreadStatsTag();
                    }
                });

        inspectViolation(
                () -> {
                    try (Socket socket = new Socket(""example.com"", 80)) {
                        socket.getOutputStream().close();
                    }
                },
                info -> assertThat(info.getViolationClass())
                        .isAssignableTo(UntaggedSocketViolation.class));
    }

    private static final int PERMISSION_USER_ONLY = 0600;"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/StrictModeTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.StrictModeTest"	"testRead"	""	"1: permission"	"([2:/android/os/cts/StrictModeTest.java]:[permission]:[2]:method_text:[);        inspectViolation(() -> Os.read(fd, new byte[10], 0, 1), assertDiskReadPolicy);    }   ]) :|: 
    public void testRead() throws Exception {
        final File test = File.createTempFile(""foo"", ""bar"");
        final File dir = test.getParentFile();

        final FileInputStream is = new FileInputStream(test);
        final FileDescriptor fd =
                Os.open(test.getAbsolutePath(), OsConstants.O_RDONLY, PERMISSION_USER_ONLY);

        StrictMode.setThreadPolicy(
                new StrictMode.ThreadPolicy.Builder().detectDiskReads().penaltyLog().build());
        inspectViolation(
                test::exists,
                info -> {
                    assertThat(info.getViolationDetails()).isNull();
                    assertThat(info.getStackTrace()).contains(""DiskReadViolation"");
                });

        Consumer<ViolationInfo> assertDiskReadPolicy = info -> assertThat(
                info.getViolationClass()).isAssignableTo(DiskReadViolation.class);
        inspectViolation(test::exists, assertDiskReadPolicy);
        inspectViolation(test::length, assertDiskReadPolicy);
        inspectViolation(dir::list, assertDiskReadPolicy);
        inspectViolation(is::read, assertDiskReadPolicy);

        inspectViolation(() -> new FileInputStream(test), assertDiskReadPolicy);
        inspectViolation(
                () -> Os.open(test.getAbsolutePath(), OsConstants.O_RDONLY, PERMISSION_USER_ONLY),
                assertDiskReadPolicy);
        inspectViolation(() -> Os.read(fd, new byte[10], 0, 1), assertDiskReadPolicy);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/StrictModeTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.StrictModeTest"	"testWrite"	""	"1: permission"	"([2:/android/os/cts/StrictModeTest.java]:[permission]:[2]:method_text:[.renameTo(new File(file.getParent(), ""foobar"")), assertDiskWritePolicy);    }    @AppModeFull   ]) :|: 
    public void testWrite() throws Exception {
        File file = File.createTempFile(""foo"", ""bar"");

        final FileOutputStream os = new FileOutputStream(file);
        final FileDescriptor fd =
                Os.open(file.getAbsolutePath(), OsConstants.O_RDWR, PERMISSION_USER_ONLY);

        StrictMode.setThreadPolicy(
                new StrictMode.ThreadPolicy.Builder().detectDiskWrites().penaltyLog().build());

        inspectViolation(
                file::createNewFile,
                info -> {
                    assertThat(info.getViolationDetails()).isNull();
                    assertThat(info.getStackTrace()).contains(""DiskWriteViolation"");
                });

        Consumer<ViolationInfo> assertDiskWritePolicy = info -> assertThat(
                info.getViolationClass()).isAssignableTo(DiskWriteViolation.class);

        inspectViolation(() -> File.createTempFile(""foo"", ""bar""), assertDiskWritePolicy);
        inspectViolation(() -> new FileOutputStream(file), assertDiskWritePolicy);
        inspectViolation(file::delete, assertDiskWritePolicy);
        inspectViolation(file::createNewFile, assertDiskWritePolicy);
        inspectViolation(() -> os.write(32), assertDiskWritePolicy);

        inspectViolation(
                () -> Os.open(file.getAbsolutePath(), OsConstants.O_RDWR, PERMISSION_USER_ONLY),
                assertDiskWritePolicy);
        inspectViolation(() -> Os.write(fd, new byte[10], 0, 1), assertDiskWritePolicy);
        inspectViolation(() -> Os.fsync(fd), assertDiskWritePolicy);
        inspectViolation(
                () -> file.renameTo(new File(file.getParent(), ""foobar"")), assertDiskWritePolicy);
    }

    @AppModeFull"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/StrictModeTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.AppHibernationIntegrationTest.kt"	"testAppInfo_RemovePermissionsAndFreeUpSpaceToggleExists"	""	"1: permission"	"([4:/android/os/cts/AppHibernationIntegrationTest.kt]:[permission]:[4]:method_text:[Selector): UiObject2 {        return waitFindObject(instrumentation.uiAutomation, selector)    }}]) :|: 
    fun testAppInfo_RemovePermissionsAndFreeUpSpaceToggleExists() {
        withDeviceConfig(NAMESPACE_APP_HIBERNATION, ""app_hibernation_enabled"", ""true"") {
            withApp(APK_PATH_S_APP, APK_PACKAGE_NAME_S_APP) {
                // Open app info
                val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS)
                val uri = Uri.fromParts(""package"", APK_PACKAGE_NAME_S_APP, null /* fragment */)
                intent.data = uri
                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                context.startActivity(intent)

                waitForIdle()
                UiAutomatorUtils.getUiDevice()

                val packageManager = context.packageManager
                val settingsPackage = intent.resolveActivity(packageManager).packageName
                val res = packageManager.getResourcesForApplication(settingsPackage)
                val title = res.getString(
                    res.getIdentifier(""unused_apps_switch"", ""string"", settingsPackage))

                // Settings can have multiple scrollable containers so all of them should be
                // searched.
                var toggleFound = UiDevice.getInstance(instrumentation)
                    .findObject(UiSelector().text(title))
                    .waitForExists(WAIT_TIME_MS)
                var i = 0
                var scrollableObject = UiScrollable(UiSelector().scrollable(true).instance(i))
                while (!toggleFound && scrollableObject.waitForExists(WAIT_TIME_MS)) {
                    toggleFound = scrollableObject.scrollTextIntoView(title)
                    scrollableObject = UiScrollable(UiSelector().scrollable(true).instance(++i))
                }

                assertTrue(""Remove permissions and free up space toggle not found"", toggleFound)
            }
        }
    }

    private fun leaveApp(packageName: String) {
        eventually {
            goHome()
            SystemUtil.runWithShellPermissionIdentity {"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/AppHibernationIntegrationTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.ParcelFileDescriptorProcessTest"	"isInstantApp"	""	"1: permission"	"([1:/android/os/cts/ParcelFileDescriptorProcessTest.java]:[permission]:[1]:method_text:[ITY_SERVICE);            am.killBackgroundProcesses(context.getPackageName());        }    }   ]) :|: public void test/*
 *.
 */

package android.os.cts;

import android.app.ActivityManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.IBinder;
import android.os.ParcelFileDescriptor;
import android.os.RemoteException;
import android.os.SystemClock;
import android.test.AndroidTestCase;

import com.google.common.util.concurrent.AbstractFuture;

import junit.framework.ComparisonFailure;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/**
 * Test various cross-process {@link ParcelFileDescriptor} interactions.
 */
public class ParcelFileDescriptorProcessTest extends AndroidTestCase {

    private Intent redIntent;
    private Intent blueIntent;
    private PeerConnection redConn;
    private PeerConnection blueConn;
    private IParcelFileDescriptorPeer red;
    private IParcelFileDescriptorPeer blue;

    public static class PeerConnection extends AbstractFuture<IParcelFileDescriptorPeer>
            implements ServiceConnection {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            set(IParcelFileDescriptorPeer.Stub.asInterface(service));
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
        }

        @Override
        public IParcelFileDescriptorPeer get() throws InterruptedException, ExecutionException {
            try {
                return get(5, TimeUnit.SECONDS);
            } catch (TimeoutException e) {
                throw new RuntimeException(e);
            }
        }
    }

    private static void assertContains(String expected, String actual) {
        if (actual.contains(expected)) return;
        throw new ComparisonFailure("""", expected, actual);
    }

    private static void crash(IParcelFileDescriptorPeer peer) {
        try {
            peer.cr"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorProcessTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.storage.cts.StorageManagerTest"	"testAttemptMountObbWrongPackage"	""	"1: permission"	"([1:/android/os/storage/cts/StorageManagerTest.java]:[permission]:[1]:method_text:[ile.getPath()));    }    @AppModeFull(reason = ""Instant apps cannot access external storage"")   ]) :|: public void testAttemptMountObbWrongPackage() {
        for (File target : getTargetFiles()) {
            target = new File(target, ""test1_wrongpackage.obb"");
            Log.d(TAG, ""Testing path "" + target);
            doAttemptMountObbWrongPackage(target);
        }
    }

    private void doAttemptMountObbWrongPackage(File outFile) {
        mountObb(R.raw.test1_wrongpackage, outFile,
                OnObbStateChangeListener.ERROR_PERMISSION_DENIED);

        assertFalse(""OBB should not be mounted"",
                mStorageManager.isObbMounted(outFile.getPath()));

        assertNull(""OBB's mounted path should be null"",
                mStorageManager.getMountedObbPath(outFile.getPath()));
    }

    @AppModeFull(reason = ""Instant apps cannot access external storage"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/storage/cts/StorageManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.storage.cts.StorageManagerTest"	"testFatUuidHandling"	""	"1: permission"	"([1:/android/os/storage/cts/StorageManagerTest.java]:[permission]:[1]:method_text:[    }    @AppModeFull(reason = ""Instant apps cannot hold MANAGE_EXTERNAL_STORAGE permission"")   ]) :|: public void testFatUuidHandling() throws Exception {
        assertEquals(UUID.fromString(""fafafafa-fafa-5afa-8afa-fafa01234567""),
                StorageManager.convert(""0123-4567""));
        assertEquals(UUID.fromString(""fafafafa-fafa-5afa-8afa-fafadeadbeef""),
                StorageManager.convert(""DEAD-BEEF""));
        assertEquals(UUID.fromString(""fafafafa-fafa-5afa-8afa-fafadeadbeef""),
                StorageManager.convert(""dead-BEEF""));

        try {
            StorageManager.convert(""DEADBEEF"");
            fail();
        } catch (IllegalArgumentException expected) {}

        try {
            StorageManager.convert(""DEAD-BEEF0"");
            fail();
        } catch (IllegalArgumentException expected) {}

        assertEquals(""0123-4567"",
                StorageManager.convert(UUID.fromString(""fafafafa-fafa-5afa-8afa-fafa01234567"")));
        assertEquals(""DEAD-BEEF"",
                StorageManager.convert(UUID.fromString(""fafafafa-fafa-5afa-8afa-fafadeadbeef"")));
    }

    @AppModeFull(reason = ""Instant apps cannot hold MANAGE_EXTERNAL_STORAGE permission"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/storage/cts/StorageManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.storage.cts.StorageManagerTest"	"testGetManageSpaceActivityIntent"	""	"1: permission"	"([6:/android/os/storage/cts/StorageManagerTest.java]:[permission]:[6]:method_text:[) {            bytes.write(buffer, 0, count);        }        return bytes.toByteArray();    }}]) :|: public void testGetManageSpaceActivityIntent() throws Exception {
        String packageName = ""android.os.cts"";
        int REQUEST_CODE = 1;
        PendingIntent piActual = null;

        // Without MANAGE_EXTERNAL_STORAGE permission, this call should fail.
        assertThrows(
                RuntimeException.class,
                () -> mStorageManager.getManageSpaceActivityIntent(packageName, REQUEST_CODE));

        // Adopt MANAGE_EXTERNAL_STORAGE permission and then try the API call. We launch
        // the manageSpaceActivity in a new task.
        InstrumentationRegistry.getInstrumentation().getUiAutomation().adoptShellPermissionIdentity(
                android.Manifest.permission.MANAGE_EXTERNAL_STORAGE);

        // Invalid packageName should throw an IllegalArgumentException
        String invalidPackageName = ""this.is.invalid"";
        assertThrows(
                IllegalArgumentException.class,
                () -> mStorageManager.getManageSpaceActivityIntent(invalidPackageName,
                        REQUEST_CODE));

        piActual = mStorageManager.getManageSpaceActivityIntent(packageName,
                REQUEST_CODE);
        assertThat(piActual.isActivity()).isTrue();

        // Nothing to assert, but call send to make sure it does not throw an exception
        piActual.send();

        // Drop MANAGE_EXTERNAL_STORAGE permission
        InstrumentationRegistry.getInstrumentation().getUiAutomation().dropShellPermissionIdentity();
    }

    private void assertStorageVolumesEquals(StorageVolume volume, StorageVolume clone)
            throws Exception {
        // Asserts equals() method.
        assertEquals(""StorageVolume.equals() mismatch"", volume, clone);
        // Make sure all fields match.
        for (Field field : StorageVolume.class.getDeclaredFields()) {
            if (Modifier.isStatic(field.getModifiers())) continue;
            field.setAccessible(true);
            final Object originalValue = field.get(volume);"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/storage/cts/StorageManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.image.cts.DynamicSystemClientTest"	"adoptShellPermissionIdentity"	""	"1: permission"	"([1:/android/os/image/cts/DynamicSystemClientTest.java]:[permission]:[1]:method_text:[rumentation();        mInstrumentation.getUiAutomation().adoptShellPermissionIdentity();    }   ]) :|: /*
 *.
 */

package android.os.cts;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import android.app.Instrumentation;
import android.content.ActivityNotFoundException;
import android.content.pm.PackageManager;
import android.net.Uri;
import android.os.image.DynamicSystemClient;
import android.platform.test.annotations.AppModeFull;

import androidx.test.InstrumentationRegistry;
import androidx.test.filters.SmallTest;
import androidx.test.runner.AndroidJUnit4;

import org.junit.After;
import org.junit.Assume;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

@AppModeFull(reason = ""Instant apps cannot access DynamicSystemClient"")
@SmallTest
@RunWith(AndroidJUnit4.class)
public class DynamicSystemClientTest implements DynamicSystemClient.OnStatusChangedListener {
    private boolean mUpdated;
    private Instrumentation mInstrumentation;

    private static final String DSU_PACKAGE_NAME = ""com.android.dynsystem"";

    private PackageManager getPackageManager() {
        return mInstrumentation.getContext().getPackageManager();
    }

    public void onStatusChanged(int status, int cause, long progress, Throwable detail) {
        mUpdated = true;
    }

    @Before
    public void setUp() {
        mInstrumentation = InstrumentationRegistry.getInstrumentation();
        mInstrumentation.getUiAutomation().adoptShellPermissionIdentity();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/image/cts/DynamicSystemClientTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.image.cts.DynamicSystemClientTest"	"testDynamicSystemClient_withoutOnStatusChangedListener"	""	"1: permission"	"([1:/android/os/image/cts/DynamicSystemClientTest.java]:[permission]:[1]:method_text:[ void tearDown() {        mInstrumentation.getUiAutomation().dropShellPermissionIdentity();    }}]) :|: 
    public void testDynamicSystemClient_withoutOnStatusChangedListener() {
        DynamicSystemClient dSClient = new DynamicSystemClient(mInstrumentation.getTargetContext());
        try {
            dSClient.bind();
        } catch (SecurityException e) {
            fail();
        }
        Uri uri = Uri.parse(""https://www.google.com/"").buildUpon().build();
        try {
            dSClient.start(uri, 1024L << 10);
        } catch (ActivityNotFoundException e) {
            try {
                getPackageManager().getPackageInfo(DSU_PACKAGE_NAME, 0);
            } catch (PackageManager.NameNotFoundException ignore) {
                Assume.assumeNoException(ignore);
            }
            throw e;
        } catch (SecurityException e) {
            fail();
        }
        try {
            Thread.sleep(3 * 1000);
        } catch (InterruptedException e) {
            fail();
        }
        try {
            dSClient.unbind();
        } catch (SecurityException e) {
            fail();
        }
    }

    @After
    public void tearDown() {
        mInstrumentation.getUiAutomation().dropShellPermissionIdentity();
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/image/cts/DynamicSystemClientTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.type.cts.MimeMapTest"	"bug154667531_consistent"	"CtsMimeMapTestCases"	"1: permission"	"([1:/android/content/type/cts/MimeMapTest.java]:[permission]:[1]:method_text:[d to "" + after);                    }                    break;            }        }    }   ]) :|:  public void bug154667531_consistent() {
        // Verify that if developers start from a strongly-typed MIME type, that
        // sending it through a file extension doesn't lose that fidelity. We're
        // only interested in the major MIME types that are relevant to
        // permission models; we're not worried about generic types like
        // ""application/x-flac"" being mapped to ""audio/flac"".
        for (String before : mimeMap.mimeTypes()) {
            final String beforeMajor = extractMajorMimeType(before);
            switch (beforeMajor.toLowerCase(Locale.US)) {
                case ""audio"":
                case ""video"":
                case ""image"":
                    final String extension = mimeMap.guessExtensionFromMimeType(before);
                    final String after = mimeMap.guessMimeTypeFromExtension(extension);
                    final String afterMajor = extractMajorMimeType(after);
                    if (!beforeMajor.equalsIgnoreCase(afterMajor)) {
                        fail(""Expected "" + before + "" to map back to "" + beforeMajor
                                + ""/* after bouncing through file extension, ""
                                + ""but instead mapped to "" + after);
                    }
                    break;
            }
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/mimemap/src/android/content/type/cts/MimeMapTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.openglperf.cts.GlAppSwitchTest"	"testGlActivitySwitchingSlow"	"CtsOpenGlPerfTestCases"	"1: permission"	"([1:/android/openglperf/cts/GlAppSwitchTest.java]:[permission]:[1]:method_text:[an show) {        mActivityManager.moveTaskToFront(show ? mTaskIdReplica : mTaskIdSelf, 0);    }}]) :|: public void testGlActivitySwitchingSlow() throws InterruptedException {
        runTaskSwitchTest(TASK_SWITCH_SLOW_WAIT_TIME_MS, NUMBER_OF_TASK_SWITCHES_SLOW);
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        Instrumentation instrument = getInstrumentation();
        Context context = instrument.getContext();

        // This is needed so that |mActivityManager.getRunningTasks(...)| is able to
        // see tasks from |REPLICA_ISLAND_PACKAGE|.
        instrument.getUiAutomation().adoptShellPermissionIdentity();

        mActivityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);

        Intent intentPlanets = new Intent();
        intentPlanets.putExtra(GlPlanetsActivity.INTENT_EXTRA_NUM_FRAMES, 0); //runs forever
        intentPlanets.putExtra(GlPlanetsActivity.INTENT_EXTRA_NUM_PLANETS, 4); // max load
        setActivityIntent(intentPlanets);
        Activity activity = getActivity();
        instrument.waitForIdleSync();
        mTaskIdSelf = activity.getTaskId();
        // wait further to render some frames
        Thread.sleep(1000);

        Intent intentIsland = new Intent(Intent.ACTION_MAIN);
        intentIsland.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        intentIsland.addCategory(Intent.CATEGORY_LAUNCHER);
        intentIsland.setComponent(new ComponentName(REPLICA_ISLAND_PACKAGE,
                REPLICA_ISLAND_PACKAGE + ""."" + REPLICA_ISLAND_ACTIVITY));
        context.startActivity(intentIsland);
        // wait to render some frames
        Thread.sleep(5000);

        setReplicaIslandTask();
    }

    @Override
    protected void tearDown() throws Exception {
        showOrHideReplicaIsland(false);
        super.tearDown();
    }

    /**
     * run foreground / background task switching between replica island and GlPlanetsActivity.
     * @param waitTimeMs time to wait after each task switching
     * @param numberOfSwitches number of task switches to run
     * @thro"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/openglperf/src/android/openglperf/cts/GlAppSwitchTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.systemui.cts.WindowInsetsBehaviorTests"	"WindowInsetsBehaviorTests"	"CtsSystemUiTestCases"	"1: permission"	"([2:/android/systemui/cts/WindowInsetsBehaviorTests.java]:[permission]:[2]:method_text:[rn bounds;    }    /**     * @throws Throwable when setting the property goes wrong.     */   ]) :|: /*
 *.
 */

package android.systemui.cts;

import static android.app.WindowConfiguration.WINDOWING_MODE_FULLSCREEN;
import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;
import static android.provider.DeviceConfig.NAMESPACE_ANDROID;
import static android.provider.AndroidDeviceConfig.KEY_SYSTEM_GESTURE_EXCLUSION_LIMIT_DP;
import static android.view.View.SYSTEM_UI_CLEARABLE_FLAGS;
import static android.view.View.SYSTEM_UI_FLAG_FULLSCREEN;
import static android.view.View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;
import static android.view.View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;
import static android.view.View.SYSTEM_UI_FLAG_VISIBLE;

import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;

import static junit.framework.Assert.assertEquals;
import static junit.framework.TestCase.fail;

import static org.junit.Assert.assertTrue;
import static org.junit.Assume.assumeTrue;

import static java.util.concurrent.TimeUnit.SECONDS;

import android.app.ActivityOptions;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.res.Resources;
import android.graphics.Insets;
import android.graphics.Point;
import android.graphics.Rect;
import android.hardware.display.DisplayManager;
import android.os.Bundle;
import android.provider.DeviceConfig;
import android.support.test.uiautomator.By;
import android.support.test.uiautomator.BySelector;
import android.support.test.uiautomator.UiDevice;
import android.support.test.uiautomator.UiObject2;
import android.support.test.uiautomator.Until;
import android.util.ArrayMap;
import android.util.DisplayMetrics;
import android.view.Display;
import android.view.View;
import android.view.ViewTreeObserver;
import android.view.WindowInsets;

import androidx.test.platform.app.InstrumentationRegistry;
import androidx.test.rule.ActivityTestRule;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.co"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/systemui/src/android/systemui/cts/WindowInsetsBehaviorTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.systemui.cts.WindowInsetsBehaviorTests"	"getSystemUiVisibility"	"CtsSystemUiTestCases"	"1: permission"	"([2:/android/systemui/cts/WindowInsetsBehaviorTests.java]:[permission]:[2]:method_text:[oString(originalLimitDp[0]) : null,                    false /* makeDefault */));        }    }}]) :|: 
    public void swipeOutsideLimit_immersiveSticky_noEventCanceled() throws Throwable {
        assumeTrue(hasSystemGestureFeature());

        // The first event may be never canceled. So we need to swipe at least twice.
        final int swipeCount = 2;
        final boolean insideLimit = false;
        testSystemGestureExclusionLimit(swipeCount, insideLimit, SYSTEM_UI_FLAG_IMMERSIVE_STICKY
                | SYSTEM_UI_FLAG_FULLSCREEN | SYSTEM_UI_FLAG_HIDE_NAVIGATION);

        assertEquals(""Swipe must not be canceled."", 0, mActionCancelPoints.size());
        assertEquals(""Action up points."", swipeCount, mActionUpPoints.size());
        assertEquals(""Action down points."", swipeCount, mActionDownPoints.size());
    }

    private void testSystemGestureExclusionLimit(int swipeCount, boolean insideLimit,
            int systemUiVisibility) throws Throwable {
        final int shiftY = insideLimit ? 1 : -1;
        assumeGestureNavigation();
        doInExclusionLimitSession(() -> {
            setSystemUiVisibility(systemUiVisibility);
            setAndWaitForSystemGestureExclusionRectsListenerTrigger(null);

            final Rect swipeBounds = new Rect();
            mainThreadRun(() -> {
                final View rootView = mActivity.getWindow().getDecorView();
                swipeBounds.set(mActivity.getViewBoundOnScreen(rootView));
            });
            // The limit is consumed from bottom to top.
            final int swipeY = swipeBounds.bottom - mExclusionLimit + shiftY;

            for (int i = 0; i < swipeCount; i++) {
                mDevice.swipe(swipeBounds.left, swipeY, swipeBounds.right, swipeY, STEPS);
            }

            mainThreadRun(() -> {
                mActionDownPoints = mActivity.getActionDownPoints();
                mActionUpPoints = mActivity.getActionUpPoints();
                mActionCancelPoints = mActivity.getActionCancelPoints();
            });
        });
    }

    private void assumeGestureNavigation() {
        f"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/systemui/src/android/systemui/cts/WindowInsetsBehaviorTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.audio.cts.RoutingTest"	"test_audioTrack_preferredDevice"	""	"1: permission"	"([1:/android/media/audio/cts/RoutingTest.java]:[permission]:[1]:method_text:[ll));        assertNull(audioTrack.getPreferredDevice());        audioTrack.release();    }   ]) :|: public void test_audioTrack_preferredDevice() {
        if (!mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUDIO_OUTPUT)) {
            // Can't do it so skip this test
            return;
        }

        AudioTrack audioTrack = allocAudioTrack();
        assertNotNull(audioTrack);

        // None selected (new AudioTrack), so check for default
        assertNull(audioTrack.getPreferredDevice());

        // resets to default
        assertTrue(audioTrack.setPreferredDevice(null));

        // test each device
        AudioDeviceInfo[] deviceList = mAudioManager.getDevices(AudioManager.GET_DEVICES_OUTPUTS);
        for (int index = 0; index < deviceList.length; index++) {
            if (deviceList[index].getType() == AudioDeviceInfo.TYPE_TELEPHONY) {
                // Device with type as TYPE_TELEPHONY requires a privileged permission.
                continue;
            }
            assertTrue(audioTrack.setPreferredDevice(deviceList[index]));
            assertTrue(audioTrack.getPreferredDevice() == deviceList[index]);
        }

        // Check defaults again
        assertTrue(audioTrack.setPreferredDevice(null));
        assertNull(audioTrack.getPreferredDevice());

        audioTrack.release();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/audio/src/android/media/audio/cts/RoutingTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.audio.cts.RoutingTest"	"test_audioTrack_incallMusicRoutingPermissions"	""	"1: permission"	"([4:/android/media/audio/cts/RoutingTest.java]:[permission]:[4]:method_text:[oTrack audioTrack) {}        public void onRoutingChanged(AudioRouting audioRouting) {}    }   ]) :|: public void test_audioTrack_incallMusicRoutingPermissions() {
        if (!mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUDIO_OUTPUT)) {
            // Can't do it so skip this test
            return;
        }

        // only apps with MODIFY_PHONE_STATE permission can route playback
        // to the uplink stream during a phone call, so this test makes sure that
        // audio is re-routed to default device when the permission is missing

        AudioDeviceInfo telephonyDevice = getTelephonyDeviceAndSetInCommunicationMode();
        if (telephonyDevice == null) {
            // Can't do it so skip this test
            return;
        }

        AudioTrack audioTrack = null;

        try {
            audioTrack = allocAudioTrack();
            assertNotNull(audioTrack);

            audioTrack.setPreferredDevice(telephonyDevice);
            assertEquals(AudioDeviceInfo.TYPE_TELEPHONY, audioTrack.getPreferredDevice().getType());

            audioTrack.play();
            assertTrue(audioTrack.getRoutedDevice().getType() != AudioDeviceInfo.TYPE_TELEPHONY);

        } finally {
            if (audioTrack != null) {
                audioTrack.stop();
                audioTrack.release();
            }
            mAudioManager.setMode(AudioManager.MODE_NORMAL);
        }
    }

    private AudioDeviceInfo getTelephonyDeviceAndSetInCommunicationMode() {
        // get the output device for telephony
        AudioDeviceInfo telephonyDevice = null;
        AudioDeviceInfo[] deviceList = mAudioManager.getDevices(AudioManager.GET_DEVICES_OUTPUTS);
        for (int index = 0; index < deviceList.length; index++) {
            if (deviceList[index].getType() == AudioDeviceInfo.TYPE_TELEPHONY) {
                telephonyDevice = deviceList[index];
            }
        }

        if (telephonyDevice == null) {
            return null;
        }

        // simulate an in call state using MODE_IN_COMMUNICATION since
        // AudioManager.setMo"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/audio/src/android/media/audio/cts/RoutingTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.audio.cts.RoutingTest"	"test_mediaPlayer_preferredDevice"	""	"1: permission"	"([1:/android/media/audio/cts/RoutingTest.java]:[permission]:[1]:method_text:[Player.getPreferredDevice());        mediaPlayer.stop();        mediaPlayer.release();    }   ]) :|: public void test_mediaPlayer_preferredDevice() {
        if (!mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUDIO_OUTPUT)) {
            // Can't do it so skip this test
            return;
        }

        MediaPlayer mediaPlayer = allocMediaPlayer();
        assertTrue(mediaPlayer.isPlaying());

        // None selected (new MediaPlayer), so check for default
        assertNull(mediaPlayer.getPreferredDevice());

        // resets to default
        assertTrue(mediaPlayer.setPreferredDevice(null));

        // test each device
        AudioDeviceInfo[] deviceList = mAudioManager.getDevices(AudioManager.GET_DEVICES_OUTPUTS);
        for (int index = 0; index < deviceList.length; index++) {
            if (deviceList[index].getType() == AudioDeviceInfo.TYPE_TELEPHONY) {
                // Device with type as TYPE_TELEPHONY requires a privileged permission.
                continue;
            }
            assertTrue(mediaPlayer.setPreferredDevice(deviceList[index]));
            assertTrue(mediaPlayer.getPreferredDevice() == deviceList[index]);
        }

        // Check defaults again
        assertTrue(mediaPlayer.setPreferredDevice(null));
        assertNull(mediaPlayer.getPreferredDevice());

        mediaPlayer.stop();
        mediaPlayer.release();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/audio/src/android/media/audio/cts/RoutingTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.audio.cts.RoutingTest"	"test_mediaPlayer_incallMusicRoutingPermissions"	""	"1: permission"	"([4:/android/media/audio/cts/RoutingTest.java]:[permission]:[4]:method_text:[ing AudioRecord is initialized.        Thread.sleep(1000);        return mediaRecorder;    }   ]) :|: public void test_mediaPlayer_incallMusicRoutingPermissions() {
        if (!mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUDIO_OUTPUT)) {
            // Can't do it so skip this test
            return;
        }

        // only apps with MODIFY_PHONE_STATE permission can route playback
        // to the uplink stream during a phone call, so this test makes sure that
        // audio is re-routed to default device when the permission is missing

        AudioDeviceInfo telephonyDevice = getTelephonyDeviceAndSetInCommunicationMode();
        if (telephonyDevice == null) {
            // Can't do it so skip this test
            return;
        }

        MediaPlayer mediaPlayer = null;

        try {
            mediaPlayer = allocMediaPlayer(telephonyDevice, false);
            assertEquals(AudioDeviceInfo.TYPE_TELEPHONY, mediaPlayer.getPreferredDevice().getType());
            mediaPlayer.start();
            // Sleep for 1s to ensure the underlying AudioTrack is created and started
            SystemClock.sleep(1000);
            telephonyDevice = mediaPlayer.getRoutedDevice();
            // 3 behaviors are accepted when permission to play to telephony device is rejected:
            // - indicate a null routed device
            // - fallback to another device for playback
            // - stop playback in error.
            assertTrue(telephonyDevice == null
                    || telephonyDevice.getType() != AudioDeviceInfo.TYPE_TELEPHONY
                    || !mediaPlayer.isPlaying());
        } finally {
            if (mediaPlayer != null) {
                mediaPlayer.stop();
                mediaPlayer.release();
            }
            mAudioManager.setMode(AudioManager.MODE_NORMAL);
        }
    }

    private MediaRecorder allocMediaRecorder() throws Exception {
        final String outputPath = new File(Environment.getExternalStorageDirectory(),
            ""record.out"").getAbsolutePath();
        mOutFile = new File(outpu"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/audio/src/android/media/audio/cts/RoutingTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.audio.cts.RoutingTest"	"test_mediaRecorder_preferredDevice"	""	"1: permission"	"([1:/android/media/audio/cts/RoutingTest.java]:[permission]:[1]:method_text:[ad.sleep(RECORD_TIME_MS);        mediaRecorder.stop();        mediaRecorder.release();    }   ]) :|: public void test_mediaRecorder_preferredDevice() throws Exception {
        if (!mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_MICROPHONE)
                || !MediaUtils.hasEncoder(MediaFormat.MIMETYPE_AUDIO_AAC)) {
            MediaUtils.skipTest(""no audio codecs or microphone"");
            return;
        }

        MediaRecorder mediaRecorder = allocMediaRecorder();

        // None selected (new MediaPlayer), so check for default
        assertNull(mediaRecorder.getPreferredDevice());

        // resets to default
        assertTrue(mediaRecorder.setPreferredDevice(null));

        // test each device
        AudioDeviceInfo[] deviceList = mAudioManager.getDevices(AudioManager.GET_DEVICES_INPUTS);
        for (int index = 0; index < deviceList.length; index++) {
            if (!AVAILABLE_INPUT_DEVICES_TYPE.contains(deviceList[index].getType())) {
                // Only try to set devices whose type is contained in predefined set as preferred
                // device in case of permission denied when switching input device.
                continue;
            }
            assertTrue(mediaRecorder.setPreferredDevice(deviceList[index]));
            assertTrue(mediaRecorder.getPreferredDevice() == deviceList[index]);
        }

        // Check defaults again
        assertTrue(mediaRecorder.setPreferredDevice(null));
        assertNull(mediaRecorder.getPreferredDevice());
        Thread.sleep(RECORD_TIME_MS);

        mediaRecorder.stop();
        mediaRecorder.release();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/audio/src/android/media/audio/cts/RoutingTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.audio.cts.AudioRecordingConfigurationTest"	"testParcel"	""	"1: permission"	"([2:/android/media/audio/cts/AudioRecordingConfigurationTest.java]:[permission]:[2]:method_text:[       fail(""Exception thrown during reflection on config privileged fields"" + e);        }    }}]) :|: public void testParcel() throws Exception {
        if (!hasMicrophone()) {
            return;
        }
        AudioManager am = new AudioManager(getContext());
        assertNotNull(""Could not create AudioManager"", am);

        assertEquals(AudioRecord.STATE_INITIALIZED, mAudioRecord.getState());
        mAudioRecord.startRecording();
        assertEquals(AudioRecord.RECORDSTATE_RECORDING, mAudioRecord.getRecordingState());
        Thread.sleep(TEST_TIMING_TOLERANCE_MS);

        List<AudioRecordingConfiguration> configs = am.getActiveRecordingConfigurations();
        assertTrue(""Empty array of record configs during recording"", configs.size() > 0);
        assertEquals(0, configs.get(0).describeContents());

        // marshall a AudioRecordingConfiguration and compare to unmarshalled
        final Parcel srcParcel = Parcel.obtain();
        final Parcel dstParcel = Parcel.obtain();

        configs.get(0).writeToParcel(srcParcel, 0 /*no public flags for marshalling*/);
        final byte[] mbytes = srcParcel.marshall();
        dstParcel.unmarshall(mbytes, 0, mbytes.length);
        dstParcel.setDataPosition(0);
        final AudioRecordingConfiguration unmarshalledConf =
                AudioRecordingConfiguration.CREATOR.createFromParcel(dstParcel);

        assertNotNull(""Failure to unmarshall AudioRecordingConfiguration"", unmarshalledConf);
        assertEquals(""Source and destination AudioRecordingConfiguration not equal"",
                configs.get(0), unmarshalledConf);
    }

    static class MyAudioRecordingCallback extends AudioManager.AudioRecordingCallback {
        boolean mCalled;
        List<AudioRecordingConfiguration> mConfigs;
        private final int mTestSource;
        private final int mTestSession;
        private CountDownLatch mCountDownLatch;

        void reset() {
            mCountDownLatch = new CountDownLatch(1);
            mCalled = false;
            mConfigs = new ArrayList<AudioRecordingConfiguration>();
        }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/audio/src/android/media/audio/cts/AudioRecordingConfigurationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.audio.cts.AudioRecordTest"	"testRestrictedAudioSourcePermissions"	""	"1: permission"	"([4:/android/media/audio/cts/AudioRecordTest.java]:[permission]:[4]:method_text:[                 + source + "" Exception:"" + e);                }            }        }    }   ]) :|: 
    public void testRestrictedAudioSourcePermissions() throws Exception {
        // Make sure that the following audio sources cannot be used by apps that
        // don't have the CAPTURE_AUDIO_OUTPUT permissions:
        // - VOICE_CALL,
        // - VOICE_DOWNLINK
        // - VOICE_UPLINK
        // - REMOTE_SUBMIX
        // - ECHO_REFERENCE  - 1997
        // - RADIO_TUNER - 1998
        // - HOTWORD - 1999
        // The attempt to build an AudioRecord with those sources should throw either
        // UnsupportedOperationException or IllegalArgumentException exception.
        final int[] restrictedAudioSources = new int [] {
            MediaRecorder.AudioSource.VOICE_CALL,
            MediaRecorder.AudioSource.VOICE_DOWNLINK,
            MediaRecorder.AudioSource.VOICE_UPLINK,
            MediaRecorder.AudioSource.REMOTE_SUBMIX,
            1997,
            1998,
            1999
        };

        for (int source : restrictedAudioSources) {
            // AudioRecord.Builder should fail when trying to use
            // one of the voice call audio sources.
            try {
                AudioRecord ar = new AudioRecord.Builder()
                 .setAudioSource(source)
                 .setAudioFormat(new AudioFormat.Builder()
                         .setEncoding(AudioFormat.ENCODING_PCM_16BIT)
                         .setSampleRate(8000)
                         .setChannelMask(AudioFormat.CHANNEL_IN_MONO)
                         .build())
                 .build();
                fail(""testRestrictedAudioSourcePermissions: no exception thrown for source: ""
                        + source);
            } catch (Exception e) {
                Log.i(TAG, ""Exception: "" + e);
                if (!UnsupportedOperationException.class.isInstance(e)
                        && !IllegalArgumentException.class.isInstance(e)) {
                    fail(""testRestrictedAudioSourcePermissions: no exception thrown for source: ""
                        + sourc"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/audio/src/android/media/audio/cts/AudioRecordTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.audio.cts.AudioManagerTest"	"isMicrophoneMute"	""	"1: permission"	"([1:/android/media/audio/cts/AudioManagerTest.java]:[permission]:[1]:method_text:[    @AppModeFull(reason = ""Instant apps cannot hold android.permission.MODIFY_AUDIO_SETTINGS"")   ]) :|: public void test/*
 *.
 */

package android.media.audio.cts;

import static org.junit.Assert.assertNotEquals;

import static android.media.AudioManager.ADJUST_LOWER;
import static android.media.AudioManager.ADJUST_RAISE;
import static android.media.AudioManager.ADJUST_SAME;
import static android.media.AudioManager.MODE_IN_CALL;
import static android.media.AudioManager.MODE_IN_COMMUNICATION;
import static android.media.AudioManager.MODE_NORMAL;
import static android.media.AudioManager.MODE_RINGTONE;
import static android.media.AudioManager.RINGER_MODE_NORMAL;
import static android.media.AudioManager.RINGER_MODE_SILENT;
import static android.media.AudioManager.RINGER_MODE_VIBRATE;
import static android.media.AudioManager.STREAM_ACCESSIBILITY;
import static android.media.AudioManager.STREAM_ALARM;
import static android.media.AudioManager.STREAM_DTMF;
import static android.media.AudioManager.STREAM_MUSIC;
import static android.media.AudioManager.STREAM_NOTIFICATION;
import static android.media.AudioManager.STREAM_RING;
import static android.media.AudioManager.STREAM_SYSTEM;
import static android.media.AudioManager.STREAM_VOICE_CALL;
import static android.media.AudioManager.USE_DEFAULT_STREAM_TYPE;
import static android.media.AudioManager.VIBRATE_SETTING_OFF;
import static android.media.AudioManager.VIBRATE_SETTING_ON;
import static android.media.AudioManager.VIBRATE_SETTING_ONLY_SILENT;
import static android.media.AudioManager.VIBRATE_TYPE_NOTIFICATION;
import static android.media.AudioManager.VIBRATE_TYPE_RINGER;
import static android.provider.Settings.System.SOUND_EFFECTS_ENABLED;

import android.Manifest;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.content.res.Resources;
import android.media.AudioAttributes;
import android.media.AudioDe"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/audio/src/android/media/audio/cts/AudioManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.audio.cts.AudioManagerTest"	"testMicrophoneMute"	""	"1: permission"	"([1:/android/media/audio/cts/AudioManagerTest.java]:[permission]:[1]:method_text:[    @AppModeFull(reason = ""Instant apps cannot hold android.permission.MODIFY_AUDIO_SETTINGS"")   ]) :|: public void testMicrophoneMute() throws Exception {
        mAudioManager.setMicrophoneMute(true);
        assertTrue(mAudioManager.isMicrophoneMute());
        mAudioManager.setMicrophoneMute(false);
        assertFalse(mAudioManager.isMicrophoneMute() && !mDoNotCheckUnmute);
    }

    @AppModeFull(reason = ""Instant apps cannot hold android.permission.MODIFY_AUDIO_SETTINGS"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/audio/src/android/media/audio/cts/AudioManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.audio.cts.AudioManagerTest"	"testMicrophoneMuteIntent"	""	"1: permission"	"([1:/android/media/audio/cts/AudioManagerTest.java]:[permission]:[1]:method_text:[    @AppModeFull(reason = ""Instant apps cannot hold android.permission.MODIFY_AUDIO_SETTINGS"")   ]) :|: public void testMicrophoneMuteIntent() throws Exception {
        if (!mDoNotCheckUnmute) {
            final MyBlockingIntentReceiver receiver = new MyBlockingIntentReceiver(
                    AudioManager.ACTION_MICROPHONE_MUTE_CHANGED);
            final boolean initialMicMute = mAudioManager.isMicrophoneMute();
            try {
                mContext.registerReceiver(receiver,
                        new IntentFilter(AudioManager.ACTION_MICROPHONE_MUTE_CHANGED));
                // change the mic mute state
                mAudioManager.setMicrophoneMute(!initialMicMute);
                // verify a change was reported
                final boolean intentFired = receiver.waitForExpectedAction(500/*ms*/);
                assertTrue(""ACTION_MICROPHONE_MUTE_CHANGED wasn't fired"", intentFired);
                // verify the mic mute state is expected
                final boolean newMicMute = mAudioManager.isMicrophoneMute();
                assertTrue(""new mic mute state not as expected ("" + !initialMicMute + "")"",
                        (newMicMute == !initialMicMute));
            } finally {
                mContext.unregisterReceiver(receiver);
                mAudioManager.setMicrophoneMute(initialMicMute);
            }
        }
    }

    @AppModeFull(reason = ""Instant apps cannot hold android.permission.MODIFY_AUDIO_SETTINGS"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/audio/src/android/media/audio/cts/AudioManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.audio.cts.AudioManagerTest"	"testMusicActive"	""	"1: permission"	"([1:/android/media/audio/cts/AudioManagerTest.java]:[permission]:[1]:method_text:[    @AppModeFull(reason = ""Instant apps cannot hold android.permission.MODIFY_AUDIO_SETTINGS"")   ]) :|: public void testMusicActive() throws Exception {
        if (mAudioManager.isMusicActive()) {
            return;
        }
        MediaPlayer mp = MediaPlayer.create(mContext, MP3_TO_PLAY);
        assertNotNull(mp);
        mp.setAudioStreamType(STREAM_MUSIC);
        mp.start();
        assertMusicActive(true);
        mp.stop();
        mp.release();
        assertMusicActive(false);
    }

    @AppModeFull(reason = ""Instant apps cannot hold android.permission.MODIFY_AUDIO_SETTINGS"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/audio/src/android/media/audio/cts/AudioManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.audio.cts.AudioManagerTest"	"testSetSurroundFormatEnabled"	""	"1: permission"	"([3:/android/media/audio/cts/AudioManagerTest.java]:[permission]:[3]:method_text:[oFormat));        getInstrumentation().getUiAutomation().dropShellPermissionIdentity();    }   ]) :|: public void testSetSurroundFormatEnabled() throws Exception {
        getInstrumentation().getUiAutomation().adoptShellPermissionIdentity(
                Manifest.permission.WRITE_SETTINGS);

        int audioFormat = AudioFormat.ENCODING_DTS;

        mAudioManager.setSurroundFormatEnabled(audioFormat, true /*enabled*/);
        assertTrue(mAudioManager.isSurroundFormatEnabled(audioFormat));

        mAudioManager.setSurroundFormatEnabled(audioFormat, false /*enabled*/);
        assertFalse(mAudioManager.isSurroundFormatEnabled(audioFormat));

        getInstrumentation().getUiAutomation().dropShellPermissionIdentity();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/audio/src/android/media/audio/cts/AudioManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.audio.cts.AudioManagerTest"	"testSetEncodedSurroundMode"	""	"1: permission"	"([4:/android/media/audio/cts/AudioManagerTest.java]:[permission]:[4]:method_text:[)    @AppModeFull(reason = ""Instant apps cannot hold android.permission.MODIFY_AUDIO_SETTINGS"")   ]) :|: public void testSetEncodedSurroundMode() throws Exception {
        getInstrumentation().getUiAutomation().adoptShellPermissionIdentity(
                Manifest.permission.WRITE_SETTINGS);

        int expectedSurroundFormatsMode = Settings.Global.ENCODED_SURROUND_OUTPUT_MANUAL;
        mAudioManager.setEncodedSurroundMode(expectedSurroundFormatsMode);
        assertEquals(expectedSurroundFormatsMode, mAudioManager.getEncodedSurroundMode());

        expectedSurroundFormatsMode = Settings.Global.ENCODED_SURROUND_OUTPUT_NEVER;
        mAudioManager.setEncodedSurroundMode(expectedSurroundFormatsMode);
        assertEquals(expectedSurroundFormatsMode, mAudioManager.getEncodedSurroundMode());

        getInstrumentation().getUiAutomation().dropShellPermissionIdentity();
    }

    @SuppressWarnings(""deprecation"")
    @AppModeFull(reason = ""Instant apps cannot hold android.permission.MODIFY_AUDIO_SETTINGS"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/audio/src/android/media/audio/cts/AudioManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.audio.cts.AudioManagerTest"	"testAccessibilityVolume"	""	"1: permission"	"([1:/android/media/audio/cts/AudioManagerTest.java]:[permission]:[1]:method_text:[ITY, originalVol,                    ""Should not be able to change A11y vol"");        }    }   ]) :|: public void testAccessibilityVolume() throws Exception {
        if (mUseFixedVolume) {
            Log.i(""AudioManagerTest"", ""testAccessibilityVolume() skipped: fixed volume"");
            return;
        }
        final int maxA11yVol = mAudioManager.getStreamMaxVolume(STREAM_ACCESSIBILITY);
        assertTrue(""Max a11yVol not strictly positive"", maxA11yVol > 0);
        int originalVol = mAudioManager.getStreamVolume(STREAM_ACCESSIBILITY);

        // changing STREAM_ACCESSIBILITY is subject to permission, shouldn't be able to change it
        // test setStreamVolume
        final int testSetVol;
        if (originalVol != maxA11yVol) {
            testSetVol = maxA11yVol;
        } else {
            testSetVol = maxA11yVol - 1;
        }
        mAudioManager.setStreamVolume(STREAM_ACCESSIBILITY, testSetVol, 0);
        assertStreamVolumeEquals(STREAM_ACCESSIBILITY, originalVol,
                ""Should not be able to change A11y vol"");

        // test adjustStreamVolume
        //        LOWER
        if (originalVol > 0) {
            mAudioManager.adjustStreamVolume(STREAM_ACCESSIBILITY, ADJUST_LOWER, 0);
            assertStreamVolumeEquals(STREAM_ACCESSIBILITY, originalVol,
                    ""Should not be able to change A11y vol"");
        }
        //        RAISE
        if (originalVol < maxA11yVol) {
            mAudioManager.adjustStreamVolume(STREAM_ACCESSIBILITY, ADJUST_RAISE, 0);
            assertStreamVolumeEquals(STREAM_ACCESSIBILITY, originalVol,
                    ""Should not be able to change A11y vol"");
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/audio/src/android/media/audio/cts/AudioManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.audio.cts.AudioManagerTest"	"testSetVoiceCallVolumeToZeroPermission"	""	"1: permission"	"([1:/android/media/audio/cts/AudioManagerTest.java]:[permission]:[1]:method_text:[volume to 0"",                    mAudioManager.getStreamVolume(STREAM_VOICE_CALL) != 0);    }   ]) :|: public void testSetVoiceCallVolumeToZeroPermission() {
        // Verify that only apps with MODIFY_PHONE_STATE can set VOICE_CALL_STREAM to 0
        mAudioManager.setStreamVolume(STREAM_VOICE_CALL, 0, 0);
        assertTrue(""MODIFY_PHONE_STATE is required in order to set voice call volume to 0"",
                    mAudioManager.getStreamVolume(STREAM_VOICE_CALL) != 0);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/audio/src/android/media/audio/cts/AudioManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.audio.cts.AudioManagerTest"	"testPreferredDevicesForStrategy"	""	"1: permission"	"([5:/android/media/audio/cts/AudioManagerTest.java]:[permission]:[5]:method_text:[          fail(""onPreferredDevicesForCapturePresetChanged must not be called"");        }    }   ]) :|: public void testPreferredDevicesForStrategy() {
        // setPreferredDeviceForStrategy
        AudioDeviceInfo[] devices = mAudioManager.getDevices(AudioManager.GET_DEVICES_OUTPUTS);
        if (devices.length <= 0) {
            Log.i(TAG, ""Skip testPreferredDevicesForStrategy as there is no output device"");
            return;
        }
        final AudioDeviceAttributes ada = new AudioDeviceAttributes(devices[0]);

        final AudioAttributes mediaAttr = new AudioAttributes.Builder().setUsage(
                AudioAttributes.USAGE_MEDIA).build();
        final List<AudioProductStrategy> strategies =
                AudioProductStrategy.getAudioProductStrategies();
        AudioProductStrategy strategyForMedia = null;
        for (AudioProductStrategy strategy : strategies) {
            if (strategy.supportsAudioAttributes(mediaAttr)) {
                strategyForMedia = strategy;
                break;
            }
        }
        if (strategyForMedia == null) {
            Log.i(TAG, ""Skip testPreferredDevicesForStrategy as there is no strategy for media"");
            return;
        }

        try {
            mAudioManager.setPreferredDeviceForStrategy(strategyForMedia, ada);
            fail(""setPreferredDeviceForStrategy must fail due to no permission"");
        } catch (SecurityException e) {
        }
        try {
            mAudioManager.getPreferredDeviceForStrategy(strategyForMedia);
            fail(""getPreferredDeviceForStrategy must fail due to no permission"");
        } catch (SecurityException e) {
        }
        final List<AudioDeviceAttributes> adas = new ArrayList<>();
        adas.add(ada);
        try {
            mAudioManager.setPreferredDevicesForStrategy(strategyForMedia, adas);
            fail(""setPreferredDevicesForStrategy must fail due to no permission"");
        } catch (SecurityException e) {
        }
        try {
            mAudioManager.getPreferredDevicesForStrategy(strategyForMedia);
            fail(""getPref"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/audio/src/android/media/audio/cts/AudioManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.audio.cts.AudioManagerTest"	"testPreferredDeviceForCapturePreset"	""	"1: permission"	"([4:/android/media/audio/cts/AudioManagerTest.java]:[permission]:[4]:method_text:[        mAudioManager.removeOnPreferredDevicesForCapturePresetChangedListener(listener);    }   ]) :|: public void testPreferredDeviceForCapturePreset() {
        AudioDeviceInfo[] devices = mAudioManager.getDevices(AudioManager.GET_DEVICES_INPUTS);
        if (devices.length <= 0) {
            Log.i(TAG, ""Skip testPreferredDevicesForStrategy as there is no input device"");
            return;
        }
        final AudioDeviceAttributes ada = new AudioDeviceAttributes(devices[0]);

        try {
            mAudioManager.setPreferredDeviceForCapturePreset(MediaRecorder.AudioSource.MIC, ada);
            fail(""setPreferredDeviceForCapturePreset must fail due to no permission"");
        } catch (SecurityException e) {
        }
        try {
            mAudioManager.getPreferredDevicesForCapturePreset(MediaRecorder.AudioSource.MIC);
            fail(""getPreferredDevicesForCapturePreset must fail due to no permission"");
        } catch (SecurityException e) {
        }
        try {
            mAudioManager.clearPreferredDevicesForCapturePreset(MediaRecorder.AudioSource.MIC);
            fail(""clearPreferredDevicesForCapturePreset must fail due to no permission"");
        } catch (SecurityException e) {
        }
        MyPrevDevicesForCapturePresetChangedListener listener =
                new MyPrevDevicesForCapturePresetChangedListener();
        try {
            mAudioManager.addOnPreferredDevicesForCapturePresetChangedListener(
                Executors.newSingleThreadExecutor(), listener);
            fail(""addOnPreferredDevicesForCapturePresetChangedListener must fail""
                    + ""due to no permission"");
        } catch (SecurityException e) {
        }
        // There is not listener added at server side. Nothing to remove.
        mAudioManager.removeOnPreferredDevicesForCapturePresetChangedListener(listener);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/audio/src/android/media/audio/cts/AudioManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.audio.cts.AudioManagerTest"	"testGetDevices"	""	"1: permission"	"([1:/android/media/audio/cts/AudioManagerTest.java]:[permission]:[1]:method_text:[ibutes() require privledged permission MODIFY_AUDIO_ROUTING    // and thus cannot be tested here.}]) :|: public void testGetDevices() {
        AudioDeviceInfo[] devices = mAudioManager.getDevices(AudioManager.GET_DEVICES_ALL);
        for (AudioDeviceInfo device : devices) {
            HashSet<Integer> formats = IntStream.of(device.getEncodings()).boxed()
                    .collect(Collectors.toCollection(HashSet::new));
            HashSet<Integer> channelMasks = IntStream.of(device.getChannelMasks()).boxed()
                    .collect(Collectors.toCollection(HashSet::new));
            HashSet<Integer> channelIndexMasks = IntStream.of(device.getChannelIndexMasks()).boxed()
                    .collect(Collectors.toCollection(HashSet::new));
            HashSet<Integer> sampleRates = IntStream.of(device.getSampleRates()).boxed()
                    .collect(Collectors.toCollection(HashSet::new));
            HashSet<Integer> formatsFromProfile = new HashSet<>();
            HashSet<Integer> channelMasksFromProfile = new HashSet<>();
            HashSet<Integer> channelIndexMasksFromProfile = new HashSet<>();
            HashSet<Integer> sampleRatesFromProfile = new HashSet<>();
            for (AudioProfile profile : device.getAudioProfiles()) {
                formatsFromProfile.add(profile.getFormat());
                channelMasksFromProfile.addAll(Arrays.stream(profile.getChannelMasks()).boxed()
                        .collect(Collectors.toList()));
                channelIndexMasksFromProfile.addAll(Arrays.stream(profile.getChannelIndexMasks())
                        .boxed().collect(Collectors.toList()));
                sampleRatesFromProfile.addAll(Arrays.stream(profile.getSampleRates()).boxed()
                        .collect(Collectors.toList()));
                assertTrue(ALL_ENCAPSULATION_TYPES.contains(profile.getEncapsulationType()));
            }
            for (AudioDescriptor descriptor : device.getAudioDescriptors()) {
                assertNotEquals(AudioDescriptor.STANDARD_NONE, descriptor.getStandard());
                assertNotNull(d"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/audio/src/android/media/audio/cts/AudioManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.audio.cts.AudioRecordSharedAudioTest"	"adoptShellPermissionIdentity"	""	"1: permission"	"([4:/android/media/audio/cts/AudioRecordSharedAudioTest.java]:[permission]:[4]:method_text:[               .dropShellPermissionIdentity();        clearAudioserverPermissionCache();    }   ]) :|: /*
 *.
 */

package android.media.audio.cts;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.testng.Assert.assertThrows;

import android.content.Context;
import android.content.pm.PackageManager;
import android.media.AudioFormat;
import android.media.AudioRecord;
import android.media.MediaSyncEvent;
import android.media.cts.NonMediaMainlineTest;
import android.util.Log;

import androidx.test.InstrumentationRegistry;
import androidx.test.filters.SdkSuppress;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.SystemUtil;

import java.io.IOException;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;



@NonMediaMainlineTest
@RunWith(AndroidJUnit4.class)
@SdkSuppress(minSdkVersion = 31, codeName = ""S"")
public class AudioRecordSharedAudioTest {
    private static final String TAG = ""AudioRecordSharedAudioTest"";
    private static final int SAMPLING_RATE_HZ = 16000;

    @Before
    public void setUp() throws Exception {
        if (!hasMicrophone()) {
            return;
        }
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity();
        clearAudioserverPermissionCache();
    }

    @After
    public void tearDown() throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .dropShellPermissionIdentity();
        clearAudioserverPermissionCache();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/audio/src/android/media/audio/cts/AudioRecordSharedAudioTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.audio.cts.AudioRecordSharedAudioTest"	"testPermissionFailure"	""	"1: permission"	"([3:/android/media/audio/cts/AudioRecordSharedAudioTest.java]:[permission]:[3]:method_text:[ackageName(), 100);                });        record.stop();        record.release();    }   ]) :|: 
    public void testPermissionFailure() throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .dropShellPermissionIdentity();
        clearAudioserverPermissionCache();

        assertThrows(UnsupportedOperationException.class, () -> {
                    AudioRecord record = new AudioRecord.Builder().setMaxSharedAudioHistoryMillis(
                            AudioRecord.getMaxSharedAudioHistoryMillis() - 1).build();
                });

        final AudioRecord record =
                new AudioRecord.Builder()
                        .setAudioFormat(new AudioFormat.Builder()
                            .setSampleRate(SAMPLING_RATE_HZ)
                            .setEncoding(AudioFormat.ENCODING_PCM_16BIT)
                            .setChannelMask(AudioFormat.CHANNEL_IN_MONO).build())
                        .setBufferSizeInBytes(SAMPLING_RATE_HZ
                                * AudioFormat.getBytesPerSample(AudioFormat.ENCODING_PCM_16BIT))
                        .build();
        assertEquals(AudioRecord.STATE_INITIALIZED, record.getState());
        record.startRecording();
        Thread.sleep(500);

        assertThrows(SecurityException.class, () -> {
                    record.shareAudioHistory(
                            InstrumentationRegistry.getTargetContext().getPackageName(), 100);
                });

        record.stop();
        record.release();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/audio/src/android/media/audio/cts/AudioRecordSharedAudioTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.audio.cts.AudioRecordSharedAudioTest"	"testPermissionSuccess"	""	"1: permission"	"([2:/android/media/audio/cts/AudioRecordSharedAudioTest.java]:[permission]:[2]:method_text:[);        } finally {            record.stop();            record.release();        }    }   ]) :|: 
    public void testPermissionSuccess() throws Exception {
        AudioRecord record = new AudioRecord.Builder().setAudioFormat(new AudioFormat.Builder()
                    .setSampleRate(SAMPLING_RATE_HZ)
                    .setEncoding(AudioFormat.ENCODING_PCM_16BIT)
                    .setChannelMask(AudioFormat.CHANNEL_IN_MONO).build())
                .setBufferSizeInBytes(SAMPLING_RATE_HZ
                        * AudioFormat.getBytesPerSample(AudioFormat.ENCODING_PCM_16BIT))
                .setMaxSharedAudioHistoryMillis(
                    AudioRecord.getMaxSharedAudioHistoryMillis()-1)
                .build();

        assertEquals(AudioRecord.STATE_INITIALIZED, record.getState());

        record.startRecording();
        Thread.sleep(500);
        try {
            record.shareAudioHistory(
                    InstrumentationRegistry.getTargetContext().getPackageName(), 100);
        } catch (SecurityException e) {
            fail(""testPermissionSuccess shareAudioHistory be allowed"");
        } finally {
            record.stop();
            record.release();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/audio/src/android/media/audio/cts/AudioRecordSharedAudioTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.audio.cts.AudioRecordSharedAudioTest"	"testCapturesMatch"	""	"1: permission"	"([3:/android/media/audio/cts/AudioRecordSharedAudioTest.java]:[permission]:[3]:method_text:[(IOException e) {            fail(""cannot purge audio server permission cache"");        }    }}]) :|: 
    public void testCapturesMatch() throws Exception {
        AudioRecord record1 = null;
        AudioRecord record2 = null;
        try {
            record1 = new AudioRecord.Builder().setAudioFormat(new AudioFormat.Builder()
                                .setSampleRate(SAMPLING_RATE_HZ)
                                .setEncoding(AudioFormat.ENCODING_PCM_16BIT)
                                .setChannelMask(AudioFormat.CHANNEL_IN_MONO).build())
                            .setBufferSizeInBytes(SAMPLING_RATE_HZ
                                * AudioFormat.getBytesPerSample(AudioFormat.ENCODING_PCM_16BIT))
                            .setMaxSharedAudioHistoryMillis(
                                    AudioRecord.getMaxSharedAudioHistoryMillis() - 1)
                            .build();
            assertEquals(AudioRecord.STATE_INITIALIZED, record1.getState());

            record1.startRecording();

            final int RECORD1_NUM_SAMPLES = SAMPLING_RATE_HZ / 2;
            short[] buffer1 = new short[RECORD1_NUM_SAMPLES];

            // blocking read should allow for at least 500ms of audio in buffer
            int samplesRead = record1.read(buffer1, 0, RECORD1_NUM_SAMPLES);
            assertTrue(samplesRead >= RECORD1_NUM_SAMPLES);


            final int RECORD2_START_TIME_MS = 100;
            MediaSyncEvent event = record1.shareAudioHistory(
                    InstrumentationRegistry.getTargetContext().getPackageName(),
                    (long) RECORD2_START_TIME_MS /* startFromMillis */);
            assertEquals(event.getAudioSessionId(), record1.getAudioSessionId());

            record2 = new AudioRecord.Builder().setAudioFormat(new AudioFormat.Builder()
                                .setSampleRate(SAMPLING_RATE_HZ)
                                .setEncoding(AudioFormat.ENCODING_PCM_16BIT)
                                .setChannelMask(AudioFormat.CHANNEL_IN_MONO).build())
                            .setBufferSizeInBytes(SAMPLING_R"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/audio/src/android/media/audio/cts/AudioRecordSharedAudioTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.audio.cts.AudioFocusTest"	"testAudioFocusRequestMediaGainLossWithPlayer"	""	"1: permission"	"([3:/android/media/audio/cts/AudioFocusTest.java]:[permission]:[3]:method_text:[ * @throws Exception     */    @AppModeFull(reason = ""Instant apps cannot access the SD card"")   ]) :|: public void testAudioFocusRequestMediaGainLossWithPlayer() throws Exception {
        if (hasAutomotiveFeature(getContext())) {
            Log.i(TAG, ""Test testAudioFocusRequestMediaGainLossWithPlayer ""
                    + ""skipped: not required for Auto platform"");
            return;
        }

        // for query of fade out duration and focus request/abandon test methods
        getInstrumentation().getUiAutomation().adoptShellPermissionIdentity(
                Manifest.permission.QUERY_AUDIO_STATE);

        final int NB_FOCUS_OWNERS = 2;
        final AudioFocusRequest[] focusRequests = new AudioFocusRequest[NB_FOCUS_OWNERS];
        final FocusChangeListener[] focusListeners = new FocusChangeListener[NB_FOCUS_OWNERS];
        final int FOCUS_UNDER_TEST = 0;// index of focus owner to be tested
        final int FOCUS_SIMULATED = 1; // index of focus requester used to simulate a request coming
                                       //   from another client on a different UID than CTS

        final HandlerThread handlerThread = new HandlerThread(TAG);
        handlerThread.start();
        final Handler handler = new Handler(handlerThread.getLooper());

        final AudioAttributes mediaAttributes = new AudioAttributes.Builder()
                .setUsage(AudioAttributes.USAGE_MEDIA)
                .build();
        for (int focusIndex : new int[]{ FOCUS_UNDER_TEST, FOCUS_SIMULATED }) {
            focusListeners[focusIndex] = new FocusChangeListener();
            focusRequests[focusIndex] = new AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN)
                    .setAudioAttributes(mediaAttributes)
                    .setOnAudioFocusChangeListener(focusListeners[focusIndex], handler)
                    .build();
        }
        final AudioManager am = new AudioManager(getContext());

        MediaPlayer mp = null;
        final String simFocusClientId = ""fakeClientId"";
        try {
            // set up the test conditions: a focus owner is"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/audio/src/android/media/audio/cts/AudioFocusTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.audio.cts.AudioFocusTest"	"testAudioFocusRequestMediaGainLossWithPauseOnDuckFocusRequest"	""	"1: permission"	"([3:/android/media/audio/cts/AudioFocusTest.java]:[permission]:[3]:method_text:[  synchronized (mLock) {                mFocusChange = focusChange;            }        }    }}]) :|: public void testAudioFocusRequestMediaGainLossWithPauseOnDuckFocusRequest() throws Exception {
        if (hasAutomotiveFeature(getContext())) {
            Log.i(TAG, ""Test testAudioFocusRequestMediaGainLossWithSpeechPlayer ""
                    + ""skipped: not required for Auto platform"");
            return;
        }
        doTwoFocusOwnerOnePlayerFocusLoss(
                false /*playSpeech*/,
                false /*speechFocus*/,
                true /*pauseOnDuck*/);
    }

    private void doTwoFocusOwnerOnePlayerFocusLoss(boolean playSpeech, boolean speechFocus,
            boolean pauseOnDuck) throws Exception {
        // for query of fade out duration and focus request/abandon test methods
        getInstrumentation().getUiAutomation().adoptShellPermissionIdentity(
                Manifest.permission.QUERY_AUDIO_STATE);

        final int NB_FOCUS_OWNERS = 2;
        final AudioFocusRequest[] focusRequests = new AudioFocusRequest[NB_FOCUS_OWNERS];
        final FocusChangeListener[] focusListeners = new FocusChangeListener[NB_FOCUS_OWNERS];
        // index of focus owner to be tested, has an active player
        final int FOCUS_UNDER_TEST = 0;
        // index of focus requester used to simulate a request coming from another client
        // on a different UID than CTS
        final int FOCUS_SIMULATED = 1;

        final HandlerThread handlerThread = new HandlerThread(TAG);
        handlerThread.start();
        final Handler handler = new Handler(handlerThread.getLooper());

        final AudioAttributes focusAttributes = new AudioAttributes.Builder()
                .setUsage(AudioAttributes.USAGE_MEDIA)
                .setContentType(playSpeech ? AudioAttributes.CONTENT_TYPE_SPEECH
                        : AudioAttributes.CONTENT_TYPE_MUSIC)
                .build();
        final AudioAttributes playerAttributes = new AudioAttributes.Builder()
                .setUsage(AudioAttributes.USAGE_MEDIA)
                .setContentType(speechFocus"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/audio/src/android/media/audio/cts/AudioFocusTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.cts.MediaPlayerTest"	"testSetOnRtpRxNoticeListenerWithoutPermission"	"CtsMediaTestCases"	"1: permission"	"([2:/android/media/cts/MediaPlayerTest.java]:[permission]:[2]:method_text:[            // Expected. We don't have the required permission.        }    }    @Presubmit   ]) :|: public void testSetOnRtpRxNoticeListenerWithoutPermission() {
        try {
            mMediaPlayer.setOnRtpRxNoticeListener(
                    mContext, Runnable::run, (mp, noticeType, params) -> {});
            fail();
        } catch (IllegalArgumentException e) {
            // Expected. We don't have the required permission.
        }
    }

    @Presubmit"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaPlayerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.cts.MediaPlayerTest"	"testSetOnRtpRxNoticeListenerWithPermission"	"CtsMediaTestCases"	"1: permission"	"([3:/android/media/cts/MediaPlayerTest.java]:[permission]:[3]:method_text:[            getInstrumentation().getUiAutomation().dropShellPermissionIdentity();        }    }}]) :|: public void testSetOnRtpRxNoticeListenerWithPermission() {
        try {
            getInstrumentation().getUiAutomation().adoptShellPermissionIdentity();
            mMediaPlayer.setOnRtpRxNoticeListener(
                    mContext, Runnable::run, (mp, noticeType, params) -> {});
        } finally {
            getInstrumentation().getUiAutomation().dropShellPermissionIdentity();
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaPlayerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.cts.MediaRouter2Test"	"testGettingSystemMediaRouter2WithoutPermissionThrowsSecurityException"	"CtsMediaTestCases"	"1: permission"	"([5:/android/media/cts/MediaRouter2Test.java]:[permission]:[5]:method_text:[ss,                () -> MediaRouter2.getInstance(mContext, mContext.getPackageName()));    }   ]) :|: 
    public void testGettingSystemMediaRouter2WithoutPermissionThrowsSecurityException() {
        // Make sure that the permission is not given.
        assertNotEquals(PackageManager.PERMISSION_GRANTED,
                mContext.checkSelfPermission(Manifest.permission.MEDIA_CONTENT_CONTROL));

        assertThrows(SecurityException.class,
                () -> MediaRouter2.getInstance(mContext, mContext.getPackageName()));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaRouter2Test.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.cts.MediaCasTest"	"adoptShellPermissionIdentity"	"CtsMediaTestCases"	"1: permission"	"([3:/android/media/cts/MediaCasTest.java]:[permission]:[3]:method_text:[th the enumeration results, and all enumerated CA system ids can     * be instantiated.     */   ]) :|: public void test/*
 *.
 */

package android.media.cts;

import android.media.MediaCas;
import android.media.MediaCas.PluginDescriptor;
import android.media.MediaCas.Session;
import android.media.MediaCasException;
import android.media.MediaCasException.UnsupportedCasException;
import android.media.MediaCasStateException;
import android.media.MediaCodec;
import android.media.MediaDescrambler;
import android.media.cts.R;
import android.os.Build;
import android.os.Handler;
import android.os.HandlerThread;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.Presubmit;
import android.platform.test.annotations.RequiresDevice;
import android.test.AndroidTestCase;
import android.util.Log;

import androidx.test.filters.SmallTest;
import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.MediaUtils;
import com.android.compatibility.common.util.PropertyUtil;

import java.lang.ArrayIndexOutOfBoundsException;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Presubmit
@SmallTest
@RequiresDevice
@AppModeFull(reason = ""TODO: evaluate and port to instant"")
public class MediaCasTest extends AndroidTestCase {
    private static final String TAG = ""MediaCasTest"";

    // CA System Ids used for testing
    private static final int sInvalidSystemId = 0;
    private static final int sClearKeySystemId = 0xF6D8;
    private static final int API_LEVEL_BEFORE_CAS_SESSION = 28;
    private boolean mIsAtLeastR = ApiLevelUtil.isAtLeast(Build.VERSION_CODES.R);
    private boolean mIsAtLeastS = ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S);

    // ClearKey CAS/Descrambler test vectors
    private static final String sProvisionStr =
            ""{                                                   "" +
            """	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaCasTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.cts.MediaSessionManagerTest"	"dropShellPermissionIdentity"	"CtsMediaTestCases"	"1: permission"	"([1:/android/media/cts/MediaSessionManagerTest.java]:[permission]:[1]:method_text:[trumentation().getUiAutomation().dropShellPermissionIdentity();        super.tearDown();    }   ]) :|: public void test/*
 *.
 */
package android.media.cts;

import android.Manifest;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.res.Resources;
import android.media.AudioManager;
import android.media.MediaSession2;
import android.media.Session2CommandGroup;
import android.media.Session2Token;
import android.media.session.MediaController;
import android.media.session.MediaSession;
import android.media.session.MediaSessionManager;
import android.media.session.PlaybackState;
import android.os.Build;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Looper;
import android.os.Process;
import android.platform.test.annotations.AppModeFull;
import android.test.InstrumentationTestCase;
import android.test.UiThreadTest;
import android.view.KeyEvent;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.MediaUtils;
import com.android.compatibility.common.util.SystemUtil;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

@AppModeFull(reason = ""TODO: evaluate and port to instant"")
public class MediaSessionManagerTest extends InstrumentationTestCase {
    private static final String TAG = ""MediaSessionManagerTest"";
    private static final int TIMEOUT_MS = 3000;
    private static final int WAIT_MS = 500;

    private AudioManager mAudioManager;
    private MediaSessionManager mSessionManager;

    private static boolean sIsAtLeastS = ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S);
    private static boolean sIsAtLeastT = ApiLevelUtil.isAtLeast(Build.VERSION_CODES.TIRAMISU);

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mAudioManager = (AudioManager) getIns"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaSessionManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.cts.MediaSessionManagerTest"	"testOnMediaKeyEventSessionChangedListener"	"CtsMediaTestCases"	"1: permission"	"([4:/android/media/cts/MediaSessionManagerTest.java]:[permission]:[4]:method_text:[sertFalse(keyEventSessionListener.mCountDownLatch.await(WAIT_MS, TimeUnit.MILLISECONDS));    }   ]) :|: public void testOnMediaKeyEventSessionChangedListener() throws Exception {
        // The permission can be held only on S+
        if (!MediaUtils.check(sIsAtLeastS, ""test invalid before Android 12"")) return;

        getInstrumentation().getUiAutomation().adoptShellPermissionIdentity(
                Manifest.permission.MEDIA_CONTENT_CONTROL,
                Manifest.permission.MANAGE_EXTERNAL_STORAGE);

        MediaKeyEventSessionListener keyEventSessionListener = new MediaKeyEventSessionListener();
        mSessionManager.addOnMediaKeyEventSessionChangedListener(
                Executors.newSingleThreadExecutor(), keyEventSessionListener);

        MediaSession session = createMediaKeySession();
        assertTrue(keyEventSessionListener.mCountDownLatch
                .await(TIMEOUT_MS, TimeUnit.MILLISECONDS));

        assertEquals(session.getSessionToken(), keyEventSessionListener.mSessionToken);
        assertEquals(session.getSessionToken(), mSessionManager.getMediaKeyEventSession());
        assertEquals(getInstrumentation().getTargetContext().getPackageName(),
                mSessionManager.getMediaKeyEventSessionPackageName());

        mSessionManager.removeOnMediaKeyEventSessionChangedListener(keyEventSessionListener);
        keyEventSessionListener.resetCountDownLatch();

        session.release();
        // This shouldn't be called because the callback is removed
        assertFalse(keyEventSessionListener.mCountDownLatch.await(WAIT_MS, TimeUnit.MILLISECONDS));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaSessionManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.cts.MediaSessionManagerTest"	"testOnMediaKeyEventSessionChangedListener_whenSessionIsReleased"	"CtsMediaTestCases"	"1: permission"	"([4:/android/media/cts/MediaSessionManagerTest.java]:[permission]:[4]:method_text:[rtMediaPlaybackStarted(getInstrumentation().getTargetContext());        return session;    }   ]) :|: public void testOnMediaKeyEventSessionChangedListener_whenSessionIsReleased() throws Exception {
        // The permission can be held only on S+
        if (!MediaUtils.check(sIsAtLeastS, ""test invalid before Android 12"")) return;

        getInstrumentation().getUiAutomation().adoptShellPermissionIdentity(
                Manifest.permission.MEDIA_CONTENT_CONTROL,
                Manifest.permission.MANAGE_EXTERNAL_STORAGE);

        MediaKeyEventSessionListener keyEventSessionListener = new MediaKeyEventSessionListener();
        mSessionManager.addOnMediaKeyEventSessionChangedListener(
                Executors.newSingleThreadExecutor(), keyEventSessionListener);

        MediaSession session = createMediaKeySession();
        assertTrue(keyEventSessionListener.mCountDownLatch
                .await(TIMEOUT_MS, TimeUnit.MILLISECONDS));

        // Check that this is called when the session is released.
        keyEventSessionListener.resetCountDownLatch();
        session.release();
        assertTrue(keyEventSessionListener.mCountDownLatch
                .await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
        assertNull(keyEventSessionListener.mSessionToken);
        assertNull(mSessionManager.getMediaKeyEventSession());
        assertEquals("""", mSessionManager.getMediaKeyEventSessionPackageName());
    }

    private MediaSession createMediaKeySession() {
        MediaSession session = new MediaSession(getInstrumentation().getTargetContext(), TAG);
        session.setFlags(MediaSession.FLAG_HANDLES_MEDIA_BUTTONS
                | MediaSession.FLAG_HANDLES_TRANSPORT_CONTROLS);
        PlaybackState state = new PlaybackState.Builder()
                .setState(PlaybackState.STATE_PLAYING, 0, 1.0f).build();
        // Fake the media session service so this session can take the media key events.
        session.setPlaybackState(state);
        session.setActive(true);
        Utils.assertMediaPlaybackStarted(getInstrumentation().getTargetContext());

        return s"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaSessionManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.cts.MediaSessionManagerTest"	"testOnMediaKeyEventSessionChangedListener_noPermission_throwsSecurityException"	"CtsMediaTestCases"	"1: permission"	"([1:/android/media/cts/MediaSessionManagerTest.java]:[permission]:[1]:method_text:[gedListener"");        } catch (SecurityException ex) {            // Expected        }    }   ]) :|: public void testOnMediaKeyEventSessionChangedListener_noPermission_throwsSecurityException() {
        if (!MediaUtils.check(sIsAtLeastS, ""test invalid before Android 12"")) return;
        MediaKeyEventSessionListener keyEventSessionListener = new MediaKeyEventSessionListener();
        try {
            mSessionManager.addOnMediaKeyEventSessionChangedListener(
                    Executors.newSingleThreadExecutor(), keyEventSessionListener);
            fail(""Expected security exception for call to""
                    + "" addOnMediaKeyEventSessionChangedListener"");
        } catch (SecurityException ex) {
            // Expected
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaSessionManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.cts.MediaSessionManagerTest"	"testOnMediaKeyEventDispatchedListener"	"CtsMediaTestCases"	"1: permission"	"([4:/android/media/cts/MediaSessionManagerTest.java]:[permission]:[4]:method_text:[   .await(WAIT_MS, TimeUnit.MILLISECONDS));        session.release();    }    @UiThreadTest   ]) :|: public void testOnMediaKeyEventDispatchedListener() throws Exception {
        // The permission can be held only on S+
        if (!MediaUtils.check(sIsAtLeastS, ""test invalid before Android 12"")) return;

        getInstrumentation().getUiAutomation().adoptShellPermissionIdentity(
                Manifest.permission.MEDIA_CONTENT_CONTROL,
                Manifest.permission.MANAGE_EXTERNAL_STORAGE);

        MediaKeyEventDispatchedListener keyEventDispatchedListener =
                new MediaKeyEventDispatchedListener();
        mSessionManager.addOnMediaKeyEventDispatchedListener(Executors.newSingleThreadExecutor(),
                keyEventDispatchedListener);

        MediaSession session = new MediaSession(getInstrumentation().getTargetContext(), TAG);
        session.setFlags(MediaSession.FLAG_HANDLES_MEDIA_BUTTONS
                | MediaSession.FLAG_HANDLES_TRANSPORT_CONTROLS);
        PlaybackState state = new PlaybackState.Builder()
                .setState(PlaybackState.STATE_PLAYING, 0, 1.0f).build();
        // Fake the media session service so this session can take the media key events.
        session.setPlaybackState(state);
        session.setActive(true);
        Utils.assertMediaPlaybackStarted(getInstrumentation().getTargetContext());

        final int keyCode = KeyEvent.KEYCODE_MEDIA_PLAY;
        simulateMediaKeyInput(keyCode);
        assertTrue(keyEventDispatchedListener.mCountDownLatch
                .await(TIMEOUT_MS, TimeUnit.MILLISECONDS));

        assertEquals(keyCode, keyEventDispatchedListener.mKeyEvent.getKeyCode());
        assertEquals(getInstrumentation().getTargetContext().getPackageName(),
                keyEventDispatchedListener.mPackageName);
        assertEquals(session.getSessionToken(), keyEventDispatchedListener.mSessionToken);

        mSessionManager.removeOnMediaKeyEventDispatchedListener(keyEventDispatchedListener);
        keyEventDispatchedListener.resetCountDownLatch();

        simulateMediaKeyInput(keyCode);"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaSessionManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.cts.SystemMediaRouter2Test"	"ArrayList"	"CtsMediaTestCases"	"1: permission"	"([3:/android/media/cts/SystemMediaRouter2Test.java]:[permission]:[3]:method_text:[callbacks        clearCallbacks();        mUiAutomation.dropShellPermissionIdentity();    }   ]) :|: /*
 *.
 */

package android.media.cts;

import static android.content.Context.AUDIO_SERVICE;
import static android.media.MediaRoute2Info.FEATURE_LIVE_AUDIO;
import static android.media.MediaRoute2Info.PLAYBACK_VOLUME_VARIABLE;
import static android.media.cts.StubMediaRoute2ProviderService.FEATURE_SAMPLE;
import static android.media.cts.StubMediaRoute2ProviderService.FEATURE_SPECIAL;
import static android.media.cts.StubMediaRoute2ProviderService.ROUTE_ID1;
import static android.media.cts.StubMediaRoute2ProviderService.ROUTE_ID2;
import static android.media.cts.StubMediaRoute2ProviderService.ROUTE_ID3_SESSION_CREATION_FAILED;
import static android.media.cts.StubMediaRoute2ProviderService.ROUTE_ID4_TO_SELECT_AND_DESELECT;
import static android.media.cts.StubMediaRoute2ProviderService.ROUTE_ID5_TO_TRANSFER_TO;
import static android.media.cts.StubMediaRoute2ProviderService.ROUTE_ID_VARIABLE_VOLUME;
import static android.media.cts.StubMediaRoute2ProviderService.ROUTE_NAME2;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertTrue;

import android.Manifest;
import android.app.UiAutomation;
import android.content.Context;
import android.media.AudioManager;
import android.media.MediaRoute2Info;
import android.media.MediaRouter2;
import android.media.MediaRouter2.ControllerCallback;
import android.media.MediaRouter2.RouteCallback;
import android.media.MediaRouter2.RoutingController;
import android.media.MediaRouter2.TransferCallback;
import android.media.MediaRouter2Manager;
import android.media.RouteDiscoveryPreference;
import android.media.RoutingSessionInfo;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.LargeTest;
import android.text.TextUtils;

import androidx.test.Instrume"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/SystemMediaRouter2Test.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.view.cts.receivecontent.ContentInfoTest"	"testReleasePermissions"	"CtsViewReceiveContentTestCases"	"1: permission"	"([4:/android/view/cts/receivecontent/ContentInfoTest.java]:[permission]:[4]:method_text:[ontentInfo.Builder(clip, SOURCE_CLIPBOARD).build();        payload.releasePermissions();    }   ]) :|: 
    public void testReleasePermissions() throws Exception {
        // Verify that releasePermissions() doesn't throw when there is no permissions metadata.
        ClipData clip = ClipData.newPlainText("""", ""Hello"");
        ContentInfo payload = new ContentInfo.Builder(clip, SOURCE_CLIPBOARD).build();
        payload.releasePermissions();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/view/receivecontent/src/android/view/cts/receivecontent/ContentInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.view.cts.receivecontent.ContentInfoTest"	"testReleasePermissions_ime"	"CtsViewReceiveContentTestCases"	"1: permission"	"([5:/android/view/cts/receivecontent/ContentInfoTest.java]:[permission]:[5]:method_text:[      payload.releasePermissions();        verify(inputContentInfo).releasePermission();    }   ]) :|: 
    public void testReleasePermissions_ime() throws Exception {
        // Verify that releasePermissions() makes the appropriate call when IME permissions
        // metadata is present.
        ClipData clip = ClipData.newPlainText("""", ""Hello"");
        InputContentInfo inputContentInfo = mock(InputContentInfo.class);
        ContentInfo payload = new ContentInfo.Builder(clip, SOURCE_INPUT_METHOD)
                .setInputContentInfo(inputContentInfo)
                .build();
        payload.releasePermissions();
        verify(inputContentInfo).releasePermission();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/view/receivecontent/src/android/view/cts/receivecontent/ContentInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.view.cts.receivecontent.ContentInfoTest"	"testReleasePermissions_ime_afterCopy"	"CtsViewReceiveContentTestCases"	"1: permission"	"([4:/android/view/cts/receivecontent/ContentInfoTest.java]:[permission]:[4]:method_text:[        copy.releasePermissions();        verify(inputContentInfo).releasePermission();    }   ]) :|: 
    public void testReleasePermissions_ime_afterCopy() throws Exception {
        ClipData clip = ClipData.newPlainText("""", ""Hello"");
        InputContentInfo inputContentInfo = mock(InputContentInfo.class);
        ContentInfo payload = new ContentInfo.Builder(clip, SOURCE_INPUT_METHOD)
                .setInputContentInfo(inputContentInfo)
                .build();

        // Verify that making a copy of the payload via the builder carries along the IME
        // permissions metadata.
        ContentInfo copy = new ContentInfo.Builder(payload).build();
        copy.releasePermissions();
        verify(inputContentInfo).releasePermission();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/view/receivecontent/src/android/view/cts/receivecontent/ContentInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.view.cts.receivecontent.ContentInfoTest"	"testReleasePermissions_dragAndDrop"	"CtsViewReceiveContentTestCases"	"1: permission"	"([10:/android/view/cts/receivecontent/ContentInfoTest.java]:[permission]:[10]:method_text:[;        payload.releasePermissions();        verify(dragAndDropPermissions).release();    }   ]) :|: 
    public void testReleasePermissions_dragAndDrop() throws Exception {
        // Verify that releasePermissions() makes the appropriate call when permissions metadata
        // for drag-and-drop is present.
        ClipData clip = ClipData.newPlainText("""", ""Hello"");
        DragAndDropPermissions dragAndDropPermissions = mock(DragAndDropPermissions.class);
        ContentInfo payload = new ContentInfo.Builder(clip, SOURCE_DRAG_AND_DROP)
                .setDragAndDropPermissions(dragAndDropPermissions)
                .build();
        payload.releasePermissions();
        verify(dragAndDropPermissions).release();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/view/receivecontent/src/android/view/cts/receivecontent/ContentInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.view.cts.receivecontent.ContentInfoTest"	"testReleasePermissions_dragAndDrop_afterCopy"	"CtsViewReceiveContentTestCases"	"1: permission"	"([9:/android/view/cts/receivecontent/ContentInfoTest.java]:[permission]:[9]:method_text:[d();        copy.releasePermissions();        verify(dragAndDropPermissions).release();    }   ]) :|: 
    public void testReleasePermissions_dragAndDrop_afterCopy() throws Exception {
        ClipData clip = ClipData.newPlainText("""", ""Hello"");
        DragAndDropPermissions dragAndDropPermissions = mock(DragAndDropPermissions.class);
        ContentInfo payload = new ContentInfo.Builder(clip, SOURCE_DRAG_AND_DROP)
                .setDragAndDropPermissions(dragAndDropPermissions)
                .build();

        // Verify that making a copy of the payload via the builder carries along the permissions
        // metadata for drag-and-drop.
        ContentInfo copy = new ContentInfo.Builder(payload).build();
        copy.releasePermissions();
        verify(dragAndDropPermissions).release();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/view/receivecontent/src/android/view/cts/receivecontent/ContentInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.view.cts.receivecontent.ContentInfoTest"	"testParcel_imePermissionsMetadata"	"CtsViewReceiveContentTestCases"	"1: permission"	"([4:/android/view/cts/receivecontent/ContentInfoTest.java]:[permission]:[4]:method_text:[     parcel.setDataPosition(0);        return ContentInfo.CREATOR.createFromParcel(parcel);    }}]) :|: 
    public void testParcel_imePermissionsMetadata() throws Exception {
        ClipData clip = ClipData.newPlainText("""", ""Hello"");
        InputContentInfo inputContentInfo = new InputContentInfo(Uri.parse(""content://example/1""),
                new ClipDescription("""", new String[]{""image/png""}));
        ContentInfo payload = new ContentInfo.Builder(clip, SOURCE_INPUT_METHOD)
                .setInputContentInfo(inputContentInfo)
                .build();

        // Verify that releasePermissions() doesn't throw an exception when IME permissions
        // metadata is present after going through parceling.
        ContentInfo fromParcel = parcelAndUnparcel(payload);
        fromParcel.releasePermissions();
    }

    private static ContentInfo parcelAndUnparcel(ContentInfo payload) {
        Parcel parcel = Parcel.obtain();
        payload.writeToParcel(parcel, 0);
        parcel.setDataPosition(0);
        return ContentInfo.CREATOR.createFromParcel(parcel);
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/view/receivecontent/src/android/view/cts/receivecontent/ContentInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.view.cts.ChoreographerNativeTest"	"nativeTestRefreshRateCallbacksAreSyncedWithDisplayManager"	"CtsViewTestCases"	"1: permission"	"([6:/android/view/cts/ChoreographerNativeTest.java]:[permission]:[6]:method_text:[ds)) {            fail(""Failed to setup choreographer tests"");        }    }    @MediumTest   ]) :|: /*
 *.
 */

package android.view.cts;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import android.Manifest;
import android.content.Context;
import android.hardware.display.DisplayManager;
import android.os.Handler;
import android.os.Looper;
import android.view.Display;
import android.view.Display.Mode;
import android.view.Window;
import android.view.WindowManager;

import androidx.test.InstrumentationRegistry;
import androidx.test.annotation.UiThreadTest;
import androidx.test.filters.FlakyTest;
import androidx.test.filters.MediumTest;
import androidx.test.filters.SmallTest;
import androidx.test.rule.ActivityTestRule;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.AdoptShellPermissionsRule;
import com.android.compatibility.common.util.DisplayUtil;

import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.time.Duration;
import java.util.Arrays;
import java.util.Optional;

@FlakyTest
@RunWith(AndroidJUnit4.class)
public class ChoreographerNativeTest {
    private long mChoreographerPtr;

    @Rule
    public ActivityTestRule<CtsActivity> mTestActivityRule =
            new ActivityTestRule<>(
                CtsActivity.class);

    @Rule
    public final AdoptShellPermissionsRule mShellPermissionsRule =
            new AdoptShellPermissionsRule(
                    InstrumentationRegistry.getInstrumentation().getUiAutomation(),
                    Manifest.permission.OVERRIDE_DISPLAY_MODE_REQUESTS,
                    Manifest.permission.MODIFY_REFRESH_RATE_SWITCHING_TYPE);

    private static native long nativeGetChoreographer();
    private static native boolean nativePrepareChoreographerTests(long ptr, long[] refreshPeriods);
    private static native void nativeTestPostCallbackWithoutDelayEventuallyRunsCallbacks(long ptr);
    private static"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/ChoreographerNativeTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.view.cts.SurfaceViewSyncTest"	"TestName"	"CtsViewTestCases"	"1: permission"	"([2:/android/view/cts/SurfaceViewSyncTest.java]:[permission]:[2]:method_text:[  /** Draws a moving 10x10 black rectangle, validates 100 pixels of black are seen each frame */   ]) :|: /*
 *.
 */
package android.view.cts;

import static android.server.wm.WindowManagerState.getLogicalDisplaySize;

import android.animation.ObjectAnimator;
import android.animation.PropertyValuesHolder;
import android.animation.ValueAnimator;
import android.annotation.SuppressLint;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.media.MediaPlayer;
import android.support.test.uiautomator.UiObjectNotFoundException;
import android.view.Gravity;
import android.view.SurfaceHolder;
import android.view.SurfaceView;
import android.view.View;
import android.view.ViewGroup;
import android.view.animation.LinearInterpolator;
import android.view.cts.surfacevalidator.AnimationFactory;
import android.view.cts.surfacevalidator.AnimationTestCase;
import android.view.cts.surfacevalidator.CapturedActivityWithResource;
import android.view.cts.surfacevalidator.PixelChecker;
import android.view.cts.surfacevalidator.ViewFactory;
import android.widget.FrameLayout;

import androidx.test.filters.LargeTest;
import androidx.test.filters.RequiresDevice;
import androidx.test.rule.ActivityTestRule;
import androidx.test.runner.AndroidJUnit4;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TestName;
import org.junit.runner.RunWith;

@RunWith(AndroidJUnit4.class)
@LargeTest
@SuppressLint(""RtlHardcoded"")
@RequiresDevice
public class SurfaceViewSyncTest {
    private static final String TAG = ""SurfaceViewSyncTests"";

    @Rule
    public ActivityTestRule<CapturedActivityWithResource> mActivityRule =
            new ActivityTestRule<>(CapturedActivityWithResource.class);

    @Rule
    public TestName mName = new TestName();

    private CapturedActivityWithResource mActivity;
    private MediaPlayer mMediaPlayer;

    @Before
    public void setup() {
        mActivity = mActivityRule.getActivity();
        mMediaPlayer = mActivity.getMediaPlayer();
        mActivity.setLog"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/SurfaceViewSyncTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.view.cts.AttachedSurfaceControlSyncTest"	"TestName"	"CtsViewTestCases"	"1: permission"	"([2:/android/view/cts/AttachedSurfaceControlSyncTest.java]:[permission]:[2]:method_text:[ Draws a moving 10x10 green rectangle with hole punch, make sure we don't get any sync errors */   ]) :|: /*
 *.
 */
package android.view.cts;

import static android.server.wm.WindowManagerState.getLogicalDisplaySize;

import android.animation.ObjectAnimator;
import android.animation.PropertyValuesHolder;
import android.animation.ValueAnimator;
import android.annotation.SuppressLint;
import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.PorterDuff;
import android.graphics.Rect;
import android.graphics.Region;
import android.support.test.uiautomator.UiObjectNotFoundException;
import android.view.Gravity;
import android.view.SurfaceControl;
import android.view.SurfaceView;
import android.view.Surface;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewTreeObserver;
import android.view.animation.LinearInterpolator;
import android.view.cts.surfacevalidator.AnimationFactory;
import android.view.cts.surfacevalidator.AnimationTestCase;
import android.view.cts.surfacevalidator.CapturedActivityWithResource;
import android.view.cts.surfacevalidator.PixelChecker;
import android.view.cts.surfacevalidator.ViewFactory;
import android.widget.FrameLayout;

import android.util.Log;

import androidx.test.filters.LargeTest;
import androidx.test.filters.RequiresDevice;
import androidx.test.rule.ActivityTestRule;
import androidx.test.runner.AndroidJUnit4;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TestName;
import org.junit.runner.RunWith;

@RunWith(AndroidJUnit4.class)
@LargeTest
@SuppressLint(""RtlHardcoded"")
@RequiresDevice
public class AttachedSurfaceControlSyncTest {
    private static final String TAG = ""AttachedSurfaceControlSyncTests"";

    @Rule
    public ActivityTestRule<CapturedActivityWithResource> mActivityRule =
            new ActivityTestRule<>(CapturedActivityWithResource.class);

    @Rule
    public TestName mName = new TestName();

    private CapturedActivityWithResource mActivity;

      private stati"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/AttachedSurfaceControlSyncTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.view.cts.ASurfaceControlBackPressureTest"	"TestName"	"CtsViewTestCases"	"1: permission"	"([1:/android/view/cts/ASurfaceControlBackPressureTest.java]:[permission]:[1]:method_text:[, buffers);            cycler.start();            mBufferCyclers.add(cycler);        }    }   ]) :|: /*
 *.
 */

package android.view.cts;

import static android.server.wm.WindowManagerState.getLogicalDisplaySize;
import static android.view.cts.util.ASurfaceControlTestUtils.TransactionCompleteListener;
import static android.view.cts.util.ASurfaceControlTestUtils.applyAndDeleteSurfaceTransaction;
import static android.view.cts.util.ASurfaceControlTestUtils.nSurfaceControl_createFromWindow;
import static android.view.cts.util.ASurfaceControlTestUtils.nSurfaceControl_release;
import static android.view.cts.util.ASurfaceControlTestUtils.nSurfaceTransaction_create;
import static android.view.cts.util.ASurfaceControlTestUtils.nSurfaceTransaction_releaseBuffer;
import static android.view.cts.util.ASurfaceControlTestUtils.nSurfaceTransaction_setBuffer;
import static android.view.cts.util.ASurfaceControlTestUtils.nSurfaceTransaction_setEnableBackPressure;
import static android.view.cts.util.ASurfaceControlTestUtils.nSurfaceTransaction_setOnCompleteCallback;
import static android.view.cts.util.ASurfaceControlTestUtils.nSurfaceTransaction_setSolidBuffer;
import static android.view.cts.util.ASurfaceControlTestUtils.reparent;

import static org.junit.Assert.assertTrue;

import android.graphics.Canvas;
import android.graphics.Color;
import android.support.test.uiautomator.UiObjectNotFoundException;
import android.test.suitebuilder.annotation.LargeTest;
import android.view.Surface;
import android.view.SurfaceHolder;
import android.view.cts.surfacevalidator.CapturedActivity;
import android.view.cts.surfacevalidator.MultiFramePixelChecker;
import android.view.cts.surfacevalidator.PixelColor;
import android.view.cts.surfacevalidator.SurfaceControlTestCase;

import androidx.test.rule.ActivityTestRule;
import androidx.test.runner.AndroidJUnit4;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TestName;
import org.junit.runner.RunWith;

import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.Count"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/ASurfaceControlBackPressureTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.cts.network.permission.UpdateStatsPermissionTest"	"testUpdateDeviceStatsPermission"	"CtsNetTestCases"	"1: permission"	"([5:/android/net/cts/network/permission/UpdateStatsPermissionTest.java]:[permission]:[5]:method_text:[ission:     *   {@link android.Manifest.permission#UPDATE_DEVICE_STATS}.     */    @SmallTest   ]) :|: 
    public void testUpdateDeviceStatsPermission() throws Exception {

        // Set the current thread uid to a another uid. It should silently fail when tagging the
        // socket since the current process doesn't have UPDATE_DEVICE_STATS permission.
        TrafficStats.setThreadStatsTag(0);
        TrafficStats.setThreadStatsUid(/*root uid*/ 0);
        Socket socket = new Socket(""example.com"", 80);
        TrafficStats.tagSocket(socket);

        // Transfer 1K of data to a remote host and verify the stats is still billed to the current
        // uid.
        final int byteCount = 1024;

        socket.setTcpNoDelay(true);
        socket.setSoLinger(true, 0);
        OutputStream out = socket.getOutputStream();
        byte[] buf = new byte[byteCount];
        final long uidTxBytesBefore = TrafficStats.getUidTxBytes(Process.myUid());
        out.write(buf);
        out.close();
        socket.close();
        long uidTxBytesAfter = TrafficStats.getUidTxBytes(Process.myUid());
        long uidTxDeltaBytes = uidTxBytesAfter - uidTxBytesBefore;
        assertTrue(""uidtxb: "" + uidTxBytesBefore + "" -> "" + uidTxBytesAfter + "" delta=""
                + uidTxDeltaBytes + "" >= "" + byteCount, uidTxDeltaBytes >= byteCount);
    }

    static final int UNSUPPORTED = -1;

    /**
     * Verify that get TrafficStats of a different uid failed because of the permission is not
     * granted to a third-party app.
     * <p>Tests Permission:
     *   {@link android.Manifest.permission#UPDATE_DEVICE_STATS}.
     */
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/netpermission/updatestatspermission/src/android/net/cts/network/permission/UpdateStatsPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.cts.network.permission.UpdateStatsPermissionTest"	"testGetStatsOfOtherUid"	"CtsNetTestCases"	"1: permission"	"([1:/android/net/cts/network/permission/UpdateStatsPermissionTest.java]:[permission]:[1]:method_text:[ve permission        assertEquals(UNSUPPORTED, TrafficStats.getUidRxBytes(/*root uid*/ 0));    }}]) :|: 
    public void testGetStatsOfOtherUid() throws Exception {
        // Test get stats of another uid failed since the current process does not have permission
        assertEquals(UNSUPPORTED, TrafficStats.getUidRxBytes(/*root uid*/ 0));
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/netpermission/updatestatspermission/src/android/net/cts/network/permission/UpdateStatsPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.vcn.cts.VcnGatewayConnectionConfigTest"	"testBuildVcnGatewayConnectionConfig"	"CtsVcnTestCases"	"1: INTERNET"	"([1:/android/net/vcn/cts/VcnGatewayConnectionConfigTest.java]:[INTERNET]:[1]:method_text:[   assertArrayEquals(RETRY_INTERNAL_MILLIS, gatewayConnConfig.getRetryIntervalsMillis());    }   ]) :|: 
    public void testBuildVcnGatewayConnectionConfig() throws Exception {
        final VcnGatewayConnectionConfig gatewayConnConfig = buildVcnGatewayConnectionConfig();

        assertEquals(VCN_GATEWAY_CONNECTION_NAME, gatewayConnConfig.getGatewayConnectionName());
        assertEquals(buildTunnelConnectionParams(), gatewayConnConfig.getTunnelConnectionParams());
        assertArrayEquals(
                new int[] {NET_CAPABILITY_INTERNET}, gatewayConnConfig.getExposedCapabilities());
        assertArrayEquals(RETRY_INTERNAL_MILLIS, gatewayConnConfig.getRetryIntervalsMillis());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/vcn/src/android/net/vcn/cts/VcnGatewayConnectionConfigTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.vcn.cts.VcnGatewayConnectionConfigTest"	"testBuilderAddRemove"	"CtsVcnTestCases"	"1: INTERNET"	"([1:/android/net/vcn/cts/VcnGatewayConnectionConfigTest.java]:[INTERNET]:[1]:method_text:[        new int[] {NET_CAPABILITY_INTERNET}, gatewayConnConfig.getExposedCapabilities());    }   ]) :|: 
    public void testBuilderAddRemove() throws Exception {
        final VcnGatewayConnectionConfig gatewayConnConfig =
                buildVcnGatewayConnectionConfigBase()
                        .addExposedCapability(NET_CAPABILITY_DUN)
                        .removeExposedCapability(NET_CAPABILITY_DUN)
                        .build();

        assertArrayEquals(
                new int[] {NET_CAPABILITY_INTERNET}, gatewayConnConfig.getExposedCapabilities());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/vcn/src/android/net/vcn/cts/VcnGatewayConnectionConfigTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.vcn.cts.VcnManagerTest"	"testSetVcnConfigOnTestNetwork"	"CtsVcnTestCases"	"1: INTERNET"	"([1:/android/net/vcn/cts/VcnManagerTest.java]:[INTERNET]:[1]:method_text:[etworkCapabilities(vcnNetwork));            }        } // Else already torn down, pass.    }   ]) :|: 
    public void testSetVcnConfigOnTestNetwork() throws Exception {
        final int subId = verifyAndGetValidDataSubId();

        mTestNetworkWrapper =
                new TestNetworkWrapper(
                        mContext,
                        TEST_NETWORK_MTU,
                        true /* isMetered */,
                        Collections.singleton(subId),
                        LOCAL_ADDRESS);
        assertNotNull(""No test network found"", mTestNetworkWrapper.tunNetwork);

        // Get current cell Network then wait for it to drop (due to losing NOT_VCN_MANAGED) before
        // waiting for VCN Network.
        final NetworkRequest cellNetworkReq = new NetworkRequest.Builder()
                .addTransportType(TRANSPORT_CELLULAR)
                .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                .build();
        final VcnTestNetworkCallback cellNetworkCb = new VcnTestNetworkCallback();
        mConnectivityManager.requestNetwork(cellNetworkReq, cellNetworkCb);
        final Network cellNetwork = cellNetworkCb.waitForAvailable();
        assertNotNull(""No cell network found"", cellNetwork);

        CarrierPrivilegeUtils.withCarrierPrivilegesForShell(mContext, subId, () -> {
            SubscriptionGroupUtils.withEphemeralSubscriptionGroup(mContext, subId, (subGrp) -> {
                final Network vcnNetwork =
                        setupAndGetVcnNetwork(subGrp, cellNetwork, cellNetworkCb);

                clearVcnConfigsAndVerifyNetworkTeardown(subGrp, cellNetworkCb, vcnNetwork);
            });
        });

        mConnectivityManager.unregisterNetworkCallback(cellNetworkCb);
    }

    private Network setupAndGetVcnNetwork(
            @NonNull ParcelUuid subGrp,
            @NonNull Network cellNetwork,
            @NonNull VcnTestNetworkCallback cellNetworkCb)
            throws Exception {
        cellNetworkCb.waitForAvailable();
        mVcnManager.setVcnConfig(subGrp, buildTestModeVcnConfig());

        // Wait"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/vcn/src/android/net/vcn/cts/VcnManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.vcn.cts.VcnManagerTest"	"testVcnMigrationAfterNetworkDies"	"CtsVcnTestCases"	"1: INTERNET"	"([1:/android/net/vcn/cts/VcnManagerTest.java]:[INTERNET]:[1]:method_text:[gId */,                true /* expectedUseEncap */,                ikeDeleteChildResp);    }   ]) :|: 
    public void testVcnMigrationAfterNetworkDies() throws Exception {
        final int subId = verifyAndGetValidDataSubId();

        mTestNetworkWrapper =
                new TestNetworkWrapper(
                        mContext,
                        TEST_NETWORK_MTU,
                        true /* isMetered */,
                        Collections.singleton(subId),
                        LOCAL_ADDRESS);
        assertNotNull(""No test network found"", mTestNetworkWrapper.tunNetwork);

        // Get current cell Network then wait for it to drop (due to losing NOT_VCN_MANAGED) before
        // waiting for VCN Network.
        final NetworkRequest cellNetworkReq = new NetworkRequest.Builder()
                .addTransportType(TRANSPORT_CELLULAR)
                .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                .build();
        final VcnTestNetworkCallback cellNetworkCb = new VcnTestNetworkCallback();
        mConnectivityManager.requestNetwork(cellNetworkReq, cellNetworkCb);
        final Network cellNetwork = cellNetworkCb.waitForAvailable();
        assertNotNull(""No cell network found"", cellNetwork);

        CarrierPrivilegeUtils.withCarrierPrivilegesForShell(mContext, subId, () -> {
            SubscriptionGroupUtils.withEphemeralSubscriptionGroup(mContext, subId, (subGrp) -> {
                final Network vcnNetwork =
                        setupAndGetVcnNetwork(subGrp, cellNetwork, cellNetworkCb);

                mTestNetworkWrapper.close();
                mTestNetworkWrapper.vcnNetworkCallback.waitForLost();

                final TestNetworkWrapper secondaryTestNetworkWrapper =
                        new TestNetworkWrapper(
                                mContext,
                                TEST_NETWORK_MTU,
                                true /* isMetered */,
                                Collections.singleton(subId),
                                SECONDARY_LOCAL_ADDRESS);

                try {"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/vcn/src/android/net/vcn/cts/VcnManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.vcn.cts.VcnManagerTest"	"testVcnSafemodeOnTestNetwork"	"CtsVcnTestCases"	"1: INTERNET"	"([1:/android/net/vcn/cts/VcnManagerTest.java]:[INTERNET]:[1]:method_text:[     });        });        mConnectivityManager.unregisterNetworkCallback(cellNetworkCb);    }}]) :|: 
    public void testVcnSafemodeOnTestNetwork() throws Exception {
        final int subId = verifyAndGetValidDataSubId();

        mTestNetworkWrapper =
                new TestNetworkWrapper(
                        mContext,
                        TEST_NETWORK_MTU,
                        true /* isMetered */,
                        Collections.singleton(subId),
                        LOCAL_ADDRESS);
        assertNotNull(""No test network found"", mTestNetworkWrapper.tunNetwork);

        // Before the VCN starts, the test network should have NOT_VCN_MANAGED
        waitForExpectedUnderlyingNetworkWithCapabilities(
                true /* expectNotVcnManaged */,
                false /* expectNotMetered */,
                TestNetworkWrapper.NETWORK_CB_TIMEOUT_MS);

        // Get current cell Network then wait for it to drop (due to losing NOT_VCN_MANAGED) before
        // waiting for VCN Network.
        final NetworkRequest cellNetworkReq = new NetworkRequest.Builder()
                .addTransportType(TRANSPORT_CELLULAR)
                .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                .build();
        final VcnTestNetworkCallback cellNetworkCb = new VcnTestNetworkCallback();
        mConnectivityManager.requestNetwork(cellNetworkReq, cellNetworkCb);
        final Network cellNetwork = cellNetworkCb.waitForAvailable();
        assertNotNull(""No cell network found"", cellNetwork);

        CarrierPrivilegeUtils.withCarrierPrivilegesForShell(mContext, subId, () -> {
            SubscriptionGroupUtils.withEphemeralSubscriptionGroup(mContext, subId, (subGrp) -> {
                final Network vcnNetwork =
                        setupAndGetVcnNetwork(subGrp, cellNetwork, cellNetworkCb);

                // TODO(b/191801185): use VcnStatusCallbacks to verify safemode

                // Once VCN starts, the test network should lose NOT_VCN_MANAGED
                waitForExpectedUnderlyingNetworkWithCapabilities("	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/vcn/src/android/net/vcn/cts/VcnManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.vcn.cts.VcnManagerTest"	"VcnManagerTest"	"CtsVcnTestCases"	"1: permission"	"([3:/android/net/vcn/cts/VcnManagerTest.java]:[permission]:[3]:method_text:[           INVALID_SUBSCRIPTION_ID,                dataSubId);        return dataSubId;    }   ]) :|: /*
 *.
 */

package android.net.vcn.cts;

import static android.content.pm.PackageManager.FEATURE_TELEPHONY;
import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_METERED;
import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_VCN_MANAGED;
import static android.net.NetworkCapabilities.NET_CAPABILITY_VALIDATED;
import static android.net.NetworkCapabilities.TRANSPORT_CELLULAR;
import static android.telephony.SubscriptionManager.INVALID_SUBSCRIPTION_ID;

import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;

import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import android.annotation.NonNull;
import android.annotation.Nullable;
import android.content.Context;
import android.ipsec.ike.cts.IkeTunUtils;
import android.net.ConnectivityManager;
import android.net.InetAddresses;
import android.net.LinkProperties;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.vcn.VcnConfig;
import android.net.vcn.VcnManager;
import android.net.vcn.cts.TestNetworkWrapper.VcnTestNetworkCallback;
import android.net.vcn.cts.TestNetworkWrapper.VcnTestNetworkCallback.CapabilitiesChangedEvent;
import android.os.ParcelUuid;
import android.os.SystemClock;
import android.telephony.SubscriptionManager;
import android.telephony.TelephonyManager;
import android.telephony.cts.util.CarrierPrivilegeUtils;
import android.telephony.cts.util.SubscriptionGroupUtils;

import androidx.test.InstrumentationRegistry;
import androidx.test.ext.junit.runners.AndroidJUnit4;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
impo"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/vcn/src/android/net/vcn/cts/VcnManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.vcn.cts.VcnManagerTest"	"testAddVcnNetworkPolicyChangeListener_noNetworkFactoryPermission"	"CtsVcnTestCases"	"1: permission"	"([4:/android/net/vcn/cts/VcnManagerTest.java]:[permission]:[4]:method_text:[nally {            mVcnManager.removeVcnNetworkPolicyChangeListener(listener);        }    }   ]) :|: (expected = SecurityException.class)
    public void testAddVcnNetworkPolicyChangeListener_noNetworkFactoryPermission()
            throws Exception {
        // Drop shell permission identity to test unpermissioned behavior.
        getInstrumentation().getUiAutomation().dropShellPermissionIdentity();

        final TestVcnNetworkPolicyChangeListener listener =
                new TestVcnNetworkPolicyChangeListener();

        try {
            mVcnManager.addVcnNetworkPolicyChangeListener(INLINE_EXECUTOR, listener);
        } finally {
            mVcnManager.removeVcnNetworkPolicyChangeListener(listener);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/vcn/src/android/net/vcn/cts/VcnManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.vcn.cts.VcnManagerTest"	"testRemoveVcnNetworkPolicyChangeListener_noNetworkFactoryPermission"	"CtsVcnTestCases"	"1: permission"	"([1:/android/net/vcn/cts/VcnManagerTest.java]:[permission]:[1]:method_text:[icyChangeListener();        mVcnManager.removeVcnNetworkPolicyChangeListener(listener);    }   ]) :|: 
    public void testRemoveVcnNetworkPolicyChangeListener_noNetworkFactoryPermission() {
        final TestVcnNetworkPolicyChangeListener listener =
                new TestVcnNetworkPolicyChangeListener();

        mVcnManager.removeVcnNetworkPolicyChangeListener(listener);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/vcn/src/android/net/vcn/cts/VcnManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.vcn.cts.VcnManagerTest"	"testApplyVcnNetworkPolicy_noNetworkFactoryPermission"	"CtsVcnTestCases"	"1: permission"	"([4:/android/net/vcn/cts/VcnManagerTest.java]:[permission]:[4]:method_text:[Properties lp = new LinkProperties();        mVcnManager.applyVcnNetworkPolicy(nc, lp);    }   ]) :|: (expected = SecurityException.class)
    public void testApplyVcnNetworkPolicy_noNetworkFactoryPermission() throws Exception {
        // Drop shell permission identity to test unpermissioned behavior.
        getInstrumentation().getUiAutomation().dropShellPermissionIdentity();

        final NetworkCapabilities nc = new NetworkCapabilities.Builder().build();
        final LinkProperties lp = new LinkProperties();

        mVcnManager.applyVcnNetworkPolicy(nc, lp);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/vcn/src/android/net/vcn/cts/VcnManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.vcn.cts.VcnManagerTest"	"testApplyVcnNetworkPolicy_manageTestNetworkRequiresTransportTest"	"CtsVcnTestCases"	"1: permission"	"([2:/android/net/vcn/cts/VcnManagerTest.java]:[permission]:[2]:method_text:[registerVcnStatusCallback(subGrp, INLINE_EXECUTOR, callback);            });        });    }   ]) :|: 
    public void testApplyVcnNetworkPolicy_manageTestNetworkRequiresTransportTest()
            throws Exception {
        final NetworkCapabilities nc =
                new NetworkCapabilities.Builder().addTransportType(TRANSPORT_CELLULAR).build();
        final LinkProperties lp = new LinkProperties();

        runWithShellPermissionIdentity(
                () -> {
                    try {
                        mVcnManager.applyVcnNetworkPolicy(nc, lp);
                        fail(""Expected IllegalStateException for applyVcnNetworkPolicy"");
                    } catch (IllegalStateException e) {
                    }
                },
                android.Manifest.permission.MANAGE_TEST_NETWORKS);
    }

    /** Test implementation of VcnStatusCallback for verification purposes. */
    private static class TestVcnStatusCallback extends VcnManager.VcnStatusCallback {
        private final CompletableFuture<Integer> mFutureOnStatusChanged =
                new CompletableFuture<>();
        private final CompletableFuture<GatewayConnectionError> mFutureOnGatewayConnectionError =
                new CompletableFuture<>();

        @Override
        public void onStatusChanged(int statusCode) {
            mFutureOnStatusChanged.complete(statusCode);
        }

        @Override
        public void onGatewayConnectionError(
                @NonNull String gatewayConnectionName, int errorCode, @Nullable Throwable detail) {
            mFutureOnGatewayConnectionError.complete(
                    new GatewayConnectionError(gatewayConnectionName, errorCode, detail));
        }

        public int awaitOnStatusChanged() throws Exception {
            return mFutureOnStatusChanged.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
        }

        public GatewayConnectionError awaitOnGatewayConnectionError() throws Exception {
            return mFutureOnGatewayConnectionError.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
        }
    }

    /** Info class for organizing VcnSta"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/vcn/src/android/net/vcn/cts/VcnManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.sdk28.cts.CellInfoTest"	"isCamped"	"CtsTelephonySdk28TestCases"	"1: permission"	"([11:/android/telephony/sdk28/cts/CellInfoTest.java]:[permission]:[11]:method_text:[                      == android.content.pm.PackageManager.PERMISSION_GRANTED);        }    }   ]) :|: /*
 *.
 */

package android.telephony.sdk28.cts;

import static androidx.test.InstrumentationRegistry.getContext;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import android.content.Context;
import android.content.pm.PackageManager;
import android.telephony.AccessNetworkConstants;
import android.telephony.CellInfo;
import android.telephony.NetworkRegistrationInfo;
import android.telephony.ServiceState;
import android.telephony.TelephonyManager;
import android.util.Log;

import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.Before;
import org.junit.Test;

import java.util.List;

public class CellInfoTest {
    private static final String TAG = ""CellInfoTest"";

    private static final int MAX_WAIT_SECONDS = 15;
    private static final int POLL_INTERVAL_MILLIS = 1000;

    private static final String[] sPermissions = new String[] {
            android.Manifest.permission.READ_PHONE_STATE,
            android.Manifest.permission.ACCESS_COARSE_LOCATION};

    private TelephonyManager mTm;
    private PackageManager mPm;

    private boolean isCamped() {
        ServiceState ss = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTm, TelephonyManager::getServiceState);

        if (ss == null) return false;
        if (ss.getState() == ServiceState.STATE_EMERGENCY_ONLY) return true;
        List<NetworkRegistrationInfo> nris = ss.getNetworkRegistrationInfoList();
        for (NetworkRegistrationInfo nri : nris) {
            if (nri.getTransportType() != AccessNetworkConstants.TRANSPORT_TYPE_WWAN) continue;
            if (nri.isRegistered()) return true;
        }
        return false;
    }

    @Before
    public void setUp() throws Exception {
        mTm = (TelephonyManager) getContext().getSystemService(Context.TELEPHONY_SERVICE);
        mPm = getContext().getPackageManager();

        for ("	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/sdk28/src/android/telephony/sdk28/cts/CellInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.sdk28.cts.CellInfoTest"	"testCellInfoSdk28"	"CtsTelephonySdk28TestCases"	"1: permission"	"([2:/android/telephony/sdk28/cts/CellInfoTest.java]:[permission]:[2]:method_text:[        }        fail(""CellInfo failed to update after "" + MAX_WAIT_SECONDS + "" seconds."");    }}]) :|: 
    public void testCellInfoSdk28() {
        if (!mPm.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            Log.d(TAG, ""Skipping test that requires FEATURE_TELEPHONY"");
            return;
        }

        if (!isCamped()) fail(""Device is not camped to a cell"");

        List<CellInfo> cellInfo = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTm, TelephonyManager::getAllCellInfo);

        // getAllCellInfo should never return null, and there should be at least one entry.
        assertNotNull(""TelephonyManager.getAllCellInfo() returned NULL CellInfo"", cellInfo);
        assertFalse(""TelephonyManager.getAllCellInfo() returned an empty list"", cellInfo.isEmpty());

        final long initialTime = cellInfo.get(0).getTimeStamp();

        for(int i = 0; i < MAX_WAIT_SECONDS; i++) {
            try {
                Thread.sleep(POLL_INTERVAL_MILLIS); // 1 second
            } catch (InterruptedException ie) {
                fail(""Thread was interrupted"");
            }
            List<CellInfo> newCellInfo = ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTm, TelephonyManager::getAllCellInfo);
            assertNotNull(""TelephonyManager.getAllCellInfo() returned NULL CellInfo"", newCellInfo);
            assertFalse(""TelephonyManager.getAllCellInfo() returned an empty list"",
                    newCellInfo.isEmpty());
            // Test that new CellInfo has been retrieved from the modem
            if (newCellInfo.get(0).getTimeStamp() != initialTime) return;
        }
        fail(""CellInfo failed to update after "" + MAX_WAIT_SECONDS + "" seconds."");
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/sdk28/src/android/telephony/sdk28/cts/CellInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.preconditions.cleanerApp.TelephonyCleanerAppTest"	"testEnsureWifiEnabled"	""	"1: permission"	"([1:/android/telephony/cts/preconditions/cleanerApp/TelephonyCleanerAppTest.java]:[permission]:[1]:method_text:[ss);    runWithShellPermissionIdentity(() -> assertTrue(wifiManager.setWifiEnabled(true)));  }}]) :|: public void testEnsureWifiEnabled() throws Exception {
    if (!hasTelephony()) return;

    final WifiManager wifiManager = getContext().getSystemService(
      android.net.wifi.WifiManager.class);

    runWithShellPermissionIdentity(() -> assertTrue(wifiManager.setWifiEnabled(true)));
  }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/preconditions/cleanerApp/src/android/telephony/cts/preconditions/cleanerApp/TelephonyCleanerAppTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.preconditions.preparerApp.TelephonyPreparerAppTest"	"testEnsureWifiDisabled"	""	"1: permission"	"([1:/android/telephony/cts/preconditions/preparerApp/TelephonyPreparerAppTest.java]:[permission]:[1]:method_text:[        runWithShellPermissionIdentity(() -> assertTrue(wifiManager.setWifiEnabled(false)));    }}]) :|: public void testEnsureWifiDisabled() throws Exception {
        if (!hasTelephony()) return;

        final WifiManager wifiManager = getContext().getSystemService(
                android.net.wifi.WifiManager.class);

        runWithShellPermissionIdentity(() -> assertTrue(wifiManager.setWifiEnabled(false)));
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/preconditions/preparerApp/src/android/telephony/cts/preconditions/preparerApp/TelephonyPreparerAppTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.gba.cts.GbaServiceTest"	"testPermissions"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/gba/cts/GbaServiceTest.java]:[permission]:[2]:method_text:[SON_FEATURE_NOT_SUPPORTED,                android.Manifest.permission.READ_PHONE_STATE);    }   ]) :|:  (expected = SecurityException.class)
    public void testPermissions() {
        if (!isFeatureSupported()) {
            throw new SecurityException(""Feaure is not supported"");
        }

        runGbaFailCase(TelephonyManager.GBA_FAILURE_REASON_FEATURE_NOT_SUPPORTED,
                android.Manifest.permission.READ_PHONE_STATE);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/gba/cts/GbaServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.gba.cts.GbaServiceTest"	"testAuthSuccess"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/gba/cts/GbaServiceTest.java]:[permission]:[2]:method_text:[            assertTrue(isSuccess.get());            assertFalse(isFail.get());        }    }   ]) :|: 
    public void testAuthSuccess() {
        if (!isFeatureSupported()) {
            return;
        }

        Random rand = new Random();

        for (int i = 0; i < 20; i++) {
            Log.d(TAG, ""testAuthSuccess["" + i + ""]"");
            byte[] key = new byte[16];
            rand.nextBytes(key);
            sConfig.setConfig(true, key, BTID, TelephonyManager.GBA_FAILURE_REASON_UNKNOWN);
            final AtomicBoolean isSuccess = new AtomicBoolean(false);
            final AtomicBoolean isFail = new AtomicBoolean(false);
            TelephonyManager.BootstrapAuthenticationCallback cb = new
                      TelephonyManager.BootstrapAuthenticationCallback() {
                @Override
                public void onKeysAvailable(byte[] gbaKey, String btId) {
                    super.onKeysAvailable(gbaKey, btId);
                    assertNotNull(gbaKey);
                    assertNotNull(btId);
                    assertArrayEquals(key, gbaKey);
                    assertEquals(BTID, btId);
                    synchronized (isSuccess) {
                        isSuccess.set(true);
                        isSuccess.notify();
                    }
                }

                @Override
                public void onAuthenticationFailure(int reason) {
                    super.onAuthenticationFailure(reason);
                    synchronized (isSuccess) {
                        isFail.set(true);
                        isSuccess.notify();
                    }
                }
            };
            UaSecurityProtocolIdentifier.Builder builder =
                    new UaSecurityProtocolIdentifier.Builder();
            builder.setOrg(UaSecurityProtocolIdentifier.ORG_3GPP).setProtocol(
                    UaSecurityProtocolIdentifier.UA_SECURITY_PROTOCOL_3GPP_HTTP_BASED_MBMS);

            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(sTm,
                    (tm) -> tm.bootstrapAuthenticationRequest(TelephonyManager.APPTYPE_USI"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/gba/cts/GbaServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.gba.cts.GbaServiceTest"	"testGbaNotSupported"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/gba/cts/GbaServiceTest.java]:[permission]:[1]:method_text:[anifest.permission.MODIFY_PHONE_STATE);        assertTrue(setService(SERVICE_PACKAGE));    }   ]) :|: 
    public void testGbaNotSupported() throws Exception {
        if (!isFeatureSupported()) {
            return;
        }

        setService("""");
        sConfig.setConfig(true, new byte[16], BTID, TelephonyManager.GBA_FAILURE_REASON_UNKNOWN);

        runGbaFailCase(TelephonyManager.GBA_FAILURE_REASON_FEATURE_NOT_SUPPORTED,
                android.Manifest.permission.MODIFY_PHONE_STATE);

        assertTrue(setService(SERVICE_PACKAGE));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/gba/cts/GbaServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.gba.cts.GbaServiceTest"	"testAuthFail"	"CtsTelephonyTestCases"	"1: permission"	"([4:/android/telephony/gba/cts/GbaServiceTest.java]:[permission]:[4]:method_text:[l, REQ_TIMEOUT);        assertTrue(isFail.get());        assertFalse(isSuccess.get());    }   ]) :|: 
    public void testAuthFail() {
        if (!isFeatureSupported()) {
            return;
        }

        for (int r = TelephonyManager.GBA_FAILURE_REASON_UNKNOWN;
                r <= TelephonyManager.GBA_FAILURE_REASON_SECURITY_PROTOCOL_NOT_SUPPORTED; r++) {
            sConfig.setConfig(false, new byte[16], BTID, r);
            runGbaFailCase(r, android.Manifest.permission.MODIFY_PHONE_STATE);
        }
    }

    private void runGbaFailCase(int r, String permission) {
        final AtomicBoolean isSuccess = new AtomicBoolean(false);
        final AtomicBoolean isFail = new AtomicBoolean(false);
        TelephonyManager.BootstrapAuthenticationCallback cb = new
                  TelephonyManager.BootstrapAuthenticationCallback() {
            @Override
            public void onKeysAvailable(byte[] gbaKey, String btId) {
                synchronized (isFail) {
                    isSuccess.set(true);
                    isFail.notify();
                }
            }

            @Override
            public void onAuthenticationFailure(int reason) {
                assertEquals(reason, r);
                synchronized (isFail) {
                    isFail.set(true);
                    isFail.notify();
                }
            }
        };
        UaSecurityProtocolIdentifier.Builder builder = new UaSecurityProtocolIdentifier.Builder();
        builder.setOrg(UaSecurityProtocolIdentifier.ORG_3GPP).setProtocol(
                UaSecurityProtocolIdentifier.UA_SECURITY_PROTOCOL_3GPP_HTTP_BASED_MBMS);

        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(sTm,
                (tm) -> tm.bootstrapAuthenticationRequest(TelephonyManager.APPTYPE_USIM,
                Uri.parse(NAF), builder.build(), true, AsyncTask.SERIAL_EXECUTOR, cb), permission);
        waitForMs(isFail, REQ_TIMEOUT);

        assertTrue(isFail.get());
        assertFalse(isSuccess.get());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/gba/cts/GbaServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.gba.cts.GbaServiceTest"	"testServiceReleaseDefault"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/gba/cts/GbaServiceTest.java]:[permission]:[1]:method_text:[nfig, 500);        assertFalse(TestGbaConfig.STATE_BOUND == sConfig.getServiceState());    }   ]) :|: 
    public void testServiceReleaseDefault() throws Exception {
        if (!isFeatureSupported()) {
            return;
        }

        int ss = sConfig.getServiceState();
        boolean isExpected = (ss == TestGbaConfig.STATE_UNKNOWN
                || ss == TestGbaConfig.STATE_REMOVED
                || ss == TestGbaConfig.STATE_UNBOUND);
        assertTrue(isExpected);
        sConfig.setConfig(false, new byte[16], BTID,
                TelephonyManager.GBA_FAILURE_REASON_UNKNOWN);

        runGbaFailCase(TelephonyManager.GBA_FAILURE_REASON_UNKNOWN,
                android.Manifest.permission.MODIFY_PHONE_STATE);
        waitForMs(sConfig, 500);

        assertFalse(TestGbaConfig.STATE_BOUND == sConfig.getServiceState());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/gba/cts/GbaServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.gba.cts.GbaServiceTest"	"testServiceReleaseDuration"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/gba/cts/GbaServiceTest.java]:[permission]:[1]:method_text:[SE_TEST_MS);        assertFalse(TestGbaConfig.STATE_BOUND == sConfig.getServiceState());    }   ]) :|: 
    public void testServiceReleaseDuration() throws Exception {
        if (!isFeatureSupported()) {
            return;
        }

        int ss = sConfig.getServiceState();
        boolean isExpected = (ss == TestGbaConfig.STATE_UNKNOWN
                || ss == TestGbaConfig.STATE_REMOVED
                || ss == TestGbaConfig.STATE_UNBOUND);
        assertTrue(isExpected);
        sConfig.setConfig(false, new byte[16], BTID,
                TelephonyManager.GBA_FAILURE_REASON_UNKNOWN);
        assertTrue(setReleaseTime(RELEASE_TEST_MS));

        runGbaFailCase(TelephonyManager.GBA_FAILURE_REASON_UNKNOWN,
                android.Manifest.permission.MODIFY_PHONE_STATE);

        waitForMs(sConfig, 500);
        assertEquals(TestGbaConfig.STATE_BOUND, sConfig.getServiceState());

        waitForMs(sConfig, RELEASE_TEST_MS);
        assertFalse(TestGbaConfig.STATE_BOUND == sConfig.getServiceState());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/gba/cts/GbaServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.gba.cts.GbaServiceTest"	"testServiceNoRelease"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/gba/cts/GbaServiceTest.java]:[permission]:[2]:method_text:[) {            return false;        }        sSubId = activeSubs[0];        return true;    }}]) :|: 
    public void testServiceNoRelease() throws Exception {
        if (!isFeatureSupported()) {
            return;
        }

        int ss = sConfig.getServiceState();
        boolean isExpected = (ss == TestGbaConfig.STATE_UNKNOWN
                || ss == TestGbaConfig.STATE_REMOVED
                || ss == TestGbaConfig.STATE_UNBOUND);
        assertTrue(isExpected);
        sConfig.setConfig(false, new byte[16], BTID,
                TelephonyManager.GBA_FAILURE_REASON_UNKNOWN);
        assertTrue(setReleaseTime(RELEASE_NEVER));

        runGbaFailCase(TelephonyManager.GBA_FAILURE_REASON_UNKNOWN,
                android.Manifest.permission.MODIFY_PHONE_STATE);
        waitForMs(sConfig, 2 * RELEASE_TEST_MS);

        assertEquals(TestGbaConfig.STATE_BOUND, sConfig.getServiceState());
    }

    public static void waitForMs(Object obj, long ms) {
        synchronized (obj) {
            try {
                obj.wait(ms);
            } catch (InterruptedException e) {
                Log.d(TAG, ""InterruptedException while waiting: "" + e);
            }
        }
    }

    private static boolean setService(String packageName) throws Exception {
        String result = TelephonyUtils.executeShellCommand(sInstrumentation,
                COMMAND_UPDATE_PACKAGE + packageName);
        return ""true"".equals(result);
    }

    private static boolean setReleaseTime(int interval) throws Exception {
        String result = TelephonyUtils.executeShellCommand(sInstrumentation,
                COMMAND_UPDATE_RELEASE + interval);
        return ""true"".equals(result);
    }

    private static boolean isFeatureSupported() {
        if (!InstrumentationRegistry.getContext().getPackageManager().hasSystemFeature(
                PackageManager.FEATURE_TELEPHONY)) {
            return false;
        }

        SubscriptionManager subscriptionManager = InstrumentationRegistry.getContext()
                .getSystemService(SubscriptionManager.class);
        int[] activeSubs = Sh"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/gba/cts/GbaServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.PhoneStateListenerTest"	"testOnSignalStrengthsChanged"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/PhoneStateListenerTest.java]:[permission]:[1]:method_text:[EPORTED_SIGNAL_STRENGTH without LISTEN_ALWAYS_REPORTED_SIGNAL_STRENGTH     * permission.     *   ]) :|: 
    public void testOnSignalStrengthsChanged() throws Throwable {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }
        assertTrue(mSignalStrength == null);

        mHandler.post(() -> {
            mListener = new PhoneStateListener() {
                @Override
                public void onSignalStrengthsChanged(SignalStrength signalStrength) {
                    synchronized (mLock) {
                        mSignalStrength = signalStrength;
                        mLock.notify();
                    }
                }
            };
            mTelephonyManager.listen(mListener, PhoneStateListener.LISTEN_SIGNAL_STRENGTHS);
        });
        synchronized (mLock) {
            if (mSignalStrength == null) {
                mLock.wait(WAIT_TIME);
            }
        }

        assertTrue(mSignalStrength != null);
        // Call SignalStrength methods to make sure they do not throw any exceptions
        mSignalStrength.getCdmaDbm();
        mSignalStrength.getCdmaEcio();
        mSignalStrength.getEvdoDbm();
        mSignalStrength.getEvdoEcio();
        mSignalStrength.getEvdoSnr();
        mSignalStrength.getGsmBitErrorRate();
        mSignalStrength.getGsmSignalStrength();
        mSignalStrength.isGsm();
        mSignalStrength.getLevel();
    }

    /**
     * Due to the corresponding API is hidden in R and will be public in S, this test
     * is commented and will be un-commented in Android S.
     *
     * Validate that SecurityException should be thrown when listen
     * with LISTEN_ALWAYS_REPORTED_SIGNAL_STRENGTH without LISTEN_ALWAYS_REPORTED_SIGNAL_STRENGTH
     * permission.
     *"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/PhoneStateListenerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.PhoneStateListenerTest"	"testOnAlwaysReportedSignalStrengthChangedWithoutPermission"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/PhoneStateListenerTest.java]:[permission]:[1]:method_text:[(mSecurityExceptionThrown).isTrue();        assertTrue(mSignalStrength == null);    }     */   ]) :|: 
    public void testOnAlwaysReportedSignalStrengthChangedWithoutPermission() throws Throwable {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }

        assertTrue(mSignalStrength == null);

        mHandler.post(() -> {
            mListener = new PhoneStateListener() {
                @Override
                public void onSignalStrengthsChanged(SignalStrength signalStrength) {
                    synchronized (mLock) {
                        mSignalStrength = signalStrength;
                        mLock.notify();
                    }
                }
            };
            try {
                mTelephonyManager.listen(mListener,
                        PhoneStateListener.LISTEN_ALWAYS_REPORTED_SIGNAL_STRENGTH);
            } catch (SecurityException se) {
                synchronized (mLock) {
                    mSecurityExceptionThrown = true;
                    mLock.notify();
                }
            }
        });
        synchronized (mLock) {
            if (!mSecurityExceptionThrown) {
                mLock.wait(WAIT_TIME);
            }
        }

        assertThat(mSecurityExceptionThrown).isTrue();
        assertTrue(mSignalStrength == null);
    }
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/PhoneStateListenerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.PhoneStateListenerTest"	"testOnPreciseCallStateChanged"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/PhoneStateListenerTest.java]:[permission]:[1]:method_text:[E);        assertThat(mPreciseCallState.getRingingCallState()).isIn(PRECISE_CALL_STATE);    }   ]) :|: 
    public void testOnPreciseCallStateChanged() throws Throwable {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }
        assertThat(mOnPreciseCallStateChangedCalled).isFalse();

        mHandler.post(() -> {
            mListener = new PhoneStateListener() {
                @Override
                public void onPreciseCallStateChanged(PreciseCallState preciseCallState) {
                    synchronized (mLock) {
                        mOnPreciseCallStateChangedCalled = true;
                        mPreciseCallState = preciseCallState;
                        mLock.notify();
                    }
                }
            };
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    (tm) -> tm.listen(mListener, PhoneStateListener.LISTEN_PRECISE_CALL_STATE));
        });
        synchronized (mLock) {
            if (!mOnPreciseCallStateChangedCalled) {
                mLock.wait(WAIT_TIME);
            }
        }
        Log.d(TAG, ""testOnPreciseCallStateChanged: "" + mOnPreciseCallStateChangedCalled);

        assertThat(mOnPreciseCallStateChangedCalled).isTrue();
        assertThat(mPreciseCallState.getForegroundCallState()).isIn(PRECISE_CALL_STATE);
        assertThat(mPreciseCallState.getBackgroundCallState()).isIn(PRECISE_CALL_STATE);
        assertThat(mPreciseCallState.getRingingCallState()).isIn(PRECISE_CALL_STATE);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/PhoneStateListenerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.PhoneStateListenerTest"	"testOnCallDisconnectCauseChanged"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/PhoneStateListenerTest.java]:[permission]:[1]:method_text:[           }        }        assertThat(mOnCallDisconnectCauseChangedCalled).isTrue();    }   ]) :|: 
    public void testOnCallDisconnectCauseChanged() throws Throwable {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }
        assertThat(mOnCallDisconnectCauseChangedCalled).isFalse();

        mHandler.post(() -> {
            mListener = new PhoneStateListener() {
                @Override
                public void onCallDisconnectCauseChanged(int disconnectCause,
                        int preciseDisconnectCause) {
                    synchronized (mLock) {
                        mOnCallDisconnectCauseChangedCalled = true;
                        mLock.notify();
                    }
                }
            };
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    (tm) -> tm.listen(mListener,
                            PhoneStateListener.LISTEN_CALL_DISCONNECT_CAUSES));
        });
        synchronized (mLock) {
            if (!mOnCallDisconnectCauseChangedCalled) {
                mLock.wait(WAIT_TIME);
            }
        }

        assertThat(mOnCallDisconnectCauseChangedCalled).isTrue();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/PhoneStateListenerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.PhoneStateListenerTest"	"testOnImsCallDisconnectCauseChanged"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/PhoneStateListenerTest.java]:[permission]:[1]:method_text:[        }        }        assertThat(mOnImsCallDisconnectCauseChangedCalled).isTrue();    }   ]) :|: 
    public void testOnImsCallDisconnectCauseChanged() throws Throwable {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }
        assertThat(mOnImsCallDisconnectCauseChangedCalled).isFalse();

        mHandler.post(() -> {
            mListener = new PhoneStateListener() {
                @Override
                public void onImsCallDisconnectCauseChanged(ImsReasonInfo imsReason) {
                    synchronized (mLock) {
                        mOnImsCallDisconnectCauseChangedCalled = true;
                        mLock.notify();
                    }
                }
            };
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    (tm) -> tm.listen(mListener,
                            PhoneStateListener.LISTEN_IMS_CALL_DISCONNECT_CAUSES));
        });
        synchronized (mLock) {
            if (!mOnImsCallDisconnectCauseChangedCalled) {
                mLock.wait(WAIT_TIME);
            }
        }

        assertThat(mOnImsCallDisconnectCauseChangedCalled).isTrue();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/PhoneStateListenerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.PhoneStateListenerTest"	"testOnPhoneStateListenerExecutorWithSrvccChanged"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/PhoneStateListenerTest.java]:[permission]:[1]:method_text:[stenerExecutorWithSrvccChanged"");        assertThat(mSrvccStateChangedCalled).isTrue();    }   ]) :|: 
    public void testOnPhoneStateListenerExecutorWithSrvccChanged() throws Throwable {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }
        assertThat(mSrvccStateChangedCalled).isFalse();

        mHandler.post(() -> {
            mListener = new PhoneStateListener(mSimpleExecutor) {
                @Override
                public void onSrvccStateChanged(int state) {
                    synchronized (mLock) {
                        mSrvccStateChangedCalled = true;
                        mLock.notify();
                    }
                }
            };
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    (tm) -> tm.listen(mListener,
                            PhoneStateListener.LISTEN_SRVCC_STATE_CHANGED));
        });
        synchronized (mLock) {
            if (!mSrvccStateChangedCalled) {
                mLock.wait(WAIT_TIME);
            }
        }
        Log.d(TAG, ""testOnPhoneStateListenerExecutorWithSrvccChanged"");

        assertThat(mSrvccStateChangedCalled).isTrue();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/PhoneStateListenerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.PhoneStateListenerTest"	"testOnRadioPowerStateChanged"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/PhoneStateListenerTest.java]:[permission]:[1]:method_text:[        assertThat(mTelephonyManager.getRadioPowerState()).isEqualTo(mRadioPowerState);    }   ]) :|: 
    public void testOnRadioPowerStateChanged() throws Throwable {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }
        assertThat(mOnRadioPowerStateChangedCalled).isFalse();

        mHandler.post(() -> {
            mListener = new PhoneStateListener() {
                @Override
                public void onRadioPowerStateChanged(int state) {
                    synchronized (mLock) {
                        mRadioPowerState = state;
                        mOnRadioPowerStateChangedCalled = true;
                        mLock.notify();
                    }
                }
            };
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    (tm) -> tm.listen(mListener,
                            PhoneStateListener.LISTEN_RADIO_POWER_STATE_CHANGED));
        });
        synchronized (mLock) {
            if (!mOnRadioPowerStateChangedCalled) {
                mLock.wait(WAIT_TIME);
            }
        }
        Log.d(TAG, ""testOnRadioPowerStateChanged: "" + mRadioPowerState);

        assertThat(mTelephonyManager.getRadioPowerState()).isEqualTo(mRadioPowerState);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/PhoneStateListenerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.PhoneStateListenerTest"	"testOnVoiceActivationStateChanged"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/cts/PhoneStateListenerTest.java]:[permission]:[2]:method_text:[m) -> tm.getVoiceActivationState());        assertEquals(state, mVoiceActivationState);    }   ]) :|: 
    public void testOnVoiceActivationStateChanged() throws Throwable {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }
        assertThat(mVoiceActivationStateChangedCalled).isFalse();

        mHandler.post(() -> {
            mListener = new PhoneStateListener() {
                @Override
                public void onVoiceActivationStateChanged(int state) {
                    synchronized (mLock) {
                        mVoiceActivationState = state;
                        mVoiceActivationStateChangedCalled = true;
                        mLock.notify();
                    }
                }
            };
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    (tm) -> tm.listen(mListener,
                            PhoneStateListener.LISTEN_VOICE_ACTIVATION_STATE));
        });
        synchronized (mLock) {
            if (!mVoiceActivationStateChangedCalled) {
                mLock.wait(WAIT_TIME);
            }
        }
        Log.d(TAG, ""onVoiceActivationStateChanged: "" + mVoiceActivationState);
        int state = ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                (tm) -> tm.getVoiceActivationState());

        assertEquals(state, mVoiceActivationState);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/PhoneStateListenerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.PhoneStateListenerTest"	"testOnPreciseDataConnectionStateChanged"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/PhoneStateListenerTest.java]:[permission]:[1]:method_text:[taConnectionApnTypeBitMask();        mPreciseDataConnectionState.getDataConnectionApn();    }   ]) :|: 
    public void testOnPreciseDataConnectionStateChanged() throws Throwable {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }
        assertThat(mOnCallDisconnectCauseChangedCalled).isFalse();

        mHandler.post(() -> {
            mListener = new PhoneStateListener() {
                @Override
                public void onPreciseDataConnectionStateChanged(
                        PreciseDataConnectionState state) {
                    synchronized (mLock) {
                        mOnPreciseDataConnectionStateChanged = true;
                        mPreciseDataConnectionState = state;
                        mLock.notify();
                    }
                }
            };
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    (tm) -> tm.listen(mListener,
                            PhoneStateListener.LISTEN_PRECISE_DATA_CONNECTION_STATE));
        });
        synchronized (mLock) {
            if (!mOnPreciseDataConnectionStateChanged) {
                mLock.wait(WAIT_TIME);
            }
        }

        assertThat(mOnPreciseDataConnectionStateChanged).isTrue();
        assertThat(mPreciseDataConnectionState.getState())
                .isIn(DATA_CONNECTION_STATE);

        // Ensure that no exceptions are thrown
        mPreciseDataConnectionState.getNetworkType();
        mPreciseDataConnectionState.getLinkProperties();
        mPreciseDataConnectionState.getLastCauseCode();
        mPreciseDataConnectionState.getLinkProperties();
        mPreciseDataConnectionState.getApnSetting();
        mPreciseDataConnectionState.getTransportType();
        mPreciseDataConnectionState.getId();

        // Deprecated in R
        assertEquals(mPreciseDataConnectionState.getDataConnectionState(),
                mPreciseDataConnectionState.getState());
        asse"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/PhoneStateListenerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.PhoneStateListenerTest"	"testOnDisplayInfoChanged"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/PhoneStateListenerTest.java]:[permission]:[1]:method_text:[t(WAIT_TIME);            }        }        assertTrue(mOnTelephonyDisplayInfoChanged);    }   ]) :|: 
    public void testOnDisplayInfoChanged() throws Exception {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }
        assertThat(mOnTelephonyDisplayInfoChanged).isFalse();

        mHandler.post(() -> {
            mListener = new PhoneStateListener() {
                @Override
                public void onDisplayInfoChanged(TelephonyDisplayInfo displayInfo) {
                    synchronized (mLock) {
                        mOnTelephonyDisplayInfoChanged = true;
                        mLock.notify();
                    }
                }
            };
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    (tm) -> tm.listen(mListener,
                            PhoneStateListener.LISTEN_DISPLAY_INFO_CHANGED));
        });

        synchronized (mLock) {
            if (!mOnTelephonyDisplayInfoChanged) {
                mLock.wait(WAIT_TIME);
            }
        }
        assertTrue(mOnTelephonyDisplayInfoChanged);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/PhoneStateListenerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.PhoneStateListenerTest"	"testOnCellLocationChanged"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/PhoneStateListenerTest.java]:[permission]:[1]:method_text:[it(WAIT_TIME);            }        }        assertTrue(mOnCellLocationChangedCalled);    }   ]) :|: 
    public void testOnCellLocationChanged() throws Throwable {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }
        assertFalse(mOnCellLocationChangedCalled);

        TelephonyManagerTest.grantLocationPermissions();
        mHandler.post(() -> {
            mListener = new PhoneStateListener() {
                @Override
                public void onCellLocationChanged(CellLocation location) {
                    synchronized (mLock) {
                        mOnCellLocationChangedCalled = true;
                        mLock.notify();
                    }
                }
            };
            mTelephonyManager.listen(mListener, PhoneStateListener.LISTEN_CELL_LOCATION);
        });
        synchronized (mLock) {
            if (!mOnCellLocationChangedCalled) {
                mLock.wait(WAIT_TIME);
            }
        }

        assertTrue(mOnCellLocationChangedCalled);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/PhoneStateListenerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.PhoneStateListenerTest"	"testOnCellInfoChanged"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/PhoneStateListenerTest.java]:[permission]:[1]:method_text:[k.wait(WAIT_TIME);            }        }        assertTrue(mOnCellInfoChangedCalled);    }   ]) :|: 
    public void testOnCellInfoChanged() throws Throwable {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }
        assertFalse(mOnDataActivityCalled);

        TelephonyManagerTest.grantLocationPermissions();
        mHandler.post(() -> {
            mListener = new PhoneStateListener() {
                @Override
                public void onCellInfoChanged(List<CellInfo> cellInfo) {
                    synchronized (mLock) {
                        mOnCellInfoChangedCalled = true;
                        mLock.notify();
                    }
                }
            };
            mTelephonyManager.listen(mListener, PhoneStateListener.LISTEN_CELL_INFO);
        });
        synchronized (mLock) {
            if (!mOnCellInfoChangedCalled) {
                mLock.wait(WAIT_TIME);
            }
        }

        assertTrue(mOnCellInfoChangedCalled);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/PhoneStateListenerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.PhoneStateListenerTest"	"testOnOutgoingSmsEmergencyNumberChanged"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/PhoneStateListenerTest.java]:[permission]:[1]:method_text:[        TelephonyUtils.endBlockSuppression(InstrumentationRegistry.getInstrumentation());    }   ]) :|: 
    public void testOnOutgoingSmsEmergencyNumberChanged() throws Throwable {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }

        TelephonyUtils.addTestEmergencyNumber(
                InstrumentationRegistry.getInstrumentation(), TEST_EMERGENCY_NUMBER);

        LinkedBlockingQueue<Pair<EmergencyNumber, Integer>> smsCallbackQueue =
                new LinkedBlockingQueue<>(1);

        mHandler.post(() -> {
            mListener = new PhoneStateListener() {
                @Override
                public void onOutgoingEmergencySms(EmergencyNumber emergencyNumber,
                                                   int subscriptionId) {
                    synchronized (mLock) {
                        Log.i(TAG, ""onOutgoingEmergencySms: emergencyNumber="" + emergencyNumber);
                        smsCallbackQueue.offer(Pair.create(emergencyNumber, subscriptionId));
                    }
                }
            };
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    (tm) -> tm.listen(mListener,
                            PhoneStateListener.LISTEN_OUTGOING_EMERGENCY_SMS));
            SmsManager.getDefault().sendTextMessage(
                    TEST_EMERGENCY_NUMBER, null, ""testOutgoingSmsListenerCts"", null, null);
        });

        try {
            Pair<EmergencyNumber, Integer> emergencySmsInfo =
                    smsCallbackQueue.poll(WAIT_TIME, TimeUnit.MILLISECONDS);
            assertNotNull(""Never got emergency sms callback"", emergencySmsInfo);
            assertEquals(TEST_EMERGENCY_NUMBER, emergencySmsInfo.first.getNumber());
            assertEquals(SubscriptionManager.getDefaultSmsSubscriptionId(),
                    emergencySmsInfo.second.intValue());
        } catch (InterruptedException e) {
            Log.e(TAG, ""Operation interrup"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/PhoneStateListenerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.PhoneStateListenerTest"	"testOnBarringInfoChanged"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/PhoneStateListenerTest.java]:[permission]:[1]:method_text:[   // be not barred.        assertNotEquals(hasBarringTypeUnknown, hasBarringTypeKnown);    }   ]) :|: 
    public void testOnBarringInfoChanged() throws Throwable {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }

        assertFalse(mOnBarringInfoChangedCalled);
        mHandler.post(() -> {
            mListener = new PhoneStateListener() {
                @Override
                public void onBarringInfoChanged(BarringInfo barringInfo) {
                    synchronized (mLock) {
                        mOnBarringInfoChangedCalled = true;
                        mBarringInfo = barringInfo;
                        mLock.notify();
                    }
                }
            };
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    (tm) -> tm.listen(mListener, PhoneStateListener.LISTEN_BARRING_INFO));
        });

        synchronized (mLock) {
            if (!mOnBarringInfoChangedCalled) {
                mLock.wait(WAIT_TIME);
            }
        }
        assertTrue(mOnBarringInfoChangedCalled);

        assertBarringInfoSane(mBarringInfo);
    }

    private static final int[] sBarringServiceInfoTypes = new int[]{
            BarringInfo.BARRING_SERVICE_TYPE_CS_SERVICE,
            BarringInfo.BARRING_SERVICE_TYPE_PS_SERVICE,
            BarringInfo.BARRING_SERVICE_TYPE_CS_VOICE,
            BarringInfo.BARRING_SERVICE_TYPE_MO_SIGNALLING,
            BarringInfo.BARRING_SERVICE_TYPE_MO_DATA,
            BarringInfo.BARRING_SERVICE_TYPE_CS_FALLBACK,
            BarringInfo.BARRING_SERVICE_TYPE_MMTEL_VOICE,
            BarringInfo.BARRING_SERVICE_TYPE_MMTEL_VIDEO,
            BarringInfo.BARRING_SERVICE_TYPE_EMERGENCY,
            BarringInfo.BARRING_SERVICE_TYPE_SMS
    };

    private static void assertBarringInfoSane(BarringInfo barringInfo) {
        assertNotNull(barringInfo);

        // Flags to track whether we have had unknown and known barring t"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/PhoneStateListenerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.PhoneStateListenerTest"	"testOnRegistrationFailed"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/PhoneStateListenerTest.java]:[permission]:[1]:method_text:[ this one is not called upon registration.        assertFalse(mOnRegistrationFailedCalled);    }}]) :|: 
    public void testOnRegistrationFailed() throws Throwable {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }

        assertFalse(mOnBarringInfoChangedCalled);
        mHandler.post(() -> {
            mListener = new PhoneStateListener() {
                @Override
                public void onRegistrationFailed(CellIdentity cid, String chosenPlmn,
                                                 int domain, int causeCode,
                                                 int additionalCauseCode) {
                    synchronized (mLock) {
                        mOnRegistrationFailedCalled = true;
                        mLock.notify();
                    }
                }
            };
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    (tm) -> tm.listen(mListener,
                            PhoneStateListener.LISTEN_REGISTRATION_FAILURE));
        });

        synchronized (mLock) {
            if (!mOnBarringInfoChangedCalled) {
                mLock.wait(WAIT_TIME);
            }
        }

        // Assert that in the WAIT_TIME interval, the listener wasn't invoked. While this is
        // **technically** a flaky test, in practice this flake should happen approximately never
        // as it would mean that a registered phone is failing to reselect during CTS at this
        // exact moment.
        //
        // What the test is verifying is that there is no ""auto"" callback for registration
        // failure because unlike other PSL registrants, this one is not called upon registration.
        assertFalse(mOnRegistrationFailedCalled);
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/PhoneStateListenerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.SmsManagerTest"	"testSendAndReceiveMessages"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/SmsManagerTest.java]:[permission]:[1]:method_text:[ssageId= */ true);        sendAndReceiveMultipartSms(mccmnc, /* addMessageId= */ false);    }   ]) :|: (timeout = 10 * 60 * 1000)
    public void testSendAndReceiveMessages() throws Exception {
        assertFalse(""[RERUN] SIM card does not provide phone number. Use a suitable SIM Card."",
                TextUtils.isEmpty(mDestAddr));

        String mccmnc = mTelephonyManager.getSimOperator();

        // send/receive single text sms with and without messageId
        sendAndReceiveSms(/* addMessageId= */ true);
        sendAndReceiveSms(/* addMessageId= */ false);

        // due to permission restrictions, currently there is no way to make this test app the
        // default SMS app

        if (mTelephonyManager.getPhoneType() == TelephonyManager.PHONE_TYPE_CDMA) {
            // TODO: temp workaround, OCTET encoding for EMS not properly supported
            return;
        }

        // send/receive data sms
        sendDataSms(mccmnc);

        // send/receive multi part text sms with and without messageId
        sendAndReceiveMultipartSms(mccmnc, /* addMessageId= */ true);
        sendAndReceiveMultipartSms(mccmnc, /* addMessageId= */ false);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SmsManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.SmsManagerTest"	"testGetSmsMessagesForFinancialAppPermissionRequestedNotGranted"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/SmsManagerTest.java]:[permission]:[1]:method_text:[startsWith(FINANCIAL_SMS_APP));        assertThat(bundle.getInt(""rowNum""), equalTo(-1));    }   ]) :|: 
    public void testGetSmsMessagesForFinancialAppPermissionRequestedNotGranted() throws Exception {
        CompletableFuture<Bundle> callbackResult = new CompletableFuture<>();

        mContext.startActivity(new Intent()
                .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                .setComponent(new ComponentName(FINANCIAL_SMS_APP, FINANCIAL_SMS_APP + "".MainActivity""))
                .putExtra(""callback"", new RemoteCallback(callbackResult::complete)));

        Bundle bundle = callbackResult.get(500, TimeUnit.SECONDS);

        assertThat(bundle.getString(""class""), startsWith(FINANCIAL_SMS_APP));
        assertThat(bundle.getInt(""rowNum""), equalTo(-1));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SmsManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.SmsManagerTest"	"testGetSmsMessagesForFinancialAppPermissionRequestedGranted"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/cts/SmsManagerTest.java]:[permission]:[2]:method_text:[startsWith(FINANCIAL_SMS_APP));        assertThat(bundle.getInt(""rowNum""), equalTo(-1));    }   ]) :|: 
    public void testGetSmsMessagesForFinancialAppPermissionRequestedGranted() throws Exception {
        CompletableFuture<Bundle> callbackResult = new CompletableFuture<>();
        String ctsPackageName = getInstrumentation().getContext().getPackageName();

        executeWithShellPermissionIdentity(() -> {
            setModeForOps(FINANCIAL_SMS_APP,
                    AppOpsManager.MODE_ALLOWED,
                    AppOpsManager.OPSTR_SMS_FINANCIAL_TRANSACTIONS);
            });
        mContext.startActivity(new Intent()
                .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                .setComponent(new ComponentName(FINANCIAL_SMS_APP, FINANCIAL_SMS_APP + "".MainActivity""))
                .putExtra(""callback"", new RemoteCallback(callbackResult::complete)));


        Bundle bundle = callbackResult.get(500, TimeUnit.SECONDS);

        assertThat(bundle.getString(""class""), startsWith(FINANCIAL_SMS_APP));
        assertThat(bundle.getInt(""rowNum""), equalTo(-1));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SmsManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.SmsManagerTest"	"testSmsNotPersisted_failsWithoutCarrierPermissions"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/SmsManagerTest.java]:[permission]:[1]:method_text:[er privileges"");        } catch (SecurityException e) {            // Success        }    }   ]) :|: 
    public void testSmsNotPersisted_failsWithoutCarrierPermissions() throws Exception {
        assertFalse(""[RERUN] SIM card does not provide phone number. Use a suitable SIM Card."",
                TextUtils.isEmpty(mDestAddr));

        try {
            getSmsManager().sendTextMessageWithoutPersisting(mDestAddr, null /*scAddress */,
                    mDestAddr, mSentIntent, mDeliveredIntent);
            fail(""We should get a SecurityException due to not having carrier privileges"");
        } catch (SecurityException e) {
            // Success
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SmsManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.SmsManagerTest"	"testContentProviderAccessRestriction"	"CtsTelephonyTestCases"	"1: permission"	"([13:/android/telephony/cts/SmsManagerTest.java]:[permission]:[13]:method_text:[ mSentIntent, mDeliveredIntent);            return true;        }        return false;    }   ]) :|: 
    public void testContentProviderAccessRestriction() throws Exception {
        Uri dummySmsUri = null;
        Context context = getInstrumentation().getContext();
        ContentResolver contentResolver = context.getContentResolver();
        int originalWriteSmsMode = -1;
        String ctsPackageName = context.getPackageName();
        try {
            // Insert some test sms
            originalWriteSmsMode = context.getSystemService(AppOpsManager.class)
                    .unsafeCheckOpNoThrow(AppOpsManager.OPSTR_WRITE_SMS,
                            getPackageUid(ctsPackageName), ctsPackageName);
            setModeForOps(ctsPackageName,
                    AppOpsManager.MODE_ALLOWED, AppOpsManager.OPSTR_WRITE_SMS);
            ContentValues contentValues = new ContentValues();
            contentValues.put(Telephony.TextBasedSmsColumns.ADDRESS, ""addr"");
            contentValues.put(Telephony.TextBasedSmsColumns.READ, 1);
            contentValues.put(Telephony.TextBasedSmsColumns.SUBJECT, ""subj"");
            contentValues.put(Telephony.TextBasedSmsColumns.BODY, ""created_at_""
                    + new Date().toString().replace("" "", ""_""));

            dummySmsUri = contentResolver.insert(Telephony.Sms.CONTENT_URI, contentValues);
            assertNotNull(""Failed to insert test sms"", dummySmsUri);
            assertNotEquals(""Failed to insert test sms"", ""0"", dummySmsUri.getLastPathSegment());
            testSmsAccessAboutDefaultApp(LEGACY_SMS_APP);
            testSmsAccessAboutDefaultApp(MODERN_SMS_APP);
        } finally {
            if (dummySmsUri != null && !""/0"".equals(dummySmsUri.getLastPathSegment())) {
                final Uri finalDummySmsUri = dummySmsUri;
                executeWithShellPermissionIdentity(() -> contentResolver.delete(finalDummySmsUri,
                        null, null));
            }
            if (originalWriteSmsMode >= 0) {
                int finalOriginalWriteSmsMode = originalWriteSmsMode;
                execu"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SmsManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.SmsManagerTest"	"testGetSetSmscAddress"	"CtsTelephonyTestCases"	"1: permission"	"([6:/android/telephony/cts/SmsManagerTest.java]:[permission]:[6]:method_text:[ntation().getUiAutomation()                    .dropShellPermissionIdentity();        }    }   ]) :|: 
    public void testGetSetSmscAddress() {
        String smsc = null;
        try {
            smsc = getSmsManager().getSmscAddress();
            fail(""SmsManager.getSmscAddress() should throw a SecurityException"");
        } catch (SecurityException e) {
            // expected
        }

        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(""android.permission.READ_PRIVILEGED_PHONE_STATE"");
        try {
            smsc = getSmsManager().getSmscAddress();
        } catch (SecurityException se) {
            fail(""Caller with READ_PRIVILEGED_PHONE_STATE should be able to call API"");
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                    .dropShellPermissionIdentity();
        }

        try {
            getSmsManager().setSmscAddress(smsc);
            fail(""SmsManager.setSmscAddress() should throw a SecurityException"");
        } catch (SecurityException e) {
            // expected
        }

        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(""android.permission.MODIFY_PHONE_STATE"");
        try {
            getSmsManager().setSmscAddress(smsc);
        } catch (SecurityException se) {
            fail(""Caller with MODIFY_PHONE_STATE should be able to call API"");
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                    .dropShellPermissionIdentity();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SmsManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.SmsManagerTest"	"testGetPremiumSmsConsent"	"CtsTelephonyTestCases"	"1: permission"	"([4:/android/telephony/cts/SmsManagerTest.java]:[permission]:[4]:method_text:[ntation().getUiAutomation()                    .dropShellPermissionIdentity();        }    }   ]) :|: 
    public void testGetPremiumSmsConsent() {
        try {
            getSmsManager().getPremiumSmsConsent(""fake package name"");
            fail(""SmsManager.getPremiumSmsConsent() should throw a SecurityException"");
        } catch (SecurityException e) {
            // expected
        }

        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(""android.permission.READ_PRIVILEGED_PHONE_STATE"");
        try {
            getSmsManager().getPremiumSmsConsent(""fake package name"");
            fail(""Caller with permission but only phone/system uid is allowed"");
        } catch (SecurityException se) {
            // expected
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                    .dropShellPermissionIdentity();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SmsManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.SmsManagerTest"	"testSetPremiumSmsConsent"	"CtsTelephonyTestCases"	"1: permission"	"([7:/android/telephony/cts/SmsManagerTest.java]:[permission]:[7]:method_text:[     * Requires Permission:     * {@link android.Manifest.permission#READ_PHONE_STATE}.     */   ]) :|: 
    public void testSetPremiumSmsConsent() {
        try {
            getSmsManager().setPremiumSmsConsent(""fake package name"", 0);
            fail(""SmsManager.setPremiumSmsConsent() should throw a SecurityException"");
        } catch (SecurityException e) {
            // expected
        }

        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(""android.permission.MODIFY_PHONE_STATE"");
        try {
            getSmsManager().setPremiumSmsConsent(""fake package name"", 0);
            fail(""Caller with permission but only phone/system uid is allowed"");
        } catch (SecurityException se) {
            // expected
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                    .dropShellPermissionIdentity();
        }
    }

    /**
     * Verify that SmsManager.getSmsCapacityOnIcc requires Permission.
     * <p>
     * Requires Permission:
     * {@link android.Manifest.permission#READ_PHONE_STATE}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SmsManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.SmsManagerTest"	"testDisableCellBroadcastRange"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/SmsManagerTest.java]:[permission]:[1]:method_text:[nType);            });        } catch (Exception e) {            // expected        }    }   ]) :|: 
    public void testDisableCellBroadcastRange() {
        try {
            int ranType = SmsCbMessage.MESSAGE_FORMAT_3GPP;
            executeWithShellPermissionIdentity(() -> {
                getSmsManager().disableCellBroadcastRange(
                        CdmaSmsCbProgramData.CATEGORY_CMAS_PRESIDENTIAL_LEVEL_ALERT,
                        CdmaSmsCbProgramData.CATEGORY_CMAS_EXTREME_THREAT,
                        ranType);
            });
        } catch (Exception e) {
            // expected
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SmsManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.SmsManagerTest"	"testEnableCellBroadcastRange"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/SmsManagerTest.java]:[permission]:[1]:method_text:[nType);            });        } catch (Exception e) {            // expected        }    }   ]) :|: 
    public void testEnableCellBroadcastRange() {
        try {
            int ranType = SmsCbMessage.MESSAGE_FORMAT_3GPP;
            executeWithShellPermissionIdentity(() -> {
                getSmsManager().enableCellBroadcastRange(
                        CdmaSmsCbProgramData.CATEGORY_CMAS_PRESIDENTIAL_LEVEL_ALERT,
                        CdmaSmsCbProgramData.CATEGORY_CMAS_EXTREME_THREAT,
                        ranType);
            });
        } catch (Exception e) {
            // expected
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SmsManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyRegistryManagerTest"	"testNotifyCallStateChangedForAllSubscriptions"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyRegistryManagerTest.java]:[permission]:[1]:method_text:[E_IDLE, result.first.longValue());        assertTrue(!TextUtils.isEmpty(result.second));    }   ]) :|: 
    public void testNotifyCallStateChangedForAllSubscriptions() throws Exception {
        Context context = InstrumentationRegistry.getContext();

        LinkedBlockingQueue<Pair<Integer, String>> queue = new LinkedBlockingQueue<>(1);
        PhoneStateListener psl = new PhoneStateListener(context.getMainExecutor()) {
            @Override
            public void onCallStateChanged(int state, String number) {
                queue.offer(Pair.create(state, number));
            }
        };
        TelephonyManager tm = context.getSystemService(TelephonyManager.class);
        tm.listen(psl, PhoneStateListener.LISTEN_CALL_STATE);
        // clear the initial result from registering the listener.
        queue.poll(TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);

        String dummyNumber = ""288124"";
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyRegistryMgr,
                (trm) -> trm.notifyCallStateChangedForAllSubscriptions(
                        TelephonyManager.CALL_STATE_IDLE, dummyNumber));

        Pair<Integer, String> result = queue.poll(TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
        assertNotNull(""Timed out waiting for phone state change"", result);
        assertEquals(TelephonyManager.CALL_STATE_IDLE, result.first.longValue());
        assertTrue(!TextUtils.isEmpty(result.second));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyRegistryManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyRegistryManagerTest"	"testNotifyCallStateChanged"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyRegistryManagerTest.java]:[permission]:[1]:method_text:[E_IDLE, result.first.longValue());        assertTrue(!TextUtils.isEmpty(result.second));    }   ]) :|: 
    public void testNotifyCallStateChanged() throws Exception {
        Context context = InstrumentationRegistry.getContext();

        LinkedBlockingQueue<Pair<Integer, String>> queue = new LinkedBlockingQueue<>(1);
        PhoneStateListener psl = new PhoneStateListener(context.getMainExecutor()) {
            @Override
            public void onCallStateChanged(int state, String number) {
                queue.offer(Pair.create(state, number));
            }
        };
        TelephonyManager tm = context.getSystemService(TelephonyManager.class);
        tm = tm.createForSubscriptionId(SubscriptionManager.getDefaultSubscriptionId());
        tm.listen(psl, PhoneStateListener.LISTEN_CALL_STATE);
        // clear the initial result from registering the listener.
        queue.poll(TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);

        String dummyNumber = ""288124"";
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyRegistryMgr,
                (trm) -> trm.notifyCallStateChanged(
                        SubscriptionManager.getSlotIndex(
                                SubscriptionManager.getDefaultSubscriptionId()),
                        SubscriptionManager.getDefaultSubscriptionId(),
                        TelephonyManager.CALL_STATE_IDLE, dummyNumber));

        Pair<Integer, String> result = queue.poll(TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
        assertNotNull(""Timed out waiting for phone state change"", result);
        assertEquals(TelephonyManager.CALL_STATE_IDLE, result.first.longValue());
        assertTrue(!TextUtils.isEmpty(result.second));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyRegistryManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyRegistryManagerTest"	"testNotifyServiceStateChanged"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyRegistryManagerTest.java]:[permission]:[1]:method_text:[d out waiting for phone state change"", result);        assertEquals(dummyState, result);    }   ]) :|: 
    public void testNotifyServiceStateChanged() throws Exception {
        Context context = InstrumentationRegistry.getContext();

        LinkedBlockingQueue<ServiceState> queue = new LinkedBlockingQueue<>(1);
        PhoneStateListener psl = new PhoneStateListener(context.getMainExecutor()) {
            @Override
            public void onServiceStateChanged(ServiceState ss) {
                queue.offer(ss);
            }
        };
        TelephonyManager tm = context.getSystemService(TelephonyManager.class);
        tm.listen(psl, PhoneStateListener.LISTEN_SERVICE_STATE);
        // clear the initial result from registering the listener.
        queue.poll(TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);

        ServiceState dummyState = new ServiceState();
        dummyState.setCdmaSystemAndNetworkId(1234, 5678);
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyRegistryMgr,
                (trm) -> trm.notifyServiceStateChanged(
                        SubscriptionManager.getSlotIndex(
                                SubscriptionManager.getDefaultSubscriptionId()),
                        SubscriptionManager.getDefaultSubscriptionId(),
                        dummyState));

        ServiceState result = queue.poll(TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
        assertNotNull(""Timed out waiting for phone state change"", result);
        assertEquals(dummyState, result);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyRegistryManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyRegistryManagerTest"	"testNotifySignalStrengthChanged"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyRegistryManagerTest.java]:[permission]:[1]:method_text:[ed out waiting for phone state change"", result);        assertEquals(testValue, result);    }   ]) :|: 
    public void testNotifySignalStrengthChanged() throws Exception {
        Context context = InstrumentationRegistry.getContext();

        LinkedBlockingQueue<SignalStrength> queue = new LinkedBlockingQueue<>(1);
        PhoneStateListener psl = new PhoneStateListener(context.getMainExecutor()) {
            @Override
            public void onSignalStrengthsChanged(SignalStrength ss) {
                queue.offer(ss);
            }
        };
        TelephonyManager tm = context.getSystemService(TelephonyManager.class);
        tm.listen(psl, PhoneStateListener.LISTEN_SIGNAL_STRENGTHS);
        // clear the initial result from registering the listener.
        queue.poll(TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);

        SignalStrength testValue = new SignalStrength();
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyRegistryMgr,
                (trm) -> trm.notifySignalStrengthChanged(
                        SubscriptionManager.getSlotIndex(
                                SubscriptionManager.getDefaultSubscriptionId()),
                        SubscriptionManager.getDefaultSubscriptionId(),
                        testValue));

        SignalStrength result = queue.poll(TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
        assertNotNull(""Timed out waiting for phone state change"", result);
        assertEquals(testValue, result);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyRegistryManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyRegistryManagerTest"	"testNotifyMessageWaitingChanged"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyRegistryManagerTest.java]:[permission]:[1]:method_text:[eue.poll(TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);        assertEquals(testValue, result);    }   ]) :|: 
    public void testNotifyMessageWaitingChanged() throws Exception {
        Context context = InstrumentationRegistry.getContext();

        LinkedBlockingQueue<Boolean> queue = new LinkedBlockingQueue<>(1);
        PhoneStateListener psl = new PhoneStateListener(context.getMainExecutor()) {
            @Override
            public void onMessageWaitingIndicatorChanged(boolean msgWaitingInd) {
                queue.offer(msgWaitingInd);
            }
        };
        TelephonyManager tm = context.getSystemService(TelephonyManager.class);
        tm.listen(psl, PhoneStateListener.LISTEN_MESSAGE_WAITING_INDICATOR);
        // clear the initial result from registering the listener.
        queue.poll(TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);

        boolean testValue = true;
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyRegistryMgr,
                (trm) -> trm.notifyMessageWaitingChanged(
                        SubscriptionManager.getSlotIndex(
                                SubscriptionManager.getDefaultSubscriptionId()),
                        SubscriptionManager.getDefaultSubscriptionId(),
                        testValue));

        boolean result = queue.poll(TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
        assertEquals(testValue, result);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyRegistryManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyRegistryManagerTest"	"testNotifyCallForwardingChanged"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyRegistryManagerTest.java]:[permission]:[1]:method_text:[eue.poll(TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);        assertEquals(testValue, result);    }   ]) :|: 
    public void testNotifyCallForwardingChanged() throws Exception {
        Context context = InstrumentationRegistry.getContext();

        LinkedBlockingQueue<Boolean> queue = new LinkedBlockingQueue<>(1);
        PhoneStateListener psl = new PhoneStateListener(context.getMainExecutor()) {
            @Override
            public void onCallForwardingIndicatorChanged(boolean callForwarding) {
                queue.offer(callForwarding);
            }
        };
        TelephonyManager tm = context.getSystemService(TelephonyManager.class);
        tm.listen(psl, PhoneStateListener.LISTEN_CALL_FORWARDING_INDICATOR);
        // clear the initial result from registering the listener.
        queue.poll(TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);

        boolean testValue = true;
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyRegistryMgr,
                (trm) -> trm.notifyCallForwardingChanged(
                        SubscriptionManager.getDefaultSubscriptionId(),
                        testValue));

        boolean result = queue.poll(TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
        assertEquals(testValue, result);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyRegistryManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyRegistryManagerTest"	"testNotifyDataActivityChanged"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyRegistryManagerTest.java]:[permission]:[1]:method_text:[queue.poll(TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);        assertEquals(testValue, result);    }}]) :|: 
    public void testNotifyDataActivityChanged() throws Exception {
        Context context = InstrumentationRegistry.getContext();

        LinkedBlockingQueue<Integer> queue = new LinkedBlockingQueue<>(1);
        PhoneStateListener psl = new PhoneStateListener(context.getMainExecutor()) {
            @Override
            public void onDataActivity(int activity) {
                queue.offer(activity);
            }
        };
        TelephonyManager tm = context.getSystemService(TelephonyManager.class);
        tm.listen(psl, PhoneStateListener.LISTEN_DATA_ACTIVITY);
        // clear the initial result from registering the listener.
        queue.poll(TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);

        int testValue = TelephonyManager.DATA_ACTIVITY_DORMANT;
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyRegistryMgr,
                (trm) -> trm.notifyDataActivityChanged(
                        SubscriptionManager.getDefaultSubscriptionId(),
                        testValue));

        int result = queue.poll(TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
        assertEquals(testValue, result);
    }

}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyRegistryManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.CellBroadcastDataMigrationTest"	"testLegacyContentProvider"	"CtsTelephonyTestCases"	"1: permission"	"([3:/android/telephony/cts/CellBroadcastDataMigrationTest.java]:[permission]:[3]:method_text:[rray) {        if (array != null && array.length > 0) {            fail(message);        }    }]) :|: 
    public void testLegacyContentProvider() throws Exception {
        final ProviderInfo legacy = InstrumentationRegistry.getContext().getPackageManager()
                .resolveContentProvider(CellBroadcasts.AUTHORITY_LEGACY, 0);
        if (legacy == null) {
            Log.d(TAG, ""Device does not support data migration"");
            return;
        }

        // Verify that legacy provider is protected with certain permissions
        assertEquals(""Legacy provider at MediaStore.AUTHORITY_LEGACY must protect its data"",
                android.Manifest.permission.READ_CELL_BROADCASTS, legacy.readPermission);

        // Skip headless check for OEM defined data migration app. e.g, OEMs might use messaging
        // apps to store CBR data pre-R.
        if (!DEFAULT_LEGACY_DATA_MIGRATION_APP.equals(legacy.applicationInfo.packageName)) {
            Log.d(TAG, ""Device support data migration from OEM apps"");
            return;
        }

        // And finally verify that legacy provider is headless. We expect the legacy provider only
        // surface the old data for migration rather than handling emergency alerts.
        final PackageInfo legacyPackage = InstrumentationRegistry.getContext().getPackageManager()
                .getPackageInfo(legacy.packageName, PackageManager.GET_ACTIVITIES
                        | PackageManager.GET_PROVIDERS | PackageManager.GET_RECEIVERS
                        | PackageManager.GET_SERVICES);
        assertEmpty(""Headless LegacyCellBroadcastContentProvider must have no activities"",
                legacyPackage.activities);
        assertEquals(""Headless LegacyCellBroadcastContentProvider must have exactly one provider"",
                1, legacyPackage.providers.length);
        assertEmpty(""Headless LegacyCellBroadcastContentProvider must have no receivers"",
                legacyPackage.receivers);
        assertEmpty(""Headless LegacyCellBroadcastContentProvider must have no services"",
                legacyPackage.se"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/CellBroadcastDataMigrationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.BatteryStatsManagerTest"	"testGetCellularBatteryStats"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/cts/BatteryStatsManagerTest.java]:[permission]:[2]:method_text:[eryStats.getTimeInRxSignalStrengthLevelMicros(                anyInt())).isAtLeast(-1L);    }   ]) :|: 
    public void testGetCellularBatteryStats() throws Exception {
        BatteryStatsManager bsm = getContext().getSystemService(BatteryStatsManager.class);
        CellularBatteryStats cellularBatteryStats =
                SystemUtil.callWithShellPermissionIdentity(bsm::getCellularBatteryStats,
                        android.Manifest.permission.BATTERY_STATS);

        assertThat(cellularBatteryStats.getEnergyConsumedMaMillis()).isAtLeast(0L);
        assertThat(cellularBatteryStats.getIdleTimeMillis()).isAtLeast(0L);
        assertThat(cellularBatteryStats.getLoggingDurationMillis()).isAtLeast(0L);
        assertThat(cellularBatteryStats.getKernelActiveTimeMillis()).isAtLeast(0L);
        assertThat(cellularBatteryStats.getMonitoredRailChargeConsumedMaMillis()).isAtLeast(0L);
        assertThat(cellularBatteryStats.getNumBytesRx()).isAtLeast(0L);
        assertThat(cellularBatteryStats.getNumBytesTx()).isAtLeast(0L);
        assertThat(cellularBatteryStats.getNumPacketsRx()).isAtLeast(0L);
        assertThat(cellularBatteryStats.getNumPacketsTx()).isAtLeast(0L);
        assertThat(cellularBatteryStats.getRxTimeMillis()).isAtLeast(0L);
        assertThat(cellularBatteryStats.getSleepTimeMillis()).isAtLeast(0L);
        assertThat(cellularBatteryStats.getTimeInRatMicros(anyInt())).isAtLeast(-1L);
        assertThat(cellularBatteryStats.getTimeInRxSignalStrengthLevelMicros(
                anyInt())).isAtLeast(-1L);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/BatteryStatsManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.BatteryStatsManagerTest"	"testGetCellularBatteryStats_requiresPermission"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/BatteryStatsManagerTest.java]:[permission]:[1]:method_text:[ice(BatteryStatsManager.class);        bsm.getCellularBatteryStats();  // Expected to throw    }}]) :|: (expected = SecurityException.class)
    public void testGetCellularBatteryStats_requiresPermission() {
        BatteryStatsManager bsm = getContext().getSystemService(BatteryStatsManager.class);
        bsm.getCellularBatteryStats();  // Expected to throw
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/BatteryStatsManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyLocationTests"	"testCellLocationFinePermission"	"CtsTelephonyTestCases"	"1: permission"	"([5:/android/telephony/cts/TelephonyLocationTests.java]:[permission]:[5]:method_text:[AGE, cellLocationAccess,                Manifest.permission.ACCESS_BACKGROUND_LOCATION);    }   ]) :|: 
    public void testCellLocationFinePermission() {
        if (!mShouldTest) return;
        Runnable cellLocationAccess = () -> {
            try {
                Bundle cellLocationBundle = (Bundle) performLocationAccessCommand(
                        CtsLocationAccessService.COMMAND_GET_CELL_LOCATION);
                CellLocation cellLocation = cellLocationBundle == null ? null :
                        CellLocation.newFromBundle(cellLocationBundle);
                assertTrue(cellLocation == null || cellLocation.isEmpty());
            } catch (SecurityException e) {
                // expected
            }

            try {
                List cis = (List) performLocationAccessCommand(
                        CtsLocationAccessService.COMMAND_GET_CELL_INFO);
                assertTrue(cis == null || cis.isEmpty());
            } catch (SecurityException e) {
                // expected
            }
        };

        withRevokedPermission(LOCATION_ACCESS_APP_CURRENT_PACKAGE,
                cellLocationAccess, Manifest.permission.ACCESS_FINE_LOCATION);
        withRevokedPermission(LOCATION_ACCESS_APP_CURRENT_PACKAGE, cellLocationAccess,
                Manifest.permission.ACCESS_BACKGROUND_LOCATION);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyLocationTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyLocationTests"	"testServiceStateLocationSanitization"	"CtsTelephonyTestCases"	"1: permission"	"([6:/android/telephony/cts/TelephonyLocationTests.java]:[permission]:[6]:method_text:[lse);                },                Manifest.permission.ACCESS_BACKGROUND_LOCATION);    }   ]) :|: 
    public void testServiceStateLocationSanitization() {
        if (!mShouldTest) return;

        withRevokedPermission(LOCATION_ACCESS_APP_CURRENT_PACKAGE, () -> {
                    ServiceState ss = (ServiceState) performLocationAccessCommand(
                            CtsLocationAccessService.COMMAND_GET_SERVICE_STATE);
                    assertServiceStateSanitization(ss, true);

                    withRevokedPermission(LOCATION_ACCESS_APP_CURRENT_PACKAGE, () -> {
                                ServiceState ss1 = (ServiceState) performLocationAccessCommand(
                                        CtsLocationAccessService.COMMAND_GET_SERVICE_STATE);
                                assertServiceStateSanitization(ss1, false);
                            },
                            Manifest.permission.ACCESS_COARSE_LOCATION);
                },
                Manifest.permission.ACCESS_FINE_LOCATION);

        withRevokedPermission(LOCATION_ACCESS_APP_CURRENT_PACKAGE, () -> {
                    ServiceState ss1 = (ServiceState) performLocationAccessCommand(
                            CtsLocationAccessService.COMMAND_GET_SERVICE_STATE);
                    assertServiceStateSanitization(ss1, false);
                },
                Manifest.permission.ACCESS_BACKGROUND_LOCATION);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyLocationTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyLocationTests"	"testServiceStateListeningWithoutPermissions"	"CtsTelephonyTestCases"	"1: permission"	"([7:/android/telephony/cts/TelephonyLocationTests.java]:[permission]:[7]:method_text:[lse);                },                Manifest.permission.ACCESS_BACKGROUND_LOCATION);    }   ]) :|: 
    public void testServiceStateListeningWithoutPermissions() {
        if (!mShouldTest) return;

        withRevokedPermission(LOCATION_ACCESS_APP_CURRENT_PACKAGE, () -> {
                    ServiceState ss = (ServiceState) performLocationAccessCommand(
                            CtsLocationAccessService.COMMAND_GET_SERVICE_STATE_FROM_LISTENER);
                    assertServiceStateSanitization(ss, true);

                    withRevokedPermission(LOCATION_ACCESS_APP_CURRENT_PACKAGE, () -> {
                                ServiceState ss1 = (ServiceState) performLocationAccessCommand(
                                        CtsLocationAccessService
                                                .COMMAND_GET_SERVICE_STATE_FROM_LISTENER);
                                assertServiceStateSanitization(ss1, false);
                            },
                            Manifest.permission.ACCESS_COARSE_LOCATION);
                },
                Manifest.permission.ACCESS_FINE_LOCATION);

        withRevokedPermission(LOCATION_ACCESS_APP_CURRENT_PACKAGE, () -> {
                    ServiceState ss1 = (ServiceState) performLocationAccessCommand(
                            CtsLocationAccessService
                                    .COMMAND_GET_SERVICE_STATE_FROM_LISTENER);
                    assertServiceStateSanitization(ss1, false);
                },
                Manifest.permission.ACCESS_BACKGROUND_LOCATION);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyLocationTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyLocationTests"	"testSdk28ServiceStateListeningWithoutPermissions"	"CtsTelephonyTestCases"	"1: permission"	"([5:/android/telephony/cts/TelephonyLocationTests.java]:[permission]:[5]:method_text:[_LOCATION);                },                Manifest.permission.ACCESS_FINE_LOCATION);    }   ]) :|: 
    public void testSdk28ServiceStateListeningWithoutPermissions() {
        if (!mShouldTest) return;

        withRevokedPermission(LOCATION_ACCESS_APP_SDK28_PACKAGE, () -> {
                    ServiceState ss = (ServiceState) performLocationAccessCommand(
                            CtsLocationAccessService.COMMAND_GET_SERVICE_STATE_FROM_LISTENER);
                    assertNotNull(ss);
                    assertNotEquals(ss, ss.createLocationInfoSanitizedCopy(false));

                    withRevokedPermission(LOCATION_ACCESS_APP_SDK28_PACKAGE, () -> {
                                ServiceState ss1 = (ServiceState) performLocationAccessCommand(
                                        CtsLocationAccessService
                                                .COMMAND_GET_SERVICE_STATE_FROM_LISTENER);
                                assertNotNull(ss1);
                                assertNotEquals(ss1, ss1.createLocationInfoSanitizedCopy(true));
                            },
                            Manifest.permission.ACCESS_COARSE_LOCATION);
                },
                Manifest.permission.ACCESS_FINE_LOCATION);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyLocationTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyLocationTests"	"testRegistryPermissionsForCellLocation"	"CtsTelephonyTestCases"	"1: permission"	"([5:/android/telephony/cts/TelephonyLocationTests.java]:[permission]:[5]:method_text:[ion);                },                Manifest.permission.ACCESS_BACKGROUND_LOCATION);    }   ]) :|: 
    public void testRegistryPermissionsForCellLocation() {
        if (!mShouldTest) return;

        withRevokedPermission(LOCATION_ACCESS_APP_CURRENT_PACKAGE, () -> {
                    CellLocation cellLocation = (CellLocation) performLocationAccessCommand(
                            CtsLocationAccessService.COMMAND_LISTEN_CELL_LOCATION);
                    assertNull(cellLocation);
                },
                Manifest.permission.ACCESS_FINE_LOCATION);

        withRevokedPermission(LOCATION_ACCESS_APP_CURRENT_PACKAGE, () -> {
                    CellLocation cellLocation = (CellLocation) performLocationAccessCommand(
                            CtsLocationAccessService.COMMAND_LISTEN_CELL_LOCATION);
                    assertNull(cellLocation);
                },
                Manifest.permission.ACCESS_BACKGROUND_LOCATION);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyLocationTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyLocationTests"	"testSdk28RegistryPermissionsForCellLocation"	"CtsTelephonyTestCases"	"1: permission"	"([3:/android/telephony/cts/TelephonyLocationTests.java]:[permission]:[3]:method_text:[ocation);                },                Manifest.permission.ACCESS_COARSE_LOCATION);    }   ]) :|: 
    public void testSdk28RegistryPermissionsForCellLocation() {
        if (!mShouldTest) return;

        withRevokedPermission(LOCATION_ACCESS_APP_SDK28_PACKAGE, () -> {
                    CellLocation cellLocation = (CellLocation) performLocationAccessCommand(
                            CtsLocationAccessService.COMMAND_LISTEN_CELL_LOCATION);
                    assertNull(cellLocation);
                },
                Manifest.permission.ACCESS_COARSE_LOCATION);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyLocationTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyLocationTests"	"testRegistryPermissionsForCellInfo"	"CtsTelephonyTestCases"	"1: permission"	"([5:/android/telephony/cts/TelephonyLocationTests.java]:[permission]:[5]:method_text:[ion);                },                Manifest.permission.ACCESS_BACKGROUND_LOCATION);    }   ]) :|: 
    public void testRegistryPermissionsForCellInfo() {
        if (!mShouldTest) return;

        withRevokedPermission(LOCATION_ACCESS_APP_CURRENT_PACKAGE, () -> {
                    CellLocation cellLocation = (CellLocation) performLocationAccessCommand(
                            CtsLocationAccessService.COMMAND_LISTEN_CELL_INFO);
                    assertNull(cellLocation);
                },
                Manifest.permission.ACCESS_FINE_LOCATION);

        withRevokedPermission(LOCATION_ACCESS_APP_CURRENT_PACKAGE, () -> {
                    CellLocation cellLocation = (CellLocation) performLocationAccessCommand(
                            CtsLocationAccessService.COMMAND_LISTEN_CELL_INFO);
                    assertNull(cellLocation);
                },
                Manifest.permission.ACCESS_BACKGROUND_LOCATION);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyLocationTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyLocationTests"	"testSdk28RegistryPermissionsForCellInfo"	"CtsTelephonyTestCases"	"1: permission"	"([3:/android/telephony/cts/TelephonyLocationTests.java]:[permission]:[3]:method_text:[Empty());                },                Manifest.permission.ACCESS_COARSE_LOCATION);    }   ]) :|: 
    public void testSdk28RegistryPermissionsForCellInfo() {
        if (!mShouldTest) return;

        withRevokedPermission(LOCATION_ACCESS_APP_SDK28_PACKAGE, () -> {
                    List<CellInfo> cis = (List<CellInfo>) performLocationAccessCommand(
                            CtsLocationAccessService.COMMAND_LISTEN_CELL_INFO);
                    assertTrue(cis == null || cis.isEmpty());
                },
                Manifest.permission.ACCESS_COARSE_LOCATION);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyLocationTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyLocationTests"	"testSdk28CellLocation"	"CtsTelephonyTestCases"	"1: permission"	"([6:/android/telephony/cts/TelephonyLocationTests.java]:[permission]:[6]:method_text:[permission.ACCESS_COARSE_LOCATION);        }, Manifest.permission.ACCESS_FINE_LOCATION);    }   ]) :|: 
    public void testSdk28CellLocation() {
        if (!mShouldTest) return;

        // Verify that a target-sdk 28 app can access cell location with ACCESS_COARSE_LOCATION, but
        // not with no location permissions at all.
        withRevokedPermission(LOCATION_ACCESS_APP_SDK28_PACKAGE, () -> {
            try {
                performLocationAccessCommandSdk28(
                        CtsLocationAccessService.COMMAND_GET_CELL_LOCATION);
            } catch (SecurityException e) {
                fail(""SDK28 should have access to cell location with coarse permission"");
            }

            withRevokedPermission(LOCATION_ACCESS_APP_SDK28_PACKAGE, () -> {
                try {
                    Bundle cellLocationBundle = (Bundle) performLocationAccessCommandSdk28(
                            CtsLocationAccessService.COMMAND_GET_CELL_LOCATION);
                    CellLocation cellLocation = cellLocationBundle == null ? null :
                            CellLocation.newFromBundle(cellLocationBundle);
                    assertTrue(cellLocation == null || cellLocation.isEmpty());
                } catch (SecurityException e) {
                    // expected
                }
            }, Manifest.permission.ACCESS_COARSE_LOCATION);
        }, Manifest.permission.ACCESS_FINE_LOCATION);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyLocationTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyLocationTests"	"testSdk28CellInfoUpdate"	"CtsTelephonyTestCases"	"1: permission"	"([11:/android/telephony/cts/TelephonyLocationTests.java]:[permission]:[11]:method_text:[tOperatorAlphaShort()));        assertTrue(TextUtils.isEmpty(state.getOperatorNumeric()));    }}]) :|: 
    public void testSdk28CellInfoUpdate() {
        if (!mShouldTest) return;

        // Verify that a target-sdk 28 app still requires fine location access
        // to call requestCellInfoUpdate
        withRevokedPermission(LOCATION_ACCESS_APP_SDK28_PACKAGE, () -> {
            try {
                List<CellInfo> cis = (List<CellInfo>) performLocationAccessCommandSdk28(
                        CtsLocationAccessService.COMMAND_REQUEST_CELL_INFO_UPDATE);
                assertTrue(cis == null || cis.isEmpty());
            } catch (SecurityException e) {
                // expected
            }
        }, Manifest.permission.ACCESS_FINE_LOCATION);
    }

    private ICtsLocationAccessControl getLocationAccessAppControl() {
        Intent bindIntent = new Intent(CtsLocationAccessService.CONTROL_ACTION);
        bindIntent.setComponent(new ComponentName(
                LOCATION_ACCESS_APP_CURRENT_PACKAGE,
                CtsLocationAccessService.class.getName()));

        return bindLocationAccessControl(bindIntent);
    }

    private ICtsLocationAccessControl getLocationAccessAppControlSdk28() {
        Intent bindIntent = new Intent(CtsLocationAccessService.CONTROL_ACTION);
        bindIntent.setComponent(new ComponentName(
                LOCATION_ACCESS_APP_SDK28_PACKAGE,
                CtsLocationAccessService.class.getName()));

        return bindLocationAccessControl(bindIntent);
    }

    private ICtsLocationAccessControl bindLocationAccessControl(Intent bindIntent) {
        LinkedBlockingQueue<ICtsLocationAccessControl> pipe =
                new LinkedBlockingQueue<>();
        InstrumentationRegistry.getContext().bindService(bindIntent, new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                pipe.offer(ICtsLocationAccessControl.Stub.asInterface(service));
            }

            @Override
            public void onServiceDisconnected(ComponentName name)"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyLocationTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.CellInfoTest"	"isCamped"	"CtsTelephonyTestCases"	"1: permission"	"([3:/android/telephony/cts/CellInfoTest.java]:[permission]:[3]:method_text:[er receives callbacks every time that new CellInfo     * is received and not otherwise.     */   ]) :|: /*
 *.
 */
package android.telephony.cts;

import static androidx.test.InstrumentationRegistry.getContext;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import android.annotation.Nullable;
import android.content.Context;
import android.content.pm.PackageManager;
import android.os.Parcel;
import android.os.SystemClock;
import android.telephony.AccessNetworkConstants;
import android.telephony.CellIdentity;
import android.telephony.CellIdentityCdma;
import android.telephony.CellIdentityGsm;
import android.telephony.CellIdentityLte;
import android.telephony.CellIdentityNr;
import android.telephony.CellIdentityTdscdma;
import android.telephony.CellIdentityWcdma;
import android.telephony.CellInfo;
import android.telephony.CellInfoCdma;
import android.telephony.CellInfoGsm;
import android.telephony.CellInfoLte;
import android.telephony.CellInfoNr;
import android.telephony.CellInfoTdscdma;
import android.telephony.CellInfoWcdma;
import android.telephony.CellSignalStrengthCdma;
import android.telephony.CellSignalStrengthGsm;
import android.telephony.CellSignalStrengthLte;
import android.telephony.CellSignalStrengthNr;
import android.telephony.CellSignalStrengthTdscdma;
import android.telephony.CellSignalStrengthWcdma;
import android.telephony.ClosedSubscriberGroupInfo;
import android.telephony.NetworkRegistrationInfo;
import android.telephony.PhoneStateListener;
import android.telephony.ServiceState;
import android.telephony.TelephonyManager;
import android.text.TextUtils;
import android.util.Log;
import android.util.Pair;

import androidx.test.InstrumentationRegistry;

import org.junit.Before;
import org.junit.Test;

import java.util.Arrays;
import java.util.List;
import java.util.concurrent.Executor;

/**
 * Test TelephonyManager.getAllCellInfo()
 * <p>
 *
 * Tes"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/CellInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.CellLocationTest"	"testCellLocation"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/CellLocationTest.java]:[permission]:[1]:method_text:[d.sleep(1000);        assertTrue(mOnCellLocationChangedCalled);        t.checkException();    }}]) :|: 
    public void testCellLocation() throws Throwable {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }

        TelephonyManagerTest.grantLocationPermissions();

        // getCellLocation should never return null,
        // but that is allowed if the cell network type
        // is LTE (since there is no LteCellLocation class)
        if (mTelephonyManager.getNetworkType() != TelephonyManager.NETWORK_TYPE_LTE) {
            assertNotNull(""TelephonyManager.getCellLocation() returned null!"",
                mTelephonyManager.getCellLocation());
        }

        CellLocation cl = CellLocation.getEmpty();
        if (cl instanceof GsmCellLocation) {
            GsmCellLocation gcl = (GsmCellLocation) cl;
            assertNotNull(gcl);
            assertEquals(-1, gcl.getCid());
            assertEquals(-1, gcl.getLac());
        }

        TestThread t = new TestThread(new Runnable() {
            public void run() {
                Looper.prepare();
                mListener = new PhoneStateListener() {
                    @Override
                    public void onCellLocationChanged(CellLocation location) {
                        synchronized (mLock) {
                            mOnCellLocationChangedCalled = true;
                            mLock.notify();
                        }
                    }
                };
                mTelephonyManager.listen(mListener, PhoneStateListener.LISTEN_CELL_LOCATION);

                Looper.loop();
            }
        });

        t.start();

        CellLocation.requestLocationUpdate();
        synchronized (mLock) {
            while (!mOnCellLocationChangedCalled) {
                mLock.wait();
            }
        }
        Thread.sleep(1000);
        assertTrue(mOnCellLocationChangedCalled);
        t.checkException();
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/CellLocationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.VisualVoicemailServiceTest"	"testPermissionlessService_ignored"	"CtsTelephonyTestCases"	"1: permission"	"([3:/android/telephony/cts/VisualVoicemailServiceTest.java]:[permission]:[3]:method_text:[ception | InterruptedException e) {            throw new RuntimeException(e);        }    }   ]) :|: 
    public void testPermissionlessService_ignored() {
        if (!hasTelephony(mContext)) {
            Log.d(TAG, ""skipping test that requires telephony feature"");
            return;
        }

        PackageManager packageManager = mContext.getPackageManager();
        packageManager.setComponentEnabledSetting(
                new ComponentName(mContext, MockVisualVoicemailService.class),
                PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP);
        packageManager.setComponentEnabledSetting(
                new ComponentName(mContext, PermissionlessVisualVoicemailService.class),
                PackageManager.COMPONENT_ENABLED_STATE_ENABLED, PackageManager.DONT_KILL_APP);
        String clientPrefix = ""//CTSVVM"";
        String text = ""//CTSVVM:STATUS:st=R;rc=0;srv=1;dn=1;ipt=1;spt=0;u=eg@example.com;pw=1"";

        mTelephonyManager.setVisualVoicemailSmsFilterSettings(
                new VisualVoicemailSmsFilterSettings.Builder()
                        .setClientPrefix(clientPrefix)
                        .build());

        try {
            mTelephonyManager
                    .sendVisualVoicemailSms(mPhoneNumber, 0, text, null);
            fail(""SecurityException expected"");
        } catch (SecurityException e) {
            // Expected
        }

        CompletableFuture<VisualVoicemailSms> future = new CompletableFuture<>();
        PermissionlessVisualVoicemailService.setSmsFuture(future);

        setupSmsReceiver(text);

        SmsManager.getDefault().sendTextMessage(mPhoneNumber, null, text, null, null);

        mSmsReceiver.assertReceived(EVENT_RECEIVED_TIMEOUT_MILLIS);
        try {
            future.get(EVENT_NOT_RECEIVED_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
            throw new RuntimeException(""Unexpected visual voicemail SMS received"");
        } catch (TimeoutException e) {
            // expected
        } catch (ExecutionException | InterruptedException e) {
            throw new Runtim"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/VisualVoicemailServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.CarrierSignalTest"	"TestReceiver"	"CtsTelephonyTestCases"	"1: permission"	"([3:/android/telephony/cts/CarrierSignalTest.java]:[permission]:[3]:method_text:[y {            mContext.unregisterReceiver(mReceiver);        } catch (Throwable t) { }    }   ]) :|: /*
 *.
 */

package android.telephony.cts;

import static org.junit.Assert.assertEquals;

import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.net.ConnectivityManager;
import android.os.PersistableBundle;
import android.telephony.CarrierConfigManager;
import android.telephony.SubscriptionManager;
import android.telephony.TelephonyManager;

import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.RequiredFeatureRule;
import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;

public class CarrierSignalTest {
    private class TestReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            mIntentFuture.complete(intent);
        }
    }

    @Rule
    public final RequiredFeatureRule mTelephonyRequiredRule =
            new RequiredFeatureRule(PackageManager.FEATURE_TELEPHONY);

    private static final int TEST_TIMEOUT_MILLIS = 5000;
    private Context mContext;
    private CarrierConfigManager mCarrierConfigManager;
    private int mTestSub;
    private CompletableFuture<Intent> mIntentFuture = new CompletableFuture<>();
    private final TestReceiver mReceiver = new TestReceiver();

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getContext();
        mCarrierConfigManager = mContext.getSystemService(CarrierConfigManager.class);
        mTestSub = SubscriptionManager.getDefaultSubscriptionId();

        String[] carrierConfigData = new String[] {
                new ComponentName(mContext.getPackageName(),
                        mReceiver.getCla"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/CarrierSignalTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.CarrierSignalTest"	"testResetBroadcast"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/CarrierSignalTest.java]:[permission]:[1]:method_text:[              receivedIntent.getIntExtra(SubscriptionManager.EXTRA_SUBSCRIPTION_INDEX, -1));    }}]) :|: 
    public void testResetBroadcast() throws Exception {
        mIntentFuture = new CompletableFuture<>();
        mContext.registerReceiver(mReceiver,
                new IntentFilter(TelephonyManager.ACTION_CARRIER_SIGNAL_RESET));

        // Enable airplane mode to force the reset action
        ConnectivityManager cm = mContext.getSystemService(ConnectivityManager.class);
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(cm,
                x -> x.setAirplaneMode(true));

        Intent receivedIntent = mIntentFuture.get(TEST_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
        assertEquals(mTestSub,
                receivedIntent.getIntExtra(SubscriptionManager.EXTRA_SUBSCRIPTION_INDEX, -1));
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/CarrierSignalTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testHasCarrierPrivilegesViaCarrierConfigs"	"CtsTelephonyTestCases"	"1: permission"	"([8:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[8]:method_text:[ uiAutomation.grantRuntimePermission(packageName, permission.ACCESS_BACKGROUND_LOCATION);    }   ]) :|: 
    public void testHasCarrierPrivilegesViaCarrierConfigs() throws Exception {
        if (!hasCellular()) return;
        PersistableBundle carrierConfig = mCarrierConfigManager.getConfigForSubId(mTestSub);

        try {
            assertNotNull(""CarrierConfigManager#getConfigForSubId() returned null"",
                    carrierConfig);
            assertFalse(""CarrierConfigManager#getConfigForSubId() returned empty bundle"",
                    carrierConfig.isEmpty());

            // purge the certs in carrierConfigs first
            carrierConfig.putStringArray(
                    CarrierConfigManager.KEY_CARRIER_CERTIFICATE_STRING_ARRAY, new String[]{});
            overrideCarrierConfig(carrierConfig);
            // verify we don't have privilege through carrierConfigs or Uicc
            assertFalse(mTelephonyManager.hasCarrierPrivileges());

            carrierConfig.putStringArray(
                    CarrierConfigManager.KEY_CARRIER_CERTIFICATE_STRING_ARRAY,
                    new String[]{mSelfCertHash});

            // verify we now have privilege after adding certificate to carrierConfigs
            overrideCarrierConfig(carrierConfig);
            assertTrue(mTelephonyManager.hasCarrierPrivileges());
        } finally {
            // purge the newly added certificate
            carrierConfig.putStringArray(
                    CarrierConfigManager.KEY_CARRIER_CERTIFICATE_STRING_ARRAY, new String[]{});
            // carrierConfig.remove(CarrierConfigManager.KEY_CARRIER_CERTIFICATE_STRING_ARRAY);
            overrideCarrierConfig(carrierConfig);

            // verify we no longer have privilege after removing certificate
            assertFalse(mTelephonyManager.hasCarrierPrivileges());
        }
    }

    private void overrideCarrierConfig(PersistableBundle bundle) throws Exception {
        mReceiver.clearQueue();
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mCarrierConfigManager,
                (cm) -> cm.overrid"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testListen"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[1]:method_text:[of these information, just make sure they are in right     * condition(>0 or not null).     */   ]) :|: 
    public void testListen() throws Throwable {
        if (!InstrumentationRegistry.getContext().getPackageManager()
                .hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            Log.d(TAG, ""Skipping test that requires PackageManager.FEATURE_TELEPHONY"");
            return;
        }

        if (mTelephonyManager.getPhoneType() == TelephonyManager.PHONE_TYPE_CDMA) {
            // TODO: temp workaround, need to adjust test to for CDMA
            return;
        }

        grantLocationPermissions();

        TestThread t = new TestThread(new Runnable() {
            public void run() {
                Looper.prepare();
                mListener = new PhoneStateListener() {
                    @Override
                    public void onCellLocationChanged(CellLocation location) {
                        if(!mOnCellLocationChangedCalled) {
                            synchronized (mLock) {
                                mOnCellLocationChangedCalled = true;
                                mLock.notify();
                            }
                        }
                    }
                };

                synchronized (mLock) {
                    mLock.notify(); // mListener is ready
                }

                Looper.loop();
            }
        });

        synchronized (mLock) {
            t.start();
            mLock.wait(TOLERANCE); // wait for mListener
        }

        // Test register
        synchronized (mLock) {
            // .listen generates an onCellLocationChanged event
            mTelephonyManager.listen(mListener, PhoneStateListener.LISTEN_CELL_LOCATION);
            mLock.wait(TOLERANCE);

            assertTrue(""Test register, mOnCellLocationChangedCalled should be true."",
                    mOnCellLocationChangedCalled);
        }

        synchronized (mLock) {
            mOnCellLocationChangedCalled = false;
            CellLocation.requestLocationUpdate();
            mLock.wait(TOLERANCE);"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testTelephonyManager"	"CtsTelephonyTestCases"	"1: permission"	"([21:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[21]:method_text:[  setAppOpsPermissionAllowed(false, OPSTR_USE_ICC_AUTH_WITH_DEVICE_IDENTIFIER);        }    }   ]) :|: 
    public void testTelephonyManager() {
        if (!InstrumentationRegistry.getContext().getPackageManager()
                .hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            Log.d(TAG, ""Skipping test that requires PackageManager.FEATURE_TELEPHONY"");
            return;
        }
        assertTrue(mTelephonyManager.getNetworkType() >= TelephonyManager.NETWORK_TYPE_UNKNOWN);
        assertTrue(mTelephonyManager.getPhoneType() >= TelephonyManager.PHONE_TYPE_NONE);
        assertTrue(mTelephonyManager.getSimState() >= TelephonyManager.SIM_STATE_UNKNOWN);
        assertTrue(mTelephonyManager.getDataActivity() >= TelephonyManager.DATA_ACTIVITY_NONE);
        assertTrue(mTelephonyManager.getDataState() >= TelephonyManager.DATA_DISCONNECTED);
        assertTrue(mTelephonyManager.getCallState() >= TelephonyManager.CALL_STATE_IDLE);

        for (int i = 0; i < mTelephonyManager.getPhoneCount(); ++i) {
            assertTrue(mTelephonyManager.getSimState(i) >= TelephonyManager.SIM_STATE_UNKNOWN);
        }

        // Make sure devices without MMS service won't fail on this
        if (InstrumentationRegistry.getContext().getPackageManager()
                .hasSystemFeature(PackageManager.FEATURE_TELEPHONY)
                && (mTelephonyManager.getPhoneType() != TelephonyManager.PHONE_TYPE_NONE)) {
            assertFalse(mTelephonyManager.getMmsUserAgent().isEmpty());
            assertFalse(mTelephonyManager.getMmsUAProfUrl().isEmpty());
        }

        // The following methods may return any value depending on the state of the device. Simply
        // call them to make sure they do not throw any exceptions.
        mTelephonyManager.getVoiceMailNumber();
        mTelephonyManager.getSimOperatorName();
        mTelephonyManager.getNetworkCountryIso();
        mTelephonyManager.getCellLocation();
        mTelephonyManager.getSimCarrierId();
        mTelephonyManager.getSimCarrierIdName();
        mTelephonyManager.getSimSpecificCarrierId();"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testGetCallForwarding"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[1]:method_text:[         callForwardingErrors.contains(receivedErrorCode.get()));            }        }    }   ]) :|: 
    public void testGetCallForwarding() throws Exception {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            Log.d(TAG, ""skipping test on device without FEATURE_TELEPHONY present"");
            return;
        }
        List<Integer> callForwardingReasons = new ArrayList<>();
        callForwardingReasons.add(CallForwardingInfo.REASON_UNCONDITIONAL);
        callForwardingReasons.add(CallForwardingInfo.REASON_BUSY);
        callForwardingReasons.add(CallForwardingInfo.REASON_NO_REPLY);
        callForwardingReasons.add(CallForwardingInfo.REASON_NOT_REACHABLE);
        callForwardingReasons.add(CallForwardingInfo.REASON_ALL);
        callForwardingReasons.add(CallForwardingInfo.REASON_ALL_CONDITIONAL);

        Set<Integer> callForwardingErrors = new HashSet<Integer>();
        callForwardingErrors.add(TelephonyManager.CallForwardingInfoCallback
                .RESULT_ERROR_FDN_CHECK_FAILURE);
        callForwardingErrors.add(TelephonyManager.CallForwardingInfoCallback.RESULT_ERROR_UNKNOWN);
        callForwardingErrors.add(TelephonyManager.CallForwardingInfoCallback
                .RESULT_ERROR_NOT_SUPPORTED);

        for (int callForwardingReasonToGet : callForwardingReasons) {
            Log.d(TAG, ""[testGetCallForwarding] callForwardingReasonToGet: ""
                    + callForwardingReasonToGet);
            AtomicReference<CallForwardingInfo> receivedForwardingInfo = new AtomicReference<>();
            AtomicReference<Integer> receivedErrorCode = new AtomicReference<>();
            CountDownLatch latch = new CountDownLatch(1);
            TelephonyManager.CallForwardingInfoCallback callback =
                    new TelephonyManager.CallForwardingInfoCallback() {
                        @Override
                        public void onCallForwardingInfoAvailable(CallForwardingInfo info) {
                            receivedForwardingInfo.set(info);
                            latch.countDown();"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testSetCallForwarding"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[2]:method_text:[    //        latch.await(TIMEOUT_FOR_NETWORK_OPS * 3, TimeUnit.MILLISECONDS));        }    }   ]) :|: 
    public void testSetCallForwarding() throws Exception {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            Log.d(TAG, ""skipping test on device without FEATURE_TELEPHONY present"");
            return;
        }
        List<Integer> callForwardingReasons = new ArrayList<>();
        callForwardingReasons.add(CallForwardingInfo.REASON_UNCONDITIONAL);
        callForwardingReasons.add(CallForwardingInfo.REASON_BUSY);
        callForwardingReasons.add(CallForwardingInfo.REASON_NO_REPLY);
        callForwardingReasons.add(CallForwardingInfo.REASON_NOT_REACHABLE);
        callForwardingReasons.add(CallForwardingInfo.REASON_ALL);
        callForwardingReasons.add(CallForwardingInfo.REASON_ALL_CONDITIONAL);

        // Enable Call Forwarding
        for (int callForwardingReasonToEnable : callForwardingReasons) {
            CountDownLatch latch = new CountDownLatch(1);
            // Disregard success or failure; just make sure it reports back.
            Consumer<Integer> ignoringResultListener = (x) -> latch.countDown();

            final CallForwardingInfo callForwardingInfoToEnable = new CallForwardingInfo(
                    true,
                    callForwardingReasonToEnable,
                    TEST_FORWARD_NUMBER,
                    // time seconds
                    1);
            Log.d(TAG, ""[testSetCallForwarding] Enable Call Forwarding. Reason: ""
                    + callForwardingReasonToEnable + "" Number: "" + TEST_FORWARD_NUMBER
                    + "" Time Seconds: 1"");
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    (tm) -> tm.setCallForwarding(callForwardingInfoToEnable,
                            getContext().getMainExecutor(), ignoringResultListener));
            // TODO: this takes way too long on a real network (upwards of 40s).
            // assertTrue(""No response for forwarding for reason "" + callForwardingReasonToEnable,"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testGetCallWaitingStatus"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[1]:method_text:[          callWaitingStatusResult.poll(TIMEOUT_FOR_NETWORK_OPS, TimeUnit.MILLISECONDS)));    }   ]) :|: 
    public void testGetCallWaitingStatus() throws Exception {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            Log.d(TAG, ""skipping test on device without FEATURE_TELEPHONY present"");
            return;
        }
        Set<Integer> validCallWaitingStatuses = new HashSet<Integer>();
        validCallWaitingStatuses.add(TelephonyManager.CALL_WAITING_STATUS_ENABLED);
        validCallWaitingStatuses.add(TelephonyManager.CALL_WAITING_STATUS_DISABLED);
        validCallWaitingStatuses.add(TelephonyManager.CALL_WAITING_STATUS_UNKNOWN_ERROR);
        validCallWaitingStatuses.add(TelephonyManager.CALL_WAITING_STATUS_NOT_SUPPORTED);

        LinkedBlockingQueue<Integer> callWaitingStatusResult = new LinkedBlockingQueue<>(1);
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                mTelephonyManager, (tm) -> tm.getCallWaitingStatus(getContext().getMainExecutor(),
                        callWaitingStatusResult::offer));
        assertTrue(validCallWaitingStatuses.contains(
                callWaitingStatusResult.poll(TIMEOUT_FOR_NETWORK_OPS, TimeUnit.MILLISECONDS)));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testSetCallWaitingStatus"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[2]:method_text:[                        validCallWaitingErrors.contains(result));            }        }    }   ]) :|: 
    public void testSetCallWaitingStatus() throws Exception {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            Log.d(TAG, ""skipping test on device without FEATURE_TELEPHONY present"");
            return;
        }
        Set<Integer> validCallWaitingErrors = new HashSet<Integer>();
        validCallWaitingErrors.add(TelephonyManager.CALL_WAITING_STATUS_UNKNOWN_ERROR);
        validCallWaitingErrors.add(TelephonyManager.CALL_WAITING_STATUS_NOT_SUPPORTED);
        Executor executor = getContext().getMainExecutor();
        {
            LinkedBlockingQueue<Integer> callWaitingResult = new LinkedBlockingQueue<>(1);

            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    (tm) -> tm.setCallWaitingEnabled(true, executor, callWaitingResult::offer));
            Integer result = callWaitingResult.poll(TIMEOUT_FOR_NETWORK_OPS, TimeUnit.MILLISECONDS);
            assertNotNull(""Never got callback from set call waiting"", result);
            if (result != TelephonyManager.CALL_WAITING_STATUS_ENABLED) {
                assertTrue(""Call waiting callback got an invalid value: "" + result,
                        validCallWaitingErrors.contains(result));
            }
        }

        {
            LinkedBlockingQueue<Integer> callWaitingResult = new LinkedBlockingQueue<>(1);

            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    (tm) -> tm.setCallWaitingEnabled(false, executor, callWaitingResult::offer));
            Integer result = callWaitingResult.poll(TIMEOUT_FOR_NETWORK_OPS, TimeUnit.MILLISECONDS);
            assertNotNull(""Never got callback from set call waiting"", result);
            if (result != TelephonyManager.CALL_WAITING_STATUS_DISABLED) {
                assertTrue(""Call waiting callback got an invalid value: "" + result,
                        validCallWaitingErrors.contains(result));
            }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testCreateForPhoneAccountHandle"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[2]:method_text:[m) -> tm.getSubscriberId());        assertEquals(globalSubscriberId, localSubscriberId);    }   ]) :|: 
    public void testCreateForPhoneAccountHandle() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            Log.d(TAG, ""Skipping test that requires FEATURE_TELEPHONY"");
            return;
        }
        if (!mTelephonyManager.isVoiceCapable()) {
            Log.d(TAG, ""Skipping test that requires config_voice_capable is true"");
            return;
        }
        int subId = SubscriptionManager.getDefaultDataSubscriptionId();
        if (subId == SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
            Log.d(TAG, ""Skipping test that requires DefaultDataSubscriptionId setting"");
            return;
        }

        TelecomManager telecomManager = getContext().getSystemService(TelecomManager.class);
        PhoneAccountHandle handle =
                telecomManager.getDefaultOutgoingPhoneAccount(PhoneAccount.SCHEME_TEL);
        TelephonyManager telephonyManager = mTelephonyManager.createForPhoneAccountHandle(handle);
        String globalSubscriberId = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, (tm) -> tm.getSubscriberId());
        String localSubscriberId = ShellIdentityUtils.invokeMethodWithShellPermissions(
                telephonyManager, (tm) -> tm.getSubscriberId());
        assertEquals(globalSubscriberId, localSubscriberId);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testGetPhoneAccountHandle"	"CtsTelephonyTestCases"	"1: permission"	"([3:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[3]:method_text:[dentity();        }    }    /**     * Tests that the phone count returned is valid.     */   ]) :|: 
    public void testGetPhoneAccountHandle() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            Log.d(TAG, ""Skipping test that requires FEATURE_TELEPHONY"");
            return;
        }
        TelecomManager telecomManager = getContext().getSystemService(TelecomManager.class);
        PhoneAccountHandle defaultAccount = telecomManager
                .getDefaultOutgoingPhoneAccount(PhoneAccount.SCHEME_TEL);
        try {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                    .adoptShellPermissionIdentity(
                            ""android.permission.READ_PRIVILEGED_PHONE_STATE"");
            PhoneAccountHandle phoneAccountHandle = mTelephonyManager.getPhoneAccountHandle();
            assertEquals(phoneAccountHandle, defaultAccount);
        } catch (SecurityException e) {
            fail(""TelephonyManager#getPhoneAccountHandle requires READ_PRIVILEGED_PHONE_STATE"");
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                    .dropShellPermissionIdentity();
        }
    }

    /**
     * Tests that the phone count returned is valid.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testGetDeviceId"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[1]:method_text:[rifyDeviceId(deviceId);    }    /**     * Tests the max number of active SIMs method     */   ]) :|: 
    public void testGetDeviceId() {
        String deviceId = ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                (tm) -> tm.getDeviceId());
        verifyDeviceId(deviceId);
    }

    /**
     * Tests the max number of active SIMs method
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testGetDeviceIdForSlot"	"CtsTelephonyTestCases"	"1: permission"	"([5:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[5]:method_text:[ter.getAddress();    }    private static final String ISO_COUNTRY_CODE_PATTERN = ""[a-z]{2}"";   ]) :|: 
    public void testGetDeviceIdForSlot() {
        String deviceId = ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                (tm) -> tm.getDeviceId(mTelephonyManager.getSlotIndex()));
        verifyDeviceId(deviceId);
        // Also verify that no exception is thrown for any slot index (including invalid ones)
        for (int i = -1; i <= mTelephonyManager.getPhoneCount(); i++) {
            // The compiler error 'local variables referenced from a lambda expression must be final
            // or effectively final' is reported when using i, so assign it to a final variable.
            final int currI = i;
            ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                    (tm) -> tm.getDeviceId(currI));
        }
    }

    private void verifyDeviceId(String deviceId) {
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            // Either IMEI or MEID need to be valid.
            try {
                assertImei(deviceId);
            } catch (AssertionError e) {
                assertMeidEsn(deviceId);
            }
        } else if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_WIFI)) {
            assertSerialNumber();
            assertMacAddress(getWifiMacAddress());
        } else if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_BLUETOOTH)) {
            assertSerialNumber();
            assertMacAddress(getBluetoothMacAddress());
        } else if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_ETHERNET)) {
            assertTrue(mCm.getNetworkInfo(ConnectivityManager.TYPE_ETHERNET) != null);
        }
    }

    private static void assertImei(String id) {
        assertFalse(""Imei should not be empty or null"", TextUtils.isEmpty(id));
        // IMEI may include the check digit
        String imeiPattern = ""[0-9]{14,15}"";
        String invalidPattern = ""[0]{14,15}"";
        assertTrue(""IMEI "" + id + "" does not match pattern"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testSetSystemSelectionChannels"	"CtsTelephonyTestCases"	"1: permission"	"([6:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[6]:method_text:[                   TelephonyManager::getSystemSelectionChannels));        }         **/    }   ]) :|: 
    public void testSetSystemSelectionChannels() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            Log.d(TAG, ""skipping test on device without FEATURE_TELEPHONY present"");
            return;
        }
        LinkedBlockingQueue<Boolean> queue = new LinkedBlockingQueue<>(1);
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // This is a oneway binder call, meaning we may return before the permission check
            // happens. Hold shell permissions until we get a response.
            mTelephonyManager.setSystemSelectionChannels(Collections.emptyList(),
                    getContext().getMainExecutor(), queue::offer);
            Boolean result = queue.poll(1000, TimeUnit.MILLISECONDS);
            // Ensure we get a result
            assertNotNull(result);
            // Only verify the result for supported devices on IRadio 1.3+
            if (mRadioVersion >= RADIO_HAL_VERSION_1_3) {
                assertTrue(result);
            }
        } catch (InterruptedException e) {
            fail(""interrupted"");
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }

        // Try calling the API that doesn't provide feedback. We have no way of knowing if it
        // succeeds, so just make sure nothing crashes.
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                tp -> tp.setSystemSelectionChannels(Collections.emptyList()));

        // TODO (b/189255895): Uncomment once getSystemSelection channels is functional in S QPR
        /**
        // getSystemSelectionChannels was added in IRadio 1.6, so ensure it returns
        // the value that was set by setSystemSelectionChannels.
        if (mRadioVersion >= RADIO_HAL_VERSION_1_6) {
            assertEquals(Collections.emptyList()"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testResetSettings"	"CtsTelephonyTestCases"	"1: permission"	"([10:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[10]:method_text:[isDataEnabled(),                        5 /*times*/, TOLERANCE/5 /*timeout per poll*/));    }   ]) :|: 
    public void testResetSettings() throws Exception {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            Log.d(TAG, ""skipping test on device without FEATURE_TELEPHONY present"");
            return;
        }

        UserManager userManager = getContext().getSystemService(UserManager.class);

        boolean canChangeMobileNetworkSettings = userManager != null
                && !userManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_MOBILE_NETWORKS);
        assertTrue(""Primary user must be able to configure mobile networks to pass this test"",
                canChangeMobileNetworkSettings);
        boolean initialDataSetting = isDataEnabled();

        //First check permissions are correct
        try {
            mTelephonyManager.resetSettings();
            fail(""TelephonyManager#resetSettings requires the""
                    + "" android.Manifest.permission.NETWORK_SETTINGS permission"");
        } catch (SecurityException e) {
            //expected
        }
        // and then do a reset to move data to default.
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    TelephonyManager::resetSettings,
                    ""android.permission.NETWORK_SETTINGS"",
                    ""android.permission.MODIFY_PHONE_STATE"");
        } catch (SecurityException e) {
            e.printStackTrace();
            fail(e.toString());
        }
        // This may timeout because the default is equal to the initial data setting, but there is
        // no way to definitively check what the default should be, so assume the default will be
        // set within TOLERANCE time.
        TelephonyUtils.pollUntilTrue(() -> initialDataSetting != isDataEnabled(), 5 /*times*/,
                TOLERANCE/5 /*timeout per poll*/);

        boolean defaultDataSetting = isDataEnabled();

        // set data to not the default!
        ShellIdentityUtils.invokeMethodWit"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testGetServiceStateForInactiveSub"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[1]:method_text:[AT IWLAN is not reported on WWAN transport if the device is    // operated in AP-assisted mode.   ]) :|: 
    public void testGetServiceStateForInactiveSub() {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }

        int[] allSubs  = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mSubscriptionManager, (sm) ->sm.getActiveSubscriptionIdList());
        // generate a subscription that is valid (>0) but inactive (not part of active subId list)
        // A simple way to do this is sum the active subIds and add 1
        int inactiveValidSub = 1;
        for (int sub : allSubs) {
            inactiveValidSub += sub;
        }

        assertNull(mTelephonyManager.createForSubscriptionId(inactiveValidSub).getServiceState());
    }

    // This test is to ensure the RAT IWLAN is not reported on WWAN transport if the device is
    // operated in AP-assisted mode."	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testGetPhoneCapabilityAndVerify"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[1]:method_text:[      assertArrayEquals(deviceNrCapabilities, phoneCapability.getDeviceNrCapabilities());    }   ]) :|: 
    public void testGetPhoneCapabilityAndVerify() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            Log.d(TAG,""skipping test that requires Telephony"");
            return;
        }
        boolean is5gStandalone = getContext().getResources().getBoolean(
                Resources.getSystem().getIdentifier(""config_telephony5gStandalone"", ""bool"",
                        ""android""));
        boolean is5gNonStandalone = getContext().getResources().getBoolean(
                Resources.getSystem().getIdentifier(""config_telephony5gNonStandalone"", ""bool"",
                        ""android""));
        int[] deviceNrCapabilities = new int[0];
        if (is5gStandalone || is5gNonStandalone) {
            List<Integer> list = new ArrayList<>();
            if (is5gNonStandalone) {
                list.add(DEVICE_NR_CAPABILITY_NSA);
            }
            if (is5gStandalone) {
                list.add(DEVICE_NR_CAPABILITY_SA);
            }
            deviceNrCapabilities = list.stream().mapToInt(Integer::valueOf).toArray();
        }

        PhoneCapability phoneCapability = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, (tm) -> tm.getPhoneCapability());

        assertArrayEquals(deviceNrCapabilities, phoneCapability.getDeviceNrCapabilities());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testGetSimLocale"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[1]:method_text:[cation code) or     * null.     * The TAC should match the first 8 digits of the IMEI.     */   ]) :|: 
    public void testGetSimLocale() throws InterruptedException {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            Log.d(TAG,""skipping test that requires Telephony"");
            return;
        }
        if (SubscriptionManager.getDefaultSubscriptionId()
                == SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
            fail(""Expected SIM inserted"");
        }
        Locale locale = ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                (tm) -> tm.getSimLocale());
        Log.d(TAG, ""testGetSimLocale: "" + locale);
        assertNotNull(locale);
    }

    /**
     * Tests that a GSM device properly reports either the correct TAC (type allocation code) or
     * null.
     * The TAC should match the first 8 digits of the IMEI.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testGetTac"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[1]:method_text:[ (manufacturer code) or null.     * The MC should match the first 8 digits of the MEID.     */   ]) :|: 
    public void testGetTac() {
        String tac = mTelephonyManager.getTypeAllocationCode();
        String imei = ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                (tm) -> tm.getImei());

        if (tac == null || imei == null) {
            return;
        }

        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            if (mTelephonyManager.getPhoneType() == TelephonyManager.PHONE_TYPE_GSM) {
                assertEquals(imei.substring(0, 8), tac);
            }
        }
    }

    /**
     * Tests that a CDMA device properly reports either the correct MC (manufacturer code) or null.
     * The MC should match the first 8 digits of the MEID.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testGetMc"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[1]:method_text:[   }    /**     * Tests that the device properly reports either a valid IMEI or null.     */   ]) :|: 
    public void testGetMc() {
        String mc = mTelephonyManager.getManufacturerCode();
        String meid = ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                (tm) -> tm.getMeid());

        if (mc == null || meid == null) {
            return;
        }

        // mc and meid should either be null or supported. empty string is not expected even if
        // the device does not support mc/meid.
        assertNotEquals("""", mc);
        assertNotEquals("""", meid);

        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            if (mTelephonyManager.getPhoneType() == TelephonyManager.PHONE_TYPE_CDMA) {
                assertEquals(meid.substring(0, 8), mc);
            }
        }
    }

    /**
     * Tests that the device properly reports either a valid IMEI or null.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testGetImei"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[1]:method_text:[   }    /**     * Tests that the device properly reports either a valid IMEI or null.     */   ]) :|: 
    public void testGetImei() {
        String imei = ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                (tm) -> tm.getImei());

        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            if (mTelephonyManager.getPhoneType() == TelephonyManager.PHONE_TYPE_GSM) {
                assertImei(imei);
            }
        }
    }

    /**
     * Tests that the device properly reports either a valid IMEI or null.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testGetImeiForSlot"	"CtsTelephonyTestCases"	"1: permission"	"([3:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[3]:method_text:[yManager#getRadioPowerState()} does not throw any exception     * and returns radio on.     */   ]) :|: 
    public void testGetImeiForSlot() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }

        for (int i = 0; i < mTelephonyManager.getPhoneCount(); i++) {
            // The compiler error 'local variables referenced from a lambda expression must be final
            // or effectively final' is reported when using i, so assign it to a final variable.
            final int currI = i;
            String imei = ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                    (tm) -> tm.getImei(currI));
            if (!TextUtils.isEmpty(imei)) {
                assertImei(imei);
            }
        }

        // Also verify that no exception is thrown for any slot index (including invalid ones)
        ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                (tm) -> tm.getImei(-1));
        ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                (tm) -> tm.getImei(mTelephonyManager.getPhoneCount()));
    }

    /**
     * Verifies that {@link TelephonyManager#getRadioPowerState()} does not throw any exception
     * and returns radio on.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testSetCarrierDataEnabled"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[2]:method_text:[ootRadio()} does not throw any exception     * and final radio state is radio power on.     */   ]) :|: 
    public void testSetCarrierDataEnabled() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }
        // Also verify that no exception is thrown.
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                (tm) -> tm.setCarrierDataEnabled(false));
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                (tm) -> tm.setCarrierDataEnabled(true));
    }

    /**
     * Verifies that {@link TelephonyManager#rebootRadio()} does not throw any exception
     * and final radio state is radio power on.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testRebootRadio"	"CtsTelephonyTestCases"	"1: permission"	"([5:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[5]:method_text:[pType(int)} does not throw any exception     * for all supported subscription app type.     */   ]) :|: 
    public void testRebootRadio() throws Throwable {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }
        TestThread t = new TestThread(new Runnable() {
            public void run() {
                Looper.prepare();

                mListener = new PhoneStateListener() {
                    @Override
                    public void onRadioPowerStateChanged(
                            @RadioPowerState int state) {
                        synchronized (mLock) {
                            if (state == TelephonyManager.RADIO_POWER_ON && mHasRadioPowerOff) {
                                mRadioRebootTriggered = true;
                                mLock.notify();
                            } else if (state == TelephonyManager.RADIO_POWER_OFF) {
                                // reboot must go to power off
                                mHasRadioPowerOff = true;
                            }
                        }
                    }
                };
                ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                        (tm) -> tm.listen(mListener,
                                PhoneStateListener.LISTEN_RADIO_POWER_STATE_CHANGED));
                Looper.loop();
            }
        });

        assertThat(mTelephonyManager.getRadioPowerState()).isEqualTo(
                TelephonyManager.RADIO_POWER_ON);
        assertThat(mRadioRebootTriggered).isFalse();
        assertThat(mHasRadioPowerOff).isFalse();
        boolean success = ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                (tm) -> tm.rebootRadio());
        //skip this test if not supported or unsuccessful (success=false)
        if(!success) {
            return;
        }

        t.start();
        synchronized (mLock) {
            // reboot takes longer time
            if (!mRadioRebootTriggered) {
                mLock.wait(20000);"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testGetAidForAppType"	"CtsTelephonyTestCases"	"1: permission"	"([5:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[5]:method_text:[   * Verifies that {@link TelephonyManager#getIsimDomain()} does not throw any exception     */   ]) :|: 
    public void testGetAidForAppType() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }
        ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                (tm) -> tm.getAidForAppType(TelephonyManager.APPTYPE_SIM));
        ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                (tm) -> tm.getAidForAppType(TelephonyManager.APPTYPE_CSIM));
        ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                (tm) -> tm.getAidForAppType(TelephonyManager.APPTYPE_RUIM));
        ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                (tm) -> tm.getAidForAppType(TelephonyManager.APPTYPE_ISIM));
        ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                (tm) -> tm.getAidForAppType(TelephonyManager.APPTYPE_USIM));
    }

    /**
     * Verifies that {@link TelephonyManager#getIsimDomain()} does not throw any exception
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testGetIsimDomain"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[2]:method_text:[* and has the correct permissions.     */    @Ignore(""API moved back to @hide for Android R."")   ]) :|: 
    public void testGetIsimDomain() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }
        ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                (tm) -> tm.getIsimDomain());
    }

    /**
     * Verifies that {@link TelephonyManager#getIsimImpu()} does not throw any exception when called
     * and has the correct permissions.
     */
    @Ignore(""API moved back to @hide for Android R."")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testGetIsimImpu"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[2]:method_text:[e {@link NetworkRegistrationInfo#getRegisteredPlmn()} provides valid     * information.     */   ]) :|: 
    public void testGetIsimImpu() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }
        ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                TelephonyManager::getIsimImpu);
        // Try without the correct permissions and ensure it fails.
        try {
            mTelephonyManager.getIsimImpu();
            fail();
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Basic test to ensure {@link NetworkRegistrationInfo#getRegisteredPlmn()} provides valid
     * information.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testGetMeid"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[1]:method_text:[   }    /**     * Tests that the device properly reports either a valid MEID or null.     */   ]) :|: 
    public void testGetMeid() {
        String meid = ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                (tm) -> tm.getMeid());

        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            if (mTelephonyManager.getPhoneType() == TelephonyManager.PHONE_TYPE_CDMA) {
                assertMeidEsn(meid);
            }
        }
    }

    /**
     * Tests that the device properly reports either a valid MEID or null.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testGetMeidForSlot"	"CtsTelephonyTestCases"	"1: permission"	"([3:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[3]:method_text:[caller does not have carrier privileges or is not the     * current default dialer app.     */   ]) :|: 
    public void testGetMeidForSlot() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }

        SubscriptionManager sm = getContext().getSystemService(SubscriptionManager.class);
        List<SubscriptionInfo> subInfos = sm.getActiveSubscriptionInfoList();

        if (subInfos != null) {
            for (SubscriptionInfo subInfo : subInfos) {
                int slotIndex = subInfo.getSimSlotIndex();
                int subId = subInfo.getSubscriptionId();
                TelephonyManager tm = mTelephonyManager.createForSubscriptionId(subId);
                if (tm.getPhoneType() == TelephonyManager.PHONE_TYPE_CDMA) {
                    String meid = ShellIdentityUtils.invokeMethodWithShellPermissions(
                            mTelephonyManager,
                            (telephonyManager) -> telephonyManager.getMeid(slotIndex));

                    if (!TextUtils.isEmpty(meid)) {
                        assertMeidEsn(meid);
                    }
                }
            }
        }

        // Also verify that no exception is thrown for any slot index (including invalid ones)
        ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                (tm) -> tm.getMeid(-1));
        ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                (tm) -> tm.getMeid(mTelephonyManager.getPhoneCount()));
    }

    /**
     * Tests sendDialerSpecialCode API.
     * Expects a security exception since the caller does not have carrier privileges or is not the
     * current default dialer app.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testGetManualNetworkSelectionPlmnNonPersisted"	"CtsTelephonyTestCases"	"1: permission"	"([3:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[3]:method_text:[rts the contents of ManualNetworkSelectionPlmn     * The setting is persisted selection     */   ]) :|: 
    public void testGetManualNetworkSelectionPlmnNonPersisted() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }
        if (mTelephonyManager.getPhoneType() != TelephonyManager.PHONE_TYPE_GSM) return;

        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                    (tm) -> tm.setNetworkSelectionModeManual(
                     TESTING_PLMN/* operatorNumeric */, false /* persistSelection */));
            String plmn = ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                     (tm) -> tm.getManualNetworkSelectionPlmn());
            assertEquals(TESTING_PLMN, plmn);
        } finally {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    (tm) -> tm.setNetworkSelectionModeAutomatic());
        }
    }

    /**
     * Tests that the device properly reports the contents of ManualNetworkSelectionPlmn
     * The setting is persisted selection
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testGetManualNetworkSelectionPlmnPersisted"	"CtsTelephonyTestCases"	"1: permission"	"([3:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[3]:method_text:[ returns a positive value or either     * UNINITIALIZED_CARD_ID or UNSUPPORTED_CARD_ID.     */   ]) :|: 
    public void testGetManualNetworkSelectionPlmnPersisted() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }
        if (mTelephonyManager.getPhoneType() != TelephonyManager.PHONE_TYPE_GSM) return;

        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                    (tm) -> tm.setNetworkSelectionModeManual(
                     TESTING_PLMN/* operatorNumeric */, true /* persistSelection */));
            String plmn = ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                     (tm) -> tm.getManualNetworkSelectionPlmn());
            assertEquals(TESTING_PLMN, plmn);
        } finally {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    (tm) -> tm.setNetworkSelectionModeAutomatic());
        }
    }

    /**
     * Verify that TelephonyManager.getCardIdForDefaultEuicc returns a positive value or either
     * UNINITIALIZED_CARD_ID or UNSUPPORTED_CARD_ID.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testGetUiccCardsInfo"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[1]:method_text:[  /**     * Tests that the device properly reports the contents of NetworkSelectionMode     */   ]) :|: 
    public void testGetUiccCardsInfo() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            Log.d(TAG, ""Skipping test that requires FEATURE_TELEPHONY"");
            return;
        }
        // Requires READ_PRIVILEGED_PHONE_STATE or carrier privileges
        List<UiccCardInfo> infos =
                ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                (tm) -> tm.getUiccCardsInfo());
        // test that these methods don't crash
        if (infos.size() > 0) {
            UiccCardInfo info = infos.get(0);
            info.getIccId();
            info.getEid();
            info.isRemovable();
            info.isEuicc();
            info.getCardId();
            info.getSlotIndex();
        }
    }

    private static Context getContext() {
        return InstrumentationRegistry.getContext();
    }

    /**
     * Tests that the device properly reports the contents of NetworkSelectionMode
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testGetNetworkSelectionMode"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[2]:method_text:[.     * Expects a security exception since the caller does not have carrier privileges.     */   ]) :|: 
    public void testGetNetworkSelectionMode() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }

        try {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    (tm) -> tm.setNetworkSelectionModeAutomatic());
        } catch (Exception e) {
        }

        int networkMode = ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                (tm) -> tm.getNetworkSelectionMode());

        assertEquals(TelephonyManager.NETWORK_SELECTION_MODE_AUTO, networkMode);
    }

    /**
     * Tests that the device properly sets the network selection mode to automatic.
     * Expects a security exception since the caller does not have carrier privileges.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testIsManualNetworkSelectionAllowed"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[1]:method_text:[onAllowed()));    }    /**     * Construct a CallAttributes object and test getters.     */   ]) :|: 
    public void testIsManualNetworkSelectionAllowed() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            Log.d(TAG, ""Skipping test that requires FEATURE_TELEPHONY"");
            return;
        }
        if (mTelephonyManager.getPhoneType() != TelephonyManager.PHONE_TYPE_GSM) return;

        assertTrue(ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                (tm) -> tm.isManualNetworkSelectionAllowed()));
    }

    /**
     * Construct a CallAttributes object and test getters.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testIsPotentialEmergencyNumber"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[2]:method_text:[Tests TelephonyManager.setCallComposerStatus and TelephonyManager.getCallComposerStatus.     */   ]) :|: 
    public void testIsPotentialEmergencyNumber() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }

        String countryIso = mTelephonyManager.getNetworkCountryIso();
        String potentialEmergencyAddress = ""91112345"";
        // According to com.android.i18n.phonenumbers.ShortNumberInfo, in
        // these countries, if extra digits are added to an emergency number,
        // it no longer connects to the emergency service.
        if (countryIso.equals(""br"") || countryIso.equals(""cl"") || countryIso.equals(""ni"")) {
            assertFalse(ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                    (tm) -> tm.isPotentialEmergencyNumber(potentialEmergencyAddress)));
        } else {
            assertTrue(ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                    (tm) -> tm.isPotentialEmergencyNumber(potentialEmergencyAddress)));
        }
    }

    /**
     * Tests TelephonyManager.setCallComposerStatus and TelephonyManager.getCallComposerStatus.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testSetGetCallComposerStatus"	"CtsTelephonyTestCases"	"1: permission"	"([8:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[8]:method_text:[  }    }    /**     * Tests {@link TelephonyManager#getSupportedRadioAccessFamily()}     */   ]) :|: 
    public void testSetGetCallComposerStatus() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }

        boolean hasImsFeature = mPackageManager.hasSystemFeature(
                PackageManager.FEATURE_TELEPHONY_IMS);

        if (hasImsFeature) {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    tm -> tm.setCallComposerStatus(TelephonyManager.CALL_COMPOSER_STATUS_OFF));
            int status = ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                    tm -> tm.getCallComposerStatus());
            assertThat(status).isEqualTo(TelephonyManager.CALL_COMPOSER_STATUS_OFF);

            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    tm -> tm.setCallComposerStatus(TelephonyManager.CALL_COMPOSER_STATUS_ON));
            status = ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                    tm -> tm.getCallComposerStatus());
            assertThat(status).isEqualTo(TelephonyManager.CALL_COMPOSER_STATUS_ON);
        } else {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    tm -> tm.setCallComposerStatus(TelephonyManager.CALL_COMPOSER_STATUS_OFF));
            int status = ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                    tm -> tm.getCallComposerStatus());
            assertThat(status).isEqualTo(TelephonyManager.CALL_COMPOSER_STATUS_OFF);

            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    tm -> tm.setCallComposerStatus(TelephonyManager.CALL_COMPOSER_STATUS_ON));
            status = ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                    tm -> tm.getCallComposerStatus());
            assertThat(status).isEqualTo(TelephonyManager.CALL_COMPOSE"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testGetRadioAccessFamily"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[1]:method_text:[scription} and     * {@link TelephonyManager#getPreferredOpportunisticDataSubscription}     */   ]) :|: 
    public void testGetRadioAccessFamily() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }
        long raf = ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                (tm) -> tm.getSupportedRadioAccessFamily());
        assertThat(raf).isNotEqualTo(TelephonyManager.NETWORK_TYPE_BITMASK_UNKNOWN);
    }

    private static void assertSetOpportunisticSubSuccess(int value) {
        assertThat(value).isEqualTo(TelephonyManager.SET_OPPORTUNISTIC_SUB_SUCCESS);
    }

    private static void assertSetOpportunisticNoOpportunisticSub(int value) {
        assertThat(value).isEqualTo(
                TelephonyManager.SET_OPPORTUNISTIC_SUB_NO_OPPORTUNISTIC_SUB_AVAILABLE);
    }

    /**
     * Tests {@link TelephonyManager#setPreferredOpportunisticDataSubscription} and
     * {@link TelephonyManager#getPreferredOpportunisticDataSubscription}
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testPreferredOpportunisticDataSubscription"	"CtsTelephonyTestCases"	"1: permission"	"([10:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[10]:method_text:[;        }    }    /**     * Tests {@link TelephonyManager#updateAvailableNetworks}     */   ]) :|: 
    public void testPreferredOpportunisticDataSubscription() {
        int randomSubId = 1;
        int activeSubscriptionInfoCount = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mSubscriptionManager, (tm) -> tm.getActiveSubscriptionInfoCount());
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }
        if (mTelephonyManager.getPhoneCount() == 1) {
            return;
        }
        if (mTelephonyManager.getPhoneCount() == 2 && activeSubscriptionInfoCount != 2) {
            return;
        }
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                (tm) -> tm.setPreferredOpportunisticDataSubscription(
                        SubscriptionManager.DEFAULT_SUBSCRIPTION_ID, false,
                        null, null));
        // wait for the data change to take effect
        waitForMs(500);
        int subId =
                ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                        (tm) -> tm.getPreferredOpportunisticDataSubscription());
        assertThat(subId).isEqualTo(SubscriptionManager.DEFAULT_SUBSCRIPTION_ID);
        List<SubscriptionInfo> subscriptionInfoList =
                ShellIdentityUtils.invokeMethodWithShellPermissions(mSubscriptionManager,
                        (tm) -> tm.getOpportunisticSubscriptions());
        Consumer<Integer> callbackSuccess = TelephonyManagerTest::assertSetOpportunisticSubSuccess;
        Consumer<Integer> callbackNoOpSub =
                TelephonyManagerTest::assertSetOpportunisticNoOpportunisticSub;
        if (subscriptionInfoList == null || subscriptionInfoList.size() == 0) {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    (tm) -> tm.setPreferredOpportunisticDataSubscription(randomSubId, false,
                            AsyncTask.SERIAL_EXECUTOR, callbackNoOpSub));
            // wait"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testUpdateAvailableNetworks"	"CtsTelephonyTestCases"	"1: permission"	"([7:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[7]:method_text:[nfos,                            AsyncTask.SERIAL_EXECUTOR, callbackSuccess));        }    }   ]) :|: 
    public void testUpdateAvailableNetworks() {
        int randomSubId = 1;
        int activeSubscriptionInfoCount = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mSubscriptionManager, (tm) -> tm.getActiveSubscriptionInfoCount());
        boolean isOpportunisticNetworkEnabled = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, (tm) -> tm.isOpportunisticNetworkEnabled());

        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }
        if (!isOpportunisticNetworkEnabled) {
            return;
        }
        if (mTelephonyManager.getPhoneCount() == 1) {
            return;
        }
        if (mTelephonyManager.getPhoneCount() == 2 && activeSubscriptionInfoCount != 2) {
            return;
        }

        List<SubscriptionInfo> subscriptionInfoList =
                ShellIdentityUtils.invokeMethodWithShellPermissions(mSubscriptionManager,
                        (tm) -> tm.getOpportunisticSubscriptions());
        List<String> mccMncs = new ArrayList<String>();
        List<Integer> bands = new ArrayList<Integer>();
        List<AvailableNetworkInfo> availableNetworkInfos = new ArrayList<AvailableNetworkInfo>();
        Consumer<Integer> callbackSuccess =
                TelephonyManagerTest::assertUpdateAvailableNetworkSuccess;
        Consumer<Integer> callbackNoOpSub =
                TelephonyManagerTest::assertUpdateAvailableNetworkNoOpportunisticSub;
        if (subscriptionInfoList == null || subscriptionInfoList.size() == 0
                || !mSubscriptionManager.isActiveSubscriptionId(
                subscriptionInfoList.get(0).getSubscriptionId())) {
            AvailableNetworkInfo availableNetworkInfo = new AvailableNetworkInfo(randomSubId,
                    AvailableNetworkInfo.PRIORITY_HIGH, mccMncs, bands);
            availableNetworkInfos.add(availableNetworkInfo);
            ShellIdentityUtils.invokeMethodWithShellPermi"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testSwitchMultiSimConfig"	"CtsTelephonyTestCases"	"1: permission"	"([4:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[4]:method_text:[uld require MODIFY_PHONE_STATE""                    + ""permission to access."");        }    }   ]) :|: 
    public void testSwitchMultiSimConfig() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }
        try {
            mTelephonyManager.switchMultiSimConfig(mTelephonyManager.getActiveModemCount());
            fail(""TelephonyManager#switchMultiSimConfig should require the MODIFY_PHONE_STATE""
                    + "" permission to access."");
        } catch (SecurityException e) {
            // expected
        }
        try {
            // This should result in no-op.
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    (tm) -> tm.switchMultiSimConfig(mTelephonyManager.getActiveModemCount()),
                    SecurityException.class, ""android.permission.MODIFY_PHONE_STATE"");
        } catch (SecurityException e) {
            fail(""TelephonyManager#switchMultiSimConfig should require MODIFY_PHONE_STATE""
                    + ""permission to access."");
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testIccOpenLogicalChannelBySlot"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[1]:method_text:[) {            // IllegalArgumentException is okay, just not SecurityException        }    }   ]) :|: 
    public void testIccOpenLogicalChannelBySlot() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }
        // just verify no crash
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.iccOpenLogicalChannelBySlot(0, null, 0));
        } catch (IllegalArgumentException e) {
            // IllegalArgumentException is okay, just not SecurityException
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testIccCloseLogicalChannelBySlot"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[1]:method_text:[) {            // IllegalArgumentException is okay, just not SecurityException        }    }   ]) :|: 
    public void testIccCloseLogicalChannelBySlot() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }
        // just verify no crash
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.iccCloseLogicalChannelBySlot(0, 0));
        } catch (IllegalArgumentException e) {
            // IllegalArgumentException is okay, just not SecurityException
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testIccTransmitApduLogicalChannelBySlot"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[1]:method_text:[                        null /* data */));        assertTrue(TextUtils.isEmpty(result));    }   ]) :|: 
    public void testIccTransmitApduLogicalChannelBySlot() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }
        int slotIndex = getValidSlotIndex();
        String result = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, (tm) -> tm.iccTransmitApduLogicalChannelBySlot(
                        slotIndex,
                        0 /* channel */,
                        0 /* cla */,
                        0 /* instruction */,
                        0 /* p1 */,
                        0 /* p2 */,
                        0 /* p3 */,
                        null /* data */));
        assertTrue(TextUtils.isEmpty(result));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testIccTransmitApduBasicChannelBySlot"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[1]:method_text:[) {            // IllegalArgumentException is okay, just not SecurityException        }    }   ]) :|: 
    public void testIccTransmitApduBasicChannelBySlot() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }
        // just verify no crash
        int slotIndex = getValidSlotIndex();
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.iccTransmitApduBasicChannelBySlot(
                            slotIndex,
                            0 /* cla */,
                            0 /* instruction */,
                            0 /* p1 */,
                            0 /* p2 */,
                            0 /* p3 */,
                            null /* data */));
        } catch (IllegalArgumentException e ) {
            // IllegalArgumentException is okay, just not SecurityException
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testIsIccLockEnabled"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[2]:method_text:[se) {            fail(""testIsIccLockEnabled: SecurityException not expected"");        }    }   ]) :|: 
    public void testIsIccLockEnabled() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }
        // verify SecurityException
        try {
            mTelephonyManager.isIccLockEnabled();
            fail(""testIsIccLockEnabled: Expected SecurityException on isIccLockEnabled"");
        } catch (SecurityException se) {
            // expected
        }

        // test with permission
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.isIccLockEnabled());
        } catch (SecurityException se) {
            fail(""testIsIccLockEnabled: SecurityException not expected"");
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testIsDataEnabledForApn"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[2]:method_text:[ {            fail(""testIsDataEnabledForApn: SecurityException not expected"");        }    }   ]) :|: 
    public void testIsDataEnabledForApn() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }
        // verify SecurityException
        try {
            mTelephonyManager.isDataEnabledForApn(ApnSetting.TYPE_MMS);
            fail(""testIsDataEnabledForApn: Expected SecurityException on isDataEnabledForApn"");
        } catch (SecurityException se) {
            // expected
        }

        // test with permission
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.isDataEnabledForApn(ApnSetting.TYPE_MMS));
        } catch (SecurityException se) {
            fail(""testIsDataEnabledForApn: SecurityException not expected"");
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testIsTetheringApnRequired"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[2]:method_text:[se) {            fail(""testIsIccLockEnabled: SecurityException not expected"");        }    }   ]) :|: 
    public void testIsTetheringApnRequired() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }
        // verify SecurityException
        try {
            mTelephonyManager.isTetheringApnRequired();
            fail(""testIsTetheringApnRequired: Expected SecurityException on ""
                    + ""isTetheringApnRequired"");
        } catch (SecurityException se) {
            // expected
        }

        // test with permission
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.isTetheringApnRequired());
        } catch (SecurityException se) {
            fail(""testIsIccLockEnabled: SecurityException not expected"");
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testGetCarrierInfoForImsiEncryption"	"CtsTelephonyTestCases"	"1: permission"	"([4:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[4]:method_text:[) {            // IllegalArgumentException is okay, just not SecurityException        }    }   ]) :|: 
    public void testGetCarrierInfoForImsiEncryption() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }
        // test without permission: verify SecurityException
        try {
            mTelephonyManager.getCarrierInfoForImsiEncryption(TelephonyManager.KEY_TYPE_EPDG);
            fail(""testGetCarrierInfoForImsiEncryption: ""
                    + ""SecurityException expected on getCarrierInfoForImsiEncryption"");
        } catch (SecurityException se) {
            // expected
        }
        try {
            mTelephonyManager.getCarrierInfoForImsiEncryption(TelephonyManager.KEY_TYPE_WLAN);
            fail(""testGetCarrierInfoForImsiEncryption: ""
                    + ""SecurityException expected on getCarrierInfoForImsiEncryption"");
        } catch (SecurityException se) {
            // expected
        }
        // test with permission
        PublicKey epdgKey = null;
        PublicKey wlanKey = null;
        try {
            PersistableBundle carrierConfig = mCarrierConfigManager.getConfigForSubId(mTestSub);

            assertNotNull(""CarrierConfigManager#getConfigForSubId() returned null"",
                    carrierConfig);
            assertFalse(""CarrierConfigManager#getConfigForSubId() returned empty bundle"",
                    carrierConfig.isEmpty());

            // purge the certs in carrierConfigs first
            carrierConfig.putInt(
                    CarrierConfigManager.IMSI_KEY_AVAILABILITY_INT, 3);
            carrierConfig.putString(
                    CarrierConfigManager.IMSI_KEY_DOWNLOAD_URL_STRING, BAD_IMSI_CERT_URL);
            carrierConfig.putString(
                    CarrierConfigManager.IMSI_CARRIER_PUBLIC_KEY_EPDG_STRING,
                    IMSI_CERT_STRING_EPDG);
            carrierConfig.putString(
                    CarrierConfigManager.IMSI_CARRIER_PUBLIC_KEY_WLAN_STRING,
                    IMSI_CERT_STRING_WLAN);
            overrideCarrierConfig(c"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testResetCarrierKeysForImsiEncryption"	"CtsTelephonyTestCases"	"1: permission"	"([3:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[3]:method_text:[ fail(""testResetCarrierKeysForImsiEncryption: SecurityException not expected"");        }    }   ]) :|: 
    public void testResetCarrierKeysForImsiEncryption() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }
        // test without permission: verify SecurityException
        try {
            mTelephonyManager.resetCarrierKeysForImsiEncryption();
            fail(""testResetCarrierKeysForImsiEncryption: SecurityException expected"");
        } catch (SecurityException se) {
            // expected
        }
        // test with permission
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                    mTelephonyManager,
                    (tm) -> tm.resetCarrierKeysForImsiEncryption());
        } catch (SecurityException se) {
            fail(""testResetCarrierKeysForImsiEncryption: SecurityException not expected"");
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testIsInEmergencySmsMode"	"CtsTelephonyTestCases"	"1: permission"	"([3:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[3]:method_text:[{            fail(""testIsInEmergencySmsMode: SecurityException not expected"");        }    }   ]) :|: 
    public void testIsInEmergencySmsMode() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }
        // test without permission: verify SecurityException
        try {
            mTelephonyManager.isInEmergencySmsMode();
            fail(""testIsInEmergencySmsMode: SecurityException expected"");
        } catch (SecurityException se) {
            // expected
        }
        // test with permission
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                    mTelephonyManager,
                    (tm) -> tm.isInEmergencySmsMode());
        } catch (SecurityException se) {
            fail(""testIsInEmergencySmsMode: SecurityException not expected"");
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testSetAllowedNetworkTypes"	"CtsTelephonyTestCases"	"1: permission"	"([4:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[4]:method_text:[            fail(""testSetAllowedNetworkTypes: SecurityException not expected"");        }    }   ]) :|: 
    public void testSetAllowedNetworkTypes() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }

        // test without permission: verify SecurityException
        long allowedNetworkTypes = TelephonyManager.NETWORK_TYPE_BITMASK_NR;
        try {
            mTelephonyManager.setAllowedNetworkTypes(allowedNetworkTypes);
            fail(""testSetPolicyDataEnabled: SecurityException expected"");
        } catch (SecurityException se) {
            // expected
        }

        // test with permission
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                    mTelephonyManager,
                    (tm) -> tm.setAllowedNetworkTypes(allowedNetworkTypes));

            long deviceAllowedNetworkTypes = ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> {
                        return tm.getAllowedNetworkTypes();
                    }
            );
            assertEquals(allowedNetworkTypes, deviceAllowedNetworkTypes);
        } catch (SecurityException se) {
            fail(""testSetAllowedNetworkTypes: SecurityException not expected"");
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testDisAllowedNetworkTypes"	"CtsTelephonyTestCases"	"1: permission"	"([4:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[4]:method_text:[            fail(""testDisAllowedNetworkTypes: SecurityException not expected"");        }    }   ]) :|: 
    public void testDisAllowedNetworkTypes() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }

        long allowedNetworkTypes = -1 & (~TelephonyManager.NETWORK_TYPE_BITMASK_NR);
        long networkTypeBitmask = TelephonyManager.NETWORK_TYPE_BITMASK_NR
                | TelephonyManager.NETWORK_TYPE_BITMASK_LTE
                | TelephonyManager.NETWORK_TYPE_BITMASK_LTE_CA;

        try {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                    mTelephonyManager,
                    (tm) -> tm.setAllowedNetworkTypes(allowedNetworkTypes));

            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                    mTelephonyManager,
                    (tm) -> tm.setPreferredNetworkTypeBitmask(networkTypeBitmask));

            long modemNetworkTypeBitmask = ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> {
                        return tm.getPreferredNetworkTypeBitmask();
                    }
            );
            long radioAccessFamily = ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> {
                        return tm.getSupportedRadioAccessFamily();
                    }
            );

            // RadioAccessFamily won't include all bits of RAFs group, so transfer to preferred
            // network type instead of using bitmask directly
            int modemPreferredNetworkType = RadioAccessFamily.getNetworkTypeFromRaf(
                    (int) modemNetworkTypeBitmask);
            int preferredNetworkType = RadioAccessFamily.getNetworkTypeFromRaf(
                    (int) (networkTypeBitmask & allowedNetworkTypes & radioAccessFamily));
            assertEquals(preferredNetworkType, modemPreferredNetworkType);
        } catch (SecurityException se) {
            fail(""testDisAllowedNetworkTypes: SecurityException not expected"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testSetAllowedNetworkTypesForReason"	"CtsTelephonyTestCases"	"1: permission"	"([4:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[4]:method_text:[            fail(""testSetAllowedNetworkTypes: SecurityException not expected"");        }    }   ]) :|: 
    public void testSetAllowedNetworkTypesForReason() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }

        // test without permission: verify SecurityException
        long allowedNetworkTypes = TelephonyManager.NETWORK_TYPE_BITMASK_NR;
        try {
            mIsAllowedNetworkTypeChanged = true;
            mTelephonyManager.setAllowedNetworkTypesForReason(
                    TelephonyManager.ALLOWED_NETWORK_TYPES_REASON_POWER, allowedNetworkTypes);
            fail(""testSetPolicyDataEnabled: SecurityException expected"");
        } catch (SecurityException se) {
            // expected
        }

        // test with permission
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                    mTelephonyManager,
                    (tm) -> tm.setAllowedNetworkTypesForReason(
                            TelephonyManager.ALLOWED_NETWORK_TYPES_REASON_POWER,
                            allowedNetworkTypes));

            long deviceAllowedNetworkTypes = ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> {
                        return tm.getAllowedNetworkTypesForReason(
                                TelephonyManager.ALLOWED_NETWORK_TYPES_REASON_POWER);
                    }
            );
            assertEquals(allowedNetworkTypes, deviceAllowedNetworkTypes);
        } catch (SecurityException se) {
            fail(""testSetAllowedNetworkTypes: SecurityException not expected"");
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testSetAllowedNetworkTypesForReason_moreReason"	"CtsTelephonyTestCases"	"1: permission"	"([9:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[9]:method_text:[            fail(""testSetAllowedNetworkTypes: SecurityException not expected"");        }    }   ]) :|: 
    public void testSetAllowedNetworkTypesForReason_moreReason() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }

        // test without permission: verify SecurityException
        long allowedNetworkTypes1 = TelephonyManager.NETWORK_TYPE_BITMASK_NR
                | TelephonyManager.NETWORK_TYPE_BITMASK_UMTS;
        long allowedNetworkTypes2 = TelephonyManager.NETWORK_TYPE_BITMASK_LTE
                | TelephonyManager.NETWORK_TYPE_BITMASK_LTE_CA;
        long allowedNetworkTypes3 = TelephonyManager.NETWORK_TYPE_BITMASK_NR
                | TelephonyManager.NETWORK_TYPE_BITMASK_LTE
                | TelephonyManager.NETWORK_TYPE_BITMASK_UMTS;
        long allowedNetworkTypes4 = TelephonyManager.NETWORK_TYPE_LTE
                | TelephonyManager.NETWORK_TYPE_EVDO_B;

        try {
            mIsAllowedNetworkTypeChanged = true;
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                    mTelephonyManager,
                    (tm) -> tm.setAllowedNetworkTypesForReason(
                            TelephonyManager.ALLOWED_NETWORK_TYPES_REASON_POWER,
                            allowedNetworkTypes1));

            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                    mTelephonyManager,
                    (tm) -> tm.setAllowedNetworkTypesForReason(
                            TelephonyManager.ALLOWED_NETWORK_TYPES_REASON_USER,
                            allowedNetworkTypes2));
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                    mTelephonyManager,
                    (tm) -> tm.setAllowedNetworkTypesForReason(
                            TelephonyManager.ALLOWED_NETWORK_TYPES_REASON_CARRIER,
                            allowedNetworkTypes3));
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                    mTelephonyManager,
                    (tm) -> tm.setAllowedNetwo"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testIsApplicationOnUicc"	"CtsTelephonyTestCases"	"1: permission"	"([4:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[4]:method_text:[ntation().getUiAutomation()                    .dropShellPermissionIdentity();        }    }   ]) :|: 
    public void testIsApplicationOnUicc() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }

        // Expect a security exception without permission.
        try {
            mTelephonyManager.isApplicationOnUicc(TelephonyManager.APPTYPE_SIM);
            fail(""Expected security exception"");
        } catch (SecurityException se1) {
            // Expected
        }

        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(""android.permission.READ_PRIVILEGED_PHONE_STATE"");
        try {
            mTelephonyManager.isApplicationOnUicc(TelephonyManager.APPTYPE_SIM);
        } catch (SecurityException se) {
            fail(""Caller with READ_PRIVILEGED_PHONE_STATE should be able to call API"");
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                    .dropShellPermissionIdentity();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testRequestModemActivityInfo"	"CtsTelephonyTestCases"	"1: permission"	"([3:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[3]:method_text:[ntation().getUiAutomation()                    .dropShellPermissionIdentity();        }    }   ]) :|: 
    public void testRequestModemActivityInfo() throws Exception {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }

        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(""android.permission.MODIFY_PHONE_STATE"");
        try {
            // Get one instance of activity info and make sure it's valid
            CompletableFuture<ModemActivityInfo> future1 = new CompletableFuture<>();
            mTelephonyManager.requestModemActivityInfo(getContext().getMainExecutor(),
                    future1::complete);
            ModemActivityInfo activityInfo1 = future1.get(TOLERANCE, TimeUnit.MILLISECONDS);
            assertNotNull(activityInfo1);
            assertTrue(""first activity info is"" + activityInfo1, activityInfo1.isValid());

            // Wait a bit, then get another instance to make sure that some info has accumulated
            CompletableFuture<ModemActivityInfo> future2 = new CompletableFuture<>();
            mTelephonyManager.requestModemActivityInfo(getContext().getMainExecutor(),
                    future2::complete);
            ModemActivityInfo activityInfo2 = future2.get(TOLERANCE, TimeUnit.MILLISECONDS);
            assertNotNull(activityInfo2);
            assertTrue(""second activity info is"" + activityInfo2, activityInfo2.isValid());

            ModemActivityInfo diff = activityInfo1.getDelta(activityInfo2);
            assertNotNull(diff);
            assertTrue(""diff is"" + diff, diff.isValid() || diff.isEmpty());
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                    .dropShellPermissionIdentity();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testOpportunisticNetworkState"	"CtsTelephonyTestCases"	"1: permission"	"([6:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[6]:method_text:[urn(mTelephonyManager,                tm -> tm.setOpportunisticNetworkState(isEnabled));    }   ]) :|: 
    public void testOpportunisticNetworkState() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }
        if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_WATCH)) {
            return;
        }

        boolean isEnabled = ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                tm -> tm.isOpportunisticNetworkEnabled());
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                tm -> tm.setOpportunisticNetworkState(true));
        assertTrue(ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                tm -> tm.isOpportunisticNetworkEnabled()));
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                tm -> tm.setOpportunisticNetworkState(false));
        assertFalse(ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                tm -> tm.isOpportunisticNetworkEnabled()));
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                tm -> tm.setOpportunisticNetworkState(isEnabled));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testGetSimCardState"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[1]:method_text:[WithShellPermissions(mTelephonyManager,                TelephonyManager::isDataEnabled);    }   ]) :|: 
    public void testGetSimCardState() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }
        int simCardState = mTelephonyManager.getSimCardState();
        assertTrue(Arrays.asList(TelephonyManager.SIM_STATE_UNKNOWN,
                TelephonyManager.SIM_STATE_ABSENT,
                TelephonyManager.SIM_STATE_CARD_IO_ERROR,
                TelephonyManager.SIM_STATE_CARD_RESTRICTED,
                TelephonyManager.SIM_STATE_PRESENT).contains(simCardState));
    }

    private boolean isDataEnabled() {
        return ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                TelephonyManager::isDataEnabled);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testThermalDataEnable"	"CtsTelephonyTestCases"	"1: permission"	"([6:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[6]:method_text:[er, (tm) -> tm.isDataConnectionAllowed());        assertTrue(isDataConnectionAvailable);    }   ]) :|: 
    public void testThermalDataEnable() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }

        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                mTelephonyManager,
                (tm) -> tm.setDataEnabledForReason(TelephonyManager.DATA_ENABLED_REASON_THERMAL,
                        false));

        boolean isDataEnabledForReason = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, (tm) -> tm.isDataEnabledForReason(
                        TelephonyManager.DATA_ENABLED_REASON_THERMAL));
        assertFalse(isDataEnabledForReason);

        boolean isDataConnectionAvailable = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, (tm) -> tm.isDataConnectionAllowed());
        assertFalse(isDataConnectionAvailable);

        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                mTelephonyManager,
                (tm) -> tm.setDataEnabledForReason(TelephonyManager.DATA_ENABLED_REASON_THERMAL,
                        true));

        isDataEnabledForReason = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, (tm) -> tm.isDataEnabledForReason(
                        TelephonyManager.DATA_ENABLED_REASON_THERMAL));
        assertTrue(isDataEnabledForReason);

        isDataConnectionAvailable = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, (tm) -> tm.isDataConnectionAllowed());
        assertTrue(isDataConnectionAvailable);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testPolicyDataEnable"	"CtsTelephonyTestCases"	"1: permission"	"([6:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[6]:method_text:[er, (tm) -> tm.isDataConnectionAllowed());        assertTrue(isDataConnectionAvailable);    }   ]) :|: 
    public void testPolicyDataEnable() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }

        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                mTelephonyManager,
                (tm) -> tm.setDataEnabledForReason(TelephonyManager.DATA_ENABLED_REASON_POLICY,
                        false));

        boolean isDataEnabledForReason = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, (tm) -> tm.isDataEnabledForReason(
                        TelephonyManager.DATA_ENABLED_REASON_POLICY));
        assertFalse(isDataEnabledForReason);

        boolean isDataConnectionAvailable = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, (tm) -> tm.isDataConnectionAllowed());
        assertFalse(isDataConnectionAvailable);

        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                mTelephonyManager,
                (tm) -> tm.setDataEnabledForReason(TelephonyManager.DATA_ENABLED_REASON_POLICY,
                        true));

        isDataEnabledForReason = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, (tm) -> tm.isDataEnabledForReason(
                        TelephonyManager.DATA_ENABLED_REASON_POLICY));
        assertTrue(isDataEnabledForReason);

        isDataConnectionAvailable = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, (tm) -> tm.isDataConnectionAllowed());
        assertTrue(isDataConnectionAvailable);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testCarrierDataEnable"	"CtsTelephonyTestCases"	"1: permission"	"([6:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[6]:method_text:[er, (tm) -> tm.isDataConnectionAllowed());        assertTrue(isDataConnectionAvailable);    }   ]) :|: 
    public void testCarrierDataEnable() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }

        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                mTelephonyManager,
                (tm) -> tm.setDataEnabledForReason(TelephonyManager.DATA_ENABLED_REASON_CARRIER,
                        false));

        waitForMs(500);
        boolean isDataEnabledForReason = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, (tm) -> tm.isDataEnabledForReason(
                        TelephonyManager.DATA_ENABLED_REASON_CARRIER));
        assertFalse(isDataEnabledForReason);

        boolean isDataConnectionAvailable = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, (tm) -> tm.isDataConnectionAllowed());
        assertFalse(isDataConnectionAvailable);

        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                mTelephonyManager,
                (tm) -> tm.setDataEnabledForReason(TelephonyManager.DATA_ENABLED_REASON_CARRIER,
                        true));

        waitForMs(500);
        isDataEnabledForReason = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, (tm) -> tm.isDataEnabledForReason(
                        TelephonyManager.DATA_ENABLED_REASON_CARRIER));
        assertTrue(isDataEnabledForReason);
        isDataConnectionAvailable = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, (tm) -> tm.isDataConnectionAllowed());
        assertTrue(isDataConnectionAvailable);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testUserDataEnable"	"CtsTelephonyTestCases"	"1: permission"	"([6:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[6]:method_text:[er, (tm) -> tm.isDataConnectionAllowed());        assertTrue(isDataConnectionAvailable);    }   ]) :|: 
    public void testUserDataEnable() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }

        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                mTelephonyManager,
                (tm) -> tm.setDataEnabledForReason(TelephonyManager.DATA_ENABLED_REASON_USER,
                        false));

        waitForMs(500);
        boolean isDataEnabledForReason = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, (tm) -> tm.isDataEnabledForReason(
                        TelephonyManager.DATA_ENABLED_REASON_USER));
        assertFalse(isDataEnabledForReason);

        boolean isDataConnectionAvailable = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, (tm) -> tm.isDataConnectionAllowed());
        assertFalse(isDataConnectionAvailable);

        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                mTelephonyManager,
                (tm) -> tm.setDataEnabledForReason(TelephonyManager.DATA_ENABLED_REASON_USER,
                        true));

        waitForMs(500);
        isDataEnabledForReason = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, (tm) -> tm.isDataEnabledForReason(
                        TelephonyManager.DATA_ENABLED_REASON_USER));
        assertTrue(isDataEnabledForReason);
        isDataConnectionAvailable = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, (tm) -> tm.isDataConnectionAllowed());
        assertTrue(isDataConnectionAvailable);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testDataDuringVoiceCallPolicy"	"CtsTelephonyTestCases"	"1: permission"	"([6:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[6]:method_text:[MethodWithShellPermissions(                        mTelephonyManager, getPolicyHelper));    }   ]) :|: 
    public void testDataDuringVoiceCallPolicy() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }

        ShellIdentityUtils.ShellPermissionMethodHelper<Boolean, TelephonyManager> getPolicyHelper =
                (tm) -> tm.isMobileDataPolicyEnabled(
                        TelephonyManager.MOBILE_DATA_POLICY_DATA_ON_NON_DEFAULT_DURING_VOICE_CALL);

        boolean allowDataDuringVoiceCall = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, getPolicyHelper);

        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                mTelephonyManager, (tm) -> tm.setMobileDataPolicyEnabled(
                        TelephonyManager.MOBILE_DATA_POLICY_DATA_ON_NON_DEFAULT_DURING_VOICE_CALL,
                        !allowDataDuringVoiceCall));

        assertNotEquals(allowDataDuringVoiceCall,
                ShellIdentityUtils.invokeMethodWithShellPermissions(
                        mTelephonyManager, getPolicyHelper));

        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                mTelephonyManager, (tm) -> tm.setMobileDataPolicyEnabled(
                        TelephonyManager.MOBILE_DATA_POLICY_DATA_ON_NON_DEFAULT_DURING_VOICE_CALL,
                        allowDataDuringVoiceCall));

        assertEquals(allowDataDuringVoiceCall,
                ShellIdentityUtils.invokeMethodWithShellPermissions(
                        mTelephonyManager, getPolicyHelper));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testAlwaysAllowMmsDataPolicy"	"CtsTelephonyTestCases"	"1: permission"	"([6:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[6]:method_text:[MethodWithShellPermissions(                        mTelephonyManager, getPolicyHelper));    }   ]) :|: 
    public void testAlwaysAllowMmsDataPolicy() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }

        ShellIdentityUtils.ShellPermissionMethodHelper<Boolean, TelephonyManager> getPolicyHelper =
                (tm) -> tm.isMobileDataPolicyEnabled(
                        TelephonyManager.MOBILE_DATA_POLICY_MMS_ALWAYS_ALLOWED);

        boolean mmsAlwaysAllowed = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, getPolicyHelper);

        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                mTelephonyManager, (tm) -> tm.setMobileDataPolicyEnabled(
                        TelephonyManager.MOBILE_DATA_POLICY_MMS_ALWAYS_ALLOWED,
                        !mmsAlwaysAllowed));

        assertNotEquals(mmsAlwaysAllowed,
                ShellIdentityUtils.invokeMethodWithShellPermissions(
                        mTelephonyManager, getPolicyHelper));

        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                mTelephonyManager, (tm) -> tm.setMobileDataPolicyEnabled(
                        TelephonyManager.MOBILE_DATA_POLICY_MMS_ALWAYS_ALLOWED,
                        mmsAlwaysAllowed));

        assertEquals(mmsAlwaysAllowed,
                ShellIdentityUtils.invokeMethodWithShellPermissions(
                        mTelephonyManager, getPolicyHelper));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testGetCdmaEnhancedRoamingIndicatorDisplayNumber"	"CtsTelephonyTestCases"	"1: permission"	"([3:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[3]:method_text:[{            assertFalse(isNrDualConnectivityEnabled);        }        return result;    }   ]) :|: 
    public void testGetCdmaEnhancedRoamingIndicatorDisplayNumber() {
        int index = mTelephonyManager.getCdmaEnhancedRoamingIndicatorDisplayNumber();
        int phoneType = mTelephonyManager.getPhoneType();
        if (phoneType == TelephonyManager.PHONE_TYPE_CDMA) {
            assertTrue(index >= 0 && index <= 255);
        } else {
            assertEquals(-1, index);
        }
    }

    private int disableNrDualConnectivity() {
        if (!ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, (tm) -> tm.isRadioInterfaceCapabilitySupported(
                        TelephonyManager
                                .CAPABILITY_NR_DUAL_CONNECTIVITY_CONFIGURATION_AVAILABLE))) {
            return TelephonyManager.ENABLE_NR_DUAL_CONNECTIVITY_NOT_SUPPORTED;
        }

        int result = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager,
                (tm) -> tm.setNrDualConnectivityState(
                        TelephonyManager.NR_DUAL_CONNECTIVITY_DISABLE));

        boolean isNrDualConnectivityEnabled =
                ShellIdentityUtils.invokeMethodWithShellPermissions(
                        mTelephonyManager, (tm) -> tm.isNrDualConnectivityEnabled());
        // Only verify the result for supported devices on IRadio 1.6+
        if (mRadioVersion >= RADIO_HAL_VERSION_1_6
                && result != TelephonyManager.ENABLE_NR_DUAL_CONNECTIVITY_NOT_SUPPORTED) {
            assertFalse(isNrDualConnectivityEnabled);
        }

        return result;
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testNrDualConnectivityEnable"	"CtsTelephonyTestCases"	"1: permission"	"([4:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[4]:method_text:[ }        if (!isInitiallyEnabled) {            disableNrDualConnectivity();        }    }   ]) :|: 
    public void testNrDualConnectivityEnable() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }

        if (!ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, (tm) -> tm.isRadioInterfaceCapabilitySupported(
                        TelephonyManager
                                .CAPABILITY_NR_DUAL_CONNECTIVITY_CONFIGURATION_AVAILABLE))) {
            return;
        }

        boolean isInitiallyEnabled = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, (tm) -> tm.isNrDualConnectivityEnabled());
        boolean isNrDualConnectivityEnabled;
        int result;
        if (isInitiallyEnabled) {
            result = disableNrDualConnectivity();
            if (result == TelephonyManager.ENABLE_NR_DUAL_CONNECTIVITY_NOT_SUPPORTED) {
                return;
            }
        }


        result = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager,
                (tm) -> tm.setNrDualConnectivityState(
                        TelephonyManager.NR_DUAL_CONNECTIVITY_ENABLE));

        if (result == TelephonyManager.ENABLE_NR_DUAL_CONNECTIVITY_NOT_SUPPORTED) {
            return;
        }

        isNrDualConnectivityEnabled = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, (tm) -> tm.isNrDualConnectivityEnabled());
        // Only verify the result for supported devices on IRadio 1.6+
        if (mRadioVersion >= RADIO_HAL_VERSION_1_6) {
            assertTrue(isNrDualConnectivityEnabled);
        }

        if (!isInitiallyEnabled) {
            disableNrDualConnectivity();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testCdmaRoamingMode"	"CtsTelephonyTestCases"	"1: permission"	"([6:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[6]:method_text:[oReturn(mTelephonyManager,                tm -> tm.setCdmaRoamingMode(cdmaRoamingMode));    }   ]) :|: 
    public void testCdmaRoamingMode() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)
                || mTelephonyManager.getPhoneType() != TelephonyManager.PHONE_TYPE_CDMA) {
            return;
        }

        // Save state
        int cdmaRoamingMode = ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                TelephonyManager::getCdmaRoamingMode);

        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                tm -> tm.setCdmaRoamingMode(TelephonyManager.CDMA_ROAMING_MODE_HOME));
        assertEquals(TelephonyManager.CDMA_ROAMING_MODE_HOME,
                (int) ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                        TelephonyManager::getCdmaRoamingMode));
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                tm -> tm.setCdmaRoamingMode(TelephonyManager.CDMA_ROAMING_MODE_AFFILIATED));
        assertEquals(TelephonyManager.CDMA_ROAMING_MODE_AFFILIATED,
                (int) ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                        TelephonyManager::getCdmaRoamingMode));

        // Reset state
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                tm -> tm.setCdmaRoamingMode(cdmaRoamingMode));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testCdmaSubscriptionMode"	"CtsTelephonyTestCases"	"1: permission"	"([6:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[6]:method_text:[elephonyManager,                tm -> tm.setCdmaSubscriptionMode(cdmaSubscriptionMode));    }   ]) :|: 
    public void testCdmaSubscriptionMode() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)
                || mTelephonyManager.getPhoneType() != TelephonyManager.PHONE_TYPE_CDMA) {
            return;
        }

        // Save state
        int cdmaSubscriptionMode = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, TelephonyManager::getCdmaSubscriptionMode);

        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                tm -> tm.setCdmaSubscriptionMode(TelephonyManager.CDMA_SUBSCRIPTION_NV));
        assertEquals(TelephonyManager.CDMA_SUBSCRIPTION_NV,
                (int) ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                        TelephonyManager::getCdmaSubscriptionMode));
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                tm -> tm.setCdmaSubscriptionMode(TelephonyManager.CDMA_SUBSCRIPTION_RUIM_SIM));
        assertEquals(TelephonyManager.CDMA_SUBSCRIPTION_RUIM_SIM,
                (int) ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                        TelephonyManager::getCdmaSubscriptionMode));

        // Reset state
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                tm -> tm.setCdmaSubscriptionMode(cdmaSubscriptionMode));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testPinResult"	"CtsTelephonyTestCases"	"1: permission"	"([7:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[7]:method_text:[Result.PIN_RESULT_TYPE_FAILURE);        assertTrue(result.getAttemptsRemaining() >= -1);    }   ]) :|: 
    public void testPinResult() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }
        final String empty_pin = """"; // For getting current remaining pin attempt.
        final String pin = ""fake_pin"";
        final String puk = ""fake_puk"";
        final String newPin = ""fake_new_pin"";

        //Refer GSM 02.17  5.6 PIN Manangement
        //To avoid that sim may enter PUK state,
        //TC should be allowed when current Pin attempt count is reset with 3.
        boolean isEnabled = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, TelephonyManager::isIccLockEnabled);
        PinResult result = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, (tm) -> tm.supplyIccLockPin(empty_pin));
        assertTrue(result.getResult() == PinResult.PIN_RESULT_TYPE_SUCCESS);
        if(result.getAttemptsRemaining() < 3){
            Log.d(TAG, ""Skipping test and requires that reboot device and unlock pin successfully"");
            return;
        }

        result = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, (tm) -> tm.setIccLockEnabled(!isEnabled, pin));
        assertTrue(result.getResult() == PinResult.PIN_RESULT_TYPE_INCORRECT
                || result.getResult() == PinResult.PIN_RESULT_TYPE_FAILURE);
        assertTrue(result.getAttemptsRemaining() >= -1);
        assertEquals(isEnabled, ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, TelephonyManager::isIccLockEnabled));

        result = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, (tm) -> tm.changeIccLockPin(pin, newPin));
        assertTrue(result.getResult() == PinResult.PIN_RESULT_TYPE_INCORRECT
                || result.getResult() == PinResult.PIN_RESULT_TYPE_FAILURE);
        assertTrue(result.getAttemptsRemaining() >= -1);

        result = Shel"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testSetSignalStrengthUpdateRequest_noPermission"	"CtsTelephonyTestCases"	"1: permission"	"([3:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[3]:method_text:[MODIFY_PHONE_STATE permission"");        } catch (SecurityException expected) {        }    }   ]) :|: 
    public void testSetSignalStrengthUpdateRequest_noPermission() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            Log.d(TAG, ""skipping test on device without FEATURE_TELEPHONY present"");
            return;
        }

        final SignalStrengthUpdateRequest normalRequest =
                new SignalStrengthUpdateRequest.Builder()
                        .setSignalThresholdInfos(List.of(
                                new SignalThresholdInfo.Builder()
                                        .setRadioAccessNetworkType(
                                                AccessNetworkConstants.AccessNetworkType.GERAN)
                                        .setSignalMeasurementType(
                                                SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI)
                                        .setThresholds(new int[]{-113, -103, -97, -51})
                                        .build()))
                        .setReportingRequestedWhileIdle(true)
                        .build();

        // Verify SE throws for apps without carrier privilege or MODIFY_PHONE_STATE permission
        try {
            mTelephonyManager.setSignalStrengthUpdateRequest(normalRequest);
            fail(""SecurityException expected when setSignalStrengthUpdateRequest without ""
                    + ""carrier privilege or MODIFY_PHONE_STATE permission"");
        } catch (SecurityException expected) {
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testSetSignalStrengthUpdateRequest_systemThresholdReportingRequestedWhileIdle"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[2]:method_text:[n(mTelephonyManager,                (tm) -> tm.setSignalStrengthUpdateRequest(request));    }   ]) :|: 
    public void testSetSignalStrengthUpdateRequest_systemThresholdReportingRequestedWhileIdle() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            Log.d(TAG, ""skipping test on device without FEATURE_TELEPHONY present"");
            return;
        }

        // Verify system privileged app with permission LISTEN_ALWAYS_REPORTED_SIGNAL_STRENGTH can
        // set systemThresholdReportingRequestedWhileIdle to true with empty thresholdInfos
        SignalStrengthUpdateRequest request = new SignalStrengthUpdateRequest.Builder()
                .setSignalThresholdInfos(Collections.EMPTY_LIST)
                .setSystemThresholdReportingRequestedWhileIdle(true)
                .build();

        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                (tm) -> tm.setSignalStrengthUpdateRequest(request));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testSetSignalStrengthUpdateRequest_hysteresisDbSet"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[1]:method_text:[            + ""to true"");        } catch (IllegalArgumentException expected) {        }    }   ]) :|: 
    public void testSetSignalStrengthUpdateRequest_hysteresisDbSet() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            Log.d(TAG, ""skipping test on device without FEATURE_TELEPHONY present"");
            return;
        }

        // Verify SE throws for app when set hysteresisDb in the SignalThresholdInfo
        SignalStrengthUpdateRequest requestWithHysteresisDbSet =
                new SignalStrengthUpdateRequest.Builder()
                        .setSignalThresholdInfos(List.of(
                                new SignalThresholdInfo.Builder()
                                        .setRadioAccessNetworkType(
                                                AccessNetworkConstants.AccessNetworkType.GERAN)
                                        .setSignalMeasurementType(
                                                SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI)
                                        .setThresholds(new int[]{-113, -103, -97, -51})
                                        .setHysteresisDb(10) //allowed for system caller only
                                        .build()))
                        .setReportingRequestedWhileIdle(true)
                        .build();
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    (tm) -> tm.setSignalStrengthUpdateRequest(requestWithHysteresisDbSet));
            fail(""IllegalArgumentException expected when set hysteresisDb in SignalThresholdInfo ""
                    + ""to true"");
        } catch (IllegalArgumentException expected) {
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testSetSignalStrengthUpdateRequest_hysteresisMsSet"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[1]:method_text:[            + ""to true"");        } catch (IllegalArgumentException expected) {        }    }   ]) :|: 
    public void testSetSignalStrengthUpdateRequest_hysteresisMsSet() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            Log.d(TAG, ""skipping test on device without FEATURE_TELEPHONY present"");
            return;
        }

        // Verify SE throws for app when set hysteresisMs in the SignalThresholdInfo
        SignalStrengthUpdateRequest requestWithHysteresisMsSet =
                new SignalStrengthUpdateRequest.Builder()
                        .setSignalThresholdInfos(List.of(
                                new SignalThresholdInfo.Builder()
                                        .setRadioAccessNetworkType(
                                                AccessNetworkConstants.AccessNetworkType.GERAN)
                                        .setSignalMeasurementType(
                                                SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI)
                                        .setThresholds(new int[]{-113, -103, -97, -51})
                                        .setHysteresisMs(1000) //allowed for system caller only
                                        .build()))
                        .setReportingRequestedWhileIdle(true)
                        .build();
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    (tm) -> tm.setSignalStrengthUpdateRequest(requestWithHysteresisMsSet));
            fail(""IllegalArgumentException expected when set hysteresisMs in SignalThresholdInfo ""
                    + ""to true"");
        } catch (IllegalArgumentException expected) {
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testSetSignalStrengthUpdateRequest_isEnabledSet"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[1]:method_text:[          + ""with true"");        } catch (IllegalArgumentException expected) {        }    }   ]) :|: 
    public void testSetSignalStrengthUpdateRequest_isEnabledSet() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            Log.d(TAG, ""skipping test on device without FEATURE_TELEPHONY present"");
            return;
        }

        // Verify SE throws for app when set isEnabled in the SignalThresholdInfo
        SignalStrengthUpdateRequest requestWithThresholdIsEnabledSet =
                new SignalStrengthUpdateRequest.Builder()
                        .setSignalThresholdInfos(List.of(
                                new SignalThresholdInfo.Builder()
                                        .setRadioAccessNetworkType(
                                                AccessNetworkConstants.AccessNetworkType.GERAN)
                                        .setSignalMeasurementType(
                                                SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI)
                                        .setThresholds(new int[]{-113, -103, -97})
                                        .setIsEnabled(true) //allowed for system caller only
                                        .build()))
                        .setReportingRequestedWhileIdle(true)
                        .build();
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    (tm) -> tm.setSignalStrengthUpdateRequest(requestWithThresholdIsEnabledSet));
            fail(""IllegalArgumentException expected when set isEnabled in SignalThresholdInfo ""
                    + ""with true"");
        } catch (IllegalArgumentException expected) {
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testSetSignalStrengthUpdateRequest_tooShortThresholds"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[1]:method_text:[olds that is too short"");        } catch (IllegalArgumentException expected) {        }    }   ]) :|: 
    public void testSetSignalStrengthUpdateRequest_tooShortThresholds() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            Log.d(TAG, ""skipping test on device without FEATURE_TELEPHONY present"");
            return;
        }

        // verify SE throws if app set too short thresholds
        SignalStrengthUpdateRequest requestWithTooShortThresholds =
                new SignalStrengthUpdateRequest.Builder()
                        .setSignalThresholdInfos(List.of(
                                new SignalThresholdInfo.Builder()
                                        .setRadioAccessNetworkType(
                                                AccessNetworkConstants.AccessNetworkType.GERAN)
                                        .setSignalMeasurementType(
                                                SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI)
                                        .setThresholds(new int[]{}, true /*isSystem*/)
                                        .build()))
                        .setReportingRequestedWhileIdle(true)
                        .build();
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    (tm) -> tm.setSignalStrengthUpdateRequest(requestWithTooShortThresholds));
            fail(""IllegalArgumentException expected when set thresholds that is too short"");
        } catch (IllegalArgumentException expected) {
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testSetSignalStrengthUpdateRequest_tooLongThresholds"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[1]:method_text:[holds that is too long"");        } catch (IllegalArgumentException expected) {        }    }   ]) :|: 
    public void testSetSignalStrengthUpdateRequest_tooLongThresholds() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            Log.d(TAG, ""skipping test on device without FEATURE_TELEPHONY present"");
            return;
        }

        // verify SE throws if app set too long thresholds
        SignalStrengthUpdateRequest requestWithTooLongThresholds =
                new SignalStrengthUpdateRequest.Builder()
                        .setSignalThresholdInfos(List.of(
                                new SignalThresholdInfo.Builder()
                                        .setRadioAccessNetworkType(
                                                AccessNetworkConstants.AccessNetworkType.GERAN)
                                        .setSignalMeasurementType(
                                                SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI)
                                        .setThresholds(new int[]{-113, -103, -97, -61, -51},
                                            true /*isSystem*/)
                                        .build()))
                        .setReportingRequestedWhileIdle(true)
                        .build();
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    (tm) -> tm.setSignalStrengthUpdateRequest(requestWithTooLongThresholds));
            fail(""IllegalArgumentException expected when set thresholds that is too long"");
        } catch (IllegalArgumentException expected) {
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testSetSignalStrengthUpdateRequest_duplicatedRequest"	"CtsTelephonyTestCases"	"1: permission"	"([3:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[3]:method_text:[                   (tm) -> tm.clearSignalStrengthUpdateRequest(normalRequest));        }    }   ]) :|: 
    public void testSetSignalStrengthUpdateRequest_duplicatedRequest() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            Log.d(TAG, ""skipping test on device without FEATURE_TELEPHONY present"");
            return;
        }

        final SignalStrengthUpdateRequest normalRequest =
                new SignalStrengthUpdateRequest.Builder()
                        .setSignalThresholdInfos(List.of(
                                new SignalThresholdInfo.Builder()
                                        .setRadioAccessNetworkType(
                                                AccessNetworkConstants.AccessNetworkType.GERAN)
                                        .setSignalMeasurementType(
                                                SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI)
                                        .setThresholds(new int[]{-113, -103, -97, -51})
                                        .build()))
                        .setReportingRequestedWhileIdle(true)
                        .build();

        // Verify IllegalStateException should throw when set the same request twice
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                (tm) -> tm.setSignalStrengthUpdateRequest(normalRequest));
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    (tm) -> tm.setSignalStrengthUpdateRequest(normalRequest));
            fail(""IllegalStateException expected when setSignalStrengthUpdateRequest twice with ""
                    + ""same request object"");
        } catch (IllegalStateException expected) {
        } finally {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                    (tm) -> tm.clearSignalStrengthUpdateRequest(normalRequest));
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testClearSignalStrengthUpdateRequest_noPermission"	"CtsTelephonyTestCases"	"1: permission"	"([3:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[3]:method_text:[MODIFY_PHONE_STATE permission"");        } catch (SecurityException expected) {        }    }   ]) :|: 
    public void testClearSignalStrengthUpdateRequest_noPermission() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            Log.d(TAG, ""skipping test on device without FEATURE_TELEPHONY present"");
            return;
        }

        final SignalStrengthUpdateRequest normalRequest =
                new SignalStrengthUpdateRequest.Builder()
                        .setSignalThresholdInfos(List.of(
                                new SignalThresholdInfo.Builder()
                                        .setRadioAccessNetworkType(
                                                AccessNetworkConstants.AccessNetworkType.GERAN)
                                        .setSignalMeasurementType(
                                                SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI)
                                        .setThresholds(new int[]{-113, -103, -97, -51})
                                        .build()))
                        .setReportingRequestedWhileIdle(true)
                        .build();

        // Verify SE throws for apps without carrier privilege or MODIFY_PHONE_STATE permission
        try {
            mTelephonyManager.clearSignalStrengthUpdateRequest(normalRequest);
            fail(""SecurityException expected when clearSignalStrengthUpdateRequest without ""
                    + ""carrier privilege or MODIFY_PHONE_STATE permission"");
        } catch (SecurityException expected) {
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testClearSignalStrengthUpdateRequest_clearWithNoSet"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[1]:method_text:[ger,                (tm) -> tm.clearSignalStrengthUpdateRequest(requestNeverSetBefore));    }   ]) :|: 
    public void testClearSignalStrengthUpdateRequest_clearWithNoSet() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            Log.d(TAG, ""skipping test on device without FEATURE_TELEPHONY present"");
            return;
        }

        SignalStrengthUpdateRequest requestNeverSetBefore = new SignalStrengthUpdateRequest
                .Builder()
                .setSignalThresholdInfos(List.of(new SignalThresholdInfo.Builder()
                        .setRadioAccessNetworkType(AccessNetworkConstants.AccessNetworkType.GERAN)
                        .setSignalMeasurementType(SignalThresholdInfo.SIGNAL_MEASUREMENT_TYPE_RSSI)
                        .setThresholds(new int[]{-113, -103, -97, -51})
                        .build()))
                .setReportingRequestedWhileIdle(true)
                .build();

        // Verify clearSignalStrengthUpdateRequest is no-op when clear request that was not set
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                (tm) -> tm.clearSignalStrengthUpdateRequest(requestNeverSetBefore));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testSendThermalMitigationRequest"	"CtsTelephonyTestCases"	"1: permission"	"([7:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[7]:method_text:[                     .build()));        } catch (IllegalArgumentException e) {        }    }   ]) :|: 
    public void testSendThermalMitigationRequest() throws Exception {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }

        StringBuilder cmdBuilder = new StringBuilder();
        cmdBuilder.append(THERMAL_MITIGATION_COMMAND_BASE).append(ALLOW_PACKAGE_SUBCOMMAND)
                .append(TELEPHONY_CTS_PACKAGE);
        TelephonyUtils.executeShellCommand(InstrumentationRegistry.getInstrumentation(),
                cmdBuilder.toString());

        long arbitraryCompletionWindowSecs = 1L;

        boolean isDataThrottlingSupported = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, (tm) -> tm.isRadioInterfaceCapabilitySupported(
                        TelephonyManager.CAPABILITY_THERMAL_MITIGATION_DATA_THROTTLING));

        int thermalMitigationResult = -1;
        if (isDataThrottlingSupported) {
            // Test a proper data throttling thermal mitigation request.
            thermalMitigationResult = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, (tm) -> tm.sendThermalMitigationRequest(
                        new ThermalMitigationRequest.Builder()
                                .setThermalMitigationAction(ThermalMitigationRequest
                                        .THERMAL_MITIGATION_ACTION_DATA_THROTTLING)
                                .setDataThrottlingRequest(new DataThrottlingRequest.Builder()
                                        .setDataThrottlingAction(DataThrottlingRequest
                                                .DATA_THROTTLING_ACTION_THROTTLE_SECONDARY_CARRIER)
                                        .setCompletionDurationMillis(arbitraryCompletionWindowSecs)
                                        .build())
                                .build()));

            assertEquals(thermalMitigationResult,
                    TelephonyManager.THERMAL_MITIGATION_RESULT_SUCCESS);
        }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testGetAllCellInfo"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[1]:method_text:[ged = true;                    mLock.notify();                }            }        }    }   ]) :|: 
    public void testGetAllCellInfo() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) return;

        // For IRadio <1.5, just verify that calling the method doesn't throw an error.
        if (mRadioVersion < RADIO_HAL_VERSION_1_5) {
            mTelephonyManager.getAllCellInfo();
            return;
        }

        for (CellInfo cellInfo : mTelephonyManager.getAllCellInfo()) {
            CellIdentity cellIdentity = cellInfo.getCellIdentity();
            int[] bands;
            if (cellIdentity instanceof CellIdentityLte) {
                bands = ((CellIdentityLte) cellIdentity).getBands();
                for (int band : bands) {
                    assertTrue(band >= AccessNetworkConstants.EutranBand.BAND_1
                            && band <= AccessNetworkConstants.EutranBand.BAND_88);
                }
            } else if (cellIdentity instanceof CellIdentityNr) {
                bands = ((CellIdentityNr) cellIdentity).getBands();
                for (int band : bands) {
                    assertTrue((band >= AccessNetworkConstants.NgranBands.BAND_1
                            && band <= AccessNetworkConstants.NgranBands.BAND_95)
                            || (band >= AccessNetworkConstants.NgranBands.BAND_257
                            && band <= AccessNetworkConstants.NgranBands.BAND_261));
                }
            } else {
                continue;
            }
            assertTrue(bands.length > 0);
        }
    }

    /**
     * Validate Emergency Number address that only contains the dialable character.
     *
     * @param address Emergency number address to validate
     * @return {@code true} if the address is valid; {@code false} otherwise.
     */
    private static boolean validateEmergencyNumberAddress(String address) {
        if (address == null) {
            return false;
        }
        for (char c : address.toCharArray()) {
            if (!isDialable(c)) {
                return fa"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testRegisterTelephonyCallback"	"CtsTelephonyTestCases"	"1: permission"	"([3:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[3]:method_text:[k TelephonyManager#getNetworkSlicingConfiguration()} does not throw any     * exception     */   ]) :|: 
    public void testRegisterTelephonyCallback() throws Throwable {
        if (!InstrumentationRegistry.getContext().getPackageManager()
                .hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            Log.d(TAG, ""Skipping test that requires PackageManager.FEATURE_TELEPHONY"");
            return;
        }

        if (mTelephonyManager.getPhoneType() == TelephonyManager.PHONE_TYPE_CDMA) {
            // TODO: temp workaround, need to adjust test to for CDMA
            return;
        }
        grantLocationPermissions();

        TestThread t = new TestThread(new Runnable() {
            public void run() {
                Looper.prepare();
                mMockCellInfoListener = new MockCellInfoListener();
                synchronized (mLock) {
                    mLock.notify(); // listener is ready
                }

                Looper.loop();
            }
        });

        synchronized (mLock) {
            t.start();
            mLock.wait(TOLERANCE); // wait for listener
        }

        // Test register
        synchronized (mLock) {
            // .registerTelephonyCallback generates an onCellLocationChanged event
            mTelephonyManager.registerTelephonyCallback(mSimpleExecutor, mMockCellInfoListener);
            mLock.wait(TOLERANCE);

            assertTrue(""Test register, mOnCellLocationChangedCalled should be true."",
                    mOnCellInfoChanged);
        }

        synchronized (mLock) {
            mOnCellInfoChanged = false;

            CellInfoResultsCallback resultsCallback = new CellInfoResultsCallback();
            mTelephonyManager.requestCellInfoUpdate(mSimpleExecutor, resultsCallback);
            mLock.wait(TOLERANCE);

            assertTrue(""Test register, mOnCellLocationChangedCalled should be true."",
                    mOnCellInfoChanged);
        }

        // unregister the listener
        mTelephonyManager.unregisterTelephonyCallback(mMockCellInfoListener);
        Thread.sleep(TOLERA"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testGetNetworkSlicingConfiguration"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[1]:method_text:[     (tm) -> tm.getNetworkSlicingConfiguration(mSimpleExecutor, resultFuture::complete));    }   ]) :|: 
    public void testGetNetworkSlicingConfiguration() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }
        CompletableFuture<NetworkSlicingConfig> resultFuture = new CompletableFuture<>();
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                (tm) -> tm.getNetworkSlicingConfiguration(mSimpleExecutor, resultFuture::complete));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testCheckCarrierPrivilegesForPackageEnforcesReadPrivilege"	"CtsTelephonyTestCases"	"1: permission"	"([3:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[3]:method_text:[rumentation().getUiAutomation()                .dropShellPermissionIdentity();        }    }   ]) :|: 
    public void testCheckCarrierPrivilegesForPackageEnforcesReadPrivilege() {
        try {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(""android.permission.READ_PRIVILEGED_PHONE_STATE"");
            mTelephonyManager.checkCarrierPrivilegesForPackage(mSelfPackageName);
        } catch (SecurityException e) {
            fail(""TelephonyManager#checkCarrierPrivilegesForPackage requires ""
                    + ""READ_PRIVILEGED_PHONE_STATE"");
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .dropShellPermissionIdentity();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testGetCarrierPackageNamesForIntentAndPhoneEnforcesReadPrivilege"	"CtsTelephonyTestCases"	"1: permission"	"([3:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[3]:method_text:[rumentation().getUiAutomation()                .dropShellPermissionIdentity();        }    }   ]) :|: 
    public void testGetCarrierPackageNamesForIntentAndPhoneEnforcesReadPrivilege() {
        try {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(""android.permission.READ_PRIVILEGED_PHONE_STATE"");
            Intent intent = new Intent();
            int phoneId = 1;
            mTelephonyManager.getCarrierPackageNamesForIntentAndPhone(intent, phoneId);
        } catch (SecurityException e) {
            fail(""TelephonyManager#getCarrierPackageNamesForIntentAndPhone requires ""
                    + ""READ_PRIVILEGED_PHONE_STATE"");
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .dropShellPermissionIdentity();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testGetCarrierPackageNamesForIntentAndPhoneThrowsExceptionWithoutReadPrivilege"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[1]:method_text:[rumentation().getUiAutomation()                .dropShellPermissionIdentity();        }    }   ]) :|: 
    public void testGetCarrierPackageNamesForIntentAndPhoneThrowsExceptionWithoutReadPrivilege() {
        if (!hasCellular()) return;
        try {
            Intent intent = new Intent();
            int phoneId = 1;
            mTelephonyManager.getCarrierPackageNamesForIntentAndPhone(intent, phoneId);
            fail(""TelephonyManager#getCarrierPackageNamesForIntentAndPhone must be protected ""
                    + ""with READ_PRIVILEGED_PHONE_STATE"");
        } catch (SecurityException e) {
            // expected
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .dropShellPermissionIdentity();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyManagerTest"	"testGetPackagesWithCarrierPrivilegesEnforcesReadPrivilege"	"CtsTelephonyTestCases"	"1: permission"	"([3:/android/telephony/cts/TelephonyManagerTest.java]:[permission]:[3]:method_text:[rumentation().getUiAutomation()                .dropShellPermissionIdentity();        }    }   ]) :|: 
    public void testGetPackagesWithCarrierPrivilegesEnforcesReadPrivilege() {
        try {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(""android.permission.READ_PRIVILEGED_PHONE_STATE"");
            mTelephonyManager.getPackagesWithCarrierPrivileges();
        } catch (SecurityException e) {
            fail(""TelephonyManager#getPackagesWithCarrierPrivileges requires ""
                    + ""READ_PRIVILEGED_PHONE_STATE"");
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .dropShellPermissionIdentity();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyCallbackTest"	"testTelephonyCallback"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/cts/TelephonyCallbackTest.java]:[permission]:[2]:method_text:[ServiceStateChangedCalled = true;                mLock.notify();            }        }    }   ]) :|: 
    public void testTelephonyCallback() {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }

        Looper.prepare();
        new TelephonyCallback();
    }

    private void registerTelephonyCallbackWithPermission(@NonNull TelephonyCallback callback) {
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mTelephonyManager,
                (tm) -> tm.registerTelephonyCallback(mSimpleExecutor, callback));
    }

    private void registerTelephonyCallback(@NonNull TelephonyCallback callback) {
        mTelephonyManager.registerTelephonyCallback(mSimpleExecutor, callback);
    }

    private void unRegisterTelephonyCallback(boolean condition,
                                             @NonNull TelephonyCallback callback) throws Exception {
        synchronized (mLock) {
            condition = false;
            mTelephonyManager.unregisterTelephonyCallback(callback);
            mLock.wait(WAIT_TIME);

            assertFalse(condition);
        }
    }

    private ServiceStateListener mServiceStateCallback;

    private class ServiceStateListener extends TelephonyCallback
            implements TelephonyCallback.ServiceStateListener {
        @Override
        public void onServiceStateChanged(ServiceState serviceState) {
            synchronized (mLock) {
                mOnServiceStateChangedCalled = true;
                mLock.notify();
            }
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyCallbackTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyCallbackTest"	"testOnPreciseCallStateChangedByRegisterTelephonyCallback"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyCallbackTest.java]:[permission]:[1]:method_text:[connectCauseChangedCalled = true;                mLock.notify();            }        }    }   ]) :|: 
    public void testOnPreciseCallStateChangedByRegisterTelephonyCallback() throws Throwable {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }
        assertThat(mOnPreciseCallStateChangedCalled).isFalse();

        mHandler.post(() -> {
            mPreciseCallStateCallback = new PreciseCallStateListener();
            registerTelephonyCallbackWithPermission(mPreciseCallStateCallback);
        });
        synchronized (mLock) {
            if (!mOnPreciseCallStateChangedCalled) {
                mLock.wait(WAIT_TIME);
            }
        }
        Log.d(TAG, ""testOnPreciseCallStateChangedByRegisterTelephonyCallback: ""
                + mOnPreciseCallStateChangedCalled);

        assertThat(mOnPreciseCallStateChangedCalled).isTrue();
        assertThat(mPreciseCallState.getForegroundCallState()).isIn(PRECISE_CALL_STATE);
        assertThat(mPreciseCallState.getBackgroundCallState()).isIn(PRECISE_CALL_STATE);
        assertThat(mPreciseCallState.getRingingCallState()).isIn(PRECISE_CALL_STATE);

        // Test unregister
        unRegisterTelephonyCallback(mOnPreciseCallStateChangedCalled,
                mPreciseCallStateCallback);
    }

    private CallDisconnectCauseListener mCallDisconnectCauseCallback;

    private class CallDisconnectCauseListener extends TelephonyCallback
            implements TelephonyCallback.CallDisconnectCauseListener {
        @Override
        public void onCallDisconnectCauseChanged(int disconnectCause,
                                                 int preciseDisconnectCause) {
            synchronized (mLock) {
                mOnCallDisconnectCauseChangedCalled = true;
                mLock.notify();
            }
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyCallbackTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyCallbackTest"	"testOnCallDisconnectCauseChangedByRegisterTelephonyCallback"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyCallbackTest.java]:[permission]:[1]:method_text:[connectCauseChangedCalled = true;                mLock.notify();            }        }    }   ]) :|: 
    public void testOnCallDisconnectCauseChangedByRegisterTelephonyCallback() throws Throwable {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }
        assertThat(mOnCallDisconnectCauseChangedCalled).isFalse();

        mHandler.post(() -> {
            mCallDisconnectCauseCallback = new CallDisconnectCauseListener();
            registerTelephonyCallbackWithPermission(mCallDisconnectCauseCallback);

        });
        synchronized (mLock) {
            if (!mOnCallDisconnectCauseChangedCalled) {
                mLock.wait(WAIT_TIME);
            }
        }

        assertThat(mOnCallDisconnectCauseChangedCalled).isTrue();

        // Test unregister
        unRegisterTelephonyCallback(mOnCallDisconnectCauseChangedCalled,
                mCallDisconnectCauseCallback);
    }

    private ImsCallDisconnectCauseListener mImsCallDisconnectCauseCallback;

    private class ImsCallDisconnectCauseListener extends TelephonyCallback
            implements TelephonyCallback.ImsCallDisconnectCauseListener {
        @Override
        public void onImsCallDisconnectCauseChanged(ImsReasonInfo imsReason) {
            synchronized (mLock) {
                mOnImsCallDisconnectCauseChangedCalled = true;
                mLock.notify();
            }
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyCallbackTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyCallbackTest"	"testOnImsCallDisconnectCauseChangedByRegisterTelephonyCallback"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyCallbackTest.java]:[permission]:[1]:method_text:[ mSrvccStateChangedCalled = true;                mLock.notify();            }        }    }   ]) :|: 
    public void testOnImsCallDisconnectCauseChangedByRegisterTelephonyCallback() throws Throwable {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }
        assertThat(mOnImsCallDisconnectCauseChangedCalled).isFalse();

        mHandler.post(() -> {
            mImsCallDisconnectCauseCallback = new ImsCallDisconnectCauseListener();
            registerTelephonyCallbackWithPermission(mImsCallDisconnectCauseCallback);

        });
        synchronized (mLock) {
            if (!mOnImsCallDisconnectCauseChangedCalled) {
                mLock.wait(WAIT_TIME);
            }
        }

        assertThat(mOnImsCallDisconnectCauseChangedCalled).isTrue();

        // Test unregister
        unRegisterTelephonyCallback(mOnImsCallDisconnectCauseChangedCalled,
                mImsCallDisconnectCauseCallback);
    }

    private SrvccStateListener mSrvccStateCallback;

    private class SrvccStateListener extends TelephonyCallback
            implements TelephonyCallback.SrvccStateListener {
        @Override
        public void onSrvccStateChanged(int state) {
            synchronized (mLock) {
                mSrvccStateChangedCalled = true;
                mLock.notify();
            }
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyCallbackTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyCallbackTest"	"testOSrvccStateChangedByRegisterTelephonyCallback"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyCallbackTest.java]:[permission]:[1]:method_text:[ioPowerStateChangedCalled = true;                mLock.notify();            }        }    }   ]) :|: 
    public void testOSrvccStateChangedByRegisterTelephonyCallback() throws Throwable {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }
        assertThat(mSrvccStateChangedCalled).isFalse();

        mHandler.post(() -> {
            mSrvccStateCallback = new SrvccStateListener();
            registerTelephonyCallbackWithPermission(mSrvccStateCallback);

        });
        synchronized (mLock) {
            if (!mSrvccStateChangedCalled) {
                mLock.wait(WAIT_TIME);
            }
        }
        Log.d(TAG, ""testOSrvccStateChangedByRegisterTelephonyCallback"");

        assertThat(mSrvccStateChangedCalled).isTrue();

        // Test unregister
        unRegisterTelephonyCallback(mSrvccStateChangedCalled, mSrvccStateCallback);
    }

    private RadioPowerStateListener mRadioPowerStateCallback;

    private class RadioPowerStateListener extends TelephonyCallback
            implements TelephonyCallback.RadioPowerStateListener {
        @Override
        public void onRadioPowerStateChanged(int state) {
            synchronized (mLock) {
                mRadioPowerState = state;
                mOnRadioPowerStateChangedCalled = true;
                mLock.notify();
            }
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyCallbackTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyCallbackTest"	"testOnRadioPowerStateChangedByRegisterTelephonyCallback"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyCallbackTest.java]:[permission]:[1]:method_text:[ivationStateChangedCalled = true;                mLock.notify();            }        }    }   ]) :|: 
    public void testOnRadioPowerStateChangedByRegisterTelephonyCallback() throws Throwable {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }
        assertThat(mOnRadioPowerStateChangedCalled).isFalse();

        mHandler.post(() -> {
            mRadioPowerStateCallback = new RadioPowerStateListener();
            registerTelephonyCallbackWithPermission(mRadioPowerStateCallback);
        });
        synchronized (mLock) {
            if (!mOnRadioPowerStateChangedCalled) {
                mLock.wait(WAIT_TIME);
            }
        }
        Log.d(TAG, ""testOnRadioPowerStateChangedByRegisterTelephonyCallback: ""
                + mRadioPowerState);

        assertThat(mTelephonyManager.getRadioPowerState()).isEqualTo(mRadioPowerState);

        // Test unregister
        unRegisterTelephonyCallback(mOnRadioPowerStateChangedCalled,
                mRadioPowerStateCallback);
    }

    private VoiceActivationStateListener mVoiceActivationStateCallback;

    private class VoiceActivationStateListener extends TelephonyCallback
            implements TelephonyCallback.VoiceActivationStateListener {
        @Override
        public void onVoiceActivationStateChanged(int state) {
            synchronized (mLock) {
                mVoiceActivationState = state;
                mVoiceActivationStateChangedCalled = true;
                mLock.notify();
            }
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyCallbackTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyCallbackTest"	"testOnVoiceActivationStateChangedByRegisterTelephonyCallback"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/cts/TelephonyCallbackTest.java]:[permission]:[2]:method_text:[taConnectionApnTypeBitMask();        mPreciseDataConnectionState.getDataConnectionApn();    }   ]) :|: 
    public void testOnVoiceActivationStateChangedByRegisterTelephonyCallback() throws Throwable {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }
        assertThat(mVoiceActivationStateChangedCalled).isFalse();

        mHandler.post(() -> {
            mVoiceActivationStateCallback = new VoiceActivationStateListener();
            registerTelephonyCallbackWithPermission(mVoiceActivationStateCallback);

        });
        synchronized (mLock) {
            if (!mVoiceActivationStateChangedCalled) {
                mLock.wait(WAIT_TIME);
            }
        }
        Log.d(TAG, ""testOnVoiceActivationStateChangedByRegisterTelephonyCallback: ""
                + mVoiceActivationState);
        int state = ShellIdentityUtils.invokeMethodWithShellPermissions(mTelephonyManager,
                (tm) -> tm.getVoiceActivationState());

        assertEquals(state, mVoiceActivationState);

        // Test unregister
        unRegisterTelephonyCallback(mVoiceActivationStateChangedCalled,
                mVoiceActivationStateCallback);
    }

    private PreciseDataConnectionStateListener mPreciseDataConnectionStateCallback;

    private class PreciseDataConnectionStateListener extends TelephonyCallback
            implements TelephonyCallback.PreciseDataConnectionStateListener {
        @Override
        public void onPreciseDataConnectionStateChanged(
                PreciseDataConnectionState state) {
            synchronized (mLock) {
                mOnPreciseDataConnectionStateChanged = true;
                mPreciseDataConnectionState = state;
                mLock.notify();
            }
        }
    }

    private void getPreciseDataConnectionState() {
        // Ensure that no exceptions are thrown
        mPreciseDataConnectionState.getNetworkType();
        mPreciseDataConnectionState.getLinkProperties();
        mPrecis"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyCallbackTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyCallbackTest"	"testOnPreciseDataConnectionStateChangedByRegisterTelephonyCallback"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyCallbackTest.java]:[permission]:[1]:method_text:[lephonyDisplayInfoChanged = true;                mLock.notify();            }        }    }   ]) :|: 
    public void testOnPreciseDataConnectionStateChangedByRegisterTelephonyCallback()
            throws Throwable {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }
        assertThat(mOnCallDisconnectCauseChangedCalled).isFalse();

        mHandler.post(() -> {
            mPreciseDataConnectionStateCallback =
                    new PreciseDataConnectionStateListener();
            registerTelephonyCallbackWithPermission(mPreciseDataConnectionStateCallback);

        });
        synchronized (mLock) {
            if (!mOnPreciseDataConnectionStateChanged) {
                mLock.wait(WAIT_TIME);
            }
        }

        assertThat(mOnPreciseDataConnectionStateChanged).isTrue();
        assertThat(mPreciseDataConnectionState.getState())
                .isIn(DATA_CONNECTION_STATE);

        getPreciseDataConnectionState();
        // Test unregister
        unRegisterTelephonyCallback(mOnPreciseDataConnectionStateChanged,
                mPreciseDataConnectionStateCallback);
    }

    private DisplayInfoListener mDisplayInfoCallback;

    private class DisplayInfoListener extends TelephonyCallback
            implements TelephonyCallback.DisplayInfoListener {
        @Override
        public void onDisplayInfoChanged(TelephonyDisplayInfo displayInfo) {
            synchronized (mLock) {
                mOnTelephonyDisplayInfoChanged = true;
                mLock.notify();
            }
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyCallbackTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyCallbackTest"	"testOnCellLocationChangedByRegisterTelephonyCallback"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyCallbackTest.java]:[permission]:[1]:method_text:[mOnCallStateChangedCalled = true;                mLock.notify();            }        }    }   ]) :|: 
    public void testOnCellLocationChangedByRegisterTelephonyCallback() throws Throwable {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }
        assertFalse(mOnCellLocationChangedCalled);

        TelephonyManagerTest.grantLocationPermissions();
        mHandler.post(() -> {
            mCellLocationCallback = new CellLocationListener();
            registerTelephonyCallback(mCellLocationCallback);
        });
        synchronized (mLock) {
            if (!mOnCellLocationChangedCalled) {
                mLock.wait(WAIT_TIME);
            }
        }

        assertTrue(mOnCellLocationChangedCalled);

        // Test unregister
        unRegisterTelephonyCallback(mOnCellLocationChangedCalled, mCellLocationCallback);
    }

    private CallStateListener mCallStateCallback;

    private class CallStateListener extends TelephonyCallback
            implements TelephonyCallback.CallStateListener {
        @Override
        public void onCallStateChanged(int state) {
            synchronized (mLock) {
                mOnCallStateChangedCalled = true;
                mLock.notify();
            }
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyCallbackTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyCallbackTest"	"testOnCellInfoChangedByRegisterTelephonyCallback"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyCallbackTest.java]:[permission]:[1]:method_text:[serMobileDataStateChanged = true;                mLock.notify();            }        }    }   ]) :|: 
    public void testOnCellInfoChangedByRegisterTelephonyCallback() throws Throwable {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }
        assertFalse(mOnDataActivityCalled);

        TelephonyManagerTest.grantLocationPermissions();
        mHandler.post(() -> {
            mCellInfoCallback = new CellInfoListener();
            registerTelephonyCallback(mCellInfoCallback);
        });
        synchronized (mLock) {
            if (!mOnCellInfoChangedCalled) {
                mLock.wait(WAIT_TIME);
            }
        }

        assertTrue(mOnCellInfoChangedCalled);

        // Test unregister
        unRegisterTelephonyCallback(mOnCellInfoChangedCalled, mCellInfoCallback);
    }

    private UserMobileDataStateListener mUserMobileDataStateCallback;

    private class UserMobileDataStateListener extends TelephonyCallback
            implements TelephonyCallback.UserMobileDataStateListener {
        @Override
        public void onUserMobileDataStateChanged(boolean state) {
            synchronized (mLock) {
                mOnUserMobileDataStateChanged = true;
                mLock.notify();
            }
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyCallbackTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyCallbackTest"	"testOnOutgoingSmsEmergencyNumberChangedByRegisterTelephonyCallback"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyCallbackTest.java]:[permission]:[1]:method_text:[DataSubscriptionIdChanged = true;                mLock.notify();            }        }    }   ]) :|: 
    public void testOnOutgoingSmsEmergencyNumberChangedByRegisterTelephonyCallback()
            throws Throwable {

        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }

        TelephonyUtils.addTestEmergencyNumber(
                InstrumentationRegistry.getInstrumentation(), TEST_EMERGENCY_NUMBER);
        assertNull(mOnOutgoingSmsEmergencyNumberChanged);

        mHandler.post(() -> {
            mOutgoingEmergencySmsCallback = new OutgoingEmergencySmsListener();
            registerTelephonyCallbackWithPermission(mOutgoingEmergencySmsCallback);
            SmsManager.getDefault().sendTextMessage(
                    TEST_EMERGENCY_NUMBER, null,
                    ""testOutgoingSmsListenerCtsByRegisterTelephonyCallback"",
                    null, null);
        });
        try {
            synchronized (mLock) {
                if (mOnOutgoingSmsEmergencyNumberChanged == null) {
                    mLock.wait(WAIT_TIME);
                }
            }
        } catch (InterruptedException e) {
            Log.e(TAG, ""Operation interrupted."");
        } finally {
            TelephonyUtils.removeTestEmergencyNumber(
                    InstrumentationRegistry.getInstrumentation(), TEST_EMERGENCY_NUMBER);
        }

        assertNotNull(mOnOutgoingSmsEmergencyNumberChanged);
        assertEquals(mOnOutgoingSmsEmergencyNumberChanged.getNumber(), TEST_EMERGENCY_NUMBER);

        // Test unregister
        unRegisterTelephonyCallback(mOnOutgoingSmsEmergencyNumberChanged == null,
                mOutgoingEmergencySmsCallback);

        // Disable suppressing blocking.
        TelephonyUtils.endBlockSuppression(InstrumentationRegistry.getInstrumentation());
    }

    private ActiveDataSubscriptionIdListener mActiveDataSubscriptionIdCallback;

    private class ActiveDataSubscriptionIdListener extends TelephonyCallback"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyCallbackTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyCallbackTest"	"testOnBarringInfoChangedByRegisterTelephonyCallback"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyCallbackTest.java]:[permission]:[1]:method_text:[nRegistrationFailedCalled = true;                mLock.notify();            }        }    }   ]) :|: 
    public void testOnBarringInfoChangedByRegisterTelephonyCallback() throws Throwable {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }

        assertFalse(mOnBarringInfoChangedCalled);
        mHandler.post(() -> {
            mBarringInfoCallback = new BarringInfoListener();
            registerTelephonyCallbackWithPermission(mBarringInfoCallback);
        });

        synchronized (mLock) {
            if (!mOnBarringInfoChangedCalled) {
                mLock.wait(WAIT_TIME);
            }
        }
        assertTrue(mOnBarringInfoChangedCalled);

        assertBarringInfoSane(mBarringInfo);

        // Test unregister
        unRegisterTelephonyCallback(mOnBarringInfoChangedCalled, mBarringInfoCallback);
    }

    private static final int[] sBarringServiceInfoTypes = new int[]{
            BarringInfo.BARRING_SERVICE_TYPE_CS_SERVICE,
            BarringInfo.BARRING_SERVICE_TYPE_PS_SERVICE,
            BarringInfo.BARRING_SERVICE_TYPE_CS_VOICE,
            BarringInfo.BARRING_SERVICE_TYPE_MO_SIGNALLING,
            BarringInfo.BARRING_SERVICE_TYPE_MO_DATA,
            BarringInfo.BARRING_SERVICE_TYPE_CS_FALLBACK,
            BarringInfo.BARRING_SERVICE_TYPE_MMTEL_VOICE,
            BarringInfo.BARRING_SERVICE_TYPE_MMTEL_VIDEO,
            BarringInfo.BARRING_SERVICE_TYPE_EMERGENCY,
            BarringInfo.BARRING_SERVICE_TYPE_SMS
    };

    private static void assertBarringInfoSane(BarringInfo barringInfo) {
        assertNotNull(barringInfo);

        // Flags to track whether we have had unknown and known barring types reported
        boolean hasBarringTypeUnknown = false;
        boolean hasBarringTypeKnown = false;

        for (int bsiType : sBarringServiceInfoTypes) {
            BarringInfo.BarringServiceInfo bsi = barringInfo.getBarringServiceInfo(bsiType);
            assertNotNull(bsi);
            switch"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyCallbackTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyCallbackTest"	"testOnRegistrationFailedByRegisterTelephonyCallback"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyCallbackTest.java]:[permission]:[1]:method_text:[ysicalChannelConfigCalled = true;                mLock.notify();            }        }    }   ]) :|: 
    public void testOnRegistrationFailedByRegisterTelephonyCallback() throws Throwable {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }

        assertFalse(mOnBarringInfoChangedCalled);
        mHandler.post(() -> {
            mRegistrationFailedCallback = new RegistrationFailedListener();
            registerTelephonyCallbackWithPermission(mRegistrationFailedCallback);

        });

        synchronized (mLock) {
            if (!mOnBarringInfoChangedCalled) {
                mLock.wait(WAIT_TIME);
            }
        }

        // Assert that in the WAIT_TIME interval, the listener wasn't invoked. While this is
        // **technically** a flaky test, in practice this flake should happen approximately never
        // as it would mean that a registered phone is failing to reselect during CTS at this
        // exact moment.
        //
        // What the test is verifying is that there is no ""auto"" callback for registration
        // failure because unlike other PSL registrants, this one is not called upon registration.
        assertFalse(mOnRegistrationFailedCalled);

        // Test unregister
        unRegisterTelephonyCallback(mOnRegistrationFailedCalled, mRegistrationFailedCallback);
    }

    private PhysicalChannelConfigListener mPhysicalChannelConfigCallback;

    private class PhysicalChannelConfigListener extends TelephonyCallback
            implements TelephonyCallback.PhysicalChannelConfigListener {
        @Override
        public void onPhysicalChannelConfigChanged(
                @NonNull List<PhysicalChannelConfig> configs) {
            synchronized (mLock) {
                mOnPhysicalChannelConfigCalled = true;
                mLock.notify();
            }
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyCallbackTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyCallbackTest"	"testOnPhysicalChannelConfigChanged"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyCallbackTest.java]:[permission]:[1]:method_text:[nDataEnabledChangedCalled = true;                mLock.notify();            }        }    }   ]) :|: 
    public void testOnPhysicalChannelConfigChanged() throws Throwable {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }

        assertFalse(mOnPhysicalChannelConfigCalled);
        mHandler.post(() -> {
            mPhysicalChannelConfigCallback =
                    new PhysicalChannelConfigListener();
            registerTelephonyCallbackWithPermission(mPhysicalChannelConfigCallback);
        });

        synchronized (mLock) {
            while (!mOnPhysicalChannelConfigCalled) {
                mLock.wait(WAIT_TIME);
            }
        }
        assertTrue(mOnPhysicalChannelConfigCalled);

        // Test unregister
        unRegisterTelephonyCallback(mOnPhysicalChannelConfigCalled,
                mPhysicalChannelConfigCallback);
    }

    private DataEnabledListener mDataEnabledCallback;

    private class DataEnabledListener extends TelephonyCallback
            implements TelephonyCallback.DataEnabledListener {
        @Override
        public void onDataEnabledChanged(boolean enabled, @DataEnabledReason int reason) {
            synchronized (mLock) {
                mOnDataEnabledChangedCalled = true;
                mLock.notify();
            }
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyCallbackTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyCallbackTest"	"testOnDataEnabledChangedByRegisterTelephonyCallback"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyCallbackTest.java]:[permission]:[1]:method_text:[etworkTypesChangedCalled = true;                mLock.notify();            }        }    }   ]) :|: 
    public void testOnDataEnabledChangedByRegisterTelephonyCallback() throws Throwable {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }

        assertFalse(mOnDataEnabledChangedCalled);
        mHandler.post(() -> {
            mDataEnabledCallback = new DataEnabledListener();
            registerTelephonyCallbackWithPermission(mDataEnabledCallback);
        });

        synchronized (mLock) {
            while (!mOnDataEnabledChangedCalled) {
                mLock.wait(WAIT_TIME);
            }
        }
        assertTrue(mOnDataEnabledChangedCalled);

        // Test unregister
        unRegisterTelephonyCallback(mOnDataEnabledChangedCalled, mDataEnabledCallback);
    }

    private AllowedNetworkTypesListener mAllowedNetworkTypesCallback;

    private class AllowedNetworkTypesListener extends TelephonyCallback
            implements TelephonyCallback.AllowedNetworkTypesListener {
        @Override
        public void onAllowedNetworkTypesChanged(int reason, long allowedNetworkType) {
            synchronized (mLock) {
                Log.d(TAG, ""onAllowedNetworkTypesChanged"");
                mAllowedNetworkTypeReason = reason;
                mAllowedNetworkTypeValue = allowedNetworkType;
                mOnAllowedNetworkTypesChangedCalled = true;

                mLock.notify();
            }
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyCallbackTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyCallbackTest"	"testOnAllowedNetworkTypesChangedByRegisterPhoneStateListener"	"CtsTelephonyTestCases"	"1: permission"	"([5:/android/telephony/cts/TelephonyCallbackTest.java]:[permission]:[5]:method_text:[dCalled = true;                }                mLock.notify();            }        }    }   ]) :|: 
    public void testOnAllowedNetworkTypesChangedByRegisterPhoneStateListener() throws Throwable {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }
        long originalAllowedNetworkTypeUser = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, (tm) -> {
                    return tm.getAllowedNetworkTypesForReason(
                            TelephonyManager.ALLOWED_NETWORK_TYPES_REASON_USER);
                });
        assertFalse(mOnAllowedNetworkTypesChangedCalled);

        mHandler.post(() -> {
            mAllowedNetworkTypesCallback = new AllowedNetworkTypesListener();
            registerTelephonyCallbackWithPermission(mAllowedNetworkTypesCallback);
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                    mTelephonyManager,
                    (tm) -> tm.setAllowedNetworkTypesForReason(
                            TelephonyManager.ALLOWED_NETWORK_TYPES_REASON_USER,
                            TelephonyManager.NETWORK_TYPE_BITMASK_NR));
        });

        synchronized (mLock) {
            if (!mOnAllowedNetworkTypesChangedCalled) {
                mLock.wait(WAIT_TIME);
            }
        }

        long allowedNetworkTypeUser = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTelephonyManager, (tm) -> {
                    return tm.getAllowedNetworkTypesForReason(
                            TelephonyManager.ALLOWED_NETWORK_TYPES_REASON_USER);
                });

        assertEquals(TelephonyManager.ALLOWED_NETWORK_TYPES_REASON_USER, mAllowedNetworkTypeReason);
        assertEquals(allowedNetworkTypeUser, mAllowedNetworkTypeValue);
        // Test unregister
        unRegisterTelephonyCallback(mOnAllowedNetworkTypesChangedCalled,
                mAllowedNetworkTypesCallback);

        // Recover the allowed networ"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyCallbackTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.TelephonyCallbackTest"	"testOnLinkCapacityEstimateChangedByRegisterPhoneStateListener"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/TelephonyCallbackTest.java]:[permission]:[1]:method_text:[mOnLinkCapacityEstimateChangedCalled,                mLinkCapacityEstimateChangedListener);    }}]) :|: 
    public void testOnLinkCapacityEstimateChangedByRegisterPhoneStateListener() throws Throwable {
        if (mCm.getNetworkInfo(ConnectivityManager.TYPE_MOBILE) == null) {
            Log.d(TAG, ""Skipping test that requires ConnectivityManager.TYPE_MOBILE"");
            return;
        }

        assertFalse(mOnLinkCapacityEstimateChangedCalled);
        mHandler.post(() -> {
            mLinkCapacityEstimateChangedListener = new LinkCapacityEstimateChangedListener();
            registerTelephonyCallbackWithPermission(mLinkCapacityEstimateChangedListener);
        });

        synchronized (mLock) {
            while (!mOnLinkCapacityEstimateChangedCalled) {
                mLock.wait(WAIT_TIME);
            }
        }
        assertTrue(mOnLinkCapacityEstimateChangedCalled);

        // Test unregister
        unRegisterTelephonyCallback(mOnLinkCapacityEstimateChangedCalled,
                mLinkCapacityEstimateChangedListener);
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyCallbackTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.SubscriptionManagerTest"	"isSupported"	"CtsTelephonyTestCases"	"2: INTERNET permission"	"([1:/android/telephony/cts/SubscriptionManagerTest.java]:[permission]:[1]:method_text:[R} network must both be     * either defined or undefined; you can't cross the streams.     */   ]) :|: /*
 *.
 */

package android.telephony.cts;

import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_CONGESTED;
import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_RESTRICTED;
import static android.net.NetworkCapabilities.NET_CAPABILITY_TEMPORARILY_NOT_METERED;
import static android.net.NetworkCapabilities.TRANSPORT_CELLULAR;
import static android.telephony.TelephonyManager.SET_OPPORTUNISTIC_SUB_SUCCESS;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import android.annotation.Nullable;
import android.app.UiAutomation;
import android.content.pm.PackageManager;
import android.content.res.Resources;
import android.net.ConnectivityManager;
import android.net.ConnectivityManager.NetworkCallback;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.Uri;
import android.os.Looper;
import android.os.ParcelUuid;
import android.os.PersistableBundle;
import android.telephony.CarrierConfigManager;
import android.telephony.SubscriptionInfo;
import android.telephony.SubscriptionManager;
import android.telephony.SubscriptionPlan;
import android.telephony.TelephonyManager;
import android.telephony.ims.ImsException;
import android.telephony.ims.ImsManager;
import android.telephony.ims.ImsMmTelManager;
import android.telephony.ims.ImsRcsManager;
import android.telephony.ims.RcsUceAdapter;
import android.util.Log;

import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;
import com.android.compatibility.common.util.TestThread;
import com.android.internal.util.Ar"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SubscriptionManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.SubscriptionManagerTest"	"testSetAndGetD2DSharingContacts"	"CtsTelephonyTestCases"	"2: INTERNET permission"	"([9:/android/telephony/cts/SubscriptionManagerTest.java]:[permission]:[9]:method_text:[ager.NETWORK_TYPE_NR;        return validCarrier && validNetworkType && validCapabilities;    }}]) :|: 
    public void testSetAndGetD2DSharingContacts() {
        if (!isSupported()) return;

        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        uiAutomation.adoptShellPermissionIdentity(MODIFY_PHONE_STATE);
        List<Uri> originalD2DSharingContacts = mSm.getDeviceToDeviceStatusSharingContacts(mSubId);
        mSm.setDeviceToDeviceStatusSharingContacts(mSubId, CONTACTS);
        assertEquals(CONTACTS, mSm.getDeviceToDeviceStatusSharingContacts(mSubId));
        mSm.setDeviceToDeviceStatusSharingContacts(mSubId, originalD2DSharingContacts);
        uiAutomation.dropShellPermissionIdentity();
    }

    @Nullable
    private PersistableBundle getBundleFromBackupData(byte[] data) {
        try (ByteArrayInputStream bis = new ByteArrayInputStream(data)) {
            return PersistableBundle.readFromStream(bis);
        } catch (IOException e) {
            return null;
        }
    }

    private void overrideCarrierConfig(PersistableBundle bundle, int subId) throws Exception {
        CarrierConfigManager carrierConfigManager = InstrumentationRegistry.getContext()
                .getSystemService(CarrierConfigManager.class);
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(carrierConfigManager,
                (m) -> m.overrideConfig(subId, bundle));
    }

    private void setPreferredDataSubId(int subId) {
        final LinkedBlockingQueue<Integer> resultQueue = new LinkedBlockingQueue<>(1);
        Executor executor = (command)-> command.run();
        Consumer<Integer> consumer = (res)-> {
            if (res == null) {
                resultQueue.offer(-1);
            } else {
                resultQueue.offer(res);
            }
        };

        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mSm,
                (sm) -> sm.setPreferredDataSubscriptionId(subId, false,
                        executor, consumer));
        int res = -1;
        try {
            res = resu"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SubscriptionManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.SubscriptionManagerTest"	"testGetActiveSubscriptionInfoForIcc"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/cts/SubscriptionManagerTest.java]:[permission]:[2]:method_text:[sions(mSm,                (sm) -> sm.getActiveSubscriptionInfoForIcc(info.getIccId())));    }   ]) :|: 
    public void testGetActiveSubscriptionInfoForIcc() throws Exception {
        if (!isSupported()) return;
        SubscriptionInfo info = ShellIdentityUtils.invokeMethodWithShellPermissions(mSm,
                (sm) -> sm.getActiveSubscriptionInfo(mSubId));
        assertNotNull(ShellIdentityUtils.invokeMethodWithShellPermissions(mSm,
                (sm) -> sm.getActiveSubscriptionInfoForIcc(info.getIccId())));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SubscriptionManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.SubscriptionManagerTest"	"testGetResourcesForSubId"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/SubscriptionManagerTest.java]:[permission]:[1]:method_text:[  assertEquals(mSm.getActiveSubscriptionInfo(mSubId).getMnc(), r.getConfiguration().mnc);    }   ]) :|: 
    public void testGetResourcesForSubId() {
        if (!isSupported()) return;
        Resources r = ShellIdentityUtils.invokeMethodWithShellPermissions(mSm,
                (sm) -> sm.getResourcesForSubId(InstrumentationRegistry.getContext(), mSubId));
        // this is an old method which returns mcc/mnc as ints, so use the old SM.getMcc/Mnc methods
        // because they also use ints
        assertEquals(mSm.getActiveSubscriptionInfo(mSubId).getMcc(), r.getConfiguration().mcc);
        assertEquals(mSm.getActiveSubscriptionInfo(mSubId).getMnc(), r.getConfiguration().mnc);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SubscriptionManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.SubscriptionManagerTest"	"testActiveSubscriptions"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/cts/SubscriptionManagerTest.java]:[permission]:[2]:method_text:[()                        < subList.get(i).getSubscriptionId());            }        }    }   ]) :|: 
    public void testActiveSubscriptions() throws Exception {
        if (!isSupported()) return;

        List<SubscriptionInfo> subList = ShellIdentityUtils.invokeMethodWithShellPermissions(mSm,
                (sm) -> sm.getActiveSubscriptionInfoList());
        int[] idList = ShellIdentityUtils.invokeMethodWithShellPermissions(mSm,
                (sm) -> sm.getActiveSubscriptionIdList());
        // Assert when there is no sim card present or detected
        assertNotNull(""Active subscriber required"", subList);
        assertNotNull(""Active subscriber required"", idList);
        assertFalse(""Active subscriber required"", subList.isEmpty());
        assertNotEquals(""Active subscriber required"", 0, idList.length);
        for (int i = 0; i < subList.size(); i++) {
            assertTrue(subList.get(i).getSubscriptionId() >= 0);
            assertTrue(subList.get(i).getSimSlotIndex() >= 0);
            assertTrue(ArrayUtils.contains(idList, subList.get(i).getSubscriptionId()));
            if (i >= 1) {
                assertTrue(subList.get(i - 1).getSimSlotIndex()
                        <= subList.get(i).getSimSlotIndex());
                assertTrue(subList.get(i - 1).getSimSlotIndex() < subList.get(i).getSimSlotIndex()
                        || subList.get(i - 1).getSubscriptionId()
                        < subList.get(i).getSubscriptionId());
            }
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SubscriptionManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.SubscriptionManagerTest"	"testSubscriptionInfoRecord"	"CtsTelephonyTestCases"	"1: permission"	"([3:/android/telephony/cts/SubscriptionManagerTest.java]:[permission]:[3]:method_text:[TATE"");        } catch (SecurityException expected) {            // expected        }    }   ]) :|: 
    public void testSubscriptionInfoRecord() {
        if (!isSupported() || !isAutomotive()) return;

        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        uiAutomation.adoptShellPermissionIdentity();
        String uniqueId = ""00:01:02:03:04:05"";
        String displayName = ""device_name"";
        mSm.addSubscriptionInfoRecord(uniqueId, displayName, 0,
                SubscriptionManager.SUBSCRIPTION_TYPE_REMOTE_SIM);
        assertNotNull(mSm.getActiveSubscriptionInfoForIcc(uniqueId));
        mSm.removeSubscriptionInfoRecord(uniqueId,
                SubscriptionManager.SUBSCRIPTION_TYPE_REMOTE_SIM);
        assertNull(mSm.getActiveSubscriptionInfoForIcc(uniqueId));
        uiAutomation.dropShellPermissionIdentity();

        // Testing permission fail
        try {
            mSm.addSubscriptionInfoRecord(uniqueId, displayName, 0,
                    SubscriptionManager.SUBSCRIPTION_TYPE_REMOTE_SIM);
            mSm.removeSubscriptionInfoRecord(uniqueId,
                    SubscriptionManager.SUBSCRIPTION_TYPE_REMOTE_SIM);
            fail(""SecurityException should be thrown without MODIFY_PHONE_STATE"");
        } catch (SecurityException expected) {
            // expected
        }

    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SubscriptionManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.SubscriptionManagerTest"	"testSetDefaultVoiceSubId"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/cts/SubscriptionManagerTest.java]:[permission]:[2]:method_text:[ntation().getUiAutomation()                    .dropShellPermissionIdentity();        }    }   ]) :|: 
    public void testSetDefaultVoiceSubId() {
        if (!isSupported()) return;

        int oldSubId = SubscriptionManager.getDefaultVoiceSubscriptionId();
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity();
        try {
            mSm.setDefaultVoiceSubscriptionId(SubscriptionManager.INVALID_SUBSCRIPTION_ID);
            assertEquals(SubscriptionManager.INVALID_SUBSCRIPTION_ID,
                    SubscriptionManager.getDefaultVoiceSubscriptionId());
            mSm.setDefaultVoiceSubscriptionId(oldSubId);
            assertEquals(oldSubId, SubscriptionManager.getDefaultVoiceSubscriptionId());
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                    .dropShellPermissionIdentity();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SubscriptionManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.SubscriptionManagerTest"	"testSubscriptionGrouping"	"CtsTelephonyTestCases"	"1: permission"	"([4:/android/telephony/cts/SubscriptionManagerTest.java]:[permission]:[4]:method_text:[p, null);            fail();        } catch (NullPointerException expected) {        }    }   ]) :|: 
    public void testSubscriptionGrouping() throws Exception {
        if (!isSupported()) return;

        // Set subscription group with current sub Id. This should fail
        // because we don't have MODIFY_PHONE_STATE or carrier privilege permission.
        List<Integer> subGroup = new ArrayList();
        subGroup.add(mSubId);
        try {
            mSm.createSubscriptionGroup(subGroup);
            fail();
        } catch (SecurityException expected) {
        }

        // Getting subscriptions in group should return null as setSubscriptionGroup
        // should fail.
        SubscriptionInfo info = mSm.getActiveSubscriptionInfo(mSubId);
        assertNull(info.getGroupUuid());

        // Remove from subscription group with current sub Id. This should fail
        // because we don't have MODIFY_PHONE_STATE or carrier privilege permission.
        try {
            mSm.addSubscriptionsIntoGroup(subGroup, null);
            fail();
        } catch (NullPointerException expected) {
        }

        // Add into subscription group that doesn't exist. This should fail
        // because we don't have MODIFY_PHONE_STATE or carrier privilege permission.
        try {
            ParcelUuid groupUuid = new ParcelUuid(UUID.randomUUID());
            mSm.addSubscriptionsIntoGroup(subGroup, groupUuid);
            fail();
        } catch (SecurityException expected) {
        }

        // Remove from subscription group with current sub Id. This should fail
        // because we don't have MODIFY_PHONE_STATE or carrier privilege permission.
        try {
            mSm.removeSubscriptionsFromGroup(subGroup, null);
            fail();
        } catch (NullPointerException expected) {
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SubscriptionManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.SubscriptionManagerTest"	"testSubscriptionGroupingWithPermission"	"CtsTelephonyTestCases"	"1: permission"	"([7:/android/telephony/cts/SubscriptionManagerTest.java]:[permission]:[7]:method_text:[nsInGroup(uuid);        assertNotNull(infoList);        assertTrue(infoList.isEmpty());    }   ]) :|: 
    public void testSubscriptionGroupingWithPermission() throws Exception {
        if (!isSupported()) return;

        // Set subscription group with current sub Id.
        List<Integer> subGroup = new ArrayList();
        subGroup.add(mSubId);
        ParcelUuid uuid = ShellIdentityUtils.invokeMethodWithShellPermissions(mSm,
                (sm) -> sm.createSubscriptionGroup(subGroup));

        // Getting subscriptions in group.
        List<SubscriptionInfo> infoList = mSm.getSubscriptionsInGroup(uuid);
        assertNotNull(infoList);
        assertEquals(1, infoList.size());
        assertNull(infoList.get(0).getGroupUuid());

        infoList = ShellIdentityUtils.invokeMethodWithShellPermissions(mSm,
                (sm) -> sm.getSubscriptionsInGroup(uuid));
        assertNotNull(infoList);
        assertEquals(1, infoList.size());
        assertEquals(uuid, infoList.get(0).getGroupUuid());

        List<SubscriptionInfo> availableInfoList;
        try {
            mSm.getAvailableSubscriptionInfoList();
            fail(""SecurityException should be thrown without READ_PRIVILEGED_PHONE_STATE"");
        } catch (SecurityException ex) {
            // Ignore
        }
        availableInfoList = ShellIdentityUtils.invokeMethodWithShellPermissions(mSm,
                (sm) -> sm.getAvailableSubscriptionInfoList());
        if (availableInfoList.size() > 1) {
            List<Integer> availableSubGroup = availableInfoList.stream()
                    .map(info -> info.getSubscriptionId())
                    .filter(subId -> subId != mSubId)
                    .collect(Collectors.toList());

            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mSm,
                    (sm) -> sm.addSubscriptionsIntoGroup(availableSubGroup, uuid));

            infoList = mSm.getSubscriptionsInGroup(uuid);
            assertNotNull(infoList);
            assertEquals(availableInfoList.size(), infoList.size());

            ShellIdentityUtils.invokeMethodWit"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SubscriptionManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.SubscriptionManagerTest"	"testAddSubscriptionIntoNewGroupWithPermission"	"CtsTelephonyTestCases"	"1: permission"	"([4:/android/telephony/cts/SubscriptionManagerTest.java]:[permission]:[4]:method_text:[nsInGroup(uuid);        assertNotNull(infoList);        assertTrue(infoList.isEmpty());    }   ]) :|: 
    public void testAddSubscriptionIntoNewGroupWithPermission() throws Exception {
        if (!isSupported()) return;

        // Set subscription group with current sub Id.
        List<Integer> subGroup = new ArrayList();
        subGroup.add(mSubId);
        ParcelUuid uuid = new ParcelUuid(UUID.randomUUID());
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mSm,
                (sm) -> sm.addSubscriptionsIntoGroup(subGroup, uuid));

        // Getting subscriptions in group.
        List<SubscriptionInfo> infoList = mSm.getSubscriptionsInGroup(uuid);
        assertNotNull(infoList);
        assertEquals(1, infoList.size());
        assertNull(infoList.get(0).getGroupUuid());

        infoList = ShellIdentityUtils.invokeMethodWithShellPermissions(mSm,
                (sm) -> sm.getSubscriptionsInGroup(uuid));
        assertNotNull(infoList);
        assertEquals(1, infoList.size());
        assertEquals(uuid, infoList.get(0).getGroupUuid());

        // Remove from subscription group with current sub Id.
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mSm,
                (sm) -> sm.removeSubscriptionsFromGroup(subGroup, uuid));

        infoList = mSm.getSubscriptionsInGroup(uuid);
        assertNotNull(infoList);
        assertTrue(infoList.isEmpty());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SubscriptionManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.SubscriptionManagerTest"	"testSettingOpportunisticSubscription"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/SubscriptionManagerTest.java]:[permission]:[1]:method_text:[riptionInfo info = mSm.getActiveSubscriptionInfo(mSubId);        info.isOpportunistic();    }   ]) :|: 
    public void testSettingOpportunisticSubscription() throws Exception {
        if (!isSupported()) return;

        // Set subscription to be opportunistic. This should fail
        // because we don't have MODIFY_PHONE_STATE or carrier privilege permission.
        try {
            mSm.setOpportunistic(true, mSubId);
            fail();
        } catch (SecurityException expected) {
        }

        // Shouldn't crash.
        SubscriptionInfo info = mSm.getActiveSubscriptionInfo(mSubId);
        info.isOpportunistic();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SubscriptionManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.SubscriptionManagerTest"	"testSetUiccApplicationsEnabled"	"CtsTelephonyTestCases"	"1: permission"	"([3:/android/telephony/cts/SubscriptionManagerTest.java]:[permission]:[3]:method_text:[assertTrue(mSm.getActiveSubscriptionInfo(mSubId).areUiccApplicationsEnabled());        }    }   ]) :|: 
    public void testSetUiccApplicationsEnabled() {
        if (!isSupported()) return;

        boolean canDisable = ShellIdentityUtils.invokeMethodWithShellPermissions(mSm,
                (sm) -> sm.canDisablePhysicalSubscription());
        if (canDisable) {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mSm,
                    (sm) -> sm.setUiccApplicationsEnabled(mSubId, false));
            assertFalse(mSm.getActiveSubscriptionInfo(mSubId).areUiccApplicationsEnabled());

            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mSm,
                    (sm) -> sm.setUiccApplicationsEnabled(mSubId, true));
            assertTrue(mSm.getActiveSubscriptionInfo(mSubId).areUiccApplicationsEnabled());
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SubscriptionManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.SubscriptionManagerTest"	"testGetEnabledSubscriptionId"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/SubscriptionManagerTest.java]:[permission]:[1]:method_text:[(sm) -> sm.getEnabledSubscriptionId(slotId));        assertEquals(mSubId, enabledSubId);    }   ]) :|: 
    public void testGetEnabledSubscriptionId() {
        if (!isSupported()) return;
        int slotId = SubscriptionManager.getSlotIndex(mSubId);
        if (!SubscriptionManager.isValidSlotIndex(slotId)) {
            fail(""Invalid slot id "" + slotId + "" for subscription id "" + mSubId);
        }
        int enabledSubId = executeWithShellPermissionAndDefault(-1, mSm,
                (sm) -> sm.getEnabledSubscriptionId(slotId));
        assertEquals(mSubId, enabledSubId);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SubscriptionManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.SubscriptionManagerTest"	"testSetAndCheckSubscriptionEnabled"	"CtsTelephonyTestCases"	"1: permission"	"([7:/android/telephony/cts/SubscriptionManagerTest.java]:[permission]:[7]:method_text:[   } catch (InterruptedException e) {            fail(""InterruptedException"");        }    }   ]) :|: 
    public void testSetAndCheckSubscriptionEnabled() {
        if (!isSupported()) return;
        boolean enabled = executeWithShellPermissionAndDefault(false, mSm,
                (sm) -> sm.isSubscriptionEnabled(mSubId));

        AtomicBoolean waitForIsEnabledValue = new AtomicBoolean(!enabled);
        // wait for the first call to take effect
        Object lock = new Object();
        AtomicBoolean setSubscriptionEnabledCallCompleted = new AtomicBoolean(false);
        TestThread t = new TestThread(new Runnable() {
            @Override
            public void run() {
                Looper.prepare();

                SubscriptionManager.OnSubscriptionsChangedListener listener =
                        new SubscriptionManager.OnSubscriptionsChangedListener() {
                            @Override
                            public void onSubscriptionsChanged() {
                                boolean waitForValue = waitForIsEnabledValue.get();
                                if (executeWithShellPermissionAndDefault(!waitForValue, mSm,
                                        (sm) -> sm.isSubscriptionEnabled(mSubId)) == waitForValue) {
                                    synchronized (lock) {
                                        setSubscriptionEnabledCallCompleted.set(true);
                                        lock.notifyAll();
                                    }
                                }
                            }
                        };
                mSm.addOnSubscriptionsChangedListener(listener);

                Looper.loop();
            }
        });

        try {
            t.start();
            // Enable or disable subscription may require users UX confirmation or may not be
            // supported. Call APIs to make sure there's no crash.
            executeWithShellPermissionAndDefault(false, mSm,
                    (sm) -> sm.setSubscriptionEnabled(mSubId, !enabled));

            synchronized (lock) {"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SubscriptionManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.SubscriptionManagerTest"	"testGetActiveDataSubscriptionId"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/SubscriptionManagerTest.java]:[permission]:[1]:method_text:[tSubscriptionId() == activeDataSubIdCurrent);            assertTrue(foundSub);        }    }   ]) :|: 
    public void testGetActiveDataSubscriptionId() {
        if (!isSupported()) return;

        int activeDataSubIdCurrent = executeWithShellPermissionAndDefault(
                SubscriptionManager.INVALID_SUBSCRIPTION_ID, mSm,
                (sm) -> sm.getActiveDataSubscriptionId());

        if (activeDataSubIdCurrent != SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
            List<SubscriptionInfo> subscriptionInfos = mSm.getCompleteActiveSubscriptionInfoList();
            boolean foundSub = subscriptionInfos.stream()
                    .anyMatch(x -> x.getSubscriptionId() == activeDataSubIdCurrent);
            assertTrue(foundSub);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SubscriptionManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.SubscriptionManagerTest"	"testSetPreferredDataSubscriptionId"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/SubscriptionManagerTest.java]:[permission]:[1]:method_text:[itch data back to previous preferredSubId.        setPreferredDataSubId(preferredSubId);    }   ]) :|: 
    public void testSetPreferredDataSubscriptionId() {
        if (!isSupported()) return;
        int preferredSubId = executeWithShellPermissionAndDefault(-1, mSm,
                (sm) -> sm.getPreferredDataSubscriptionId());
        if (preferredSubId != SubscriptionManager.DEFAULT_SUBSCRIPTION_ID) {
            // Make sure to switch back to primary/default data sub first.
            setPreferredDataSubId(SubscriptionManager.DEFAULT_SUBSCRIPTION_ID);
        }

        List<SubscriptionInfo> subscriptionInfos = mSm.getCompleteActiveSubscriptionInfoList();

        for (SubscriptionInfo subInfo : subscriptionInfos) {
            // Only test on opportunistic subscriptions.
            if (!subInfo.isOpportunistic()) continue;
            setPreferredDataSubId(subInfo.getSubscriptionId());
        }

        // Switch data back to previous preferredSubId.
        setPreferredDataSubId(preferredSubId);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SubscriptionManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.SubscriptionManagerTest"	"testRestoreAllSimSpecificSettingsFromBackup"	"CtsTelephonyTestCases"	"1: permission"	"([25:/android/telephony/cts/SubscriptionManagerTest.java]:[permission]:[25]:method_text:[ion expected"");        } catch (SecurityException e) {            // expected        }    }   ]) :|: 
    public void testRestoreAllSimSpecificSettingsFromBackup() throws Exception {
        if (!isSupported()) return;

        int activeDataSubId = ShellIdentityUtils.invokeMethodWithShellPermissions(mSm,
                (sm) -> sm.getActiveDataSubscriptionId());
        assertNotEquals(activeDataSubId, SubscriptionManager.INVALID_SUBSCRIPTION_ID);
        SubscriptionInfo activeSubInfo = ShellIdentityUtils.invokeMethodWithShellPermissions(mSm,
                (sm) -> sm.getActiveSubscriptionInfo(activeDataSubId));
        String isoCountryCode = activeSubInfo.getCountryIso();

        byte[] backupData = ShellIdentityUtils.invokeMethodWithShellPermissions(mSm,
                (sm) -> sm.getAllSimSpecificSettingsForBackup());
        assertTrue(backupData.length > 0);

        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.KEY_EDITABLE_ENHANCED_4G_LTE_BOOL, true);
        bundle.putBoolean(CarrierConfigManager.KEY_HIDE_ENHANCED_4G_LTE_BOOL, false);
        overrideCarrierConfig(bundle, activeDataSubId);

        // Get the original ims values.
        ImsManager imsManager = InstrumentationRegistry.getContext().getSystemService(
                ImsManager.class);
        ImsMmTelManager mMmTelManager = imsManager.getImsMmTelManager(activeDataSubId);
        boolean isVolteVtEnabledOriginal = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mMmTelManager, (m) -> m.isAdvancedCallingSettingEnabled());
        boolean isVtImsEnabledOriginal = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mMmTelManager, (m) -> m.isVtSettingEnabled());
        boolean isVoWiFiSettingEnabledOriginal =
                ShellIdentityUtils.invokeMethodWithShellPermissions(
                        mMmTelManager, (m) -> m.isVoWiFiSettingEnabled());
        int voWifiModeOriginal = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mMmTelManager, (m) -> m.getVoWiFiModeSetting());"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SubscriptionManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.SubscriptionManagerTest"	"testSetAndGetD2DStatusSharing"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/cts/SubscriptionManagerTest.java]:[permission]:[2]:method_text:[ce(mSubId, originalD2DStatusSharing);        uiAutomation.dropShellPermissionIdentity();    }   ]) :|: 
    public void testSetAndGetD2DStatusSharing() {
        if (!isSupported()) return;

        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        uiAutomation.adoptShellPermissionIdentity(MODIFY_PHONE_STATE);
        int originalD2DStatusSharing = mSm.getDeviceToDeviceStatusSharingPreference(mSubId);
        mSm.setDeviceToDeviceStatusSharingPreference(mSubId,
                SubscriptionManager.D2D_SHARING_ALL_CONTACTS);
        assertEquals(SubscriptionManager.D2D_SHARING_ALL_CONTACTS,
                mSm.getDeviceToDeviceStatusSharingPreference(mSubId));
        mSm.setDeviceToDeviceStatusSharingPreference(mSubId, SubscriptionManager.D2D_SHARING_ALL);
        assertEquals(SubscriptionManager.D2D_SHARING_ALL,
                mSm.getDeviceToDeviceStatusSharingPreference(mSubId));
        mSm.setDeviceToDeviceStatusSharingPreference(mSubId, originalD2DStatusSharing);
        uiAutomation.dropShellPermissionIdentity();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/SubscriptionManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.CarrierMessagingServiceWrapperTest"	"disconnect"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/CarrierMessagingServiceWrapperTest.java]:[permission]:[1]:method_text:[**     * Tests that the device properly connects to available CarrierMessagingServices.     */   ]) :|: /*
 *.
 */
package android.telephony.cts;

import static android.telephony.cts.FakeCarrierMessagingService.FAKE_MESSAGE_REF;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;

import android.content.Context;
import android.net.Uri;
import android.service.carrier.CarrierMessagingService;
import android.service.carrier.CarrierMessagingServiceWrapper;
import android.service.carrier.MessagePdu;
import android.telephony.SmsMessage;
import android.telephony.SubscriptionManager;
import android.telephony.TelephonyManager;

import androidx.test.InstrumentationRegistry;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;

import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/**
 * Build, install and run the tests by running the commands below:
 *  make cts -j64
 *  cts-tradefed run cts -m CtsTelephonyTestCases --test android.telephony.cts.
 *  CarrierMessagingServiceWrapperTest
 */
public class CarrierMessagingServiceWrapperTest {
    private TelephonyManager mTelephonyManager;
    private int mTestSub;
    private Context mContext;
    private CarrierMessagingServiceWrapper mServiceWrapper;
    private CompletableFuture<Void> mServiceReadyFuture = new CompletableFuture<>();
    private Runnable mOnServiceReadyCallback = () -> mServiceReadyFuture.complete(null);
    private String mPdu = ""07916164260220F0040B914151245584F600006060605130308A04D4F29C0E"";
    private static final int TIMEOUT_IN_MS = 1000;
    @Mock
    private CarrierMessagingServiceWrapper.CarrierMessagingCallback mCallback;

    private static Context getContext() {
        return InstrumentationRegistry"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/CarrierMessagingServiceWrapperTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.CarrierMessagingServiceWrapperTest"	"testConnectToMessagingServiceWrapper"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/cts/CarrierMessagingServiceWrapperTest.java]:[permission]:[2]:method_text:[indResult);        waitForServiceReady(""Service "" + packageName + "" should be ready."");    }   ]) :|: 
    public void testConnectToMessagingServiceWrapper() {
        String packageName = ""android.telephony.cts"";
        mServiceWrapper = new CarrierMessagingServiceWrapper();

        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(""android.permission.BIND_CARRIER_SERVICES"");
        boolean bindResult = mServiceWrapper.bindToCarrierMessagingService(
                mContext, packageName, Runnable::run, mOnServiceReadyCallback);
        assertTrue(bindResult);

        waitForServiceReady(""Service "" + packageName + "" should be ready."");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/CarrierMessagingServiceWrapperTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.CarrierConfigManagerTest"	"testRevokePermission"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/CarrierConfigManagerTest.java]:[permission]:[1]:method_text:[l();        }        config = mConfigManager.getConfig();        checkConfig(config);    }   ]) :|: 
    @AsbSecurityTest(cveBugId = 73136824)
    public void testRevokePermission() {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }
        PersistableBundle config;

        try {
            setOpMode(""--uid android.telephony.cts"", OPSTR_READ_PHONE_STATE, MODE_IGNORED);
        } catch (IOException e) {
            fail();
        }

        config = mConfigManager.getConfig();
        assertTrue(config.isEmptyParcel());

        try {
            setOpMode(""--uid android.telephony.cts"", OPSTR_READ_PHONE_STATE, MODE_ALLOWED);
        } catch (IOException e) {
            fail();
        }

        config = mConfigManager.getConfig();
        checkConfig(config);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/CarrierConfigManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.CarrierConfigManagerTest"	"testCarrierConfigManagerResultDependentApi"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/CarrierConfigManagerTest.java]:[permission]:[1]:method_text:[onfig(int, PersistableBundle)}     * correctly overrides the Carrier Name (SPN) string.     */   ]) :|: 
    public void testCarrierConfigManagerResultDependentApi() {
        assertNotNull(ShellIdentityUtils.invokeMethodWithShellPermissions(mConfigManager,
                (cm) -> cm.getDefaultCarrierServicePackageName()));
    }

    /**
     * This checks that {@link CarrierConfigManager#overrideConfig(int, PersistableBundle)}
     * correctly overrides the Carrier Name (SPN) string.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/CarrierConfigManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.CarrierConfigManagerTest"	"testCarrierConfigNameOverride"	"CtsTelephonyTestCases"	"1: permission"	"([5:/android/telephony/cts/CarrierConfigManagerTest.java]:[permission]:[5]:method_text:[ager.overrideConfig(subId, null);            ui.dropShellPermissionIdentity();        }    }   ]) :|: 
    public void testCarrierConfigNameOverride() throws Exception {
        if (!isSimCardPresent()
                || mTelephonyManager.getServiceState().getState() != STATE_IN_SERVICE) {
            return;
        }

        // Adopt shell permission so the required permission (android.permission.MODIFY_PHONE_STATE)
        // is granted.
        UiAutomation ui = getInstrumentation().getUiAutomation();
        ui.adoptShellPermissionIdentity();

        int subId = SubscriptionManager.getDefaultSubscriptionId();
        TestThread t = new TestThread(new Runnable() {
            @Override
            public void run() {
                Looper.prepare();

                OnSubscriptionsChangedListener listener =
                        new OnSubscriptionsChangedListener() {
                            @Override
                            public void onSubscriptionsChanged() {
                                if (CARRIER_NAME_OVERRIDE.equals(
                                        mTelephonyManager.getSimOperatorName())) {
                                    COUNT_DOWN_LATCH.countDown();
                                }
                            }
                        };
                mSubscriptionManager.addOnSubscriptionsChangedListener(listener);

                PersistableBundle carrierNameOverride = new PersistableBundle(3);
                carrierNameOverride.putBoolean(KEY_CARRIER_NAME_OVERRIDE_BOOL, true);
                carrierNameOverride.putBoolean(KEY_FORCE_HOME_NETWORK_BOOL, true);
                carrierNameOverride.putString(KEY_CARRIER_NAME_STRING, CARRIER_NAME_OVERRIDE);
                mConfigManager.overrideConfig(subId, carrierNameOverride);

                Looper.loop();
            }
        });

        try {
            t.start();
            boolean didCarrierNameUpdate =
                    COUNT_DOWN_LATCH.await(BROADCAST_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
            if (!didCarrierNameUpdate) {
                fail(""Car"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/CarrierConfigManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.CarrierConfigManagerTest"	"testExtraRebroadcastOnUnlock"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/cts/CarrierConfigManagerTest.java]:[permission]:[1]:method_text:[        getContext().unregisterReceiver(receiver);            receiver = null;        }    }   ]) :|: 
    public void testExtraRebroadcastOnUnlock() throws Throwable {
        if (!hasTelephony()) {
            return;
        }

        BlockingQueue<Boolean> queue = new ArrayBlockingQueue<Boolean>(5);
        BroadcastReceiver receiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                if (CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED.equals(intent.getAction())) {
                    queue.add(new Boolean(true));
                    // verify that REBROADCAST_ON_UNLOCK is populated
                    assertFalse(
                            intent.getBooleanExtra(CarrierConfigManager.EXTRA_REBROADCAST_ON_UNLOCK,
                            true));
                }
            }
        };

        try {
            final IntentFilter filter =
                    new IntentFilter(CarrierConfigManager.ACTION_CARRIER_CONFIG_CHANGED);
            getContext().registerReceiver(receiver, filter);

            // verify that carrier config is received
            int subId = SubscriptionManager.getDefaultSubscriptionId();
            getInstrumentation().getUiAutomation().adoptShellPermissionIdentity();
            mConfigManager.notifyConfigChangedForSubId(subId);

            Boolean broadcastReceived = queue.poll(BROADCAST_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
            assertNotNull(broadcastReceived);
            assertTrue(broadcastReceived);
        } finally {
            // unregister receiver
            getContext().unregisterReceiver(receiver);
            receiver = null;
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/CarrierConfigManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsRegistrationAttributesTest"	"testRegistrationTypeToTransportAttr"	"CtsTelephonyTestCases"	"1: INTERNET"	"([5:/android/telephony/ims/cts/ImsRegistrationAttributesTest.java]:[INTERNET]:[5]:method_text:[ertNotNull(attr.getFeatureTags());        assertEquals(0, attr.getFeatureTags().size());    }   ]) :|: 
    public void testRegistrationTypeToTransportAttr() {
        ArraySet<String> featureTags = new ArraySet<>();
        featureTags.add(""+g.3gpp.icsi-ref=\""urn%3Aurn-7%3A3gpp-service.ims.icsi.oma.cpm.msg\"""");
        featureTags.add(""+g.3gpp.icsi-ref=\""urn%3Aurn-7%3A3gpp-service.ims.icsi.oma.cpm.session\"""");
        featureTags.add(""+g.gsma.callcomposer"");

        // IWLAN
        ImsRegistrationAttributes attr = new ImsRegistrationAttributes.Builder(
                ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN).setFeatureTags(featureTags)
                .build();
        assertEquals(ImsRegistrationImplBase.REGISTRATION_TECH_IWLAN,
                attr.getRegistrationTechnology());
        assertEquals(AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
                attr.getTransportType());
        assertEquals(0, (attr.getAttributeFlags()
                & ImsRegistrationAttributes.ATTR_EPDG_OVER_CELL_INTERNET));
        assertEquals(featureTags, attr.getFeatureTags());

        //LTE
        attr = new ImsRegistrationAttributes.Builder(
                ImsRegistrationImplBase.REGISTRATION_TECH_LTE).build();
        assertEquals(ImsRegistrationImplBase.REGISTRATION_TECH_LTE,
                attr.getRegistrationTechnology());
        assertEquals(AccessNetworkConstants.TRANSPORT_TYPE_WWAN,
                attr.getTransportType());
        assertEquals(0, (attr.getAttributeFlags()
                & ImsRegistrationAttributes.ATTR_EPDG_OVER_CELL_INTERNET));
        assertNotNull(attr.getFeatureTags());
        assertEquals(0, attr.getFeatureTags().size());

        // cross sim
        attr = new ImsRegistrationAttributes.Builder(
                ImsRegistrationImplBase.REGISTRATION_TECH_CROSS_SIM).build();
        assertEquals(ImsRegistrationImplBase.REGISTRATION_TECH_CROSS_SIM,
                attr.getRegistrationTechnology());
        assertEquals(AccessNetworkConstants.TRANSPORT_TYPE_WLAN,
                attr.getTransportType());
        assertEquals(ImsRegist"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsRegistrationAttributesTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsMmTelManagerTest"	"testGetVoWiFiSetting_noPermission"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/ims/cts/ImsMmTelManagerTest.java]:[permission]:[2]:method_text:[lling setting is returned. Also ensure the     * ContentObserver is triggered properly.     */   ]) :|: 
    public void testGetVoWiFiSetting_noPermission() {
        try {
            ImsManager imsManager = getContext().getSystemService(ImsManager.class);
            ImsMmTelManager mMmTelManager = imsManager.getImsMmTelManager(sTestSub);
            boolean isEnabled = mMmTelManager.isVoWiFiSettingEnabled();
            fail(""Expected SecurityException for missing permissions"");
        } catch (SecurityException ex) {
            /* Expected */
        }
    }

    /**
     * Given the advanced calling setting is editable and not hidden
     * (see {@link CarrierConfigManager#KEY_EDITABLE_ENHANCED_4G_LTE_BOOL}, and
     * {@link CarrierConfigManager#KEY_HIDE_ENHANCED_4G_LTE_BOOL}), set the advanced
     * calling setting and ensure the correct calling setting is returned. Also ensure the
     * ContentObserver is triggered properly.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsMmTelManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsMmTelManagerTest"	"testAdvancedCallingSetting"	"CtsTelephonyTestCases"	"1: permission"	"([4:/android/telephony/ims/cts/ImsMmTelManagerTest.java]:[permission]:[4]:method_text:[t is queried successfully. Also ensure the ContentObserver     * is triggered properly.     */   ]) :|: 
    public void testAdvancedCallingSetting() throws Exception {
        // Ensure advanced calling setting is editable.
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.KEY_EDITABLE_ENHANCED_4G_LTE_BOOL, true);
        bundle.putBoolean(CarrierConfigManager.KEY_HIDE_ENHANCED_4G_LTE_BOOL, false);
        overrideCarrierConfig(bundle);
        // Register Observer
        Uri callingUri = Uri.withAppendedPath(
                SubscriptionManager.ADVANCED_CALLING_ENABLED_CONTENT_URI, """" + sTestSub);
        CountDownLatch contentObservedLatch = new CountDownLatch(1);
        ContentObserver observer = createObserver(callingUri, contentObservedLatch);

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        ImsMmTelManager mMmTelManager = imsManager.getImsMmTelManager(sTestSub);
        boolean isEnabled = ShellIdentityUtils.invokeMethodWithShellPermissions(mMmTelManager,
                ImsMmTelManager::isAdvancedCallingSettingEnabled);
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                (m) -> m.setAdvancedCallingSettingEnabled(!isEnabled));

        waitForLatch(contentObservedLatch, observer);
        boolean isEnabledResult = ShellIdentityUtils.invokeMethodWithShellPermissions(mMmTelManager,
                ImsMmTelManager::isAdvancedCallingSettingEnabled);
        assertEquals(""isAdvancedCallingSettingEnabled does not reflect the new value set by ""
                        + ""setAdvancedCallingSettingEnabled"", !isEnabled, isEnabledResult);

        // Set back to default
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                (m) -> m.setAdvancedCallingSettingEnabled(isEnabled));
        // restore original carrier config.
        overrideCarrierConfig(null);
    }

    /**
     * Set the VT setting and ensure it is queried successfully. Also ensure the ContentObserver
     * is trigger"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsMmTelManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsMmTelManagerTest"	"testVtSetting"	"CtsTelephonyTestCases"	"1: permission"	"([4:/android/telephony/ims/cts/ImsMmTelManagerTest.java]:[permission]:[4]:method_text:[t is queried successfully. Also ensure the ContentObserver     * is triggered properly.     */   ]) :|: 
    public void testVtSetting() throws Exception {
        // Register Observer
        Uri callingUri = Uri.withAppendedPath(
                SubscriptionManager.VT_ENABLED_CONTENT_URI, """" + sTestSub);
        CountDownLatch contentObservedLatch = new CountDownLatch(1);
        ContentObserver observer = createObserver(callingUri, contentObservedLatch);

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        ImsMmTelManager mMmTelManager = imsManager.getImsMmTelManager(sTestSub);
        boolean isEnabled = ShellIdentityUtils.invokeMethodWithShellPermissions(mMmTelManager,
                ImsMmTelManager::isVtSettingEnabled);
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                (m) -> m.setVtSettingEnabled(!isEnabled));

        waitForLatch(contentObservedLatch, observer);
        boolean isEnabledResult = ShellIdentityUtils.invokeMethodWithShellPermissions(mMmTelManager,
                ImsMmTelManager::isVtSettingEnabled);
        assertEquals(""isVtSettingEnabled does not match the value set by setVtSettingEnabled"",
                !isEnabled, isEnabledResult);

        // Set back to default
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                (m) -> m.setVtSettingEnabled(isEnabled));
    }

    /**
     * Set the VoWiFi setting and ensure it is queried successfully. Also ensure the ContentObserver
     * is triggered properly.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsMmTelManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsMmTelManagerTest"	"testVoWiFiSetting"	"CtsTelephonyTestCases"	"1: permission"	"([4:/android/telephony/ims/cts/ImsMmTelManagerTest.java]:[permission]:[4]:method_text:[t is queried successfully.     * Also ensure the ContentObserver is triggered properly.     */   ]) :|: 
    public void testVoWiFiSetting() throws Exception {
        PersistableBundle bundle = new PersistableBundle();
        // Do not worry about provisioning for this test
        bundle.putBoolean(KEY_CARRIER_VOLTE_OVERRIDE_WFC_PROVISIONING_BOOL, false);
        bundle.putBoolean(CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONING_REQUIRED_BOOL, false);
        overrideCarrierConfig(bundle);
        // Register Observer
        Uri callingUri = Uri.withAppendedPath(
                SubscriptionManager.WFC_ENABLED_CONTENT_URI, """" + sTestSub);
        CountDownLatch contentObservedLatch = new CountDownLatch(1);
        ContentObserver observer = createObserver(callingUri, contentObservedLatch);

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        ImsMmTelManager mMmTelManager = imsManager.getImsMmTelManager(sTestSub);

        boolean isEnabled = ShellIdentityUtils.invokeMethodWithShellPermissions(mMmTelManager,
                ImsMmTelManager::isVoWiFiSettingEnabled);
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                (m) -> m.setVoWiFiSettingEnabled(!isEnabled));

        waitForLatch(contentObservedLatch, observer);
        boolean isEnabledResult = ShellIdentityUtils.invokeMethodWithShellPermissions(mMmTelManager,
                ImsMmTelManager::isVoWiFiSettingEnabled);
        assertEquals(""isVoWiFiSettingEnabled did not match value set by setVoWiFiSettingEnabled"",
                !isEnabled, isEnabledResult);

        // Set back to default
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                (m) -> m.setVoWiFiSettingEnabled(isEnabled));
        overrideCarrierConfig(null);
    }

    /**
     * Set the cross SIM setting and ensure it is queried successfully.
     * Also ensure the ContentObserver is triggered properly.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsMmTelManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsMmTelManagerTest"	"testCrossSIMSetting"	"CtsTelephonyTestCases"	"1: permission"	"([8:/android/telephony/ims/cts/ImsMmTelManagerTest.java]:[permission]:[8]:method_text:[t is queried successfully. Also ensure the     * ContentObserver is triggered properly.     */   ]) :|: 
    public void testCrossSIMSetting() throws Exception {
        PersistableBundle bundle = new PersistableBundle();
        // Do not worry about provisioning for this test
        bundle.putBoolean(KEY_CARRIER_VOLTE_OVERRIDE_WFC_PROVISIONING_BOOL, false);
        bundle.putBoolean(CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONING_REQUIRED_BOOL, false);
        overrideCarrierConfig(bundle);
        // Register Observer
        Uri callingUri = Uri.withAppendedPath(
                SubscriptionManager.CROSS_SIM_ENABLED_CONTENT_URI, """" + sTestSub);
        CountDownLatch contentObservedLatch = new CountDownLatch(1);
        ContentObserver observer = createObserver(callingUri, contentObservedLatch);

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        ImsMmTelManager mMmTelManager = imsManager.getImsMmTelManager(sTestSub);

        boolean isEnabled = ShellIdentityUtils.invokeThrowableMethodWithShellPermissions(
                mMmTelManager, ImsMmTelManager::isCrossSimCallingEnabled, ImsException.class,
                ""android.permission.READ_PRIVILEGED_PHONE_STATE"");
        ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(mMmTelManager,
                (m) -> m.setCrossSimCallingEnabled(!isEnabled),  ImsException.class,
                ""android.permission.MODIFY_PHONE_STATE"");

        waitForLatch(contentObservedLatch, observer);
        boolean isEnabledResult = ShellIdentityUtils.invokeThrowableMethodWithShellPermissions(
                mMmTelManager,
                ImsMmTelManager::isCrossSimCallingEnabled,
                ImsException.class,
                ""android.permission.READ_PRIVILEGED_PHONE_STATE"");
        assertEquals(""isCrossSimCallingEnabled did not match""
                        + ""value set by setCrossSimCallingEnabled"",
                !isEnabled, isEnabledResult);

        // Set back to default
        ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(mMmTelMan"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsMmTelManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsMmTelManagerTest"	"testVoWiFiRoamingSetting"	"CtsTelephonyTestCases"	"1: permission"	"([5:/android/telephony/ims/cts/ImsMmTelManagerTest.java]:[permission]:[5]:method_text:[    /**     * Expect to fail when Set the VoWiFi Mode setting withour proper permission     */   ]) :|: 
    public void testVoWiFiRoamingSetting() throws Exception {
        Uri callingUri = Uri.withAppendedPath(
                SubscriptionManager.WFC_ROAMING_ENABLED_CONTENT_URI, """" + sTestSub);
        CountDownLatch contentObservedLatch = new CountDownLatch(1);
        ContentObserver observer = createObserver(callingUri, contentObservedLatch);

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        ImsMmTelManager mMmTelManager = imsManager.getImsMmTelManager(sTestSub);
        boolean isEnabled = ShellIdentityUtils.invokeMethodWithShellPermissions(mMmTelManager,
                ImsMmTelManager::isVoWiFiRoamingSettingEnabled);
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                (m) -> m.setVoWiFiRoamingSettingEnabled(!isEnabled));

        waitForLatch(contentObservedLatch, observer);
        boolean isEnabledResult = ShellIdentityUtils.invokeMethodWithShellPermissions(mMmTelManager,
                ImsMmTelManager::isVoWiFiRoamingSettingEnabled);
        assertEquals(""isVoWiFiRoamingSettingEnabled result does not match the value set by ""
                + ""setVoWiFiRoamingSettingEnabled"", !isEnabled, isEnabledResult);

        // Set back to default
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                (m) -> m.setVoWiFiRoamingSettingEnabled(isEnabled));
    }

    /**
     * Expect to fail when Set the VoWiFi Mode setting withour proper permission
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsMmTelManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsMmTelManagerTest"	"testGetVoWiFiModeSetting_noPermission"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/ims/cts/ImsMmTelManagerTest.java]:[permission]:[2]:method_text:[    /**     * Expect to fail when Set the VoWiFi Mode setting withour proper permission     */   ]) :|: 
    public void testGetVoWiFiModeSetting_noPermission() throws Exception {
        try {
            ImsManager imsManager = getContext().getSystemService(ImsManager.class);
            ImsMmTelManager mMmTelManager = imsManager.getImsMmTelManager(sTestSub);
            int oldMode = mMmTelManager.getVoWiFiModeSetting();
            fail(""Expected SecurityException for missing permissoins"");
        } catch (SecurityException ex) {
            /* Expected */
        }

    }

    /**
     * Expect to fail when Set the VoWiFi Mode setting withour proper permission
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsMmTelManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsMmTelManagerTest"	"testGetVoWiFiRoamingModeSetting_noPermission"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/ims/cts/ImsMmTelManagerTest.java]:[permission]:[1]:method_text:[     * Set the VoWiFi Mode setting and ensure the ContentResolver is triggered as well.     */   ]) :|: 
    public void testGetVoWiFiRoamingModeSetting_noPermission() throws Exception {
        try {
            ImsManager imsManager = getContext().getSystemService(ImsManager.class);
            ImsMmTelManager mMmTelManager = imsManager.getImsMmTelManager(sTestSub);
            int oldMode = mMmTelManager.getVoWiFiRoamingModeSetting();
            fail(""Expected SecurityException for missing permissoins"");
        } catch (SecurityException ex) {
            /* Expected */
        }

    }


    /**
     * Set the VoWiFi Mode setting and ensure the ContentResolver is triggered as well.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsMmTelManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsMmTelManagerTest"	"testVoWiFiModeSetting"	"CtsTelephonyTestCases"	"1: permission"	"([4:/android/telephony/ims/cts/ImsMmTelManagerTest.java]:[permission]:[4]:method_text:[     * Set the VoWiFi Mode setting and ensure the ContentResolver is triggered as well.     */   ]) :|: 
    public void testVoWiFiModeSetting() throws Exception {
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(KEY_EDITABLE_WFC_MODE_BOOL, true);
        overrideCarrierConfig(bundle);
        // Register Observer
        Uri callingUri = Uri.withAppendedPath(
                SubscriptionManager.WFC_MODE_CONTENT_URI, """" + sTestSub);
        CountDownLatch contentObservedLatch = new CountDownLatch(1);
        ContentObserver observer = createObserver(callingUri, contentObservedLatch);

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        ImsMmTelManager mMmTelManager = imsManager.getImsMmTelManager(sTestSub);
        int oldMode = ShellIdentityUtils.invokeMethodWithShellPermissions(mMmTelManager,
                ImsMmTelManager::getVoWiFiModeSetting);
        // Keep the mode in the bounds 0-2
        int newMode = (oldMode + 1) % 3;
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                (m) -> m.setVoWiFiModeSetting(newMode));

        waitForLatch(contentObservedLatch, observer);
        int newModeResult = ShellIdentityUtils.invokeMethodWithShellPermissions(mMmTelManager,
                ImsMmTelManager::getVoWiFiModeSetting);
        assertEquals(newMode, newModeResult);

        // Set back to default
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                (m) -> m.setVoWiFiModeSetting(oldMode));
        overrideCarrierConfig(null);
    }

    /**
     * Set the VoWiFi Mode setting and ensure the ContentResolver is triggered as well.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsMmTelManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsMmTelManagerTest"	"testVoWiFiRoamingModeSetting"	"CtsTelephonyTestCases"	"1: permission"	"([5:/android/telephony/ims/cts/ImsMmTelManagerTest.java]:[permission]:[5]:method_text:[    overrideCarrierConfig(null);    }    /**     * Test Permissions on various APIs.     */   ]) :|: 
    public void testVoWiFiRoamingModeSetting() throws Exception {
        PersistableBundle bundle = new PersistableBundle();
        // Ensure the WFC roaming mode will be changed properly
        bundle.putBoolean(KEY_USE_WFC_HOME_NETWORK_MODE_IN_ROAMING_NETWORK_BOOL, false);
        bundle.putBoolean(KEY_EDITABLE_WFC_ROAMING_MODE_BOOL, true);
        overrideCarrierConfig(bundle);
        // Register Observer
        Uri callingUri = Uri.withAppendedPath(
                SubscriptionManager.WFC_ROAMING_MODE_CONTENT_URI, """" + sTestSub);
        CountDownLatch contentObservedLatch = new CountDownLatch(1);
        ContentObserver observer = createObserver(callingUri, contentObservedLatch);

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        ImsMmTelManager mMmTelManager = imsManager.getImsMmTelManager(sTestSub);
        int oldMode = ShellIdentityUtils.invokeMethodWithShellPermissions(mMmTelManager,
                ImsMmTelManager::getVoWiFiRoamingModeSetting);
        // Keep the mode in the bounds 0-2
        int newMode = (oldMode + 1) % 3;
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                (m) -> m.setVoWiFiRoamingModeSetting(newMode));

        waitForLatch(contentObservedLatch, observer);
        int newModeResult = ShellIdentityUtils.invokeMethodWithShellPermissions(mMmTelManager,
                ImsMmTelManager::getVoWiFiRoamingModeSetting);
        assertEquals(""getVoWiFiRoamingModeSetting was not set to value set by""
                + ""setVoWiFiRoamingModeSetting"", newMode, newModeResult);

        // Set back to default
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                (m) -> m.setVoWiFiRoamingModeSetting(oldMode));
        overrideCarrierConfig(null);
    }

    /**
     * Test Permissions on various APIs.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsMmTelManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsMmTelManagerTest"	"testMethodPermissions"	"CtsTelephonyTestCases"	"1: permission"	"([43:/android/telephony/ims/cts/ImsMmTelManagerTest.java]:[permission]:[43]:method_text:[ext getContext() {        return InstrumentationRegistry.getInstrumentation().getContext();    }}]) :|: 
    public void testMethodPermissions() throws Exception {
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        ImsMmTelManager mMmTelManager = imsManager.getImsMmTelManager(sTestSub);
        // setRttCapabilitySetting
        try {
            mMmTelManager.setRttCapabilitySetting(false);
            fail(""setRttCapabilitySetting requires MODIFY_PHONE_STATE permission."");
        } catch (SecurityException e) {
            //expected
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                    (m) -> m.setRttCapabilitySetting(false),
                    ""android.permission.MODIFY_PHONE_STATE"");
        } catch (SecurityException e) {
            fail(""setRttCapabilitySetting requires MODIFY_PHONE_STATE permission."");
        }
        // setVoWiFiNonPersistent
        try {
            mMmTelManager.setVoWiFiNonPersistent(true,
                    ImsMmTelManager.WIFI_MODE_CELLULAR_PREFERRED);
            fail(""setVoWiFiNonPersistent requires MODIFY_PHONE_STATE permission."");
        } catch (SecurityException e) {
            //expected
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mMmTelManager,
                    (m) -> m.setVoWiFiNonPersistent(true,
                            ImsMmTelManager.WIFI_MODE_CELLULAR_PREFERRED),
                    ""android.permission.MODIFY_PHONE_STATE"");
        } catch (SecurityException e) {
            fail(""setVoWiFiNonPersistent requires MODIFY_PHONE_STATE permission."");
        }

        try {
            mMmTelManager.isVtSettingEnabled();
            fail(""isVtSettingEnabled requires READ_PRECISE_PHONE_STATE permission."");
        } catch (SecurityException e) {
            //expected
        }

        try {
            mMmTelManager.isAdvancedCallingSettingEnabled();
            fail(""isAdvancedCallingSettingEnabled requires READ_PRECISE_PHONE_STATE."");
        } c"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsMmTelManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsServiceTest"	"testMmTelManagerRegistrationCallbackS"	"CtsTelephonyTestCases"	"2: INTERNET permission"	"([7:/android/telephony/ims/cts/ImsServiceTest.java]:[permission]:[7]:method_text:[E permission."");        } catch (SecurityException e) {            //expected        }    }   ]) :|: 
    public void testMmTelManagerRegistrationCallbackS() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        final ArraySet<String> featureTags = new ArraySet<>();
        featureTags.add(""featureTag1"");
        featureTags.add(""featureTag2"");

        triggerFrameworkConnectToCarrierImsService();

        // Start deregistered
        sServiceConnector.getCarrierService().getImsRegistration().onDeregistered(
                new ImsReasonInfo(ImsReasonInfo.CODE_LOCAL_NOT_REGISTERED,
                        ImsReasonInfo.CODE_UNSPECIFIED, """"));

        LinkedBlockingQueue<ImsRegistrationAttributes> mRegQueue =
                new LinkedBlockingQueue<>();
        LinkedBlockingQueue<ImsReasonInfo> mDeregQueue =
                new LinkedBlockingQueue<>();
        RegistrationManager.RegistrationCallback callback =
                new RegistrationManager.RegistrationCallback() {
            @Override
            public void onRegistered(ImsRegistrationAttributes attributes) {
                mRegQueue.offer(attributes);
            }

            @Override
            public void onRegistering(ImsRegistrationAttributes attributes) {
                mRegQueue.offer(attributes);
            }

            @Override
            public void onUnregistered(ImsReasonInfo info) {
                mDeregQueue.offer(info);
            }
        };

        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            // First try without the correct permissions.
            ImsManager imsManager = getContext().getSystemService(ImsManager.class);
            ImsMmTelManager mmTelManager = imsManager.getImsMmTelManager(sTestSub);
            mmTelManager.registerImsRegistrationCallback(getContext().getMainExecutor(), callback);
            fail(""registerImsRegistrationCallback requires READ_PRECISE_PHONE_STATE permission."");
        } catch (SecurityException e) {"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsServiceTest"	"testGetFeatureState"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/ims/cts/ImsServiceTest.java]:[permission]:[1]:method_text:[ption.class);        return state.poll(ImsUtils.TEST_TIMEOUT_MS, TimeUnit.MILLISECONDS);    }   ]) :|: 
    public void testGetFeatureState() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        // This will set feature state to ready
        triggerFrameworkConnectToCarrierImsService();

        Integer result = getFeatureState();
        assertNotNull(result);
        assertEquals(""ImsService state should be STATE_READY"",
                sServiceConnector.getCarrierService().getMmTelFeature().getFeatureState(),
                ImsFeature.STATE_READY);
        assertTrue(""ImsService state is ready, but STATE_READY is not reported."",
                ImsUtils.retryUntilTrue(() -> (getFeatureState() == ImsFeature.STATE_READY)));

        sServiceConnector.getCarrierService().getMmTelFeature().setFeatureState(
                ImsFeature.STATE_INITIALIZING);
        result = getFeatureState();
        assertNotNull(result);
        assertEquals(""ImsService state should be STATE_INITIALIZING"",
                sServiceConnector.getCarrierService().getMmTelFeature().getFeatureState(),
                ImsFeature.STATE_INITIALIZING);
        assertTrue(""ImsService state is initializing, but STATE_INITIALIZING is not reported."",
                ImsUtils.retryUntilTrue(
                        () -> (getFeatureState() == ImsFeature.STATE_INITIALIZING)));

        sServiceConnector.getCarrierService().getMmTelFeature().setFeatureState(
                ImsFeature.STATE_UNAVAILABLE);
        result = getFeatureState();
        assertNotNull(result);
        assertEquals(""ImsService state should be STATE_UNAVAILABLE"",
                sServiceConnector.getCarrierService().getMmTelFeature().getFeatureState(),
                ImsFeature.STATE_UNAVAILABLE);
        assertTrue(""ImsService state is unavailable, but STATE_UNAVAILABLE is not reported."",
                ImsUtils.retryUntilTrue(
                        () -> (getFeatureState() == ImsFeature.STATE_UNAVAILABLE)));
    }

    private Integer getFeatureState() throws Exception"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsServiceTest"	"testMmTelManagerRegistrationCallback"	"CtsTelephonyTestCases"	"1: permission"	"([7:/android/telephony/ims/cts/ImsServiceTest.java]:[permission]:[7]:method_text:[E permission."");        } catch (SecurityException e) {            //expected        }    }   ]) :|: 
    public void testMmTelManagerRegistrationCallback() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        triggerFrameworkConnectToCarrierImsService();

        // Start deregistered
        sServiceConnector.getCarrierService().getImsRegistration().onDeregistered(
                new ImsReasonInfo(ImsReasonInfo.CODE_LOCAL_NOT_REGISTERED,
                        ImsReasonInfo.CODE_UNSPECIFIED, """"));

        // This is a little bit gross looking, but on P devices, I can not define classes that
        // extend ImsMmTelManager.RegistrationCallback (because it doesn't exist), so this has to
        // happen as an anon class here.
        LinkedBlockingQueue<Integer> mQueue = new LinkedBlockingQueue<>();
        ImsMmTelManager.RegistrationCallback callback = new ImsMmTelManager.RegistrationCallback() {
            @Override
            public void onRegistered(int imsTransportType) {
                mQueue.offer(imsTransportType);
            }

            @Override
            public void onRegistering(int imsTransportType) {
                mQueue.offer(imsTransportType);
            }

            @Override
            public void onUnregistered(ImsReasonInfo info) {
                mQueue.offer(info.getCode());
            }

            @Override
            public void onTechnologyChangeFailed(int imsTransportType, ImsReasonInfo info) {
                mQueue.offer(imsTransportType);
                mQueue.offer(info.getCode());
            }
        };

        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            // First try without the correct permissions.
            ImsManager imsManager = getContext().getSystemService(ImsManager.class);
            ImsMmTelManager mmTelManager = imsManager.getImsMmTelManager(sTestSub);
            mmTelManager.registerImsRegistrationCallback(getContext().getMainExecutor(), callback);
            fail"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsServiceTest"	"testRcsDeviceCapabilitiesPublish"	"CtsTelephonyTestCases"	"1: permission"	"([10:/android/telephony/ims/cts/ImsServiceTest.java]:[permission]:[10]:method_text:[           TestImsService.LATCH_UCE_LISTENER_SET));        overrideCarrierConfig(null);    }   ]) :|: 
    public void testRcsDeviceCapabilitiesPublish() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        // Trigger carrier config changed
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONED_BOOL, false);
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL, true);
        overrideCarrierConfig(bundle);

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        if (imsManager == null) {
            fail(""Cannot find IMS service"");
        }

        ImsRcsManager imsRcsManager = imsManager.getImsRcsManager(sTestSub);
        RcsUceAdapter uceAdapter = imsRcsManager.getUceAdapter();

        // Connect to device ImsService with MmTel feature and RCS feature
        triggerFrameworkConnectToImsServiceBindMmTelAndRcsFeature();

        TestRcsCapabilityExchangeImpl capExchangeImpl = sServiceConnector.getCarrierService()
                .getRcsFeature().getRcsCapabilityExchangeImpl();

        // Register the callback to listen to the publish state changed
        LinkedBlockingQueue<Integer> publishStateQueue = new LinkedBlockingQueue<>();
        RcsUceAdapter.OnPublishStateChangedListener publishStateCallback =
                new RcsUceAdapter.OnPublishStateChangedListener() {
                    public void onPublishStateChange(int state) {
                        publishStateQueue.offer(state);
                    }
                };

        // Another publish register callback to verify the API
        // RcsUceAdapter#removeOnPublishStateChangedListener
        LinkedBlockingQueue<Integer> unregisteredPublishStateQueue = new LinkedBlockingQueue<>();
        RcsUceAdapter.OnPublishStateChangedListener unregisteredPublishStateCallback =
                new RcsUceAdapter.OnPublishStateChangedListener() {
                    public void onPublishStateChange(int state)"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsServiceTest"	"testPublishImsReg"	"CtsTelephonyTestCases"	"1: permission"	"([3:/android/telephony/ims/cts/ImsServiceTest.java]:[permission]:[3]:method_text:[           TestImsService.LATCH_UCE_LISTENER_SET));        overrideCarrierConfig(null);    }   ]) :|: 
    public void testPublishImsReg() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        // Trigger carrier config changed
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONED_BOOL, false);
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL, true);
        overrideCarrierConfig(bundle);

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        if (imsManager == null) {
            fail(""Cannot find IMS service"");
        }

        ImsRcsManager imsRcsManager = imsManager.getImsRcsManager(sTestSub);
        RcsUceAdapter uceAdapter = imsRcsManager.getUceAdapter();

        // Connect to device ImsService with MmTel feature and RCS feature
        triggerFrameworkConnectToImsServiceBindMmTelAndRcsFeature();

        TestRcsCapabilityExchangeImpl capExchangeImpl = sServiceConnector.getCarrierService()
                .getRcsFeature().getRcsCapabilityExchangeImpl();

        // Register the callback to listen to the publish state changed
        LinkedBlockingQueue<Integer> publishStateQueue = new LinkedBlockingQueue<>();
        RcsUceAdapter.OnPublishStateChangedListener publishStateCallback =
                publishStateQueue::offer;

        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            automan.adoptShellPermissionIdentity();
            uceAdapter.addOnPublishStateChangedListener(getContext().getMainExecutor(),
                    publishStateCallback);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        // Verify receiving the publish state callback immediately after registering the callback.
        assertEquals(RcsUceAdapter.PUBLISH_STATE_NOT_PUBLISHED,
                waitForIntResult(publishStateQueue));
        publishStateQueue.clear();

        Link"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsServiceTest"	"testRcsCapabilitiesPublishNetworkResponseWithReasonHeader"	"CtsTelephonyTestCases"	"1: permission"	"([6:/android/telephony/ims/cts/ImsServiceTest.java]:[permission]:[6]:method_text:[ceAdapter.PUBLISH_STATE_OTHER_ERROR, publishState);        overrideCarrierConfig(null);    }   ]) :|: 
    public void testRcsCapabilitiesPublishNetworkResponseWithReasonHeader() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        // Trigger carrier config changed
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONED_BOOL, false);
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL, true);
        overrideCarrierConfig(bundle);

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        if (imsManager == null) {
            fail(""Cannot find IMS service"");
        }

        ImsRcsManager imsRcsManager = imsManager.getImsRcsManager(sTestSub);
        RcsUceAdapter uceAdapter = imsRcsManager.getUceAdapter();

        // Connect to device ImsService with MmTel feature and RCS feature
        triggerFrameworkConnectToImsServiceBindMmTelAndRcsFeature();

        TestRcsCapabilityExchangeImpl capExchangeImpl = sServiceConnector.getCarrierService()
                .getRcsFeature().getRcsCapabilityExchangeImpl();

        // Register the callback to listen to the publish state changed
        LinkedBlockingQueue<Integer> publishStateQueue = new LinkedBlockingQueue<>();
        RcsUceAdapter.OnPublishStateChangedListener callback =
                new RcsUceAdapter.OnPublishStateChangedListener() {
                    public void onPublishStateChange(int state) {
                        publishStateQueue.offer(state);
                    }
                };

        // register the publish state callback
        ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(uceAdapter,
                a -> a.addOnPublishStateChangedListener(getContext().getMainExecutor(), callback),
                ImsException.class,
                ""android.permission.READ_PRIVILEGED_PHONE_STATE"");

        // Verify receiving the publish state callback immediately after registering the"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsServiceTest"	"testRcsPublishThrottle"	"CtsTelephonyTestCases"	"1: permission"	"([6:/android/telephony/ims/cts/ImsServiceTest.java]:[permission]:[6]:method_text:[REQUEST_PUBLISH, 3000 /* Wait up to 3 seconds */));        overrideCarrierConfig(null);    }   ]) :|: 
    public void testRcsPublishThrottle() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        // Trigger carrier config change
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONED_BOOL, false);
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL, true);
        overrideCarrierConfig(bundle);

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        if (imsManager == null) {
            fail(""Cannot get the ImsManager"");
        }
        ImsRcsManager imsRcsManager = imsManager.getImsRcsManager(sTestSub);
        RcsUceAdapter uceAdapter = imsRcsManager.getUceAdapter();

        // Connect to the ImsService
        triggerFrameworkConnectToImsServiceBindMmTelAndRcsFeature();

        TestRcsCapabilityExchangeImpl capExchangeImpl = sServiceConnector.getCarrierService()
                .getRcsFeature().getRcsCapabilityExchangeImpl();

        // Setup the response of the publish request.
        capExchangeImpl.setPublishOperator((listener, pidfXml, cb) -> {
            int networkResp = 200;
            String reason = ""OK"";
            cb.onNetworkResponse(networkResp, reason);
            listener.onPublish();
        });

        // Register the callback to listen to the publish state changed
        LinkedBlockingQueue<Integer> publishStateQueue = new LinkedBlockingQueue<>();
        RcsUceAdapter.OnPublishStateChangedListener publishStateCallback =
                new RcsUceAdapter.OnPublishStateChangedListener() {
                    public void onPublishStateChange(int state) {
                        publishStateQueue.offer(state);
                    }
                };

        final UiAutomation automation = InstrumentationRegistry.getInstrumentation()
                .getUiAutomation();
        try {
            automation.adoptShellPermissionIdentity();"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsServiceTest"	"testRcsPublishWithSipOptions"	"CtsTelephonyTestCases"	"1: permission"	"([8:/android/telephony/ims/cts/ImsServiceTest.java]:[permission]:[8]:method_text:[automation.dropShellPermissionIdentity();        }        overrideCarrierConfig(null);    }   ]) :|: 
    public void testRcsPublishWithSipOptions() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        // Override the carrier config to support SIP OPTIONS
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONED_BOOL, false);
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL, false);
        bundle.putBoolean(CarrierConfigManager.KEY_USE_RCS_SIP_OPTIONS_BOOL, true);
        overrideCarrierConfig(bundle);

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        if (imsManager == null) {
            fail(""Cannot get the ImsManager"");
        }
        ImsRcsManager imsRcsManager = imsManager.getImsRcsManager(sTestSub);
        RcsUceAdapter uceAdapter = imsRcsManager.getUceAdapter();

        // Connect to the ImsService
        triggerFrameworkConnectToImsServiceBindMmTelAndRcsFeature();

        TestRcsCapabilityExchangeImpl capExchangeImpl = sServiceConnector.getCarrierService()
                .getRcsFeature().getRcsCapabilityExchangeImpl();

        // Setup the response of the publish request. In SIP OPTIONS mechanism, ImsService
        // should not receive any publish requests.
        capExchangeImpl.setPublishOperator((listener, pidfXml, cb) -> {
            fail(""ImsService should not receive the PUBLISH request"");
        });

        // Register the callback to listen to the publish state changed
        LinkedBlockingQueue<Integer> publishStateQueue = new LinkedBlockingQueue<>();
        RcsUceAdapter.OnPublishStateChangedListener publishStateCallback =
                new RcsUceAdapter.OnPublishStateChangedListener() {
                    public void onPublishStateChange(int state) {
                        publishStateQueue.offer(state);
                    }
                };

        final UiAutomation automation = InstrumentationRegistry.getInstrument"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsServiceTest"	"testRcsPublishWithAuthorizedErrorResponse"	"CtsTelephonyTestCases"	"1: permission"	"([12:/android/telephony/ims/cts/ImsServiceTest.java]:[permission]:[12]:method_text:[remove request disallowed status: "" + e);        }        overrideCarrierConfig(null);    }   ]) :|: 
    public void testRcsPublishWithAuthorizedErrorResponse() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        // Trigger carrier config change
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.KEY_CARRIER_VOLTE_PROVISIONED_BOOL, false);
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL, true);
        overrideCarrierConfig(bundle);

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        if (imsManager == null) {
            fail(""Cannot get the ImsManager"");
        }
        ImsRcsManager imsRcsManager = imsManager.getImsRcsManager(sTestSub);
        RcsUceAdapter uceAdapter = imsRcsManager.getUceAdapter();

        // Connect to the ImsService
        triggerFrameworkConnectToImsServiceBindMmTelAndRcsFeature();

        // Register the callback to listen to the publish state changed
        LinkedBlockingQueue<Integer> publishStateQueue = new LinkedBlockingQueue<>();
        RcsUceAdapter.OnPublishStateChangedListener publishStateCallback =
                new RcsUceAdapter.OnPublishStateChangedListener() {
                    public void onPublishStateChange(int state) {
                        publishStateQueue.offer(state);
                    }
                };

        final UiAutomation automation = InstrumentationRegistry.getInstrumentation()
                .getUiAutomation();
        try {
            automation.adoptShellPermissionIdentity();
            uceAdapter.addOnPublishStateChangedListener(getContext().getMainExecutor(),
                    publishStateCallback);
            // Verify receiving the publish state callback after registering the callback.
            assertEquals(RcsUceAdapter.PUBLISH_STATE_NOT_PUBLISHED,
                    waitForIntResult(publishStateQueue));
        } finally {
            publishStateQueue.clear();
            automation.dropShell"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsServiceTest"	"testRcsManagerRegistrationCallback"	"CtsTelephonyTestCases"	"1: permission"	"([8:/android/telephony/ims/cts/ImsServiceTest.java]:[permission]:[8]:method_text:[    ""android.permission.READ_PRECISE_PHONE_STATE"");        overrideCarrierConfig(null);    }   ]) :|: 
    public void testRcsManagerRegistrationCallback() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        if (imsManager == null) {
            fail(""Cannot find IMS service"");
        }

        // Connect to device ImsService with RcsFeature
        triggerFrameworkConnectToLocalImsServiceBindRcsFeature();
        ImsRcsManager imsRcsManager = imsManager.getImsRcsManager(sTestSub);

        // Override the carrier config
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL, true);
        overrideCarrierConfig(bundle);

        // Wait for the framework to set the capabilities on the ImsService
        sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_RCS_CAP_SET);

        // Start de-registered
        sServiceConnector.getCarrierService().getImsRegistration().onDeregistered(
                new ImsReasonInfo(ImsReasonInfo.CODE_LOCAL_NOT_REGISTERED,
                        ImsReasonInfo.CODE_UNSPECIFIED, """"));

        LinkedBlockingQueue<Integer> mQueue = new LinkedBlockingQueue<>();
        RegistrationManager.RegistrationCallback callback =
                new RegistrationManager.RegistrationCallback() {
                    @Override
                    public void onRegistered(int imsTransportType) {
                        mQueue.offer(imsTransportType);
                    }

                    @Override
                    public void onRegistering(int imsTransportType) {
                        mQueue.offer(imsTransportType);
                    }

                    @Override
                    public void onUnregistered(ImsReasonInfo info) {
                        mQueue.offer(info.getCode());
                    }

                    @Override
                    public void on"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsServiceTest"	"testMmTelManagerRegistrationStateR"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/ims/cts/ImsServiceTest.java]:[permission]:[2]:method_text:[turn(mmTelManager,                (m) -> m.unregisterImsRegistrationCallback(callback));    }   ]) :|: 
    public void testMmTelManagerRegistrationStateR() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RegistrationManager regManager = imsManager.getImsMmTelManager(sTestSub);
        LinkedBlockingQueue<Integer> mQueue = new LinkedBlockingQueue<>();

        triggerFrameworkConnectToCarrierImsService();

        // Start deregistered
        sServiceConnector.getCarrierService().getImsRegistration().onDeregistered(
                new ImsReasonInfo(ImsReasonInfo.CODE_LOCAL_NOT_REGISTERED,
                        ImsReasonInfo.CODE_UNSPECIFIED, """"));

        RegistrationManager.RegistrationCallback callback =
                new RegistrationManager.RegistrationCallback() {
                    @Override
                    public void onRegistered(int imsTransportType) {
                        mQueue.offer(imsTransportType);
                    }

                    @Override
                    public void onRegistering(int imsTransportType) {
                        mQueue.offer(imsTransportType);
                    }

                    @Override
                    public void onUnregistered(ImsReasonInfo info) {
                        mQueue.offer(info.getCode());
                    }

                    @Override
                    public void onTechnologyChangeFailed(int imsTransportType, ImsReasonInfo info) {
                        mQueue.offer(imsTransportType);
                        mQueue.offer(info.getCode());
                    }
                };

        ImsMmTelManager mmTelManager = imsManager.getImsMmTelManager(sTestSub);
        ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(mmTelManager,
                (m) -> m.registerImsRegistrationCallback(getContext().getMainExecutor(), callback),
                ImsException.class);
        assertEquals(ImsReasonInfo.CODE_LOCAL_NOT_REGIS"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsServiceTest"	"testRcsManagerRegistrationState"	"CtsTelephonyTestCases"	"1: permission"	"([6:/android/telephony/ims/cts/ImsServiceTest.java]:[permission]:[6]:method_text:[ -> m.unregisterImsRegistrationCallback(callback));        overrideCarrierConfig(null);    }   ]) :|: 
    public void testRcsManagerRegistrationState() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        if (imsManager == null) {
            fail(""Cannot find IMS service"");
        }

        // Connect to device ImsService with RcsFeature
        triggerFrameworkConnectToLocalImsServiceBindRcsFeature();

        // Override the carrier config
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL, true);
        overrideCarrierConfig(bundle);

        sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_RCS_CAP_SET);

        // Start de-registered
        sServiceConnector.getCarrierService().getImsRegistration().onDeregistered(
                new ImsReasonInfo(ImsReasonInfo.CODE_LOCAL_NOT_REGISTERED,
                        ImsReasonInfo.CODE_UNSPECIFIED, """"));

        LinkedBlockingQueue<Integer> mQueue = new LinkedBlockingQueue<>();
        RegistrationManager.RegistrationCallback callback =
                new RegistrationManager.RegistrationCallback() {
                    @Override
                    public void onRegistered(int imsTransportType) {
                        mQueue.offer(imsTransportType);
                    }

                    @Override
                    public void onRegistering(int imsTransportType) {
                        mQueue.offer(imsTransportType);
                    }

                    @Override
                    public void onUnregistered(ImsReasonInfo info) {
                        mQueue.offer(info.getCode());
                    }

                    @Override
                    public void onTechnologyChangeFailed(int imsTransportType, ImsReasonInfo info) {
                        mQueue.offer(imsTransportType);
                        mQueue.of"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsServiceTest"	"testCapabilityStatusCallback"	"CtsTelephonyTestCases"	"1: permission"	"([8:/android/telephony/ims/cts/ImsServiceTest.java]:[permission]:[8]:method_text:[E permission."");        } catch (SecurityException e) {            //expected        }    }   ]) :|: 
    public void testCapabilityStatusCallback() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        ImsMmTelManager mmTelManager = imsManager.getImsMmTelManager(sTestSub);

        triggerFrameworkConnectToCarrierImsService();

        // Wait for the framework to set the capabilities on the ImsService
        sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_MMTEL_CAP_SET);
        MmTelFeature.MmTelCapabilities fwCaps = sServiceConnector.getCarrierService()
                .getMmTelFeature().getCapabilities();
        // Make sure we start off with every capability unavailable
        sServiceConnector.getCarrierService().getImsRegistration().onRegistered(
                ImsRegistrationImplBase.REGISTRATION_TECH_LTE);
        sServiceConnector.getCarrierService().getMmTelFeature()
                .notifyCapabilitiesStatusChanged(new MmTelFeature.MmTelCapabilities());

        // Make sure the capabilities match the API getter for capabilities
        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        // Latch will count down here (we callback on the state during registration).
        try {
            automan.adoptShellPermissionIdentity();
            // Make sure we are tracking voice capability over LTE properly.
            assertEquals(fwCaps.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE),
                    mmTelManager.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE,
                            ImsRegistrationImplBase.REGISTRATION_TECH_LTE));
        } finally {
            automan.dropShellPermissionIdentity();
        }

        // This is a little bit gross looking, but on P devices, I can not define classes that
        // extend ImsMmTelManager.CapabilityCallback (because it doesn't exist)"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsServiceTest"	"testCallComposerCapabilityStatusCallback"	"CtsTelephonyTestCases"	"1: permission"	"([8:/android/telephony/ims/cts/ImsServiceTest.java]:[permission]:[8]:method_text:[ such that IsAvailable returns the correct     * capability status during the callback.     */   ]) :|: 
    public void testCallComposerCapabilityStatusCallback() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        ImsMmTelManager mmTelManager = imsManager.getImsMmTelManager(sTestSub);

        triggerFrameworkConnectToCarrierImsService();

        // Wait for the framework to set the capabilities on the ImsService
        sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_MMTEL_CAP_SET);
        MmTelFeature.MmTelCapabilities fwCaps = sServiceConnector.getCarrierService()
                .getMmTelFeature().getCapabilities();
        // Make sure we start off with every capability unavailable
        sServiceConnector.getCarrierService().getImsRegistration().onRegistered(
                ImsRegistrationImplBase.REGISTRATION_TECH_LTE);
        sServiceConnector.getCarrierService().getMmTelFeature()
                .notifyCapabilitiesStatusChanged(new MmTelFeature.MmTelCapabilities());

        // Make sure the capabilities match the API getter for capabilities
        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        // Latch will count down here (we callback on the state during registration).
        try {
            automan.adoptShellPermissionIdentity();
            // Make sure we are tracking voice capability over LTE properly.
            assertEquals(fwCaps.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE),
                    mmTelManager.isCapable(MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE,
                    ImsRegistrationImplBase.REGISTRATION_TECH_LTE));
        } finally {
            automan.dropShellPermissionIdentity();
        }

        LinkedBlockingQueue<MmTelFeature.MmTelCapabilities> mQueue = new LinkedBlockingQueue<>();
        ImsMmTelManager.CapabilityCallback callback = new ImsMmTelManage"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsServiceTest"	"testCapabilityStatusWithIsAvailableDuringCallback"	"CtsTelephonyTestCases"	"1: permission"	"([10:/android/telephony/ims/cts/ImsServiceTest.java]:[permission]:[10]:method_text:[ finally {                automan.dropShellPermissionIdentity();            }        }    }   ]) :|: 
    public void testCapabilityStatusWithIsAvailableDuringCallback() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        ImsMmTelManager mmTelManager = imsManager.getImsMmTelManager(sTestSub);

        triggerFrameworkConnectToCarrierImsService();

        // Wait for the framework to set the capabilities on the ImsService
        sServiceConnector.getCarrierService().waitForLatchCountdown(
                TestImsService.LATCH_MMTEL_CAP_SET);


        // Make sure we start off with every capability unavailable
        sServiceConnector.getCarrierService().getImsRegistration().onRegistered(
                ImsRegistrationImplBase.REGISTRATION_TECH_LTE);
        MmTelFeature.MmTelCapabilities stdCapabilities = new MmTelFeature.MmTelCapabilities();
        sServiceConnector.getCarrierService().getMmTelFeature()
                .notifyCapabilitiesStatusChanged(stdCapabilities);


        // Make sure the capabilities match the API getter for capabilities
        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();

        //This lock is to keep the shell permissions from being dropped on a different thread
        //causing a permission error.
        Object lockObj = new Object();

        synchronized (lockObj) {
            try {
                automan.adoptShellPermissionIdentity();
                boolean isAvailableBeforeStatusChange = mmTelManager.isAvailable(
                        MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_VOICE,
                        ImsRegistrationImplBase.REGISTRATION_TECH_LTE);
                assertFalse(isAvailableBeforeStatusChange);
            } finally {
                automan.dropShellPermissionIdentity();
            }
        }

        LinkedBlockingQueue<Boolean> voiceIsAvailable = new LinkedBlockingQueue<>();
        ImsMmTelManager.CapabilityCal"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsServiceTest"	"testRcsCapabilityStatusCallback"	"CtsTelephonyTestCases"	"1: permission"	"([14:/android/telephony/ims/cts/ImsServiceTest.java]:[permission]:[14]:method_text:[        assertTrue(availabilityChanged.isEmpty());        overrideCarrierConfig(null);    }   ]) :|: 
    public void testRcsCapabilityStatusCallback() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        if (imsManager == null) {
            fail(""Cannot find IMS service"");
        }

        // Connect to device ImsService with RcsFeature
        triggerFrameworkConnectToLocalImsServiceBindRcsFeature();

        int registrationTech = ImsRegistrationImplBase.REGISTRATION_TECH_LTE;
        ImsRcsManager imsRcsManager = imsManager.getImsRcsManager(sTestSub);

        // Make sure we start off with none-capability
        sServiceConnector.getCarrierService().getImsRegistration().onRegistered(
                ImsRegistrationImplBase.REGISTRATION_TECH_LTE);
        RcsImsCapabilities noCapabilities = new RcsImsCapabilities(RCS_CAP_NONE);
        sServiceConnector.getCarrierService().getRcsFeature()
                .notifyCapabilitiesStatusChanged(noCapabilities);

        // Make sure the capabilities match the API getter for capabilities
        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        // Latch will count down here (we callback on the state during registration).
        try {
            automan.adoptShellPermissionIdentity();
            // Make sure we are tracking voice capability over LTE properly.
            RcsImsCapabilities availability = sServiceConnector.getCarrierService()
                    .getRcsFeature().queryCapabilityStatus();
            assertFalse(availability.isCapable(RCS_CAP_OPTIONS));
            assertFalse(availability.isCapable(RCS_CAP_PRESENCE));
        } finally {
            automan.dropShellPermissionIdentity();
        }

        // Trigger carrier config changed
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.KEY_USE_RCS_SIP_OPTIONS_BOOL, true);
        bundle.putBoolean(CarrierConf"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsServiceTest"	"testProvisioningManagerSetConfig"	"CtsTelephonyTestCases"	"1: permission"	"([3:/android/telephony/ims/cts/ImsServiceTest.java]:[permission]:[3]:method_text:[tants were moved back to @hide for now, don't want to ""            + ""completely remove test."")   ]) :|: 
    public void testProvisioningManagerSetConfig() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        triggerFrameworkConnectToCarrierImsService();

        ProvisioningManager provisioningManager =
                ProvisioningManager.createForSubscriptionId(sTestSub);

        // This is a little bit gross looking, but on P devices, I can not define classes that
        // extend ProvisioningManager.Callback (because it doesn't exist), so this has to
        // happen as an anon class here.
        LinkedBlockingQueue<Pair<Integer, Integer>> mIntQueue = new LinkedBlockingQueue<>();
        LinkedBlockingQueue<Pair<Integer, String>> mStringQueue = new LinkedBlockingQueue<>();
        ProvisioningManager.Callback callback = new ProvisioningManager.Callback() {
            @Override
            public void onProvisioningIntChanged(int item, int value) {
                mIntQueue.offer(new Pair<>(item, value));
            }

            @Override
            public void onProvisioningStringChanged(int item, String value) {
                mStringQueue.offer(new Pair<>(item, value));
            }
        };

        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            automan.adoptShellPermissionIdentity();
            provisioningManager.registerProvisioningChangedCallback(getContext().getMainExecutor(),
                    callback);

            provisioningManager.setProvisioningIntValue(TEST_CONFIG_KEY, TEST_CONFIG_VALUE_INT);
            assertTrue(waitForParam(mIntQueue, new Pair<>(TEST_CONFIG_KEY, TEST_CONFIG_VALUE_INT)));
            assertEquals(TEST_CONFIG_VALUE_INT,
                    provisioningManager.getProvisioningIntValue(TEST_CONFIG_KEY));

            provisioningManager.setProvisioningStringValue(TEST_CONFIG_KEY,
                    TEST_CONFIG_VALUE_STRING);
            assertTrue(waitForParam(mStringQueue,"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsServiceTest"	"testProvisioningManagerConstants"	"CtsTelephonyTestCases"	"1: permission"	"([3:/android/telephony/ims/cts/ImsServiceTest.java]:[permission]:[3]:method_text:[llback);        } finally {            automan.dropShellPermissionIdentity();        }    }   ]) :|: 
    public void testProvisioningManagerConstants() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        triggerFrameworkConnectToCarrierImsService();

        ProvisioningManager provisioningManager =
                ProvisioningManager.createForSubscriptionId(sTestSub);

        // This is a little bit gross looking, but on P devices, I can not define classes that
        // extend ProvisioningManager.Callback (because it doesn't exist), so this has to
        // happen as an anon class here.
        LinkedBlockingQueue<Pair<Integer, Integer>> mIntQueue = new LinkedBlockingQueue<>();
        LinkedBlockingQueue<Pair<Integer, String>> mStringQueue = new LinkedBlockingQueue<>();
        ProvisioningManager.Callback callback = new ProvisioningManager.Callback() {
            @Override
            public void onProvisioningIntChanged(int item, int value) {
                mIntQueue.offer(new Pair<>(item, value));
            }

            @Override
            public void onProvisioningStringChanged(int item, String value) {
                mStringQueue.offer(new Pair<>(item, value));
            }
        };

        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            automan.adoptShellPermissionIdentity();
            provisioningManager.registerProvisioningChangedCallback(getContext().getMainExecutor(),
                    callback);

            verifyStringKey(provisioningManager, mStringQueue,
                    ProvisioningManager.KEY_AMR_CODEC_MODE_SET_VALUES, ""1,2"");
            verifyStringKey(provisioningManager, mStringQueue,
                    ProvisioningManager.KEY_AMR_WB_CODEC_MODE_SET_VALUES, ""1,2"");
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_SIP_SESSION_TIMER_SEC, 5);
            verifyIntKey(provisioningManager, mIntQueue,
                    ProvisioningManager.KEY_MINIM"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsServiceTest"	"testProvisioningManagerProvisioningCaps"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/ims/cts/ImsServiceTest.java]:[permission]:[2]:method_text:[   automan.dropShellPermissionIdentity();        }        overrideCarrierConfig(null);    }   ]) :|: 
    public void testProvisioningManagerProvisioningCaps() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        triggerFrameworkConnectToCarrierImsService();

        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.KEY_CARRIER_SUPPORTS_SS_OVER_UT_BOOL, true);
        bundle.putBoolean(CarrierConfigManager.KEY_CARRIER_UT_PROVISIONING_REQUIRED_BOOL, true);
        overrideCarrierConfig(bundle);

        ProvisioningManager provisioningManager =
                ProvisioningManager.createForSubscriptionId(sTestSub);

        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            automan.adoptShellPermissionIdentity();
            boolean provisioningStatus = provisioningManager.getProvisioningStatusForCapability(
                    MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_UT,
                    ImsRegistrationImplBase.REGISTRATION_TECH_LTE);
            provisioningManager.setProvisioningStatusForCapability(
                    MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_UT,
                    ImsRegistrationImplBase.REGISTRATION_TECH_LTE, !provisioningStatus);
            // Make sure the change in provisioning status is correctly returned.
            assertEquals(!provisioningStatus,
                    provisioningManager.getProvisioningStatusForCapability(
                            MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_UT,
                            ImsRegistrationImplBase.REGISTRATION_TECH_LTE));
            // TODO: Enhance test to make sure the provisioning change is also sent to the
            // ImsService

            // set back to current status
            provisioningManager.setProvisioningStatusForCapability(
                    MmTelFeature.MmTelCapabilities.CAPABILITY_TYPE_UT,
                    ImsRegistrationImplBase.REGISTRATION_TECH_LTE, provisioningStatus);"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsServiceTest"	"testProvisioningManagerRcsProvisioningCaps"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/ims/cts/ImsServiceTest.java]:[permission]:[2]:method_text:[   automan.dropShellPermissionIdentity();        }        overrideCarrierConfig(null);    }   ]) :|: 
    public void testProvisioningManagerRcsProvisioningCaps() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        triggerFrameworkConnectToCarrierImsService();

        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_PUBLISH_BOOL, true);
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_CAPABILITY_EXCHANGE_BOOL,
                true);
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_RCS_BULK_CAPABILITY_EXCHANGE_BOOL, true);
        bundle.putBoolean(CarrierConfigManager.KEY_CARRIER_RCS_PROVISIONING_REQUIRED_BOOL, true);
        overrideCarrierConfig(bundle);

        ProvisioningManager provisioningManager =
                ProvisioningManager.createForSubscriptionId(sTestSub);

        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            automan.adoptShellPermissionIdentity();
            boolean provisioningStatus = provisioningManager.getRcsProvisioningStatusForCapability(
                    RCS_CAP_PRESENCE);
            provisioningManager.setRcsProvisioningStatusForCapability(RCS_CAP_PRESENCE,
                    !provisioningStatus);
            // Make sure the change in provisioning status is correctly returned.
            assertEquals(!provisioningStatus,
                    provisioningManager.getRcsProvisioningStatusForCapability(RCS_CAP_PRESENCE));
            // TODO: Enhance test to make sure the provisioning change is also sent to the
            // ImsService

            // set back to current status
            provisioningManager.setRcsProvisioningStatusForCapability(RCS_CAP_PRESENCE,
                    provisioningStatus);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        overrideCarrierConfig(null);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsServiceTest"	"testProvisioningManagerRcsProvisioningChangedCallback"	"CtsTelephonyTestCases"	"1: permission"	"([6:/android/telephony/ims/cts/ImsServiceTest.java]:[permission]:[6]:method_text:[  res = waitForIntResult(actionQueue, 500);        assertEquals(res, Integer.MAX_VALUE);    }   ]) :|: 
    public void testProvisioningManagerRcsProvisioningChangedCallback() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        triggerFrameworkConnectToLocalImsServiceBindRcsFeature();

        final int errorCode = 403;
        final String errorString = ""Forbidden"";
        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        LinkedBlockingQueue<Integer> actionQueue = new LinkedBlockingQueue<>();
        LinkedBlockingQueue<RcsProvisioningCallbackParams> paramsQueue =
                new LinkedBlockingQueue<>();
        ProvisioningManager.RcsProvisioningCallback cb =
                buildRcsProvisioningCallback(actionQueue, paramsQueue);
        ProvisioningManager provisioningManager =
                ProvisioningManager.createForSubscriptionId(sTestSub);
        ImsConfigImplBase config = sServiceConnector.getCarrierService().getConfig();

        //notify rcs configuration received, wait rcs gets ready and receives notification
        try {
            automan.adoptShellPermissionIdentity();
            provisioningManager.notifyRcsAutoConfigurationReceived(
                    TEST_RCS_CONFIG_DEFAULT.getBytes(), false);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        int res = waitForIntResult(TestAcsClient.getInstance().getActionQueue());
        assertEquals(res, TestAcsClient.ACTION_CONFIG_CHANGED);

        try {
            automan.adoptShellPermissionIdentity();
            provisioningManager.registerRcsProvisioningCallback(
                    getContext().getMainExecutor(), cb);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        //callback is expected immediately
        res = waitForIntResult(actionQueue);
        assertEquals(res, RCS_CONFIG_CB_CHANGED);
        RcsProvisioningCallbackParams params = waitForResult(paramsQueue);
        assertNotNull(params);
        ass"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsServiceTest"	"testProvisioningManagerNotifyRcsAutoConfigurationReceived"	"CtsTelephonyTestCases"	"1: permission"	"([6:/android/telephony/ims/cts/ImsServiceTest.java]:[permission]:[6]:method_text:[.equals(                configStr.getBytes(), TestAcsClient.getInstance().getConfig()));    }   ]) :|: 
    public void testProvisioningManagerNotifyRcsAutoConfigurationReceived() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        triggerFrameworkConnectToLocalImsServiceBindRcsFeature();

        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        LinkedBlockingQueue<Integer> clientQueue = new LinkedBlockingQueue<>();
        LinkedBlockingQueue<RcsProvisioningCallbackParams> paramsQueue =
                new LinkedBlockingQueue<>();
        ProvisioningManager.RcsProvisioningCallback cb =
                buildRcsProvisioningCallback(clientQueue, paramsQueue);
        ProvisioningManager provisioningManager =
                ProvisioningManager.createForSubscriptionId(sTestSub);
        String configStr = TEST_RCS_CONFIG_DEFAULT;

        //notify rcs configuration received, wait rcs gets ready and receives notification
        try {
            automan.adoptShellPermissionIdentity();
            provisioningManager.notifyRcsAutoConfigurationReceived(
                    configStr.getBytes(), false);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        int res = waitForIntResult(TestAcsClient.getInstance().getActionQueue());
        assertEquals(res, TestAcsClient.ACTION_CONFIG_CHANGED);

        try {
            automan.adoptShellPermissionIdentity();
            provisioningManager.registerRcsProvisioningCallback(
                    getContext().getMainExecutor(), cb);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        res = waitForIntResult(clientQueue);
        assertEquals(res, RCS_CONFIG_CB_CHANGED);
        RcsProvisioningCallbackParams params = waitForResult(paramsQueue);
        assertNotNull(params);
        assertTrue(Arrays.equals(params.mConfig, configStr.getBytes()));
        assertTrue(Arrays.equals(
                configStr.getBytes(), TestAcsClient.getInstance().getConfi"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsServiceTest"	"testProvisioningManagerTriggerRcsReconfiguration"	"CtsTelephonyTestCases"	"1: permission"	"([6:/android/telephony/ims/cts/ImsServiceTest.java]:[permission]:[6]:method_text:[).getActionQueue());        assertEquals(res, TestAcsClient.ACTION_TRIGGER_AUTO_CONFIG);    }   ]) :|: 
    public void testProvisioningManagerTriggerRcsReconfiguration() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        triggerFrameworkConnectToLocalImsServiceBindRcsFeature();

        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        LinkedBlockingQueue<Integer> clientQueue = new LinkedBlockingQueue<>();
        ProvisioningManager.RcsProvisioningCallback cb =
                buildRcsProvisioningCallback(clientQueue, null);

        ProvisioningManager provisioningManager =
                ProvisioningManager.createForSubscriptionId(sTestSub);

        //notify rcs configuration received, wait rcs gets ready and receives notification
        try {
            automan.adoptShellPermissionIdentity();
            provisioningManager.notifyRcsAutoConfigurationReceived(
                    TEST_RCS_CONFIG_DEFAULT.getBytes(), false);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        int res = waitForIntResult(TestAcsClient.getInstance().getActionQueue());
        assertEquals(res, TestAcsClient.ACTION_CONFIG_CHANGED);

        //set default rcs config
        try {
            automan.adoptShellPermissionIdentity();
            provisioningManager.registerRcsProvisioningCallback(
                    getContext().getMainExecutor(), cb);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        res = waitForIntResult(clientQueue);
        assertEquals(res, RCS_CONFIG_CB_CHANGED);

        //test triggerRcsReconfiguration
        try {
            automan.adoptShellPermissionIdentity();
            provisioningManager.triggerRcsReconfiguration();
        } finally {
            automan.dropShellPermissionIdentity();
        }

        res = waitForIntResult(clientQueue);
        assertEquals(res, RCS_CONFIG_CB_RESET);

        res = waitForIntResult(TestAcsClient.getInstance().getActionQueue());"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsServiceTest"	"testProvisioningManagerSetRcsClientConfiguration"	"CtsTelephonyTestCases"	"1: permission"	"([4:/android/telephony/ims/cts/ImsServiceTest.java]:[permission]:[4]:method_text:[_SET_RCS_CLIENT_CONFIG);        assertEquals(rcc, TestAcsClient.getInstance().getRcc());    }   ]) :|: 
    public void testProvisioningManagerSetRcsClientConfiguration() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        RcsClientConfiguration rcc = new RcsClientConfiguration(
                ""1.0"", ""UP_1.0"", ""Android"", ""RCSAndrd-1.0"");
        triggerFrameworkConnectToLocalImsServiceBindRcsFeature();

        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        ProvisioningManager provisioningManager =
                ProvisioningManager.createForSubscriptionId(sTestSub);

        //notify rcs configuration received, wait rcs gets ready and receives notification
        try {
            automan.adoptShellPermissionIdentity();
            provisioningManager.notifyRcsAutoConfigurationReceived(
                    TEST_RCS_CONFIG_DEFAULT.getBytes(), false);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        int res = waitForIntResult(TestAcsClient.getInstance().getActionQueue());
        assertEquals(res, TestAcsClient.ACTION_CONFIG_CHANGED);

        try {
            automan.adoptShellPermissionIdentity();
            provisioningManager.setRcsClientConfiguration(rcc);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        res = waitForIntResult(TestAcsClient.getInstance().getActionQueue());
        assertEquals(res, TestAcsClient.ACTION_SET_RCS_CLIENT_CONFIG);
        assertEquals(rcc, TestAcsClient.getInstance().getRcc());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsServiceTest"	"testProvisioningManagerRcsVolteSingleRegistrationCapable"	"CtsTelephonyTestCases"	"1: permission"	"([8:/android/telephony/ims/cts/ImsServiceTest.java]:[permission]:[8]:method_text:[ is     * available on the device and for the current carrier.     * @throws Exception     */   ]) :|: 
    public void testProvisioningManagerRcsVolteSingleRegistrationCapable() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        triggerFrameworkConnectToLocalImsServiceBindRcsFeature();

        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        boolean isSingleRegistrationEnabledOnDevice =
                sServiceConnector.getDeviceSingleRegistrationEnabled();
        boolean isSingleRegistrationEnabledByCarrier =
                sServiceConnector.getCarrierSingleRegistrationEnabled();

        ProvisioningManager provisioningManager =
                ProvisioningManager.createForSubscriptionId(sTestSub);
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(
                CarrierConfigManager.Ims.KEY_IMS_SINGLE_REGISTRATION_REQUIRED_BOOL,
                !isSingleRegistrationEnabledByCarrier);
        sSrcReceiver.clearQueue();
        overrideCarrierConfig(bundle);
        sSrcReceiver.waitForChanged();
        int capability = sSrcReceiver.getCapability();

        assertEquals(!isSingleRegistrationEnabledByCarrier,
                (ProvisioningManager.STATUS_CARRIER_NOT_CAPABLE & capability) == 0);
        try {
            automan.adoptShellPermissionIdentity();
            assertEquals(provisioningManager.isRcsVolteSingleRegistrationCapable(),
                    isSingleRegistrationEnabledOnDevice && !isSingleRegistrationEnabledByCarrier);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_IMS_SINGLE_REGISTRATION_REQUIRED_BOOL,
                isSingleRegistrationEnabledByCarrier);
        sSrcReceiver.clearQueue();
        overrideCarrierConfig(bundle);
        sSrcReceiver.waitForChanged();
        capability = sSrcReceiver.getCapability();

        assertEquals(isSingleRegistrationEnabledByCarri"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsServiceTest"	"testImsMmTelManagerImsStateCallback"	"CtsTelephonyTestCases"	"1: permission"	"([4:/android/telephony/ims/cts/ImsServiceTest.java]:[permission]:[4]:method_text:[aitForIntResult(stateQueue));        mmTelManager.unregisterImsStateCallback(callback);    }   ]) :|: 
    public void testImsMmTelManagerImsStateCallback() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        if (imsManager == null) {
            fail(""Cannot find IMS service"");
        }

        LinkedBlockingQueue<Integer> stateQueue = new LinkedBlockingQueue<>();
        ImsStateCallback callback = buildImsStateCallback(stateQueue);

        ImsMmTelManager mmTelManager = null;
        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            automan.adoptShellPermissionIdentity();
            mmTelManager = imsManager.getImsMmTelManager(sTestSub);
            mmTelManager.registerImsStateCallback(getContext().getMainExecutor(), callback);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        int reason = waitForIntResult(stateQueue);
        assertTrue(reason == ImsStateCallback.REASON_UNKNOWN_TEMPORARY_ERROR
                || reason == ImsStateCallback.REASON_UNKNOWN_PERMANENT_ERROR
                || reason == ImsStateCallback.REASON_IMS_SERVICE_DISCONNECTED
                || reason == ImsStateCallback.REASON_NO_IMS_SERVICE_CONFIGURED
                || reason == ImsStateCallback.REASON_SUBSCRIPTION_INACTIVE
                || reason == ImsStateCallback.REASON_IMS_SERVICE_NOT_READY);

        mmTelManager.unregisterImsStateCallback(callback);

        // Connect to device ImsService with MmTelFeature
        triggerFrameworkConnectToCarrierImsService();

        stateQueue = new LinkedBlockingQueue<>();
        callback = buildImsStateCallback(stateQueue);

        try {
            automan.adoptShellPermissionIdentity();
            mmTelManager.registerImsStateCallback(getContext().getMainExecutor(), callback);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        // expects FEATURE_MMTEL STA"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsServiceTest"	"testImsRcsManagerImsStateCallback"	"CtsTelephonyTestCases"	"1: permission"	"([11:/android/telephony/ims/cts/ImsServiceTest.java]:[permission]:[11]:method_text:[ return (c - 'a' + 10);        throw new RuntimeException(""Invalid hex char '"" + c + ""'"");    }}]) :|: 
    public void testImsRcsManagerImsStateCallback() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        if (imsManager == null) {
            fail(""Cannot find IMS service"");
        }

        LinkedBlockingQueue<Integer> rcsQueue = new LinkedBlockingQueue<>();
        ImsStateCallback rcsCallback = buildImsStateCallback(rcsQueue);

        LinkedBlockingQueue<Integer> sipQueue = new LinkedBlockingQueue<>();
        ImsStateCallback sipCallback = buildImsStateCallback(sipQueue);

        ImsRcsManager imsRcsManager;
        SipDelegateManager imsSipManager;
        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            automan.adoptShellPermissionIdentity();
            imsRcsManager = imsManager.getImsRcsManager(sTestSub);
            imsRcsManager.registerImsStateCallback(getContext().getMainExecutor(), rcsCallback);
            imsSipManager = imsManager.getSipDelegateManager(sTestSub);
            imsSipManager.registerImsStateCallback(getContext().getMainExecutor(), sipCallback);
        } finally {
            automan.dropShellPermissionIdentity();
        }

        int reason = waitForIntResult(rcsQueue);
        assertTrue(reason == ImsStateCallback.REASON_UNKNOWN_TEMPORARY_ERROR
                || reason == ImsStateCallback.REASON_UNKNOWN_PERMANENT_ERROR
                || reason == ImsStateCallback.REASON_IMS_SERVICE_DISCONNECTED
                || reason == ImsStateCallback.REASON_NO_IMS_SERVICE_CONFIGURED
                || reason == ImsStateCallback.REASON_SUBSCRIPTION_INACTIVE
                || reason == ImsStateCallback.REASON_IMS_SERVICE_NOT_READY);

        reason = waitForIntResult(sipQueue);
        assertTrue(reason == ImsStateCallback.REASON_UNKNOWN_TEMPORARY_ERROR
                || reason == ImsStateCallback.REASON_UNKNOWN_PERMANENT_ERROR"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.RcsUceAdapterTest"	"testGetAndSetUceSetting"	"CtsTelephonyTestCases"	"1: permission"	"([8:/android/telephony/ims/cts/RcsUceAdapterTest.java]:[permission]:[8]:method_text:[ission.MODIFY_PHONE_STATE"");            }            unregisterUceObserver();        }    }   ]) :|: 
    public void testGetAndSetUceSetting() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RcsUceAdapter adapter = imsManager.getImsRcsManager(sTestSub).getUceAdapter();
        assertNotNull(""RcsUceAdapter can not be null!"", adapter);

        Boolean isEnabled = null;
        try {
            isEnabled = ShellIdentityUtils.invokeThrowableMethodWithShellPermissions(
                    adapter, RcsUceAdapter::isUceSettingEnabled, ImsException.class,
                    ""android.permission.READ_PHONE_STATE"");
            assertNotNull(isEnabled);

            // Ensure the ContentObserver gets the correct callback based on the change.
            LinkedBlockingQueue<Uri> queue = new LinkedBlockingQueue<>(1);
            registerUceObserver(queue::offer);
            boolean userSetIsEnabled = isEnabled;
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(
                    adapter, a -> a.setUceSettingEnabled(!userSetIsEnabled), ImsException.class,
                    ""android.permission.MODIFY_PHONE_STATE"");
            Uri result = queue.poll(ImsUtils.TEST_TIMEOUT_MS, TimeUnit.MILLISECONDS);
            assertNotNull(result);
            assertTrue(""Unexpected URI, should only receive URIs with prefix "" + LISTENER_URI,
                    result.isPathPrefixMatch(LISTENER_URI));
            // Verify the subId associated with the Observer is correct.
            List<String> pathSegments = result.getPathSegments();
            String subId = pathSegments.get(pathSegments.size() - 1);
            assertEquals(""Subscription ID contained in ContentObserver URI doesn't match the ""
                            + ""subscription that has changed."",
                    String.valueOf(sTestSub), subId);

            Boolean setResult = ShellIdentityUtils.invokeThrowableMethodWithShellPermissions("	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/RcsUceAdapterTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.RcsUceAdapterTest"	"testMethodPermissions"	"CtsTelephonyTestCases"	"1: permission"	"([27:/android/telephony/ims/cts/RcsUceAdapterTest.java]:[permission]:[27]:method_text:[use it means the permission check passed.        }        overrideCarrierConfig(null);    }   ]) :|: 
    public void testMethodPermissions() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RcsUceAdapter uceAdapter = imsManager.getImsRcsManager(sTestSub).getUceAdapter();
        assertNotNull(""UCE adapter should not be null!"", uceAdapter);
        Collection<Uri> numbers = new ArrayList<>(1);
        numbers.add(sTestNumberUri);

        // isUceSettingEnabled - read
        Boolean isUceSettingEnabledResult = null;
        try {
            isUceSettingEnabledResult =
                    ShellIdentityUtils.invokeThrowableMethodWithShellPermissions(
                    uceAdapter, RcsUceAdapter::isUceSettingEnabled, ImsException.class,
                    ""android.permission.READ_PHONE_STATE"");
            assertNotNull(""result from isUceSettingEnabled should not be null"",
                    isUceSettingEnabledResult);
        } catch (SecurityException e) {
            fail(""isUceSettingEnabled should succeed with READ_PHONE_STATE."");
        } catch (ImsException e) {
            // unsupported is a valid fail cause.
            if (e.getCode() != ImsException.CODE_ERROR_UNSUPPORTED_OPERATION) {
                fail(""isUceSettingEnabled failed with code "" + e.getCode());
            }
        }

        // isUceSettingEnabled - read_privileged
        try {
            isUceSettingEnabledResult =
                    ShellIdentityUtils.invokeThrowableMethodWithShellPermissions(
                            uceAdapter, RcsUceAdapter::isUceSettingEnabled, ImsException.class,
                            ""android.permission.READ_PRIVILEGED_PHONE_STATE"");
            assertNotNull(""result from isUceSettingEnabled should not be null"",
                    isUceSettingEnabledResult);
        } catch (SecurityException e) {
            fail(""isUceSettingEnabled should succeed with READ_PRIVILEGED_PHONE_STATE."");
        } catch (ImsExcep"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/RcsUceAdapterTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.RcsUceAdapterTest"	"testCapabilitiesRequestAllowed"	"CtsTelephonyTestCases"	"1: permission"	"([4:/android/telephony/ims/cts/RcsUceAdapterTest.java]:[permission]:[4]:method_text:[ true, true);        waitForResult(completeQueue);        overrideCarrierConfig(null);    }   ]) :|: 
    public void testCapabilitiesRequestAllowed() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        // Start cap exchange disabled and enable later.
        PersistableBundle bundle = new PersistableBundle();
        bundle.putBoolean(CarrierConfigManager.Ims.KEY_ENABLE_PRESENCE_CAPABILITY_EXCHANGE_BOOL,
                false);
        overrideCarrierConfig(bundle);

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RcsUceAdapter uceAdapter = imsManager.getImsRcsManager(sTestSub).getUceAdapter();
        assertNotNull(""UCE adapter should not be null!"", uceAdapter);

        // Prepare the test contact and the callback
        Collection<Uri> numbers = new ArrayList<>(1);
        numbers.add(sTestNumberUri);

        ArrayList<String> pidfXmlList = new ArrayList<>(1);
        pidfXmlList.add(getPidfXmlData(sTestNumberUri, true, true));

        BlockingQueue<Boolean> completeQueue = new LinkedBlockingQueue<>();
        BlockingQueue<RcsContactUceCapability> capabilityQueue = new LinkedBlockingQueue<>();
        BlockingQueue<Integer> errorQueue = new LinkedBlockingQueue<>();
        RcsUceAdapter.CapabilitiesCallback callback = new RcsUceAdapter.CapabilitiesCallback() {
            @Override
            public void onCapabilitiesReceived(List<RcsContactUceCapability> capabilities) {
                capabilities.forEach(c -> capabilityQueue.offer(c));
            }
            @Override
            public void onComplete() {
                completeQueue.offer(true);
            }
            @Override
            public void onError(int errorCode, long retryAfterMilliseconds) {
                errorQueue.offer(errorCode);
            }
        };

        // The API requestCapabilities should fail when it doesn't grant the permission.
        try {
            uceAdapter.requestCapabilities(numbers, Runnable::run, callback);
            fail(""requestCapabilities requires ACC"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/RcsUceAdapterTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.RcsUceAdapterTest"	"testReceivingEmptyPidfXml"	"CtsTelephonyTestCases"	"1: permission"	"([5:/android/telephony/ims/cts/RcsUceAdapterTest.java]:[permission]:[5]:method_text:[   } catch (ImsException e) {            fail(""requestAvailability failed "" + e);        }    }}]) :|: 
    public void testReceivingEmptyPidfXml() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RcsUceAdapter uceAdapter = imsManager.getImsRcsManager(sTestSub).getUceAdapter();
        assertNotNull(""UCE adapter should not be null!"", uceAdapter);

        // Remove the test contact capabilities
        removeTestContactFromEab();

        // Connect to the ImsService
        setupTestImsService(uceAdapter, true, true /* presence cap */, false /* OPTIONS */);

        TestRcsCapabilityExchangeImpl capabilityExchangeImpl = sServiceConnector
                .getCarrierService().getRcsFeature().getRcsCapabilityExchangeImpl();

        BlockingQueue<Integer> errorQueue = new LinkedBlockingQueue<>();
        BlockingQueue<Long> errorRetryQueue = new LinkedBlockingQueue<>();
        BlockingQueue<Boolean> completeQueue = new LinkedBlockingQueue<>();
        BlockingQueue<RcsContactUceCapability> capabilityQueue = new LinkedBlockingQueue<>();
        RcsUceAdapter.CapabilitiesCallback callback = new RcsUceAdapter.CapabilitiesCallback() {
            @Override
            public void onCapabilitiesReceived(List<RcsContactUceCapability> capabilities) {
                capabilities.forEach(c -> capabilityQueue.offer(c));
            }
            @Override
            public void onComplete() {
                completeQueue.offer(true);
            }
            @Override
            public void onError(int errorCode, long retryAfterMilliseconds) {
                errorQueue.offer(errorCode);
                errorRetryQueue.offer(retryAfterMilliseconds);
            }
        };

        // Prepare the test contact
        Collection<Uri> contacts = new ArrayList<>(1);
        contacts.add(sTestNumberUri);

        // Prepare the empty PIDF xml
        ArrayList<String> pidfXmlList = new ArrayList<>(1);
        pidfXmlList.add("""");

        //"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/RcsUceAdapterTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.SipDelegateManagerTest"	"testIncorrectPermissions"	"CtsTelephonyTestCases"	"1: permission"	"([20:/android/telephony/ims/cts/SipDelegateManagerTest.java]:[permission]:[20]:method_text:[on check            fail(""uregisterImsStateCallback requires no permission."");        }    }   ]) :|: 
    // Note this test can run on devices with only feature FEATURE_TELEPHONY, so ImsResolver may not
    // be running.
    public void testIncorrectPermissions() throws Exception {
        if (!ImsUtils.shouldTestTelephony()) {
            return;
        }
        SipDelegateManager manager = getSipDelegateManager();
        try {
            manager.isSupported();
            fail(""isSupported requires READ_PRIVILEGED_PHONE_STATE or ""
                    + ""PERFORM_IMS_SINGLE_REGISTRATION"");
        } catch (SecurityException e) {
            //expected
        }
        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissions(
                    manager, SipDelegateManager::isSupported, ImsException.class,
                    ""android.permission.PERFORM_IMS_SINGLE_REGISTRATION"");
        } catch (ImsException e) {
            // Not a problem, only checking permissions here.
        } catch (SecurityException e) {
            fail(""isSupported requires READ_PRIVILEGED_PHONE_STATE or ""
                    + ""PERFORM_IMS_SINGLE_REGISTRATION, exception:"" + e);
        }
        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissions(
                    manager, SipDelegateManager::isSupported, ImsException.class,
                    ""android.permission.READ_PRIVILEGED_PHONE_STATE"");

        } catch (ImsException e) {
            // Not a problem, only checking permissions here.
        } catch (SecurityException e) {
            fail(""isSupported requires READ_PRIVILEGED_PHONE_STATE or ""
                    + ""PERFORM_IMS_SINGLE_REGISTRATION, exception:"" + e);
        }

        DelegateRequest d = new DelegateRequest(Collections.emptySet());
        TestSipDelegateConnection c = new TestSipDelegateConnection(d);
        try {
            manager.createSipDelegate(d, Runnable::run, c, c);
            fail(""createSipDelegate requires PERFORM_IMS_SINGLE_REGISTRATION"");
        } catch (SecurityException e) {"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/SipDelegateManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.SipDelegateManagerTest"	"testFeatureImsNotSupported"	"CtsTelephonyTestCases"	"1: permission"	"([6:/android/telephony/ims/cts/SipDelegateManagerTest.java]:[permission]:[6]:method_text:[      sServiceConnector.setDeviceSingleRegistrationEnabled(true);            }        }    }   ]) :|: 
    // Note this test can run on devices with only feature FEATURE_TELEPHONY, so ImsResolver may not
    // be running.
    public void testFeatureImsNotSupported() throws Exception {
        if (!ImsUtils.shouldTestTelephony()) {
            return;
        }

        if (sServiceConnector != null) {
            // Override FEATURE_TELEPHONY_IMS_SINGLE_REGISTRATION for this test so that telephony
            // will report not enabled.
            sServiceConnector.setDeviceSingleRegistrationEnabled(false);
        }

        try {
            SipDelegateManager manager = getSipDelegateManager();

            try {
                // If FEATURE_TELEPHONY_IMS_SINGLE_REGISTRATION is not supported this should
                // return false.
                Boolean result = ShellIdentityUtils.invokeThrowableMethodWithShellPermissions(
                        manager, SipDelegateManager::isSupported, ImsException.class,
                        ""android.permission.PERFORM_IMS_SINGLE_REGISTRATION"");
                assertNotNull(result);
                assertFalse(""isSupported should return false on devices that do not ""
                        + ""support feature FEATURE_TELEPHONY_IMS_SINGLE_REGISTRATION"", result);
            } catch (SecurityException e) {
                fail(""isSupported requires PERFORM_IMS_SINGLE_REGISTRATION permission"");
            }

            try {
                // If FEATURE_TELEPHONY_IMS_SINGLE_REGISTRATION is not supported, this should throw
                // an ImsException
                DelegateRequest request = new DelegateRequest(Collections.emptySet());
                TestSipDelegateConnection delegateConn = new TestSipDelegateConnection(request);
                ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(
                        manager, (m) -> m.createSipDelegate(request, Runnable::run,
                                delegateConn, delegateConn), ImsException.class,
                        ""android"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/SipDelegateManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.SipDelegateManagerTest"	"testIsSupportedWithSipTransportCapable"	"CtsTelephonyTestCases"	"1: permission"	"([3:/android/telephony/ims/cts/SipDelegateManagerTest.java]:[permission]:[3]:method_text:[     assertNotNull(result);        assertTrue(""isSupported should return true"", result);    }   ]) :|: 
    public void testIsSupportedWithSipTransportCapable() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        PersistableBundle b = new PersistableBundle();
        b.putBoolean(CarrierConfigManager.Ims.KEY_IMS_SINGLE_REGISTRATION_REQUIRED_BOOL, true);
        overrideCarrierConfig(b);
        connectTestImsServiceWithSipTransport();

        SipDelegateManager manager = getSipDelegateManager();
        Boolean result = null;
        try {
            result = callUntilImsServiceIsAvailable(() ->
                    ShellIdentityUtils.invokeThrowableMethodWithShellPermissions(manager,
                            SipDelegateManager::isSupported, ImsException.class,
                            ""android.permission.PERFORM_IMS_SINGLE_REGISTRATION""));
        } catch (SecurityException e) {
            fail(""isSupported requires PERFORM_IMS_SINGLE_REGISTRATION permission"");
        }
        assertNotNull(result);
        assertTrue(""isSupported should return true"", result);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/SipDelegateManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.SipDelegateManagerTest"	"testIsSupportedWithSipTransportCapableCarrierConfigNotSet"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/ims/cts/SipDelegateManagerTest.java]:[permission]:[2]:method_text:[                + ""false"", result);    }    @Ignore(""Disabling for integration b/175766573"")   ]) :|: 
    public void testIsSupportedWithSipTransportCapableCarrierConfigNotSet() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        PersistableBundle b = new PersistableBundle();
        // Carrier Config is explicitly set to not support single registration.
        b.putBoolean(CarrierConfigManager.Ims.KEY_IMS_SINGLE_REGISTRATION_REQUIRED_BOOL, false);
        overrideCarrierConfig(b);
        connectTestImsServiceWithSipTransport();

        Boolean result = callUntilImsServiceIsAvailable(() ->
                ShellIdentityUtils.invokeThrowableMethodWithShellPermissions(
                        getSipDelegateManager(), SipDelegateManager::isSupported,
                        ImsException.class, ""android.permission.PERFORM_IMS_SINGLE_REGISTRATION""));
        assertNotNull(result);
        assertFalse(""isSupported should return false if""
                + ""CarrierConfigManager.Ims.KEY_RCS_SINGLE_REGISTRATION_REQUIRED_BOOL is set to ""
                + ""false"", result);
    }

    @Ignore(""Disabling for integration b/175766573"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/SipDelegateManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.SipDelegateManagerTest"	"testIsSupportedWithSipTransportCapableOnlyRcs"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/ims/cts/SipDelegateManagerTest.java]:[permission]:[2]:method_text:[msService is only ""                + ""attached for RCS and not MMTEL and RCS"", result);    }   ]) :|: 
    public void testIsSupportedWithSipTransportCapableOnlyRcs() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        PersistableBundle b = new PersistableBundle();
        b.putBoolean(CarrierConfigManager.Ims.KEY_IMS_SINGLE_REGISTRATION_REQUIRED_BOOL, true);
        overrideCarrierConfig(b);

        assertTrue(sServiceConnector.connectCarrierImsServiceLocally());
        // set SipTransport as supported with RCS only attached.
        sServiceConnector.getCarrierService().addCapabilities(
                ImsService.CAPABILITY_SIP_DELEGATE_CREATION);
        sServiceConnector.getCarrierService().setSipTransportImplemented();

        ImsFeatureConfiguration c = getConfigForRcs();
        assertTrue(sServiceConnector.triggerFrameworkConnectionToCarrierImsService(c));
        verifyImsServiceState(c);

        Boolean result = callUntilImsServiceIsAvailable(() ->
                ShellIdentityUtils.invokeThrowableMethodWithShellPermissions(
                        getSipDelegateManager(), SipDelegateManager::isSupported,
                        ImsException.class, ""android.permission.PERFORM_IMS_SINGLE_REGISTRATION""));
        assertNotNull(result);
        assertFalse(""isSupported should return false in the case that the ImsService is only ""
                + ""attached for RCS and not MMTEL and RCS"", result);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/SipDelegateManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.SipDelegateManagerTest"	"testIsSupportedWithSipTransportCapableButNotImplemented"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/ims/cts/SipDelegateManagerTest.java]:[permission]:[2]:method_text:[rn false in the case that SipTransport is not ""                + ""implemented"", result);    }   ]) :|: 
    public void testIsSupportedWithSipTransportCapableButNotImplemented() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        PersistableBundle b = new PersistableBundle();
        b.putBoolean(CarrierConfigManager.Ims.KEY_IMS_SINGLE_REGISTRATION_REQUIRED_BOOL, true);
        overrideCarrierConfig(b);

        assertTrue(sServiceConnector.connectCarrierImsServiceLocally());
        // SipTransport set as capable, but no SipTransport implementation is returned.
        sServiceConnector.getCarrierService().addCapabilities(
                ImsService.CAPABILITY_SIP_DELEGATE_CREATION);
        ImsFeatureConfiguration c = getConfigForMmTelAndRcs();
        assertTrue(sServiceConnector.triggerFrameworkConnectionToCarrierImsService(c));
        verifyImsServiceState(c);

        Boolean result = callUntilImsServiceIsAvailable(() ->
                ShellIdentityUtils.invokeThrowableMethodWithShellPermissions(
                        getSipDelegateManager(), SipDelegateManager::isSupported,
                        ImsException.class, ""android.permission.PERFORM_IMS_SINGLE_REGISTRATION""));
        assertNotNull(result);
        assertFalse(""isSupported should return false in the case that SipTransport is not ""
                + ""implemented"", result);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/SipDelegateManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.SipDelegateManagerTest"	"testIsSupportedWithSipTransportImplementedButNotCapable"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/ims/cts/SipDelegateManagerTest.java]:[permission]:[2]:method_text:[ot ""                + ""set as capable in ImsService#getImsServiceCapabilities"", result);    }   ]) :|: 
    public void testIsSupportedWithSipTransportImplementedButNotCapable() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        PersistableBundle b = new PersistableBundle();
        b.putBoolean(CarrierConfigManager.Ims.KEY_IMS_SINGLE_REGISTRATION_REQUIRED_BOOL, true);
        overrideCarrierConfig(b);

        assertTrue(sServiceConnector.connectCarrierImsServiceLocally());
        // SipTransport is set as Implemented, but not Capable
        sServiceConnector.getCarrierService().setSipTransportImplemented();
        ImsFeatureConfiguration c = getConfigForMmTelAndRcs();
        assertTrue(sServiceConnector.triggerFrameworkConnectionToCarrierImsService(c));
        verifyImsServiceState(c);

        Boolean result = callUntilImsServiceIsAvailable(() ->
                ShellIdentityUtils.invokeThrowableMethodWithShellPermissions(
                        getSipDelegateManager(), SipDelegateManager::isSupported,
                        ImsException.class, ""android.permission.PERFORM_IMS_SINGLE_REGISTRATION""));
        assertNotNull(result);
        assertFalse(""isSupported should return false in the case that SipTransport is not ""
                + ""set as capable in ImsService#getImsServiceCapabilities"", result);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/SipDelegateManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.SipDelegateManagerTest"	"testIsSupportedWithSipTransportNotImplementedNotCapable"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/ims/cts/SipDelegateManagerTest.java]:[permission]:[2]:method_text:[ot ""                + ""set as capable in ImsService#getImsServiceCapabilities"", result);    }   ]) :|: 
    public void testIsSupportedWithSipTransportNotImplementedNotCapable() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        PersistableBundle b = new PersistableBundle();
        b.putBoolean(CarrierConfigManager.Ims.KEY_IMS_SINGLE_REGISTRATION_REQUIRED_BOOL, true);
        overrideCarrierConfig(b);

        assertTrue(sServiceConnector.connectCarrierImsServiceLocally());
        // Not Implemented/capable
        ImsFeatureConfiguration c = getConfigForMmTelAndRcs();
        assertTrue(sServiceConnector.triggerFrameworkConnectionToCarrierImsService(c));
        verifyImsServiceState(c);

        Boolean result = callUntilImsServiceIsAvailable(() ->
                ShellIdentityUtils.invokeThrowableMethodWithShellPermissions(
                        getSipDelegateManager(), SipDelegateManager::isSupported,
                        ImsException.class, ""android.permission.PERFORM_IMS_SINGLE_REGISTRATION""));
        assertNotNull(result);
        assertFalse(""isSupported should return false in the case that SipTransport is not ""
                + ""set as capable in ImsService#getImsServiceCapabilities"", result);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/SipDelegateManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.SipDelegateManagerTest"	"testIncomingInviteDeregistering"	"CtsTelephonyTestCases"	"1: permission"	"([2:/android/telephony/ims/cts/SipDelegateManagerTest.java]:[permission]:[2]:method_text:[ext getContext() {        return InstrumentationRegistry.getInstrumentation().getContext();    }}]) :|: 
    public void testIncomingInviteDeregistering() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }
        TransportInterfaces ifaces = new TransportInterfaces(getDefaultRequest(),
                Collections.emptySet(), 0);
        ifaces.connect();
        // move chat to deregistering
        Set<String> regFeatures = new ArraySet<>(Arrays.asList(DEFAULT_FEATURE_TAGS));
        regFeatures.remove(ONE_TO_ONE_CHAT_TAG);
        DelegateRegistrationState state = getDeregisteringState(regFeatures,
                Collections.singleton(ONE_TO_ONE_CHAT_TAG),
                DelegateRegistrationState.DEREGISTERING_REASON_PROVISIONING_CHANGE);
        verifyRegistrationState(ifaces, state);
        // receive invite, which can not be blocked
        SipDialogAttributes attr = new SipDialogAttributes();
        receiveChatInvite(attr, ifaces);
        // ensure delegate connection can still respond to the request, even if in restricted state.
        send200OkResponse(attr, ifaces);
        receiveAck(attr, ifaces);
        // receive BYE and clean up
        receiveByeRequest(attr, ifaces);
        ifaces.delegateConn.sendCleanupSession(attr.callId);
        ifaces.delegate.verifyCleanupSession(attr.callId);

        destroySipDelegateAndVerify(ifaces);
        assertEquals(""There should be no more delegates"", 0,
                ifaces.transport.getDelegates().size());
        verifyUpdateRegistrationCalled(ifaces.reg);
    }

    private SipMessage generateSipMessage(String str) {
        String crlf = ""\r\n"";
        String[] components = str.split(crlf);
        String startLine = """";
        String header = """";
        String content = """";
        StringBuilder sb = new StringBuilder();
        int idx = 1;
        if (components.length > 0) {
            startLine = components[0] + crlf;
        }
        // generate sip header
        idx = composeSipSection(idx, components, sb);
        header = sb.toString();"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/SipDelegateManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsRcsManagerTest"	"beforeAllTests"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/ims/cts/ImsRcsManagerTest.java]:[permission]:[1]:method_text:[ SIM in the device!"");        }    }    /**     * Test Permissions on various APIs.     */   ]) :|: /*
 *.
 */

package android.telephony.ims.cts;

import static org.junit.Assert.fail;

import android.content.Context;
import android.os.Looper;
import android.telephony.SubscriptionManager;
import android.telephony.ims.ImsException;
import android.telephony.ims.ImsManager;
import android.telephony.ims.ImsRcsManager;
import android.telephony.ims.ImsStateCallback;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(AndroidJUnit4.class)
public class ImsRcsManagerTest {

    private static int sTestSub = SubscriptionManager.INVALID_SUBSCRIPTION_ID;

    @BeforeClass
    public static void beforeAllTests() {
        // assumeTrue() in @BeforeClass is not supported by our test runner.
        // Resort to the early exit.
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        sTestSub = ImsUtils.getPreferredActiveSubId();

        if (Looper.getMainLooper() == null) {
            Looper.prepareMainLooper();
        }
    }

    @Before
    public void beforeTest() {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        if (!SubscriptionManager.isValidSubscriptionId(sTestSub)) {
            fail(""This test requires that there is a SIM in the device!"");
        }
    }

    /**
     * Test Permissions on various APIs.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsRcsManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.ImsRcsManagerTest"	"testMethodPermissions"	"CtsTelephonyTestCases"	"1: permission"	"([22:/android/telephony/ims/cts/ImsRcsManagerTest.java]:[permission]:[22]:method_text:[ext getContext() {        return InstrumentationRegistry.getInstrumentation().getContext();    }}]) :|: 
    public void testMethodPermissions() throws Exception {
        if (!ImsUtils.shouldTestTelephony()) {
            return;
        }

        // This verifies the permission checking in ITelephony,
        // not the IMS service's behavior.
        // Since SecurityException has the highest priority,
        // DEFAULT_SUBSCRIPTION_ID is enough to check permissions.
        // Though it throws an ImsException, we ignore that.
        if (sTestSub == SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
            sTestSub = SubscriptionManager.DEFAULT_SUBSCRIPTION_ID;
        }

        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        ImsRcsManager rcsManager = imsManager.getImsRcsManager(sTestSub);

        ImsStateCallback callback = new ImsStateCallback() {
            @Override
            public void onUnavailable(int reason) { }
            @Override
            public void onAvailable() { }
            @Override
            public void onError() { }
        };

        try {
            rcsManager.registerImsStateCallback(Runnable::run, callback);
            fail(""registerImsStateCallback requires READ_PRECISE_PHONE_STATE, ""
                    + ""ACCESS_RCS_USER_CAPABILITY_EXCHANGE or ""
                    + ""READ_PRIVILEGED_PHONE_STATE permission."");
        } catch (SecurityException e) {
            //expected
        } catch (ImsException ie) {
            fail(""registerImsStateCallback requires READ_PRECISE_PHONE_STATE, ""
                    + ""ACCESS_RCS_USER_CAPABILITY_EXCHANGE or ""
                    + ""READ_PRIVILEGED_PHONE_STATE permission."");
        }

        try {
            ShellIdentityUtils.invokeThrowableMethodWithShellPermissionsNoReturn(rcsManager,
                    m -> m.registerImsStateCallback(Runnable::run, callback),
                    ImsException.class, ""android.permission.READ_PRECISE_PHONE_STATE"");
        } catch (SecurityException e) {
            fail(""registerImsStateCallback requires READ"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/ImsRcsManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.ims.cts.EabControllerTest"	"testRequestExpiredAvailabilities"	"CtsTelephonyTestCases"	"1: permission"	"([7:/android/telephony/ims/cts/EabControllerTest.java]:[permission]:[7]:method_text:[imes--;        } while (retryTimes > 0 && Instant.now().getEpochSecond() < expirationTime);    }}]) :|: 
    public void testRequestExpiredAvailabilities() throws Exception {
        if (!ImsUtils.shouldTestImsService()) {
            return;
        }

        // Set availability expiration time
        setProvisioningIntValue(ProvisioningManager.KEY_RCS_AVAILABILITY_CACHE_EXPIRATION_SEC,
                EXPIRATION_TIME_IN_SEC);

        fakeNetworkResult(getPidfXmlData(
                sTestNumberUri,
                TEST_SERVICE_DESCRIPTION,
                TUPLE_BASIC_STATUS_OPEN,
                true,
                false,
                DUPLEX_MODE_RECEIVE_ONLY,
                DUPLEX_MODE_SEND_ONLY));
        // Request availabilities for saving availabilities to EAB provider
        requestAvailability(sTestNumberUri);
        mErrorQueue.clear();
        mCompleteQueue.clear();
        mCapabilityQueue.clear();

        // Waiting availabilities expire
        waitingEabCapabilityExpire();

        // Request availabilities again
        RcsContactUceCapability capability = requestAvailability(sTestNumberUri);

        // Verify that return the availabilities from network instead of the EAB provider
        verifyCapabilityResult(capability,
                sTestNumberUri,
                TEST_SERVICE_DESCRIPTION,
                TUPLE_BASIC_STATUS_OPEN,
                REQUEST_RESULT_FOUND,
                RcsContactUceCapability.SOURCE_TYPE_NETWORK,
                true,
                false,
                DUPLEX_MODE_RECEIVE_ONLY,
                DUPLEX_MODE_SEND_ONLY);

        // Verify the onCompleted is called
        waitForResult(mCompleteQueue);
    }

    private RcsContactUceCapability requestAvailability(Uri contact) throws Exception {
        // Request capabilities by calling the API requestCapabilities.
        ImsManager imsManager = getContext().getSystemService(ImsManager.class);
        RcsUceAdapter uceAdapter = imsManager.getImsRcsManager(sTestSub).getUceAdapter();

        try {
            ShellIdentityUtils.invokeThrowableMethodW"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/ims/cts/EabControllerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.embms.cts.MbmsDownloadReceiverTest"	"testRequestRefreshedFileDescriptors"	"CtsTelephonyTestCases"	"1: permission"	"([1:/android/telephony/embms/cts/MbmsDownloadReceiverTest.java]:[permission]:[1]:method_text:[ERVICE_ID);        intent.putExtra(VendorUtils.EXTRA_TEMP_FILE_ROOT, tempFileRootDirPath);    }}]) :|: 
    public void testRequestRefreshedFileDescriptors() throws Exception {
        // Set up a few temp files that we can request again
        Intent fdRequestIntent = new Intent(VendorUtils.ACTION_FILE_DESCRIPTOR_REQUEST);
        populateIntentWithCommonFields(fdRequestIntent);
        fdRequestIntent.putExtra(VendorUtils.EXTRA_FD_COUNT, 2);

        Bundle result = sendBroadcastAndValidate(fdRequestIntent, MbmsDownloadReceiver.RESULT_OK);
        List<UriPathPair> freeUris = result.getParcelableArrayList(VendorUtils.EXTRA_FREE_URI_LIST);

        Intent fdRefreshIntent = new Intent(VendorUtils.ACTION_FILE_DESCRIPTOR_REQUEST);
        populateIntentWithCommonFields(fdRefreshIntent);
        fdRefreshIntent.putParcelableArrayListExtra(VendorUtils.EXTRA_PAUSED_LIST,
                new ArrayList<>(freeUris.stream().map(UriPathPair::getFilePathUri)
                        .collect(Collectors.toList())));
        Bundle result2 = sendBroadcastAndValidate(fdRefreshIntent, MbmsDownloadReceiver.RESULT_OK);
        List<UriPathPair> refreshUris =
                result2.getParcelableArrayList(VendorUtils.EXTRA_PAUSED_URI_LIST);
        assertEquals(freeUris.size(), refreshUris.size());
        for (UriPathPair pathPair : refreshUris) {
            assertTrue(freeUris.stream()
                    .anyMatch((originalPair) ->
                            originalPair.getFilePathUri().equals(pathPair.getFilePathUri())));
        }
    }

    private Bundle sendBroadcastAndValidate(Intent intent, int expectedCode) {
        BlockingQueue<Bundle> receivedExtras = new LinkedBlockingQueue<>();
        BlockingQueue<Integer> receivedCode = new LinkedBlockingQueue<>();
        mContext.sendOrderedBroadcast(intent, CTS_BROADCAST_PERMISSION,
                new BroadcastReceiver() {
                    @Override
                    public void onReceive(Context context, Intent intent) {
                        receivedExtras.add(getResultExtras(true));
                        received"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/embms/cts/MbmsDownloadReceiverTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.telephonypermission.TelephonyManagerReadPhoneStatePermissionTest"	"getVisualVoicemailPackageName"	"CtsTelephonyTestCases"	"1: permission"	"([8:/android/telephony/cts/telephonypermission/TelephonyManagerReadPhoneStatePermissionTest.java]:[permission]:[8]:method_text:[ enforcement)     * getCallStateForSubscription() (when compat fwk enables enforcement)     */   ]) :|: /*
 *.
 */

package android.telephony.cts.telephonypermission;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.fail;

import android.content.Context;
import android.content.pm.PackageManager;
import android.platform.test.annotations.AppModeFull;
import android.telecom.PhoneAccount;
import android.telecom.TelecomManager;
import android.telephony.SubscriptionManager;
import android.telephony.TelephonyManager;
import android.telephony.cts.TelephonyUtils;
import android.telephony.emergency.EmergencyNumber;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Test TelephonyManager APIs with READ_PHONE_STATE Permission.
 */
@RunWith(AndroidJUnit4.class)
@AppModeFull(reason = ""Cannot grant the runtime permission in instant app mode"")
public class TelephonyManagerReadPhoneStatePermissionTest {

    private boolean mHasTelephony;
    TelephonyManager mTelephonyManager = null;
    TelecomManager mTelecomManager = null;

    @Before
    public void setUp() throws Exception {
        mHasTelephony = getContext().getPackageManager().hasSystemFeature(
                PackageManager.FEATURE_TELEPHONY);
        mTelephonyManager =
                (TelephonyManager) getContext().getSystemService(Context.TELEPHONY_SERVICE);
        assertNotNull(mTelephonyManager);
        mTelecomManager =
                (TelecomManager) getContext().getSystemService(Context.TELECOM_SERVICE);
        assertNotNull(mTelecomManager);
    }

    @After
    public void tearDown() throws Exception {
        TelephonyUtils.resetCompatCommand(InstrumentationRegistry.getInstrumentation(),
                TelephonyUtils.CTS_APP_PACKAGE,
                TelephonyUtils.ENABLE_GET_CALL_STATE_PERMISSION_PROTECTION_STRING);
    }

    /**
     * Verify that TelephonyMan"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/permissions/src/android/telephony/cts/telephonypermission/TelephonyManagerReadPhoneStatePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony.cts.telephonypermission.TelephonyManagerReadPhoneStatePermissionTest"	"testTelephonyManagersAPIsRequiringReadPhoneStatePermissions"	"CtsTelephonyTestCases"	"1: permission"	"([26:/android/telephony/cts/telephonypermission/TelephonyManagerReadPhoneStatePermissionTest.java]:[permission]:[26]:method_text:[  private static Context getContext() {        return InstrumentationRegistry.getContext();    }}]) :|: 
    public void testTelephonyManagersAPIsRequiringReadPhoneStatePermissions() throws Exception {
        if (!mHasTelephony) {
            return;
        }

        try {
            // We must ensure that compat fwk enables READ_PHONE_STATE enforcement
            TelephonyUtils.enableCompatCommand(InstrumentationRegistry.getInstrumentation(),
                    TelephonyUtils.CTS_APP_PACKAGE,
                    TelephonyUtils.ENABLE_GET_CALL_STATE_PERMISSION_PROTECTION_STRING);
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getCallState());
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getCallStateForSubscription());
        } catch (SecurityException e) {
            fail(""TelephonyManager#getCallState and TelephonyManager#getCallStateForSubscription ""
                    + ""must not throw a SecurityException because READ_PHONE_STATE permission is ""
                    + ""granted and TelecomManager#ENABLE_GET_CALL_STATE_PERMISSION_PROTECTION is ""
                    + ""enabled."");
        }

        int subId = mTelephonyManager.getSubscriptionId();

        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getNetworkType());
        } catch (SecurityException e) {
            fail(""getNetworkType() must not throw a SecurityException with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getDeviceSoftwareVersion());
        } catch (SecurityException e) {
            fail(""getDeviceSoftwareVersion() must not throw a SecurityException""
                    + "" with READ_PHONE_STATE"" + e);
        }
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTelephonyManager, (tm) -> tm.getCarrierConfig());"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/permissions/src/android/telephony/cts/telephonypermission/TelephonyManagerReadPhoneStatePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.car.cts.permissionreadcardisplayunits.PermissionReadCarDisplayUnitsTest"	"isNotNull"	""	"1: permission"	"([4:/android/car/cts/permissionreadcardisplayunits/PermissionReadCarDisplayUnitsTest.java]:[permission]:[4]:method_text:[              Car.PROPERTY_SERVICE);        assertThat(mCarPropertyManager).isNotNull();    }   ]) :|: /*
 *.
 */

package android.car.cts.permissionreadcardisplayunits;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import android.car.Car;
import android.car.VehiclePropertyIds;
import android.car.hardware.CarPropertyConfig;
import android.car.hardware.property.CarPropertyManager;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.RequiresDevice;

import androidx.test.platform.app.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.google.common.collect.ImmutableList;

import org.junit.Test;
import org.junit.Before;
import org.junit.runner.RunWith;

@RequiresDevice
@RunWith(AndroidJUnit4.class)
@AppModeFull(reason = ""Instant apps cannot get car related permissions."")
public final class PermissionReadCarDisplayUnitsTest {
    private static final ImmutableList<Integer> PERMISSION_READ_CAR_DISPLAY_UNITS_PROPERTIES =
            ImmutableList.<Integer>builder().add(
                    VehiclePropertyIds.DISTANCE_DISPLAY_UNITS,
                    VehiclePropertyIds.FUEL_VOLUME_DISPLAY_UNITS,
                    VehiclePropertyIds.TIRE_PRESSURE_DISPLAY_UNITS,
                    VehiclePropertyIds.EV_BATTERY_DISPLAY_UNITS,
                    /*VehiclePropertyIds.VEHICLE_SPEED_DISPLAY_UNITS=*/ 289408516,
                    VehiclePropertyIds.FUEL_CONSUMPTION_UNITS_DISTANCE_OVER_VOLUME)
                    .build();

    private CarPropertyManager mCarPropertyManager;

    @Before
    public void setUp() {
        mCarPropertyManager =
                (CarPropertyManager) Car.createCar(
                        InstrumentationRegistry.getInstrumentation().getContext()).getCarManager(
                        Car.PROPERTY_SERVICE);
        assertThat(mCarPropertyManager).isNotNull();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/car/PermissionReadCarDisplayUnits/src/android/car/cts/permissionreadcardisplayunits/PermissionReadCarDisplayUnitsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.car.cts.permissionreadcardisplayunits.PermissionReadCarDisplayUnitsTest"	"testPermissionReadCarDisplayUnitsGranted"	""	"1: permission"	"([2:/android/car/cts/permissionreadcardisplayunits/PermissionReadCarDisplayUnitsTest.java]:[permission]:[2]:method_text:[pertyId()).isIn(                    PERMISSION_READ_CAR_DISPLAY_UNITS_PROPERTIES);        }    }]) :|: 
    public void testPermissionReadCarDisplayUnitsGranted() {
        for (CarPropertyConfig<?> carPropertyConfig : mCarPropertyManager.getPropertyList()) {
            assertWithMessage(""%s"",
                    VehiclePropertyIds.toString(carPropertyConfig.getPropertyId())).that(
                    carPropertyConfig.getPropertyId()).isIn(
                    PERMISSION_READ_CAR_DISPLAY_UNITS_PROPERTIES);
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/car/PermissionReadCarDisplayUnits/src/android/car/cts/permissionreadcardisplayunits/PermissionReadCarDisplayUnitsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.car.cts.permissioncarenergyports.PermissionCarEnergyPortsTest"	"isNotNull"	""	"1: permission"	"([4:/android/car/cts/permissioncarenergyports/PermissionCarEnergyPortsTest.java]:[permission]:[4]:method_text:[              Car.PROPERTY_SERVICE);        assertThat(mCarPropertyManager).isNotNull();    }   ]) :|: /*
 *.
 */

package android.car.cts.permissioncarenergyports;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import android.car.Car;
import android.car.VehiclePropertyIds;
import android.car.hardware.CarPropertyConfig;
import android.car.hardware.property.CarPropertyManager;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.RequiresDevice;

import androidx.test.platform.app.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.google.common.collect.ImmutableList;

import org.junit.Test;
import org.junit.Before;
import org.junit.runner.RunWith;

@RequiresDevice
@RunWith(AndroidJUnit4.class)
@AppModeFull(reason = ""Instant apps cannot get car related permissions."")
public final class PermissionCarEnergyPortsTest {
    private static final ImmutableList<Integer> PERMISSION_CAR_ENERGY_PORTS_PROPERTIES =
            ImmutableList.<Integer>builder().add(
                    VehiclePropertyIds.FUEL_DOOR_OPEN, VehiclePropertyIds.EV_CHARGE_PORT_OPEN,
                    VehiclePropertyIds.EV_CHARGE_PORT_CONNECTED)
                    .build();

    private CarPropertyManager mCarPropertyManager;

    @Before
    public void setUp() {
        mCarPropertyManager =
                (CarPropertyManager) Car.createCar(
                        InstrumentationRegistry.getInstrumentation().getContext()).getCarManager(
                        Car.PROPERTY_SERVICE);
        assertThat(mCarPropertyManager).isNotNull();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/car/PermissionCarEnergyPorts/src/android/car/cts/permissioncarenergyports/PermissionCarEnergyPortsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.car.cts.permissioncarenergyports.PermissionCarEnergyPortsTest"	"testPermissionCarEnergyPortsGranted"	""	"1: permission"	"([2:/android/car/cts/permissioncarenergyports/PermissionCarEnergyPortsTest.java]:[permission]:[2]:method_text:[getPropertyId()).isIn(                    PERMISSION_CAR_ENERGY_PORTS_PROPERTIES);        }    }]) :|: 
    public void testPermissionCarEnergyPortsGranted() {
        for (CarPropertyConfig<?> carPropertyConfig : mCarPropertyManager.getPropertyList()) {
            assertWithMessage(""%s"",
                    VehiclePropertyIds.toString(carPropertyConfig.getPropertyId())).that(
                    carPropertyConfig.getPropertyId()).isIn(
                    PERMISSION_CAR_ENERGY_PORTS_PROPERTIES);
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/car/PermissionCarEnergyPorts/src/android/car/cts/permissioncarenergyports/PermissionCarEnergyPortsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.car.cts.permissioncarexteriorenvironment.PermissionCarExteriorEnvironmentTest"	"isNotNull"	""	"1: permission"	"([4:/android/car/cts/permissioncarexteriorenvironment/PermissionCarExteriorEnvironmentTest.java]:[permission]:[4]:method_text:[              Car.PROPERTY_SERVICE);        assertThat(mCarPropertyManager).isNotNull();    }   ]) :|: /*
 *.
 */

package android.car.cts.permissioncarexteriorenvironment;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import android.car.Car;
import android.car.VehiclePropertyIds;
import android.car.hardware.CarPropertyConfig;
import android.car.hardware.property.CarPropertyManager;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.RequiresDevice;

import androidx.test.platform.app.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.CddTest;

import com.google.common.collect.ImmutableList;

import org.junit.Test;
import org.junit.Before;
import org.junit.runner.RunWith;

@RequiresDevice
@RunWith(AndroidJUnit4.class)
@AppModeFull(reason = ""Instant apps cannot get car related permissions."")
public final class PermissionCarExteriorEnvironmentTest {
    private static final ImmutableList<Integer> PERMISSION_CAR_EXTERIOR_ENVIRONMENT_PROPERTIES =
            ImmutableList.<Integer>builder().add(
                    VehiclePropertyIds.NIGHT_MODE, VehiclePropertyIds.ENV_OUTSIDE_TEMPERATURE)
                    .build();

    private CarPropertyManager mCarPropertyManager;

    @Before
    public void setUp() {
        mCarPropertyManager =
                (CarPropertyManager) Car.createCar(
                        InstrumentationRegistry.getInstrumentation().getContext()).getCarManager(
                        Car.PROPERTY_SERVICE);
        assertThat(mCarPropertyManager).isNotNull();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/car/PermissionCarExteriorEnvironment/src/android/car/cts/permissioncarexteriorenvironment/PermissionCarExteriorEnvironmentTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.car.cts.permissioncarexteriorenvironment.PermissionCarExteriorEnvironmentTest"	"testPermissionCarExteriorEnvironmentGranted"	""	"1: permission"	"([2:/android/car/cts/permissioncarexteriorenvironment/PermissionCarExteriorEnvironmentTest.java]:[permission]:[2]:method_text:[SSION_CAR_EXTERIOR_ENVIRONMENT_PROPERTIES);        }    }    @CddTest(requirement = ""2.5.1"")   ]) :|: 
    public void testPermissionCarExteriorEnvironmentGranted() {
        for (CarPropertyConfig<?> carPropertyConfig : mCarPropertyManager.getPropertyList()) {
            assertWithMessage(""%s"",
                    VehiclePropertyIds.toString(carPropertyConfig.getPropertyId())).that(
                    carPropertyConfig.getPropertyId()).isIn(
                    PERMISSION_CAR_EXTERIOR_ENVIRONMENT_PROPERTIES);
        }
    }

    @CddTest(requirement = ""2.5.1"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/car/PermissionCarExteriorEnvironment/src/android/car/cts/permissioncarexteriorenvironment/PermissionCarExteriorEnvironmentTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.car.cts.permissioncarexteriorenvironment.PermissionCarExteriorEnvironmentTest"	"testRequiredPropertyAvailableWithPermissionCarExteriorEnvironmentGranted"	""	"1: permission"	"([1:/android/car/cts/permissioncarexteriorenvironment/PermissionCarExteriorEnvironmentTest.java]:[permission]:[1]:method_text:[er.getCarPropertyConfig(                        VehiclePropertyIds.NIGHT_MODE)).isNotNull();    }]) :|: 
    public void testRequiredPropertyAvailableWithPermissionCarExteriorEnvironmentGranted() {
        assertWithMessage(""%s"", VehiclePropertyIds.toString(VehiclePropertyIds.NIGHT_MODE))
                .that(mCarPropertyManager.getCarPropertyConfig(
                        VehiclePropertyIds.NIGHT_MODE)).isNotNull();
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/car/PermissionCarExteriorEnvironment/src/android/car/cts/permissioncarexteriorenvironment/PermissionCarExteriorEnvironmentTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.car.cts.nopropertypermissions.NoPropertyPermissionsTest"	"isNotNull"	""	"1: permission"	"([3:/android/car/cts/nopropertypermissions/NoPropertyPermissionsTest.java]:[permission]:[3]:method_text:[              Car.PROPERTY_SERVICE);        assertThat(mCarPropertyManager).isNotNull();    }   ]) :|: /*
 *.
 */

package android.car.cts.nopropertypermissions;

import static com.google.common.truth.Truth.assertWithMessage;
import static com.google.common.truth.Truth.assertThat;

import android.car.Car;
import android.car.hardware.property.CarPropertyManager;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.RequiresDevice;

import androidx.test.platform.app.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import org.junit.Test;
import org.junit.Before;
import org.junit.runner.RunWith;

@RequiresDevice
@RunWith(AndroidJUnit4.class)
@AppModeFull(reason = ""Instant apps cannot get car related permissions."")
public final class NoPropertyPermissionsTest {
    private CarPropertyManager mCarPropertyManager;

    @Before
    public void setUp() {
        mCarPropertyManager =
                (CarPropertyManager) Car.createCar(
                        InstrumentationRegistry.getInstrumentation().getContext()).getCarManager(
                        Car.PROPERTY_SERVICE);
        assertThat(mCarPropertyManager).isNotNull();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/car/NoPropertyPermissions/src/android/car/cts/nopropertypermissions/NoPropertyPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.car.cts.nopropertypermissions.NoPropertyPermissionsTest"	"testNoPropertyPermissionsGranted"	""	"1: permission"	"([1:/android/car/cts/nopropertypermissions/NoPropertyPermissionsTest.java]:[permission]:[1]:method_text:[r.getPropertyList()"").that(                mCarPropertyManager.getPropertyList()).isEmpty();    }]) :|: 
    public void testNoPropertyPermissionsGranted() {
        assertWithMessage(""CarPropertyManager.getPropertyList()"").that(
                mCarPropertyManager.getPropertyList()).isEmpty();
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/car/NoPropertyPermissions/src/android/car/cts/nopropertypermissions/NoPropertyPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.car.cts.permissioncarspeed.PermissionCarSpeedTest"	"isNotNull"	""	"1: permission"	"([4:/android.car.cts.permissioncarspeed/PermissionCarSpeedTest.java]:[permission]:[4]:method_text:[              Car.PROPERTY_SERVICE);        assertThat(mCarPropertyManager).isNotNull();    }   ]) :|: /*
 *.
 */

package android.car.cts.permissioncarspeed;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import android.car.Car;
import android.car.VehiclePropertyIds;
import android.car.hardware.CarPropertyConfig;
import android.car.hardware.property.CarPropertyManager;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.RequiresDevice;

import androidx.test.platform.app.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.CddTest;

import com.google.common.collect.ImmutableList;

import org.junit.Test;
import org.junit.Before;
import org.junit.runner.RunWith;

@RequiresDevice
@RunWith(AndroidJUnit4.class)
@AppModeFull(reason = ""Instant apps cannot get car related permissions."")
public final class PermissionCarSpeedTest {
    private static final ImmutableList<Integer> PERMISSION_CAR_SPEED_PROPERTIES =
            ImmutableList.<Integer>builder().add(
                    VehiclePropertyIds.PERF_VEHICLE_SPEED,
                    VehiclePropertyIds.PERF_VEHICLE_SPEED_DISPLAY, VehiclePropertyIds.WHEEL_TICK)
                    .build();

    private CarPropertyManager mCarPropertyManager;

    @Before
    public void setUp() {
        mCarPropertyManager =
                (CarPropertyManager) Car.createCar(
                        InstrumentationRegistry.getInstrumentation().getContext()).getCarManager(
                        Car.PROPERTY_SERVICE);
        assertThat(mCarPropertyManager).isNotNull();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/car/PermissionCarSpeed/src/android.car.cts.permissioncarspeed/PermissionCarSpeedTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.car.cts.permissioncarspeed.PermissionCarSpeedTest"	"testPermissionCarSpeedGranted"	""	"1: permission"	"([2:/android.car.cts.permissioncarspeed/PermissionCarSpeedTest.java]:[permission]:[2]:method_text:[d()).isIn(PERMISSION_CAR_SPEED_PROPERTIES);        }    }    @CddTest(requirement = ""2.5.1"")   ]) :|: 
    public void testPermissionCarSpeedGranted() {
        for (CarPropertyConfig<?> carPropertyConfig : mCarPropertyManager.getPropertyList()) {
            assertWithMessage(""%s"", VehiclePropertyIds.toString(carPropertyConfig.getPropertyId()))
                    .that(carPropertyConfig.getPropertyId()).isIn(PERMISSION_CAR_SPEED_PROPERTIES);
        }
    }

    @CddTest(requirement = ""2.5.1"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/car/PermissionCarSpeed/src/android.car.cts.permissioncarspeed/PermissionCarSpeedTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.car.cts.permissioncarspeed.PermissionCarSpeedTest"	"testRequiredPropertyAvailableWithPermissionCarSpeedGranted"	""	"1: permission"	"([1:/android.car.cts.permissioncarspeed/PermissionCarSpeedTest.java]:[permission]:[1]:method_text:[rPropertyConfig(                        VehiclePropertyIds.PERF_VEHICLE_SPEED)).isNotNull();    }]) :|: 
    public void testRequiredPropertyAvailableWithPermissionCarSpeedGranted() {
        assertWithMessage(""%s"", VehiclePropertyIds.toString(VehiclePropertyIds.PERF_VEHICLE_SPEED))
                .that(mCarPropertyManager.getCarPropertyConfig(
                        VehiclePropertyIds.PERF_VEHICLE_SPEED)).isNotNull();
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/car/PermissionCarSpeed/src/android.car.cts.permissioncarspeed/PermissionCarSpeedTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.car.cts.permissioncarpowertrain.PermissionCarPowertrainTest"	"isNotNull"	""	"1: permission"	"([4:/android/car/cts/permissioncarpowertrain/PermissionCarPowertrainTest.java]:[permission]:[4]:method_text:[              Car.PROPERTY_SERVICE);        assertThat(mCarPropertyManager).isNotNull();    }   ]) :|: /*
 *.
 */

package android.car.cts.permissioncarpowertrain;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import android.car.Car;
import android.car.VehiclePropertyIds;
import android.car.hardware.CarPropertyConfig;
import android.car.hardware.property.CarPropertyManager;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.RequiresDevice;

import androidx.test.platform.app.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.CddTest;

import com.google.common.collect.ImmutableList;

import org.junit.Test;
import org.junit.Before;
import org.junit.runner.RunWith;

@RequiresDevice
@RunWith(AndroidJUnit4.class)
@AppModeFull(reason = ""Instant apps cannot get car related permissions."")
public final class PermissionCarPowertrainTest {
    private static final ImmutableList<Integer> PERMISSION_CAR_POWERTRAIN_PROPERTIES =
            ImmutableList.<Integer>builder().add(
                    VehiclePropertyIds.GEAR_SELECTION, VehiclePropertyIds.CURRENT_GEAR,
                    VehiclePropertyIds.PARKING_BRAKE_ON,
                    VehiclePropertyIds.PARKING_BRAKE_AUTO_APPLY, VehiclePropertyIds.IGNITION_STATE)
                    .build();

    private CarPropertyManager mCarPropertyManager;

    @Before
    public void setUp() {
        mCarPropertyManager =
                (CarPropertyManager) Car.createCar(
                        InstrumentationRegistry.getInstrumentation().getContext()).getCarManager(
                        Car.PROPERTY_SERVICE);
        assertThat(mCarPropertyManager).isNotNull();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/car/PermissionCarPowertrain/src/android/car/cts/permissioncarpowertrain/PermissionCarPowertrainTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.car.cts.permissioncarpowertrain.PermissionCarPowertrainTest"	"testPermissionCarPowertrainGranted"	""	"1: permission"	"([2:/android/car/cts/permissioncarpowertrain/PermissionCarPowertrainTest.java]:[permission]:[2]:method_text:[     PERMISSION_CAR_POWERTRAIN_PROPERTIES);        }    }    @CddTest(requirement = ""2.5.1"")   ]) :|: 
    public void testPermissionCarPowertrainGranted() {
        for (CarPropertyConfig<?> carPropertyConfig : mCarPropertyManager.getPropertyList()) {
            assertWithMessage(""%s"", VehiclePropertyIds.toString(carPropertyConfig.getPropertyId()))
                    .that(carPropertyConfig.getPropertyId()).isIn(
                    PERMISSION_CAR_POWERTRAIN_PROPERTIES);
        }
    }

    @CddTest(requirement = ""2.5.1"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/car/PermissionCarPowertrain/src/android/car/cts/permissioncarpowertrain/PermissionCarPowertrainTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.car.cts.permissioncarpowertrain.PermissionCarPowertrainTest"	"testRequiredPropertyAvailableWithPermissionCarPowertrainGranted"	""	"1: permission"	"([1:/android/car/cts/permissioncarpowertrain/PermissionCarPowertrainTest.java]:[permission]:[1]:method_text:[CarPropertyConfig(                        VehiclePropertyIds.PARKING_BRAKE_ON)).isNotNull();    }]) :|: 
    public void testRequiredPropertyAvailableWithPermissionCarPowertrainGranted() {
        assertWithMessage(""%s"", VehiclePropertyIds.toString(VehiclePropertyIds.GEAR_SELECTION))
                .that(mCarPropertyManager.getCarPropertyConfig(
                        VehiclePropertyIds.GEAR_SELECTION)).isNotNull();
        assertWithMessage(""%s"", VehiclePropertyIds.toString(VehiclePropertyIds.PARKING_BRAKE_ON))
                .that(mCarPropertyManager.getCarPropertyConfig(
                        VehiclePropertyIds.PARKING_BRAKE_ON)).isNotNull();
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/car/PermissionCarPowertrain/src/android/car/cts/permissioncarpowertrain/PermissionCarPowertrainTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.car.cts.CarBluetoothTest"	"disable"	"CtsCarTestCases"	"1: permission"	"([1:/android/car/cts/CarBluetoothTest.java]:[permission]:[1]:method_text:[ented), or for the    // configured timeout. If all required profiles connect, the test passes.   ]) :|: /*
 *.
 */

package android.car.cts;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothManager;
import android.bluetooth.BluetoothProfile;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.RequiresDevice;
import android.test.suitebuilder.annotation.SmallTest;
import android.util.Log;
import android.util.SparseArray;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.CddTest;
import com.android.compatibility.common.util.FeatureUtil;
import com.android.compatibility.common.util.RequiredFeatureRule;

import org.junit.After;
import org.junit.Before;
import org.junit.ClassRule;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Contains the tests to prove compliance with android automotive specific bluetooth requirements.
 */
@SmallTest
@RequiresDevice
@RunWith(AndroidJUnit4.class)
@AppModeFull(reason = ""Instant Apps cannot get Bluetooth related permissions"")
public class CarBluetoothTest {
    @ClassRule
    public static final RequiredFeatureRule sRequiredFeatureRule = new RequiredFeatureRule(
            PackageManager.FEATURE_AUTOMOTIVE);

    private static final String TAG = ""CarBluetoothTest"";
    private static final boolean DBG = false;
    private Context mContext;

    // Bluetooth Core objects
    private BluetoothManager mBluetoothManager;
    private BluetoothAdapter mBluetoothAdapter;

    // Timeout for waiting for an adapter state change
    private s"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/car/src/android/car/cts/CarBluetoothTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.car.cts.CarPropertyConfigTest"	"getPropertyList"	"CtsCarTestCases"	"1: permission"	"([1:/android/car/cts/CarPropertyConfigTest.java]:[permission]:[1]:method_text:[rManager(Car.PROPERTY_SERVICE);        mConfigs = mCarPropertyManager.getPropertyList();    }   ]) :|: /*
 *
 */

package android.car.cts;

import static com.google.common.truth.Truth.assertThat;

import android.car.Car;
import android.car.VehicleAreaType;
import android.car.VehiclePropertyType;
import android.car.hardware.CarPropertyConfig;
import android.car.hardware.property.CarPropertyManager;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.RequiresDevice;
import android.test.suitebuilder.annotation.SmallTest;

import androidx.test.runner.AndroidJUnit4;

import org.junit.Before;
import org.junit.Test;
import org.junit.Assert;
import org.junit.Test.None;
import org.junit.runner.RunWith;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

@SmallTest
@RequiresDevice
@RunWith(AndroidJUnit4.class)
@AppModeFull(reason = ""Instant apps cannot get car related permissions."")
public class CarPropertyConfigTest extends CarApiTestBase {
    private CarPropertyManager mCarPropertyManager;
    private List<CarPropertyConfig> mConfigs = new ArrayList<>();
    private static final float EPSILON = 0.00001f;

    @Before
    public void setUp() throws Exception {
        super.setUp();
        mCarPropertyManager = (CarPropertyManager) getCar().getCarManager(Car.PROPERTY_SERVICE);
        mConfigs = mCarPropertyManager.getPropertyList();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/car/src/android/car/cts/CarPropertyConfigTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.car.cts.CarPropertyManagerTest"	"getPropertyList"	"CtsCarTestCases"	"1: permission"	"([1:/android/car/cts/CarPropertyManagerTest.java]:[permission]:[1]:method_text:[G_BRAKE_ON);    }    /**     * Test for {@link CarPropertyManager#getPropertyList()}     */   ]) :|: /*
 *.
 */

package android.car.cts;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.testng.Assert.assertThrows;

import android.car.Car;
import android.car.EvConnectorType;
import android.car.FuelType;
import android.car.PortLocationType;
import android.car.VehicleAreaSeat;
import android.car.VehicleAreaType;
import android.car.VehicleAreaWheel;
import android.car.VehicleGear;
import android.car.VehiclePropertyIds;
import android.car.cts.utils.VehiclePropertyVerifier;
import android.car.hardware.CarPropertyConfig;
import android.car.hardware.CarPropertyValue;
import android.car.hardware.property.CarPropertyManager;
import android.car.hardware.property.CarPropertyManager.CarPropertyEventCallback;
import android.car.hardware.property.VehicleElectronicTollCollectionCardStatus;
import android.car.hardware.property.VehicleElectronicTollCollectionCardType;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.RequiresDevice;
import android.test.suitebuilder.annotation.SmallTest;
import android.util.ArraySet;
import android.util.SparseArray;

import androidx.annotation.GuardedBy;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.CddTest;

import com.google.common.collect.ImmutableSet;

import org.junit.Assert;
import org.junit.Assume;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

@SmallTest
@RequiresDevice
@RunWith(AndroidJUnit4.class)
@AppModeFull(reason = ""Instant apps cannot get car related permissions."")
public class CarPropertyManagerTest extends CarApiTestBase {

    private static final long WAIT_CALLBACK = 1500L;
    private static final int NO_EVENTS = 0;
    private static final int ONCHANGE_RATE_EVENT_COUNTER = 1;
    private static final int UI_RATE_EVE"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/car/src/android/car/cts/CarPropertyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.car.cts.CarPowerManagerTest"	"testApplyNewPowerPolicy"	"CtsCarTestCases"	"1: permission"	"([4:/android/car/cts/CarPowerManagerTest.java]:[permission]:[4]:method_text:[ {                return mCurrentPolicyId;            }            return null;        }    }}]) :|: 
    public void testApplyNewPowerPolicy() throws Exception {
        PowerPolicyListenerImpl listenerAudioOne = new PowerPolicyListenerImpl();
        PowerPolicyListenerImpl listenerAudioTwo = new PowerPolicyListenerImpl();
        PowerPolicyListenerImpl listenerWifi = new PowerPolicyListenerImpl();
        PowerPolicyListenerImpl listenerLocation = new PowerPolicyListenerImpl();
        CarPowerPolicyFilter filterAudio = new CarPowerPolicyFilter.Builder()
                .setComponents(PowerComponent.AUDIO).build();
        CarPowerPolicyFilter filterWifi = new CarPowerPolicyFilter.Builder()
                .setComponents(PowerComponent.WIFI).build();
        CarPowerPolicyFilter filterLocation = new CarPowerPolicyFilter.Builder()
                .setComponents(PowerComponent.LOCATION).build();
        String policyId = ""audio_on_wifi_off"";

        definePowerPolicy(policyId, ""AUDIO"", ""WIFI"");
        mCarPowerManager.addPowerPolicyListener(mExecutor, filterAudio, listenerAudioOne);
        mCarPowerManager.addPowerPolicyListener(mExecutor, filterAudio, listenerAudioTwo);
        mCarPowerManager.addPowerPolicyListener(mExecutor, filterWifi, listenerWifi);
        mCarPowerManager.addPowerPolicyListener(mExecutor, filterLocation, listenerLocation);
        mCarPowerManager.removePowerPolicyListener(listenerAudioTwo);
        applyPowerPolicy(policyId);

        CarPowerPolicy policy = mCarPowerManager.getCurrentPowerPolicy();
        assertWithMessage(""Current power policy"").that(policy).isNotNull();
        assertWithMessage(""Current power policy ID"").that(policy.getPolicyId()).isEqualTo(policyId);
        assertWithMessage(""Added audio listener's current policy ID"")
                .that(listenerAudioOne.getCurrentPolicyId(LISTENER_WAIT_TIME_MS))
                .isEqualTo(policyId);
        makeSureExecutorReady();
        assertWithMessage(""Removed audio listener's current policy"")
                .that(listenerAudioTwo.getCurrentPolicyId(NO_WAIT)).isNull()"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/car/src/android/car/cts/CarPowerManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.car.cts.permissioncarenergy.PermissionCarEnergyTest"	"isNotNull"	""	"1: permission"	"([4:/android/car/cts/permissioncarenergy/PermissionCarEnergyTest.java]:[permission]:[4]:method_text:[              Car.PROPERTY_SERVICE);        assertThat(mCarPropertyManager).isNotNull();    }   ]) :|: /*
 *.
 */

package android.car.cts.permissioncarenergy;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import android.car.Car;
import android.car.VehiclePropertyIds;
import android.car.hardware.CarPropertyConfig;
import android.car.hardware.property.CarPropertyManager;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.RequiresDevice;

import androidx.test.platform.app.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.google.common.collect.ImmutableList;

import org.junit.Test;
import org.junit.Before;
import org.junit.runner.RunWith;

@RequiresDevice
@RunWith(AndroidJUnit4.class)
@AppModeFull(reason = ""Instant apps cannot get car related permissions."")
public final class PermissionCarEnergyTest {
    private static final ImmutableList<Integer> PERMISSION_CAR_ENERGY_PROPERTIES =
            ImmutableList.<Integer>builder().add(
                    VehiclePropertyIds.FUEL_LEVEL, VehiclePropertyIds.EV_BATTERY_LEVEL,
                    VehiclePropertyIds.EV_BATTERY_INSTANTANEOUS_CHARGE_RATE,
                    VehiclePropertyIds.RANGE_REMAINING, VehiclePropertyIds.FUEL_LEVEL_LOW)
                    .build();

    private CarPropertyManager mCarPropertyManager;

    @Before
    public void setUp() {
        mCarPropertyManager =
                (CarPropertyManager) Car.createCar(
                        InstrumentationRegistry.getInstrumentation().getContext()).getCarManager(
                        Car.PROPERTY_SERVICE);
        assertThat(mCarPropertyManager).isNotNull();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/car/PermissionCarEnergy/src/android/car/cts/permissioncarenergy/PermissionCarEnergyTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.car.cts.permissioncarenergy.PermissionCarEnergyTest"	"testPermissionCarEnergyGranted"	""	"1: permission"	"([2:/android/car/cts/permissioncarenergy/PermissionCarEnergyTest.java]:[permission]:[2]:method_text:[         carPropertyConfig.getPropertyId()).isIn(PERMISSION_CAR_ENERGY_PROPERTIES);        }    }]) :|: 
    public void testPermissionCarEnergyGranted() {
        for (CarPropertyConfig<?> carPropertyConfig : mCarPropertyManager.getPropertyList()) {
            assertWithMessage(""%s"",
                    VehiclePropertyIds.toString(carPropertyConfig.getPropertyId())).that(
                    carPropertyConfig.getPropertyId()).isIn(PERMISSION_CAR_ENERGY_PROPERTIES);
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/car/PermissionCarEnergy/src/android/car/cts/permissioncarenergy/PermissionCarEnergyTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.car.cts.permissioncarinfo.PermissionCarInfoTest"	"isNotNull"	""	"1: permission"	"([4:/android/car/cts/permissioncarinfo/PermissionCarInfoTest.java]:[permission]:[4]:method_text:[              Car.PROPERTY_SERVICE);        assertThat(mCarPropertyManager).isNotNull();    }   ]) :|: /*
 *.
 */

package android.car.cts.permissioncarinfo;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import android.car.Car;
import android.car.VehiclePropertyIds;
import android.car.hardware.CarPropertyConfig;
import android.car.hardware.property.CarPropertyManager;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.RequiresDevice;

import androidx.test.platform.app.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.google.common.collect.ImmutableList;

import org.junit.Test;
import org.junit.Before;
import org.junit.runner.RunWith;

@RequiresDevice
@RunWith(AndroidJUnit4.class)
@AppModeFull(reason = ""Instant apps cannot get car related permissions."")
public final class PermissionCarInfoTest {
    private static final ImmutableList<Integer> PERMISSION_CAR_INFO_PROPERTIES =
            ImmutableList.<Integer>builder().add(
                    VehiclePropertyIds.INFO_MAKE, VehiclePropertyIds.INFO_MODEL,
                    VehiclePropertyIds.INFO_MODEL_YEAR, VehiclePropertyIds.INFO_FUEL_CAPACITY,
                    VehiclePropertyIds.INFO_FUEL_TYPE, VehiclePropertyIds.INFO_EV_BATTERY_CAPACITY,
                    VehiclePropertyIds.INFO_EV_CONNECTOR_TYPE,
                    VehiclePropertyIds.INFO_FUEL_DOOR_LOCATION,
                    VehiclePropertyIds.INFO_MULTI_EV_PORT_LOCATIONS,
                    VehiclePropertyIds.INFO_EV_PORT_LOCATION, VehiclePropertyIds.INFO_DRIVER_SEAT,
                    VehiclePropertyIds.INFO_EXTERIOR_DIMENSIONS,
                    VehiclePropertyIds.ELECTRONIC_TOLL_COLLECTION_CARD_TYPE,
                    VehiclePropertyIds.ELECTRONIC_TOLL_COLLECTION_CARD_STATUS)
                    .build();

    private CarPropertyManager mCarPropertyManager;

    @Before
    public void setUp() {
        mCarPropertyManager =
                (CarPropertyManager) Car.createCar("	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/car/PermissionCarInfo/src/android/car/cts/permissioncarinfo/PermissionCarInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.car.cts.permissioncarinfo.PermissionCarInfoTest"	"testPermissionCarInfoGranted"	""	"1: permission"	"([2:/android/car/cts/permissioncarinfo/PermissionCarInfoTest.java]:[permission]:[2]:method_text:[          carPropertyConfig.getPropertyId()).isIn(PERMISSION_CAR_INFO_PROPERTIES);        }    }}]) :|: 
    public void testPermissionCarInfoGranted() {
        for (CarPropertyConfig<?> carPropertyConfig : mCarPropertyManager.getPropertyList()) {
            assertWithMessage(""%s"",
                    VehiclePropertyIds.toString(carPropertyConfig.getPropertyId())).that(
                    carPropertyConfig.getPropertyId()).isIn(PERMISSION_CAR_INFO_PROPERTIES);
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/car/PermissionCarInfo/src/android/car/cts/permissioncarinfo/PermissionCarInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.security.cts.CVE_2020_0294"	"testPocCVE_2020_0294"	"CtsSecurityTestCases"	"1: permission"	"([2:/android/security/cts/CVE_2020_0294.java]:[permission]:[2]:method_text:[mutable            fail(""PendingIntent from WallpaperManagerService is mutable"");        }    }}]) :|: 
    @AsbSecurityTest(cveBugId = 154915372)
    public void testPocCVE_2020_0294() throws Exception {
        Instrumentation instrumentation = InstrumentationRegistry.getInstrumentation();
        ActivityManager activityManager = (ActivityManager) instrumentation.getContext()
                .getSystemService(Context.ACTIVITY_SERVICE);
        Context targetContext = instrumentation.getTargetContext();
        ComponentName componentName =
                ComponentName.unflattenFromString(""com.android.systemui/.ImageWallpaper"");
        PendingIntent pi = activityManager.getRunningServiceControlPanel(componentName);
        assumeNotNull(pi);

        Intent spuriousIntent = new Intent();
        spuriousIntent.setPackage(targetContext.getPackageName());
        spuriousIntent.setDataAndType(
                Uri.parse(""content://com.android.settings.files/my_cache/NOTICE.html""), ""txt/html"");
        spuriousIntent.setFlags(
                Intent.FLAG_GRANT_WRITE_URI_PERMISSION | Intent.FLAG_GRANT_READ_URI_PERMISSION);
        try {
            pi.send(targetContext, 0, spuriousIntent, null, null);
        } catch (PendingIntent.CanceledException e) {
            //This means PendingIntent has failed as its mutable
            fail(""PendingIntent from WallpaperManagerService is mutable"");
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/security/src/android/security/cts/CVE_2020_0294.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.security.cts.CVE_2021_0309"	"testPocCVE_2021_0309"	"CtsSecurityTestCases"	"1: permission"	"([6:/android/security/cts/CVE_2021_0309.java]:[permission]:[6]:method_text:[ad.sleep(5000);        } catch (Exception e) {        }        assertFalse(isVulnerable);    }}]) :|: 
    @AsbSecurityTest(cveBugId = 158480899)
    public void testPocCVE_2021_0309() {
        /**
         * Output of adb shell pm list packages --user 0 -U com.android.providers.media
         * package:com.android.providers.media uid:10008
         */
        final int REQUESTED_UID = 10008;
        Intent intent = new Intent();
        intent.setClassName(""android"",
                            ""android.accounts.GrantCredentialsPermissionActivity"");
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_ACCOUNT,
                        new Account(""abc@xyz.org"", ""com.my.auth""));
        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_AUTH_TOKEN_TYPE,
                        AccountManager.ACCOUNT_ACCESS_TOKEN_TYPE);
        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_RESPONSE,
            new AccountAuthenticatorResponse(new IAccountAuthenticatorResponse.Stub() {
                @Override
                public void onResult(Bundle value) throws RemoteException {
                }

                @Override
                public void onRequestContinued() {
                }

                @Override
                public void onError(int errorCode, String errorMessage) throws RemoteException {
                    /**
                     * GrantCredentialsPermissionActivity's onCreate() should not execute and
                     * should return error when the requested UID does not match the process's UID
                     */
                    isVulnerable = false;
                }
            }));

        intent.putExtra(GrantCredentialsPermissionActivity.EXTRAS_REQUESTING_UID,
                        REQUESTED_UID);
        mContext.startActivity(intent);
        /**
         * Sleep for 5 seconds to ensure that the AccountAuthenticatorResponse callback gets
         * triggered if vulnerability is fixed.
         */
        try {
            Thread.sleep(5000);"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/security/src/android/security/cts/CVE_2021_0309.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.security.cts.SQLiteTest"	"test_android_cve_2019_2195"	"CtsSecurityTestCases"	"1: permission"	"([5:/android/security/cts/SQLiteTest.java]:[permission]:[5]:method_text:[g        }    }    /**     * b/153352319     */    @AsbSecurityTest(cveBugId = 153352319)   ]) :|: public void test_android_cve_2019_2195() {
        Uri uri = VoicemailContract.Voicemails.CONTENT_URI;
        uri = uri.buildUpon().appendQueryParameter(""source_package"", mPackageName).build();

        try {
            mContext.grantUriPermission(mPackageName, uri,
                    Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION
                            | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION);
        } catch (Exception e) {
            if (e instanceof java.lang.SecurityException) {
                // this suggests com.android.providers.contacts.VoicemailContentProvider
                // does not allow granting of Uri permissions, hence return.
                return;
            }
        }

        try {
            String fileToDump = mContext.createPackageContext(""com.android.providers.contacts"", 0)
                    .getDatabasePath(""contacts2.db"").getAbsolutePath();
            try {
                mResolver.query(uri, null, null, null,
                   ""_id ASC LIMIT _TOKENIZE('calls(_data,_data,_data,source_package,type) VALUES(''""
                                + fileToDump + ""'',?,?,''"" + mPackageName + ""'',4);',0,'','Z')"")
                        .close();
                fail(""Vulnerable function exists"");
            } catch (android.database.sqlite.SQLiteException e) {
                    // do nothing
            }
        } catch (NameNotFoundException n) {
            // do nothing
        }
    }

    /**
     * b/153352319
     */
    @AsbSecurityTest(cveBugId = 153352319)"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/security/src/android/security/cts/SQLiteTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.security.cts.ServicePermissionsTest"	"testDumpProtected"	"CtsSecurityTestCases"	"1: permission"	"([7:/android/security/cts/ServicePermissionsTest.java]:[permission]:[7]:method_text:[ msg.append(failure).append('\n');            }            fail(msg.toString());        }    }}]) :|: public void testDumpProtected() throws Exception {

        String[] services = null;
        try {
            services = (String[]) Class.forName(""android.os.ServiceManager"")
                    .getDeclaredMethod(""listServices"").invoke(null);
        } catch (ClassCastException e) {
        } catch (ClassNotFoundException e) {
        } catch (NoSuchMethodException e) {
        } catch (InvocationTargetException e) {
        } catch (IllegalAccessException e) {
        }

        if ((services == null) || (services.length == 0)) {
            Log.w(TAG, ""No registered services, that's odd"");
            return;
        }

        final ArrayList<String> failures = new ArrayList<>();

        for (String service : services) {
            mTempFile.delete();

            IBinder serviceBinder = null;
            try {
                serviceBinder = (IBinder) Class.forName(""android.os.ServiceManager"")
                        .getDeclaredMethod(""getService"", String.class).invoke(null, service);
            } catch (ClassCastException e) {
            } catch (ClassNotFoundException e) {
            } catch (NoSuchMethodException e) {
            } catch (InvocationTargetException e) {
            } catch (IllegalAccessException e) {
            }

            if (serviceBinder == null) {
                Log.w(TAG, ""Missing service "" + service);
                continue;
            }

            Log.d(TAG, ""Dumping service "" + service);
            final FileOutputStream out = new FileOutputStream(mTempFile);
            try {
                serviceBinder.dump(out.getFD(), new String[0]);
            } catch (SecurityException e) {
                String msg = e.getMessage();
                if ((msg == null) || msg.contains(""android.permission.DUMP"")) {
                    Log.d(TAG, ""Service "" + service + "" correctly checked permission"");
                    // Service correctly checked for DUMP permission, yay
                } else {
                    // Ser"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/security/src/android/security/cts/ServicePermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.security.cts.STKFrameworkTest"	"testInterceptedSIMCommandsToTelephony"	"CtsSecurityTestCases"	"1: permission"	"([2:/android/security/cts/STKFrameworkTest.java]:[permission]:[2]:method_text:[as it is protected by permission in             * patched devices             */        }    }}]) :|: public void testInterceptedSIMCommandsToTelephony() {
        if (!mHasTelephony) {
            return;
        }

        Intent intent = new Intent();
        intent.setAction(""com.android.internal.stk.command"");
        intent.putExtra(""STK CMD"", ""test"");
        ComponentName cn =
                ComponentName.unflattenFromString(""com.android.stk/com.android.stk.StkCmdReceiver"");
        intent.setComponent(cn);
        try {
            mContext.sendBroadcast(intent);
            fail(""Able to send broadcast which can be received by any app which has registered "" +
                    ""broadcast for action 'com.android.internal.stk.command' since it is not "" +
                    ""protected with any permission. Device is vulnerable to CVE-2015-3843."");
        } catch (SecurityException e) {
            /* Pass the Test case: App should not be able to send broadcast using action
             * 'com.android.internal.stk.command' as it is protected by permission in
             * patched devices
             */
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/security/src/android/security/cts/STKFrameworkTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.security.cts.FileIntegrityManagerTest"	"testSupportedOnDevicesFirstLaunchedWithR"	"CtsSecurityTestCases"	"1: 9.1"	"([1:/android/security/cts/FileIntegrityManagerTest.java]:[9.1]:[1]:method_text:[tyManager.isApkVeritySupported());        }    }    @CddTest(requirement=""9.10/C-0-3,C-1-1"")   ]) :|: 
    public void testSupportedOnDevicesFirstLaunchedWithR() throws Exception {
        if (PropertyUtil.getFirstApiLevel() >= MIN_REQUIRED_API_LEVEL) {
            assertTrue(mFileIntegrityManager.isApkVeritySupported());
        }
    }

    @CddTest(requirement=""9.10/C-0-3,C-1-1"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/security/src/android/security/cts/FileIntegrityManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.security.cts.FileIntegrityManagerTest"	"testCtsReleaseCertificateTrusted"	"CtsSecurityTestCases"	"1: 9.1"	"([1:/android/security/cts/FileIntegrityManagerTest.java]:[9.1]:[1]:method_text:[Trusted);        }    }    @CddTest(requirement=""9.10/C-0-3,C-1-1"")    @RestrictedBuildTest   ]) :|: 
    public void testCtsReleaseCertificateTrusted() throws Exception {
        boolean isReleaseCertTrusted = mFileIntegrityManager.isAppSourceCertificateTrusted(
                readAssetAsX509Certificate(""fsverity-release.x509.der""));
        if (mFileIntegrityManager.isApkVeritySupported()) {
            assertTrue(isReleaseCertTrusted);
        } else {
            assertFalse(isReleaseCertTrusted);
        }
    }

    @CddTest(requirement=""9.10/C-0-3,C-1-1"")
    @RestrictedBuildTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/security/src/android/security/cts/FileIntegrityManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephonyprovider.cts.ServiceStateTest"	"testGetDataRegState_changeObserved"	"CtsTelephonyProviderTestCases"	"1: permission"	"([1:/android/telephonyprovider/cts/ServiceStateTest.java]:[permission]:[1]:method_text:[out permissions, those fields are not     * available to apps with targetSdkVersion S+.     */   ]) :|: 
    public void testGetDataRegState_changeObserved() throws Exception {
        ServiceState oldSS = new ServiceState();
        oldSS.setStateOutOfService();

        ServiceState newSS = new ServiceState();
        newSS.setStateOutOfService();
        newSS.setStateOff();

        verifyNotificationObservedWhenFieldChanged(
                DATA_REG_STATE, oldSS, newSS, true /*expectChange*/);
    }

    /**
     * Verifies that when query location protected fields without permissions, those fields are not
     * available to apps with targetSdkVersion S+.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephonyprovider/src/android/telephonyprovider/cts/ServiceStateTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephonyprovider.cts.ServiceStateTest"	"testLocationProtectedFields_noPermission"	"CtsTelephonyProviderTestCases"	"1: permission"	"([3:/android/telephonyprovider/cts/ServiceStateTest.java]:[permission]:[3]:method_text:[ption exception) {            assertThat(exception).isInstanceOf(exceptionClass);        }    }}]) :|: 
    public void testLocationProtectedFields_noPermission() {
        try (Cursor cursor = mContentResolver.query(Telephony.ServiceStateTable.CONTENT_URI,
                null, null, null)) {
            assertThat(cursor.getCount()).isEqualTo(1);
            cursor.moveToNext();

            assertThat(cursor.getColumnIndex(""network_id"")).isEqualTo(-1);
            assertThat(cursor.getColumnIndex(""system_id"")).isEqualTo(-1);

            assertThrows(IllegalArgumentException.class,
                    () -> mContentResolver.query(Telephony.ServiceStateTable.CONTENT_URI,
                            new String[]{""network_id""}, null, null));
            assertThrows(IllegalArgumentException.class,
                    () -> mContentResolver.query(Telephony.ServiceStateTable.CONTENT_URI,
                            new String[]{""system_id""}, null, null));
        }
    }

    /**
     * Insert new ServiceState over the old ServiceState and expect the observer receiving the
     * notification over the observed field change.
     */
    private void verifyNotificationObservedWhenFieldChanged(String field, ServiceState oldSS,
            ServiceState newSS, boolean expectChange) throws Exception {
        final Uri uriForSubAndField =
                Telephony.ServiceStateTable.getUriForSubscriptionIdAndField(mSubId, field);
        insertServiceState(oldSS);

        RecordingContentObserver observer = new RecordingContentObserver();
        mContentResolver.registerContentObserver(uriForSubAndField, false, observer);
        assertWithMessage(""Observer is NOT empty in the beginning."").that(
                observer.mObserved).isEmpty();

        insertServiceState(newSS);

        if (expectChange) {
            // Only verify we did receive the notification for the expected field, instead of the
            // number of notifications we received to remove flakiness for different cases.
            PollingCheck.check(
                    ""Expect notification when "" + f"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephonyprovider/src/android/telephonyprovider/cts/ServiceStateTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephonyprovider.cts.CellBroadcastProviderTest"	"testAccessMessageHistoryWithoutPermission"	"CtsTelephonyProviderTestCases"	"1: permission"	"([1:/android/telephonyprovider/cts/CellBroadcastProviderTest.java]:[permission]:[1]:method_text:[ception thrown"");        } catch (SecurityException e) {            // expected        }    }}]) :|: public void testAccessMessageHistoryWithoutPermission() {
        if (!mHasTelephony) {
            return;
        }
        try {
            mContentResolver.query(Telephony.CellBroadcasts.MESSAGE_HISTORY_URI,
                    null, null, null, null);
            fail(""No SecurityException thrown"");
        } catch (SecurityException e) {
            // expected
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephonyprovider/src/android/telephonyprovider/cts/CellBroadcastProviderTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.drm.cts.DrmEventTest"	"testGetAttribute"	"CtsDrmTestCases"	"1: INTERNET"	"([2:/android/drm/cts/DrmEventTest.java]:[INTERNET]:[2]:method_text:[h(IllegalArgumentException iae) {            // intentionally ignored        }        */    }}]) :|: public void test/*
 *.
 */

package android.drm.cts;

import java.util.HashMap;
import android.util.Log;
import android.test.AndroidTestCase;
import android.drm.DrmEvent;
import android.drm.DrmInfoEvent;
import android.drm.DrmErrorEvent;

public class DrmEventTest extends AndroidTestCase {
    private static String TAG = ""CtsDrmEventTest"";

    public static void testGetAttribute() throws Exception {
        HashMap<String, Object> attributes = new HashMap<String, Object>(3);
        attributes.put(""Hello World"", attributes);
        attributes.put(""Hello"", ""World"");
        attributes.put(""World"", """");

        // DrmInfoEvent related
        checkGetAttributeWithEventType(null, ""NotNull"", true);
        checkGetAttributeWithEventType(null, null, true);
        checkGetAttributeWithEventType(attributes, null, true);
        checkGetAttributeWithEventType(attributes, """", true);
        checkGetAttributeWithEventType(attributes, ""Hello"", true);
        checkGetAttributeWithEventType(attributes, ""World"", true);
        checkGetAttributeWithEventType(attributes, ""Hello World"", true);

        // DrmErrorEvent related
        checkGetAttributeWithEventType(null, ""NotNull"", false);
        checkGetAttributeWithEventType(null, null, false);
        checkGetAttributeWithEventType(attributes, null, false);
        checkGetAttributeWithEventType(attributes, """", false);
        checkGetAttributeWithEventType(attributes, ""Hello"", false);
        checkGetAttributeWithEventType(attributes, ""World"", false);
        checkGetAttributeWithEventType(attributes, ""Hello World"", false);
    }

    public static void testGetMessage() throws Exception {
        // DrmInfoEvent related
        checkGetMessageWithEventType(null, true);
        checkGetMessageWithEventType("""", true);
        checkGetMessageWithEventType(""Hello World"", true);

        // DrmErrorEvent related
        checkGetMessageWithEventType(null, false);
        checkGetMessageWithEventType("""", false);
        checkGetMe"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/drm/src/android/drm/cts/DrmEventTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.notification.legacy30.cts.StatusBarManagerApi30Test"	"testCollapsePanels_withoutStatusBarPermission_doesNotThrow"	"CtsLegacyNotification30TestCases"	"1: permission"	"([1:/android/app/notification/legacy30/cts/StatusBarManagerApi30Test.java]:[permission]:[1]:method_text:[xception {        mStatusBarManager.collapsePanels();        // Nothing thrown, passed    }   ]) :|: 
    public void testCollapsePanels_withoutStatusBarPermission_doesNotThrow() throws Exception {
        mStatusBarManager.collapsePanels();

        // Nothing thrown, passed
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/notificationlegacy/notificationlegacy30/src/android/app/notification/legacy30/cts/StatusBarManagerApi30Test.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.notification.legacy30.cts.StatusBarManagerApi30Test"	"testTogglePanel_withoutStatusBarPermission_doesNotThrow"	"CtsLegacyNotification30TestCases"	"1: permission"	"([1:/android/app/notification/legacy30/cts/StatusBarManagerApi30Test.java]:[permission]:[1]:method_text:[s Exception {        mStatusBarManager.togglePanel();        // Nothing thrown, passed    }   ]) :|: 
    public void testTogglePanel_withoutStatusBarPermission_doesNotThrow() throws Exception {
        mStatusBarManager.togglePanel();

        // Nothing thrown, passed
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/notificationlegacy/notificationlegacy30/src/android/app/notification/legacy30/cts/StatusBarManagerApi30Test.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.notification.legacy30.cts.StatusBarManagerApi30Test"	"testHandleSystemKey_withoutStatusBarPermission_doesNotThrow"	"CtsLegacyNotification30TestCases"	"1: permission"	"([1:/android/app/notification/legacy30/cts/StatusBarManagerApi30Test.java]:[permission]:[1]:method_text:[r.handleSystemKey(KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP);        // Nothing thrown, passed    }}]) :|: 
    public void testHandleSystemKey_withoutStatusBarPermission_doesNotThrow() throws Exception {
        mStatusBarManager.handleSystemKey(KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP);

        // Nothing thrown, passed
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/notificationlegacy/notificationlegacy30/src/android/app/notification/legacy30/cts/StatusBarManagerApi30Test.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.notification.legacy29.cts.NotificationManager29Test"	"testPostFullScreenIntent_noPermission"	"CtsLegacyNotification29TestCases"	"1: permission"	"([2:/android/app/notification/legacy29/cts/NotificationManager29Test.java]:[permission]:[2]:method_text:[(id);        assertNotNull(n);        assertNull(n.getNotification().fullScreenIntent);    }   ]) :|: 
    public void testPostFullScreenIntent_noPermission() {
        // no permission? no full screen intent
        int id = 6000;
        final Notification notification =
                new Notification.Builder(mContext, NOTIFICATION_CHANNEL_ID)
                        .setSmallIcon(android.R.id.icon)
                        .setWhen(System.currentTimeMillis())
                        .setFullScreenIntent(getPendingIntent(), true)
                        .setContentText(""This is #FSI notification"")
                        .setContentIntent(getPendingIntent())
                        .build();
        mNotificationManager.notify(id, notification);

        StatusBarNotification n = findPostedNotification(id);
        assertNotNull(n);
        assertNull(n.getNotification().fullScreenIntent);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/notificationlegacy/notificationlegacy29/src/android/app/notification/legacy29/cts/NotificationManager29Test.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.notification.legacy29.cts.NotificationAssistantServiceTest"	"isWatch"	"CtsLegacyNotification29TestCases"	"1: permission"	"([1:/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java]:[permission]:[1]:method_text:[(false);        toggleAssistantAccess(false);        mUi.dropShellPermissionIdentity();    }   ]) :|: /*
 *.
 */

package android.app.notification.legacy29.cts;

import static android.service.notification.NotificationAssistantService.FEEDBACK_RATING;

import static junit.framework.Assert.assertEquals;
import static junit.framework.Assert.assertTrue;
import static junit.framework.TestCase.assertFalse;
import static junit.framework.TestCase.assertNotNull;

import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeFalse;

import android.app.Instrumentation;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.Person;
import android.app.StatusBarManager;
import android.app.UiAutomation;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.Bundle;
import android.os.ParcelFileDescriptor;
import android.os.SystemClock;
import android.provider.Telephony;
import android.service.notification.Adjustment;
import android.service.notification.NotificationAssistantService;
import android.service.notification.NotificationListenerService;
import android.service.notification.StatusBarNotification;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import junit.framework.Assert;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;

@RunWith(AndroidJUnit4.class)
public class NotificationAssistantServiceTest {

    final String TAG = ""NotAsstServiceTest"";
    final String NOTIFICATION_CHANNEL_ID = ""NotificationAssistantServiceTest"";
    final int ICON_ID = android.R.drawable.sym_def_app_icon;
    final long SLEEP_TIME = 1000; // milliseconds"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/notificationlegacy/notificationlegacy29/src/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.notification.legacy29.cts.NotificationAssistantServiceTest"	"testOnNotificationEnqueued"	"CtsLegacyNotification29TestCases"	"1: permission"	"([3:/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java]:[permission]:[3]:method_text:[ListenerService.Ranking.USER_SENTIMENT_POSITIVE,                out.getUserSentiment());    }   ]) :|: 
    public void testOnNotificationEnqueued() throws Exception {
        toggleListenerAccess(true);
        Thread.sleep(SLEEP_TIME);

        mUi.adoptShellPermissionIdentity(""android.permission.STATUS_BAR_SERVICE"");
        mNotificationManager.allowAssistantAdjustment(Adjustment.KEY_USER_SENTIMENT);
        mUi.dropShellPermissionIdentity();

        mNotificationListenerService = TestNotificationListener.getInstance();

        sendNotification(1, ICON_ID);
        StatusBarNotification sbn = getFirstNotificationFromPackage(TestNotificationListener.PKG);
        NotificationListenerService.Ranking out = new NotificationListenerService.Ranking();
        mNotificationListenerService.mRankingMap.getRanking(sbn.getKey(), out);

        // No modification because the Notification Assistant is not enabled
        assertEquals(NotificationListenerService.Ranking.USER_SENTIMENT_NEUTRAL,
                out.getUserSentiment());
        mNotificationListenerService.resetData();

        toggleAssistantAccess(true);
        Thread.sleep(SLEEP_TIME); // wait for listener and assistant to be allowed
        mNotificationAssistantService = TestNotificationAssistant.getInstance();

        sendNotification(1, ICON_ID);
        sbn = getFirstNotificationFromPackage(TestNotificationListener.PKG);
        mNotificationListenerService.mRankingMap.getRanking(sbn.getKey(), out);

        // Assistant gets correct rank
        assertTrue(mNotificationAssistantService.notificationRank >= 0);
        // Assistant modifies notification
        assertEquals(NotificationListenerService.Ranking.USER_SENTIMENT_POSITIVE,
                out.getUserSentiment());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/notificationlegacy/notificationlegacy29/src/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.notification.legacy29.cts.NotificationAssistantServiceTest"	"testAdjustNotification_userSentimentKey"	"CtsLegacyNotification29TestCases"	"1: permission"	"([3:/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java]:[permission]:[3]:method_text:[ListenerService.Ranking.USER_SENTIMENT_NEGATIVE,                out.getUserSentiment());    }   ]) :|: 
    public void testAdjustNotification_userSentimentKey() throws Exception {
        setUpListeners();

        mUi.adoptShellPermissionIdentity(""android.permission.STATUS_BAR_SERVICE"");
        mNotificationManager.allowAssistantAdjustment(Adjustment.KEY_USER_SENTIMENT);
        mUi.dropShellPermissionIdentity();

        sendNotification(1, ICON_ID);
        StatusBarNotification sbn = getFirstNotificationFromPackage(TestNotificationListener.PKG);
        NotificationListenerService.Ranking out = new NotificationListenerService.Ranking();
        mNotificationListenerService.mRankingMap.getRanking(sbn.getKey(), out);

        assertEquals(NotificationListenerService.Ranking.USER_SENTIMENT_POSITIVE,
                out.getUserSentiment());

        Bundle signals = new Bundle();
        signals.putInt(Adjustment.KEY_USER_SENTIMENT,
                NotificationListenerService.Ranking.USER_SENTIMENT_NEGATIVE);
        Adjustment adjustment = new Adjustment(sbn.getPackageName(), sbn.getKey(), signals, """",
                sbn.getUser());

        mNotificationAssistantService.adjustNotification(adjustment);
        Thread.sleep(SLEEP_TIME); // wait for adjustment to be processed

        mNotificationListenerService.mRankingMap.getRanking(sbn.getKey(), out);

        assertEquals(NotificationListenerService.Ranking.USER_SENTIMENT_NEGATIVE,
                out.getUserSentiment());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/notificationlegacy/notificationlegacy29/src/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.notification.legacy29.cts.NotificationAssistantServiceTest"	"testAdjustNotification_importanceKey"	"CtsLegacyNotification29TestCases"	"1: permission"	"([3:/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java]:[permission]:[3]:method_text:[getRanking(sbn.getKey(), out);        assertEquals(newImportance, out.getImportance());    }   ]) :|: 
    public void testAdjustNotification_importanceKey() throws Exception {
        setUpListeners();

        mUi.adoptShellPermissionIdentity(""android.permission.STATUS_BAR_SERVICE"");
        mNotificationManager.allowAssistantAdjustment(Adjustment.KEY_IMPORTANCE);
        mUi.dropShellPermissionIdentity();

        sendNotification(1, ICON_ID);
        StatusBarNotification sbn = getFirstNotificationFromPackage(TestNotificationListener.PKG);
        NotificationListenerService.Ranking out = new NotificationListenerService.Ranking();
        mNotificationListenerService.mRankingMap.getRanking(sbn.getKey(), out);

        int currentImportance = out.getImportance();
        int newImportance = currentImportance == NotificationManager.IMPORTANCE_DEFAULT
                ? NotificationManager.IMPORTANCE_HIGH : NotificationManager.IMPORTANCE_DEFAULT;

        Bundle signals = new Bundle();
        signals.putInt(Adjustment.KEY_IMPORTANCE, newImportance);
        Adjustment adjustment = new Adjustment(sbn.getPackageName(), sbn.getKey(), signals, """",
                sbn.getUser());

        mNotificationAssistantService.adjustNotification(adjustment);
        Thread.sleep(SLEEP_TIME); // wait for adjustment to be processed

        mNotificationListenerService.mRankingMap.getRanking(sbn.getKey(), out);

        assertEquals(newImportance, out.getImportance());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/notificationlegacy/notificationlegacy29/src/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.notification.legacy29.cts.NotificationAssistantServiceTest"	"testAdjustNotifications_rankingScoreKey"	"CtsLegacyNotification29TestCases"	"1: permission"	"([6:/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java]:[permission]:[6]:method_text:[t(Adjustment.KEY_RANKING_SCORE);            mUi.dropShellPermissionIdentity();        }    }   ]) :|: 
    public void testAdjustNotifications_rankingScoreKey() throws Exception {
        setUpListeners();

        try {
            mUi.adoptShellPermissionIdentity(""android.permission.STATUS_BAR_SERVICE"");
            mNotificationManager.allowAssistantAdjustment(Adjustment.KEY_RANKING_SCORE);
            mUi.dropShellPermissionIdentity();

            sendNotification(1, ICON_ID);
            StatusBarNotification sbn1 = getFirstNotificationFromPackage(
                    TestNotificationListener.PKG);
            NotificationListenerService.Ranking out1 = new NotificationListenerService.Ranking();

            sendNotification(2, ICON_ID);
            StatusBarNotification sbn2 = getFirstNotificationFromPackage(
                    TestNotificationListener.PKG);
            NotificationListenerService.Ranking out2 = new NotificationListenerService.Ranking();

            mNotificationListenerService.mRankingMap.getRanking(sbn1.getKey(), out1);
            mNotificationListenerService.mRankingMap.getRanking(sbn2.getKey(), out2);

            int currentRank1 = out1.getRank();
            int currentRank2 = out2.getRank();

            float rankingScore1 = (currentRank1 > currentRank2) ? 1f : 0;
            float rankingScore2 = (currentRank1 > currentRank2) ? 0 : 1f;

            Bundle signals = new Bundle();
            signals.putFloat(Adjustment.KEY_RANKING_SCORE, rankingScore1);
            Adjustment adjustment = new Adjustment(sbn1.getPackageName(), sbn1.getKey(), signals, """",
                    sbn1.getUser());
            Bundle signals2 = new Bundle();
            signals2.putFloat(Adjustment.KEY_RANKING_SCORE, rankingScore2);
            Adjustment adjustment2 = new Adjustment(sbn2.getPackageName(), sbn2.getKey(), signals2, """",
                    sbn2.getUser());
            mNotificationAssistantService.adjustNotifications(List.of(adjustment, adjustment2));
            Thread.sleep(SLEEP_TIME); // wait for adjustments to be processed

            mN"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/notificationlegacy/notificationlegacy29/src/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.notification.legacy29.cts.NotificationAssistantServiceTest"	"testAdjustNotification_smartActionKey"	"CtsLegacyNotification29TestCases"	"1: permission"	"([3:/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java]:[permission]:[3]:method_text:[und || action.actionIntent.equals(sendIntent);        }        assertTrue(actionFound);    }   ]) :|: 
    public void testAdjustNotification_smartActionKey() throws Exception {
        setUpListeners();

        mUi.adoptShellPermissionIdentity(""android.permission.STATUS_BAR_SERVICE"");
        mNotificationManager.allowAssistantAdjustment(Adjustment.KEY_CONTEXTUAL_ACTIONS);
        mUi.dropShellPermissionIdentity();

        PendingIntent sendIntent = PendingIntent.getActivity(mContext, 0,
                new Intent(Intent.ACTION_SEND), PendingIntent.FLAG_MUTABLE_UNAUDITED);
        Notification.Action sendAction = new Notification.Action.Builder(ICON_ID, ""SEND"",
                sendIntent).build();

        sendNotification(1, ICON_ID);
        StatusBarNotification sbn = getFirstNotificationFromPackage(TestNotificationListener.PKG);
        NotificationListenerService.Ranking out = new NotificationListenerService.Ranking();
        mNotificationListenerService.mRankingMap.getRanking(sbn.getKey(), out);

        List<Notification.Action> smartActions = out.getSmartActions();
        if (smartActions != null) {
            for (int i = 0; i < smartActions.size(); i++) {
                Notification.Action action = smartActions.get(i);
                assertNotEquals(sendIntent, action.actionIntent);
            }
        }

        ArrayList<Notification.Action> extraAction = new ArrayList<>();
        extraAction.add(sendAction);
        Bundle signals = new Bundle();
        signals.putParcelableArrayList(Adjustment.KEY_CONTEXTUAL_ACTIONS, extraAction);
        Adjustment adjustment = new Adjustment(sbn.getPackageName(), sbn.getKey(), signals, """",
                sbn.getUser());

        mNotificationAssistantService.adjustNotification(adjustment);
        Thread.sleep(SLEEP_TIME); //wait for adjustment to be processed

        mNotificationListenerService.mRankingMap.getRanking(sbn.getKey(), out);

        boolean actionFound = false;
        smartActions = out.getSmartActions();
        for (int i = 0; i < smartActions.size(); i++) {
            Notification.Ac"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/notificationlegacy/notificationlegacy29/src/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.notification.legacy29.cts.NotificationAssistantServiceTest"	"testAdjustNotification_smartReplyKey"	"CtsLegacyNotification29TestCases"	"1: permission"	"([3:/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java]:[permission]:[3]:method_text:[Found = replyFound || reply.equals(smartReply);        }        assertTrue(replyFound);    }   ]) :|: 
    public void testAdjustNotification_smartReplyKey() throws Exception {
        setUpListeners();
        CharSequence smartReply = ""Smart Reply!"";

        mUi.adoptShellPermissionIdentity(""android.permission.STATUS_BAR_SERVICE"");
        mNotificationManager.allowAssistantAdjustment(Adjustment.KEY_TEXT_REPLIES);
        mUi.dropShellPermissionIdentity();

        sendNotification(1, ICON_ID);
        StatusBarNotification sbn = getFirstNotificationFromPackage(TestNotificationListener.PKG);
        NotificationListenerService.Ranking out = new NotificationListenerService.Ranking();
        mNotificationListenerService.mRankingMap.getRanking(sbn.getKey(), out);

        List<CharSequence> smartReplies = out.getSmartReplies();
        if (smartReplies != null) {
            for (int i = 0; i < smartReplies.size(); i++) {
                CharSequence reply = smartReplies.get(i);
                assertNotEquals(smartReply, reply);
            }
        }

        ArrayList<CharSequence> extraReply = new ArrayList<>();
        extraReply.add(smartReply);
        Bundle signals = new Bundle();
        signals.putCharSequenceArrayList(Adjustment.KEY_TEXT_REPLIES, extraReply);
        Adjustment adjustment = new Adjustment(sbn.getPackageName(), sbn.getKey(), signals, """",
                sbn.getUser());

        mNotificationAssistantService.adjustNotification(adjustment);
        Thread.sleep(SLEEP_TIME); //wait for adjustment to be processed

        mNotificationListenerService.mRankingMap.getRanking(sbn.getKey(), out);

        boolean replyFound = false;
        smartReplies = out.getSmartReplies();
        for (int i = 0; i < smartReplies.size(); i++) {
            CharSequence reply = smartReplies.get(i);
            replyFound = replyFound || reply.equals(smartReply);
        }
        assertTrue(replyFound);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/notificationlegacy/notificationlegacy29/src/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.notification.legacy29.cts.NotificationAssistantServiceTest"	"testAdjustNotification_importanceKey_notAllowed"	"CtsLegacyNotification29TestCases"	"1: permission"	"([3:/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java]:[permission]:[3]:method_text:[nking(sbn.getKey(), out);        assertEquals(currentImportance, out.getImportance());    }   ]) :|: 
    public void testAdjustNotification_importanceKey_notAllowed() throws Exception {
        setUpListeners();

        mUi.adoptShellPermissionIdentity(""android.permission.STATUS_BAR_SERVICE"");
        mNotificationManager.disallowAssistantAdjustment(Adjustment.KEY_IMPORTANCE);
        mUi.dropShellPermissionIdentity();

        sendNotification(1, ICON_ID);
        StatusBarNotification sbn = getFirstNotificationFromPackage(
                TestNotificationListener.PKG);
        NotificationListenerService.Ranking out = new NotificationListenerService.Ranking();
        mNotificationListenerService.mRankingMap.getRanking(sbn.getKey(), out);

        int currentImportance = out.getImportance();
        int newImportance = currentImportance == NotificationManager.IMPORTANCE_DEFAULT
                ? NotificationManager.IMPORTANCE_HIGH : NotificationManager.IMPORTANCE_DEFAULT;

        Bundle signals = new Bundle();
        signals.putInt(Adjustment.KEY_IMPORTANCE, newImportance);
        Adjustment adjustment = new Adjustment(sbn.getPackageName(), sbn.getKey(), signals, """",
                sbn.getUser());

        mNotificationAssistantService.adjustNotification(adjustment);
        Thread.sleep(SLEEP_TIME); // wait for adjustment to be processed

        mNotificationListenerService.mRankingMap.getRanking(sbn.getKey(), out);

        assertEquals(currentImportance, out.getImportance());

    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/notificationlegacy/notificationlegacy29/src/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.notification.legacy29.cts.NotificationAssistantServiceTest"	"testAdjustNotification_rankingScoreKey_notAllowed"	"CtsLegacyNotification29TestCases"	"1: permission"	"([3:/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java]:[permission]:[3]:method_text:[ank1 > newRank2);        } else {            assertTrue(newRank1 < newRank2);        }    }   ]) :|: 
    public void testAdjustNotification_rankingScoreKey_notAllowed() throws Exception {
        setUpListeners();

        mUi.adoptShellPermissionIdentity(""android.permission.STATUS_BAR_SERVICE"");
        mNotificationManager.cancelAll();
        mNotificationManager.disallowAssistantAdjustment(Adjustment.KEY_RANKING_SCORE);
        mUi.dropShellPermissionIdentity();

        sendNotification(1, ICON_ID);
        StatusBarNotification sbn1 = getFirstNotificationFromPackage(TestNotificationListener.PKG);
        NotificationListenerService.Ranking out1 = new NotificationListenerService.Ranking();

        sendNotification(2, ICON_ID);
        StatusBarNotification sbn2 = getFirstNotificationFromPackage(TestNotificationListener.PKG);
        NotificationListenerService.Ranking out2 = new NotificationListenerService.Ranking();

        mNotificationListenerService.mRankingMap.getRanking(sbn1.getKey(), out1);
        mNotificationListenerService.mRankingMap.getRanking(sbn2.getKey(), out2);

        int currentRank1 = out1.getRank();
        int currentRank2 = out2.getRank();

        float rankingScore1 = (currentRank1 > currentRank2) ? 1f: 0;
        float rankingScore2 = (currentRank1 > currentRank2) ? 0: 1f;

        Bundle signals = new Bundle();
        signals.putFloat(Adjustment.KEY_RANKING_SCORE, rankingScore1);
        Adjustment adjustment = new Adjustment(sbn1.getPackageName(), sbn1.getKey(), signals, """",
                sbn1.getUser());
        mNotificationAssistantService.adjustNotification(adjustment);
        signals = new Bundle();
        signals.putFloat(Adjustment.KEY_RANKING_SCORE, rankingScore2);
        adjustment = new Adjustment(sbn2.getPackageName(), sbn2.getKey(), signals, """",
                sbn2.getUser());
        mNotificationAssistantService.adjustNotification(adjustment);
        Thread.sleep(SLEEP_TIME); // wait for adjustments to be processed

        mNotificationListenerService.mRankingMap.getRanking(sbn1.getKey(), out1);
        mN"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/notificationlegacy/notificationlegacy29/src/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.notification.legacy29.cts.NotificationAssistantServiceTest"	"testGetAllowedAssistantCapabilities_permission"	"CtsLegacyNotification29TestCases"	"1: permission"	"([1:/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java]:[permission]:[1]:method_text:[ call this method"");        } catch (SecurityException e) {            //pass        }    }   ]) :|: 
    public void testGetAllowedAssistantCapabilities_permission() throws Exception {
        toggleAssistantAccess(false);

        try {
            mNotificationManager.getAllowedAssistantAdjustments();
            fail("" Non assistants cannot call this method"");
        } catch (SecurityException e) {
            //pass
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/notificationlegacy/notificationlegacy29/src/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.notification.legacy29.cts.NotificationAssistantServiceTest"	"testGetAllowedAssistantCapabilities"	"CtsLegacyNotification29TestCases"	"1: permission"	"([3:/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java]:[permission]:[3]:method_text:[            Adjustment.KEY_SNOOZE_CRITERIA));        mUi.dropShellPermissionIdentity();    }   ]) :|: 
    public void testGetAllowedAssistantCapabilities() throws Exception {
        toggleAssistantAccess(true);
        Thread.sleep(SLEEP_TIME); // wait for assistant to be allowed
        mNotificationAssistantService = TestNotificationAssistant.getInstance();
        mNotificationAssistantService.onAllowedAdjustmentsChanged();
        assertNotNull(mNotificationAssistantService.currentCapabilities);

        mUi.adoptShellPermissionIdentity(""android.permission.STATUS_BAR_SERVICE"");
        mNotificationManager.allowAssistantAdjustment(Adjustment.KEY_SNOOZE_CRITERIA);

        Thread.sleep(SLEEP_TIME);
        assertTrue(mNotificationAssistantService.currentCapabilities.contains(
                Adjustment.KEY_SNOOZE_CRITERIA));

        mNotificationManager.disallowAssistantAdjustment(Adjustment.KEY_SNOOZE_CRITERIA);
        Thread.sleep(SLEEP_TIME);
        assertFalse(mNotificationAssistantService.currentCapabilities.contains(
                Adjustment.KEY_SNOOZE_CRITERIA));

        // just in case KEY_SNOOZE_CRITERIA was included in the original set, test adding again
        mNotificationManager.allowAssistantAdjustment(Adjustment.KEY_SNOOZE_CRITERIA);
        Thread.sleep(SLEEP_TIME);
        assertTrue(mNotificationAssistantService.currentCapabilities.contains(
                Adjustment.KEY_SNOOZE_CRITERIA));

        mUi.dropShellPermissionIdentity();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/notificationlegacy/notificationlegacy29/src/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.notification.legacy29.cts.NotificationAssistantServiceTest"	"testOnNotificationVisibilityChanged"	"CtsLegacyNotification29TestCases"	"1: permission"	"([3:/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java]:[permission]:[3]:method_text:[icationAssistantService.notificationVisible);        mUi.dropShellPermissionIdentity();    }   ]) :|: 
    public void testOnNotificationVisibilityChanged() throws Exception {
        if (isTelevision()) {
            return;
        }
        assumeFalse(""Status bar service not supported"", isWatch());
        setUpListeners();
        turnScreenOn();
        mUi.adoptShellPermissionIdentity(""android.permission.EXPAND_STATUS_BAR"");

        sendConversationNotification(mNotificationAssistantService.notificationId);
        Thread.sleep(SLEEP_TIME * 2);

        // Initialize as closed
        mStatusBarManager.collapsePanels();
        Thread.sleep(SLEEP_TIME * 2);

        mStatusBarManager.expandNotificationsPanel();
        Thread.sleep(SLEEP_TIME * 2);
        assertTrue(mNotificationAssistantService.notificationVisible);

        mStatusBarManager.collapsePanels();
        Thread.sleep(SLEEP_TIME * 2);
        assertFalse(mNotificationAssistantService.notificationVisible);

        mUi.dropShellPermissionIdentity();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/notificationlegacy/notificationlegacy29/src/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.notification.legacy29.cts.NotificationAssistantServiceTest"	"testOnNotificationsSeen"	"CtsLegacyNotification29TestCases"	"1: permission"	"([3:/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java]:[permission]:[3]:method_text:[;        mStatusBarManager.collapsePanels();        mUi.dropShellPermissionIdentity();    }   ]) :|: 
    public void testOnNotificationsSeen() throws Exception {
        if (isTelevision()) {
            return;
        }
        assumeFalse(""Status bar service not supported"", isWatch());
        setUpListeners();
        turnScreenOn();
        mUi.adoptShellPermissionIdentity(""android.permission.EXPAND_STATUS_BAR"");

        mNotificationAssistantService.resetNotificationVisibilityCounts();

        // Initialize as closed
        mStatusBarManager.collapsePanels();

        sendNotification(1, ICON_ID);
        assertEquals(0, mNotificationAssistantService.notificationSeenCount);

        mStatusBarManager.expandNotificationsPanel();
        Thread.sleep(SLEEP_TIME * 2);
        assertTrue(mNotificationAssistantService.notificationSeenCount > 0);

        mStatusBarManager.collapsePanels();
        mUi.dropShellPermissionIdentity();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/notificationlegacy/notificationlegacy29/src/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.notification.legacy29.cts.NotificationAssistantServiceTest"	"testOnPanelRevealedAndHidden"	"CtsLegacyNotification29TestCases"	"1: permission"	"([3:/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java]:[permission]:[3]:method_text:[e(mNotificationAssistantService.isPanelOpen);        mUi.dropShellPermissionIdentity();    }   ]) :|: 
    public void testOnPanelRevealedAndHidden() throws Exception {
        if (isTelevision()) {
            return;
        }
        assumeFalse(""Status bar service not supported"", isWatch());
        setUpListeners();
        turnScreenOn();
        mUi.adoptShellPermissionIdentity(""android.permission.EXPAND_STATUS_BAR"");

        // Initialize as closed
        mStatusBarManager.collapsePanels();
        assertFalse(mNotificationAssistantService.isPanelOpen);

        mStatusBarManager.expandNotificationsPanel();
        Thread.sleep(SLEEP_TIME * 2);
        assertTrue(mNotificationAssistantService.isPanelOpen);

        mStatusBarManager.collapsePanels();
        Thread.sleep(SLEEP_TIME * 2);
        assertFalse(mNotificationAssistantService.isPanelOpen);

        mUi.dropShellPermissionIdentity();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/notificationlegacy/notificationlegacy29/src/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.notification.legacy29.cts.NotificationAssistantServiceTest"	"testOnNotificationClicked"	"CtsLegacyNotification29TestCases"	"1: permission"	"([4:/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java]:[permission]:[4]:method_text:[        mStatusBarManager.collapsePanels();        mUi.dropShellPermissionIdentity();    }   ]) :|: 
    public void testOnNotificationClicked() throws Exception {
        if (isTelevision()) {
            return;
        }

        setUpListeners();
        turnScreenOn();
        mUi.adoptShellPermissionIdentity(""android.permission.STATUS_BAR_SERVICE"", ""android.permission.EXPAND_STATUS_BAR"");

        mNotificationAssistantService.resetNotificationClickCount();

        // Initialize as closed
        mStatusBarManager.collapsePanels();
        sendNotification(1, ICON_ID);
        StatusBarNotification sbn = getFirstNotificationFromPackage(TestNotificationListener.PKG);

        mStatusBarManager.expandNotificationsPanel();
        Thread.sleep(SLEEP_TIME * 2);
        mStatusBarManager.clickNotification(sbn.getKey(), 1, 1, true);
        Thread.sleep(SLEEP_TIME * 2);

        assertEquals(1, mNotificationAssistantService.notificationClickCount);

        mStatusBarManager.collapsePanels();
        mUi.dropShellPermissionIdentity();

    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/notificationlegacy/notificationlegacy29/src/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.notification.legacy29.cts.NotificationAssistantServiceTest"	"testOnNotificationFeedbackReceived"	"CtsLegacyNotification29TestCases"	"1: permission"	"([8:/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java]:[permission]:[8]:method_text:[ new IOException(""Could not read stdout of command:"" + command, e);            }        }    }}]) :|: 
    public void testOnNotificationFeedbackReceived() throws Exception {
        setUpListeners(); // also enables assistant
        mUi.adoptShellPermissionIdentity(""android.permission.STATUS_BAR_SERVICE"", ""android.permission.EXPAND_STATUS_BAR"");

        sendNotification(1, ICON_ID);
        StatusBarNotification sbn = getFirstNotificationFromPackage(TestNotificationListener.PKG);

        Bundle feedback = new Bundle();
        feedback.putInt(FEEDBACK_RATING, 1);

        mStatusBarManager.sendNotificationFeedback(sbn.getKey(), feedback);
        Thread.sleep(SLEEP_TIME * 2);
        assertEquals(1, mNotificationAssistantService.notificationFeedback);

        mUi.dropShellPermissionIdentity();
    }

    private StatusBarNotification getFirstNotificationFromPackage(String PKG)
            throws InterruptedException {
        StatusBarNotification sbn = mNotificationListenerService.mPosted.poll(SLEEP_TIME,
                TimeUnit.MILLISECONDS);
        assertNotNull(sbn);
        while (!sbn.getPackageName().equals(PKG)) {
            sbn = mNotificationListenerService.mPosted.poll(SLEEP_TIME, TimeUnit.MILLISECONDS);
        }
        assertNotNull(sbn);
        return sbn;
    }

    private void setUpListeners() throws Exception {
        toggleListenerAccess(true);
        toggleAssistantAccess(true);
        Thread.sleep(2 * SLEEP_TIME); // wait for listener and assistant to be allowed

        mNotificationListenerService = TestNotificationListener.getInstance();
        mNotificationAssistantService = TestNotificationAssistant.getInstance();

        assertNotNull(mNotificationListenerService);
        assertNotNull(mNotificationAssistantService);
    }

    private void sendNotification(final int id, final int icon) throws Exception {
        sendNotification(id, null, icon);
    }

    private void sendNotification(final int id, String groupKey, final int icon) throws Exception {
        final Intent intent = new Intent(Intent.ACTION_MAIN, Telephony.Th"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/notificationlegacy/notificationlegacy29/src/android/app/notification/legacy29/cts/NotificationAssistantServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.notification.legacy28.cts.NotificationManager28Test"	"testPostFullScreenIntent_noPermission"	"CtsLegacyNotification28TestCases"	"1: permission"	"([2:/android/app/notification/legacy28/cts/NotificationManager28Test.java]:[permission]:[2]:method_text:[  mContext, 0, new Intent(mContext, this.getClass()), PendingIntent.FLAG_MUTABLE_UNAUDITED);    }}]) :|: 
    public void testPostFullScreenIntent_noPermission() {
        // No Full screen intent permission; but full screen intent should still be allowed
        int id = 6000;
        final Notification notification =
                new Notification.Builder(mContext, NOTIFICATION_CHANNEL_ID)
                        .setSmallIcon(android.R.id.icon)
                        .setWhen(System.currentTimeMillis())
                        .setFullScreenIntent(getPendingIntent(), true)
                        .setContentText(""This is #FSI notification"")
                        .setContentIntent(getPendingIntent())
                        .build();
        mNotificationManager.notify(id, notification);

        StatusBarNotification n = findPostedNotification(id);
        assertNotNull(n);
        assertEquals(notification.fullScreenIntent, n.getNotification().fullScreenIntent);
    }

    private StatusBarNotification findPostedNotification(int id) {
        // notification is a bit asynchronous so it may take a few ms to appear in
        // getActiveNotifications()
        // we will check for it for up to 300ms before giving up
        StatusBarNotification n = null;
        for (int tries = 3; tries--> 0;) {
            final StatusBarNotification[] sbns = mNotificationManager.getActiveNotifications();
            for (StatusBarNotification sbn : sbns) {
                Log.d(TAG, ""Found "" + sbn.getKey());
                if (sbn.getId() == id) {
                    n = sbn;
                    break;
                }
            }
            if (n != null) break;
            try {
                Thread.sleep(100);
            } catch (InterruptedException ex) {
                // pass
            }
        }
        return n;
    }

    private PendingIntent getPendingIntent() {
        return PendingIntent.getActivity(
                mContext, 0, new Intent(mContext, this.getClass()), PendingIntent.FLAG_MUTABLE_UNAUDITED);
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/notificationlegacy/notificationlegacy28/src/android/app/notification/legacy28/cts/NotificationManager28Test.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.notification.legacy.cts.ConditionProviderServiceTest"	"testRequestRebindWhenLostAccess"	"CtsLegacyNotification27TestCases"	"1: permission"	"([1:/android/app/notification/legacy/cts/ConditionProviderServiceTest.java]:[permission]:[1]:method_text:[nd after permission lost"");        } catch (Exception e) {            // pass        }    }   ]) :|: 
    public void testRequestRebindWhenLostAccess() throws Exception {
        // make sure it gets bound
        pollForConnection(LegacyConditionProviderService.class, true);

        // request unbind
        LegacyConditionProviderService.getInstance().requestUnbind();

        // make sure it unbinds
        pollForConnection(LegacyConditionProviderService.class, false);

        // lose dnd access
        toggleNotificationPolicyAccess(mContext.getPackageName(),
                InstrumentationRegistry.getInstrumentation(), false);

        // try to rebind
        LegacyConditionProviderService.requestRebind(LegacyConditionProviderService.getId());

        // make sure it isn't rebound
        try {
            pollForConnection(LegacyConditionProviderService.class, true);
            fail(""Service got rebound after permission lost"");
        } catch (Exception e) {
            // pass
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/notificationlegacy/notificationlegacy27/src/android/app/notification/legacy/cts/ConditionProviderServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.batterysaving.ActionChargingTest"	"uptimeMillis"	"CtsBatterySavingTestCases"	"1: permission"	"([1:/android/os/cts/batterysaving/ActionChargingTest.java]:[permission]:[1]:method_text:[eryManager.class);    }    @After    public void tearDown() {        resetSetting();    }   ]) :|: /*
 *.
 */
package android.os.cts.batterysaving;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.BatteryManager;
import android.os.SystemClock;
import android.util.Log;

import com.android.compatibility.common.util.AmUtils;
import com.android.compatibility.common.util.BatteryUtils;
import com.android.compatibility.common.util.SettingsUtils;
import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

public class ActionChargingTest extends BatterySavingTestBase {
    private static final String TAG = ""ActionChargingTest"";

    private static final long DELIVER_DELAY_ALLOWANCE_MILLIS = 5000;
    private static final long CHARGING_DELAY_MILLIS = 5000;

    private BatteryManager mBatteryManager;

    private class ActionChargingListener extends BroadcastReceiver {
        private final CountDownLatch mLatch = new CountDownLatch(1);
        private volatile long mReceiveUptime;

        @Override
        public void onReceive(Context context, Intent intent) {
            if (BatteryManager.ACTION_CHARGING.equals(intent.getAction())) {
                Log.i(TAG, ""ACTION_CHARGING received"");
                mReceiveUptime = SystemClock.uptimeMillis();
                mLatch.countDown();
            }
        }

        public void startMonitoring() {
            final IntentFilter filter = new IntentFilter(BatteryManager.ACTION_CHARGING);
            getContext().registerReceiver(this, filter);
        }

        public void stopMonitoring() {
            getContext().unregisterReceiver(this);
        }

        public void"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/batterysaving/src/android/os/cts/batterysaving/ActionChargingTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.batterysaving.ActionChargingTest"	"testActionChargingDeferred_withApi"	"CtsBatterySavingTestCases"	"1: permission"	"([1:/android/os/cts/batterysaving/ActionChargingTest.java]:[permission]:[1]:method_text:[teUpdateDelayMillis((int) CHARGING_DELAY_MILLIS));        checkActionChargingDeferred();    }   ]) :|: 
    public void testActionChargingDeferred_withApi() throws Exception {
        ShellIdentityUtils.invokeMethodWithShellPermissions(mBatteryManager,
                (bm) -> bm.setChargingStateUpdateDelayMillis((int) CHARGING_DELAY_MILLIS));
        checkActionChargingDeferred();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/batterysaving/src/android/os/cts/batterysaving/ActionChargingTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.batterysaving.ActionChargingTest"	"testActionChargingDeferred_withApiThenReset"	"CtsBatterySavingTestCases"	"1: permission"	"([2:/android/os/cts/batterysaving/ActionChargingTest.java]:[permission]:[2]:method_text:[GING_DELAY_MILLIS);        } finally {            listener.stopMonitoring();        }    }   ]) :|: 
    public void testActionChargingDeferred_withApiThenReset() throws Exception {
        setChargingDelay(CHARGING_DELAY_MILLIS);

        // Set a longer value via the API, and then set -1, which should reset the override value.
        ShellIdentityUtils.invokeMethodWithShellPermissions(mBatteryManager,
                (bm) -> bm.setChargingStateUpdateDelayMillis((int) CHARGING_DELAY_MILLIS * 100));
        ShellIdentityUtils.invokeMethodWithShellPermissions(mBatteryManager,
                (bm) -> bm.setChargingStateUpdateDelayMillis(-1));

        // So now CHARGING_DELAY_MILLIS should be in effect.
        checkActionChargingDeferred();
    }

    public void checkActionChargingDeferred() throws Exception {
        BatteryUtils.runDumpsysBatteryUnplug();
        BatteryUtils.runDumpsysBatterySetLevel(50);

        AmUtils.waitForBroadcastIdle();

        final ActionChargingListener listener = new ActionChargingListener();
        try {
            listener.startMonitoring();

            // Plug in the charger.
            BatteryUtils.runDumpsysBatterySetPluggedIn(true);

            // Wait for CHARGING_DELAY_MILLIS -- broadcast shouldn't be sent yet, because
            // the battery level hasn't increased.
            Thread.sleep(CHARGING_DELAY_MILLIS + DELIVER_DELAY_ALLOWANCE_MILLIS);
            AmUtils.waitForBroadcastIdle();

            assertFalse(
                    ""CHARGING shouldn't be sent (battery level not increased)"",
                    listener.received());

            // Increase the battery level, now the broadcast should be sent.
            final long increasedUptime = SystemClock.uptimeMillis();
            BatteryUtils.runDumpsysBatterySetLevel(51);

            listener.await(CHARGING_DELAY_MILLIS + DELIVER_DELAY_ALLOWANCE_MILLIS);

            final long actualDelay = listener.getReceivedUptime() - increasedUptime;

            assertThat(actualDelay).isAtLeast(CHARGING_DELAY_MILLIS);

        } finally {
            listener.s"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/batterysaving/src/android/os/cts/batterysaving/ActionChargingTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.batterysaving.ActionChargingTest"	"testSetChargingStateUpdateDelayMillis_noPermission"	"CtsBatterySavingTestCases"	"1: permission"	"([1:/android/os/cts/batterysaving/ActionChargingTest.java]:[permission]:[1]:method_text:[on expected) {            return;        }        fail(""Didn't throw SecurityException"");    }}]) :|: 
    public void testSetChargingStateUpdateDelayMillis_noPermission() {
        try {
            mBatteryManager.setChargingStateUpdateDelayMillis(1);
        } catch (SecurityException expected) {
            return;
        }
        fail(""Didn't throw SecurityException"");
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/batterysaving/src/android/os/cts/batterysaving/ActionChargingTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.batterysaving.BatterySaverTest"	"testSetBatterySaver_powerManager"	"CtsBatterySavingTestCases"	"1: permission"	"([1:/android/os/cts/batterysaving/BatterySaverTest.java]:[permission]:[1]:method_text:[}    /** Tests that Battery Saver exemptions activate when automotive projection is active. */   ]) :|: 
    public void testSetBatterySaver_powerManager() throws Exception {
        enableBatterySaver(false);

        runWithShellPermissionIdentity(() -> {
            PowerManager manager = BatteryUtils.getPowerManager();
            assertFalse(manager.isPowerSaveMode());

            // Unplug the charger.
            runDumpsysBatteryUnplug();
            // Verify battery saver gets toggled.
            manager.setPowerSaveModeEnabled(true);
            assertTrue(manager.isPowerSaveMode());

            manager.setPowerSaveModeEnabled(false);
            assertFalse(manager.isPowerSaveMode());
        });
    }

    /** Tests that Battery Saver exemptions activate when automotive projection is active. */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/batterysaving/src/android/os/cts/batterysaving/BatterySaverTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.os.cts.batterysaving.BatterySaverTest"	"testAutomotiveProjectionExceptions"	"CtsBatterySavingTestCases"	"1: permission"	"([8:/android/os/cts/batterysaving/BatterySaverTest.java]:[permission]:[8]:method_text:[MOTIVE),                    Manifest.permission.TOGGLE_AUTOMOTIVE_PROJECTION);        }    }   ]) :|: 
    public void testAutomotiveProjectionExceptions() throws Exception {
        runShellCommand(""cmd uimode night no"");
        UiModeManager uiModeManager = getContext().getSystemService(UiModeManager.class);
        runWithShellPermissionIdentity(() ->
                        uiModeManager.releaseProjection(UiModeManager.PROJECTION_TYPE_AUTOMOTIVE),
                Manifest.permission.TOGGLE_AUTOMOTIVE_PROJECTION);

        final PowerManager powerManager = BatteryUtils.getPowerManager();

        try {
            runDumpsysBatteryUnplug();

            SettingsUtils.set(SettingsUtils.NAMESPACE_GLOBAL, ""battery_saver_constants"",
                    ""location_mode="" + PowerManager.LOCATION_MODE_ALL_DISABLED_WHEN_SCREEN_OFF
                            + "",enable_night_mode=true"");

            enableBatterySaver(true);

            assertTrue(powerManager.isPowerSaveMode());
            // Updating based on the settings change may take some time.
            waitUntil(""Location mode didn't change to ""
                            + PowerManager.LOCATION_MODE_ALL_DISABLED_WHEN_SCREEN_OFF,
                    () -> PowerManager.LOCATION_MODE_ALL_DISABLED_WHEN_SCREEN_OFF ==
                            powerManager.getLocationPowerSaveMode());
            // UI change can take a while to propagate, so need to wait for this check.
            waitUntil(""UI mode didn't change to "" + Configuration.UI_MODE_NIGHT_YES,
                    () -> Configuration.UI_MODE_NIGHT_YES ==
                            (getContext().getResources().getConfiguration().uiMode
                                    & Configuration.UI_MODE_NIGHT_MASK));

            assertTrue(runWithShellPermissionIdentity(
                    () -> uiModeManager.requestProjection(UiModeManager.PROJECTION_TYPE_AUTOMOTIVE),
                    Manifest.permission.TOGGLE_AUTOMOTIVE_PROJECTION));

            // Wait for UI change first before checking location mode since we can then be
            // confident th"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/batterysaving/src/android/os/cts/batterysaving/BatterySaverTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.uiautomation.cts.UiAutomationTest"	"testAdoptAllShellPermissions"	"CtsUiAutomationTestCases"	"1: permission"	"([19:/android/app/uiautomation/cts/UiAutomationTest.java]:[permission]:[19]:method_text:[ not be able to access APIs protected by a permission apps cannot get"");    }    @AppModeFull   ]) :|: 
    public void testAdoptAllShellPermissions() {
        final Context context = getInstrumentation().getContext();
        final ActivityManager activityManager = context.getSystemService(ActivityManager.class);
        final PackageManager packageManager = context.getPackageManager();

        // Try to access APIs guarded by a platform defined signature permissions
        assertThrows(SecurityException.class,
                () -> activityManager.getPackageImportance(""foo.bar.baz""),
                ""Should not be able to access APIs protected by a permission apps cannot get"");
        assertThrows(SecurityException.class,
                () -> packageManager.grantRuntimePermission(context.getPackageName(),
                        Manifest.permission.ANSWER_PHONE_CALLS, Process.myUserHandle()),
                ""Should not be able to access APIs protected by a permission apps cannot get"");

        // Access APIs guarded by a platform defined signature permissions
        try {
            getInstrumentation().getUiAutomation().adoptShellPermissionIdentity();
            // Access APIs guarded by a platform defined signature permission
            activityManager.getPackageImportance(""foo.bar.baz"");

            // Grant ourselves a runtime permission (was granted at install)
            packageManager.grantRuntimePermission(context.getPackageName(),
                    Manifest.permission.ANSWER_PHONE_CALLS, Process.myUserHandle());
        } catch (SecurityException e) {
            fail(""Should be able to access APIs protected by a permission apps cannot get"");
        } finally {
            getInstrumentation().getUiAutomation().dropShellPermissionIdentity();
        }

        // Try to access APIs guarded by a platform defined signature permissions
        assertThrows(SecurityException.class,
                () -> activityManager.getPackageImportance(""foo.bar.baz""),
                ""Should not be able to access APIs protected by a permission apps cannot g"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/uiautomation/src/android/app/uiautomation/cts/UiAutomationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.uiautomation.cts.UiAutomationTest"	"testAdoptSomeShellPermissions"	"CtsUiAutomationTestCases"	"1: permission"	"([36:/android/app/uiautomation/cts/UiAutomationTest.java]:[permission]:[36]:method_text:[          getInstrumentation().getUiAutomation().dropShellPermissionIdentity();        }    }   ]) :|: 
    public void testAdoptSomeShellPermissions() {
        final Context context = getInstrumentation().getContext();

        // Make sure we don't have any of the permissions
        assertSame(PackageManager.PERMISSION_DENIED, context.checkSelfPermission(
                Manifest.permission.BATTERY_STATS));
        assertSame(PackageManager.PERMISSION_DENIED, context.checkSelfPermission(
                Manifest.permission.PACKAGE_USAGE_STATS));

        try {
            // Adopt a permission
            getInstrumentation().getUiAutomation().adoptShellPermissionIdentity(
                    Manifest.permission.BATTERY_STATS);
            // Check one is granted and the other not
            assertSame(PackageManager.PERMISSION_GRANTED, context.checkSelfPermission(
                    Manifest.permission.BATTERY_STATS));
            assertSame(PackageManager.PERMISSION_DENIED, context.checkSelfPermission(
                    Manifest.permission.PACKAGE_USAGE_STATS));

            // Adopt all permissions
            getInstrumentation().getUiAutomation().adoptShellPermissionIdentity();
            // Check both permissions are granted
            assertSame(PackageManager.PERMISSION_GRANTED, context.checkSelfPermission(
                    Manifest.permission.BATTERY_STATS));
            assertSame(PackageManager.PERMISSION_GRANTED, context.checkSelfPermission(
                    Manifest.permission.PACKAGE_USAGE_STATS));

            // Adopt a permission
            getInstrumentation().getUiAutomation().adoptShellPermissionIdentity(
                    Manifest.permission.PACKAGE_USAGE_STATS);
            // Check one is granted and the other not
            assertSame(PackageManager.PERMISSION_DENIED, context.checkSelfPermission(
                    Manifest.permission.BATTERY_STATS));
            assertSame(PackageManager.PERMISSION_GRANTED, context.checkSelfPermission(
                    Manifest.permission.PACKAGE_USAGE_STATS));
        } finally {"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/uiautomation/src/android/app/uiautomation/cts/UiAutomationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.uiautomation.cts.UiAutomationTest"	"testCallingPublicAPIsWithDontUseAccessibilityFlag_shouldNotThrowException"	"CtsUiAutomationTestCases"	"1: permission"	"([6:/android/app/uiautomation/cts/UiAutomationTest.java]:[permission]:[6]:method_text:[entation getInstrumentation() {        return InstrumentationRegistry.getInstrumentation();    }}]) :|: 
    public void testCallingPublicAPIsWithDontUseAccessibilityFlag_shouldNotThrowException()
            throws Exception {
        final UiAutomation uiAutomation = getInstrumentation()
                .getUiAutomation(UiAutomation.FLAG_DONT_USE_ACCESSIBILITY);
        final KeyEvent event = new KeyEvent(0, 0, KeyEvent.ACTION_DOWN,
                KeyEvent.KEYCODE_BACK, 0);
        uiAutomation.injectInputEvent(event, true);
        uiAutomation.syncInputTransactions();
        uiAutomation.setRotation(UiAutomation.ROTATION_FREEZE_0);
        uiAutomation.takeScreenshot();
        uiAutomation.clearWindowAnimationFrameStats();
        uiAutomation.getWindowAnimationFrameStats();
        try {
            uiAutomation.adoptShellPermissionIdentity(Manifest.permission.BATTERY_STATS);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    private void scrollListView(UiAutomation uiAutomation, final ListView listView,
            final int position) throws TimeoutException {
        getInstrumentation().runOnMainSync(new Runnable() {
            @Override
            public void run() {
                listView.smoothScrollToPosition(position);
            }
        });
        Runnable emptyRunnable = new Runnable() {
            @Override
            public void run() {
            }
        };
        UiAutomation.AccessibilityEventFilter scrollFilter =
                new UiAutomation.AccessibilityEventFilter() {
                    @Override
                    public boolean accept(AccessibilityEvent accessibilityEvent) {
                        return accessibilityEvent.getEventType()
                                == AccessibilityEvent.TYPE_VIEW_SCROLLED;
                    }
                };
        uiAutomation.executeAndWaitForEvent(emptyRunnable, scrollFilter,
                TOTAL_TIME_TO_WAIT_FOR_IDLE_STATE);
        uiAutomation.waitForIdle(
                QUIET_TIME_TO_BE_CONSIDERED_IDLE_STATE, TOTAL_TIME_TO"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/uiautomation/src/android/app/uiautomation/cts/UiAutomationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.telephony.TelephonyManagerPermissionTest"	"testGetDeviceId"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/telephony/TelephonyManagerPermissionTest.java]:[permission]:[3]:method_text:[     * Requires Permission:     * {@link android.Manifest.permission#READ_PHONE_STATE}.     */   ]) :|: 
    public void testGetDeviceId() {
        if (!mHasTelephony) {
            return;
        }

        try {
            String id = mTelephonyManager.getDeviceId();
            fail(""Got device ID: "" + id);
        } catch (SecurityException e) {
            // expected
        }
        try {
            String id = mTelephonyManager.getDeviceId(0);
            fail(""Got device ID: "" + id);
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that TelephonyManager.getLine1Number requires Permission.
     * <p>
     * Requires Permission:
     * {@link android.Manifest.permission#READ_PHONE_STATE}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/telephony/src/android/permission/cts/telephony/TelephonyManagerPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.telephony.TelephonyManagerPermissionTest"	"testGetLine1Number"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/telephony/TelephonyManagerPermissionTest.java]:[permission]:[3]:method_text:[     * Requires Permission:     * {@link android.Manifest.permission#READ_PHONE_STATE}.     */   ]) :|: 
    public void testGetLine1Number() {
        if (!mHasTelephony) {
            return;
        }

        try {
            String nmbr = mTelephonyManager.getLine1Number();
            fail(""Got line 1 number: "" + nmbr);
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that TelephonyManager.getSimSerialNumber requires Permission.
     * <p>
     * Requires Permission:
     * {@link android.Manifest.permission#READ_PHONE_STATE}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/telephony/src/android/permission/cts/telephony/TelephonyManagerPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.telephony.TelephonyManagerPermissionTest"	"testGetSimSerialNumber"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/telephony/TelephonyManagerPermissionTest.java]:[permission]:[3]:method_text:[     * Requires Permission:     * {@link android.Manifest.permission#READ_PHONE_STATE}.     */   ]) :|: 
    public void testGetSimSerialNumber() {
        if (!mHasTelephony) {
            return;
        }

        try {
            String nmbr = mTelephonyManager.getSimSerialNumber();
            fail(""Got SIM serial number: "" + nmbr);
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that TelephonyManager.getSubscriberId requires Permission.
     * <p>
     * Requires Permission:
     * {@link android.Manifest.permission#READ_PHONE_STATE}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/telephony/src/android/permission/cts/telephony/TelephonyManagerPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.telephony.TelephonyManagerPermissionTest"	"testGetSubscriberId"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/telephony/TelephonyManagerPermissionTest.java]:[permission]:[3]:method_text:[     * Requires Permission:     * {@link android.Manifest.permission#READ_PHONE_STATE}.     */   ]) :|: 
    public void testGetSubscriberId() {
        if (!mHasTelephony) {
            return;
        }

        try {
            String sid = mTelephonyManager.getSubscriberId();
            fail(""Got subscriber id: "" + sid);
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that TelephonyManager.getVoiceMailNumber requires Permission.
     * <p>
     * Requires Permission:
     * {@link android.Manifest.permission#READ_PHONE_STATE}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/telephony/src/android/permission/cts/telephony/TelephonyManagerPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.telephony.TelephonyManagerPermissionTest"	"testVoiceMailNumber"	"CtsPermissionTestCases"	"1: permission"	"([4:/android/permission/cts/telephony/TelephonyManagerPermissionTest.java]:[permission]:[4]:method_text:[id.Manifest.permission#MODIFY_PHONE_STATE} for     * {@link AudioManager#MODE_IN_CALL}.     */   ]) :|: 
    public void testVoiceMailNumber() {
        if (!mHasTelephony) {
            return;
        }

        try {
            String vmnum = mTelephonyManager.getVoiceMailNumber();
            fail(""Got voicemail number: "" + vmnum);
        } catch (SecurityException e) {
            // expected
        }
    }
    /**
     * Verify that AudioManager.setMode requires Permission.
     * <p>
     * Requires Permissions:
     * {@link android.Manifest.permission#MODIFY_AUDIO_SETTINGS} and
     * {@link android.Manifest.permission#MODIFY_PHONE_STATE} for
     * {@link AudioManager#MODE_IN_CALL}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/telephony/src/android/permission/cts/telephony/TelephonyManagerPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.telephony.TelephonyManagerPermissionTest"	"testSetMode"	"CtsPermissionTestCases"	"1: permission"	"([1:/android/permission/cts/telephony/TelephonyManagerPermissionTest.java]:[permission]:[1]:method_text:[n     * Expects a security exception since the caller does not have carrier privileges.     */   ]) :|: 
    public void testSetMode() {
        if (!mHasTelephony) {
            return;
        }
        int audioMode = mAudioManager.getMode();
        mAudioManager.setMode(AudioManager.MODE_IN_CALL);
        assertEquals(audioMode, mAudioManager.getMode());
    }

     /**
     * Tests that isManualNetworkSelectionAllowed requires permission
     * Expects a security exception since the caller does not have carrier privileges.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/telephony/src/android/permission/cts/telephony/TelephonyManagerPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.telephony.TelephonyManagerPermissionTest"	"testIsManualNetworkSelectionAllowedWithoutPermission"	"CtsPermissionTestCases"	"1: permission"	"([2:/android/permission/cts/telephony/TelephonyManagerPermissionTest.java]:[permission]:[2]:method_text:[n     * Expects a security exception since the caller does not have carrier privileges.     */   ]) :|: 
    public void testIsManualNetworkSelectionAllowedWithoutPermission() {
        if (!mHasTelephony) {
            return;
        }
        try {
            mTelephonyManager.isManualNetworkSelectionAllowed();
            fail(""Expected SecurityException. App does not have carrier privileges."");
        } catch (SecurityException expected) {
        }
    }

    /**
     * Tests that getManualNetworkSelectionPlmn requires permission
     * Expects a security exception since the caller does not have carrier privileges.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/telephony/src/android/permission/cts/telephony/TelephonyManagerPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.telephony.TelephonyManagerPermissionTest"	"testGetManualNetworkSelectionPlmnWithoutPermission"	"CtsPermissionTestCases"	"1: permission"	"([1:/android/permission/cts/telephony/TelephonyManagerPermissionTest.java]:[permission]:[1]:method_text:[        }    }    /**     * Verify that Telephony related broadcasts are protected.     */   ]) :|: 
    public void testGetManualNetworkSelectionPlmnWithoutPermission() {
        if (!mHasTelephony) {
            return;
        }
        try {
            mTelephonyManager.getManualNetworkSelectionPlmn();
            fail(""Expected SecurityException. App does not have carrier privileges."");
        } catch (SecurityException expected) {
        }
    }

    /**
     * Verify that Telephony related broadcasts are protected.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/telephony/src/android/permission/cts/telephony/TelephonyManagerPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.telephony.TelephonyManagerPermissionTest"	"testProtectedBroadcasts"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/telephony/TelephonyManagerPermissionTest.java]:[permission]:[3]:method_text:[     * Requires Permission:     * {@link android.Manifest.permission#READ_PHONE_STATE}.     */   ]) :|: 
    public void testProtectedBroadcasts() {
        if (!mHasTelephony) {
            return;
        }
        try {
            Intent intent = new Intent(""android.intent.action.SIM_STATE_CHANGED"");
            getContext().sendBroadcast(intent);
            fail(""SecurityException expected!"");
        } catch (SecurityException e) {}
        try {
            Intent intent = new Intent(""android.intent.action.SERVICE_STATE"");
            getContext().sendBroadcast(intent);
            fail(""SecurityException expected!"");
        } catch (SecurityException e) {}
        try {
            Intent intent = new Intent(""android.telephony.action.DEFAULT_SUBSCRIPTION_CHANGED"");
            getContext().sendBroadcast(intent);
            fail(""SecurityException expected!"");
        } catch (SecurityException e) {}
        try {
            Intent intent = new Intent(
                    ""android.intent.action.ACTION_DEFAULT_DATA_SUBSCRIPTION_CHANGED"");
            getContext().sendBroadcast(intent);
            fail(""SecurityException expected!"");
        } catch (SecurityException e) {}
        try {
            Intent intent = new Intent(
                    ""android.telephony.action.DEFAULT_SMS_SUBSCRIPTION_CHANGED"");
            getContext().sendBroadcast(intent);
            fail(""SecurityException expected!"");
        } catch (SecurityException e) {}
        try {
            Intent intent = new Intent(
                    ""android.intent.action.ACTION_DEFAULT_VOICE_SUBSCRIPTION_CHANGED"");
            getContext().sendBroadcast(intent);
            fail(""SecurityException expected!"");
        } catch (SecurityException e) {}
        try {
            Intent intent = new Intent(""android.intent.action.SIG_STR"");
            getContext().sendBroadcast(intent);
            fail(""SecurityException expected!"");
        } catch (SecurityException e) {}
        try {
            Intent intent = new Intent(""android.provider.Telephony.SECRET_CODE"");
            getContext().s"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/telephony/src/android/permission/cts/telephony/TelephonyManagerPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.telephony.TelephonyManagerPermissionTest"	"testGetImei"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/telephony/TelephonyManagerPermissionTest.java]:[permission]:[3]:method_text:[     * Requires Permission:     * {@link android.Manifest.permission#READ_PHONE_STATE}.     */   ]) :|: 
    public void testGetImei() {
        if (!mHasTelephony) {
            return;
        }

        try {
            String imei = mTelephonyManager.getImei();
            fail(""Got IMEI: "" + imei);
        } catch (SecurityException e) {
            // expected
        }
        try {
            String imei = mTelephonyManager.getImei(0);
            fail(""Got IMEI: "" + imei);
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that getNetworkType and getDataNetworkType requires Permission.
     * <p>
     * Requires Permission:
     * {@link android.Manifest.permission#READ_PHONE_STATE}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/telephony/src/android/permission/cts/telephony/TelephonyManagerPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.telephony.TelephonyManagerPermissionTest"	"testGetNetworkType"	"CtsPermissionTestCases"	"1: permission"	"([1:/android/permission/cts/telephony/TelephonyManagerPermissionTest.java]:[permission]:[1]:method_text:[n     * Expects a security exception since the caller does not have carrier privileges.     */   ]) :|: 
    public void testGetNetworkType() {
        if (!mHasTelephony) {
            return;
        }

        try {
            mTelephonyManager.getNetworkType();
            fail(""getNetworkType did not throw a SecurityException"");
        } catch (SecurityException e) {
            // expected
        }

        try {
            mTelephonyManager.getDataNetworkType();
            fail(""getDataNetworkType did not throw a SecurityException"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Tests that getNetworkSelectionMode requires permission
     * Expects a security exception since the caller does not have carrier privileges.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/telephony/src/android/permission/cts/telephony/TelephonyManagerPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.telephony.TelephonyManagerPermissionTest"	"testGetNetworkSelectionModeWithoutPermission"	"CtsPermissionTestCases"	"1: permission"	"([2:/android/permission/cts/telephony/TelephonyManagerPermissionTest.java]:[permission]:[2]:method_text:[n     * Expects a security exception since the caller does not have carrier privileges.     */   ]) :|: 
    public void testGetNetworkSelectionModeWithoutPermission() {
        if (!mHasTelephony) {
            return;
        }
        assertThrowsSecurityException(() -> mTelephonyManager.getNetworkSelectionMode(),
                ""Expected SecurityException. App does not have carrier privileges."");
    }

    /**
     * Tests that setNetworkSelectionModeAutomatic requires permission
     * Expects a security exception since the caller does not have carrier privileges.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/telephony/src/android/permission/cts/telephony/TelephonyManagerPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.telephony.TelephonyManagerPermissionTest"	"testSetNetworkSelectionModeAutomaticWithoutPermission"	"CtsPermissionTestCases"	"1: permission"	"([4:/android/permission/cts/telephony/TelephonyManagerPermissionTest.java]:[permission]:[4]:method_text:[   * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).     */   ]) :|: 
    public void testSetNetworkSelectionModeAutomaticWithoutPermission() {
        if (!mHasTelephony) {
            return;
        }
        assertThrowsSecurityException(() -> mTelephonyManager.setNetworkSelectionModeAutomatic(),
                ""Expected SecurityException. App does not have carrier privileges."");
    }

    /**
     * Verify that setForbiddenPlmns requires Permission.
     * <p>
     * Requires Permission:
     * {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
     * or that the calling app has carrier privileges (see {@link #hasCarrierPrivileges}).
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/telephony/src/android/permission/cts/telephony/TelephonyManagerPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.telephony.TelephonyManagerPermissionTest"	"testSetForbiddenPlmns"	"CtsPermissionTestCases"	"1: permission"	"([6:/android/permission/cts/telephony/TelephonyManagerPermissionTest.java]:[permission]:[6]:method_text:[RMISSION_MASK;    /**     * Verify the documented permissions for PhoneStateListener.     */   ]) :|: 
    public void testSetForbiddenPlmns() {
        if (!mHasTelephony) {
            return;
        }

        try {
            mTelephonyManager.setForbiddenPlmns(new ArrayList<String>());
            fail(""SetForbiddenPlmns did not throw a SecurityException"");
        } catch (SecurityException e) {
            // expected
        }
    }

    static final int PHONE_STATE_PERMISSION_MASK =
                PhoneStateListener.LISTEN_CALL_FORWARDING_INDICATOR
                        | PhoneStateListener.LISTEN_MESSAGE_WAITING_INDICATOR
                        | PhoneStateListener.LISTEN_EMERGENCY_NUMBER_LIST;

    static final int PRECISE_PHONE_STATE_PERMISSION_MASK =
                PhoneStateListener.LISTEN_PRECISE_DATA_CONNECTION_STATE
                        | PhoneStateListener.LISTEN_CALL_DISCONNECT_CAUSES
                        | PhoneStateListener.LISTEN_IMS_CALL_DISCONNECT_CAUSES
                        | PhoneStateListener.LISTEN_REGISTRATION_FAILURE
                        | PhoneStateListener.LISTEN_BARRING_INFO;

    static final int PHONE_PERMISSIONS_MASK =
            PHONE_STATE_PERMISSION_MASK | PRECISE_PHONE_STATE_PERMISSION_MASK;

    /**
     * Verify the documented permissions for PhoneStateListener.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/telephony/src/android/permission/cts/telephony/TelephonyManagerPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.telephony.TelephonyManagerPermissionTest"	"testListen"	"CtsPermissionTestCases"	"1: permission"	"([1:/android/permission/cts/telephony/TelephonyManagerPermissionTest.java]:[permission]:[1]:method_text:[ion(Runnable r, String message) {        assertThrows(SecurityException.class, r, message);    }}]) :|: 
    public void testListen() {
        PhoneStateListener psl = new PhoneStateListener((Runnable r) -> { });

        try {
            for (int i = 1; i != 0; i = i << 1) {
                if ((i & PHONE_PERMISSIONS_MASK) == 0) continue;
                final int listenBit = i;
                assertThrowsSecurityException(() -> mTelephonyManager.listen(psl, listenBit),
                        ""Expected a security exception for "" + Integer.toHexString(i));
            }
        } finally {
            mTelephonyManager.listen(psl, PhoneStateListener.LISTEN_NONE);
        }
    }

    private static Context getContext() {
        return InstrumentationRegistry.getContext();
    }

    // An actual version of assertThrows() was added in JUnit5
    private static <T extends Throwable> void assertThrows(Class<T> clazz, Runnable r,
            String message) {
        try {
            r.run();
        } catch (Exception expected) {
            assertTrue(clazz.isAssignableFrom(expected.getClass()));
            return;
        }
        fail(message);
    }

    private static void assertThrowsSecurityException(Runnable r, String message) {
        assertThrows(SecurityException.class, r, message);
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/telephony/src/android/permission/cts/telephony/TelephonyManagerPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoNetworkStatePermissionTest"	"testGetActiveNetworkInfo"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NoNetworkStatePermissionTest.java]:[permission]:[3]:method_text:[ssion:     *   {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.     */    @SmallTest   ]) :|: public void testGetActiveNetworkInfo() {
        try {
            mConnectivityManager.getActiveNetworkInfo();
            fail(""ConnectivityManager.getActiveNetworkInfo didn't throw SecurityException as""
                    + "" expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that ConnectivityManager#getNetworkInfo() requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
     */
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoNetworkStatePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoNetworkStatePermissionTest"	"testGetNetworkInfo"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NoNetworkStatePermissionTest.java]:[permission]:[3]:method_text:[ssion:     *   {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.     */    @SmallTest   ]) :|: public void testGetNetworkInfo() {
        try {
            mConnectivityManager.getNetworkInfo(TEST_NETWORK_TYPE);
            fail(""ConnectivityManager.getNetworkInfo didn't throw SecurityException as""
                    + "" expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that ConnectivityManager#getAllNetworkInfo() requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
     */
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoNetworkStatePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NfcPermissionTest"	"isControllerAlwaysOnSupported"	"CtsPermissionTestCases"	"1: permission"	"([5:/android/permission/cts/NfcPermissionTest.java]:[permission]:[5]:method_text:[* Requires Permission: {@link android.Manifest.permission#NFC_SET_CONTROLLER_ALWAYS_ON}.     */   ]) :|: /*
 *.
 */

package android.permission.cts;

import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import android.content.pm.PackageManager;
import android.nfc.NfcAdapter;
import android.nfc.NfcAdapter.ControllerAlwaysOnListener;
import android.platform.test.annotations.AppModeFull;

import androidx.test.InstrumentationRegistry;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

import java.util.concurrent.Executor;

@RunWith(JUnit4.class)
public final class NfcPermissionTest {

    private NfcAdapter mNfcAdapter;

    private boolean supportsHardware() {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
        return pm.hasSystemFeature(PackageManager.FEATURE_NFC);
    }

    @Before
    public void setUp() {
        assumeTrue(supportsHardware());
        mNfcAdapter = NfcAdapter.getDefaultAdapter(InstrumentationRegistry.getTargetContext());
    }

    /**
     * Verifies that isControllerAlwaysOnSupported() requires Permission.
     * <p>
     * Requires Permission: {@link android.Manifest.permission#NFC_SET_CONTROLLER_ALWAYS_ON}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NfcPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NfcPermissionTest"	"testIsControllerAlwaysOnSupported"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NfcPermissionTest.java]:[permission]:[3]:method_text:[* Requires Permission: {@link android.Manifest.permission#NFC_SET_CONTROLLER_ALWAYS_ON}.     */   ]) :|: 
    @AppModeFull
    public void testIsControllerAlwaysOnSupported() {
        try {
            mNfcAdapter.isControllerAlwaysOnSupported();
            fail(""mNfcAdapter.isControllerAlwaysOnSupported() did not throw SecurityException""
                    + "" as expected"");
        } catch (SecurityException se) {
            // Expected Exception
        }
    }

    /**
     * Verifies that isControllerAlwaysOn() requires Permission.
     * <p>
     * Requires Permission: {@link android.Manifest.permission#NFC_SET_CONTROLLER_ALWAYS_ON}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NfcPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NfcPermissionTest"	"testIsControllerAlwaysOn"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NfcPermissionTest.java]:[permission]:[3]:method_text:[* Requires Permission: {@link android.Manifest.permission#NFC_SET_CONTROLLER_ALWAYS_ON}.     */   ]) :|: 
    @AppModeFull
    public void testIsControllerAlwaysOn() {
        try {
            mNfcAdapter.isControllerAlwaysOn();
            fail(""mNfcAdapter.isControllerAlwaysOn() did not throw SecurityException""
                    + "" as expected"");
        } catch (SecurityException se) {
            // Expected Exception
        }
    }

    /**
     * Verifies that setControllerAlwaysOn(true) requires Permission.
     * <p>
     * Requires Permission: {@link android.Manifest.permission#NFC_SET_CONTROLLER_ALWAYS_ON}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NfcPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NfcPermissionTest"	"testSetControllerAlwaysOnTrue"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NfcPermissionTest.java]:[permission]:[3]:method_text:[* Requires Permission: {@link android.Manifest.permission#NFC_SET_CONTROLLER_ALWAYS_ON}.     */   ]) :|: 
    @AppModeFull
    public void testSetControllerAlwaysOnTrue() {
        try {
            mNfcAdapter.setControllerAlwaysOn(true);
            fail(""mNfcAdapter.setControllerAlwaysOn(true) did not throw SecurityException""
                    + "" as expected"");
        } catch (SecurityException se) {
            // Expected Exception
        }
    }

    /**
     * Verifies that setControllerAlwaysOn(false) requires Permission.
     * <p>
     * Requires Permission: {@link android.Manifest.permission#NFC_SET_CONTROLLER_ALWAYS_ON}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NfcPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NfcPermissionTest"	"testSetControllerAlwaysOnFalse"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NfcPermissionTest.java]:[permission]:[3]:method_text:[* Requires Permission: {@link android.Manifest.permission#NFC_SET_CONTROLLER_ALWAYS_ON}.     */   ]) :|: 
    @AppModeFull
    public void testSetControllerAlwaysOnFalse() {
        try {
            mNfcAdapter.setControllerAlwaysOn(false);
            fail(""mNfcAdapter.setControllerAlwaysOn(true) did not throw SecurityException""
                    + "" as expected"");
        } catch (SecurityException se) {
            // Expected Exception
        }
    }

    /**
     * Verifies that registerControllerAlwaysOnListener() requires Permission.
     * <p>
     * Requires Permission: {@link android.Manifest.permission#NFC_SET_CONTROLLER_ALWAYS_ON}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NfcPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NfcPermissionTest"	"testRegisterControllerAlwaysOnListener"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NfcPermissionTest.java]:[permission]:[3]:method_text:[* Requires Permission: {@link android.Manifest.permission#NFC_SET_CONTROLLER_ALWAYS_ON}.     */   ]) :|: 
    @AppModeFull
    public void testRegisterControllerAlwaysOnListener() {
        try {
            mNfcAdapter.registerControllerAlwaysOnListener(
                    new SynchronousExecutor(), new AlwaysOnStateListener());
            fail(""mNfcAdapter.registerControllerAlwaysOnListener did not throw""
                    + ""SecurityException as expected"");
        } catch (SecurityException se) {
            // Expected Exception
        }
    }

    /**
     * Verifies that unregisterControllerAlwaysOnListener() requires Permission.
     * <p>
     * Requires Permission: {@link android.Manifest.permission#NFC_SET_CONTROLLER_ALWAYS_ON}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NfcPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.ConnectivityManagerPermissionTest"	"testGetNetworkInfo"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/ConnectivityManagerPermissionTest.java]:[permission]:[3]:method_text:[ssion:     *   {@link android.Manifest.permission#CONTROL_OEM_PAID_NETWORK_PREFERENCE}.     */   ]) :|: 
    public void testGetNetworkInfo() {
        try {
            mConnectivityManager.getNetworkInfo(ConnectivityManager.TYPE_MOBILE);
            fail(""Was able to call getNetworkInfo"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that calling {@link ConnectivityManager#setOemNetworkPreference(OemNetworkPreferences,
     * Executor, ConnectivityManager.OnSetOemNetworkPreferenceListener)}
     * requires permissions.
     * <p>Tests Permission:
     *   {@link android.Manifest.permission#CONTROL_OEM_PAID_NETWORK_PREFERENCE}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ConnectivityManagerPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.MainlineNetworkStackPermissionTest"	"testPackageWithMainlineNetworkStackPermission"	"CtsPermissionTestCases"	"1: permission"	"([18:/android/permission/cts/MainlineNetworkStackPermissionTest.java]:[permission]:[18]:method_text:[ package defining "" + PERMISSION_MAINLINE_NETWORK_STACK                + "" is installed."");    }}]) :|: 
    @AppModeFull(reason = ""Instant apps cannot access PackageManager#getPermissionInfo"")
    public void testPackageWithMainlineNetworkStackPermission() throws Exception {
        final PackageManager packageManager = mContext.getPackageManager();
        assertNotNull(""Unable to find PackageManager."", packageManager);

        final PermissionInfo permissioninfo =
                packageManager.getPermissionInfo(PERMISSION_MAINLINE_NETWORK_STACK, 0);
        assertNotNull(""Network stack permission is not defined."", permissioninfo);

        PackageInfo packageInfo = packageManager.getPackageInfo(permissioninfo.packageName,
                PackageManager.MATCH_SYSTEM_ONLY | PackageManager.GET_PERMISSIONS);
        assertNotNull(""Package defining the network stack permission is not a system package."",
                packageInfo.permissions);

        for (PermissionInfo permission : packageInfo.permissions) {
            if (PERMISSION_MAINLINE_NETWORK_STACK.equals(permission.name)) {
                return;
            }
        }

        fail(""Expect a system package defining "" + PERMISSION_MAINLINE_NETWORK_STACK
                + "" is installed."");
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/MainlineNetworkStackPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoWifiStatePermissionTest"	"getWifiState"	"CtsPermissionTestCases"	"1: permission"	"([6:/android/permission/cts/NoWifiStatePermissionTest.java]:[permission]:[6]:method_text:[ <p>Requires Permission:     *   {@link android.Manifest.permission#ACCESS_WIFI_STATE}.     */   ]) :|: public void test/*
 *.
 */

package android.permission.cts;

import android.content.Context;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;
import android.platform.test.annotations.AppModeFull;
import android.test.AndroidTestCase;
import android.test.suitebuilder.annotation.SmallTest;

/**
 * Verify WifiManager related methods without specific Wifi state permissions.
 */
@AppModeFull(reason = ""Instant apps cannot access the WifiManager"")
@SmallTest
public class NoWifiStatePermissionTest extends AndroidTestCase {
    private static final int TEST_NET_ID = 1;
    private static final WifiConfiguration TEST_WIFI_CONFIGURATION = new WifiConfiguration();
    private WifiManager mWifiManager;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mWifiManager = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);
        assertNotNull(mWifiManager);
    }

    /**
     * Verify that WifiManager#getWifiState() requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#ACCESS_WIFI_STATE}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoWifiStatePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoWifiStatePermissionTest"	"testGetWifiState"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NoWifiStatePermissionTest.java]:[permission]:[3]:method_text:[ <p>Requires Permission:     *   {@link android.Manifest.permission#ACCESS_WIFI_STATE}.     */   ]) :|: public void testGetWifiState() {
        try {
            mWifiManager.getWifiState();
            fail(""WifiManager.getWifiState didn't throw SecurityException as expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that WifiManager#getConfiguredNetworks() requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#ACCESS_WIFI_STATE}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoWifiStatePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoWifiStatePermissionTest"	"testGetConfiguredNetworks"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NoWifiStatePermissionTest.java]:[permission]:[3]:method_text:[ <p>Requires Permission:     *   {@link android.Manifest.permission#ACCESS_WIFI_STATE}.     */   ]) :|: public void testGetConfiguredNetworks() {
        try {
            mWifiManager.getConfiguredNetworks();
            fail(""WifiManager.getConfiguredNetworks didn't throw SecurityException as expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that WifiManager#getConnectionInfo() requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#ACCESS_WIFI_STATE}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoWifiStatePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoWifiStatePermissionTest"	"testGetConnectionInfo"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NoWifiStatePermissionTest.java]:[permission]:[3]:method_text:[ <p>Requires Permission:     *   {@link android.Manifest.permission#ACCESS_WIFI_STATE}.     */   ]) :|: public void testGetConnectionInfo() {
        try {
            mWifiManager.getConnectionInfo();
            fail(""WifiManager.getConnectionInfo didn't throw SecurityException as expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that WifiManager#getScanResults() requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#ACCESS_WIFI_STATE}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoWifiStatePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoWifiStatePermissionTest"	"testGetScanResults"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NoWifiStatePermissionTest.java]:[permission]:[3]:method_text:[ <p>Requires Permission:     *   {@link android.Manifest.permission#ACCESS_WIFI_STATE}.     */   ]) :|: public void testGetScanResults() {
        try {
            mWifiManager.getScanResults();
            fail(""WifiManager.getScanResults didn't throw SecurityException as expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that WifiManager#getDhcpInfo() requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#ACCESS_WIFI_STATE}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoWifiStatePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoWifiStatePermissionTest"	"testGetDhcpInfo"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NoWifiStatePermissionTest.java]:[permission]:[3]:method_text:[ <p>Requires Permission:     *   {@link android.Manifest.permission#CHANGE_WIFI_STATE}.     */   ]) :|: public void testGetDhcpInfo() {
        try {
            mWifiManager.getDhcpInfo();
            fail(""WifiManager.getDhcpInfo didn't throw SecurityException as expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that WifiManager#disconnect() requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#CHANGE_WIFI_STATE}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoWifiStatePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoWifiStatePermissionTest"	"testDisconnect"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NoWifiStatePermissionTest.java]:[permission]:[3]:method_text:[ <p>Requires Permission:     *   {@link android.Manifest.permission#CHANGE_WIFI_STATE}.     */   ]) :|: public void testDisconnect() {
        try {
            mWifiManager.disconnect();
            fail(""WifiManager.disconnect didn't throw SecurityException as expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that WifiManager#reconnect() requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#CHANGE_WIFI_STATE}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoWifiStatePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoWifiStatePermissionTest"	"testReconnect"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NoWifiStatePermissionTest.java]:[permission]:[3]:method_text:[ <p>Requires Permission:     *   {@link android.Manifest.permission#CHANGE_WIFI_STATE}.     */   ]) :|: public void testReconnect() {
        try {
            mWifiManager.reconnect();
            fail(""WifiManager.reconnect didn't throw SecurityException as expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that WifiManager#reassociate() requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#CHANGE_WIFI_STATE}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoWifiStatePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoWifiStatePermissionTest"	"testReassociate"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NoWifiStatePermissionTest.java]:[permission]:[3]:method_text:[ <p>Requires Permission:     *   {@link android.Manifest.permission#CHANGE_WIFI_STATE}.     */   ]) :|: public void testReassociate() {
        try {
            mWifiManager.reassociate();
            fail(""WifiManager.reassociate didn't throw SecurityException as expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that WifiManager#addNetwork() requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#CHANGE_WIFI_STATE}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoWifiStatePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoWifiStatePermissionTest"	"testAddNetwork"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NoWifiStatePermissionTest.java]:[permission]:[3]:method_text:[ <p>Requires Permission:     *   {@link android.Manifest.permission#CHANGE_WIFI_STATE}.     */   ]) :|: public void testAddNetwork() {
        try {
            mWifiManager.addNetwork(TEST_WIFI_CONFIGURATION);
            fail(""WifiManager.addNetwork didn't throw SecurityException as expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that WifiManager#updateNetwork() requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#CHANGE_WIFI_STATE}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoWifiStatePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoWifiStatePermissionTest"	"testUpdateNetwork"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NoWifiStatePermissionTest.java]:[permission]:[3]:method_text:[ <p>Requires Permission:     *   {@link android.Manifest.permission#CHANGE_WIFI_STATE}.     */   ]) :|: public void testUpdateNetwork() {
        TEST_WIFI_CONFIGURATION.networkId = 2;

        try {
            mWifiManager.updateNetwork(TEST_WIFI_CONFIGURATION);
            fail(""WifiManager.updateNetwork didn't throw SecurityException as expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that WifiManager#removeNetwork() requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#CHANGE_WIFI_STATE}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoWifiStatePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoWifiStatePermissionTest"	"testRemoveNetwork"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NoWifiStatePermissionTest.java]:[permission]:[3]:method_text:[ <p>Requires Permission:     *   {@link android.Manifest.permission#CHANGE_WIFI_STATE}.     */   ]) :|: public void testRemoveNetwork() {
        try {
            mWifiManager.removeNetwork(TEST_NET_ID);
            fail(""WifiManager.removeNetwork didn't throw SecurityException as expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that WifiManager#enableNetwork() requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#CHANGE_WIFI_STATE}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoWifiStatePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoWifiStatePermissionTest"	"testEnableNetwork"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NoWifiStatePermissionTest.java]:[permission]:[3]:method_text:[ <p>Requires Permission:     *   {@link android.Manifest.permission#CHANGE_WIFI_STATE}.     */   ]) :|: public void testEnableNetwork() {
        try {
            mWifiManager.enableNetwork(TEST_NET_ID, false);
            fail(""WifiManager.enableNetwork didn't throw SecurityException as expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that WifiManager#disableNetwork() requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#CHANGE_WIFI_STATE}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoWifiStatePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoWifiStatePermissionTest"	"testDisableNetwork"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NoWifiStatePermissionTest.java]:[permission]:[3]:method_text:[ <p>Requires Permission:     *   {@link android.Manifest.permission#CHANGE_WIFI_STATE}.     */   ]) :|: public void testDisableNetwork() {
        try {
            mWifiManager.disableNetwork(TEST_NET_ID);
            fail(""WifiManager.disableNetwork didn't throw SecurityException as expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that WifiManager#pingSupplicant() requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#CHANGE_WIFI_STATE}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoWifiStatePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoWifiStatePermissionTest"	"testPingSupplicant"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NoWifiStatePermissionTest.java]:[permission]:[3]:method_text:[ <p>Requires Permission:     *   {@link android.Manifest.permission#CHANGE_WIFI_STATE}.     */   ]) :|: public void testPingSupplicant() {
        try {
            mWifiManager.pingSupplicant();
            fail(""WifiManager.pingSupplicant didn't throw SecurityException as expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that WifiManager#startScan() requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#CHANGE_WIFI_STATE}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoWifiStatePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoWifiStatePermissionTest"	"testStartScan"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NoWifiStatePermissionTest.java]:[permission]:[3]:method_text:[ <p>Requires Permission:     *   {@link android.Manifest.permission#CHANGE_WIFI_STATE}.     */   ]) :|: public void testStartScan() {
        try {
            mWifiManager.startScan();
            fail(""WifiManager.startScan didn't throw SecurityException as expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that WifiManager#setWifiEnabled() requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#CHANGE_WIFI_STATE}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoWifiStatePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.PowerManagerServicePermissionTest"	"testSetBatterySaver_requiresPermissions"	"CtsPermissionTestCases"	"1: permission"	"([2:/android/permission/cts/PowerManagerServicePermissionTest.java]:[permission]:[2]:method_text:[on"");        } catch (SecurityException e) {            // Expected Exception        }    }   ]) :|: public void testSetBatterySaver_requiresPermissions() {
        PowerManager manager = getContext().getSystemService(PowerManager.class);
        boolean batterySaverOn = manager.isPowerSaveMode();

        try {
            manager.setPowerSaveModeEnabled(!batterySaverOn);
            fail(""Toggling battery saver requires POWER_SAVER or DEVICE_POWER permission"");
        } catch (SecurityException e) {
            // Expected Exception
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/PowerManagerServicePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.PowerManagerServicePermissionTest"	"testSetDynamicPowerSavings_requiresPermissions"	"CtsPermissionTestCases"	"1: permission"	"([2:/android/permission/cts/PowerManagerServicePermissionTest.java]:[permission]:[2]:method_text:[on"");        } catch (SecurityException e) {            // Expected Exception        }    }   ]) :|: public void testSetDynamicPowerSavings_requiresPermissions() {
        try {
            PowerManager manager = getContext().getSystemService(PowerManager.class);
            manager.setDynamicPowerSaveHint(true, 0);
            fail(""Updating the dynamic power savings state requires the POWER_SAVER permission"");
        } catch (SecurityException e) {
            // Expected Exception
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/PowerManagerServicePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.PowerManagerServicePermissionTest"	"testSetBatteryDischargePrediction_requiresPermissions"	"CtsPermissionTestCases"	"1: permission"	"([2:/android/permission/cts/PowerManagerServicePermissionTest.java]:[permission]:[2]:method_text:[ssion"");        } catch (SecurityException e) {            // Expected Exception        }    }}]) :|: public void testSetBatteryDischargePrediction_requiresPermissions() {
        try {
            PowerManager manager = getContext().getSystemService(PowerManager.class);
            manager.setBatteryDischargePrediction(Duration.ofMillis(1000), false);
            fail(""Updating the discharge prediction requires the DEVICE_POWER""
                    + "" or BATTERY_PREDICTION permission"");
        } catch (SecurityException e) {
            // Expected Exception
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/PowerManagerServicePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoActivityRelatedPermissionTest"	"NoActivityRelatedPermissionTest"	"CtsPermissionTestCases"	"1: permission"	"([11:/android/permission/cts/NoActivityRelatedPermissionTest.java]:[permission]:[11]:method_text:[uires Permission:     *   {@link android.Manifest.permission#GET_TASKS}     */    @MediumTest   ]) :|: public void test/*
 *.
 */

package android.permission.cts;


import android.app.ActivityManager;
import android.content.Context;
import android.content.Intent;
import android.test.ActivityInstrumentationTestCase2;
import android.test.suitebuilder.annotation.MediumTest;

import java.util.List;

/**
 * Verify the Activity related operations require specific permissions.
 */
public class NoActivityRelatedPermissionTest
        extends ActivityInstrumentationTestCase2<PermissionStubActivity> {

    private PermissionStubActivity mActivity;

    public NoActivityRelatedPermissionTest() {
        super(""android.permission.cts"", PermissionStubActivity.class);
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mActivity = getActivity();
    }

    /**
     * Verify that get task requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#GET_TASKS}
     */
    @MediumTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoActivityRelatedPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoCaptureVideoPermissionTest"	"createVirtualDisplay"	"CtsPermissionTestCases"	"1: permission"	"([7:/android/permission/cts/NoCaptureVideoPermissionTest.java]:[permission]:[7]:method_text:[     *   {@link android.Manifest.permission#CAPTURE_SECURE_VIDEO_OUTPUT}.     */    @SmallTest   ]) :|: public void test/*
 *.
 */

package android.permission.cts;

import android.content.Context;
import android.graphics.PixelFormat;
import android.hardware.display.DisplayManager;
import android.hardware.display.VirtualDisplay;
import android.media.ImageReader;
import android.test.AndroidTestCase;
import android.test.suitebuilder.annotation.SmallTest;
import android.util.DisplayMetrics;

/**
 * Verify the capture system video output permission requirements.
 */
public class NoCaptureVideoPermissionTest extends AndroidTestCase {
    private static final String NAME = ""VirtualDisplayTest"";
    private static final int WIDTH = 720;
    private static final int HEIGHT = 480;
    private static final int DENSITY = DisplayMetrics.DENSITY_MEDIUM;

    /**
     * Verify that DisplayManager.createVirtualDisplay() requires permissions to
     * create public displays.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#CAPTURE_VIDEO_OUTPUT} or
     *   {@link android.Manifest.permission#CAPTURE_SECURE_VIDEO_OUTPUT}.
     */
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoCaptureVideoPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoCaptureVideoPermissionTest"	"testCreatePublicVirtualDisplay"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NoCaptureVideoPermissionTest.java]:[permission]:[3]:method_text:[     *   {@link android.Manifest.permission#CAPTURE_SECURE_VIDEO_OUTPUT}.     */    @SmallTest   ]) :|: public void testCreatePublicVirtualDisplay() {
        DisplayManager displayManager =
                (DisplayManager)mContext.getSystemService(Context.DISPLAY_SERVICE);
        ImageReader reader = ImageReader.newInstance(WIDTH, HEIGHT, PixelFormat.RGBX_8888, 1);
        try {
            displayManager.createVirtualDisplay(NAME, WIDTH, HEIGHT, DENSITY,
                    reader.getSurface(), DisplayManager.VIRTUAL_DISPLAY_FLAG_PUBLIC);
            fail(""DisplayManager.createVirtualDisplay() didn't throw SecurityException ""
                    + ""as expected when creating public virtual display."");
        } catch (SecurityException e) {
            // expected
        } finally {
            reader.close();
        }
    }

    /**
     * Verify that DisplayManager.createVirtualDisplay() requires permissions to
     * create secure displays.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#CAPTURE_SECURE_VIDEO_OUTPUT}.
     */
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoCaptureVideoPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoCaptureVideoPermissionTest"	"testCreateSecureVirtualDisplay"	"CtsPermissionTestCases"	"1: permission"	"([1:/android/permission/cts/NoCaptureVideoPermissionTest.java]:[permission]:[1]:method_text:[isplay() does not requires permissions to     * create private displays.     */    @SmallTest   ]) :|: public void testCreateSecureVirtualDisplay() {
        DisplayManager displayManager =
                (DisplayManager)mContext.getSystemService(Context.DISPLAY_SERVICE);
        ImageReader reader = ImageReader.newInstance(WIDTH, HEIGHT, PixelFormat.RGBX_8888, 1);
        try {
            displayManager.createVirtualDisplay(NAME, WIDTH, HEIGHT, DENSITY,
                    reader.getSurface(), DisplayManager.VIRTUAL_DISPLAY_FLAG_SECURE);
            fail(""DisplayManager.createVirtualDisplay() didn't throw SecurityException ""
                    + ""as expected when creating secure virtual display."");
        } catch (SecurityException e) {
            // expected
        } finally {
            reader.close();
        }
    }

    /**
     * Verify that DisplayManager.createVirtualDisplay() does not requires permissions to
     * create private displays.
     */
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoCaptureVideoPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.SecureElementPermissionTest"	"testSecureElementPrivilegedPermission"	"CtsPermissionTestCases"	"1: permission"	"([4:/android/permission/cts/SecureElementPermissionTest.java]:[permission]:[4]:method_text:[ hold the "" +                 ""SECURE_ELEMENT_PRIVILEGED_OPERATION permission."");        }    }}]) :|: 
    public void testSecureElementPrivilegedPermission() {
        PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();

        List<Integer> specialUids = Arrays.asList(Process.SYSTEM_UID, Process.PHONE_UID);

        List<PackageInfo> holding = pm.getPackagesHoldingPermissions(
                new String[] { SECURE_ELEMENT_PRIVILEGED_PERMISSION },
                PackageManager.MATCH_DISABLED_COMPONENTS);

        List<Integer> nonSpecialPackages = holding.stream()
                .map(pi -> {
                    try {
                        return pm.getPackageUid(pi.packageName, 0);
                    } catch (PackageManager.NameNotFoundException e) {
                        return Process.INVALID_UID;
                    }
                })
                .filter(uid -> !specialUids.contains(uid))
                .collect(Collectors.toList());

        if (nonSpecialPackages.size() > 1) {
            fail(""Only one app on the device is allowed to hold the "" +
                 ""SECURE_ELEMENT_PRIVILEGED_OPERATION permission."");
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/SecureElementPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"isEnabled"	"CtsPermissionTestCases"	"1: permission"	"([27:/android/permission/cts/NearbyDevicesPermissionTest.java]:[permission]:[27]:method_text:[efore    @After    public void uninstallTestApp() {        uninstallApp(TEST_APP_PKG);    }   ]) :|: /*
 *.
 */

package android.permission.cts;

import static android.Manifest.permission.ACCESS_BACKGROUND_LOCATION;
import static android.Manifest.permission.ACCESS_FINE_LOCATION;
import static android.Manifest.permission.BLUETOOTH_CONNECT;
import static android.Manifest.permission.BLUETOOTH_SCAN;
import static android.permission.cts.PermissionUtils.grantPermission;
import static android.permission.cts.PermissionUtils.install;
import static android.permission.cts.PermissionUtils.revokePermission;
import static android.permission.cts.PermissionUtils.uninstallApp;

import static com.android.compatibility.common.util.SystemUtil.runShellCommandOrThrow;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assume.assumeTrue;

import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothManager;
import android.bluetooth.cts.BTAdapterUtils;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.Build;
import android.os.Bundle;
import android.os.SystemClock;
import android.platform.test.annotations.AppModeFull;

import androidx.test.InstrumentationRegistry;
import androidx.test.filters.SdkSuppress;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.CddTest;

import org.junit.After;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Tests the behavior of the
 * {@link android.Manifest.permission_group#NEARBY_DEVICES} permission group
 * under various permutations of grant states.
 */
@RunWith(AndroidJUnit4.class)
@AppModeFull
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.S, codeName = ""S"")
public class NearbyDevicesPermissionTest {
    private static final String TEST_APP_PKG = ""android.permission.cts.appthatrequestpermission"";
    private static final String TEST_APP_AUTHORITY = ""appthatreques"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermission30_Default"	"CtsPermissionTestCases"	"1: permission"	"([1:/android/permission/cts/NearbyDevicesPermissionTest.java]:[permission]:[1]:method_text:[ble {        install(APK_BLUETOOTH_30);        assertScanBluetoothResult(Result.EMPTY);    }   ]) :|: 
    @CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermission30_Default() throws Throwable {
        install(APK_BLUETOOTH_30);
        assertScanBluetoothResult(Result.EMPTY);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermission30_GrantLocation"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NearbyDevicesPermissionTest.java]:[permission]:[3]:method_text:[EST_APP_PKG, ACCESS_BACKGROUND_LOCATION);        assertScanBluetoothResult(Result.FULL);    }   ]) :|: 
    @CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermission30_GrantLocation() throws Throwable {
        install(APK_BLUETOOTH_30);
        grantPermission(TEST_APP_PKG, ACCESS_FINE_LOCATION);
        grantPermission(TEST_APP_PKG, ACCESS_BACKGROUND_LOCATION);
        assertScanBluetoothResult(Result.FULL);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermission31_Default"	"CtsPermissionTestCases"	"1: permission"	"([1:/android/permission/cts/NearbyDevicesPermissionTest.java]:[permission]:[1]:method_text:[{        install(APK_BLUETOOTH_31);        assertScanBluetoothResult(Result.EXCEPTION);    }   ]) :|: 
    @CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermission31_Default() throws Throwable {
        install(APK_BLUETOOTH_31);
        assertScanBluetoothResult(Result.EXCEPTION);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermission31_GrantNearby"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NearbyDevicesPermissionTest.java]:[permission]:[3]:method_text:[ermission(TEST_APP_PKG, BLUETOOTH_SCAN);        assertScanBluetoothResult(Result.EMPTY);    }   ]) :|: 
    @CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermission31_GrantNearby() throws Throwable {
        install(APK_BLUETOOTH_31);
        grantPermission(TEST_APP_PKG, BLUETOOTH_CONNECT);
        grantPermission(TEST_APP_PKG, BLUETOOTH_SCAN);
        assertScanBluetoothResult(Result.EMPTY);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermission31_GrantLocation"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NearbyDevicesPermissionTest.java]:[permission]:[3]:method_text:[PP_PKG, ACCESS_BACKGROUND_LOCATION);        assertScanBluetoothResult(Result.EXCEPTION);    }   ]) :|: 
    @CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermission31_GrantLocation() throws Throwable {
        install(APK_BLUETOOTH_31);
        grantPermission(TEST_APP_PKG, ACCESS_FINE_LOCATION);
        grantPermission(TEST_APP_PKG, ACCESS_BACKGROUND_LOCATION);
        assertScanBluetoothResult(Result.EXCEPTION);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermission31_GrantNearby_GrantLocation"	"CtsPermissionTestCases"	"1: permission"	"([5:/android/permission/cts/NearbyDevicesPermissionTest.java]:[permission]:[5]:method_text:[EST_APP_PKG, ACCESS_BACKGROUND_LOCATION);        assertScanBluetoothResult(Result.FULL);    }   ]) :|: 
    @CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermission31_GrantNearby_GrantLocation() throws Throwable {
        install(APK_BLUETOOTH_31);
        grantPermission(TEST_APP_PKG, BLUETOOTH_CONNECT);
        grantPermission(TEST_APP_PKG, BLUETOOTH_SCAN);
        grantPermission(TEST_APP_PKG, ACCESS_FINE_LOCATION);
        grantPermission(TEST_APP_PKG, ACCESS_BACKGROUND_LOCATION);
        assertScanBluetoothResult(Result.FULL);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermissionNeverForLocation31_Default"	"CtsPermissionTestCases"	"1: permission"	"([1:/android/permission/cts/NearbyDevicesPermissionTest.java]:[permission]:[1]:method_text:[PK_BLUETOOTH_NEVER_FOR_LOCATION_31);        assertScanBluetoothResult(Result.EXCEPTION);    }   ]) :|: 
    @CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermissionNeverForLocation31_Default() throws Throwable {
        install(APK_BLUETOOTH_NEVER_FOR_LOCATION_31);
        assertScanBluetoothResult(Result.EXCEPTION);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermissionNeverForLocation31_GrantNearby"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NearbyDevicesPermissionTest.java]:[permission]:[3]:method_text:[ission(TEST_APP_PKG, BLUETOOTH_SCAN);        assertScanBluetoothResult(Result.FILTERED);    }   ]) :|: 
    @CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermissionNeverForLocation31_GrantNearby() throws Throwable {
        install(APK_BLUETOOTH_NEVER_FOR_LOCATION_31);
        grantPermission(TEST_APP_PKG, BLUETOOTH_CONNECT);
        grantPermission(TEST_APP_PKG, BLUETOOTH_SCAN);
        assertScanBluetoothResult(Result.FILTERED);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermissionNeverForLocation31_GrantLocation"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NearbyDevicesPermissionTest.java]:[permission]:[3]:method_text:[PP_PKG, ACCESS_BACKGROUND_LOCATION);        assertScanBluetoothResult(Result.EXCEPTION);    }   ]) :|: 
    @CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermissionNeverForLocation31_GrantLocation() throws Throwable {
        install(APK_BLUETOOTH_NEVER_FOR_LOCATION_31);
        grantPermission(TEST_APP_PKG, ACCESS_FINE_LOCATION);
        grantPermission(TEST_APP_PKG, ACCESS_BACKGROUND_LOCATION);
        assertScanBluetoothResult(Result.EXCEPTION);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermissionNeverForLocation31_GrantNearby_GrantLocation"	"CtsPermissionTestCases"	"1: permission"	"([5:/android/permission/cts/NearbyDevicesPermissionTest.java]:[permission]:[5]:method_text:[APP_PKG, ACCESS_BACKGROUND_LOCATION);        assertScanBluetoothResult(Result.FILTERED);    }   ]) :|: 
    @CddTest(requirement=""7.4.3/C-6-1"")
    public void testRequestBluetoothPermissionNeverForLocation31_GrantNearby_GrantLocation()
            throws Throwable {
        install(APK_BLUETOOTH_NEVER_FOR_LOCATION_31);
        grantPermission(TEST_APP_PKG, BLUETOOTH_CONNECT);
        grantPermission(TEST_APP_PKG, BLUETOOTH_SCAN);
        grantPermission(TEST_APP_PKG, ACCESS_FINE_LOCATION);
        grantPermission(TEST_APP_PKG, ACCESS_BACKGROUND_LOCATION);
        assertScanBluetoothResult(Result.FILTERED);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermission31_OnBehalfOfDisavowingApp"	"CtsPermissionTestCases"	"1: permission"	"([6:/android/permission/cts/NearbyDevicesPermissionTest.java]:[permission]:[6]:method_text:[uetooth     * scan results; they'd always need to involve the user to gain permissions.     */   ]) :|: 
    public void testRequestBluetoothPermission31_OnBehalfOfDisavowingApp() throws Throwable {
        install(APK_BLUETOOTH_31);
        install(APK_BLUETOOTH_NEVER_FOR_LOCATION_NO_PROVIDER);
        grantPermission(TEST_APP_PKG, BLUETOOTH_CONNECT);
        grantPermission(TEST_APP_PKG, BLUETOOTH_SCAN);
        grantPermission(DISAVOWAL_APP_PKG, BLUETOOTH_CONNECT);
        grantPermission(DISAVOWAL_APP_PKG, BLUETOOTH_SCAN);
        assertScanBluetoothResult(""PROXY"", Result.FILTERED);
    }

    /**
     * Verify that upgrading an app doesn't gain them any access to Bluetooth
     * scan results; they'd always need to involve the user to gain permissions.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermission_Upgrade"	"CtsPermissionTestCases"	"1: permission"	"([7:/android/permission/cts/NearbyDevicesPermissionTest.java]:[permission]:[7]:method_text:[uetooth     * scan results; they'd always need to involve the user to gain permissions.     */   ]) :|: 
    @Ignore
    public void testRequestBluetoothPermission_Upgrade() throws Throwable {
        install(APK_BLUETOOTH_30);
        grantPermission(TEST_APP_PKG, ACCESS_FINE_LOCATION);
        grantPermission(TEST_APP_PKG, ACCESS_BACKGROUND_LOCATION);
        assertScanBluetoothResult(Result.FULL);

        // Upgrading to target a new SDK level means they need to explicitly
        // request the new runtime permission; by default it's denied
        install(APK_BLUETOOTH_31);
        assertScanBluetoothResult(Result.EXCEPTION);

        // If the user does grant it, they can scan again
        grantPermission(TEST_APP_PKG, BLUETOOTH_CONNECT);
        grantPermission(TEST_APP_PKG, BLUETOOTH_SCAN);
        assertScanBluetoothResult(Result.FULL);
    }

    /**
     * Verify that downgrading an app doesn't gain them any access to Bluetooth
     * scan results; they'd always need to involve the user to gain permissions.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NearbyDevicesPermissionTest"	"testRequestBluetoothPermission_Downgrade"	"CtsPermissionTestCases"	"1: permission"	"([11:/android/permission/cts/NearbyDevicesPermissionTest.java]:[permission]:[11]:method_text:[               + "" com.android.bluetooth/.btservice.AdapterService set-test-mode disabled"");    }}]) :|: 
    public void testRequestBluetoothPermission_Downgrade() throws Throwable {
        install(APK_BLUETOOTH_31);
        grantPermission(TEST_APP_PKG, BLUETOOTH_CONNECT);
        grantPermission(TEST_APP_PKG, BLUETOOTH_SCAN);
        grantPermission(TEST_APP_PKG, ACCESS_FINE_LOCATION);
        grantPermission(TEST_APP_PKG, ACCESS_BACKGROUND_LOCATION);
        assertScanBluetoothResult(Result.FULL);

        // Revoking nearby permission means modern app can't scan
        revokePermission(TEST_APP_PKG, BLUETOOTH_CONNECT);
        revokePermission(TEST_APP_PKG, BLUETOOTH_SCAN);
        assertScanBluetoothResult(Result.EXCEPTION);

        // And if they attempt to downgrade, confirm that they can't obtain the
        // split-permission grant from the older non-runtime permissions
        install(APK_BLUETOOTH_30);
        assertScanBluetoothResult(Result.EXCEPTION);
    }

    private void assertScanBluetoothResult(Result expected) {
        assertScanBluetoothResult(null, expected);
    }

    private void assertScanBluetoothResult(String arg, Result expected) {
        SystemClock.sleep(1000); // Wait for location permissions to propagate
        final ContentResolver resolver = InstrumentationRegistry.getTargetContext()
                .getContentResolver();
        final Bundle res = resolver.call(TEST_APP_AUTHORITY, """", arg, null);
        Result actual = Result.values()[res.getInt(Intent.EXTRA_INDEX)];
        assertEquals(expected, actual);
    }

    private boolean supportsBluetooth() {
        return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH);
    }

    private void enableTestMode() {
        runShellCommandOrThrow(""dumpsys activity service""
                + "" com.android.bluetooth/.btservice.AdapterService set-test-mode enabled"");
    }

    private void disableTestMode() {
        runShellCommandOrThrow(""dumpsys activity service""
                + "" com.android.bluetooth/.btservice.AdapterService set-test-mode disa"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NearbyDevicesPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.LocationAccessCheckTest"	"getPermissionControllerPackageName"	"CtsPermissionTestCases"	"1: permission"	"([54:/android/permission/cts/LocationAccessCheckTest.java]:[permission]:[54]:method_text:[    @After    public void locationUnbind() throws Throwable {        unbindService();    }   ]) :|: /*
 *.
 */

package android.permission.cts;

import static android.Manifest.permission.ACCESS_BACKGROUND_LOCATION;
import static android.Manifest.permission.ACCESS_FINE_LOCATION;
import static android.app.AppOpsManager.OPSTR_FINE_LOCATION;
import static android.app.AppOpsManager.OP_FLAGS_ALL_TRUSTED;
import static android.app.Notification.EXTRA_TITLE;
import static android.content.Context.BIND_AUTO_CREATE;
import static android.content.Context.BIND_NOT_FOREGROUND;
import static android.content.Intent.ACTION_BOOT_COMPLETED;
import static android.content.Intent.FLAG_RECEIVER_FOREGROUND;
import static android.location.Criteria.ACCURACY_FINE;
import static android.os.Process.myUserHandle;
import static android.provider.Settings.Secure.LOCATION_ACCESS_CHECK_DELAY_MILLIS;
import static android.provider.Settings.Secure.LOCATION_ACCESS_CHECK_INTERVAL_MILLIS;

import static com.android.compatibility.common.util.SystemUtil.runShellCommand;
import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;
import static com.android.server.job.nano.JobPackageHistoryProto.START_PERIODIC_JOB;
import static com.android.server.job.nano.JobPackageHistoryProto.STOP_JOB;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeFalse;
import static org.junit.Assume.assumeTrue;

import static java.lang.Math.max;
import static java.util.concurrent.TimeUnit.MILLISECONDS;

import android.app.ActivityManager;
import android.app.AppOpsManager;
import android.app.UiAutomation;
import android.content.ComponentName;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.content.pm.PackageManager;
import android.content.pm.Reso"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/LocationAccessCheckTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.LocationAccessCheckTest"	"notificationIsShownAgainAfterClear"	"CtsPermissionTestCases"	"1: permission"	"([4:/android/permission/cts/LocationAccessCheckTest.java]:[permission]:[4]:method_text:[otification(true)), EXPECTED_TIMEOUT_MILLIS);    }    @SystemUserOnly(reason = ""b/172259935"")   ]) :|: 
    @AsbSecurityTest(cveBugId = 141028068)
    public void notificationIsShownAgainAfterClear() throws Throwable {
        assumeNotPlayManaged();
        accessLocation();
        runLocationCheck();

        eventually(() -> assertNotNull(getNotification(true)), EXPECTED_TIMEOUT_MILLIS);

        clearPackageData(TEST_APP_PKG);

        // Wait until package is cleared and permission controller has cleared the state
        Thread.sleep(10000);

        // Clearing removed the permissions, hence grant them again
        grantPermissionToTestApp(ACCESS_FINE_LOCATION);
        grantPermissionToTestApp(ACCESS_BACKGROUND_LOCATION);

        accessLocation();
        runLocationCheck();

        eventually(() -> assertNotNull(getNotification(true)), EXPECTED_TIMEOUT_MILLIS);
    }

    @SystemUserOnly(reason = ""b/172259935"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/LocationAccessCheckTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.LocationAccessCheckTest"	"notificationIsShownAgainAfterUninstallAndReinstall"	"CtsPermissionTestCases"	"1: permission"	"([1:/android/permission/cts/LocationAccessCheckTest.java]:[permission]:[1]:method_text:[        eventually(() -> assertNotNull(getNotification(true)), EXPECTED_TIMEOUT_MILLIS);    }   ]) :|: 
    public void notificationIsShownAgainAfterUninstallAndReinstall() throws Throwable {
        accessLocation();
        runLocationCheck();

        eventually(() -> assertNotNull(getNotification(true)), EXPECTED_TIMEOUT_MILLIS);

        uninstallBackgroundAccessApp();

        // Wait until package permission controller has cleared the state
        Thread.sleep(2000);

        installBackgroundAccessApp();

        accessLocation();
        runLocationCheck();

        eventually(() -> assertNotNull(getNotification(true)), EXPECTED_TIMEOUT_MILLIS);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/LocationAccessCheckTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.LocationAccessCheckTest"	"notificationIsNotShownAfterAppDoesNotRequestLocationAnymore"	"CtsPermissionTestCases"	"1: permission"	"([2:/android/permission/cts/LocationAccessCheckTest.java]:[permission]:[2]:method_text:[tion(false));        } finally {            installBackgroundAccessApp(true);        }    }   ]) :|: 
    public void notificationIsNotShownAfterAppDoesNotRequestLocationAnymore() throws Throwable {
        accessLocation();
        runLocationCheck();

        eventually(() -> assertNotNull(getNotification(true)), EXPECTED_TIMEOUT_MILLIS);

        // Update to app to a version that does not request permission anymore
        installForegroundAccessApp();

        try {
            resetPermissionController();

            runLocationCheck();

            // We don't expect a notification, but try to trigger one anyway
            assertNull(getNotification(false));
        } finally {
            installBackgroundAccessApp(true);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/LocationAccessCheckTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.FileSystemPermissionTest"	"testCreateFileHasSanePermissions"	"CtsPermissionTestCases"	"1: permission"	"([2:/android/permission/cts/FileSystemPermissionTest.java]:[permission]:[2]:method_text:[);        } finally {            assertTrue(myFile.delete());        }    }    @MediumTest   ]) :|: 
    public void testCreateFileHasSanePermissions() throws Exception {
        File myFile = new File(getContext().getFilesDir(), ""hello"");
        FileOutputStream stream = new FileOutputStream(myFile);
        stream.write(""hello world"".getBytes());
        stream.close();
        try {
            FileUtils.FileStatus status = new FileUtils.FileStatus();
            FileUtils.getFileStatus(myFile.getAbsolutePath(), status, false);
            int expectedPerms = FileUtils.S_IFREG
                    | FileUtils.S_IWUSR
                    | FileUtils.S_IRUSR;
            assertEquals(
                    ""Newly created files should have 0600 permissions"",
                    Integer.toOctalString(expectedPerms),
                    Integer.toOctalString(status.mode));
        } finally {
            assertTrue(myFile.delete());
        }
    }

    @MediumTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.FileSystemPermissionTest"	"testCreateDirectoryHasSanePermissions"	"CtsPermissionTestCases"	"1: permission"	"([2:/android/permission/cts/FileSystemPermissionTest.java]:[permission]:[2]:method_text:[);        } finally {            assertTrue(myDir.delete());        }    }    @MediumTest   ]) :|: 
    public void testCreateDirectoryHasSanePermissions() throws Exception {
        File myDir = new File(getContext().getFilesDir(), ""helloDirectory"");
        assertTrue(myDir.mkdir());
        try {
            FileUtils.FileStatus status = new FileUtils.FileStatus();
            FileUtils.getFileStatus(myDir.getAbsolutePath(), status, false);
            int expectedPerms = FileUtils.S_IFDIR
                    | FileUtils.S_IWUSR
                    | FileUtils.S_IRUSR
                    | FileUtils.S_IXUSR;
            assertEquals(
                    ""Newly created directories should have 0700 permissions"",
                    Integer.toOctalString(expectedPerms),
                    Integer.toOctalString(status.mode));

        } finally {
            assertTrue(myDir.delete());
        }
    }

    @MediumTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.FileSystemPermissionTest"	"testMntSecureSane"	"CtsPermissionTestCases"	"1: permission"	"([1:/android/permission/cts/FileSystemPermissionTest.java]:[permission]:[1]:method_text:[ithin unreadable subdirectories     * will NOT be detected by this code.     */    @LargeTest   ]) :|: 
    public void testMntSecureSane() throws Exception {
        final File f = new File(""/mnt/secure"");
        assertFalse(f.canRead());
        assertFalse(f.canWrite());
        assertFalse(f.canExecute());
    }

    private static boolean isDirectoryWritable(File directory) {
        File toCreate = new File(directory, ""hello"");
        try {
            toCreate.createNewFile();
            return true;
        } catch (IOException e) {
            // It's expected we'll get a ""Permission denied"" exception.
        } finally {
            toCreate.delete();
        }
        return false;
    }

    /**
     * Verify that any publicly readable directories reachable from
     * the root directory are not writable.  An application should only be
     * able to write to it's own home directory. World writable directories
     * are a security hole because they enable a number of different attacks.
     * <ul>
     *   <li><a href=""http://en.wikipedia.org/wiki/Symlink_race"">Symlink Races</a></li>
     *   <li>Data destruction by deleting or renaming files you don't own</li>
     *   <li>Data substitution by replacing trusted files with untrusted files</li>
     * </ul>
     *
     * Note: Because not all directories are readable, this is a best-effort
     * test only.  Writable directories within unreadable subdirectories
     * will NOT be detected by this code.
     */
    @LargeTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/FileSystemPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.PermissionManagerTest"	"testRuntimePermissionsVersion"	"CtsPermissionTestCases"	"1: permission"	"([10:/android/permission/cts/PermissionManagerTest.java]:[permission]:[10]:method_text:[sionIdentity(() ->                permissionManager.setRuntimePermissionsVersion(version));    }}]) :|: 
    public void testRuntimePermissionsVersion() throws Exception {
        final PermissionManager permissionManager =
                mContext.getSystemService(PermissionManager.class);
        final int version = callWithShellPermissionIdentity(() ->
                permissionManager.getRuntimePermissionsVersion());
        assertThat(version).isAtLeast(0);
        runWithShellPermissionIdentity(() ->
                permissionManager.setRuntimePermissionsVersion(version));
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/PermissionManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.SmsManagerPermissionTest"	"testSendMultimediaMessage"	"CtsPermissionTestCases"	"1: permission"	"([1:/android/permission/cts/SmsManagerPermissionTest.java]:[permission]:[1]:method_text:[/some-image.png"");        mSmsManager.sendMultimediaMessage(mContext, uri, """", null, null);    }}]) :|: (expected = SecurityException.class)
    public void testSendMultimediaMessage() {
        // Ideally we would provide an Uri to an existing resource, to make sure the
        // SecurityException is not due to the invalid Uri.
        Uri uri = Uri.parse(""android.resource://android.permission.cts/some-image.png"");
        mSmsManager.sendMultimediaMessage(mContext, uri, """", null, null);
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/SmsManagerPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.StorageEscalationTest.kt"	"grantStoragePermissions"	"CtsPermissionTestCases"	"1: permission"	"([15:/android/permission/cts/StorageEscalationTest.kt]:[permission]:[15]:method_text:[rmName,                APP_PACKAGE_NAME) == PackageManager.PERMISSION_GRANTED)        }    }   ]) :|: /*
 *.
 */

package android.permission.cts

import android.Manifest.permission.ACCESS_MEDIA_LOCATION
import android.Manifest.permission.READ_EXTERNAL_STORAGE
import android.Manifest.permission.WRITE_EXTERNAL_STORAGE
import android.app.Instrumentation
import android.app.UiAutomation
import android.content.Context
import android.content.pm.PackageManager
import android.os.Process
import android.os.UserHandle
import android.platform.test.annotations.AppModeFull
import androidx.test.platform.app.InstrumentationRegistry
import com.android.compatibility.common.util.SystemUtil
import org.junit.After
import org.junit.Assert
import org.junit.Assert.assertTrue
import org.junit.Assume.assumeNoException
import org.junit.Before
import org.junit.Test

@AppModeFull
class StorageEscalationTest {
    companion object {
        private const val APK_DIRECTORY = ""/data/local/tmp/cts/permissions""
        const val APP_APK_PATH_28 = ""$APK_DIRECTORY/CtsStorageEscalationApp28.apk""
        const val APP_APK_PATH_29_SCOPED = ""$APK_DIRECTORY/CtsStorageEscalationApp29Scoped.apk""
        const val APP_APK_PATH_29_FULL = ""$APK_DIRECTORY/CtsStorageEscalationApp29Full.apk""
        const val APP_PACKAGE_NAME = ""android.permission3.cts.storageescalation""
        const val DELAY_TIME_MS: Long = 200
        val permissions = listOf<String>(READ_EXTERNAL_STORAGE, WRITE_EXTERNAL_STORAGE,
            ACCESS_MEDIA_LOCATION)
    }

    private val instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation()
    private val context: Context = instrumentation.context
    private val uiAutomation: UiAutomation = instrumentation.uiAutomation
    private var secondaryUserId: Int? = null

    @Before
    @After
    fun uninstallApp() {
        SystemUtil.runShellCommand(""pm uninstall $APP_PACKAGE_NAME --user ALL"")
    }

    private fun installPackage(apk: String) {
        var userString = """"
        secondaryUserId?.let { userId ->
            userString = "" --user $userId""
        }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/StorageEscalationTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.StorageEscalationTest.kt"	"testCannotEscalateWithNewManifestLegacyRequestSecondary"	"CtsPermissionTestCases"	"1: permission"	"([4:/android/permission/cts/StorageEscalationTest.kt]:[permission]:[4]:method_text:[od        Thread.sleep(DELAY_TIME_MS)        assertStoragePermissionState(granted = false)    }}]) :|: 
    fun testCannotEscalateWithNewManifestLegacyRequestSecondary() {
        createSecondaryUser()
        runStorageEscalationTest(APP_APK_PATH_29_SCOPED, APP_APK_PATH_29_FULL)
    }

    private fun runStorageEscalationTest(startPackageApk: String, finishPackageApk: String) {
        installPackage(startPackageApk)
        grantStoragePermissions()
        assertStoragePermissionState(granted = true)
        installPackage(finishPackageApk)
        // permission revoke is async, so wait a short period
        Thread.sleep(DELAY_TIME_MS)
        assertStoragePermissionState(granted = false)
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/StorageEscalationTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.ShellPermissionTest"	"testBlacklistedPermissions"	"CtsPermissionTestCases"	"1: permission"	"([12:/android/permission/cts/ShellPermissionTest.java]:[permission]:[12]:method_text:[al permission "" + permission,                    blacklist.contains(permission));        }    }}]) :|: 
    @AppModeFull(reason = ""Instant apps cannot read properties of other packages. Also the shell ""
            + ""is never an instant app, hence this test does not matter for instant apps."")
    public void testBlacklistedPermissions() throws Exception {
        final Set<String> blacklist = new HashSet<>(Arrays.asList(BLACKLISTED_PERMISSIONS));

        final PackageManager pm = sContext.getPackageManager();
        final String[] pkgs = pm.getPackagesForUid(Process.SHELL_UID);
        assertNotNull(""No SHELL packages were found"", pkgs);
        assertNotEquals(""SHELL package list had 0 size"", 0, pkgs.length);
        String pkg = pkgs[0];

        final PackageInfo packageInfo = pm.getPackageInfo(pkg, PackageManager.GET_PERMISSIONS);
        assertNotNull(""No permissions found for "" + pkg, packageInfo.requestedPermissions);

        for (String permission : packageInfo.requestedPermissions) {
            Log.d(LOG_TAG, ""SHELL as "" + pkg + "" uses permission "" + permission);
            assertFalse(""SHELL as "" + pkg + "" contains the illegal permission "" + permission,
                    blacklist.contains(permission));
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ShellPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoWallpaperPermissionsTest"	"testSetResource"	"CtsPermissionTestCases"	"1: permission"	"([1:/android/permission/cts/NoWallpaperPermissionsTest.java]:[permission]:[1]:method_text:[rify that the setBitmap(...) methods enforce the SET_WALLPAPER permission     */    @SmallTest   ]) :|: public void testSetResource() throws IOException {
        if (wallpaperNotSupported()) {
            return;
        }

        try {
            mWM.setResource(R.drawable.robot);
            fail(""WallpaperManager.setResource(id) did not enforce SET_WALLPAPER"");
        } catch (SecurityException expected) { /* expected */ }

        try {
            mWM.setResource(R.drawable.robot, FLAG_LOCK);
            fail(""WallpaperManager.setResource(id, which) did not enforce SET_WALLPAPER"");
        } catch (SecurityException expected) { /* expected */ }
    }

    /**
     * Verify that the setBitmap(...) methods enforce the SET_WALLPAPER permission
     */
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoWallpaperPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoWallpaperPermissionsTest"	"testSetBitmap"	"CtsPermissionTestCases"	"1: permission"	"([1:/android/permission/cts/NoWallpaperPermissionsTest.java]:[permission]:[1]:method_text:[rify that the setStream(...) methods enforce the SET_WALLPAPER permission     */    @SmallTest   ]) :|: public void testSetBitmap() throws IOException  {
        if (wallpaperNotSupported()) {
            return;
        }

        Bitmap b = Bitmap.createBitmap(160, 120, Bitmap.Config.RGB_565);

        try {
            mWM.setBitmap(b);
            fail(""setBitmap(b) did not enforce SET_WALLPAPER"");
        } catch (SecurityException expected) { /* expected */ }

        try {
            mWM.setBitmap(b, null, false);
            fail(""setBitmap(b, crop, allowBackup) did not enforce SET_WALLPAPER"");
        } catch (SecurityException expected) { /* expected */ }

        try {
            mWM.setBitmap(b, null, false, FLAG_SYSTEM);
            fail(""setBitmap(b, crop, allowBackup, which) did not enforce SET_WALLPAPER"");
        } catch (SecurityException expected) { /* expected */ }
    }

    /**
     * Verify that the setStream(...) methods enforce the SET_WALLPAPER permission
     */
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoWallpaperPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoWallpaperPermissionsTest"	"testSetStream"	"CtsPermissionTestCases"	"1: permission"	"([1:/android/permission/cts/NoWallpaperPermissionsTest.java]:[permission]:[1]:method_text:[that the clearWallpaper(...) methods enforce the SET_WALLPAPER permission     */    @SmallTest   ]) :|: public void testSetStream() throws IOException  {
        if (wallpaperNotSupported()) {
            return;
        }

        ByteArrayInputStream stream = new ByteArrayInputStream(new byte[32]);

        try {
            mWM.setStream(stream);
            fail(""setStream(stream) did not enforce SET_WALLPAPER"");
        } catch (SecurityException expected) { /* expected */ }

        try {
            mWM.setStream(stream, null, false);
            fail(""setStream(stream, crop, allowBackup) did not enforce SET_WALLPAPER"");
        } catch (SecurityException expected) { /* expected */ }

        try {
            mWM.setStream(stream, null, false, FLAG_LOCK);
            fail(""setStream(stream, crop, allowBackup, which) did not enforce SET_WALLPAPER"");
        } catch (SecurityException expected) { /* expected */ }
    }

    /**
     * Verify that the clearWallpaper(...) methods enforce the SET_WALLPAPER permission
     */
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoWallpaperPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.CameraPermissionTest"	"testCamera"	"CtsPermissionTestCases"	"1: permission"	"([1:/android/permission/cts/CameraPermissionTest.java]:[permission]:[1]:method_text:[sn't translating the EPERM error status into            // a SecurityException.        }    }}]) :|: public void testCamera() {
        try {
            (Camera.open()).takePicture(new ShutterCallback(),
                                        new RawPictureCallback(),
                                        new JpegPictureCallback());
            fail(""Was able to take a picture with the camera with no permission"");
        }
        catch (SecurityException e) {
            // expected
        } catch (RuntimeException e) {
            // expected
            // The JNI layer isn't translating the EPERM error status into
            // a SecurityException.
        }
    }

}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/CameraPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.AppIdleStatePermissionTest"	"testChangeAppIdleStatePermission"	"CtsPermissionTestCases"	"1: permission"	"([4:/android/permission/cts/AppIdleStatePermissionTest.java]:[permission]:[4]:method_text:[NGE_APP_IDLE_STATE permission; found packages: \n""                    + pkgNames);        }    }]) :|: 
    public void testChangeAppIdleStatePermission() throws Exception {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
        final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[]{
                android.Manifest.permission.CHANGE_APP_IDLE_STATE
        }, PackageManager.MATCH_SYSTEM_ONLY);

        int count = 0;
        String pkgNames = """";
        for (PackageInfo pkg : holding) {
            int uid = pm.getApplicationInfo(pkg.packageName, 0).uid;
            if (UserHandle.isApp(uid)) {
                pkgNames += pkg.packageName + ""\n"";
                count++;
            }
        }
        if (count > 1) {
            fail(""Only one app may hold the CHANGE_APP_IDLE_STATE permission; found packages: \n""
                    + pkgNames);
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/AppIdleStatePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoWakeLockPermissionTest"	"testWifiLockAcquire"	"CtsPermissionTestCases"	"1: permission"	"([4:/android/permission/cts/NoWakeLockPermissionTest.java]:[permission]:[4]:method_text:[uires Permission:     *   {@link android.Manifest.permission#WAKE_LOCK}.     */    @SmallTest   ]) :|: public void testWifiLockAcquire() {
        final WifiManager wifiManager = (WifiManager) mContext.getSystemService(
                Context.WIFI_SERVICE);
        final WifiLock wifiLock = wifiManager.createWifiLock(""WakeLockPermissionTest"");
        try {
            wifiLock.acquire();
            fail(""WifiManager.WifiLock.acquire() didn't throw SecurityException as expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that MediaPlayer.start() requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#WAKE_LOCK}.
     */
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoWakeLockPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoWakeLockPermissionTest"	"testMediaPlayerWakeLock"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NoWakeLockPermissionTest.java]:[permission]:[3]:method_text:[uires Permission:     *   {@link android.Manifest.permission#WAKE_LOCK}.     */    @SmallTest   ]) :|: public void testMediaPlayerWakeLock() {
        final MediaPlayer mediaPlayer = new MediaPlayer();
        mediaPlayer.setWakeMode(mContext, PowerManager.FULL_WAKE_LOCK);
        try {
            mediaPlayer.start();
            fail(""MediaPlayer.setWakeMode() did not throw SecurityException as expected"");
        } catch (SecurityException e) {
            // expected
        }

        mediaPlayer.stop();
    }

    /**
     * Verify that PowerManager.WakeLock.acquire() requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#WAKE_LOCK}.
     */
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoWakeLockPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoWakeLockPermissionTest"	"testPowerManagerWakeLockAcquire"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NoWakeLockPermissionTest.java]:[permission]:[3]:method_text:[uires Permission:     *   {@link android.Manifest.permission#WAKE_LOCK}.     */    @SmallTest   ]) :|: public void testPowerManagerWakeLockAcquire() {
        try {
            mWakeLock.acquire();
            fail(""WakeLock.acquire() did not throw SecurityException as expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that PowerManager.WakeLock.acquire(long) requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#WAKE_LOCK}.
     */
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoWakeLockPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.ContactsProviderTest"	"testQueryContacts"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/ContactsProviderTest.java]:[permission]:[3]:method_text:[ Requires Permission: {@link android.Manifest.permission#WRITE_CONTACTS}.     */    @SmallTest   ]) :|: public void testQueryContacts() {
        try {
            getContext().getContentResolver().query(ContactsContract.Contacts.CONTENT_URI,
                    null, null, null, null);
            fail(""query(ContactsContract.Contacts.CONTENT_URI) did not throw SecurityException""
                    + "" as expected"");
        } catch (SecurityException se) {
            // Expected Exception
        }
    }

    /**
     * Verifies that insert(ContactsContract.Contacts.CONTENT_URI) requires
     * Permission.
     * <p>
     * Requires Permission: {@link android.Manifest.permission#WRITE_CONTACTS}.
     */
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ContactsProviderTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.ContactsProviderTest"	"testInsertContacts"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/ContactsProviderTest.java]:[permission]:[3]:method_text:[* Requires Permission: {@link android.Manifest.permission#READ_CONTACTS}.     */    @SmallTest   ]) :|: public void testInsertContacts() {
        try {
            getContext().getContentResolver().insert(ContactsContract.Contacts.CONTENT_URI,
                    new ContentValues());
            fail(""insert(ContactsContract.Contacts.CONTENT_URI) did not throw SecurityException""
                    + "" as expected"");
        } catch (SecurityException se) {
            // Expected Exception
        }
    }

    /**
     * Verifies that query(ContactsContract.Profile.CONTENT_URI) requires
     * Permission.
     * <p>
     * Requires Permission: {@link android.Manifest.permission#READ_CONTACTS}.
     */
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ContactsProviderTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.ContactsProviderTest"	"testQueryProfile"	"CtsPermissionTestCases"	"1: permission"	"([5:/android/permission/cts/ContactsProviderTest.java]:[permission]:[5]:method_text:[ Requires Permission: {@link android.Manifest.permission#WRITE_CONTACTS}.     */    @SmallTest   ]) :|: public void testQueryProfile() {
        try {
            getContext().getContentResolver().query(ContactsContract.Profile.CONTENT_URI,
                    null, null, null, null);
            fail(""query(ContactsContract.Profile.CONTENT_URI) did not throw SecurityException""
                    + "" as expected"");
        } catch (SecurityException se) {
            // Expected Exception
        }
    }

    /**
     * Verifies that insert(ContactsContract.Profile.CONTENT_URI) requires
     * Permission. The provider doesn't actually let you do this even if you have the
     * permission, but trying to do it without the permission should throw a
     * SecurityException anyway.
     * <p>
     * Requires Permission: {@link android.Manifest.permission#WRITE_CONTACTS}.
     */
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ContactsProviderTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.ContactsProviderTest"	"testInsertProfile"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/ContactsProviderTest.java]:[permission]:[3]:method_text:[ Requires Permission: {@link android.Manifest.permission#WRITE_CONTACTS}.     */    @SmallTest   ]) :|: public void testInsertProfile() {
        try {
            getContext().getContentResolver().insert(ContactsContract.Profile.CONTENT_URI,
                    new ContentValues(0));
            fail(""insert(ContactsContract.Profile.CONTENT_URI) did not throw SecurityException ""
                    + ""as expected"");
        } catch (SecurityException se) {
            // Expected Exception
        }
    }

    /**
     * Verifies that update(ContactsContract.Profile.CONTENT_URI) requires
     * Permission.
     * <p>
     * Requires Permission: {@link android.Manifest.permission#WRITE_CONTACTS}.
     */
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ContactsProviderTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.ContactsProviderTest"	"testUpdateProfile"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/ContactsProviderTest.java]:[permission]:[3]:method_text:[res Permission: {@link android.Manifest.permission#INTERACT_ACROSS_USERS}.    */    @SmallTest   ]) :|: public void testUpdateProfile() {
        try {
            getContext().getContentResolver().update(ContactsContract.Profile.CONTENT_URI,
                    new ContentValues(0), null, null);
            fail(""update(ContactsContract.Profile.CONTENT_URI) did not throw SecurityException""
                    + "" as expected"");
        } catch (SecurityException se) {
            // Expected Exception
        }
    }

    /**
    * Verifies that query(ContactsContract.CommonDataKinds.Phone.ENTERPRISE_CONTENT_URI) requires
    * Permission.
    * <p>
    * Requires Permission: {@link android.Manifest.permission#INTERACT_ACROSS_USERS}.
    */
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ContactsProviderTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.ContactsProviderTest"	"testQueryPhoneEnterprise"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/ContactsProviderTest.java]:[permission]:[3]:method_text:[res Permission: {@link android.Manifest.permission#INTERACT_ACROSS_USERS}.    */    @SmallTest   ]) :|: public void testQueryPhoneEnterprise() {
        try {
            getContext().getContentResolver().query(
                    ContactsContract.CommonDataKinds.Phone.ENTERPRISE_CONTENT_URI,
                    null, null, null, null);
            fail(""query(ContactsContract.CommonDataKinds.Phone.ENTERPRISE_CONTENT_URI) did not""
                    + "" throw SecurityException as expected"");
        } catch (SecurityException se) {
            // Expected Exception
        }
    }

    /**
    * Verifies that query(ContactsContract.RawContactsEntity.CORP_CONTENT_URI) requires
    * Permission.
    * <p>
    * Requires Permission: {@link android.Manifest.permission#INTERACT_ACROSS_USERS}.
    */
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ContactsProviderTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoReadLogsPermissionTest"	"testLogcat"	"CtsPermissionTestCases"	"1: permission"	"([1:/android/permission/cts/NoReadLogsPermissionTest.java]:[permission]:[1]:method_text:[            if (reader != null) {                reader.close();            }        }    }   ]) :|: public void testLogcat() throws IOException {
        Process logcatProc = null;
        BufferedReader reader = null;
        try {
            logcatProc = Runtime.getRuntime().exec(new String[]
                    {""logcat"", ""-v"", ""brief"", ""-d"", ""ActivityManager:* *:S"" });

            reader = new BufferedReader(new InputStreamReader(logcatProc.getInputStream()));

            int lineCt = 0;
            String line;
            while ((line = reader.readLine()) != null) {
                if (!line.startsWith(""--------- beginning of "")) {
                    lineCt++;
                }
            }

            // no permission get an empty log buffer.
            // Logcat returns only one line:
            // ""--------- beginning of <log device>""

            assertEquals(""Unexpected logcat entries. Are you running the ""
                       + ""the latest logger.c from the Android kernel?"",
                    0, lineCt);

        } finally {
            if (reader != null) {
                reader.close();
            }
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoReadLogsPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoRollbackPermissionTest"	"testCreateInstallSessionWithReasonRollbackFails"	"CtsPermissionTestCases"	"1: permission"	"([2:/android/permission/cts/NoRollbackPermissionTest.java]:[permission]:[2]:method_text:[  assertThrows(SecurityException.class, () -> packageInstaller.createSession(parentParams));    }}]) :|: 
    public void testCreateInstallSessionWithReasonRollbackFails() throws Exception {
        // The INSTALL_REASON_ROLLBACK allows an APK to be rolled back to a previous signing key
        // without setting the ROLLBACK capability in the lineage. Since only signature|privileged
        // apps can hold the necessary permission to initiate a rollback ensure apps without this
        // permission cannot set rollback as the install reason.
        PackageInstaller packageInstaller =
                InstrumentationRegistry.getInstrumentation().getTargetContext().getPackageManager()
                        .getPackageInstaller();
        PackageInstaller.SessionParams parentParams = new PackageInstaller.SessionParams(
                PackageInstaller.SessionParams.MODE_FULL_INSTALL);
        parentParams.setRequestDowngrade(true);
        parentParams.setMultiPackage();
        // The constant PackageManager.INSTALL_REASON_ROLLBACK is hidden from apps, but an app can
        // still use its constant value.
        parentParams.setInstallReason(5);
        assertThrows(SecurityException.class, () -> packageInstaller.createSession(parentParams));
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoRollbackPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.ProviderPermissionTest"	"testReadContacts"	"CtsPermissionTestCases"	"1: permission"	"([5:/android/permission/cts/ProviderPermissionTest.java]:[permission]:[5]:method_text:[     * <p>Tests Permission:     *   {@link android.Manifest.permission#WRITE_CONTACTS}     */   ]) :|: public void testReadContacts() {
        for (Uri uri : CONTACT_URIS) {
            Log.d(TAG, ""Checking contacts URI "" + uri);
            assertReadingContentUriRequiresPermission(uri,
                    android.Manifest.permission.READ_CONTACTS);
        }
    }

    /**
     * Verify that writing contacts requires permissions.
     * <p>Tests Permission:
     *   {@link android.Manifest.permission#WRITE_CONTACTS}
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ProviderPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.ProviderPermissionTest"	"testWriteContacts"	"CtsPermissionTestCases"	"1: permission"	"([5:/android/permission/cts/ProviderPermissionTest.java]:[permission]:[5]:method_text:[ Permission:     *   {@link android.Manifest.permission#READ_CALL_LOG}     */    @AppModeFull   ]) :|: public void testWriteContacts() {
        assertWritingContentUriRequiresPermission(Contacts.People.CONTENT_URI,
                android.Manifest.permission.WRITE_CONTACTS);
    }

    /**
     * Verify that reading call logs requires permissions.
     * <p>Tests Permission:
     *   {@link android.Manifest.permission#READ_CALL_LOG}
     */
    @AppModeFull"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ProviderPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.ProviderPermissionTest"	"testReadCallLog"	"CtsPermissionTestCases"	"1: permission"	"([5:/android/permission/cts/ProviderPermissionTest.java]:[permission]:[5]:method_text:[Permission:     *   {@link android.Manifest.permission#WRITE_CALL_LOG}     */    @AppModeFull   ]) :|: public void testReadCallLog() {
        assertReadingContentUriRequiresPermission(CallLog.CONTENT_URI,
                android.Manifest.permission.READ_CALL_LOG);
    }

    /**
     * Verify that writing call logs requires permissions.
     * <p>Tests Permission:
     *   {@link android.Manifest.permission#WRITE_CALL_LOG}
     */
    @AppModeFull"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ProviderPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.ProviderPermissionTest"	"testWriteCallLog"	"CtsPermissionTestCases"	"1: permission"	"([2:/android/permission/cts/ProviderPermissionTest.java]:[permission]:[2]:method_text:[provider that is not accessible to instant apps)     * returns null     */    @AppModeInstant   ]) :|: public void testWriteCallLog() {
        assertWritingContentUriRequiresPermission(CallLog.CONTENT_URI,
                android.Manifest.permission.WRITE_CALL_LOG);
    }

    /**
     * Verify that reading from call-log (a content provider that is not accessible to instant apps)
     * returns null
     */
    @AppModeInstant"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ProviderPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.ProviderPermissionTest"	"testWriteCallLogInstant"	"CtsPermissionTestCases"	"1: permission"	"([4:/android/permission/cts/ProviderPermissionTest.java]:[permission]:[4]:method_text:[_SMS}     *     * <p>Note: The WRITE_SMS permission has been removed.     */    @AppModeFull   ]) :|: public void testWriteCallLogInstant() {
        try {
            getContext().getContentResolver().insert(CallLog.CONTENT_URI, new ContentValues());
            fail(""Expected IllegalArgumentException"");
        } catch (IllegalArgumentException expected) {
        }
    }

    /**
     * Verify that reading already received SMS messages requires permissions.
     * <p>Tests Permission:
     *   {@link android.Manifest.permission#READ_SMS}
     *
     * <p>Note: The WRITE_SMS permission has been removed.
     */
    @AppModeFull"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ProviderPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.ProviderPermissionTest"	"testReadSms"	"CtsPermissionTestCases"	"1: permission"	"([2:/android/permission/cts/ProviderPermissionTest.java]:[permission]:[2]:method_text:[provider that is not accessible to instant apps)     * returns null     */    @AppModeInstant   ]) :|: public void testReadSms() {
        if (!mContext.getPackageManager().hasSystemFeature(
                PackageManager.FEATURE_TELEPHONY)) {
            return;
        }

        assertReadingContentUriRequiresPermission(Telephony.Sms.CONTENT_URI,
                android.Manifest.permission.READ_SMS);
    }

    /**
     * Verify that reading from 'sms' (a content provider that is not accessible to instant apps)
     * returns null
     */
    @AppModeInstant"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ProviderPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.ProviderPermissionTest"	"testReadSmsInstant"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/ProviderPermissionTest.java]:[permission]:[3]:method_text:[     * <p>Tests Permission:     *   {@link android.Manifest.permission#WRITE_SETTINGS}     */   ]) :|: public void testReadSmsInstant() {
        if (!mContext.getPackageManager().hasSystemFeature(
                PackageManager.FEATURE_TELEPHONY)) {
            return;
        }

        assertNull(getContext().getContentResolver().query(Telephony.Sms.CONTENT_URI, null, null,
                null, null));
    }

    /**
     * Verify that write to settings requires permissions.
     * <p>Tests Permission:
     *   {@link android.Manifest.permission#WRITE_SETTINGS}
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ProviderPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.ProviderPermissionTest"	"testWriteSettings"	"CtsPermissionTestCases"	"1: permission"	"([10:/android/permission/cts/ProviderPermissionTest.java]:[permission]:[10]:method_text:[* {@link android.content.Intent#FLAG_GRANT_READ_URI_PERMISSION} and related     * APIs.     */   ]) :|: public void testWriteSettings() {
        final String permission = android.Manifest.permission.WRITE_SETTINGS;
        ContentValues value = new ContentValues();
        value.put(Settings.System.NAME, ""name"");
        value.put(Settings.System.VALUE, ""value_insert"");

        try {
            getContext().getContentResolver().insert(Settings.System.CONTENT_URI, value);
            fail(""expected SecurityException requiring "" + permission);
        } catch (SecurityException expected) {
            assertNotNull(""security exception's error message."", expected.getMessage());
            assertTrue(""error message should contain \"""" + permission + ""\"". Got: \""""
                    + expected.getMessage() + ""\""."",
                    expected.getMessage().contains(permission));
        }
    }

    /**
     * Verify that the {@link android.Manifest.permission#MANAGE_DOCUMENTS}
     * permission is only held by up to one package: whoever handles the
     * {@link android.content.Intent#ACTION_OPEN_DOCUMENT} intent, if any.
     * <p>
     * No other apps should <em>ever</em> attempt to acquire this permission,
     * since it would give those apps extremely broad access to all storage
     * providers on the device without user involvement in the arbitration
     * process. Apps should instead always rely on Uri permission grants for
     * access, using
     * {@link android.content.Intent#FLAG_GRANT_READ_URI_PERMISSION} and related
     * APIs.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ProviderPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.ProviderPermissionTest"	"testManageDocuments"	"CtsPermissionTestCases"	"1: permission"	"([9:/android/permission/cts/ProviderPermissionTest.java]:[permission]:[9]:method_text:[@code WRITE_MEDIA_STORAGE}, that     * would be a CDD violation and a privacy incident.     */   ]) :|: public void testManageDocuments() {
        final PackageManager pm = getContext().getPackageManager();

        final Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        intent.setType(""*/*"");
        final ResolveInfo ri = pm.resolveActivity(intent, 0);

        if (ri != null) {
            final String validPkg = ri.activityInfo.packageName;

            final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[] {
                    android.Manifest.permission.MANAGE_DOCUMENTS
                    }, PackageManager.MATCH_UNINSTALLED_PACKAGES);
            for (PackageInfo pi : holding) {
                if (!Objects.equals(pi.packageName, validPkg)) {
                    fail(""Exactly one package (must be "" + validPkg
                            + "") can request the MANAGE_DOCUMENTS permission; found package ""
                            + pi.packageName + "" which must be revoked for security reasons"");
                }
            }
        }
    }

    /**
     * The {@link android.Manifest.permission#WRITE_MEDIA_STORAGE} permission is
     * a very powerful permission that grants raw storage access to all devices,
     * and as such it's only appropriate to be granted to the media stack.
     * <p>
     * CDD now requires that all apps requesting this permission also hold the
     * ""Storage"" runtime permission, to give users visibility into the
     * capabilities of each app, and control over those capabilities.
     * <p>
     * If the end user revokes the ""Storage"" permission from an app, but that
     * app still has raw access to storage via {@code WRITE_MEDIA_STORAGE}, that
     * would be a CDD violation and a privacy incident.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ProviderPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.ProviderPermissionTest"	"testWriteMediaStorage"	"CtsPermissionTestCases"	"1: permission"	"([17:/android/permission/cts/ProviderPermissionTest.java]:[permission]:[17]:method_text:[                return true;                }            }        }        return false;    }}]) :|: public void testWriteMediaStorage() throws Exception {
        final UiAutomation ui = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        final PackageManager pm = getContext().getPackageManager();
        final UserHandle userHandle = getContext().getUser();
        final List<PackageInfo> pkgs = pm.getInstalledPackages(
                PackageManager.MATCH_UNINSTALLED_PACKAGES | PackageManager.GET_PERMISSIONS);
        for (PackageInfo pkg : pkgs) {
            final int appUid = userHandle.getAppId(pkg.applicationInfo.uid);
            final boolean isSystem = appUid == android.os.Process.SYSTEM_UID;
            final boolean hasFrontDoor = pm.getLaunchIntentForPackage(pkg.packageName) != null;
            final boolean grantedMedia = pm.checkPermission(WRITE_MEDIA_STORAGE,
                    pkg.packageName) == PackageManager.PERMISSION_GRANTED;

            if (!isSystem && hasFrontDoor && grantedMedia) {
                final boolean requestsStorage = contains(pkg.requestedPermissions,
                        WRITE_EXTERNAL_STORAGE);
                if (!requestsStorage) {
                    fail(""Found "" + pkg.packageName + "" holding WRITE_MEDIA_STORAGE permission ""
                            + ""without also requesting WRITE_EXTERNAL_STORAGE; these permissions ""
                            + ""must be requested together"");
                }

                final boolean grantedStorage = pm.checkPermission(WRITE_EXTERNAL_STORAGE,
                        pkg.packageName) == PackageManager.PERMISSION_GRANTED;
                if (grantedStorage) {
                    final int flags;
                    ui.adoptShellPermissionIdentity(""android.permission.GET_RUNTIME_PERMISSIONS"");
                    try {
                        flags = pm.getPermissionFlags(WRITE_EXTERNAL_STORAGE, pkg.packageName,
                                android.os.Process.myUserHandle());
                    } finally {
                        ui.dropShellPermis"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ProviderPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.RevokePermissionTest.kt"	"testRevokePermission"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/RevokePermissionTest.kt]:[permission]:[3]:method_text:[P_PKG_NAME,                permission = READ_CALENDAR,                isGranted = true)    }   ]) :|: 
    @AppModeFull(reason = ""Instant apps can't revoke permissions."")
    fun testRevokePermission() {
        testRevoke(
                packageName = APP_PKG_NAME,
                permission = READ_CALENDAR,
                isGranted = true)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/RevokePermissionTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.RevokePermissionTest.kt"	"testRevokePermissionNotRequested"	"CtsPermissionTestCases"	"1: permission"	"([4:/android/permission/cts/RevokePermissionTest.kt]:[permission]:[4]:method_text:[Exception::class.java,                throwableMessage = ""has not requested permission"")    }   ]) :|: 
    @AppModeFull(reason = ""Instant apps can't revoke permissions."")
    fun testRevokePermissionNotRequested() {
        testRevoke(
                packageName = APP_PKG_NAME,
                permission = CAMERA,
                throwableType = SecurityException::class.java,
                throwableMessage = ""has not requested permission"")
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/RevokePermissionTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.RevokePermissionTest.kt"	"testRevokeFakePermission"	"CtsPermissionTestCases"	"1: permission"	"([8:/android/permission/cts/RevokePermissionTest.kt]:[permission]:[8]:method_text:[class.java,                throwableMessage = ""Unknown permission: $fakePermissionName"")    }   ]) :|: 
    @AppModeFull(reason = ""Instant apps can't revoke permissions."")
    fun testRevokeFakePermission() {
        val fakePermissionName = ""FAKE_PERMISSION""
        testRevoke(
                packageName = APP_PKG_NAME,
                permission = fakePermissionName,
                throwableType = java.lang.IllegalArgumentException::class.java,
                throwableMessage = ""Unknown permission: $fakePermissionName"")
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/RevokePermissionTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.RevokePermissionTest.kt"	"testRevokeFakePackage"	"CtsPermissionTestCases"	"1: permission"	"([2:/android/permission/cts/RevokePermissionTest.kt]:[permission]:[2]:method_text:[               packageName = fakePackageName,                permission = READ_CALENDAR)    }   ]) :|: 
    @AppModeFull(reason = ""Instant apps can't revoke permissions."")
    fun testRevokeFakePackage() {
        val fakePackageName = ""fake.package.name.which.should.not.exist""
        assertPackageNotInstalled(fakePackageName)
        testRevoke(
                packageName = fakePackageName,
                permission = READ_CALENDAR)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/RevokePermissionTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.RevokePermissionTest.kt"	"testRevokePermissionWithReason"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/RevokePermissionTest.kt]:[permission]:[3]:method_text:[ READ_CALENDAR,                reason = ""test reason"",                isGranted = true)    }   ]) :|: 
    @AppModeFull(reason = ""Instant apps can't revoke permissions."")
    fun testRevokePermissionWithReason() {
        testRevoke(
                packageName = APP_PKG_NAME,
                permission = READ_CALENDAR,
                reason = ""test reason"",
                isGranted = true)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/RevokePermissionTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.RevokePermissionTest.kt"	"testRevokePermissionNotRequestedWithReason"	"CtsPermissionTestCases"	"1: permission"	"([4:/android/permission/cts/RevokePermissionTest.kt]:[permission]:[4]:method_text:[Exception::class.java,                throwableMessage = ""has not requested permission"")    }   ]) :|: 
    @AppModeFull(reason = ""Instant apps can't revoke permissions."")
    fun testRevokePermissionNotRequestedWithReason() {
        testRevoke(
                packageName = APP_PKG_NAME,
                permission = CAMERA,
                reason = ""test reason"",
                throwableType = SecurityException::class.java,
                throwableMessage = ""has not requested permission"")
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/RevokePermissionTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.RevokePermissionTest.kt"	"testRevokeFakePermissionWithReason"	"CtsPermissionTestCases"	"1: permission"	"([8:/android/permission/cts/RevokePermissionTest.kt]:[permission]:[8]:method_text:[class.java,                throwableMessage = ""Unknown permission: $fakePermissionName"")    }   ]) :|: 
    @AppModeFull(reason = ""Instant apps can't revoke permissions."")
    fun testRevokeFakePermissionWithReason() {
        val fakePermissionName = ""FAKE_PERMISSION""
        testRevoke(
                packageName = APP_PKG_NAME,
                permission = fakePermissionName,
                reason = ""test reason"",
                throwableType = java.lang.IllegalArgumentException::class.java,
                throwableMessage = ""Unknown permission: $fakePermissionName"")
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/RevokePermissionTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.RevokePermissionTest.kt"	"testRevokeFakePackageWithReason"	"CtsPermissionTestCases"	"1: permission"	"([16:/android/permission/cts/RevokePermissionTest.kt]:[permission]:[16]:method_text:[        } catch (e: PackageManager.NameNotFoundException) {            // Expected        }    }]) :|: 
    @AppModeFull(reason = ""Instant apps can't revoke permissions."")
    fun testRevokeFakePackageWithReason() {
        val fakePackageName = ""fake.package.name.which.should.not.exist""
        assertPackageNotInstalled(fakePackageName)
        testRevoke(
                packageName = fakePackageName,
                permission = READ_CALENDAR,
                reason = ""test reason"")
    }

    @After
    fun uninstallApp() {
        runShellCommand(""pm uninstall $APP_PKG_NAME"")
    }

    private fun testRevoke(
        packageName: String,
        permission: String,
        reason: String? = null,
        isGranted: Boolean = false,
        throwableType: Class<*>? = null,
        throwableMessage: String = """"
    ) {
        val context = InstrumentationRegistry.getInstrumentation().targetContext
        val pm = context.packageManager

        if (isGranted) {
            assertEquals(PERMISSION_GRANTED, pm.checkPermission(READ_CALENDAR, APP_PKG_NAME))
        }

        runWithShellPermissionIdentity {
            if (throwableType == null) {
                if (reason == null) {
                    pm.revokeRuntimePermission(packageName, permission, Process.myUserHandle())
                } else {
                    pm.revokeRuntimePermission(packageName, permission, Process.myUserHandle(),
                            reason)
                }
            } else {
                try {
                    if (reason == null) {
                        pm.revokeRuntimePermission(packageName, permission, Process.myUserHandle())
                    } else {
                        pm.revokeRuntimePermission(packageName, permission, Process.myUserHandle(),
                                reason)
                    }
                } catch (t: Throwable) {
                    if (t::class.java.name == throwableType.name &&
                            t.message!!.contains(throwableMessage)) {
                        return@runWithShellPermissionIdentity"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/RevokePermissionTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.UndefinedGroupPermissionTest.kt"	"testOtherGroupPermissionsNotGranted_1"	"CtsPermissionTestCases"	"1: permission"	"([2:/android/permission/cts/UndefinedGroupPermissionTest.kt]:[permission]:[2]:method_text:[issionsNotGranted_1() {        testOtherGroupPermissionsNotGranted(CAMERA, RECORD_AUDIO)    }   ]) :|: 
    fun testOtherGroupPermissionsNotGranted_1() {
        testOtherGroupPermissionsNotGranted(CAMERA, RECORD_AUDIO)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/UndefinedGroupPermissionTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.UndefinedGroupPermissionTest.kt"	"testOtherGroupPermissionsNotGranted_2"	"CtsPermissionTestCases"	"1: permission"	"([2:/android/permission/cts/UndefinedGroupPermissionTest.kt]:[permission]:[2]:method_text:[rmissionsNotGranted_2() {        testOtherGroupPermissionsNotGranted(TEST, RECORD_AUDIO)    }   ]) :|: 
    fun testOtherGroupPermissionsNotGranted_2() {
        testOtherGroupPermissionsNotGranted(TEST, RECORD_AUDIO)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/UndefinedGroupPermissionTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.UndefinedGroupPermissionTest.kt"	"testOtherGroupPermissionsNotGranted_3"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/UndefinedGroupPermissionTest.kt]:[permission]:[3]:method_text:[*     * When the custom permission is granted nothing else gets granted as a byproduct.     */   ]) :|: 
    fun testOtherGroupPermissionsNotGranted_3() {
        testOtherGroupPermissionsNotGranted(CAMERA, TEST)
    }

    /**
     * When the custom permission is granted nothing else gets granted as a byproduct.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/UndefinedGroupPermissionTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.UndefinedGroupPermissionTest.kt"	"testCustomPermissionGrantedAlone"	"CtsPermissionTestCases"	"1: permission"	"([48:/android/permission/cts/UndefinedGroupPermissionTest.kt]:[permission]:[48]:method_text:[.PERMISSIONS""        const val TEST = ""android.permission.cts.appthatrequestpermission.TEST""    }]) :|: 
    fun testCustomPermissionGrantedAlone() {
        Assert.assertEquals(mPm!!.checkPermission(CAMERA, APP_PKG_NAME),
                PackageManager.PERMISSION_DENIED)
        Assert.assertEquals(mPm!!.checkPermission(RECORD_AUDIO, APP_PKG_NAME),
                PackageManager.PERMISSION_DENIED)
        Assert.assertEquals(mPm!!.checkPermission(TEST, APP_PKG_NAME),
                PackageManager.PERMISSION_DENIED)
        eventually {
            startRequestActivity(arrayOf(TEST))
            mUiDevice!!.waitForIdle()
            findAllowButton().click()
        }
        eventually {
            Assert.assertEquals(mPm!!.checkPermission(CAMERA, APP_PKG_NAME),
                    PackageManager.PERMISSION_DENIED)
            Assert.assertEquals(mPm!!.checkPermission(RECORD_AUDIO, APP_PKG_NAME),
                    PackageManager.PERMISSION_DENIED)
            Assert.assertEquals(mPm!!.checkPermission(TEST, APP_PKG_NAME),
                    PackageManager.PERMISSION_GRANTED)
        }
    }

    @After
    fun uninstall() {
        SystemUtil.runShellCommand(""pm uninstall $APP_PKG_NAME"")
    }

    fun findAllowButton(): UiObject2 {
        return if (mContext?.packageManager
                        ?.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE) == true) {
            waitFindObject(By.text(mAllowButtonText), 100)
        } else {
            waitFindObject(By.res(
                    ""com.android.permissioncontroller:id/permission_allow_button""),
                    100)
        }
    }

    /**
     * If app has one permission granted, then it can't grant itself another permission for free.
     */
    fun testOtherGroupPermissionsNotGranted(grantedPerm: String, targetPermission: String) {
        // Grant the permission in the background
        SystemUtil.runWithShellPermissionIdentity {
            mPm!!.grantRuntimePermission(
                    APP_PKG_NAME, grantedPerm, Process.myUserHandle())
        }
        Assert.assertEquals(""$grantedPerm no"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/UndefinedGroupPermissionTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoBroadcastPackageRemovedPermissionTest"	"testSendOrRemoveStickyBroadcast"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NoBroadcastPackageRemovedPermissionTest.java]:[permission]:[3]:method_text:[:     *   {@link android.Manifest.permission#BROADCAST_PACKAGE_REMOVED}.     */    @SmallTest   ]) :|: public void testSendOrRemoveStickyBroadcast() {
        try {
            mContext.sendStickyBroadcast(createIntent(Intent.ACTION_WALLPAPER_CHANGED));
            fail(""Context.sendStickyBroadcast did not throw SecurityException as expected"");
        } catch (SecurityException e) {
            // expected
        }

        try {
            mContext.removeStickyBroadcast(createIntent(Intent.ACTION_WALLPAPER_CHANGED));
            fail(""Context.removeStickyBroadcast did not throw SecurityException as expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that Context#sendBroadcast(Intent),
     * Context#sendBroadcast(Intent, String)
     * Context#sendOrderedBroadcast(Intent, String, BroadcastReceiver,
     *                              Handler, int, String, Bundle)
     * Context#sendOrderedBroadcast(Intent, String) with ACTION_UID_REMOVED
     * with ACTION_PACKAGE_REMOVED requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#BROADCAST_PACKAGE_REMOVED}.
     */
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoBroadcastPackageRemovedPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoBroadcastPackageRemovedPermissionTest"	"testSendBroadcast"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NoBroadcastPackageRemovedPermissionTest.java]:[permission]:[3]:method_text:[      Intent intent = new Intent();        intent.setAction(action);        return intent;    }}]) :|: public void testSendBroadcast() {
        try {
            mContext.sendBroadcast(createIntent(Intent.ACTION_PACKAGE_REMOVED));
            fail(""Context.sendBroadcast did not throw SecurityException as expected"");
        } catch (SecurityException e) {
            // expected
        }

        try {
            mContext.sendBroadcast(createIntent(Intent.ACTION_PACKAGE_REMOVED),
                    TEST_RECEIVER_PERMISSION);
            fail(""Context.sendBroadcast did not throw SecurityException as expected"");
        } catch (SecurityException e) {
            // expected
        }

        try {
            mContext.sendOrderedBroadcast(createIntent(Intent.ACTION_PACKAGE_REMOVED),
                    TEST_RECEIVER_PERMISSION, null, null, 0, ""initialData"", Bundle.EMPTY);
            fail(""Context.sendOrderedBroadcast did not throw SecurityException as expected"");
        } catch (SecurityException e) {
            // expected
        }

        try {
            mContext.sendOrderedBroadcast(createIntent(Intent.ACTION_PACKAGE_REMOVED),
                    TEST_RECEIVER_PERMISSION);
            fail(""Context.sendOrderedBroadcast did not throw SecurityException as expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    private Intent createIntent(String action) {
        Intent intent = new Intent();
        intent.setAction(action);
        return intent;
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoBroadcastPackageRemovedPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.ServicePermissionTest"	"testServicePermissions"	"CtsPermissionTestCases"	"1: permission"	"([4:/android/permission/cts/ServicePermissionTest.java]:[permission]:[4]:method_text:[packages outside of the core system: ""                    + failures.toString());        }    }}]) :|: public void testServicePermissions() {
        final PackageManager pm = getContext().getPackageManager();

        final List<String> failures = new ArrayList<>();
        for (String perm : sServicePermissions) {
            final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(
                    new String[] { perm }, PackageManager.MATCH_UNINSTALLED_PACKAGES);
            for (PackageInfo pi : holding) {
                if (!Objects.equals(""android"", pi.packageName)) {
                    failures.add(perm + "" held by "" + pi.packageName);
                }
            }
        }
        if (!failures.isEmpty()) {
            fail(""Found permissions granted to packages outside of the core system: ""
                    + failures.toString());
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ServicePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoSystemFunctionPermissionTest"	"testRestartPackage"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NoSystemFunctionPermissionTest.java]:[permission]:[3]:method_text:[s Permission:     *   {@link android.Manifest.permission#SET_TIME_ZONE}.     */    @SmallTest   ]) :|: public void testRestartPackage() {
        ActivityManager activityManager = (ActivityManager) mContext.getSystemService(
                Context.ACTIVITY_SERVICE);

        try {
            activityManager.restartPackage(""packageName"");
            fail(""ActivityManager.restartPackage() didn't throw SecurityException as expected."");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that AlarmManager.setTimeZone() requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#SET_TIME_ZONE}.
     */
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoSystemFunctionPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoSystemFunctionPermissionTest"	"testSetTimeZone"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NoSystemFunctionPermissionTest.java]:[permission]:[3]:method_text:[  */    @AppModeFull(reason = ""Instant apps cannot access the WallpaperManager"")    @SmallTest   ]) :|: public void testSetTimeZone() {
        AlarmManager alarmManager = (AlarmManager) mContext.getSystemService(
                Context.ALARM_SERVICE);
        String[] timeZones = TimeZone.getAvailableIDs();
        String timeZone = timeZones[0];

        try {
            alarmManager.setTimeZone(timeZone);
            fail(""AlarmManager.setTimeZone() did not throw SecurityException as expected."");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that setting wallpaper relate methods require permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#SET_WALLPAPER}.
     * @throws IOException 
     */
    @AppModeFull(reason = ""Instant apps cannot access the WallpaperManager"")
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoSystemFunctionPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoSystemFunctionPermissionTest"	"testSetWallpaper"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NoSystemFunctionPermissionTest.java]:[permission]:[3]:method_text:[equires Permission:     *   {@link android.Manifest.permission#VIBRATE}.     */    @SmallTest   ]) :|: public void testSetWallpaper() throws IOException {
        if (!WallpaperManager.getInstance(mContext).isWallpaperSupported()) {
            return;
        }

        Bitmap bitmap = Bitmap.createBitmap(1, 1, Bitmap.Config.RGB_565);

        try {
            mContext.setWallpaper(bitmap);
            fail(""Context.setWallpaper(BitMap) did not throw SecurityException as expected."");
        } catch (SecurityException e) {
            // expected
        }

        try {
            mContext.setWallpaper((InputStream) null);
            fail(""Context.setWallpaper(InputStream) did not throw SecurityException as expected."");
        } catch (SecurityException e) {
            // expected
        }

        try {
            mContext.clearWallpaper();
            fail(""Context.clearWallpaper() did not throw SecurityException as expected."");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that Vibrator's vibrating related methods requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#VIBRATE}.
     */
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoSystemFunctionPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoSystemFunctionPermissionTest"	"testVibrator"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NoSystemFunctionPermissionTest.java]:[permission]:[3]:method_text:[<p>Requires Permission:     *   {@link android.Manifest.permission#SMS}.     */    @SmallTest   ]) :|: public void testVibrator() {
        Vibrator vibrator = (Vibrator)getContext().getSystemService(Context.VIBRATOR_SERVICE);

        try {
            vibrator.cancel();
            fail(""Vibrator.cancel() did not throw SecurityException as expected."");
        } catch (SecurityException e) {
            // expected
        }

        try {
            vibrator.vibrate(1);
            fail(""Vibrator.vibrate(long) did not throw SecurityException as expected."");
        } catch (SecurityException e) {
            // expected
        }

        long[] testPattern = {1, 1, 1, 1, 1};

        try {
            vibrator.vibrate(testPattern, 1);
            fail(""Vibrator.vibrate(long[], int) not throw SecurityException as expected."");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that sending sms requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#SMS}.
     */
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoSystemFunctionPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.Camera2PermissionTest"	"getCameraIdList"	"CtsPermissionTestCases"	"1: permission"	"([7:/android/permission/cts/Camera2PermissionTest.java]:[permission]:[7]:method_text:[ to open camera. Requires Permission:     * {@link android.Manifest.permission#CAMERA}.     */   ]) :|: public void test/*
 *.
 */

package android.permission.cts;

import static com.android.ex.camera2.blocking.BlockingStateCallback.*;

import android.content.Context;
import android.hardware.camera2.CameraCharacteristics;
import android.hardware.camera2.CameraCharacteristics.Key;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CameraManager;
import android.os.Handler;
import android.os.HandlerThread;
import android.platform.test.annotations.Presubmit;
import android.test.AndroidTestCase;
import android.util.Log;

import com.android.ex.camera2.blocking.BlockingCameraManager;
import com.android.ex.camera2.blocking.BlockingStateCallback;

import java.util.ArrayList;
import java.util.List;

/**
 * Tests for Camera2 API related Permissions. Currently, this means
 * android.permission.CAMERA.
 */
public class Camera2PermissionTest extends AndroidTestCase {
    private static final String TAG = ""Camera2PermissionTest"";
    private static final boolean VERBOSE = Log.isLoggable(TAG, Log.VERBOSE);
    private static final int CAMERA_CLOSE_TIMEOUT_MS = 2000;

    private CameraManager mCameraManager;
    private CameraDevice mCamera;
    private BlockingStateCallback mCameraListener;
    private String[] mCameraIds;
    protected Handler mHandler;
    protected HandlerThread mHandlerThread;

    @Override
    public void setContext(Context context) {
        super.setContext(context);
        mCameraManager = (CameraManager) context.getSystemService(Context.CAMERA_SERVICE);
        assertNotNull(""Can't connect to camera manager!"", mCameraManager);
    }

    /**
     * Set up the camera2 test case required environments, including CameraManager,
     * HandlerThread, Camera IDs, and CameraStateCallback etc.
     */
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mCameraIds = mCameraManager.getCameraIdList();
        assertNotNull(""Camera ids shouldn't be null"", mCameraIds);
        mHandlerThread = new Handl"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/Camera2PermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.Camera2PermissionTest"	"testCameraOpen"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/Camera2PermissionTest.java]:[permission]:[3]:method_text:[t     * {@link android.Manifest.permission#CAMERA} and android.permission.SYSTEM_CAMERA     */   ]) :|: public void testCameraOpen() throws Exception {
        for (String id : mCameraIds) {
            try {
                openCamera(id);
                fail(""Was able to open camera "" + id + "" with no permission"");
            }
            catch (SecurityException e) {
                // expected
            } finally {
                closeCamera();
            }
        }
    }

    /**
     * Check that no system cameras can be discovered without
     * {@link android.Manifest.permission#CAMERA} and android.permission.SYSTEM_CAMERA
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/Camera2PermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.Camera2PermissionTest"	"testSystemCameraDiscovery"	"CtsPermissionTestCases"	"1: permission"	"([2:/android/permission/cts/Camera2PermissionTest.java]:[permission]:[2]:method_text:[ristics keys that require Permission:     * {@link android.Manifest.permission#CAMERA}.     */   ]) :|: public void testSystemCameraDiscovery() throws Exception {
        for (String id : mCameraIds) {
            Log.i(TAG, ""testSystemCameraDiscovery for camera id "" +  id);
            CameraCharacteristics characteristics = mCameraManager.getCameraCharacteristics(id);
            assertNotNull(""Camera characteristics shouldn't be null"", characteristics);
            int[] availableCapabilities =
                    characteristics.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);
            assertTrue(""Camera capabilities shouldn't be null"", availableCapabilities != null);
            List<Integer> capList = toList(availableCapabilities);
            assertFalse(""System camera device "" + id + "" should not be public"",
                    capList.contains(
                            CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_SYSTEM_CAMERA));
        }
    }

    /**
     * Check the absence of camera characteristics keys that require Permission:
     * {@link android.Manifest.permission#CAMERA}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/Camera2PermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.Camera2PermissionTest"	"testCameraCharacteristicsNeedingPermission"	"CtsPermissionTestCases"	"1: permission"	"([8:/android/permission/cts/Camera2PermissionTest.java]:[permission]:[8]:method_text:[  * Add and remove availability listeners should work without permission.     */    @Presubmit   ]) :|: public void testCameraCharacteristicsNeedingPermission() throws Exception {
        for (String id : mCameraIds) {
            CameraCharacteristics capabilities = mCameraManager.getCameraCharacteristics(id);
            assertNotNull(""Camera characteristics shouldn't be null"", capabilities);
            List<Key<?>> keysNeedingPermission = capabilities.getKeysNeedingPermission();
            if (keysNeedingPermission == null) {
                continue;
            }
            List<Key<?>> keys = capabilities.getKeys();
            assertNotNull(""Camera characteristics key list shouldn't be null"", keys);
            for (Key<?> key : keysNeedingPermission) {
                assertEquals(""Key "" + key.getName() + "" needing permission is part of the"" +
                        "" available characteristics keys"", -1, keys.indexOf(key));
                assertNull(""Key "" + key.getName() + "" needing permission must not present"" +
                        "" in camera characteristics"", capabilities.get(key));
            }
        }
    }

    /**
     * Add and remove availability listeners should work without permission.
     */
    @Presubmit"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/Camera2PermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoKeyPermissionTest"	"testDisableKeyguard"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NoKeyPermissionTest.java]:[permission]:[3]:method_text:[ermission:     *   {@link android.Manifest.permission#DISABLE_KEYGUARD}.     */    @SmallTest   ]) :|: public void testDisableKeyguard() {
        // KeyguardManager was not accessible, pass.
        if (mKeyManager == null) {
            return;
        }
        try {
            mKeyLock.disableKeyguard();
            fail(""KeyguardManager.KeyguardLock.disableKeyguard did not throw SecurityException as""
                    + "" expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that KeyguardManager.KeyguardLock.reenableKeyguard requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#DISABLE_KEYGUARD}.
     */
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoKeyPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoKeyPermissionTest"	"testReenableKeyguard"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/NoKeyPermissionTest.java]:[permission]:[3]:method_text:[ermission:     *   {@link android.Manifest.permission#DISABLE_KEYGUARD}.     */    @SmallTest   ]) :|: public void testReenableKeyguard() {
        // KeyguardManager was not accessible, pass.
        if (mKeyManager == null) {
            return;
        }
        try {
            mKeyLock.reenableKeyguard();
            fail(""KeyguardManager.KeyguardLock.reenableKeyguard did not throw SecurityException as""
                    + "" expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that KeyguardManager.exitKeyguardSecurely requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#DISABLE_KEYGUARD}.
     */
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoKeyPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.PackageManagerRequiringPermissionsTest"	"testSetApplicationEnabledSetting"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/PackageManagerRequiringPermissionsTest.java]:[permission]:[3]:method_text:[res Permission:     *   {@link android.Manifest.permission#SET_PREFERRED_APPLICATIONS}.     */   ]) :|: public void testSetApplicationEnabledSetting() {
        try {
            mPackageManager.setApplicationEnabledSetting(PACKAGE_NAME,
                    PackageManager.COMPONENT_ENABLED_STATE_ENABLED,
                    PackageManager.DONT_KILL_APP);
            fail(""PackageManager.setApplicationEnabledSetting did not throw SecurityException as""
                    + ""expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that PackageManager.addPreferredActivity requires permission.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#SET_PREFERRED_APPLICATIONS}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/PackageManagerRequiringPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.PackageManagerRequiringPermissionsTest"	"testAddPreferredActivity"	"CtsPermissionTestCases"	"1: permission"	"([4:/android/permission/cts/PackageManagerRequiringPermissionsTest.java]:[permission]:[4]:method_text:[always returns null for instant apps ""            + ""(it does not even check for permissions)"")   ]) :|: public void testAddPreferredActivity() {
        try {
            IntentFilter filter = new IntentFilter(Intent.ACTION_MAIN);
            filter.addCategory(Intent.CATEGORY_HOME);
            mPackageManager.addPreferredActivity(filter, 0, null, null);
            fail(""PackageManager.addPreferredActivity did not throw"" +
                    "" SecurityException as expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that PackageManager.clearPackagePreferredActivities requires permission.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#SET_PREFERRED_APPLICATIONS}.
     */
    @AppModeFull(reason = ""clearPackagePreferredActivities always returns null for instant apps ""
            + ""(it does not even check for permissions)"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/PackageManagerRequiringPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.PackageManagerRequiringPermissionsTest"	"testClearPackagePreferredActivities"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/PackageManagerRequiringPermissionsTest.java]:[permission]:[3]:method_text:[ires Permission:     *   {@link android.Manifest.permission#PACKAGE_VERIFICATION_AGENT}     */   ]) :|: public void testClearPackagePreferredActivities() {
        try {
            mPackageManager.clearPackagePreferredActivities(null);
            fail(""PackageManager.clearPackagePreferredActivities did not throw SecurityException""
                    + "" as expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that PackageManager.verifyPendingInstall requires permission.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#PACKAGE_VERIFICATION_AGENT}
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/PackageManagerRequiringPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.PackageManagerRequiringPermissionsTest"	"testVerifyPendingInstall"	"CtsPermissionTestCases"	"1: permission"	"([3:/android/permission/cts/PackageManagerRequiringPermissionsTest.java]:[permission]:[3]:method_text:[res Permission:     *   {@link android.Manifest.permission#PACKAGE_VERIFICATION_AGENT}.     */   ]) :|: public void testVerifyPendingInstall() {
        try {
            mPackageManager.verifyPendingInstall(1, 1);
            fail(""PackageManager.verifyPendingInstall did not throw SecurityException""
                    + "" as expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that PackageManager.extendVerificationTimeout requires permission.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#PACKAGE_VERIFICATION_AGENT}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/PackageManagerRequiringPermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.OneTimePermissionTest"	"testOneTimePermission"	"CtsPermissionTestCases"	"1: permission"	"([1:/android/permission/cts/OneTimePermissionTest.java]:[permission]:[1]:method_text:[_PERIOD);        assertExpectedLifespan(exitTime, ONE_TIME_TIMEOUT_MILLIS);    }    @Ignore   ]) :|: 
    public void testOneTimePermission() throws Throwable {
        startApp();

        CompletableFuture<Long> exitTime = registerAppExitListener();

        clickOneTimeButton();

        exitApp();

        assertGranted(5000);

        assertDenied(ONE_TIME_TIMEOUT_MILLIS + ONE_TIME_TIMER_UPPER_GRACE_PERIOD);

        assertExpectedLifespan(exitTime, ONE_TIME_TIMEOUT_MILLIS);
    }

    @Ignore"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/OneTimePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.OneTimePermissionTest"	"testForegroundServiceMaintainsPermission"	"CtsPermissionTestCases"	"1: permission"	"([1:/android/permission/cts/OneTimePermissionTest.java]:[permission]:[1]:method_text:[_UPPER_GRACE_PERIOD);        assertExpectedLifespan(exitTime, expectedLifespanMillis);    }   ]) :|: 
    public void testForegroundServiceMaintainsPermission() throws Throwable {
        startApp();

        CompletableFuture<Long> exitTime = registerAppExitListener();

        clickOneTimeButton();

        long expectedLifespanMillis = 2 * ONE_TIME_TIMEOUT_MILLIS;
        startAppForegroundService(expectedLifespanMillis, false);

        exitApp();

        assertGranted(5000);

        assertDenied(expectedLifespanMillis + ONE_TIME_TIMER_UPPER_GRACE_PERIOD);

        assertExpectedLifespan(exitTime, expectedLifespanMillis);

    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/OneTimePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.OneTimePermissionTest"	"testPermissionRevokedOnKill"	"CtsPermissionTestCases"	"1: permission"	"([5:/android/permission/cts/OneTimePermissionTest.java]:[permission]:[5]:method_text:[         ""one_time_permissions_killed_delay_millis"", 5000L)));        assertDenied(500);    }   ]) :|: 
    public void testPermissionRevokedOnKill() throws Throwable {
        startApp();

        clickOneTimeButton();

        exitApp();

        assertGranted(5000);

        mUiDevice.waitForIdle();
        SystemUtil.runWithShellPermissionIdentity(() ->
                mActivityManager.killBackgroundProcesses(APP_PKG_NAME));

        runWithShellPermissionIdentity(
                () -> Thread.sleep(DeviceConfig.getLong(DeviceConfig.NAMESPACE_PERMISSIONS,
                ""one_time_permissions_killed_delay_millis"", 5000L)));
        assertDenied(500);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/OneTimePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.OneTimePermissionTest"	"testStickyServiceMaintainsPermissionOnRestart"	"CtsPermissionTestCases"	"1: permission"	"([20:/android/permission/cts/OneTimePermissionTest.java]:[permission]:[20]:method_text:[               mActivityManager.removeOnUidImportanceListener(this);            }        }    }}]) :|: 
    public void testStickyServiceMaintainsPermissionOnRestart() throws Throwable {
        startApp();

        clickOneTimeButton();

        startAppForegroundService(2 * ONE_TIME_TIMEOUT_MILLIS, true);

        exitApp();

        assertGranted(5000);
        mUiDevice.waitForIdle();
        Thread.sleep(ONE_TIME_TIMEOUT_MILLIS);

        runShellCommand(""am crash "" + APP_PKG_NAME);

        eventually(() -> runWithShellPermissionIdentity(() -> {
            if (mActivityManager.getPackageImportance(APP_PKG_NAME) <= IMPORTANCE_CACHED) {
                throw new AssertionError(""App was never killed"");
            }
        }));

        eventually(() -> runWithShellPermissionIdentity(() -> {
            if (mActivityManager.getPackageImportance(APP_PKG_NAME)
                    > IMPORTANCE_FOREGROUND_SERVICE) {
                throw new AssertionError(""Foreground service never resumed"");
            }
            Assert.assertEquals(""Service resumed without permission"",
                    PackageManager.PERMISSION_GRANTED, mContext.getPackageManager()
                            .checkPermission(ACCESS_FINE_LOCATION, APP_PKG_NAME));
        }));
    }

    private void assertGrantedState(String s, int permissionGranted, long timeoutMillis) {
        eventually(() -> Assert.assertEquals(s,
                permissionGranted, mContext.getPackageManager()
                        .checkPermission(ACCESS_FINE_LOCATION, APP_PKG_NAME)), timeoutMillis);
    }

    private void assertGranted(long timeoutMillis) {
        assertGrantedState(""Permission was never granted"", PackageManager.PERMISSION_GRANTED,
                timeoutMillis);
    }

    private void assertDenied(long timeoutMillis) {
        assertGrantedState(""Permission was never revoked"", PackageManager.PERMISSION_DENIED,
                timeoutMillis);
    }

    private void assertExpectedLifespan(CompletableFuture<Long> exitTime, long expectedLifespan)
            throws InterruptedException, java.util."	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/OneTimePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoAudioPermissionTest"	"testSetMicrophoneMute"	"CtsPermissionTestCases"	"1: permission"	"([5:/android/permission/cts/NoAudioPermissionTest.java]:[permission]:[5]:method_text:[t.permission#MODIFY_AUDIO_SETTINGS}.     */    @SuppressWarnings(""deprecation"")    @SmallTest   ]) :|: public void testSetMicrophoneMute() {
        boolean muteState = mAudioManager.isMicrophoneMute();
        int originalMode = mAudioManager.getMode();
        // If there is no permission of MODIFY_AUDIO_SETTINGS, setMicrophoneMute does nothing.
        if (muteState) {
            Log.w(TAG, ""Mic seems muted by hardware! Please unmute and rerrun the test."");
        } else {
            mAudioManager.setMicrophoneMute(!muteState);
            assertEquals(muteState, mAudioManager.isMicrophoneMute());
        }

        // If there is no permission of MODIFY_AUDIO_SETTINGS, setMode does nothing.
        assertTrue(AudioManager.MODE_NORMAL != AudioManager.MODE_RINGTONE);

        mAudioManager.setMode(AudioManager.MODE_NORMAL);
        assertEquals(originalMode, mAudioManager.getMode());

        mAudioManager.setMode(AudioManager.MODE_RINGTONE);
        assertEquals(originalMode, mAudioManager.getMode());
    }

    /**
     * Verify that AudioManager routing methods require permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#MODIFY_AUDIO_SETTINGS}.
     */
    @SuppressWarnings(""deprecation"")
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoAudioPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoAudioPermissionTest"	"testRouting"	"CtsPermissionTestCases"	"1: permission"	"([4:/android/permission/cts/NoAudioPermissionTest.java]:[permission]:[4]:method_text:[quire permission     * {@link android.Manifest.permission#RECORD_AUDIO}.     */    @SmallTest   ]) :|: public void testRouting() {

        // If there is no permission of MODIFY_AUDIO_SETTINGS, setSpeakerphoneOn does nothing.
        boolean prevState = mAudioManager.isSpeakerphoneOn();
        mAudioManager.setSpeakerphoneOn(!prevState);
        assertEquals(prevState, mAudioManager.isSpeakerphoneOn());

        // If there is no permission of MODIFY_AUDIO_SETTINGS, setBluetoothScoOn does nothing.
        prevState = mAudioManager.isBluetoothScoOn();
        mAudioManager.setBluetoothScoOn(!prevState);
        assertEquals(prevState, mAudioManager.isBluetoothScoOn());
    }

    /**
     * Verify that {@link android.media.AudioRecord.Builder#build} and
     * {@link android.media.AudioRecord#AudioRecord} require permission
     * {@link android.Manifest.permission#RECORD_AUDIO}.
     */
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoAudioPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.NoAudioPermissionTest"	"testRecordPermission"	"CtsPermissionTestCases"	"1: permission"	"([1:/android/permission/cts/NoAudioPermissionTest.java]:[permission]:[1]:method_text:[e();        record.release();        assertEquals(AudioRecord.STATE_UNINITIALIZED, state);    }}]) :|: public void testRecordPermission() {
        if (!hasMicrophone()) return;

        // test builder
        assertThrows(java.lang.UnsupportedOperationException.class, () -> {
            final AudioRecord record = new AudioRecord.Builder().build();
            record.release();
        });

        // test constructor
        final int sampleRate = 8000;
        final int halfSecondInBytes = sampleRate;
        AudioRecord record = new AudioRecord(
                MediaRecorder.AudioSource.DEFAULT, sampleRate, AudioFormat.CHANNEL_IN_MONO,
                AudioFormat.ENCODING_PCM_16BIT, halfSecondInBytes);
        final int state = record.getState();
        record.release();
        assertEquals(AudioRecord.STATE_UNINITIALIZED, state);
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/NoAudioPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.BackgroundPermissionButtonLabelTest"	"getPermissionControllerPackageName"	"CtsPermissionTestCases"	"1: permission"	"([7:/android/permission/cts/BackgroundPermissionButtonLabelTest.java]:[permission]:[7]:method_text:[sionController =            mContext.getPackageManager().getPermissionControllerPackageName();   ]) :|: /*
 *.
 */

package android.permission.cts;

import android.content.Context;
import android.content.pm.PackageManager;

import androidx.test.platform.app.InstrumentationRegistry;

import org.junit.Assert;
import org.junit.Test;

public class BackgroundPermissionButtonLabelTest {

    // Name of the resource which provides background permission button string
    public static final String APP_PERMISSION_BUTTON_ALLOW_ALWAYS =
            ""app_permission_button_allow_always"";

    private final Context mContext =
            InstrumentationRegistry.getInstrumentation().getTargetContext();
    private final String mPermissionController =
            mContext.getPackageManager().getPermissionControllerPackageName();"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/BackgroundPermissionButtonLabelTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission.cts.BackgroundPermissionButtonLabelTest"	"testBackgroundPermissionButtonLabel"	"CtsPermissionTestCases"	"1: permission"	"([8:/android/permission/cts/BackgroundPermissionButtonLabelTest.java]:[permission]:[8]:method_text:[ageManager.NameNotFoundException e) {            throw new RuntimeException(e);        }    }}]) :|: 
    public void testBackgroundPermissionButtonLabel() {
        try {
            Context permissionControllerContext =
                    mContext.createPackageContext(mPermissionController, 0);
            int stringId = permissionControllerContext.getResources().getIdentifier(
                    APP_PERMISSION_BUTTON_ALLOW_ALWAYS, ""string"",
                    ""com.android.permissioncontroller"");

            Assert.assertEquals(mContext.getPackageManager().getBackgroundPermissionOptionLabel(),
                    permissionControllerContext.getString(stringId));
        } catch (PackageManager.NameNotFoundException e) {
            throw new RuntimeException(e);
        }

    }

}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/BackgroundPermissionButtonLabelTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.appops.cts.DiscreteAppopsTest.kt"	"setUpTest"	"CtsAppOpsTestCases"	"1: permission"	"([10:/android/app/appops/cts/DiscreteAppopsTest.kt]:[permission]:[10]:method_text:[IVACY + "" "" +                PROPERTY_OPS_LIST + "" "" + previousDiscreteHistoryOpsCslist)    }   ]) :|: /*
 *.
 */

package android.app.appops.cts

import android.app.AppOpsManager
import android.app.AppOpsManager.HISTORICAL_MODE_ENABLED_ACTIVE
import android.app.AppOpsManager.HISTORICAL_MODE_ENABLED_PASSIVE
import android.app.AppOpsManager.HistoricalOps
import android.app.AppOpsManager.HISTORY_FLAG_AGGREGATE
import android.app.AppOpsManager.HISTORY_FLAG_DISCRETE
import android.app.AppOpsManager.HISTORY_FLAGS_ALL
import android.app.AppOpsManager.KEY_FG_SERVICE_STATE_SETTLE_TIME
import android.app.AppOpsManager.KEY_TOP_STATE_SETTLE_TIME
import android.app.AppOpsManager.KEY_BG_STATE_SETTLE_TIME
import android.app.AppOpsManager.MODE_ALLOWED
import android.app.AppOpsManager.MODE_IGNORED
import android.app.AppOpsManager.OPSTR_CAMERA
import android.app.AppOpsManager.OPSTR_FINE_LOCATION
import android.app.AppOpsManager.OP_FLAGS_ALL
import android.app.AppOpsManager.OP_FLAG_SELF
import android.app.AppOpsManager.OP_FLAG_TRUSTED_PROXIED
import android.app.AppOpsManager.UID_STATE_CACHED
import android.app.AppOpsManager.UID_STATE_PERSISTENT
import android.content.ComponentName
import android.content.Context
import android.content.Intent
import android.content.ServiceConnection
import android.os.IBinder
import android.platform.test.annotations.AppModeFull
import android.provider.DeviceConfig
import android.provider.DeviceConfig.NAMESPACE_PRIVACY
import android.provider.Settings
import androidx.test.platform.app.InstrumentationRegistry
import androidx.test.uiautomator.UiDevice
import com.android.compatibility.common.util.SystemUtil
import com.google.common.truth.Truth.assertThat
import org.junit.After
import org.junit.Assert
import org.junit.Before
import org.junit.Test
import java.util.concurrent.CompletableFuture
import java.util.concurrent.locks.ReentrantLock
import java.util.concurrent.TimeUnit
import java.util.function.Consumer

private const val PACKAGE_NAME = ""android.app.appops.cts.appfordiscretetest""
private const val TIMEOUT_MILLIS = 45000L
private const val DEFAULT_TIME_Q"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appop/src/android/app/appops/cts/DiscreteAppopsTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.appops.cts.DiscreteAppopsTest.kt"	"testTimeTravel"	"CtsAppOpsTestCases"	"1: permission"	"([1:/android/app/appops/cts/DiscreteAppopsTest.kt]:[permission]:[1]:method_text:[cessTime(OP_FLAGS_ALL))                .isEqualTo(timeStamp - DEFAULT_TIME_QUANT_MILLIS)    }   ]) :|: 
    fun testTimeTravel() {
        waitUntilSafelyInTimeQuant(DEFAULT_TIME_QUANT_MILLIS, SAFETY_MARGIN_MILLIS)
        val timeStamp = System.currentTimeMillis() /
                DEFAULT_TIME_QUANT_MILLIS * DEFAULT_TIME_QUANT_MILLIS
        noteOp(OPSTR_CAMERA, uid, PACKAGE_NAME, null, null)

        var allOps = getHistoricalOps()

        assertThat(allOps).isNotNull()
        assertThat(allOps!!.uidCount).isEqualTo(1)

        var uidOps = allOps.getUidOpsAt(0)
        assertThat(uidOps).isNotNull()
        assertThat(uidOps.uid).isEqualTo(uid)
        assertThat(uidOps.packageCount).isEqualTo(1)

        var packageOps = uidOps.getPackageOpsAt(0)
        assertThat(packageOps).isNotNull()
        assertThat(packageOps.packageName).isEqualTo(PACKAGE_NAME)
        assertThat(packageOps.opCount).isEqualTo(1)

        var op = packageOps.getOpAt(0)
        assertThat(op).isNotNull()
        assertThat(op.opName).isEqualTo(OPSTR_CAMERA)
        assertThat(op.discreteAccessCount).isEqualTo(1)
        var discrete = op.getDiscreteAccessAt(0)

        assertThat(discrete.getLastDuration(OP_FLAGS_ALL)).isEqualTo(-1)
        assertThat(discrete.getLastAccessTime(OP_FLAGS_ALL)).isEqualTo(timeStamp)
        runWithShellPermissionIdentity {
            appOpsManager.offsetHistory(DEFAULT_TIME_QUANT_MILLIS)
        }

        allOps = getHistoricalOps()
        assertThat(allOps).isNotNull()
        assertThat(allOps!!.uidCount).isEqualTo(1)

        uidOps = allOps.getUidOpsAt(0)
        assertThat(uidOps).isNotNull()
        assertThat(uidOps.uid).isEqualTo(uid)
        assertThat(uidOps.packageCount).isEqualTo(1)

        packageOps = uidOps.getPackageOpsAt(0)
        assertThat(packageOps).isNotNull()
        assertThat(packageOps.packageName).isEqualTo(PACKAGE_NAME)
        assertThat(packageOps.opCount).isEqualTo(1)

        op = packageOps.getOpAt(0)
        assertThat(op).isNotNull()
        assertThat(op.opName).isEqualTo(OPSTR_CAMERA)
        assertThat(op.discret"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appop/src/android/app/appops/cts/DiscreteAppopsTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.appops.cts.DiscreteAppopsTest.kt"	"testHistoryTimeParameter"	"CtsAppOpsTestCases"	"1: permission"	"([1:/android/app/appops/cts/DiscreteAppopsTest.kt]:[permission]:[1]:method_text:[        assertThat(allOps).isNotNull()        assertThat(allOps!!.uidCount).isEqualTo(0)    }   ]) :|: 
    fun testHistoryTimeParameter() {
        waitUntilSafelyInTimeQuant(DEFAULT_TIME_QUANT_MILLIS, SAFETY_MARGIN_MILLIS)
        var timeStamp = System.currentTimeMillis() /
                DEFAULT_TIME_QUANT_MILLIS * DEFAULT_TIME_QUANT_MILLIS - TEN_MINUTES_MILLIS
        noteOp(OPSTR_CAMERA, uid, PACKAGE_NAME)

        runWithShellPermissionIdentity {
            appOpsManager.offsetHistory(TEN_MINUTES_MILLIS)
        }

        var allOps = getHistoricalOps()

        assertThat(allOps).isNotNull()
        assertThat(allOps!!.uidCount).isEqualTo(1)

        var uidOps = allOps.getUidOpsAt(0)
        assertThat(uidOps).isNotNull()
        assertThat(uidOps.uid).isEqualTo(uid)
        assertThat(uidOps.packageCount).isEqualTo(1)

        var packageOps = uidOps.getPackageOpsAt(0)
        assertThat(packageOps).isNotNull()
        assertThat(packageOps.packageName).isEqualTo(PACKAGE_NAME)
        assertThat(packageOps.opCount).isEqualTo(1)

        var op = packageOps.getOpAt(0)
        assertThat(op).isNotNull()
        assertThat(op.opName).isEqualTo(OPSTR_CAMERA)
        assertThat(op.discreteAccessCount).isEqualTo(1)
        var discrete = op.getDiscreteAccessAt(0)

        assertThat(discrete.getLastDuration(OP_FLAGS_ALL)).isEqualTo(-1)
        assertThat(discrete.getLastAccessTime(OP_FLAGS_ALL))
                .isEqualTo(timeStamp)

        allOps = getHistoricalOps(HISTORY_FLAGS_ALL, null, OP_FLAGS_ALL,
                System.currentTimeMillis() - ONE_MINUTE_MILLIS, Long.MAX_VALUE)
        assertThat(allOps).isNotNull()
        assertThat(allOps!!.uidCount).isEqualTo(0)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appop/src/android/app/appops/cts/DiscreteAppopsTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.appops.cts.DiscreteAppopsTest.kt"	"testCutoffTime"	"CtsAppOpsTestCases"	"1: permission"	"([2:/android/app/appops/cts/DiscreteAppopsTest.kt]:[permission]:[2]:method_text:[        assertThat(allOps).isNotNull()        assertThat(allOps!!.uidCount).isEqualTo(0)    }   ]) :|: 
    fun testCutoffTime() {
        runWithShellPermissionIdentity {
            DeviceConfig.setProperty(NAMESPACE_PRIVACY, PROPERTY_CUTOFF, 120000L.toString(), false)
        }
        // Pause to give the AppOpsService (DiscreteRegistry) time to pick up the new value.
        Thread.sleep(1000)

        waitUntilSafelyInTimeQuant(DEFAULT_TIME_QUANT_MILLIS, SAFETY_MARGIN_MILLIS)
        val timeStamp = System.currentTimeMillis() /
                DEFAULT_TIME_QUANT_MILLIS * DEFAULT_TIME_QUANT_MILLIS

        noteOp(OPSTR_CAMERA, uid, PACKAGE_NAME)
        var allOps = getHistoricalOps()
        assertThat(allOps).isNotNull()
        assertThat(allOps!!.uidCount).isEqualTo(1)

        var uidOps = allOps.getUidOpsAt(0)
        assertThat(uidOps).isNotNull()
        assertThat(uidOps.uid).isEqualTo(uid)
        assertThat(uidOps.packageCount).isEqualTo(1)

        var packageOps = uidOps.getPackageOpsAt(0)
        assertThat(packageOps).isNotNull()
        assertThat(packageOps.packageName).isEqualTo(PACKAGE_NAME)
        assertThat(packageOps.opCount).isEqualTo(1)

        var op = packageOps.getOpAt(0)
        assertThat(op).isNotNull()
        assertThat(op.opName).isEqualTo(OPSTR_CAMERA)
        assertThat(op.discreteAccessCount).isEqualTo(1)
        var discrete = op.getDiscreteAccessAt(0)

        assertThat(discrete.getLastDuration(OP_FLAGS_ALL)).isEqualTo(-1)
        assertThat(discrete.getLastAccessTime(OP_FLAGS_ALL)).isEqualTo(timeStamp)

        runWithShellPermissionIdentity {
            appOpsManager.offsetHistory(180000)
        }

        allOps = getHistoricalOps()
        assertThat(allOps).isNotNull()
        assertThat(allOps!!.uidCount).isEqualTo(0)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appop/src/android/app/appops/cts/DiscreteAppopsTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.appops.cts.DiscreteAppopsTest.kt"	"testOperationWithDuration"	"CtsAppOpsTestCases"	"1: permission"	"([2:/android/app/appops/cts/DiscreteAppopsTest.kt]:[permission]:[2]:method_text:[MILLIS)        assertThat(discrete.getLastAccessTime(OP_FLAGS_ALL)).isEqualTo(timestamp)    }   ]) :|: 
    fun testOperationWithDuration() {
        setQuantization(SHORT_TIME_QUANT_MILLIS)
        waitUntilNextQuantStarts(SHORT_TIME_QUANT_MILLIS)
        val timestamp = System.currentTimeMillis() /
                SHORT_TIME_QUANT_MILLIS * SHORT_TIME_QUANT_MILLIS

        runWithShellPermissionIdentity {
            appOpsManager.startOp(OPSTR_CAMERA, uid, PACKAGE_NAME, null, null)
        }

        // First test that unfinished op was added without duration
        var allOps = getHistoricalOps()
        assertThat(allOps).isNotNull()
        assertThat(allOps!!.uidCount).isEqualTo(1)

        var uidOps = allOps.getUidOpsAt(0)
        assertThat(uidOps).isNotNull()
        assertThat(uidOps.uid).isEqualTo(uid)
        assertThat(uidOps.packageCount).isEqualTo(1)

        var packageOps = uidOps.getPackageOpsAt(0)
        assertThat(packageOps).isNotNull()
        assertThat(packageOps.packageName).isEqualTo(PACKAGE_NAME)
        assertThat(packageOps.opCount).isEqualTo(1)

        var op = packageOps.getOpAt(0)
        assertThat(op).isNotNull()
        assertThat(op.opName).isEqualTo(OPSTR_CAMERA)
        assertThat(op.discreteAccessCount).isEqualTo(1)
        var discrete = op.getDiscreteAccessAt(0)

        assertThat(discrete.getLastDuration(OP_FLAGS_ALL)).isEqualTo(-1)
        assertThat(discrete.getLastAccessTime(OP_FLAGS_ALL)).isEqualTo(timestamp)
        Thread.sleep(SHORT_TIME_QUANT_MILLIS)
        runWithShellPermissionIdentity {
            appOpsManager.finishOp(OPSTR_CAMERA, uid, PACKAGE_NAME, null)
        }

        allOps = getHistoricalOps()
        assertThat(allOps).isNotNull()
        assertThat(allOps!!.uidCount).isEqualTo(1)

        uidOps = allOps.getUidOpsAt(0)
        assertThat(uidOps).isNotNull()
        assertThat(uidOps.uid).isEqualTo(uid)
        assertThat(uidOps.packageCount).isEqualTo(1)

        packageOps = uidOps.getPackageOpsAt(0)
        assertThat(packageOps).isNotNull()
        assertThat(packageOps.packageName).isEqualTo"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appop/src/android/app/appops/cts/DiscreteAppopsTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.appops.cts.DiscreteAppopsTest.kt"	"testOperationWithDurationForcedSavedDuringTransaction"	"CtsAppOpsTestCases"	"1: permission"	"([3:/android/app/appops/cts/DiscreteAppopsTest.kt]:[permission]:[3]:method_text:[MILLIS)        assertThat(discrete.getLastAccessTime(OP_FLAGS_ALL)).isEqualTo(timestamp)    }   ]) :|: 
    fun testOperationWithDurationForcedSavedDuringTransaction() {
        setQuantization(SHORT_TIME_QUANT_MILLIS)
        waitUntilNextQuantStarts(SHORT_TIME_QUANT_MILLIS)
        val timestamp = System.currentTimeMillis() /
                SHORT_TIME_QUANT_MILLIS * SHORT_TIME_QUANT_MILLIS

        runWithShellPermissionIdentity {
            appOpsManager.startOp(OPSTR_CAMERA, uid, PACKAGE_NAME, null, null)
        }

        // Force persistence
        runWithShellPermissionIdentity {
            appOpsManager.offsetHistory(0)
        }

        // First test that unfinished op was added without duration
        var allOps = getHistoricalOps()
        assertThat(allOps).isNotNull()
        assertThat(allOps!!.uidCount).isEqualTo(1)

        var uidOps = allOps.getUidOpsAt(0)
        assertThat(uidOps).isNotNull()
        assertThat(uidOps.uid).isEqualTo(uid)
        assertThat(uidOps.packageCount).isEqualTo(1)

        var packageOps = uidOps.getPackageOpsAt(0)
        assertThat(packageOps).isNotNull()
        assertThat(packageOps.packageName).isEqualTo(PACKAGE_NAME)
        assertThat(packageOps.opCount).isEqualTo(1)

        var op = packageOps.getOpAt(0)
        assertThat(op).isNotNull()
        assertThat(op.opName).isEqualTo(OPSTR_CAMERA)
        assertThat(op.discreteAccessCount).isEqualTo(1)
        var discrete = op.getDiscreteAccessAt(0)

        assertThat(discrete.getLastDuration(OP_FLAGS_ALL)).isEqualTo(-1)
        assertThat(discrete.getLastAccessTime(OP_FLAGS_ALL)).isEqualTo(timestamp)
        Thread.sleep(SHORT_TIME_QUANT_MILLIS)
        runWithShellPermissionIdentity {
            appOpsManager.finishOp(OPSTR_CAMERA, uid, PACKAGE_NAME, null)
        }

        allOps = getHistoricalOps()
        assertThat(allOps).isNotNull()
        assertThat(allOps!!.uidCount).isEqualTo(1)

        uidOps = allOps.getUidOpsAt(0)
        assertThat(uidOps).isNotNull()
        assertThat(uidOps.uid).isEqualTo(uid)
        assertThat(uidOps.packageCount).isEq"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appop/src/android/app/appops/cts/DiscreteAppopsTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.appops.cts.DiscreteAppopsTest.kt"	"testOpFlagsAndDeduplication"	"CtsAppOpsTestCases"	"1: permission"	"([1:/android/app/appops/cts/DiscreteAppopsTest.kt]:[permission]:[1]:method_text:[UID_STATE_CACHED, OP_FLAG_TRUSTED_PROXIED)        assertThat(accesses.size).isEqualTo(1)    }   ]) :|: 
    fun testOpFlagsAndDeduplication() {
        waitUntilSafelyInTimeQuant(DEFAULT_TIME_QUANT_MILLIS, SAFETY_MARGIN_MILLIS)
        runWithShellPermissionIdentity {
            appOpsManager.noteProxyOp(OPSTR_CAMERA, PACKAGE_NAME, uid, null, null)
            appOpsManager.noteOp(OPSTR_CAMERA, uid, PACKAGE_NAME, null, null)
        }

        val timeStamp = System.currentTimeMillis() /
                DEFAULT_TIME_QUANT_MILLIS * DEFAULT_TIME_QUANT_MILLIS
        Thread.sleep(500)
        var allOps = getHistoricalOps(HISTORY_FLAG_DISCRETE)

        assertThat(allOps).isNotNull()
        assertThat(allOps!!.uidCount).isEqualTo(1)

        var uidOps = allOps.getUidOpsAt(0)
        assertThat(uidOps).isNotNull()
        assertThat(uidOps.uid).isEqualTo(uid)
        assertThat(uidOps.packageCount).isEqualTo(1)

        var packageOps = uidOps.getPackageOpsAt(0)
        assertThat(packageOps).isNotNull()
        assertThat(packageOps.packageName).isEqualTo(PACKAGE_NAME)
        assertThat(packageOps.opCount).isEqualTo(1)

        var op = packageOps.getOpAt(0)
        assertThat(op).isNotNull()
        assertThat(op.opName).isEqualTo(OPSTR_CAMERA)
        assertThat(op.discreteAccessCount).isEqualTo(1)
        var discrete = op.getDiscreteAccessAt(0)

        assertThat(discrete.getLastDuration(OP_FLAGS_ALL)).isEqualTo(-1)
        assertThat(discrete.getLastAccessTime(OP_FLAGS_ALL)).isEqualTo(timeStamp)
        assertThat(discrete.getLastAccessTime(OP_FLAG_TRUSTED_PROXIED)).isEqualTo(timeStamp)
        assertThat(discrete.getLastAccessTime(OP_FLAG_SELF)).isEqualTo(timeStamp)

        allOps = getHistoricalOps(HISTORY_FLAG_DISCRETE, null, OP_FLAG_TRUSTED_PROXIED)

        assertThat(allOps).isNotNull()
        assertThat(allOps!!.uidCount).isEqualTo(1)

        uidOps = allOps.getUidOpsAt(0)
        assertThat(uidOps).isNotNull()
        assertThat(uidOps.uid).isEqualTo(uid)
        assertThat(uidOps.packageCount).isEqualTo(1)

        packageOps = uidOps.getPackageOps"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appop/src/android/app/appops/cts/DiscreteAppopsTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.appops.cts.DiscreteAppopsTest.kt"	"testOpFlagsParameter"	"CtsAppOpsTestCases"	"1: permission"	"([3:/android/app/appops/cts/DiscreteAppopsTest.kt]:[permission]:[3]:method_text:[lTo(timeStamp)        assertThat(discrete.getLastAccessTime(OP_FLAG_SELF)).isEqualTo(-1)    }   ]) :|: 
    fun testOpFlagsParameter() {
        // Collect only OP_FLAG_TRUSTED_PROXIED (8)
        runWithShellPermissionIdentity {
            DeviceConfig.setProperty(NAMESPACE_PRIVACY, PROPERTY_FLAGS, 8.toString(), false)
        }

        var allOps: HistoricalOps? = null

        for (i in 1..3) {
            waitUntilSafelyInTimeQuant(DEFAULT_TIME_QUANT_MILLIS, SAFETY_MARGIN_MILLIS)
            runWithShellPermissionIdentity {
                appOpsManager.noteProxyOp(OPSTR_CAMERA, PACKAGE_NAME, uid, null, null)
                appOpsManager.noteOp(OPSTR_CAMERA, uid, PACKAGE_NAME, null, null)
            }
            allOps = getHistoricalOps(HISTORY_FLAG_DISCRETE)
            if (allOps!!.getUidOpsAt(0).getPackageOpsAt(0).getOpAt(0).getDiscreteAccessAt(0)
                            .getLastAccessTime(OP_FLAG_SELF) == -1L) {
                break
            }
            runWithShellPermissionIdentity {
                appOpsManager.clearHistory()
            }
            // maybe device_config callback didn't propagate yet, give it some more time
            Thread.sleep(CALLBACK_PROPAGATION_DELAY)
        }

        val timeStamp = System.currentTimeMillis() /
                DEFAULT_TIME_QUANT_MILLIS * DEFAULT_TIME_QUANT_MILLIS

        assertThat(allOps).isNotNull()
        assertThat(allOps!!.uidCount).isEqualTo(1)

        var uidOps = allOps.getUidOpsAt(0)
        assertThat(uidOps).isNotNull()
        assertThat(uidOps.uid).isEqualTo(uid)
        assertThat(uidOps.packageCount).isEqualTo(1)

        var packageOps = uidOps.getPackageOpsAt(0)
        assertThat(packageOps).isNotNull()
        assertThat(packageOps.packageName).isEqualTo(PACKAGE_NAME)
        assertThat(packageOps.opCount).isEqualTo(1)

        var op = packageOps.getOpAt(0)
        assertThat(op).isNotNull()
        assertThat(op.opName).isEqualTo(OPSTR_CAMERA)
        assertThat(op.discreteAccessCount).isEqualTo(1)
        var discrete = op.getDiscreteAccessAt(0)

        assertThat(di"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appop/src/android/app/appops/cts/DiscreteAppopsTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.appops.cts.DiscreteAppopsTest.kt"	"testOpsListParameter"	"CtsAppOpsTestCases"	"1: permission"	"([7:/android/app/appops/cts/DiscreteAppopsTest.kt]:[permission]:[7]:method_text:[ MODE_IGNORED) {                break            }            Thread.sleep(100)        }    }}]) :|: 
    fun testOpsListParameter() {
        // collect only OP_FINE_LOCATION = 1
        makeTop()
        runWithShellPermissionIdentity {
            DeviceConfig.setProperty(NAMESPACE_PRIVACY, PROPERTY_OPS_LIST, ""1"", false)
        }
        var allOps: HistoricalOps? = null
        for (i in 1..3) {
            waitUntilSafelyInTimeQuant(DEFAULT_TIME_QUANT_MILLIS, SAFETY_MARGIN_MILLIS)
            noteOp(OPSTR_FINE_LOCATION, uid, PACKAGE_NAME, null, null)
            noteOp(OPSTR_CAMERA, uid, PACKAGE_NAME, null, null)
            allOps = getHistoricalOps(HISTORY_FLAG_DISCRETE)
            if (allOps!!.getUidOpsAt(0).getPackageOpsAt(0).opCount == 1) break
            runWithShellPermissionIdentity {
                appOpsManager.clearHistory()
            }
            // maybe device_config callback didn't propagate yet, give it some more time
            Thread.sleep(CALLBACK_PROPAGATION_DELAY)
        }

        val timeStamp = System.currentTimeMillis() /
                DEFAULT_TIME_QUANT_MILLIS * DEFAULT_TIME_QUANT_MILLIS

        assertThat(allOps).isNotNull()
        assertThat(allOps!!.uidCount).isEqualTo(1)

        var uidOps = allOps.getUidOpsAt(0)
        assertThat(uidOps).isNotNull()
        assertThat(uidOps.uid).isEqualTo(uid)
        assertThat(uidOps.packageCount).isEqualTo(1)

        var packageOps = uidOps.getPackageOpsAt(0)
        assertThat(packageOps).isNotNull()
        assertThat(packageOps.packageName).isEqualTo(PACKAGE_NAME)
        assertThat(packageOps.opCount).isEqualTo(1)

        var op = packageOps.getOpAt(0)
        assertThat(op).isNotNull()
        assertThat(op.opName).isEqualTo(OPSTR_FINE_LOCATION)
        assertThat(op.discreteAccessCount).isEqualTo(1)
        var discrete = op.getDiscreteAccessAt(0)

        assertThat(discrete.getLastDuration(OP_FLAGS_ALL)).isEqualTo(-1)
        assertThat(discrete.getLastAccessTime(OP_FLAGS_ALL)).isEqualTo(timeStamp)
    }

    /** Provides guarantee that there is at least requiredSafet"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appop/src/android/app/appops/cts/DiscreteAppopsTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.appops.cts.HistoricalAppopsTest.kt"	"setUpTest"	"CtsAppOpsTestCases"	"1: permission"	"([10:/android/app/appops/cts/HistoricalAppopsTest.kt]:[permission]:[10]:method_text:[  PROPERTY_PERMISSIONS_HUB_ENABLED, wasPermissionsHubEnabled.toString(), false)        }    }   ]) :|: /*
 *.
 */

package android.app.appops.cts

import android.app.AppOpsManager
import android.app.AppOpsManager.HistoricalOp
import android.app.AppOpsManager.HistoricalOps
import android.app.AppOpsManager.OPSTR_REQUEST_DELETE_PACKAGES
import android.app.AppOpsManager.OP_FLAGS_ALL
import android.os.Process
import android.os.SystemClock
import android.provider.DeviceConfig
import androidx.test.InstrumentationRegistry
import androidx.test.rule.ActivityTestRule
import androidx.test.runner.AndroidJUnit4
import androidx.test.uiautomator.UiDevice
import com.google.common.truth.Truth.assertThat
import org.junit.After
import org.junit.Before
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith
import java.time.Instant
import java.util.concurrent.TimeUnit
import java.util.concurrent.locks.ReentrantLock
import java.util.function.Consumer

const val PROPERTY_PERMISSIONS_HUB_ENABLED = ""permissions_hub_enabled""

@RunWith(AndroidJUnit4::class)
class HistoricalAppopsTest {
    private val uid = Process.myUid()
    private lateinit var appOpsManager: AppOpsManager
    private lateinit var packageName: String

    private var wasPermissionsHubEnabled = false

    // Start an activity to make sure this app counts as being in the foreground
    @Rule @JvmField
    var activityRule = ActivityTestRule(UidStateForceActivity::class.java)

    @Before
    fun wakeScreenUp() {
        val uiDevice = UiDevice.getInstance(instrumentation)
        uiDevice.wakeUp()
        uiDevice.executeShellCommand(""wm dismiss-keyguard"")
    }

    @Before
    fun setUpTest() {
        appOpsManager = context.getSystemService(AppOpsManager::class.java)!!
        packageName = context.packageName!!
        runWithShellPermissionIdentity {
            wasPermissionsHubEnabled = DeviceConfig.getBoolean(DeviceConfig.NAMESPACE_PRIVACY,
                    PROPERTY_PERMISSIONS_HUB_ENABLED, false)
            DeviceConfig.setProperty(DeviceConfig.NAMESPACE_PRIVACY,
                    PROPERTY_"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appop/src/android/app/appops/cts/HistoricalAppopsTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.appops.cts.HistoricalAppopsTest.kt"	"testRebootHistory"	"CtsAppOpsTestCases"	"1: permission"	"([1:/android/app/appops/cts/HistoricalAppopsTest.kt]:[permission]:[1]:method_text:[gIntervalBeginMillis, everythingIntervalEndMillis)        assertHasCounts(allOps!!, 460)    }   ]) :|: 
    fun testRebootHistory() {
        // Configure historical registry behavior.
        setHistoryParameters(
                AppOpsManager.HISTORICAL_MODE_ENABLED_PASSIVE,
                SNAPSHOT_INTERVAL_MILLIS,
                INTERVAL_COMPRESSION_MULTIPLIER)

        // Add the data to the history
        val chunk = createDataChunk()
        val chunkCount = (INTERVAL_COMPRESSION_MULTIPLIER * 2) + 3
        for (i in 0 until chunkCount) {
            addHistoricalOps(chunk)
        }

        // Validate the data for the first interval
        val firstIntervalBeginMillis = computeIntervalBeginRawMillis(0)
        val firstIntervalEndMillis = computeIntervalBeginRawMillis(1)
        var firstOps = getHistoricalOpsFromDiskRaw(uid, packageName, null /*opNames*/,
                firstIntervalBeginMillis, firstIntervalEndMillis)
        assertHasCounts(firstOps!!, 197)

        // Validate the data for the second interval
        val secondIntervalBeginMillis = computeIntervalBeginRawMillis(1)
        val secondIntervalEndMillis = computeIntervalBeginRawMillis(2)
        var secondOps = getHistoricalOpsFromDiskRaw(uid, packageName, null /*opNames*/,
                secondIntervalBeginMillis, secondIntervalEndMillis)
        assertHasCounts(secondOps!!, 33)

        // Validate the data for all intervals
        val everythingIntervalBeginMillis = Instant.EPOCH.toEpochMilli()
        val everythingIntervalEndMillis = Long.MAX_VALUE
        var allOps = getHistoricalOpsFromDiskRaw(uid, packageName, null /*opNames*/,
                everythingIntervalBeginMillis, everythingIntervalEndMillis)
        assertHasCounts(allOps!!, 230)

        // Now reboot the history
        runWithShellPermissionIdentity {
            appOpsManager.rebootHistory(firstIntervalEndMillis)
        }

        // Validate the data for the first interval
        firstOps = getHistoricalOpsFromDiskRaw(uid, packageName, null /*opNames*/,
                firstIntervalBeginMillis, firstInterval"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appop/src/android/app/appops/cts/HistoricalAppopsTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.appops.cts.HistoricalAppopsTest.kt"	"testHistoryTimeTravel"	"CtsAppOpsTestCases"	"1: permission"	"([2:/android/app/appops/cts/HistoricalAppopsTest.kt]:[permission]:[2]:method_text:[llis)        assertThat(fifthOps).isNotNull()        assertHasCounts(fifthOps!!, 1703)    }   ]) :|: 
    fun testHistoryTimeTravel() {
        // Configure historical registry behavior.
        setHistoryParameters(
                AppOpsManager.HISTORICAL_MODE_ENABLED_PASSIVE,
                SNAPSHOT_INTERVAL_MILLIS,
                INTERVAL_COMPRESSION_MULTIPLIER)

        // Fill the first two intervals with data
        val chunk = createDataChunk()
        val chunkCount = computeSlotCount(2) * SNAPSHOT_INTERVAL_MILLIS / chunk.endTimeMillis
        for (i in 0 until chunkCount) {
            addHistoricalOps(chunk)
        }

        // Move history in past with the first interval duration
        val firstIntervalDurationMillis = computeIntervalDurationMillis(0)
        runWithShellPermissionIdentity {
            appOpsManager.offsetHistory(firstIntervalDurationMillis)
        }

        // Validate the data for the first interval
        val firstIntervalBeginMillis = computeIntervalBeginRawMillis(0)
        val firstIntervalEndMillis = firstIntervalBeginMillis + firstIntervalDurationMillis
        val firstOps = getHistoricalOpsFromDiskRaw(uid, packageName, null /*opNames*/,
                firstIntervalBeginMillis, firstIntervalEndMillis)
        assertThat(firstOps).isNotNull()
        assertThat(firstOps!!.uidCount).isEqualTo(0)

        // Validate the data for the second interval
        val secondIntervalBeginMillis = computeIntervalBeginRawMillis(1)
        val secondIntervalDurationMillis = computeIntervalDurationMillis(1)
        val secondIntervalEndMillis = secondIntervalBeginMillis + secondIntervalDurationMillis
        val secondOps = getHistoricalOpsFromDiskRaw(uid, packageName, null /*opNames*/,
                secondIntervalBeginMillis, secondIntervalEndMillis)
        val secondChunkCount = ((computeSlotCount(2) - computeSlotCount(1))
            .times(SNAPSHOT_INTERVAL_MILLIS) / chunk.endTimeMillis)
        assertHasCounts(secondOps!!, 10 * secondChunkCount)

        // Validate the data for the third interval
        val thirdInterval"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appop/src/android/app/appops/cts/HistoricalAppopsTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.appops.cts.HistoricalAppopsTest.kt"	"testGetHistoricalAggregationOverAttributions"	"CtsAppOpsTestCases"	"1: permission"	"([7:/android/app/appops/cts/HistoricalAppopsTest.kt]:[permission]:[7]:method_text:[Long()            }            return beginTimeMillis * SNAPSHOT_INTERVAL_MILLIS        }    }}]) :|: 
    fun testGetHistoricalAggregationOverAttributions() {
        // Configure historical registry behavior.
        setHistoryParameters(
                AppOpsManager.HISTORICAL_MODE_ENABLED_ACTIVE,
                SNAPSHOT_INTERVAL_MILLIS,
                INTERVAL_COMPRESSION_MULTIPLIER)

        setUidMode(OPSTR_REQUEST_DELETE_PACKAGES, uid, AppOpsManager.MODE_ALLOWED)

        UidStateForceActivity.waitForResumed()

        appOpsManager.noteOp(OPSTR_REQUEST_DELETE_PACKAGES, uid, packageName, ""firstAttribution"",
                null)
        appOpsManager.noteOp(OPSTR_REQUEST_DELETE_PACKAGES, uid, packageName, ""secondAttribution"",
                null)
        var memOps: AppOpsManager.HistoricalOps? = null
        eventually(SNAPSHOT_INTERVAL_MILLIS / 2) {
            memOps = getHistoricalOps(appOpsManager, uid = uid)!!

            assertThat(memOps!!.getUidOpsAt(0).getPackageOpsAt(0)
                    .getOp(OPSTR_REQUEST_DELETE_PACKAGES)!!.getForegroundAccessCount(OP_FLAGS_ALL))
                    .isEqualTo(2)
            assertThat(memOps!!.getUidOpsAt(0).getPackageOpsAt(0)
                    .getAttributedOps(""firstAttribution"")!!.getOp(OPSTR_REQUEST_DELETE_PACKAGES)!!
                    .getForegroundAccessCount(OP_FLAGS_ALL)).isEqualTo(1)
            assertThat(memOps!!.getUidOpsAt(0).getPackageOpsAt(0)
                    .getAttributedOps(""secondAttribution"")!!.getOp(OPSTR_REQUEST_DELETE_PACKAGES)!!
                    .getForegroundAccessCount(OP_FLAGS_ALL)).isEqualTo(1)
        }

        // Wait until data is on disk and verify no entry got lost
        Thread.sleep(SNAPSHOT_INTERVAL_MILLIS)

        val diskOps = getHistoricalOps(appOpsManager, uid = uid)!!
        assertThat(diskOps.getUidOpsAt(0)).isEqualTo(memOps?.getUidOpsAt(0))
    }

    private fun testHistoricalAggregationSomeLevelsDeep(depth: Int) {
        // Configure historical registry behavior.
        setHistoryParameters(
                AppOpsManager.HISTORICAL_MODE_ENABLED"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appop/src/android/app/appops/cts/HistoricalAppopsTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.appops.cts.AppOpsTest.kt"	"startOpTwiceAndVerifyChangeListener"	"CtsAppOpsTestCases"	"1: permission"	"([1:/android/app/appops/cts/AppOpsTest.kt]:[permission]:[1]:method_text:[nally {                mAppOps.stopWatchingActive(activeWatcher)            }        }    }   ]) :|: 
    @AppModeFull(reason = ""Instant app cannot query for the shell package"")
    fun startOpTwiceAndVerifyChangeListener() {
        runWithShellPermissionIdentity {
            val receivedActiveState = LinkedBlockingDeque<Boolean>()
            val activeWatcher =
                    AppOpsManager.OnOpActiveChangedListener { _, uid, packageName, active ->
                        if (packageName == SHELL_PACKAGE_NAME &&
                                uid == Process.SHELL_UID) {
                            receivedActiveState.push(active)
                        }
                    }

            mAppOps.startWatchingActive(arrayOf(OPSTR_WIFI_SCAN), Executor { it.run() },
                    activeWatcher)
            try {
                mAppOps.startOp(OPSTR_WIFI_SCAN, mMyUid, mOpPackageName, null, null)
                assertTrue(receivedActiveState.poll(TIMEOUT_MS, TimeUnit.MILLISECONDS)!!)

                mAppOps.finishOp(OPSTR_WIFI_SCAN, Process.SHELL_UID, SHELL_PACKAGE_NAME, null)
                assertFalse(receivedActiveState.poll(TIMEOUT_MS, TimeUnit.MILLISECONDS)!!)

                mAppOps.startOp(OPSTR_WIFI_SCAN, mMyUid, mOpPackageName, null, null)
                assertTrue(receivedActiveState.poll(TIMEOUT_MS, TimeUnit.MILLISECONDS)!!)

                mAppOps.finishOp(OPSTR_WIFI_SCAN, Process.SHELL_UID, SHELL_PACKAGE_NAME, null)
                assertFalse(receivedActiveState.poll(TIMEOUT_MS, TimeUnit.MILLISECONDS)!!)
            } finally {
                mAppOps.stopWatchingActive(activeWatcher)
            }
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appop/src/android/app/appops/cts/AppOpsTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.appops.cts.AppOpsTest.kt"	"testPermissionMapping"	"CtsAppOpsTestCases"	"1: permission"	"([13:/android/app/appops/cts/AppOpsTest.kt]:[permission]:[13]:method_text:[Back)    }    /**     * Test that the app can not change the app op mode for itself.     */   ]) :|: 
    fun testPermissionMapping() {
        for (entry in permissionToOpStr) {
            testPermissionMapping(entry.key, entry.value)
        }
    }

    private fun testPermissionMapping(permission: String, opStr: String) {
        // Do the public value => internal op code lookups.
        val mappedOpStr = AppOpsManager.permissionToOp(permission)
        assertEquals(mappedOpStr, opStr)
        val mappedOpCode = AppOpsManager.permissionToOpCode(permission)
        val mappedOpCode2 = AppOpsManager.strOpToOp(opStr)
        assertEquals(mappedOpCode, mappedOpCode2)

        // Do the internal op code => public value lookup (reverse lookup).
        val permissionMappedBack = AppOpsManager.opToPermission(mappedOpCode)
        assertEquals(permission, permissionMappedBack)
    }

    /**
     * Test that the app can not change the app op mode for itself.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appop/src/android/app/appops/cts/AppOpsTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.appops.cts.AppOpsTest.kt"	"testCantSetModeForSelf"	"CtsAppOpsTestCases"	"1: permission"	"([2:/android/app/appops/cts/AppOpsTest.kt]:[permission]:[2]:method_text:[Was able to set mode for self"")        } catch (expected: SecurityException) {        }    }   ]) :|: 
    fun testCantSetModeForSelf() {
        try {
            val writeSmsOp = AppOpsManager.permissionToOpCode(""android.permission.WRITE_SMS"")
            mAppOps.setMode(writeSmsOp, Process.myUid(), mOpPackageName, AppOpsManager.MODE_ALLOWED)
            fail(""Was able to set mode for self"")
        } catch (expected: SecurityException) {
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appop/src/android/app/appops/cts/AppOpsTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.appops.cts.AppOpsTest.kt"	"testNonHistoricalStatePersistence"	"CtsAppOpsTestCases"	"1: permission"	"([3:/android/app/appops/cts/AppOpsTest.kt]:[permission]:[3]:method_text:[E_IN_PICTURE, Process.myUid(),                    mOpPackageName, defaultMode)        }    }   ]) :|: 
    fun testNonHistoricalStatePersistence() {
        // Put a package and uid level data
        runWithShellPermissionIdentity {
            mAppOps.setMode(OPSTR_PICTURE_IN_PICTURE, Process.myUid(),
                    mOpPackageName, MODE_IGNORED)
            mAppOps.setUidMode(OPSTR_PICTURE_IN_PICTURE, Process.myUid(), MODE_ERRORED)

            // Write the data to disk and read it
            mAppOps.reloadNonHistoricalState()
        }

        // Verify the uid state is preserved
        assertSame(mAppOps.unsafeCheckOpNoThrow(OPSTR_PICTURE_IN_PICTURE,
                Process.myUid(), mOpPackageName), MODE_ERRORED)

        runWithShellPermissionIdentity {
            // Clear the uid state
            mAppOps.setUidMode(OPSTR_PICTURE_IN_PICTURE, Process.myUid(),
                    AppOpsManager.opToDefaultMode(OPSTR_PICTURE_IN_PICTURE))
        }

        // Verify the package state is preserved
        assertSame(mAppOps.unsafeCheckOpNoThrow(OPSTR_PICTURE_IN_PICTURE,
                Process.myUid(), mOpPackageName), MODE_IGNORED)

        runWithShellPermissionIdentity {
            // Clear the uid state
            val defaultMode = AppOpsManager.opToDefaultMode(OPSTR_PICTURE_IN_PICTURE)
            mAppOps.setUidMode(OPSTR_PICTURE_IN_PICTURE, Process.myUid(), defaultMode)
            mAppOps.setMode(OPSTR_PICTURE_IN_PICTURE, Process.myUid(),
                    mOpPackageName, defaultMode)
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appop/src/android/app/appops/cts/AppOpsTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.appops.cts.AppOpsTest.kt"	"adoptShellPermissionIdentity"	"CtsAppOpsTestCases"	"1: permission"	"([3:/android/app/appops/cts/AppOpsTest.kt]:[permission]:[3]:method_text:[nvoke()        } finally {            uiAutomation.dropShellPermissionIdentity()        }    }}]) :|: 
    fun ensurePhoneCallOpsRestricted() {
        assumeTrue(mContext.packageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY))
        val micReturn = mAppOps.noteOp(OPSTR_PHONE_CALL_MICROPHONE, Process.myUid(), mOpPackageName,
                null, null)
        assertEquals(MODE_IGNORED, micReturn)
        val cameraReturn = mAppOps.noteOp(OPSTR_PHONE_CALL_CAMERA, Process.myUid(),
                mOpPackageName, null, null)
        assertEquals(MODE_IGNORED, cameraReturn)
    }

    private fun runWithShellPermissionIdentity(command: () -> Unit) {
        val uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation()
        uiAutomation.adoptShellPermissionIdentity()
        try {
            command.invoke()
        } finally {
            uiAutomation.dropShellPermissionIdentity()
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appop/src/android/app/appops/cts/AppOpsTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.packageinstaller.uninstall.cts.UninstallPinnedTest"	"isScreenOn"	"CtsPackageUninstallTestCases"	"1: permission"	"([1:/android/packageinstaller/uninstall/cts/UninstallPinnedTest.java]:[permission]:[1]:method_text:[G_ACTIVITY_NEW_TASK);        mContext.startActivity(i);        pinActivity(COMPONENT);    }   ]) :|: /*
 *.
 */
package android.packageinstaller.uninstall.cts;

import static android.content.Intent.FLAG_ACTIVITY_NEW_TASK;

import static com.android.compatibility.common.util.SystemUtil.eventually;
import static com.android.compatibility.common.util.SystemUtil.runShellCommand;
import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;
import static com.android.compatibility.common.util.UiAutomatorUtils.waitFindObject;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import android.app.ActivityTaskManager;
import android.app.PendingIntent;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageInstaller;
import android.content.pm.PackageManager;
import android.server.wm.WindowManagerStateHelper;
import android.support.test.uiautomator.By;
import android.support.test.uiautomator.UiDevice;

import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.AppOpsUtils;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.io.IOException;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

public class UninstallPinnedTest {

    private static final String APK =
            ""/data/local/tmp/cts/uninstall/CtsSelfUninstallingTestApp.apk"";
    private static final String TEST_PKG_NAME = ""android.packageinstaller.selfuninstalling.cts"";
    private static final String TEST_ACTIVITY_NAME = TEST_PKG_NAME + "".SelfUninstallActivity"";
    private static final String ACTION_SELF_UNINSTALL =
            ""android.packageinstaller.selfuninstalling.cts.action.SELF_UNINSTALL"";
    private static final ComponentName COMPONENT = new ComponentName(TEST_PKG_NAME, TEST_ACTIVITY"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/packageinstaller/uninstall/src/android/packageinstaller/uninstall/cts/UninstallPinnedTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.packageinstaller.uninstall.cts.UninstallPinnedTest"	"testCantUninstallAppDirectly"	"CtsPackageUninstallTestCases"	"1: permission"	"([1:/android/packageinstaller/uninstall/cts/UninstallPinnedTest.java]:[permission]:[1]:method_text:[_FAILURE_BLOCKED, status);        assertTrue(""Package was uninstalled."", isInstalled());    }   ]) :|: 
    public void testCantUninstallAppDirectly() {
        CompletableFuture<Integer> statusFuture = new CompletableFuture<>();
        mContext.registerReceiver(new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                statusFuture.complete(
                        intent.getIntExtra(PackageInstaller.EXTRA_STATUS, Integer.MAX_VALUE));
            }
        }, new IntentFilter(CALLBACK_ACTION));

        runWithShellPermissionIdentity(() -> {
            mContext.getPackageManager().getPackageInstaller().uninstall(TEST_PKG_NAME,
                    PendingIntent.getBroadcast(mContext, 1,
                            new Intent(CALLBACK_ACTION),
                            PendingIntent.FLAG_MUTABLE).getIntentSender());
        });

        int status = statusFuture.join();
        assertEquals(""Wrong code received"", PackageInstaller.STATUS_FAILURE_BLOCKED, status);
        assertTrue(""Package was uninstalled."", isInstalled());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/packageinstaller/uninstall/src/android/packageinstaller/uninstall/cts/UninstallPinnedTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.packageinstaller.uninstall.cts.UninstallPinnedTest"	"testCantUninstallWithShell"	"CtsPackageUninstallTestCases"	"1: permission"	"([2:/android/packageinstaller/uninstall/cts/UninstallPinnedTest.java]:[permission]:[2]:method_text:[      } catch (PackageManager.NameNotFoundException e) {            return false;        }    }}]) :|: 
    public void testCantUninstallWithShell() throws Exception {
        mUiDevice.executeShellCommand(""pm uninstall "" + TEST_PKG_NAME);
        assertTrue(""Package was uninstalled."", isInstalled());
    }

    @After
    public void unpinAndUninstall() throws IOException {
        runWithShellPermissionIdentity(() -> mActivityTaskManager.stopSystemLockTaskMode());
        mUiDevice.executeShellCommand(""pm uninstall "" + TEST_PKG_NAME);
    }

    private void pinActivity(ComponentName component) {
        mWmState.computeState();

        int stackId = mWmState.getRootTaskIdByActivity(component);

        runWithShellPermissionIdentity(() -> {
            mActivityTaskManager.startSystemLockTaskMode(
                    stackId);
        });
    }

    private boolean isInstalled() {
        try {
            mContext.getPackageManager().getPackageInfo(TEST_PKG_NAME, 0);
            return true;
        } catch (PackageManager.NameNotFoundException e) {
            return false;
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/packageinstaller/uninstall/src/android/packageinstaller/uninstall/cts/UninstallPinnedTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.tests.atomicinstall.AtomicInstallTest"	"adoptShellPermissions"	"CtsAtomicInstallTestCases"	"1: permission"	"([7:/com/android/tests/atomicinstall/AtomicInstallTest.java]:[permission]:[7]:method_text:[ionError(message);    }    /**     * Tests a completed session should be cleaned up.     */   ]) :|: /*
 *.
 */

package com.android.tests.atomicinstall;

import static com.android.cts.install.lib.InstallUtils.assertStatusSuccess;
import static com.android.cts.install.lib.InstallUtils.getInstalledVersion;
import static com.android.cts.install.lib.InstallUtils.openPackageInstallerSession;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.fail;

import android.Manifest;
import android.content.pm.PackageInstaller;

import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.SystemUtil;
import com.android.cts.install.lib.Install;
import com.android.cts.install.lib.InstallUtils;
import com.android.cts.install.lib.LocalIntentSender;
import com.android.cts.install.lib.TestApp;
import com.android.cts.install.lib.Uninstall;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

import java.util.function.Predicate;
import java.util.function.Supplier;

/**
 * Tests for multi-package (a.k.a. atomic) installs.
 */
@RunWith(JUnit4.class)
public class AtomicInstallTest {
    /**
     * Time between repeated checks in {@link #retry}.
     */
    private static final long RETRY_CHECK_INTERVAL_MILLIS = 500;
    /**
     * Maximum number of checks in {@link #retry} before a timeout occurs.
     */
    private static final long RETRY_MAX_INTERVALS = 20;

    public static final String TEST_APP_CORRUPT_FILENAME = ""corrupt.apk"";
    private static final TestApp CORRUPT_TESTAPP = new TestApp(
            ""corrupt"", ""com.corrupt"", 1, false, TEST_APP_CORRUPT_FILENAME);

    private void adoptShellPermissions() {
        InstrumentationRegistry
                .getInstrumentation()
                .getUiAutomation()
                .adoptShellPermissionIdentity(Manifest.permission.INSTALL_PACKAGES,
                    Manifest.permission.DELETE_PACKAGES);
    }

    @Before
    public void setup() throws Exception {
        adoptShellPer"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/packageinstaller/atomicinstall/src/com/android/tests/atomicinstall/AtomicInstallTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.provider.cts.contacts.ContactsProvider2_AccountRemovalTest"	"testAccountRemoval_doesNotDeleteSimAccountContacts"	"CtsContactsProviderTestCases"	"1: permission"	"([1:/android/provider/cts/contacts/ContactsProvider2_AccountRemovalTest.java]:[permission]:[1]:method_text:[er, int)} is called.     * Only SIM accounts from the sim slot index should be removed.     */   ]) :|: public void testAccountRemoval_doesNotDeleteSimAccountContacts() {
        mAccountManager.addAccountExplicitly(ACCT_1, null, null);
        SystemUtil.runWithShellPermissionIdentity(() -> {
            SimContacts.addSimAccount(mResolver, SIM_ACCT_NAME_1, SIM_ACCT_TYPE_1, SIM_SLOT_0,
                    ContactsContract.SimAccount.ADN_EF_TYPE);
        });
        ArrayList<ContactIdPair> acc1Ids = createContacts(ACCT_1, 5);

        long simRawContactId = RawContactUtil
                .createRawContactWithAutoGeneratedName(mResolver,
                        new Account(SIM_ACCT_NAME_1, SIM_ACCT_TYPE_1));

        mAccountManager.removeAccount(ACCT_1, null, null);
        // Wait for deletion of the contacts in the removed account to finish before verifying
        // the existence of the device contacts
        assertContactsDeletedEventually(System.currentTimeMillis(), acc1Ids);

        assertTrue(RawContactUtil.rawContactExistsById(mResolver, simRawContactId));
    }

    /**
     * Contacts saved to a SIM account that was added through
     * {@link SimContacts#addSimAccount(ContentResolver, String, String, int, int)}
     * should be deleted when {@link SimContacts#removeSimAccounts(ContentResolver, int)} is called.
     * Only SIM accounts from the sim slot index should be removed.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/contactsprovider/src/android/provider/cts/contacts/ContactsProvider2_AccountRemovalTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.provider.cts.contacts.ContactsProvider2_AccountRemovalTest"	"testRemoveSimAccount_deleteSimAccountContacts"	"CtsContactsProviderTestCases"	"1: permission"	"([2:/android/provider/cts/contacts/ContactsProvider2_AccountRemovalTest.java]:[permission]:[2]:method_text:[     * one account is removed.  But contact should have last updated timestamp updated.     */   ]) :|: public void testRemoveSimAccount_deleteSimAccountContacts() {
        SystemUtil.runWithShellPermissionIdentity(() -> {
            SimContacts.addSimAccount(mResolver, SIM_ACCT_NAME_1, SIM_ACCT_TYPE_1, SIM_SLOT_0,
                    ContactsContract.SimAccount.ADN_EF_TYPE);
            SimContacts.addSimAccount(mResolver, SIM_ACCT_NAME_2, SIM_ACCT_TYPE_2, SIM_SLOT_0,
                    ContactsContract.SimAccount.SDN_EF_TYPE);
            SimContacts.addSimAccount(mResolver, SIM_ACCT_NAME_3, SIM_ACCT_TYPE_3, SIM_SLOT_1,
                    ContactsContract.SimAccount.ADN_EF_TYPE);
        });


        ArrayList<ContactIdPair> acc1Ids = createContacts(
                new Account(SIM_ACCT_NAME_1, SIM_ACCT_TYPE_1), 5);
        ArrayList<ContactIdPair> acc2Ids = createContacts(
                new Account(SIM_ACCT_NAME_2, SIM_ACCT_TYPE_2), 5);


        long secondSimSlotRawContactId = RawContactUtil
                .createRawContactWithAutoGeneratedName(mResolver,
                        new Account(SIM_ACCT_NAME_3, SIM_ACCT_TYPE_3));

        SystemUtil.runWithShellPermissionIdentity(() -> {
            SimContacts.removeSimAccounts(mResolver, SIM_SLOT_0);
        });
        // Wait for deletion of the contacts in the removed account to finish before verifying
        // the existence of the device contacts
        assertContactsDeletedEventually(System.currentTimeMillis(), acc1Ids);
        assertContactsDeletedEventually(System.currentTimeMillis(), acc2Ids);

        // Sim contacts in a different slot should remain
        assertTrue(RawContactUtil.rawContactExistsById(mResolver, secondSimSlotRawContactId));
    }

    /**
     * Contact has merged raw contacts from different accounts. Contact should not be deleted when
     * one account is removed.  But contact should have last updated timestamp updated.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/contactsprovider/src/android/provider/cts/contacts/ContactsProvider2_AccountRemovalTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.provider.cts.contacts.ContactsContract_SimContactTest"	"testAddSimAccount_returnedByGetSimAccounts"	"CtsContactsProviderTestCases"	"1: permission"	"([1:/android/provider/cts/contacts/ContactsContract_SimContactTest.java]:[permission]:[1]:method_text:[nt is added, {@link SimContacts#ACTION_SIM_ACCOUNTS_CHANGED} should be     * broadcast.     */   ]) :|: public void testAddSimAccount_returnedByGetSimAccounts() {
        SystemUtil.runWithShellPermissionIdentity(() -> {
            SimContacts.addSimAccount(mResolver, SIM_ACCT_NAME_1, SIM_ACCT_TYPE_1, SIM_SLOT_0,
                    SimAccount.ADN_EF_TYPE);
            SimContacts.addSimAccount(mResolver, SIM_ACCT_NAME_2, SIM_ACCT_TYPE_2, SIM_SLOT_1,
                    SimAccount.ADN_EF_TYPE);
        });

        List<SimAccount> simAccounts = SimContacts.getSimAccounts(mResolver);

        assertThat(simAccounts).hasSize(2);
        SimAccount simAccount1 = simAccounts.get(0);

        assertThat(SIM_ACCT_NAME_1).isEqualTo(simAccount1.getAccountName());
        assertThat(SIM_ACCT_TYPE_1).isEqualTo(simAccount1.getAccountType());
        assertThat(SIM_SLOT_0).isEqualTo(simAccount1.getSimSlotIndex());
        assertThat(SimAccount.ADN_EF_TYPE).isEqualTo(simAccount1.getEfType());

        SimAccount simAccount2 = simAccounts.get(1);

        assertThat(SIM_ACCT_NAME_2).isEqualTo(simAccount2.getAccountName());
        assertThat(SIM_ACCT_TYPE_2).isEqualTo(simAccount2.getAccountType());
        assertThat(SIM_SLOT_1).isEqualTo(simAccount2.getSimSlotIndex());
        assertThat(SimAccount.ADN_EF_TYPE).isEqualTo(simAccount2.getEfType());
    }

    /**
     * When a SIM account is added, {@link SimContacts#ACTION_SIM_ACCOUNTS_CHANGED} should be
     * broadcast.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/contactsprovider/src/android/provider/cts/contacts/ContactsContract_SimContactTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.provider.cts.contacts.ContactsContract_SimContactTest"	"testAddSimAccount_broadcastsChange"	"CtsContactsProviderTestCases"	"1: permission"	"([1:/android/provider/cts/contacts/ContactsContract_SimContactTest.java]:[permission]:[1]:method_text:[ is removed, {@link SimContacts#ACTION_SIM_ACCOUNTS_CHANGED} should be     * broadcast.     */   ]) :|: public void testAddSimAccount_broadcastsChange() throws Exception {
        getContext().registerReceiver(mBroadcastReceiver,
                new IntentFilter(SimContacts.ACTION_SIM_ACCOUNTS_CHANGED));

        SystemUtil.runWithShellPermissionIdentity(() -> {
            SimContacts.addSimAccount(mResolver, SIM_ACCT_NAME_1, SIM_ACCT_TYPE_1, SIM_SLOT_0,
                    SimAccount.ADN_EF_TYPE);
        });

        TestUtils.waitUntil(""Broadcast has not been received in time"", ASYNC_TIMEOUT_LIMIT_SEC,
                () -> mReceivedIntents.size() == 1);
        Intent receivedIntent = mReceivedIntents.get(0);
        assertThat(SimContacts.ACTION_SIM_ACCOUNTS_CHANGED).isEqualTo(receivedIntent.getAction());
    }

    /**
     * When a SIM account is removed, {@link SimContacts#ACTION_SIM_ACCOUNTS_CHANGED} should be
     * broadcast.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/contactsprovider/src/android/provider/cts/contacts/ContactsContract_SimContactTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.provider.cts.contacts.ContactsContract_SimContactTest"	"testRemoveSimAccount_broadcastsChange"	"CtsContactsProviderTestCases"	"1: permission"	"([2:/android/provider/cts/contacts/ContactsContract_SimContactTest.java]:[permission]:[2]:method_text:[  assertThat(SimContacts.ACTION_SIM_ACCOUNTS_CHANGED).isEqualTo(receivedIntent.getAction());    }}]) :|: public void testRemoveSimAccount_broadcastsChange() throws Exception {
        SystemUtil.runWithShellPermissionIdentity(() -> {
            SimContacts.addSimAccount(mResolver, SIM_ACCT_NAME_1, SIM_ACCT_TYPE_1, SIM_SLOT_0,
                    SimAccount.ADN_EF_TYPE);
        });
        getContext().registerReceiver(mBroadcastReceiver,
                new IntentFilter(SimContacts.ACTION_SIM_ACCOUNTS_CHANGED));

        SystemUtil.runWithShellPermissionIdentity(() -> {
            SimContacts.removeSimAccounts(mResolver, SIM_SLOT_0);
        });

        TestUtils.waitUntil(""Broadcast has not been received in time"", ASYNC_TIMEOUT_LIMIT_SEC,
                () -> mReceivedIntents.size() == 1);
        Intent receivedIntent = mReceivedIntents.get(0);
        assertThat(SimContacts.ACTION_SIM_ACCOUNTS_CHANGED).isEqualTo(receivedIntent.getAction());
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/contactsprovider/src/android/provider/cts/contacts/ContactsContract_SimContactTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContentProviderTest"	"TestApis"	"CtsContentTestCases"	"1: permission"	"([1:/android/content/cts/ContentProviderTest.java]:[permission]:[1]:method_text:[      sContext.deleteDatabase(TEST_DB_NAME);        sContext.deleteFile(TEST_FILE_NAME);    }   ]) :|: /*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License""); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package android.content.cts;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.testng.Assert.assertThrows;

import android.content.ContentProvider;
import android.content.ContentProvider.CallingIdentity;
import android.content.ContentResolver;
import android.content.ContentValues;
import android.content.Context;
import android.content.pm.PackageManager;
import android.content.pm.ProviderInfo;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.net.Uri;
import android.os.Binder;
import android.os.ParcelFileDescriptor;
import android.os.UserHandle;
import android.platform.test.annotations.AppModeFull;
import android.provider.MediaStore;

import androidx.test.core.app.ApplicationProvider;

import com.android.bedstead.harrier.BedsteadJUnit4;
import com.android.bedstead.harrier.DeviceState;
import com.android.bedstead.harrier.annotations.EnsureHasWorkProfile;
import com.android.bedstead.nene.TestApis;

import org.junit.After;
import org.junit.ClassRule;
import org.junit.Rule;
import org.junit.Test;
import"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContentProviderTest"	"testAttachInfo"	"CtsContentTestCases"	"1: permission"	"([26:/android/content/cts/ContentProviderTest.java]:[permission]:[26]:method_text:[);        assertEquals(info1.writePermission, mockContentProvider.getWritePermission());    }   ]) :|: 
    public void testAttachInfo() {
        MockContentProvider mockContentProvider = new MockContentProvider();

        ProviderInfo info1 = new ProviderInfo();
        info1.readPermission = ""android.permission.READ_SMS"";
        info1.writePermission = null; // Guarded by an app op not a permission.
        mockContentProvider.attachInfo(sContext, info1);
        assertSame(sContext, mockContentProvider.getContext());
        assertEquals(info1.readPermission, mockContentProvider.getReadPermission());
        assertEquals(info1.writePermission, mockContentProvider.getWritePermission());

        ProviderInfo info2 = new ProviderInfo();
        info2.readPermission = ""android.permission.READ_CONTACTS"";
        info2.writePermission = ""android.permission.WRITE_CONTACTS"";
        mockContentProvider.attachInfo(null, info2);
        assertSame(sContext, mockContentProvider.getContext());
        assertEquals(info1.readPermission, mockContentProvider.getReadPermission());
        assertEquals(info1.writePermission, mockContentProvider.getWritePermission());

        mockContentProvider = new MockContentProvider();
        mockContentProvider.attachInfo(null, null);
        assertNull(mockContentProvider.getContext());
        assertNull(mockContentProvider.getReadPermission());
        assertNull(mockContentProvider.getWritePermission());

        mockContentProvider.attachInfo(null, info2);
        assertNull(mockContentProvider.getContext());
        assertEquals(info2.readPermission, mockContentProvider.getReadPermission());
        assertEquals(info2.writePermission, mockContentProvider.getWritePermission());

        mockContentProvider.attachInfo(sContext, info1);
        assertSame(sContext, mockContentProvider.getContext());
        assertEquals(info1.readPermission, mockContentProvider.getReadPermission());
        assertEquals(info1.writePermission, mockContentProvider.getWritePermission());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContentProviderTest"	"testAccessReadPermission"	"CtsContentTestCases"	"1: permission"	"([10:/android/content/cts/ContentProviderTest.java]:[permission]:[10]:method_text:[ReadPermissionWrapper(null);        assertNull(mockContentProvider.getReadPermission());    }   ]) :|: 
    public void testAccessReadPermission() {
        MockContentProvider mockContentProvider = new MockContentProvider();
        assertNull(mockContentProvider.getReadPermission());

        String expected = ""android.permission.READ_CONTACTS"";
        mockContentProvider.setReadPermissionWrapper(expected);
        assertEquals(expected, mockContentProvider.getReadPermission());

        expected = ""android.permission.READ_SMS"";
        mockContentProvider.setReadPermissionWrapper(expected);
        assertEquals(expected, mockContentProvider.getReadPermission());

        mockContentProvider.setReadPermissionWrapper(null);
        assertNull(mockContentProvider.getReadPermission());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContentProviderTest"	"testAccessWritePermission"	"CtsContentTestCases"	"1: permission"	"([7:/android/content/cts/ContentProviderTest.java]:[permission]:[7]:method_text:[itePermissionWrapper(null);        assertNull(mockContentProvider.getWritePermission());    }   ]) :|: 
    public void testAccessWritePermission() {
        MockContentProvider mockContentProvider = new MockContentProvider();
        assertNull(mockContentProvider.getWritePermission());

        String expected = ""android.permission.WRITE_CONTACTS"";
        mockContentProvider.setWritePermissionWrapper(expected);
        assertEquals(expected, mockContentProvider.getWritePermission());

        mockContentProvider.setWritePermissionWrapper(null);
        assertNull(mockContentProvider.getWritePermission());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContentProviderTest"	"testCheckUriPermission"	"CtsContentTestCases"	"1: permission"	"([3:/android/content/cts/ContentProviderTest.java]:[permission]:[3]:method_text:[DENIED,                provider.checkUriPermission(uri, android.os.Process.myUid(), 0));    }   ]) :|: 
    public void testCheckUriPermission() {
        MockContentProvider provider = new MockContentProvider();
        final Uri uri = Uri.parse(""content://test"");
        assertEquals(PackageManager.PERMISSION_DENIED,
                provider.checkUriPermission(uri, android.os.Process.myUid(), 0));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContentProviderTest"	"isTemporary"	"CtsContentTestCases"	"1: permission"	"([8:/android/content/cts/ContentProviderTest.java]:[permission]:[8]:method_text:[mode) throws FileNotFoundException {            return openFileHelper(uri, mode);        }    }}]) :|: 
    @EnsureHasWorkProfile
    @AppModeFull
    public void createContentUriForUser_returnsCorrectUri() {
        final ContentResolver profileContentResolver =
                sTestApis.context().androidContextAsUser(sDeviceState.workProfile())
                        .getContentResolver();
        final String testContentDisplayName = ""testContent.mp3"";
        final Uri workProfileUriWithoutUserId = createAndInsertTestAudioFile(
                profileContentResolver, testContentDisplayName);

        final Uri workProfileUriWithUserId = ContentProvider.createContentUriForUser(
                workProfileUriWithoutUserId, sDeviceState.workProfile().userHandle());

        assertThat(getAudioContentDisplayName(
                sContext.getContentResolver(), workProfileUriWithUserId))
                .isEqualTo(testContentDisplayName);
    }

    private Uri createAndInsertTestAudioFile(ContentResolver resolver, String displayName) {
        final Uri audioCollection = MediaStore.Audio.Media.getContentUri(
                MediaStore.VOLUME_EXTERNAL_PRIMARY);
        final ContentValues testContent = new ContentValues();
        testContent.put(MediaStore.Audio.Media.DISPLAY_NAME, displayName);
        return resolver.insert(audioCollection, testContent);
    }

    private String getAudioContentDisplayName(ContentResolver resolver, Uri uri) {
        String name = null;
        try (Cursor cursor = resolver.query(
                uri,
                /* projection = */ null,
                /* selection = */ null,
                /* selectionArgs = */ null,
                /* sortOrder = */ null)) {
            final int nameColumn =
                    cursor.getColumnIndexOrThrow(MediaStore.Audio.Media.DISPLAY_NAME);
            if (cursor.moveToNext()) {
                name = cursor.getString(nameColumn);
            }
        }
        return name;
    }

    private class MockContentProvider extends ContentProvider {
        private int mInsertCount = 0;"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentProviderTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"getContextUnderTest"	"CtsContentTestCases"	"1: permission"	"([14:/android/content/cts/ContextTest.java]:[permission]:[14]:method_text:[{            mContext.unregisterReceiver(receiver);        }        super.tearDown();    }   ]) :|: public void test/*
 *.
 */

package android.content.cts;

import static android.content.pm.PackageManager.PERMISSION_DENIED;
import static android.content.pm.PackageManager.PERMISSION_GRANTED;

import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;

import android.app.Activity;
import android.app.AppOpsManager;
import android.app.Instrumentation;
import android.app.WallpaperManager;
import android.content.ActivityNotFoundException;
import android.content.AttributionSource;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.ContextParams;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.ServiceConnection;
import android.content.SharedPreferences;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.res.ColorStateList;
import android.content.res.Resources.NotFoundException;
import android.content.res.Resources.Theme;
import android.content.res.TypedArray;
import android.content.res.XmlResourceParser;
import android.database.Cursor;
import android.database.sqlite.SQLiteCursorDriver;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteQuery;
import android.graphics.Bitmap;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Binder;
import android.os.Bundle;
import android.os.Handler;
import android.os.IBinder;
import android.os.Looper;
import android.os.Process;
import android.os.UserHandle;
import android.platform.test.annotations.AppModeFull;
import android.preference.PreferenceManager;
import android.test.AndroidTestCase;
import android.util.AttributeSet;
import android.util.Log;
import android.util.Xml;
import android.view.WindowManager;

import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdent"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testSendOrderedBroadcastWithAppOp"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/cts/ContextTest.java]:[permission]:[2]:method_text:[                  && finalReceiver.hasReceivedBroadCast();            }        }.run();    }   ]) :|: public void testSendOrderedBroadcastWithAppOp() {
        // we use a HighPriorityBroadcastReceiver because the final receiver should get the
        // broadcast only at the end.
        final ResultReceiver receiver = new HighPriorityBroadcastReceiver();
        final ResultReceiver finalReceiver = new ResultReceiver();

        AppOpsManager aom =
                (AppOpsManager) getContextUnderTest().getSystemService(Context.APP_OPS_SERVICE);
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(aom,
                (appOpsMan) -> appOpsMan.setUidMode(AppOpsManager.OPSTR_READ_CELL_BROADCASTS,
                Process.myUid(), AppOpsManager.MODE_ALLOWED));

        registerBroadcastReceiver(receiver, new IntentFilter(ResultReceiver.MOCK_ACTION));

        mContext.sendOrderedBroadcast(
                new Intent(ResultReceiver.MOCK_ACTION),
                null, // permission
                AppOpsManager.OPSTR_READ_CELL_BROADCASTS,
                finalReceiver,
                null, // scheduler
                0, // initial code
                null, //initial data
                null); // initial extras

        new PollingCheck(BROADCAST_TIMEOUT){
            @Override
            protected boolean check() {
                return receiver.hasReceivedBroadCast()
                        && !finalReceiver.hasReceivedBroadCast();
            }
        }.run();

        synchronized (receiver) {
            receiver.notify();
        }

        new PollingCheck(BROADCAST_TIMEOUT){
            @Override
            protected boolean check() {
                // ensure that first receiver has received broadcast before final receiver
                return receiver.hasReceivedBroadCast()
                        && finalReceiver.hasReceivedBroadCast();
            }
        }.run();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testSendOrderedBroadcastWithAppOp_NotGranted"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/cts/ContextTest.java]:[permission]:[2]:method_text:[            broadcastNeverSent = true;        }        assertTrue(broadcastNeverSent);    }   ]) :|: public void testSendOrderedBroadcastWithAppOp_NotGranted() {
        final ResultReceiver receiver = new ResultReceiver();

        AppOpsManager aom =
                (AppOpsManager) getContextUnderTest().getSystemService(Context.APP_OPS_SERVICE);
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(aom,
                (appOpsMan) -> appOpsMan.setUidMode(AppOpsManager.OPSTR_READ_CELL_BROADCASTS,
                        Process.myUid(), AppOpsManager.MODE_ERRORED));

        registerBroadcastReceiver(receiver, new IntentFilter(ResultReceiver.MOCK_ACTION));

        mContext.sendOrderedBroadcast(
                new Intent(ResultReceiver.MOCK_ACTION),
                null, // permission
                AppOpsManager.OPSTR_READ_CELL_BROADCASTS,
                null, // final receiver
                null, // scheduler
                0, // initial code
                null, //initial data
                null); // initial extras

        boolean broadcastNeverSent = false;
        try {
            new PollingCheck(BROADCAST_TIMEOUT) {
                @Override
                protected boolean check() {
                    return receiver.hasReceivedBroadCast();
                }

                public void runWithInterruption() throws InterruptedException {
                    if (check()) {
                        return;
                    }

                    long timeout = BROADCAST_TIMEOUT;
                    while (timeout > 0) {
                        try {
                            Thread.sleep(50 /* time slice */);
                        } catch (InterruptedException e) {
                            fail(""unexpected InterruptedException"");
                        }

                        if (check()) {
                            return;
                        }

                        timeout -= 50; // time slice
                    }
                    throw new InterruptedException();
                }
            }.runWithI"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testRegisterReceiverForAllUsers"	"CtsContentTestCases"	"1: permission"	"([3:/android/content/cts/ContextTest.java]:[permission]:[3]:method_text:[ceiver.hadReceivedBroadCast2());        mContext.unregisterReceiver(broadcastReceiver);    }   ]) :|: public void testRegisterReceiverForAllUsers() throws InterruptedException {
        FilteredReceiver broadcastReceiver = new FilteredReceiver();
        IntentFilter filter = new IntentFilter();
        filter.addAction(MOCK_ACTION1);

        // Test registerReceiverForAllUsers without permission: verify SecurityException.
        try {
            mContext.registerReceiverForAllUsers(broadcastReceiver, filter, null, null);
            fail(""testRegisterReceiverForAllUsers: ""
                    + ""SecurityException expected on registerReceiverForAllUsers"");
        } catch (SecurityException se) {
            // expected
        }

        // Test registerReceiverForAllUsers with permission.
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mContext,
                    (ctx) -> ctx.registerReceiverForAllUsers(broadcastReceiver, filter, null, null)
            );
        } catch (SecurityException se) {
            fail(""testRegisterReceiverForAllUsers: SecurityException not expected"");
        }

        // Test unwanted intent(action = MOCK_ACTION2)
        broadcastReceiver.reset();
        waitForFilteredIntent(mContext, MOCK_ACTION2);
        assertFalse(broadcastReceiver.hadReceivedBroadCast1());
        assertFalse(broadcastReceiver.hadReceivedBroadCast2());

        // Send wanted intent(action = MOCK_ACTION1)
        broadcastReceiver.reset();
        waitForFilteredIntent(mContext, MOCK_ACTION1);
        assertTrue(broadcastReceiver.hadReceivedBroadCast1());
        assertEquals(broadcastReceiver.getSendingUser(), Process.myUserHandle());
        assertFalse(broadcastReceiver.hadReceivedBroadCast2());

        mContext.unregisterReceiver(broadcastReceiver);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testEnforceUriPermission1"	"CtsContentTestCases"	"1: permission"	"([5:/android/content/cts/ContextTest.java]:[permission]:[5]:method_text:[eption here because currently no            // IPC is handled by this process.        }    }   ]) :|: public void testEnforceUriPermission1() {
        try {
            Uri uri = Uri.parse(""content://ctstest"");
            mContext.enforceUriPermission(uri, Binder.getCallingPid(),
                    Binder.getCallingUid(), Intent.FLAG_GRANT_WRITE_URI_PERMISSION,
                    ""enforceUriPermission is not working without possessing an IPC."");
            fail(""enforceUriPermission is not working without possessing an IPC."");
        } catch (SecurityException e) {
            // If the function is OK, it should throw a SecurityException here because currently no
            // IPC is handled by this process.
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testEnforceUriPermission2"	"CtsContentTestCases"	"1: permission"	"([7:/android/content/cts/ContextTest.java]:[permission]:[7]:method_text:[eption here because currently no            // IPC is handled by this process.        }    }   ]) :|: public void testEnforceUriPermission2() {
        Uri uri = Uri.parse(""content://ctstest"");
        try {
            mContext.enforceUriPermission(uri, NOT_GRANTED_PERMISSION,
                    NOT_GRANTED_PERMISSION, Binder.getCallingPid(), Binder.getCallingUid(),
                    Intent.FLAG_GRANT_WRITE_URI_PERMISSION,
                    ""enforceUriPermission is not working without possessing an IPC."");
            fail(""enforceUriPermission is not working without possessing an IPC."");
        } catch (SecurityException e) {
            // If the function is ok, it should throw a SecurityException here because currently no
            // IPC is handled by this process.
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testStartActivityAsUser"	"CtsContentTestCases"	"1: permission"	"([1:/android/content/cts/ContextTest.java]:[permission]:[1]:method_text:[                    mContext.startActivityAsUser(intent, UserHandle.CURRENT)));        }    }   ]) :|: public void testStartActivityAsUser() {
        try (ActivitySession activitySession = new ActivitySession()) {
            Intent intent = new Intent(mContext, AvailableIntentsActivity.class);

            activitySession.assertActivityLaunched(intent.getComponent().getClassName(),
                    () -> SystemUtil.runWithShellPermissionIdentity(() ->
                            mContext.startActivityAsUser(intent, UserHandle.CURRENT)));
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testRevokeUriPermission"	"CtsContentTestCases"	"1: permission"	"([3:/android/content/cts/ContextTest.java]:[permission]:[3]:method_text:[est"");        mContext.revokeUriPermission(uri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);    }   ]) :|: public void testRevokeUriPermission() {
        Uri uri = Uri.parse(""contents://ctstest"");
        mContext.revokeUriPermission(uri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testCheckCallingOrSelfUriPermissions"	"CtsContentTestCases"	"1: permission"	"([5:/android/content/cts/ContextTest.java]:[permission]:[5]:method_text:[ls(PERMISSION_DENIED, retValue[0]);        assertEquals(PERMISSION_DENIED, retValue[1]);    }   ]) :|: public void testCheckCallingOrSelfUriPermissions() {
        List<Uri> uris = new ArrayList<>();
        Uri uri1 = Uri.parse(""content://ctstest1"");
        uris.add(uri1);
        Uri uri2 = Uri.parse(""content://ctstest2"");
        uris.add(uri2);

        int[] retValue = mContext.checkCallingOrSelfUriPermissions(uris,
                Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
        assertEquals(retValue.length, 2);
        // This package does not have access to the given URIs
        assertEquals(PERMISSION_DENIED, retValue[0]);
        assertEquals(PERMISSION_DENIED, retValue[1]);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testCheckCallingOrSelfUriPermission"	"CtsContentTestCases"	"1: permission"	"([4:/android/content/cts/ContextTest.java]:[permission]:[4]:method_text:[_WRITE_URI_PERMISSION);        assertEquals(PackageManager.PERMISSION_DENIED, retValue);    }   ]) :|: public void testCheckCallingOrSelfUriPermission() {
        Uri uri = Uri.parse(""content://ctstest"");

        int retValue = mContext.checkCallingOrSelfUriPermission(uri,
                Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
        assertEquals(PackageManager.PERMISSION_DENIED, retValue);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testGrantUriPermission"	"CtsContentTestCases"	"1: permission"	"([3:/android/content/cts/ContextTest.java]:[permission]:[3]:method_text:[Uri.parse(""contents://ctstest""),                Intent.FLAG_GRANT_WRITE_URI_PERMISSION);    }   ]) :|: public void testGrantUriPermission() {
        mContext.grantUriPermission(""com.android.mms"", Uri.parse(""contents://ctstest""),
                Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testCheckPermissionGranted"	"CtsContentTestCases"	"1: permission"	"([4:/android/content/cts/ContextTest.java]:[permission]:[4]:method_text:[, Process.myUid());        assertEquals(PackageManager.PERMISSION_GRANTED, returnValue);    }   ]) :|: public void testCheckPermissionGranted() {
        int returnValue = mContext.checkPermission(
                GRANTED_PERMISSION, Process.myPid(), Process.myUid());
        assertEquals(PackageManager.PERMISSION_GRANTED, returnValue);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testCheckPermissionNotGranted"	"CtsContentTestCases"	"1: permission"	"([4:/android/content/cts/ContextTest.java]:[permission]:[4]:method_text:[), Process.myUid());        assertEquals(PackageManager.PERMISSION_DENIED, returnValue);    }   ]) :|: public void testCheckPermissionNotGranted() {
        int returnValue = mContext.checkPermission(
                NOT_GRANTED_PERMISSION, Process.myPid(), Process.myUid());
        assertEquals(PackageManager.PERMISSION_DENIED, returnValue);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testCheckPermissionRootUser"	"CtsContentTestCases"	"1: permission"	"([4:/android/content/cts/ContextTest.java]:[permission]:[4]:method_text:[SION, 1, ROOT_UID);        assertEquals(PackageManager.PERMISSION_GRANTED, returnValue);    }   ]) :|: public void testCheckPermissionRootUser() {
        // Test with root user, everything will be granted.
        int returnValue = mContext.checkPermission(NOT_GRANTED_PERMISSION, 1, ROOT_UID);
        assertEquals(PackageManager.PERMISSION_GRANTED, returnValue);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testCheckPermissionInvalidRequest"	"CtsContentTestCases"	"1: permission"	"([9:/android/content/cts/ContextTest.java]:[permission]:[9]:method_text:[PERMISSION, 1, -11);        assertEquals(PackageManager.PERMISSION_DENIED, returnValue);    }   ]) :|: public void testCheckPermissionInvalidRequest() {
        // Test with null permission.
        try {
            int returnValue = mContext.checkPermission(null, 0, ROOT_UID);
            fail(""checkPermission should not accept null permission"");
        } catch (IllegalArgumentException e) {
        }

        // Test with invalid uid and included granted permission.
        int returnValue = mContext.checkPermission(GRANTED_PERMISSION, 1, -11);
        assertEquals(PackageManager.PERMISSION_DENIED, returnValue);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testCheckSelfPermissionGranted"	"CtsContentTestCases"	"1: permission"	"([4:/android/content/cts/ContextTest.java]:[permission]:[4]:method_text:[RANTED_PERMISSION);        assertEquals(PackageManager.PERMISSION_GRANTED, returnValue);    }   ]) :|: public void testCheckSelfPermissionGranted() {
        int returnValue = mContext.checkSelfPermission(GRANTED_PERMISSION);
        assertEquals(PackageManager.PERMISSION_GRANTED, returnValue);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testCheckSelfPermissionNotGranted"	"CtsContentTestCases"	"1: permission"	"([4:/android/content/cts/ContextTest.java]:[permission]:[4]:method_text:[GRANTED_PERMISSION);        assertEquals(PackageManager.PERMISSION_DENIED, returnValue);    }   ]) :|: public void testCheckSelfPermissionNotGranted() {
        int returnValue = mContext.checkSelfPermission(NOT_GRANTED_PERMISSION);
        assertEquals(PackageManager.PERMISSION_DENIED, returnValue);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testEnforcePermissionGranted"	"CtsContentTestCases"	"1: permission"	"([4:/android/content/cts/ContextTest.java]:[permission]:[4]:method_text:[ERMISSION, Process.myPid(), Process.myUid(),                ""permission isn't granted"");    }   ]) :|: public void testEnforcePermissionGranted() {
        mContext.enforcePermission(
                GRANTED_PERMISSION, Process.myPid(), Process.myUid(),
                ""permission isn't granted"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testEnforcePermissionNotGranted"	"CtsContentTestCases"	"1: permission"	"([5:/android/content/cts/ContextTest.java]:[permission]:[5]:method_text:[mission shouldn't be granted."");        } catch (SecurityException expected) {        }    }   ]) :|: public void testEnforcePermissionNotGranted() {
        try {
            mContext.enforcePermission(
                    NOT_GRANTED_PERMISSION, Process.myPid(), Process.myUid(),
                    ""permission isn't granted"");
            fail(""Permission shouldn't be granted."");
        } catch (SecurityException expected) {
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testCheckCallingOrSelfPermission_noIpc"	"CtsContentTestCases"	"1: permission"	"([8:/android/content/cts/ContextTest.java]:[permission]:[8]:method_text:[OT_GRANTED_PERMISSION);        assertEquals(PackageManager.PERMISSION_DENIED, retValue);    }   ]) :|: public void testCheckCallingOrSelfPermission_noIpc() {
        // There's no ongoing Binder call, so this package's permissions are checked.
        int retValue = mContext.checkCallingOrSelfPermission(GRANTED_PERMISSION);
        assertEquals(PackageManager.PERMISSION_GRANTED, retValue);

        retValue = mContext.checkCallingOrSelfPermission(NOT_GRANTED_PERMISSION);
        assertEquals(PackageManager.PERMISSION_DENIED, retValue);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testCheckCallingOrSelfPermission_ipc"	"CtsContentTestCases"	"1: permission"	"([11:/android/content/cts/ContextTest.java]:[permission]:[11]:method_text:[ finally {            mContext.unbindService(mBinderPermissionTestConnection);        }    }   ]) :|: public void testCheckCallingOrSelfPermission_ipc() throws Exception {
        bindBinderPermissionTestService();
        try {
            int retValue = mBinderPermissionTestService.doCheckCallingOrSelfPermission(
                    GRANTED_PERMISSION);
            assertEquals(PackageManager.PERMISSION_GRANTED, retValue);

            retValue = mBinderPermissionTestService.doCheckCallingOrSelfPermission(
                    NOT_GRANTED_PERMISSION);
            assertEquals(PackageManager.PERMISSION_DENIED, retValue);
        } finally {
            mContext.unbindService(mBinderPermissionTestConnection);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testEnforceCallingOrSelfPermission_noIpc"	"CtsContentTestCases"	"1: permission"	"([9:/android/content/cts/ContextTest.java]:[permission]:[9]:method_text:[mission shouldn't be granted."");        } catch (SecurityException expected) {        }    }   ]) :|: public void testEnforceCallingOrSelfPermission_noIpc() {
        // There's no ongoing Binder call, so this package's permissions are checked.
        mContext.enforceCallingOrSelfPermission(
                GRANTED_PERMISSION, ""permission isn't granted"");

        try {
            mContext.enforceCallingOrSelfPermission(
                    NOT_GRANTED_PERMISSION, ""permission isn't granted"");
            fail(""Permission shouldn't be granted."");
        } catch (SecurityException expected) {
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testEnforceCallingOrSelfPermission_ipc"	"CtsContentTestCases"	"1: permission"	"([10:/android/content/cts/ContextTest.java]:[permission]:[10]:method_text:[ finally {            mContext.unbindService(mBinderPermissionTestConnection);        }    }   ]) :|: public void testEnforceCallingOrSelfPermission_ipc() throws Exception {
        bindBinderPermissionTestService();
        try {
            mBinderPermissionTestService.doEnforceCallingOrSelfPermission(GRANTED_PERMISSION);

            try {
                mBinderPermissionTestService.doEnforceCallingOrSelfPermission(
                        NOT_GRANTED_PERMISSION);
                fail(""Permission shouldn't be granted."");
            } catch (SecurityException expected) {
            }
        } finally {
            mContext.unbindService(mBinderPermissionTestConnection);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testCheckCallingPermission_noIpc"	"CtsContentTestCases"	"1: permission"	"([4:/android/content/cts/ContextTest.java]:[permission]:[4]:method_text:[on(GRANTED_PERMISSION);        assertEquals(PackageManager.PERMISSION_DENIED, retValue);    }   ]) :|: public void testCheckCallingPermission_noIpc() {
        // Denied because no IPC is active.
        int retValue = mContext.checkCallingPermission(GRANTED_PERMISSION);
        assertEquals(PackageManager.PERMISSION_DENIED, retValue);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testEnforceCallingPermission_noIpc"	"CtsContentTestCases"	"1: permission"	"([5:/android/content/cts/ContextTest.java]:[permission]:[5]:method_text:[     // Currently no IPC is handled by this process, this exception is expected        }    }   ]) :|: public void testEnforceCallingPermission_noIpc() {
        try {
            mContext.enforceCallingPermission(
                    GRANTED_PERMISSION,
                    ""enforceCallingPermission is not working without possessing an IPC."");
            fail(""enforceCallingPermission is not working without possessing an IPC."");
        } catch (SecurityException e) {
            // Currently no IPC is handled by this process, this exception is expected
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testEnforceCallingPermission_ipc"	"CtsContentTestCases"	"1: permission"	"([10:/android/content/cts/ContextTest.java]:[permission]:[10]:method_text:[ finally {            mContext.unbindService(mBinderPermissionTestConnection);        }    }   ]) :|: public void testEnforceCallingPermission_ipc() throws Exception {
        bindBinderPermissionTestService();
        try {
            mBinderPermissionTestService.doEnforceCallingPermission(GRANTED_PERMISSION);

            try {
                mBinderPermissionTestService.doEnforceCallingPermission(NOT_GRANTED_PERMISSION);
                fail(""Permission shouldn't be granted."");
            } catch (SecurityException expected) {
            }
        } finally {
            mContext.unbindService(mBinderPermissionTestConnection);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testCheckCallingPermission_ipc"	"CtsContentTestCases"	"1: permission"	"([19:/android/content/cts/ContextTest.java]:[permission]:[19]:method_text:[BinderPermissionTestService != null; // Service was bound.            }        }.run();    }   ]) :|: public void testCheckCallingPermission_ipc() throws Exception {
        bindBinderPermissionTestService();
        try {
            int returnValue = mBinderPermissionTestService.doCheckCallingPermission(
                    GRANTED_PERMISSION);
            assertEquals(PackageManager.PERMISSION_GRANTED, returnValue);

            returnValue = mBinderPermissionTestService.doCheckCallingPermission(
                    NOT_GRANTED_PERMISSION);
            assertEquals(PackageManager.PERMISSION_DENIED, returnValue);
        } finally {
            mContext.unbindService(mBinderPermissionTestConnection);
        }
    }

    private void bindBinderPermissionTestService() {
        Intent intent = new Intent(mContext, IBinderPermissionTestService.class);
        intent.setComponent(new ComponentName(
                ""com.android.cts"", ""com.android.cts.BinderPermissionTestService""));

        mBinderPermissionTestConnection = new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName componentName, IBinder iBinder) {
                mBinderPermissionTestService =
                        IBinderPermissionTestService.Stub.asInterface(iBinder);
            }

            @Override
            public void onServiceDisconnected(ComponentName componentName) {
            }
        };

        assertTrue(""Service not bound"", mContext.bindService(
                intent, mBinderPermissionTestConnection, Context.BIND_AUTO_CREATE));

        new PollingCheck(15 * 1000) {
            protected boolean check() {
                return mBinderPermissionTestService != null; // Service was bound.
            }
        }.run();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testCheckUriPermissions"	"CtsContentTestCases"	"1: permission"	"([9:/android/content/cts/ContextTest.java]:[permission]:[9]:method_text:[ls(PERMISSION_DENIED, retValue[0]);        assertEquals(PERMISSION_DENIED, retValue[1]);    }   ]) :|: public void testCheckUriPermissions() {
        List<Uri> uris = new ArrayList<>();
        Uri uri1 = Uri.parse(""content://ctstest1"");
        uris.add(uri1);
        Uri uri2 = Uri.parse(""content://ctstest2"");
        uris.add(uri2);

        // Root has access to all URIs
        int[] retValue = mContext.checkUriPermissions(uris, Binder.getCallingPid(), 0,
                Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
        assertEquals(retValue.length, 2);
        assertEquals(PERMISSION_GRANTED, retValue[0]);
        assertEquals(PERMISSION_GRANTED, retValue[1]);

        retValue = mContext.checkUriPermissions(uris, Binder.getCallingPid(),
                Binder.getCallingUid(), Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
        assertEquals(retValue.length, 2);
        // This package does not have access to the given URIs
        assertEquals(PERMISSION_DENIED, retValue[0]);
        assertEquals(PERMISSION_DENIED, retValue[1]);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testCheckUriPermission1"	"CtsContentTestCases"	"1: permission"	"([7:/android/content/cts/ContextTest.java]:[permission]:[7]:method_text:[_WRITE_URI_PERMISSION);        assertEquals(PackageManager.PERMISSION_DENIED, retValue);    }   ]) :|: public void testCheckUriPermission1() {
        Uri uri = Uri.parse(""content://ctstest"");

        int retValue = mContext.checkUriPermission(uri, Binder.getCallingPid(), 0,
                Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
        assertEquals(PackageManager.PERMISSION_GRANTED, retValue);

        retValue = mContext.checkUriPermission(uri, Binder.getCallingPid(),
                Binder.getCallingUid(), Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
        assertEquals(PackageManager.PERMISSION_DENIED, retValue);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testCheckUriPermission2"	"CtsContentTestCases"	"1: permission"	"([11:/android/content/cts/ContextTest.java]:[permission]:[11]:method_text:[_WRITE_URI_PERMISSION);        assertEquals(PackageManager.PERMISSION_DENIED, retValue);    }   ]) :|: public void testCheckUriPermission2() {
        Uri uri = Uri.parse(""content://ctstest"");

        int retValue = mContext.checkUriPermission(uri, NOT_GRANTED_PERMISSION,
                NOT_GRANTED_PERMISSION, Binder.getCallingPid(), 0,
                Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
        assertEquals(PackageManager.PERMISSION_GRANTED, retValue);

        retValue = mContext.checkUriPermission(uri, NOT_GRANTED_PERMISSION,
                NOT_GRANTED_PERMISSION, Binder.getCallingPid(), Binder.getCallingUid(),
                Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
        assertEquals(PackageManager.PERMISSION_DENIED, retValue);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testCheckCallingUriPermissions"	"CtsContentTestCases"	"1: permission"	"([5:/android/content/cts/ContextTest.java]:[permission]:[5]:method_text:[ls(PERMISSION_DENIED, retValue[0]);        assertEquals(PERMISSION_DENIED, retValue[1]);    }   ]) :|: public void testCheckCallingUriPermissions() {
        List<Uri> uris = new ArrayList<>();
        Uri uri1 = Uri.parse(""content://ctstest1"");
        uris.add(uri1);
        Uri uri2 = Uri.parse(""content://ctstest2"");
        uris.add(uri2);

        int[] retValue = mContext.checkCallingUriPermissions(uris,
                Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
        assertEquals(retValue.length, 2);
        // This package does not have access to the given URIs
        assertEquals(PERMISSION_DENIED, retValue[0]);
        assertEquals(PERMISSION_DENIED, retValue[1]);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testCheckCallingUriPermission"	"CtsContentTestCases"	"1: permission"	"([4:/android/content/cts/ContextTest.java]:[permission]:[4]:method_text:[_WRITE_URI_PERMISSION);        assertEquals(PackageManager.PERMISSION_DENIED, retValue);    }   ]) :|: public void testCheckCallingUriPermission() {
        Uri uri = Uri.parse(""content://ctstest"");

        int retValue = mContext.checkCallingUriPermission(uri,
                Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
        assertEquals(PackageManager.PERMISSION_DENIED, retValue);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testEnforceCallingUriPermission"	"CtsContentTestCases"	"1: permission"	"([5:/android/content/cts/ContextTest.java]:[permission]:[5]:method_text:[eption here because currently no            // IPC is handled by this process.        }    }   ]) :|: public void testEnforceCallingUriPermission() {
        try {
            Uri uri = Uri.parse(""content://ctstest"");
            mContext.enforceCallingUriPermission(uri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION,
                    ""enforceCallingUriPermission is not working without possessing an IPC."");
            fail(""enforceCallingUriPermission is not working without possessing an IPC."");
        } catch (SecurityException e) {
            // If the function is OK, it should throw a SecurityException here because currently no
            // IPC is handled by this process.
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testSendBroadcast2"	"CtsContentTestCases"	"1: permission"	"([1:/android/content/cts/ContextTest.java]:[permission]:[1]:method_text:[ }.run();    }    /** The receiver should get the broadcast if it has all the permissions. */   ]) :|: public void testSendBroadcast2() throws InterruptedException {
        final ResultReceiver receiver = new ResultReceiver();

        registerBroadcastReceiver(receiver, new IntentFilter(ResultReceiver.MOCK_ACTION));

        mContext.sendBroadcast(new Intent(ResultReceiver.MOCK_ACTION), null);

        new PollingCheck(BROADCAST_TIMEOUT){
            @Override
            protected boolean check() {
                return receiver.hasReceivedBroadCast();
            }
        }.run();
    }

    /** The receiver should get the broadcast if it has all the permissions. */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testSendBroadcastWithMultiplePermissions_receiverHasAllPermissions"	"CtsContentTestCases"	"1: permission"	"([7:/android/content/cts/ContextTest.java]:[permission]:[7]:method_text:[}    /** The receiver should not get the broadcast if it does not have all the permissions. */   ]) :|: public void testSendBroadcastWithMultiplePermissions_receiverHasAllPermissions()
            throws Exception {
        final ResultReceiver receiver = new ResultReceiver();

        registerBroadcastReceiver(receiver, new IntentFilter(ResultReceiver.MOCK_ACTION));

        mContext.sendBroadcastWithMultiplePermissions(
                new Intent(ResultReceiver.MOCK_ACTION),
                new String[] { // this test APK has both these permissions
                        android.Manifest.permission.ACCESS_WIFI_STATE,
                        android.Manifest.permission.ACCESS_NETWORK_STATE,
                });

        new PollingCheck(BROADCAST_TIMEOUT) {
            @Override
            protected boolean check() {
                return receiver.hasReceivedBroadCast();
            }
        }.run();
    }

    /** The receiver should not get the broadcast if it does not have all the permissions. */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testSendBroadcastWithMultiplePermissions_receiverHasSomePermissions"	"CtsContentTestCases"	"1: permission"	"([6:/android/content/cts/ContextTest.java]:[permission]:[6]:method_text:[;    }    /** The receiver should not get the broadcast if it has none of the permissions. */   ]) :|: public void testSendBroadcastWithMultiplePermissions_receiverHasSomePermissions()
            throws Exception {
        final ResultReceiver receiver = new ResultReceiver();

        registerBroadcastReceiver(receiver, new IntentFilter(ResultReceiver.MOCK_ACTION));

        mContext.sendBroadcastWithMultiplePermissions(
                new Intent(ResultReceiver.MOCK_ACTION),
                new String[] { // this test APK only has ACCESS_WIFI_STATE
                        android.Manifest.permission.ACCESS_WIFI_STATE,
                        android.Manifest.permission.NETWORK_STACK,
                });

        Thread.sleep(BROADCAST_TIMEOUT);
        assertFalse(receiver.hasReceivedBroadCast());
    }

    /** The receiver should not get the broadcast if it has none of the permissions. */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testSendBroadcastWithMultiplePermissions_receiverHasNoPermissions"	"CtsContentTestCases"	"1: permission"	"([6:/android/content/cts/ContextTest.java]:[permission]:[6]:method_text:[   Thread.sleep(BROADCAST_TIMEOUT);        assertFalse(receiver.hasReceivedBroadCast());    }   ]) :|: public void testSendBroadcastWithMultiplePermissions_receiverHasNoPermissions()
            throws Exception {
        final ResultReceiver receiver = new ResultReceiver();

        registerBroadcastReceiver(receiver, new IntentFilter(ResultReceiver.MOCK_ACTION));

        mContext.sendBroadcastWithMultiplePermissions(
                new Intent(ResultReceiver.MOCK_ACTION),
                new String[] { // this test APK has neither of these permissions
                        android.Manifest.permission.NETWORK_SETTINGS,
                        android.Manifest.permission.NETWORK_STACK,
                });

        Thread.sleep(BROADCAST_TIMEOUT);
        assertFalse(receiver.hasReceivedBroadCast());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContextTest"	"testEnforceCallingOrSelfUriPermission"	"CtsContentTestCases"	"1: permission"	"([5:/android/content/cts/ContextTest.java]:[permission]:[5]:method_text:[eption here because currently no            // IPC is handled by this process.        }    }   ]) :|: public void testEnforceCallingOrSelfUriPermission() {
        try {
            Uri uri = Uri.parse(""content://ctstest"");
            mContext.enforceCallingOrSelfUriPermission(uri,
                    Intent.FLAG_GRANT_WRITE_URI_PERMISSION,
                    ""enforceCallingOrSelfUriPermission is not working without possessing an IPC."");
            fail(""enforceCallingOrSelfUriPermission is not working without possessing an IPC."");
        } catch (SecurityException e) {
            // If the function is OK, it should throw a SecurityException here because currently no
            // IPC is handled by this process.
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContextTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ClipboardManagerTest"	"dropShellPermissionIdentity"	"CtsContentTestCases"	"1: permission"	"([1:/android/content/cts/ClipboardManagerTest.java]:[permission]:[1]:method_text:[ry.getInstrumentation().getUiAutomation()                .dropShellPermissionIdentity();    }   ]) :|: /*
 *.
 */

package android.content.cts;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assume.assumeTrue;

import android.Manifest;
import android.app.Activity;
import android.content.ClipData;
import android.content.ClipData.Item;
import android.content.ClipDescription;
import android.content.ClipboardManager;
import android.content.ClipboardManager.OnPrimaryClipChangedListener;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.net.Uri;
import android.support.test.uiautomator.By;
import android.support.test.uiautomator.UiDevice;
import android.support.test.uiautomator.Until;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

@RunWith(AndroidJUnit4.class)
//@AppModeFull // TODO(Instant) Should clip board data be visible?
public class ClipboardManagerTest {
    private final Context mContext = InstrumentationRegistry.getTargetContext();
    private ClipboardManager mClipboardManager;
    private UiDevice mUiDevice;

    @Before
    public void setUp() throws Exception {
        assumeTrue(""Skipping Test: Wear-Os does not support ClipboardService"", hasAutoFillFeature());
        mClipboardManager = mContext.getSystemService(ClipboardManager.class);
        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        mUiDevice.wakeUp();
        launchActivity(MockActivity.class);
    }

    @After
    public void cleanUp() {
        InstrumentationRegistry.g"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ClipboardManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ClipboardManagerTest"	"testClipSourceRecordedWhenClipSet"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/cts/ClipboardManagerTest.java]:[permission]:[2]:method_text:[              mClipboardManager.getPrimaryClipSource()).isEqualTo(""android.content.cts"");    }   ]) :|: 
    public void testClipSourceRecordedWhenClipSet() {
        ClipData clipData = ClipData.newPlainText(""TextLabel"", ""Text1"");
        mClipboardManager.setPrimaryClip(clipData);

        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(Manifest.permission.SET_CLIP_SOURCE);
        assertThat(
                mClipboardManager.getPrimaryClipSource()).isEqualTo(""android.content.cts"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ClipboardManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ClipboardManagerTest"	"testSetPrimaryClipAsPackage"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/cts/ClipboardManagerTest.java]:[permission]:[2]:method_text:[text.getPackageManager().hasSystemFeature(                PackageManager.FEATURE_AUTOFILL);    }}]) :|: 
    public void testSetPrimaryClipAsPackage() {
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(Manifest.permission.SET_CLIP_SOURCE);

        ClipData clipData = ClipData.newPlainText(""TextLabel"", ""Text1"");
        mClipboardManager.setPrimaryClipAsPackage(clipData, ""test.package"");

        assertThat(
                mClipboardManager.getPrimaryClipSource()).isEqualTo(""test.package"");
    }

    private void launchActivity(Class<? extends Activity> clazz) {
        Intent intent = new Intent(Intent.ACTION_MAIN);
        intent.setClassName(mContext.getPackageName(), clazz.getName());
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(intent);
        mUiDevice.wait(Until.hasObject(By.pkg(clazz.getPackageName())), 15000);
    }

    private class ExpectedClipItem {
        CharSequence mText;
        Intent mIntent;
        Uri mUri;

        ExpectedClipItem(CharSequence text, Intent intent, Uri uri) {
            mText = text;
            mIntent = intent;
            mUri = uri;
        }
    }

    private void assertSetPrimaryClip(ClipData clipData,
            String expectedLabel,
            String[] expectedMimeTypes,
            ExpectedClipItem... expectedClipItems) {
        ClipboardManager clipboardManager = mClipboardManager;

        clipboardManager.setPrimaryClip(clipData);
        assertTrue(clipboardManager.hasPrimaryClip());

        if (expectedClipItems != null
                && expectedClipItems.length > 0
                && expectedClipItems[0].mText != null) {
            assertTrue(clipboardManager.hasText());
        } else {
            assertFalse(clipboardManager.hasText());
        }

        assertNotNull(clipboardManager.getPrimaryClip());
        assertNotNull(clipboardManager.getPrimaryClipDescription());

        assertClipData(clipboardManager.getPrimaryClip(),
                expectedLabel, expectedMimeTypes, expectedCli"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ClipboardManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContentResolverTest"	"dropShellPermissionIdentity"	"CtsContentTestCases"	"1: permission"	"([1:/android/content/cts/ContentResolverTest.java]:[permission]:[1]:method_text:[ !mCursor.isClosed() ) {            mCursor.close();        }        super.tearDown();    }   ]) :|: public void test/*
 *.
 */

package android.content.cts;

import static android.content.ContentResolver.NOTIFY_INSERT;
import static android.content.ContentResolver.NOTIFY_UPDATE;

import android.accounts.Account;
import android.content.ContentProviderClient;
import android.content.ContentResolver;
import android.content.ContentResolver.MimeTypeInfo;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.res.AssetFileDescriptor;
import android.database.ContentObserver;
import android.database.Cursor;
import android.icu.text.Collator;
import android.icu.util.ULocale;
import android.net.Uri;
import android.os.Bundle;
import android.os.CancellationSignal;
import android.os.OperationCanceledException;
import android.os.ParcelFileDescriptor;
import android.os.RemoteException;
import android.platform.test.annotations.AppModeFull;
import android.test.AndroidTestCase;
import android.util.Log;

import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.PollingCheck;
import com.android.internal.util.ArrayUtils;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

public class ContentResolverTest extends AndroidTestCase {
    private static final String TAG = ""ContentResolverTest"";

    private final static String COLUMN_ID_NAME = ""_id"";
    private final static String COLUMN_KEY_NAME = ""key"";
    private final static String COLUMN_VALUE_NAME = ""value"";

    private static final String AUTHORITY = ""ctstest"";
    private sta"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentResolverTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContentResolverTest"	"testCheckUriPermission"	"CtsContentTestCases"	"1: permission"	"([7:/android/content/cts/ContentResolverTest.java]:[permission]:[7]:method_text:[        TABLE1_URI, android.os.Process.myUid(), Intent.FLAG_GRANT_WRITE_URI_PERMISSION));    }   ]) :|: public void testCheckUriPermission() {
        assertEquals(PackageManager.PERMISSION_GRANTED, mContentResolver.checkUriPermission(
                TABLE1_URI, android.os.Process.myUid(), Intent.FLAG_GRANT_READ_URI_PERMISSION));
        assertEquals(PackageManager.PERMISSION_DENIED, mContentResolver.checkUriPermission(
                TABLE1_URI, android.os.Process.myUid(), Intent.FLAG_GRANT_WRITE_URI_PERMISSION));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentResolverTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContentResolverTest"	"testHangRecover"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/cts/ContentResolverTest.java]:[permission]:[2]:method_text:[freed, then we        // fail with a timeout.        latch.await(10, TimeUnit.SECONDS);    }   ]) :|: public void testHangRecover() throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(android.Manifest.permission.REMOVE_TASKS);

        final CountDownLatch latch = new CountDownLatch(1);
        new Thread(() -> {
            final ContentProviderClient client = mContentResolver
                    .acquireUnstableContentProviderClient(REMOTE_AUTHORITY);
            client.setDetectNotResponding(2_000);
            try {
                client.query(REMOTE_HANG_URI, null, null, null);
                fail(""Funky, we somehow returned?"");
            } catch (RemoteException e) {
                latch.countDown();
            }
        }).start();

        // The remote process should have been killed after the ANR was detected
        // above, causing our pending call to return and release our latch above
        // within 10 seconds; if our Binder thread hasn't been freed, then we
        // fail with a timeout.
        latch.await(10, TimeUnit.SECONDS);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentResolverTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ContentResolverTest"	"testContentResolverCaching"	"CtsContentTestCases"	"1: permission"	"([3:/android/content/cts/ContentResolverTest.java]:[permission]:[3]:method_text:[        response = mContentResolver.getCache(TABLE1_URI);        assertNull(response);    }   ]) :|: public void testContentResolverCaching() throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().adoptShellPermissionIdentity(
                android.Manifest.permission.CACHE_CONTENT,
                android.Manifest.permission.INTERACT_ACROSS_USERS_FULL);

        Bundle cached = new Bundle();
        cached.putString(""key"", ""value"");
        mContentResolver.putCache(TABLE1_URI, cached);

        Bundle response = mContentResolver.getCache(TABLE1_URI);
        assertEquals(""value"", response.getString(""key""));

        ContentValues values = new ContentValues();
        values.put(COLUMN_KEY_NAME, ""key10"");
        values.put(COLUMN_VALUE_NAME, 10);
        mContentResolver.update(TABLE1_URI, values, null, null);

        response = mContentResolver.getCache(TABLE1_URI);
        assertNull(response);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ContentResolverTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.BroadcastReceiverTest"	"BroadcastReceiverTest"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/cts/BroadcastReceiverTest.java]:[permission]:[2]:method_text:[    }    @Override    protected void setUp() throws Exception {        super.setUp();    }   ]) :|: public void test/*
 *.
 */

package android.content.cts;


import android.app.Service;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.ServiceConnection;
import android.content.pm.PackageManager;
import android.hardware.Camera;
import android.os.Bundle;
import android.os.IBinder;
import android.platform.test.annotations.AppModeFull;
import android.test.ActivityInstrumentationTestCase2;

/**
 * Test {@link BroadcastReceiver}.
 * TODO:  integrate the existing tests.
 */
public class BroadcastReceiverTest extends ActivityInstrumentationTestCase2<MockActivity> {
    private static final int RESULT_INITIAL_CODE = 1;
    private static final String RESULT_INITIAL_DATA = ""initial data"";

    private static final int RESULT_INTERNAL_FINAL_CODE = 7;
    private static final String RESULT_INTERNAL_FINAL_DATA = ""internal final data"";

    private static final String ACTION_BROADCAST_INTERNAL =
            ""android.content.cts.BroadcastReceiverTest.BROADCAST_INTERNAL"";
    private static final String ACTION_BROADCAST_MOCKTEST =
            ""android.content.cts.BroadcastReceiverTest.BROADCAST_MOCKTEST"";
    private static final String ACTION_BROADCAST_TESTABORT =
            ""android.content.cts.BroadcastReceiverTest.BROADCAST_TESTABORT"";
    private static final String ACTION_BROADCAST_DISABLED =
            ""android.content.cts.BroadcastReceiverTest.BROADCAST_DISABLED"";
    private static final String TEST_PACKAGE_NAME = ""android.content.cts"";

    private static final String SIGNATURE_PERMISSION = ""android.content.cts.SIGNATURE_PERMISSION"";

    private static final long SEND_BROADCAST_TIMEOUT = 15000;
    private static final long START_SERVICE_TIMEOUT  = 3000;

    private static final ComponentName DISABLEABLE_RECEIVER =
            new ComponentName(""android.content.cts"",
                    ""android.content.cts.MockRec"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/BroadcastReceiverTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.BroadcastReceiverTest"	"testManifestReceiverPermission"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/cts/BroadcastReceiverTest.java]:[permission]:[2]:method_text:[KEY));        assertNull(resultExtras.getString(MockReceiver.RESULT_EXTRAS_REMOVE_KEY));    }   ]) :|: public void testManifestReceiverPermission() throws InterruptedException {
        MockReceiverInternal internalReceiver = new MockReceiverInternal();

        Bundle map = new Bundle();
        map.putString(MockReceiver.RESULT_EXTRAS_INVARIABLE_KEY,
                MockReceiver.RESULT_EXTRAS_INVARIABLE_VALUE);
        map.putString(MockReceiver.RESULT_EXTRAS_REMOVE_KEY,
                MockReceiver.RESULT_EXTRAS_REMOVE_VALUE);
        getInstrumentation().getContext().sendOrderedBroadcast(
                new Intent(ACTION_BROADCAST_MOCKTEST)
                        .addFlags(Intent.FLAG_RECEIVER_FOREGROUND),
                SIGNATURE_PERMISSION, internalReceiver,
                null, RESULT_INITIAL_CODE, RESULT_INITIAL_DATA, map);
        internalReceiver.waitForReceiver(SEND_BROADCAST_TIMEOUT);

        // These are set by MockReceiver.
        assertEquals(MockReceiver.RESULT_CODE, internalReceiver.getResultCode());
        assertEquals(MockReceiver.RESULT_DATA, internalReceiver.getResultData());

        Bundle resultExtras = internalReceiver.getResultExtras(false);
        assertEquals(MockReceiver.RESULT_EXTRAS_INVARIABLE_VALUE,
                resultExtras.getString(MockReceiver.RESULT_EXTRAS_INVARIABLE_KEY));
        assertEquals(MockReceiver.RESULT_EXTRAS_ADD_VALUE,
                resultExtras.getString(MockReceiver.RESULT_EXTRAS_ADD_KEY));
        assertNull(resultExtras.getString(MockReceiver.RESULT_EXTRAS_REMOVE_KEY));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/BroadcastReceiverTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.IntentTest"	"testResolveActivityMultipleMatch"	"CtsContentTestCases"	"1: permission"	"([4:/android/content/cts/IntentTest.java]:[permission]:[4]:method_text:[        + "" doesn't have SET_PREFERRED_APPLICATIONS permission"");            }        }    }   ]) :|: public void testResolveActivityMultipleMatch() {
        final Intent intent = new Intent(""android.content.cts.action.TEST_ACTION"");

        // Should have multiple activities, resulting in resolver dialog
        final ComponentName target = intent.resolveActivity(mPm);
        final String pkgName = target.getPackageName();
        assertFalse(""android.content.cts"".equals(pkgName));

        // Whoever they are must be able to set preferred activities
        if (!""android"".equals(pkgName)) {
            if (mPm.checkPermission(android.Manifest.permission.SET_PREFERRED_APPLICATIONS, pkgName)
                    != PackageManager.PERMISSION_GRANTED) {
                fail(""Resolved target "" + target
                        + "" doesn't have SET_PREFERRED_APPLICATIONS permission"");
            }
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/IntentTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.IntentTest"	"testGetIntent"	"CtsContentTestCases"	"1: permission"	"([4:/android/content/cts/IntentTest.java]:[permission]:[4]:method_text:[i);        assertEquals(testShort, target.getShortExtra(TEST_EXTRA_NAME, defaultShort));    }   ]) :|: public void testGetIntent() throws URISyntaxException {
        mIntent = Intent.getIntent(""test#"");
        assertEquals(Intent.ACTION_VIEW, mIntent.getAction());

        try {
            String uri = ""#Intent;action=android.content.IntentTest_test;""
                    + ""category=testCategory;type=testtype;identifier=testident;launchFlags=0x1;""
                    + ""component=com.android/.app.MockActivity;K.testExtraName=1;end"";
            mIntent = Intent.getIntent(uri);
            fail(""should throw URISyntaxException."");
        } catch (Exception e) {
            // expected
        }
        mIntent = new Intent();

        String uri = mIntent.toURI();
        Intent target = Intent.getIntent(uri);
        assertEquals(Intent.ACTION_VIEW, target.getAction());

        mIntent.setAction(TEST_ACTION);
        uri = mIntent.toURI();
        target = Intent.getIntent(uri);
        assertEquals(TEST_ACTION, target.getAction());

        mIntent.setData(TEST_URI);
        uri = mIntent.toURI();
        target = Intent.getIntent(uri);
        assertEquals(TEST_URI, target.getData());

        mIntent.setComponent(mComponentName);
        uri = mIntent.toURI();
        target = Intent.getIntent(uri);
        assertEquals(mComponentName, target.getComponent());

        mIntent.addCategory(TEST_CATEGORY);
        uri = mIntent.toURI();
        target = Intent.getIntent(uri);
        assertEquals(1, target.getCategories().size());
        assertEquals(TEST_CATEGORY, (String) (target.getCategories().toArray()[0]));

        mIntent.setType(TEST_TYPE);
        uri = mIntent.toURI();
        target = Intent.getIntent(uri);
        assertEquals(TEST_TYPE, target.getType());

        mIntent.setIdentifier(TEST_IDENTIFIER);
        uri = mIntent.toURI();
        target = Intent.getIntent(uri);
        assertEquals(TEST_IDENTIFIER, target.getIdentifier());

        mIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_DOCUMENT
                | Intent.FLAG_GRANT_WRITE_URI_PERMISSI"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/IntentTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.cts.ReadableFileReceiverActivity"	"finish"	"CtsContentTestCases"	"1: permission"	"([4:/android/content/cts/ReadableFileReceiverActivity.java]:[permission]:[4]:method_text:[tring(buffer);        return ReadableUriExtraToClipDataTest.TEST_INPUT.equals(fileContents);    }]) :|: public void test/*
 *.
 */
package android.content.cts;

import android.app.Activity;
import android.content.ClipData;
import android.content.ClipData.Item;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.util.Log;

import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;
import java.util.ArrayList;
import java.util.List;

public class ReadableFileReceiverActivity extends Activity {
    public static final String ACTION_CONFIRM_READ_SUCCESS
        = ""android.content.cts.action.CONFIRM_READ_SUCCESS"";
    private static final String TAG = ReadableUriExtraToClipDataTest.TAG;

    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Intent intent = getIntent();

        // Check action.
        String action = intent.getAction();
        if (Intent.ACTION_SEND.equals(action)
                || Intent.ACTION_SEND_MULTIPLE.equals(action)) {
            readFilesFromClipDataUri(intent);
        }

        finish();
    }

    // Sends ACTION_FILE_READY intent when read from clipdata uri is succesful
    // and read data matches the data written by the test.
    private void readFilesFromClipDataUri(Intent intent) {
        if ((intent.getFlags() & Intent.FLAG_GRANT_READ_URI_PERMISSION) == 0) {

            // Note: since this activity is in the same package as the test we can read from the
            // file regardless of this permission, but in general this permission is required.
            Log.e(TAG, ""Intent.FLAG_GRANT_READ_URI_PERMISSION was not granted."");
            return;
        }

        List<File> files = getFilesFromIntent(intent);
        if (files == null) {
            Log.e(TAG, ""Could not get files from clipdata."");
            return;
        }
        for (File file : files) {
            if (!testFileContents(file)) {
                Log.e(TAG, ""File contents of "" + file.getPath()
                        + """	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/ReadableFileReceiverActivity.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PermissionInfoTest"	"testPermissionInfo"	"CtsContentTestCases"	"1: permission"	"([19:/android/content/pm/cts/PermissionInfoTest.java]:[permission]:[19]:method_text:[el);        assertEquals(expected.nonLocalizedDescription, actual.nonLocalizedDescription);    }}]) :|: public void testPermissionInfo() throws NameNotFoundException {
        PackageManager pm = getContext().getPackageManager();
        Parcel p = Parcel.obtain();
        // Test constructors
        new PermissionInfo();
        PermissionInfo permissionInfo = pm.getPermissionInfo(PERMISSION_NAME, 0);
        PermissionInfo infoFromExisted = new PermissionInfo(permissionInfo);
        checkInfoSame(permissionInfo, infoFromExisted);

        // Test toString, describeContents, loadDescription
        assertNotNull(permissionInfo.toString());
        assertEquals(0, permissionInfo.describeContents());
        assertEquals(DEFAULT_DISCPRIPTION, permissionInfo.loadDescription(pm));

        permissionInfo.writeToParcel(p, 0);
        p.setDataPosition(0);
        PermissionInfo infoFromParcel = PermissionInfo.CREATOR.createFromParcel(p);
        checkInfoSame(permissionInfo, infoFromParcel);
        p.recycle();
    }

    private void checkInfoSame(PermissionInfo expected, PermissionInfo actual) {
        assertEquals(expected.name, actual.name);
        assertEquals(expected.group, actual.group);
        assertEquals(expected.descriptionRes, actual.descriptionRes);
        assertEquals(expected.protectionLevel, actual.protectionLevel);
        assertEquals(expected.nonLocalizedDescription, actual.nonLocalizedDescription);
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PermissionInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PackageManagerQueryPropertyTest"	"adoptShellPermissions"	"CtsContentTestCases"	"1: permission"	"([10:/android/content/pm/cts/PackageManagerQueryPropertyTest.java]:[permission]:[10]:method_text:[;        Uninstall.packages(PROPERTY_APP3_PACKAGE_NAME);        dropShellPermissions();    }   ]) :|: /*
 *.
 */

package android.content.pm.cts;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import android.Manifest;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.Property;
import android.platform.test.annotations.AppModeFull;

import androidx.test.InstrumentationRegistry;

import com.android.cts.install.lib.Install;
import com.android.cts.install.lib.TestApp;
import com.android.cts.install.lib.Uninstall;

import org.junit.After;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

import java.util.List;
import java.util.Objects;

@RunWith(JUnit4.class)
@AppModeFull(reason = ""Instant applications cannot install other packages"")
public class PackageManagerQueryPropertyTest {

    private static PackageManager sPackageManager;
    private static final String PROPERTY_APP1_PACKAGE_NAME = ""com.android.cts.packagepropertyapp1"";
    private static final String PROPERTY_APP2_PACKAGE_NAME = ""com.android.cts.packagepropertyapp2"";
    private static final String PROPERTY_APP3_PACKAGE_NAME = ""com.android.cts.packagepropertyapp3"";
    private static final TestApp PROPERTY_APP1 =
            new TestApp(""PackagePropertyTestApp1"", PROPERTY_APP1_PACKAGE_NAME, 30,
                    false, ""PackagePropertyTestApp1.apk"");
    private static final TestApp PROPERTY_APP2 =
            new TestApp(""PackagePropertyTestApp2"", PROPERTY_APP2_PACKAGE_NAME, 30,
                    false, ""PackagePropertyTestApp2.apk"");
    private static final TestApp PROPERTY_APP3 =
            new TestApp(""PackagePropertyTestApp3"", PROPERTY_APP3_PACKAGE_NAME, 30,
                    false, ""PackagePropertyTestApp3.apk"");
    private static void adoptShellPermissions() {
        InstrumentationRegistry"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerQueryPropertyTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PackageManagerQueryPropertyTest"	"testPackageRemoval"	"CtsContentTestCases"	"1: permission"	"([6:/android/content/pm/cts/PackageManagerQueryPropertyTest.java]:[permission]:[6]:method_text:[d.cts.PROPERTY_STRING2"");            assertEquals(0, testPropertyList.size());        }    }   ]) :|: 
    public void testPackageRemoval() throws Exception {
        {
            final List<Property> testPropertyList = sPackageManager
                    .queryApplicationProperty(""android.cts.PROPERTY_RESOURCE_XML"");
            assertEquals(2, testPropertyList.size());
            assertProperty(testPropertyList, ""android.cts.PROPERTY_RESOURCE_XML"",
                    PROPERTY_APP1_PACKAGE_NAME,
                    null,
                    PROPERTY_TYPE_RESOURCE, 0x7f060000);
            assertProperty(testPropertyList, ""android.cts.PROPERTY_RESOURCE_XML"",
                    PROPERTY_APP2_PACKAGE_NAME,
                    null,
                    PROPERTY_TYPE_RESOURCE, 0x7f060000);
        }

        adoptShellPermissions();
        Uninstall.packages(PROPERTY_APP2_PACKAGE_NAME);
        dropShellPermissions();
        {
            final List<Property> testPropertyList = sPackageManager
                    .queryApplicationProperty(""android.cts.PROPERTY_RESOURCE_XML"");
            assertEquals(1, testPropertyList.size());
            assertProperty(testPropertyList, ""android.cts.PROPERTY_RESOURCE_XML"",
                    PROPERTY_APP1_PACKAGE_NAME,
                    null,
                    PROPERTY_TYPE_RESOURCE, 0x7f060000);
        }

        adoptShellPermissions();
        Uninstall.packages(PROPERTY_APP1_PACKAGE_NAME);
        Install.single(PROPERTY_APP2).commit();
        dropShellPermissions();
        {
            final List<Property> testPropertyList = sPackageManager
                    .queryApplicationProperty(""android.cts.PROPERTY_RESOURCE_XML"");
            assertEquals(1, testPropertyList.size());
            assertProperty(testPropertyList, ""android.cts.PROPERTY_RESOURCE_XML"",
                    PROPERTY_APP2_PACKAGE_NAME,
                    null,
                    PROPERTY_TYPE_RESOURCE, 0x7f060000);
        }

        adoptShellPermissions();
        Uninstall.packages(PROPERTY_APP2_PACKAGE_NAME);
        dropShellPermissions();"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerQueryPropertyTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PermissionGroupInfoTest"	"testPermissionGroupInfo"	"CtsContentTestCases"	"1: permission"	"([19:/android/content/pm/cts/PermissionGroupInfoTest.java]:[permission]:[19]:method_text:[es);        assertEquals(expected.nonLocalizedDescription, actual.nonLocalizedDescription);    }}]) :|: public void testPermissionGroupInfo() throws NameNotFoundException {
        PackageManager pm = getContext().getPackageManager();
        Parcel p = Parcel.obtain();
        // Test constructors
        new PermissionGroupInfo();
        PermissionGroupInfo permissionGroupInfo = pm
                .getPermissionGroupInfo(GROUP, 0);
        PermissionGroupInfo infoFromExisted = new PermissionGroupInfo(permissionGroupInfo);
        checkInfoSame(permissionGroupInfo, infoFromExisted);

        // Test toString, describeContents, loadDescription
        assertNotNull(permissionGroupInfo.toString());
        assertEquals(0, permissionGroupInfo.describeContents());
        assertEquals(GROUP_NAME, permissionGroupInfo.loadLabel(pm));
        assertEquals(GROUP_DESCRIPTION, permissionGroupInfo.loadDescription(pm));

        // Test writeToParcel
        permissionGroupInfo.writeToParcel(p, 0);
        p.setDataPosition(0);
        PermissionGroupInfo infoFromParcel = PermissionGroupInfo.CREATOR.createFromParcel(p);
        checkInfoSame(permissionGroupInfo, infoFromParcel);
        p.recycle();
    }

    private void checkInfoSame(PermissionGroupInfo expected, PermissionGroupInfo actual) {
        assertEquals(expected.descriptionRes, actual.descriptionRes);
        assertEquals(expected.nonLocalizedDescription, actual.nonLocalizedDescription);
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PermissionGroupInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.ActivityInfoTest"	"testWriteToParcel"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/pm/cts/ActivityInfoTest.java]:[permission]:[2]:method_text:[Exception"");        } catch (NullPointerException e) {            // expected        }    }   ]) :|: public void testWriteToParcel() throws NameNotFoundException {
        ComponentName componentName = new ComponentName(mContext, MockActivity.class);

        mActivityInfo = mContext.getPackageManager().getActivityInfo(
                componentName, PackageManager.GET_META_DATA);

        Parcel p = Parcel.obtain();
        mActivityInfo.writeToParcel(p, 0);
        p.setDataPosition(0);
        ActivityInfo info = ActivityInfo.CREATOR.createFromParcel(p);
        assertEquals(mActivityInfo.theme, info.theme);
        assertEquals(mActivityInfo.launchMode, info.launchMode);
        assertEquals(mActivityInfo.permission, info.permission);
        assertEquals(mActivityInfo.taskAffinity, info.taskAffinity);
        assertEquals(mActivityInfo.targetActivity, info.targetActivity);
        assertEquals(mActivityInfo.flags, info.flags);
        assertEquals(mActivityInfo.screenOrientation, info.screenOrientation);
        assertEquals(mActivityInfo.configChanges, info.configChanges);

        try {
            mActivityInfo.writeToParcel(null, 0);
            fail(""should throw NullPointerException"");
        } catch (NullPointerException e) {
            // expected
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/ActivityInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PackageManagerTest"	"testGetPermissionInfo"	"CtsContentTestCases"	"4: INTERNET android.permission.INTERNET permission.INTERNET permission"	"([46:/android/content/pm/cts/PackageManagerTest.java]:[permission]:[46]:method_text:[             permissionInfo.getProtectionFlags() & PermissionInfo.PROTECTION_FLAG_APPOP);    }   ]) :|: 
    public void testGetPermissionInfo() throws NameNotFoundException {
        // Check a normal permission.
        String permissionName = ""android.permission.INTERNET"";
        PermissionInfo permissionInfo = mPackageManager.getPermissionInfo(permissionName, 0);
        assertEquals(permissionName, permissionInfo.name);
        assertEquals(PermissionInfo.PROTECTION_NORMAL, permissionInfo.getProtection());

        // Check a dangerous (runtime) permission.
        permissionName = ""android.permission.RECORD_AUDIO"";
        permissionInfo = mPackageManager.getPermissionInfo(permissionName, 0);
        assertEquals(permissionName, permissionInfo.name);
        assertEquals(PermissionInfo.PROTECTION_DANGEROUS, permissionInfo.getProtection());
        assertNotNull(permissionInfo.group);

        // Check a signature permission.
        permissionName = ""android.permission.MODIFY_PHONE_STATE"";
        permissionInfo = mPackageManager.getPermissionInfo(permissionName, 0);
        assertEquals(permissionName, permissionInfo.name);
        assertEquals(PermissionInfo.PROTECTION_SIGNATURE, permissionInfo.getProtection());

        // Check a special access (appop) permission.
        permissionName = ""android.permission.SYSTEM_ALERT_WINDOW"";
        permissionInfo = mPackageManager.getPermissionInfo(permissionName, 0);
        assertEquals(permissionName, permissionInfo.name);
        assertEquals(PermissionInfo.PROTECTION_SIGNATURE, permissionInfo.getProtection());
        assertEquals(PermissionInfo.PROTECTION_FLAG_APPOP,
                permissionInfo.getProtectionFlags() & PermissionInfo.PROTECTION_FLAG_APPOP);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PackageManagerTest"	"testQuery"	"CtsContentTestCases"	"1: permission"	"([18:/android/content/pm/cts/PackageManagerTest.java]:[permission]:[18]:method_text:[d = true;                break;            }        }        assertTrue(isContained);    }   ]) :|: 
    public void testQuery() throws NameNotFoundException {
        // Test query Intent Activity related methods

        Intent activityIntent = new Intent(ACTIVITY_ACTION_NAME);
        String cmpActivityName = ""android.content.pm.cts.TestPmCompare"";
        // List with different activities and the filter doesn't work,
        List<ResolveInfo> listWithDiff = mPackageManager.queryIntentActivityOptions(
                new ComponentName(PACKAGE_NAME, cmpActivityName), null, activityIntent, 0);
        checkActivityInfoName(ACTIVITY_NAME, listWithDiff);

        // List with the same activities to make filter work
        List<ResolveInfo> listInSame = mPackageManager.queryIntentActivityOptions(
                new ComponentName(PACKAGE_NAME, ACTIVITY_NAME), null, activityIntent, 0);
        assertEquals(0, listInSame.size());

        // Test queryIntentActivities
        List<ResolveInfo> intentActivities =
                mPackageManager.queryIntentActivities(activityIntent, 0);
        assertTrue(intentActivities.size() > 0);
        checkActivityInfoName(ACTIVITY_NAME, intentActivities);

        // End of Test query Intent Activity related methods

        // Test queryInstrumentation
        String targetPackage = ""android"";
        List<InstrumentationInfo> instrumentations = mPackageManager.queryInstrumentation(
                targetPackage, 0);
        checkInstrumentationInfoName(INSTRUMENT_NAME, instrumentations);

        // Test queryIntentServices
        Intent serviceIntent = new Intent(SERVICE_ACTION_NAME);
        List<ResolveInfo> services = mPackageManager.queryIntentServices(serviceIntent,
                0 /*flags*/);
        checkServiceInfoName(SERVICE_NAME, services);

        // Test queryBroadcastReceivers
        String receiverActionName = ""android.content.pm.cts.PackageManagerTest.PMTEST_RECEIVER"";
        Intent broadcastIntent = new Intent(receiverActionName);
        List<ResolveInfo> broadcastReceivers = new ArrayList<ResolveInf"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PackageManagerTest"	"testGetInfo"	"CtsContentTestCases"	"1: permission"	"([20:/android/content/pm/cts/PackageManagerTest.java]:[permission]:[20]:method_text:[e PackageManager#addPreferredActivity(IntentFilter, int, ComponentName[], ComponentName)     */   ]) :|: 
    public void testGetInfo() throws NameNotFoundException {
        // Test getApplicationInfo, getText
        ApplicationInfo appInfo = mPackageManager.getApplicationInfo(PACKAGE_NAME, 0);
        int discriptionRes = R.string.hello_android;
        String expectedDisciptionRes = ""Hello, Android!"";
        CharSequence appText = mPackageManager.getText(PACKAGE_NAME, discriptionRes, appInfo);
        assertEquals(expectedDisciptionRes, appText);
        ComponentName activityName = new ComponentName(PACKAGE_NAME, ACTIVITY_NAME);
        ComponentName serviceName = new ComponentName(PACKAGE_NAME, SERVICE_NAME);
        ComponentName receiverName = new ComponentName(PACKAGE_NAME, RECEIVER_NAME);
        ComponentName instrName = new ComponentName(PACKAGE_NAME, INSTRUMENT_NAME);

        // Test getPackageInfo
        PackageInfo packageInfo = mPackageManager.getPackageInfo(PACKAGE_NAME,
                PackageManager.GET_INSTRUMENTATION);
        assertEquals(PACKAGE_NAME, packageInfo.packageName);

        // Test getApplicationInfo, getApplicationLabel
        String appLabel = ""Android TestCase"";
        assertEquals(appLabel, mPackageManager.getApplicationLabel(appInfo));
        assertEquals(PACKAGE_NAME, appInfo.processName);

        // Test getServiceInfo
        assertEquals(SERVICE_NAME, mPackageManager.getServiceInfo(serviceName,
                PackageManager.GET_META_DATA).name);

        // Test getReceiverInfo
        assertEquals(RECEIVER_NAME, mPackageManager.getReceiverInfo(receiverName, 0).name);

        // Test getPackageArchiveInfo
        final String apkRoute = mContext.getPackageCodePath();
        final String apkName = mContext.getPackageName();
        assertEquals(apkName, mPackageManager.getPackageArchiveInfo(apkRoute, 0).packageName);

        // Test getPackagesForUid, getNameForUid
        checkPackagesNameForUid(PACKAGE_NAME, mPackageManager.getPackagesForUid(appInfo.uid));
        assertEquals(PACKAGE_NAME, mPackageManager.getName"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PackageManagerTest"	"testGetPreferredActivities"	"CtsContentTestCases"	"1: permission"	"([3:/android/content/pm/cts/PackageManagerTest.java]:[permission]:[3]:method_text:[     * able to call this method because it is not signed with the platform certificate.     */   ]) :|: 
    public void testGetPreferredActivities() {
        assertNoPreferredActivities();
    }

    /**
     * Helper method to test that {@link PackageManager#getPreferredActivities(List, List, String)}
     * returns empty lists.
     */
    private void assertNoPreferredActivities() {
        List<ComponentName> outActivities = new ArrayList<ComponentName>();
        List<IntentFilter> outFilters = new ArrayList<IntentFilter>();
        mPackageManager.getPreferredActivities(outFilters, outActivities, PACKAGE_NAME);
        assertEquals(0, outActivities.size());
        assertEquals(0, outFilters.size());
    }

    /**
     * Test that calling {@link PackageManager#addPreferredActivity(IntentFilter, int,
     * ComponentName[], ComponentName)} throws a {@link SecurityException}.
     * <p/>
     * The method is protected by the {@link android.permission.SET_PREFERRED_APPLICATIONS}
     * signature permission. Even though this app declares that permission, it still should not be
     * able to call this method because it is not signed with the platform certificate.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PackageManagerTest"	"testCheckPermissionGranted"	"CtsContentTestCases"	"1: permission"	"([4:/android/content/pm/cts/PackageManagerTest.java]:[permission]:[4]:method_text:[                mPackageManager.checkPermission(GRANTED_PERMISSION_NAME, PACKAGE_NAME));    }   ]) :|: 
    public void testCheckPermissionGranted() {
        assertEquals(PackageManager.PERMISSION_GRANTED,
                mPackageManager.checkPermission(GRANTED_PERMISSION_NAME, PACKAGE_NAME));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PackageManagerTest"	"testCheckPermissionNotGranted"	"CtsContentTestCases"	"1: permission"	"([4:/android/content/pm/cts/PackageManagerTest.java]:[permission]:[4]:method_text:[             mPackageManager.checkPermission(NOT_GRANTED_PERMISSION_NAME, PACKAGE_NAME));    }   ]) :|: 
    public void testCheckPermissionNotGranted() {
        assertEquals(PackageManager.PERMISSION_DENIED,
                mPackageManager.checkPermission(NOT_GRANTED_PERMISSION_NAME, PACKAGE_NAME));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PackageManagerTest"	"testGetPackageInfo"	"CtsContentTestCases"	"1: permission"	"([1:/android/content/pm/cts/PackageManagerTest.java]:[permission]:[1]:method_text:[ | GET_PROVIDERS | GET_SERVICES | GET_RECEIVERS);        assertTestPackageInfo(pkgInfo);    }   ]) :|: 
    public void testGetPackageInfo() throws NameNotFoundException {
        PackageInfo pkgInfo = mPackageManager.getPackageInfo(PACKAGE_NAME, GET_META_DATA
                | GET_PERMISSIONS | GET_ACTIVITIES | GET_PROVIDERS | GET_SERVICES | GET_RECEIVERS);
        assertTestPackageInfo(pkgInfo);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PackageManagerTest"	"testGetInstalledPackages"	"CtsContentTestCases"	"1: permission"	"([27:/android/content/pm/cts/PackageManagerTest.java]:[permission]:[27]:method_text:[als(PACKAGE_NAME, receiver.packageName);    }    // Tests that other packages can be queried.   ]) :|: 
    public void testGetInstalledPackages() throws Exception {
        List<PackageInfo> pkgs = mPackageManager.getInstalledPackages(GET_META_DATA
                | GET_PERMISSIONS | GET_ACTIVITIES | GET_PROVIDERS | GET_SERVICES | GET_RECEIVERS);

        PackageInfo pkgInfo = findPackageOrFail(pkgs, PACKAGE_NAME);
        assertTestPackageInfo(pkgInfo);
    }

    /**
     * Asserts that the pkgInfo object correctly describes the {@link #PACKAGE_NAME} package.
     */
    private void assertTestPackageInfo(PackageInfo pkgInfo) {
        // Check metadata
        ApplicationInfo appInfo = pkgInfo.applicationInfo;
        assertEquals(APPLICATION_NAME, appInfo.name);
        assertEquals(""Android TestCase"", appInfo.loadLabel(mPackageManager));
        assertEquals(PACKAGE_NAME, appInfo.packageName);
        assertTrue(appInfo.enabled);
        // The process name defaults to the package name when not set.
        assertEquals(PACKAGE_NAME, appInfo.processName);
        assertEquals(0, appInfo.flags & FLAG_SYSTEM);
        assertEquals(FLAG_INSTALLED, appInfo.flags & FLAG_INSTALLED);
        assertEquals(FLAG_HAS_CODE, appInfo.flags & FLAG_HAS_CODE);

        // Check required permissions
        List<String> requestedPermissions = Arrays.asList(pkgInfo.requestedPermissions);
        assertThat(requestedPermissions).containsAtLeast(
                ""android.permission.MANAGE_ACCOUNTS"",
                ""android.permission.ACCESS_NETWORK_STATE"",
                ""android.content.cts.permission.TEST_GRANTED"");

        // Check usesPermissionFlags
        for (int i = 0; i < pkgInfo.requestedPermissions.length; i++) {
            final String name = pkgInfo.requestedPermissions[i];
            final int flags = pkgInfo.requestedPermissionsFlags[i];
            final boolean neverForLocation = (flags
                    & PackageInfo.REQUESTED_PERMISSION_NEVER_FOR_LOCATION) != 0;
            if (""android.content.cts.permission.TEST_GRANTED"".equals(name)) {"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PackageManagerTest"	"testGetPackagesHoldingPermissions"	"CtsContentTestCases"	"1: permission"	"([5:/android/content/pm/cts/PackageManagerTest.java]:[permission]:[5]:method_text:[                fail(""Must not return package "" + PACKAGE_NAME);            }        }    }   ]) :|: 
    public void testGetPackagesHoldingPermissions() {
        List<PackageInfo> pkgInfos = mPackageManager.getPackagesHoldingPermissions(
                new String[] { GRANTED_PERMISSION_NAME }, 0);
        findPackageOrFail(pkgInfos, PACKAGE_NAME);

        pkgInfos = mPackageManager.getPackagesHoldingPermissions(
                new String[] { NOT_GRANTED_PERMISSION_NAME }, 0);
        for (PackageInfo pkgInfo : pkgInfos) {
            if (PACKAGE_NAME.equals(pkgInfo.packageName)) {
                fail(""Must not return package "" + PACKAGE_NAME);
            }
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PackageManagerTest"	"testGetPermissionInfo_notFound"	"CtsContentTestCases"	"1: permission"	"([4:/android/content/pm/cts/PackageManagerTest.java]:[permission]:[4]:method_text:[ fail(""Exception expected"");        } catch (NameNotFoundException expected) {        }    }   ]) :|: 
    public void testGetPermissionInfo_notFound() {
        try {
            mPackageManager.getPermissionInfo(""android.permission.nonexistent.permission"", 0);
            fail(""Exception expected"");
        } catch (NameNotFoundException expected) {
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PackageManagerTest"	"testGetPermissionGroupInfo"	"CtsContentTestCases"	"1: permission"	"([5:/android/content/pm/cts/PackageManagerTest.java]:[permission]:[5]:method_text:[ame);        assertFalse(TextUtils.isEmpty(groupInfo.loadDescription(mPackageManager)));    }   ]) :|: 
    public void testGetPermissionGroupInfo() throws NameNotFoundException {
        PermissionGroupInfo groupInfo = mPackageManager.getPermissionGroupInfo(
                PERMISSIONGROUP_NAME, 0);
        assertEquals(PERMISSIONGROUP_NAME, groupInfo.name);
        assertEquals(PACKAGE_NAME, groupInfo.packageName);
        assertFalse(TextUtils.isEmpty(groupInfo.loadDescription(mPackageManager)));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PackageManagerTest"	"testGetPermissionGroupInfo_notFound"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/pm/cts/PackageManagerTest.java]:[permission]:[2]:method_text:[ fail(""Exception expected"");        } catch (NameNotFoundException expected) {        }    }   ]) :|: 
    public void testGetPermissionGroupInfo_notFound() throws NameNotFoundException {
        try {
            mPackageManager.getPermissionGroupInfo(""this.group.does.not.exist"", 0);
            fail(""Exception expected"");
        } catch (NameNotFoundException expected) {
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PackageManagerTest"	"testAddPermission_cantAddOutsideRoot"	"CtsContentTestCases"	"1: permission"	"([17:/android/content/pm/cts/PackageManagerTest.java]:[permission]:[17]:method_text:[tree defined in the manifest."");        } catch (SecurityException expected) {        }    }   ]) :|: 
    public void testAddPermission_cantAddOutsideRoot() {
        PermissionInfo permissionInfo = new PermissionInfo();
        permissionInfo.name = ""some.other.permission.tree.some-permission"";
        permissionInfo.nonLocalizedLabel = ""Some Permission"";
        permissionInfo.protectionLevel = PermissionInfo.PROTECTION_NORMAL;
        // Remove first
        try {
            mPackageManager.removePermission(permissionInfo.name);
        } catch (SecurityException se) {
        }
        try {
            mPackageManager.addPermission(permissionInfo);
            fail(""Must not add permission outside the permission tree defined in the manifest."");
        } catch (SecurityException expected) {
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PackageManagerTest"	"testAddPermission"	"CtsContentTestCases"	"1: permission"	"([19:/android/content/pm/cts/PackageManagerTest.java]:[permission]:[19]:method_text:[Name);        assertEquals(PermissionInfo.PROTECTION_NORMAL, savedInfo.protectionLevel);    }   ]) :|: 
    public void testAddPermission() throws NameNotFoundException {
        PermissionInfo permissionInfo = new PermissionInfo();
        permissionInfo.name = PERMISSION_TREE_ROOT + "".some-permission"";
        permissionInfo.protectionLevel = PermissionInfo.PROTECTION_NORMAL;
        permissionInfo.nonLocalizedLabel = ""Some Permission"";
        // Remove first
        try {
            mPackageManager.removePermission(permissionInfo.name);
        } catch (SecurityException se) {
        }
        mPackageManager.addPermission(permissionInfo);
        PermissionInfo savedInfo = mPackageManager.getPermissionInfo(permissionInfo.name, 0);
        assertEquals(PACKAGE_NAME, savedInfo.packageName);
        assertEquals(PermissionInfo.PROTECTION_NORMAL, savedInfo.protectionLevel);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PackageManagerTest"	"testSetSystemAppHiddenUntilInstalled"	"CtsContentTestCases"	"1: permission"	"([4:/android/content/pm/cts/PackageManagerTest.java]:[permission]:[4]:method_text:[     + "" should be found via getPackageInfo after re-enabling."");            }        }    }   ]) :|: 
    public void testSetSystemAppHiddenUntilInstalled() throws Exception {
        String packageToManipulate = ""com.android.cts.ctsshim"";
        try {
            mPackageManager.getPackageInfo(packageToManipulate, MATCH_SYSTEM_ONLY);
        } catch (NameNotFoundException e) {
            Log.i(TAG, ""Device doesn't have "" + packageToManipulate + "" installed, skipping"");
            return;
        }

        try {
            SystemUtil.runWithShellPermissionIdentity(() ->
                    mPackageManager.setSystemAppState(packageToManipulate,
                            PackageManager.SYSTEM_APP_STATE_UNINSTALLED));
            SystemUtil.runWithShellPermissionIdentity(() ->
                    mPackageManager.setSystemAppState(packageToManipulate,
                            PackageManager.SYSTEM_APP_STATE_HIDDEN_UNTIL_INSTALLED_HIDDEN));

            // Setting the state to SYSTEM_APP_STATE_UNINSTALLED is an async operation in
            // PackageManagerService with no way to listen for completion, so poll until the
            // app is no longer found.
            int pollingPeriodMs = 100;
            int timeoutMs = 1000;
            long startTimeMs = SystemClock.elapsedRealtime();
            boolean isAppStillVisible = true;
            while (SystemClock.elapsedRealtime() < startTimeMs + timeoutMs) {
                try {
                    mPackageManager.getPackageInfo(packageToManipulate, MATCH_SYSTEM_ONLY);
                } catch (NameNotFoundException e) {
                    // expected, stop polling
                    isAppStillVisible = false;
                    break;
                }
                Thread.sleep(pollingPeriodMs);
            }
            if (isAppStillVisible) {
                fail(packageToManipulate + "" should not be found via getPackageInfo."");
            }
        } finally {
            SystemUtil.runWithShellPermissionIdentity(() ->
                    mPackageManager.setSystemAppState(packageToManipulate,"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PackageManagerTest"	"testInstallTestOnlyPackagePermission_onlyGrantedToShell"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/pm/cts/PackageManagerTest.java]:[permission]:[2]:method_text:[asSize(1);        assertThat(packages.get(0).packageName).isEqualTo(SHELL_PACKAGE_NAME);    }   ]) :|: 
    public void testInstallTestOnlyPackagePermission_onlyGrantedToShell() {
        List<PackageInfo> packages = mPackageManager.getPackagesHoldingPermissions(
                new String[]{INSTALL_TEST_ONLY_PACKAGE}, /* flags= */ 0);

        assertThat(packages).hasSize(1);
        assertThat(packages.get(0).packageName).isEqualTo(SHELL_PACKAGE_NAME);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PackageInfoTest"	"testApplicationInfoSame"	"CtsContentTestCases"	"1: permission"	"([6:/android/content/pm/cts/PackageInfoTest.java]:[permission]:[6]:method_text:[  assertNull(actual);        } else {            assertEquals(0, actual.length);        }    }}]) :|: public void testApplicationInfoSame() {
        ApplicationInfo ai = mPackageInfo.applicationInfo;

        // Make sure all the components in it has the same ApplicationInfo.
        for (ComponentInfo[] ar : new ComponentInfo[][]{
                mPackageInfo.activities, mPackageInfo.services, mPackageInfo.providers,
                mPackageInfo.receivers}) {
            for (ComponentInfo ci : ar) {
                assertSame(""component="" + ci.getComponentName(), ai, ci.applicationInfo);
            }
        }
    }

    private void checkPkgInfoSame(PackageInfo expected, PackageInfo actual) {
        assertEquals(expected.packageName, actual.packageName);
        assertEquals(expected.getLongVersionCode(), actual.getLongVersionCode());
        assertEquals(expected.versionName, actual.versionName);
        assertEquals(expected.sharedUserId, actual.sharedUserId);
        assertEquals(expected.sharedUserLabel, actual.sharedUserLabel);
        if (expected.applicationInfo != null) {
            assertNotNull(actual.applicationInfo);
            checkAppInfo(expected.applicationInfo, actual.applicationInfo);
        } else {
            assertNull(actual.applicationInfo);
        }
        assertTrue(Arrays.equals(expected.gids, actual.gids));
        checkInfoArray(expected.activities, actual.activities);
        checkInfoArray(expected.receivers, actual.receivers);
        checkInfoArray(expected.services, actual.services);
        checkInfoArray(expected.providers, actual.providers);
        checkInfoArray(expected.instrumentation, actual.instrumentation);
        checkInfoArray(expected.permissions, actual.permissions);
        assertTrue(Arrays.equals(expected.requestedPermissions, actual.requestedPermissions));
        checkSignatureInfo(expected.signatures, actual.signatures);
        checkConfigInfo(expected.configPreferences, actual.configPreferences);
        checkAttributionInfo(expected.attributions, actual.attributions);
    }

    private void checkA"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PackageManagerGetPropertyTest"	"adoptShellPermissions"	"CtsContentTestCases"	"1: permission"	"([10:/android/content/pm/cts/PackageManagerGetPropertyTest.java]:[permission]:[10]:method_text:[;        Uninstall.packages(PROPERTY_APP3_PACKAGE_NAME);        dropShellPermissions();    }   ]) :|: /*
 *.
 */

package android.content.pm.cts;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import static java.lang.Boolean.TRUE;

import android.Manifest;
import android.content.ComponentName;
import android.content.pm.PackageManager;
import android.content.pm.PackageManager.NameNotFoundException;
import android.content.pm.PackageManager.Property;
import android.platform.test.annotations.AppModeFull;

import androidx.test.InstrumentationRegistry;

import com.android.cts.install.lib.Install;
import com.android.cts.install.lib.TestApp;
import com.android.cts.install.lib.Uninstall;

import org.junit.After;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

import java.util.Objects;

@RunWith(JUnit4.class)
@AppModeFull(reason = ""Instant applications cannot install other packages"")
public class PackageManagerGetPropertyTest {
    private static PackageManager sPackageManager;
    private static final String PROPERTY_APP1_PACKAGE_NAME = ""com.android.cts.packagepropertyapp1"";
    private static final String PROPERTY_APP2_PACKAGE_NAME = ""com.android.cts.packagepropertyapp2"";
    private static final String PROPERTY_APP3_PACKAGE_NAME = ""com.android.cts.packagepropertyapp3"";
    private static final TestApp PROPERTY_APP1 =
            new TestApp(""PackagePropertyTestApp1"", PROPERTY_APP1_PACKAGE_NAME, 30,
                    false, ""PackagePropertyTestApp1.apk"");
    private static final TestApp PROPERTY_APP2 =
            new TestApp(""PackagePropertyTestApp2"", PROPERTY_APP2_PACKAGE_NAME, 30,
                    false, ""PackagePropertyTestApp2.apk"");
    private static final TestApp PROPERTY_APP3 =
            new TestApp(""PackagePropertyTestApp3"", PROPERTY_APP3_PACKAGE_NAME, 30,
                    false, ""PackagePro"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerGetPropertyTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PackageManagerGetPropertyTest"	"testPackageRemoval"	"CtsContentTestCases"	"1: permission"	"([4:/android/content/pm/cts/PackageManagerGetPropertyTest.java]:[permission]:[4]:method_text:[erty.getResourceId());        } else {            fail(""Unknown property type"");        }    }}]) :|: 
    public void testPackageRemoval() throws Exception {
        adoptShellPermissions();
        Install.single(PROPERTY_APP3).commit();
        dropShellPermissions();

        try {
            final Property testPropertyList = sPackageManager.getProperty(
                    ""android.cts.PROPERTY_NOT_FOUND"", PROPERTY_APP3_PACKAGE_NAME);
            fail(""getProperty() did not throw NameNotFoundException"");
        } catch (NameNotFoundException expected) {
        }
        try {
            final ComponentName component = new ComponentName(PROPERTY_APP3_PACKAGE_NAME,
                    ""com.android.cts.packagepropertyapp.MyService"");
            Property testProperty = sPackageManager.getProperty(
                    ""android.cts.PROPERTY_NOT_FOUND"", component);
            fail(""getProperty() did not throw NameNotFoundException"");
        } catch (NameNotFoundException expected) {
        }

        adoptShellPermissions();
        Uninstall.packages(PROPERTY_APP1_PACKAGE_NAME);
        Uninstall.packages(PROPERTY_APP2_PACKAGE_NAME);
        dropShellPermissions();

        try {
            final Property testPropertyList = sPackageManager.getProperty(
                    ""android.cts.PROPERTY_NOT_FOUND"", PROPERTY_APP3_PACKAGE_NAME);
            fail(""getProperty() did not throw NameNotFoundException"");
        } catch (NameNotFoundException expected) {
        }
        try {
            final ComponentName component = new ComponentName(PROPERTY_APP3_PACKAGE_NAME,
                    ""com.android.cts.packagepropertyapp.MyService"");
            Property testProperty = sPackageManager.getProperty(
                    ""android.cts.PROPERTY_NOT_FOUND"", component);
            fail(""getProperty() did not throw NameNotFoundException"");
        } catch (NameNotFoundException expected) {
        }
    }

    private static final int PROPERTY_TYPE_BOOLEAN = 1;
    private static final int PROPERTY_TYPE_FLOAT = 2;
    private static final int PROPERTY_TYPE_INTEGER ="	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerGetPropertyTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.LauncherAppsTest"	"testGetAppUsageLimit_isNull"	"CtsContentTestCases"	"1: permission"	"([1:/android/content/pm/cts/LauncherAppsTest.java]:[permission]:[1]:method_text:[NGS_PACKAGE, USER_HANDLE);        assertNull(limit); // An observer was never registered    }   ]) :|: 
    @Ignore(""Can be enabled only after b/126946674 is fixed"")
    @AppModeFull(reason = ""Need special permission"")
    public void testGetAppUsageLimit_isNull() {
        final LauncherApps.AppUsageLimit limit = mLauncherApps.getAppUsageLimit(
                SETTINGS_PACKAGE, USER_HANDLE);
        assertNull(limit); // An observer was never registered
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/LauncherAppsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.LauncherAppsTest"	"testGetAppUsageLimit_isNotNull"	"CtsContentTestCases"	"1: permission"	"([1:/android/content/pm/cts/LauncherAppsTest.java]:[permission]:[1]:method_text:[UsageLimit(                SETTINGS_PACKAGE, USER_HANDLE);        assertNotNull(limit);    }   ]) :|: 
    @Ignore(""Can be enabled only after b/126946674 is fixed"")
    @AppModeFull(reason = ""Need special permission"")
    public void testGetAppUsageLimit_isNotNull() {
        registerDefaultObserver();
        final LauncherApps.AppUsageLimit limit = mLauncherApps.getAppUsageLimit(
                SETTINGS_PACKAGE, USER_HANDLE);
        assertNotNull(limit);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/LauncherAppsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.LauncherAppsTest"	"testGetAppUsageLimit_isNullOnUnregister"	"CtsContentTestCases"	"1: permission"	"([1:/android/content/pm/cts/LauncherAppsTest.java]:[permission]:[1]:method_text:[CKAGE, USER_HANDLE);        assertNull(""An unregistered observer was returned."", limit);    }   ]) :|: 
    @Ignore(""Can be enabled only after b/126946674 is fixed"")
    @AppModeFull(reason = ""Need special permission"")
    public void testGetAppUsageLimit_isNullOnUnregister() {
        registerDefaultObserver();
        unregisterObserver(DEFAULT_OBSERVER_ID);
        final LauncherApps.AppUsageLimit limit = mLauncherApps.getAppUsageLimit(
                SETTINGS_PACKAGE, USER_HANDLE);
        assertNull(""An unregistered observer was returned."", limit);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/LauncherAppsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.LauncherAppsTest"	"testGetAppUsageLimit_getTotalUsageLimit"	"CtsContentTestCases"	"1: permission"	"([1:/android/content/pm/cts/LauncherAppsTest.java]:[permission]:[1]:method_text:[              TimeUnit.MINUTES.toMillis(DEFAULT_TIME_LIMIT), limit.getTotalUsageLimit());    }   ]) :|: 
    @Ignore(""Can be enabled only after b/126946674 is fixed"")
    @AppModeFull(reason = ""Need special permission"")
    public void testGetAppUsageLimit_getTotalUsageLimit() {
        registerDefaultObserver();
        final LauncherApps.AppUsageLimit limit = mLauncherApps.getAppUsageLimit(
                SETTINGS_PACKAGE, USER_HANDLE);
        assertEquals(""Total usage limit not equal to the limit registered."",
                TimeUnit.MINUTES.toMillis(DEFAULT_TIME_LIMIT), limit.getTotalUsageLimit());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/LauncherAppsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.LauncherAppsTest"	"testGetAppUsageLimit_getTotalUsageRemaining"	"CtsContentTestCases"	"1: permission"	"([1:/android/content/pm/cts/LauncherAppsTest.java]:[permission]:[1]:method_text:[ with no usage."",                limit.getTotalUsageLimit(), limit.getUsageRemaining());    }   ]) :|: 
    @Ignore(""Can be enabled only after b/126946674 is fixed"")
    @AppModeFull(reason = ""Need special permission"")
    public void testGetAppUsageLimit_getTotalUsageRemaining() {
        registerDefaultObserver();
        final LauncherApps.AppUsageLimit limit = mLauncherApps.getAppUsageLimit(
                SETTINGS_PACKAGE, USER_HANDLE);
        assertEquals(""Usage remaining not equal to the total limit with no usage."",
                limit.getTotalUsageLimit(), limit.getUsageRemaining());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/LauncherAppsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.LauncherAppsTest"	"testGetAppUsageLimit_smallestLimitReturned"	"CtsContentTestCases"	"1: permission"	"([1:/android/content/pm/cts/LauncherAppsTest.java]:[permission]:[1]:method_text:[t.getTotalUsageLimit());        } finally {            unregisterObserver(1);        }    }   ]) :|: 
    @Ignore(""Can be enabled only after b/126946674 is fixed"")
    @AppModeFull(reason = ""Need special permission"")
    public void testGetAppUsageLimit_smallestLimitReturned() {
        registerDefaultObserver();
        registerObserver(1, Duration.ofMinutes(5), Duration.ofMinutes(0));
        final LauncherApps.AppUsageLimit limit = mLauncherApps.getAppUsageLimit(
                SETTINGS_PACKAGE, USER_HANDLE);
        try {
            assertEquals(""Smallest usage limit not returned when multiple limits exist."",
                    TimeUnit.MINUTES.toMillis(DEFAULT_TIME_LIMIT), limit.getTotalUsageLimit());
        } finally {
            unregisterObserver(1);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/LauncherAppsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.LauncherAppsTest"	"testGetAppUsageLimit_zeroUsageRemaining"	"CtsContentTestCases"	"1: permission"	"([1:/android/content/pm/cts/LauncherAppsTest.java]:[permission]:[1]:method_text:[        assertEquals(""Usage remaining expected to be 0."", 0, limit.getUsageRemaining());    }   ]) :|: 
    @Ignore(""Can be enabled only after b/126946674 is fixed"")
    @AppModeFull(reason = ""Need special permission"")
    public void testGetAppUsageLimit_zeroUsageRemaining() {
        registerObserver(DEFAULT_OBSERVER_ID, Duration.ofMinutes(1), Duration.ofMinutes(1));
        final LauncherApps.AppUsageLimit limit = mLauncherApps.getAppUsageLimit(
                SETTINGS_PACKAGE, USER_HANDLE);
        assertNotNull(""An observer with an exhaused time limit was not registered."", limit);
        assertEquals(""Usage remaining expected to be 0."", 0, limit.getUsageRemaining());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/LauncherAppsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.LauncherAppsTest"	"testIsActivityEnabled"	"CtsContentTestCases"	"1: permission"	"([1:/android/content/pm/cts/LauncherAppsTest.java]:[permission]:[1]:method_text:[ assertFalse(mLauncherApps.isActivityEnabled(FULL_DISABLED_COMPONENT_NAME, USER_HANDLE));    }   ]) :|: 
    @AppModeFull(reason = ""Need special permission"")
    public void testIsActivityEnabled() {
        assertTrue(mLauncherApps.isActivityEnabled(FULL_COMPONENT_NAME, USER_HANDLE));
        assertFalse(mLauncherApps.isActivityEnabled(FULL_DISABLED_COMPONENT_NAME, USER_HANDLE));

        mContext.getPackageManager().setComponentEnabledSetting(
                FULL_COMPONENT_NAME,
                PackageManager.COMPONENT_ENABLED_STATE_DISABLED,
                PackageManager.DONT_KILL_APP);
        mContext.getPackageManager().setComponentEnabledSetting(
                FULL_DISABLED_COMPONENT_NAME,
                PackageManager.COMPONENT_ENABLED_STATE_DISABLED,
                PackageManager.DONT_KILL_APP);

        assertFalse(mLauncherApps.isActivityEnabled(FULL_COMPONENT_NAME, USER_HANDLE));
        assertFalse(mLauncherApps.isActivityEnabled(FULL_DISABLED_COMPONENT_NAME, USER_HANDLE));

        mContext.getPackageManager().setComponentEnabledSetting(
                FULL_COMPONENT_NAME,
                PackageManager.COMPONENT_ENABLED_STATE_ENABLED,
                PackageManager.DONT_KILL_APP);
        mContext.getPackageManager().setComponentEnabledSetting(
                FULL_DISABLED_COMPONENT_NAME,
                PackageManager.COMPONENT_ENABLED_STATE_ENABLED,
                PackageManager.DONT_KILL_APP);

        assertTrue(mLauncherApps.isActivityEnabled(FULL_COMPONENT_NAME, USER_HANDLE));
        assertTrue(mLauncherApps.isActivityEnabled(FULL_DISABLED_COMPONENT_NAME, USER_HANDLE));

        mContext.getPackageManager().setComponentEnabledSetting(
                FULL_COMPONENT_NAME,
                PackageManager.COMPONENT_ENABLED_STATE_DEFAULT,
                PackageManager.DONT_KILL_APP);
        mContext.getPackageManager().setComponentEnabledSetting(
                FULL_DISABLED_COMPONENT_NAME,
                PackageManager.COMPONENT_ENABLED_STATE_DEFAULT,
                PackageManager.DONT_KILL_APP);

        assertTrue(mLauncherApps.isActi"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/LauncherAppsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.LauncherAppsTest"	"testGetActivityInfo"	"CtsContentTestCases"	"1: permission"	"([3:/android/content/pm/cts/LauncherAppsTest.java]:[permission]:[3]:method_text:[ntity(() ->                mUsageStatsManager.unregisterAppUsageLimitObserver(observerId));    }}]) :|: 
    @AppModeFull(reason = ""Need special permission"")
    public void testGetActivityInfo() {
        LauncherActivityInfo info = mLauncherApps.resolveActivity(
                new Intent().setComponent(FULL_COMPONENT_NAME), USER_HANDLE);
        assertNotNull(info);
        assertNotNull(info.getActivityInfo());
        assertEquals(info.getName(), info.getActivityInfo().name);
        assertEquals(info.getComponentName().getPackageName(), info.getActivityInfo().packageName);
    }

    private void registerDefaultObserver() {
        registerObserver(DEFAULT_OBSERVER_ID, Duration.ofMinutes(DEFAULT_TIME_LIMIT),
                Duration.ofMinutes(0));
    }

    private void registerObserver(int observerId, Duration timeLimit, Duration timeUsed) {
        SystemUtil.runWithShellPermissionIdentity(() ->
                mUsageStatsManager.registerAppUsageLimitObserver(
                        observerId, SETTINGS_PACKAGE_GROUP, timeLimit, timeUsed,
                        PendingIntent.getActivity(mContext, -1, new Intent(), PendingIntent.FLAG_MUTABLE_UNAUDITED)));
    }

    private void unregisterObserver(int observerId) {
        SystemUtil.runWithShellPermissionIdentity(() ->
                mUsageStatsManager.unregisterAppUsageLimitObserver(observerId));
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/LauncherAppsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.ResourcesHardeningTest"	"TestBlockFilter"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/pm/cts/ResourcesHardeningTest.java]:[permission]:[2]:method_text:[ {        return (ActivityManager) getContext().getSystemService(Context.ACTIVITY_SERVICE);    }}]) :|: 
    public void checkOpenFdRemote() throws Exception {
        // Failing to read missing blocks through a file descriptor using read/pread causes an
        // IOException to be thrown.
        testIncrementalOwnPackageResources(TestUtils.TEST_OPEN_FILE_FD, false /* expectCrash */);
    }

    private interface TestFunction {
        void apply(Resources res, TestUtils.AssertionType type) throws Exception;
    }

    /**
     * Installs a package incrementally and tests that retrieval of that package's resources from
     * within this process does not crash this process and instead falls back to some default
     * behavior.
     */
    private void testIncrementalForeignPackageResources(TestFunction test) throws Exception {
        try (ShellInstallSession session = startInstallSession()) {
            test.apply(session.getPackageResources(), TestUtils.AssertionType.ASSERT_SUCCESS);
        }
        try (ShellInstallSession session = startInstallSession()) {
            session.enableBlockRestrictions();
            test.apply(session.getPackageResources(), TestUtils.AssertionType.ASSERT_READ_FAILURE);
        }
    }

    /**
     * Installs a package incrementally and tests that the package crashes when it fails to retrieve
     * its own resources due to incremental installation.
     */
    private void testIncrementalOwnPackageResources(String testName, boolean expectCrash)
            throws Exception {
        try (RemoteTest session = new RemoteTest(startInstallSession(), testName)) {
            session.mSession.getPackageResources();
            session.start(true /* assertSuccess */);
        }

        try (RemoteTest session = new RemoteTest(startInstallSession(), testName)) {
            session.mSession.getPackageResources();
            session.mSession.enableBlockRestrictions();
            if (expectCrash) {
                MatcherUtils.assertThrows(instanceOf(RemoteProcessCrashedException.class),
                        () -> session.start(f"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/ResourcesHardeningTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PermissionFeatureTest"	"testPermissionRequiredFeatureDefined"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/pm/cts/PermissionFeatureTest.java]:[permission]:[2]:method_text:[ined() {        assertPermissionGranted(""android.content.cts.REQUIRED_FEATURE_DEFINED"");    }   ]) :|: public void testPermissionRequiredFeatureDefined() {
        assertPermissionGranted(""android.content.cts.REQUIRED_FEATURE_DEFINED"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PermissionFeatureTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PermissionFeatureTest"	"testPermissionRequiredFeatureDefined_usingTags"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/pm/cts/PermissionFeatureTest.java]:[permission]:[2]:method_text:[gs() {        assertPermissionGranted(""android.content.cts.REQUIRED_FEATURE_DEFINED_2"");    }   ]) :|: public void testPermissionRequiredFeatureDefined_usingTags() {
        assertPermissionGranted(""android.content.cts.REQUIRED_FEATURE_DEFINED_2"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PermissionFeatureTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PermissionFeatureTest"	"testPermissionRequiredFeatureUndefined"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/pm/cts/PermissionFeatureTest.java]:[permission]:[2]:method_text:[ned() {        assertPermissionDenied(""android.content.cts.REQUIRED_FEATURE_UNDEFINED"");    }   ]) :|: public void testPermissionRequiredFeatureUndefined() {
        assertPermissionDenied(""android.content.cts.REQUIRED_FEATURE_UNDEFINED"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PermissionFeatureTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PermissionFeatureTest"	"testPermissionRequiredNotFeatureDefined"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/pm/cts/PermissionFeatureTest.java]:[permission]:[2]:method_text:[d() {        assertPermissionDenied(""android.content.cts.REQUIRED_NOT_FEATURE_DEFINED"");    }   ]) :|: public void testPermissionRequiredNotFeatureDefined() {
        assertPermissionDenied(""android.content.cts.REQUIRED_NOT_FEATURE_DEFINED"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PermissionFeatureTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PermissionFeatureTest"	"testPermissionRequiredNotFeatureUndefined"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/pm/cts/PermissionFeatureTest.java]:[permission]:[2]:method_text:[ {        assertPermissionGranted(""android.content.cts.REQUIRED_NOT_FEATURE_UNDEFINED"");    }   ]) :|: public void testPermissionRequiredNotFeatureUndefined() {
        assertPermissionGranted(""android.content.cts.REQUIRED_NOT_FEATURE_UNDEFINED"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PermissionFeatureTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PermissionFeatureTest"	"testPermissionRequiredNotFeatureUndefined_usingTags"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/pm/cts/PermissionFeatureTest.java]:[permission]:[2]:method_text:[        assertPermissionGranted(""android.content.cts.REQUIRED_NOT_FEATURE_UNDEFINED_2"");    }   ]) :|: public void testPermissionRequiredNotFeatureUndefined_usingTags() {
        assertPermissionGranted(""android.content.cts.REQUIRED_NOT_FEATURE_UNDEFINED_2"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PermissionFeatureTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PermissionFeatureTest"	"testPermissionRequiredMultiDeny"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/pm/cts/PermissionFeatureTest.java]:[permission]:[2]:method_text:[dMultiDeny() {        assertPermissionDenied(""android.content.cts.REQUIRED_MULTI_DENY"");    }   ]) :|: public void testPermissionRequiredMultiDeny() {
        assertPermissionDenied(""android.content.cts.REQUIRED_MULTI_DENY"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PermissionFeatureTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PermissionFeatureTest"	"testPermissionRequiredMultiDeny_usingTags"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/pm/cts/PermissionFeatureTest.java]:[permission]:[2]:method_text:[singTags() {        assertPermissionDenied(""android.content.cts.REQUIRED_MULTI_DENY_2"");    }   ]) :|: public void testPermissionRequiredMultiDeny_usingTags() {
        assertPermissionDenied(""android.content.cts.REQUIRED_MULTI_DENY_2"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PermissionFeatureTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PermissionFeatureTest"	"testPermissionRequiredMultiDeny_usingTagsAndAttributes"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/pm/cts/PermissionFeatureTest.java]:[permission]:[2]:method_text:[tributes() {        assertPermissionDenied(""android.content.cts.REQUIRED_MULTI_DENY_3"");    }   ]) :|: public void testPermissionRequiredMultiDeny_usingTagsAndAttributes() {
        assertPermissionDenied(""android.content.cts.REQUIRED_MULTI_DENY_3"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PermissionFeatureTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PermissionFeatureTest"	"testPermissionRequiredMultiGrant"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/pm/cts/PermissionFeatureTest.java]:[permission]:[2]:method_text:[ltiGrant() {        assertPermissionGranted(""android.content.cts.REQUIRED_MULTI_GRANT"");    }   ]) :|: public void testPermissionRequiredMultiGrant() {
        assertPermissionGranted(""android.content.cts.REQUIRED_MULTI_GRANT"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PermissionFeatureTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PermissionFeatureTest"	"testPermissionRequiredMultiGrant_usingTags"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/pm/cts/PermissionFeatureTest.java]:[permission]:[2]:method_text:[ngTags() {        assertPermissionGranted(""android.content.cts.REQUIRED_MULTI_GRANT_2"");    }   ]) :|: public void testPermissionRequiredMultiGrant_usingTags() {
        assertPermissionGranted(""android.content.cts.REQUIRED_MULTI_GRANT_2"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PermissionFeatureTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PermissionFeatureTest"	"testPermissionRequiredMultiGrant_usingTagsAndAttributes"	"CtsContentTestCases"	"1: permission"	"([8:/android/content/pm/cts/PermissionFeatureTest.java]:[permission]:[8]:method_text:[ISSION_DENIED,                pm.checkPermission(permName, getContext().getPackageName()));    }}]) :|: public void testPermissionRequiredMultiGrant_usingTagsAndAttributes() {
        assertPermissionGranted(""android.content.cts.REQUIRED_MULTI_GRANT_3"");
    }

    public void assertPermissionGranted(String permName) {
        final PackageManager pm = getContext().getPackageManager();
        assertEquals(PackageManager.PERMISSION_GRANTED,
                pm.checkPermission(permName, getContext().getPackageName()));
    }

    public void assertPermissionDenied(String permName) {
        final PackageManager pm = getContext().getPackageManager();
        assertEquals(PackageManager.PERMISSION_DENIED,
                pm.checkPermission(permName, getContext().getPackageName()));
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PermissionFeatureTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PackageManagerShellCommandTest"	"testDataLoaderParamsApiV1"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/pm/cts/PackageManagerShellCommandTest.java]:[permission]:[2]:method_text:[       } finally {            getUiAutomation().dropShellPermissionIdentity();        }    }   ]) :|: 
    public void testDataLoaderParamsApiV1() throws Exception {
        if (!mStreaming) {
            return;
        }

        getUiAutomation().adoptShellPermissionIdentity();
        try {
            final PackageInstaller installer = getPackageInstaller();

            final SessionParams params = new SessionParams(SessionParams.MODE_FULL_INSTALL);

            final int sessionId = installer.createSession(params);
            PackageInstaller.Session session = installer.openSession(sessionId);

            assertEquals(null, session.getDataLoaderParams());

            installer.abandonSession(sessionId);
        } finally {
            getUiAutomation().dropShellPermissionIdentity();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerShellCommandTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PackageManagerShellCommandTest"	"testDataLoaderParamsApiV2"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/pm/cts/PackageManagerShellCommandTest.java]:[permission]:[2]:method_text:[       } finally {            getUiAutomation().dropShellPermissionIdentity();        }    }   ]) :|: 
    public void testDataLoaderParamsApiV2() throws Exception {
        if (!mStreaming) {
            return;
        }

        getUiAutomation().adoptShellPermissionIdentity();
        try {
            final PackageInstaller installer = getPackageInstaller();

            final SessionParams params = new SessionParams(SessionParams.MODE_FULL_INSTALL);
            final ComponentName componentName = new ComponentName(""foo"", ""bar"");
            final String args = ""args"";
            params.setDataLoaderParams(
                    mIncremental ? DataLoaderParams.forIncremental(componentName, args)
                            : DataLoaderParams.forStreaming(componentName, args));

            final int sessionId = installer.createSession(params);
            PackageInstaller.Session session = installer.openSession(sessionId);

            DataLoaderParams dataLoaderParams = session.getDataLoaderParams();
            assertEquals(mIncremental ? DATA_LOADER_TYPE_INCREMENTAL : DATA_LOADER_TYPE_STREAMING,
                    dataLoaderParams.getType());
            assertEquals(""foo"", dataLoaderParams.getComponentName().getPackageName());
            assertEquals(""bar"", dataLoaderParams.getComponentName().getClassName());
            assertEquals(""args"", dataLoaderParams.getArguments());

            installer.abandonSession(sessionId);
        } finally {
            getUiAutomation().dropShellPermissionIdentity();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerShellCommandTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PackageManagerShellCommandTest"	"testRemoveFileApiV2"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/pm/cts/PackageManagerShellCommandTest.java]:[permission]:[2]:method_text:[mand(                ""pm uninstall "" + packageName + "" "" + String.join("" "", splitNames)));    }}]) :|: 
    public void testRemoveFileApiV2() throws Exception {
        if (!mStreaming) {
            return;
        }

        getUiAutomation().adoptShellPermissionIdentity();
        try {
            final PackageInstaller installer = getPackageInstaller();

            final SessionParams params = new SessionParams(SessionParams.MODE_INHERIT_EXISTING);
            params.setAppPackageName(""com.package.name"");
            final ComponentName componentName = new ComponentName(""foo"", ""bar"");
            final String args = ""args"";
            params.setDataLoaderParams(
                    mIncremental ? DataLoaderParams.forIncremental(componentName, args)
                            : DataLoaderParams.forStreaming(componentName, args));

            final int sessionId = installer.createSession(params);
            PackageInstaller.Session session = installer.openSession(sessionId);

            session.addFile(LOCATION_DATA_APP, ""base.apk"", 123, ""123"".getBytes(), null);
            String[] files = session.getNames();
            assertEquals(1, files.length);
            assertEquals(""base.apk"", files[0]);

            session.removeFile(LOCATION_DATA_APP, ""base.apk"");
            files = session.getNames();
            assertEquals(2, files.length);
            assertEquals(""base.apk"", files[0]);
            assertEquals(""base.apk.removed"", files[1]);

            installer.abandonSession(sessionId);
        } finally {
            getUiAutomation().dropShellPermissionIdentity();
        }
    }

    private String createUpdateSession(String packageName) throws IOException {
        return createSession(""-p "" + packageName);
    }

    private String createSession(String arg) throws IOException {
        final String prefix = ""Success: created install session ["";
        final String suffix = ""]\n"";
        final String commandResult = executeShellCommand(""pm install-create "" + arg);
        assertTrue(commandResult, commandResult.startsWith(prefix));
        asse"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerShellCommandTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.ChecksumsTest"	"testInstallerSignedChecksumsInvalidSignature"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/pm/cts/ChecksumsTest.java]:[permission]:[2]:method_text:[       } finally {            getUiAutomation().dropShellPermissionIdentity();        }    }   ]) :|: 
    public void testInstallerSignedChecksumsInvalidSignature() throws Exception {
        getUiAutomation().adoptShellPermissionIdentity();
        try {
            final PackageInstaller installer = getPackageInstaller();
            final SessionParams params = new SessionParams(SessionParams.MODE_FULL_INSTALL);

            final int sessionId = installer.createSession(params);
            Session session = installer.openSession(sessionId);
            writeFileToSession(session, ""file"", TEST_FIXED_APK);
            try {
                session.setChecksums(""file"", Arrays.asList(TEST_FIXED_APK_DIGESTS),
                        hexStringToBytes(""1eec9e86""));
                Assert.fail(""setChecksums should throw exception."");
            } catch (IllegalArgumentException e) {
                // expected
            }
        } finally {
            getUiAutomation().dropShellPermissionIdentity();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/ChecksumsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.ChecksumsTest"	"testInstallerChecksumsUpdate"	"CtsContentTestCases"	"1: permission"	"([4:/android/content/pm/cts/ChecksumsTest.java]:[permission]:[4]:method_text:[PackageName());            assertNull(checksums[9].getInstallerCertificate());        }    }   ]) :|: 
    public void testInstallerChecksumsUpdate() throws Exception {
        Checksum[] digestsBase = new Checksum[]{new Checksum(TYPE_WHOLE_SHA256, hexStringToBytes(
                ""ed8c7ae1220fe16d558e00cfc37256e6f7088ab90eb04c1bfcb39922a8a5248e"")),
                new Checksum(TYPE_WHOLE_MD5, hexStringToBytes(""dd93e23bb8cdab0382fdca0d21a4f1cb""))};
        Checksum[] digestsSplit0 = new Checksum[]{new Checksum(TYPE_WHOLE_SHA256, hexStringToBytes(
                ""bd9b095a49a9068498b018ce8cb7cc18d411b13a5a5f7fb417d2ff9808ae838e"")),
                new Checksum(TYPE_WHOLE_MD5, hexStringToBytes(""f6430e1b795ce2658c49e68d15316b2d""))};
        Checksum[] digestsSplit1 = new Checksum[]{new Checksum(TYPE_WHOLE_SHA256, hexStringToBytes(
                ""f16898f43990c14585a900eda345c3a236c6224f63920d69cfe8a7afbc0c0ccf"")),
                new Checksum(TYPE_WHOLE_MD5, hexStringToBytes(""d1f4b00d034994663e84f907fe4bb664""))};

        final Certificate installerCertificate = getInstallerCertificate();

        // Original package checksums: base + split0.
        getUiAutomation().adoptShellPermissionIdentity();
        try {
            final PackageInstaller installer = getPackageInstaller();
            final SessionParams params = new SessionParams(SessionParams.MODE_FULL_INSTALL);

            final int sessionId = installer.createSession(params);
            Session session = installer.openSession(sessionId);

            writeFileToSession(session, ""hw5"", TEST_V4_APK);
            session.setChecksums(""hw5"", Arrays.asList(digestsBase), NO_SIGNATURE);

            writeFileToSession(session, ""hw5_split0"", TEST_V4_SPLIT0);
            session.setChecksums(""hw5_split0"", Arrays.asList(digestsSplit0), NO_SIGNATURE);

            CommitIntentReceiver receiver = new CommitIntentReceiver();
            session.commit(receiver.getIntentSender());
            CommitIntentReceiver.checkSuccess(receiver.getResult());
        } finally {
            getUiAutomation().dropShellPermissio"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/ChecksumsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.ChecksumsTest"	"testInstallerSignedChecksumsUpdate"	"CtsContentTestCases"	"1: permission"	"([4:/android/content/pm/cts/ChecksumsTest.java]:[permission]:[4]:method_text:[PackageName());            assertNull(checksums[9].getInstallerCertificate());        }    }   ]) :|: 
    public void testInstallerSignedChecksumsUpdate() throws Exception {
        Checksum[] digestsBase = new Checksum[]{new Checksum(TYPE_WHOLE_SHA256, hexStringToBytes(
                ""ed8c7ae1220fe16d558e00cfc37256e6f7088ab90eb04c1bfcb39922a8a5248e"")),
                new Checksum(TYPE_WHOLE_MD5, hexStringToBytes(""dd93e23bb8cdab0382fdca0d21a4f1cb""))};
        Checksum[] digestsSplit0 = new Checksum[]{new Checksum(TYPE_WHOLE_SHA256, hexStringToBytes(
                ""bd9b095a49a9068498b018ce8cb7cc18d411b13a5a5f7fb417d2ff9808ae838e"")),
                new Checksum(TYPE_WHOLE_MD5, hexStringToBytes(""f6430e1b795ce2658c49e68d15316b2d""))};
        Checksum[] digestsSplit1 = new Checksum[]{new Checksum(TYPE_WHOLE_SHA256, hexStringToBytes(
                ""f16898f43990c14585a900eda345c3a236c6224f63920d69cfe8a7afbc0c0ccf"")),
                new Checksum(TYPE_WHOLE_MD5, hexStringToBytes(""d1f4b00d034994663e84f907fe4bb664""))};

        String digestBaseFile = ApkChecksums.buildDigestsPathForApk(TEST_V4_APK);
        String digestSplit0File = ApkChecksums.buildDigestsPathForApk(TEST_V4_SPLIT0);
        String digestSplit1File = ApkChecksums.buildDigestsPathForApk(TEST_V4_SPLIT1);

        checkStoredChecksums(digestsBase, digestBaseFile);
        checkStoredChecksums(digestsSplit0, digestSplit0File);
        checkStoredChecksums(digestsSplit1, digestSplit1File);

        byte[] digestBaseSignature = readSignature(
                ApkChecksums.buildSignaturePathForDigests(digestBaseFile));
        byte[] digestSplit0Signature = readSignature(
                ApkChecksums.buildSignaturePathForDigests(digestSplit0File));
        byte[] digestSplit1Signature = readSignature(
                ApkChecksums.buildSignaturePathForDigests(digestSplit1File));

        final Certificate certificate = readCertificate();

        // Original package checksums: base + split0.
        getUiAutomation().adoptShellPermissionIdentity();
        try {
            final PackageInstaller installer"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/ChecksumsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.ChecksumsTest"	"testInstallerChecksumsDuplicate"	"CtsContentTestCases"	"1: permission"	"([7:/android/content/pm/cts/ChecksumsTest.java]:[permission]:[7]:method_text:[     checkFailure(result, PackageInstaller.STATUS_FAILURE, expectedStatusMessage);        }    }}]) :|: 
    public void testInstallerChecksumsDuplicate() throws Exception {
        getUiAutomation().adoptShellPermissionIdentity();
        try {
            final PackageInstaller installer = getPackageInstaller();
            final SessionParams params = new SessionParams(SessionParams.MODE_FULL_INSTALL);

            final int sessionId = installer.createSession(params);
            Session session = installer.openSession(sessionId);
            writeFileToSession(session, ""file"", TEST_FIXED_APK);
            session.setChecksums(""file"", Arrays.asList(TEST_FIXED_APK_DIGESTS), NO_SIGNATURE);
            try {
                session.setChecksums(""file"", Arrays.asList(TEST_FIXED_APK_DIGESTS), NO_SIGNATURE);
                Assert.fail(""setChecksums should throw exception."");
            } catch (IllegalStateException e) {
                // expected
            }
        } finally {
            getUiAutomation().dropShellPermissionIdentity();
        }
    }

    private List<Certificate> convertSignaturesToCertificates(Signature[] signatures) {
        try {
            final CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
            ArrayList<Certificate> certs = new ArrayList<>(signatures.length);
            for (Signature signature : signatures) {
                final InputStream is = new ByteArrayInputStream(signature.toByteArray());
                final X509Certificate cert = (X509Certificate) cf.generateCertificate(is);
                certs.add(cert);
            }
            return certs;
        } catch (CertificateException e) {
            throw ExceptionUtils.propagate(e);
        }
    }

    private void installApkWithChecksums(Checksum[] checksums) throws Exception {
        installApkWithChecksums(""file"", ""file"", checksums);
    }

    private void installApkWithChecksums(String apkName, String checksumsName, Checksum[] checksums)
            throws Exception {
        CommitIntentReceiver.checkSuccess(
                installApkW"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/ChecksumsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.ServiceInfoTest"	"testServiceInfo"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/pm/cts/ServiceInfoTest.java]:[permission]:[2]:method_text:[s(expected.name, actual.name);        assertEquals(expected.permission, actual.permission);    }}]) :|: public void testServiceInfo() throws NameNotFoundException {
        PackageManager pm = getContext().getPackageManager();
        ComponentName componentName = new ComponentName(PACKAGE_NAME, SERVICE_NAME);
        Parcel p = Parcel.obtain();

        // Test ServiceInfo()
        new ServiceInfo();

        ServiceInfo serviceInfo = pm.getServiceInfo(componentName, 0);
        // Test ServiceInfo(ServiceInfo orig)
        ServiceInfo infoFromExisted = new ServiceInfo(serviceInfo);
        checkInfoSame(serviceInfo, infoFromExisted);
        // Test toString, describeContents
        assertNotNull(serviceInfo.toString());
        assertEquals(0, serviceInfo.describeContents());

        // Test writeToParcel
        serviceInfo.writeToParcel(p, 0);
        p.setDataPosition(0);
        ServiceInfo infoFromParcel = ServiceInfo.CREATOR.createFromParcel(p);
        checkInfoSame(serviceInfo, infoFromParcel);
    }

    private void checkInfoSame(ServiceInfo expected, ServiceInfo actual) {
        assertEquals(expected.name, actual.name);
        assertEquals(expected.permission, actual.permission);
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/ServiceInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.ApplicationInfoTest"	"testWriteToParcel"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/pm/cts/ApplicationInfoTest.java]:[permission]:[2]:method_text:[ctivityName);        assertEquals(mApplicationInfo.descriptionRes, info.descriptionRes);    }   ]) :|: 
    public void testWriteToParcel() throws NameNotFoundException {
        mApplicationInfo = getContext().getPackageManager().getApplicationInfo(mPackageName, 0);

        Parcel p = Parcel.obtain();
        mApplicationInfo.writeToParcel(p, 0);

        p.setDataPosition(0);
        ApplicationInfo info = ApplicationInfo.CREATOR.createFromParcel(p);
        assertEquals(mApplicationInfo.taskAffinity, info.taskAffinity);
        assertEquals(mApplicationInfo.permission, info.permission);
        assertEquals(mApplicationInfo.processName, info.processName);
        assertEquals(mApplicationInfo.className, info.className);
        assertEquals(mApplicationInfo.theme, info.theme);
        assertEquals(mApplicationInfo.flags, info.flags);
        assertEquals(mApplicationInfo.sourceDir, info.sourceDir);
        assertEquals(mApplicationInfo.publicSourceDir, info.publicSourceDir);
        assertEquals(mApplicationInfo.sharedLibraryFiles, info.sharedLibraryFiles);
        assertEquals(mApplicationInfo.dataDir, info.dataDir);
        assertEquals(mApplicationInfo.uid, info.uid);
        assertEquals(mApplicationInfo.enabled, info.enabled);
        assertEquals(mApplicationInfo.manageSpaceActivityName, info.manageSpaceActivityName);
        assertEquals(mApplicationInfo.descriptionRes, info.descriptionRes);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/ApplicationInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PackageManagerShellCommandIncrementalTest"	"testSpaceAllocatedForPackage"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/pm/cts/PackageManagerShellCommandIncrementalTest.java]:[permission]:[2]:method_text:[CREMENTAL_DELIVERY, 2)) {            assertTrue(apkTrimResult <= appFileSize);        }    }   ]) :|: 
    public void testSpaceAllocatedForPackage() throws Exception {
        final String apk = createApkPath(TEST_APK);
        final String idsig = createApkPath(TEST_APK_IDSIG);
        final long appFileSize = new File(apk).length();
        final AtomicBoolean firstTime = new AtomicBoolean(true);

        getUiAutomation().adoptShellPermissionIdentity();

        final long blockSize = Os.statvfs(""/data/incremental"").f_bsize;
        final long preAllocatedBlocks = Os.statvfs(""/data/incremental"").f_bfree;

        mSession =
                new IncrementalInstallSession.Builder()
                        .addApk(Paths.get(apk), Paths.get(idsig))
                        .addExtraArgs(""-t"", ""-i"", CTS_PACKAGE_NAME)
                        .setLogger(new IncrementalDeviceConnection.Logger())
                        .setBlockFilter((block -> {
                            // Skip allocation check after first iteration.
                            if (!firstTime.getAndSet(false)) {
                                return true;
                            }

                            try {
                                final long postAllocatedBlocks =
                                        Os.statvfs(""/data/incremental"").f_bfree;
                                final long freeSpaceDifference =
                                        (preAllocatedBlocks - postAllocatedBlocks) * blockSize;
                                assertTrue(freeSpaceDifference
                                        >= ((appFileSize * 1.015) + blockSize * 8));
                            } catch (Exception e) {
                                Log.i(TAG, ""ErrnoException: "", e);
                                throw new AssertionError(e);
                            }
                            return true;
                        }))
                        .setBlockTransformer(new CompressingBlockTransformer())
                        .build();

        try {
            mSession.start(Executor"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerShellCommandIncrementalTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PackageManagerShellCommandIncrementalTest"	"testInstallWithStreaming"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/pm/cts/PackageManagerShellCommandIncrementalTest.java]:[permission]:[2]:method_text:[dentity();        }        assertTrue(isAppInstalled(TEST_APP_PACKAGE));    }    @LargeTest   ]) :|: 
    public void testInstallWithStreaming() throws Exception {
        final String apk = createApkPath(TEST_APK);
        final String idsig = createApkPath(TEST_APK_IDSIG);
        mSession =
                new IncrementalInstallSession.Builder()
                        .addApk(Paths.get(apk), Paths.get(idsig))
                        .addExtraArgs(""-t"", ""-i"", CTS_PACKAGE_NAME)
                        .setLogger(new IncrementalDeviceConnection.Logger())
                        .build();
        getUiAutomation().adoptShellPermissionIdentity();
        try {
            mSession.start(Executors.newSingleThreadExecutor(),
                    IncrementalDeviceConnection.Factory.reliable());
            mSession.waitForInstallCompleted(30, TimeUnit.SECONDS);
        } finally {
            getUiAutomation().dropShellPermissionIdentity();
        }
        assertTrue(isAppInstalled(TEST_APP_PACKAGE));
    }

    @LargeTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerShellCommandIncrementalTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PackageManagerShellCommandIncrementalTest"	"testInstallWithMissingBlocks"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/pm/cts/PackageManagerShellCommandIncrementalTest.java]:[permission]:[2]:method_text:[xception {            return new CompressedPendingBlock(block);        }    }    @LargeTest   ]) :|: 
    public void testInstallWithMissingBlocks() throws Exception {
        setDeviceProperty(""incfs_default_timeouts"", ""0:0:0"");
        setDeviceProperty(""known_digesters_list"", CTS_PACKAGE_NAME);
        setSystemProperty(""debug.incremental.always_enable_read_timeouts_for_system_dataloaders"",
                ""0"");

        final long randomSeed = System.currentTimeMillis();
        Log.i(TAG, ""Randomizing missing blocks with seed: "" + randomSeed);
        final Random random = new Random(randomSeed);

        // TODO: add detection of orphaned IncFS instances after failed installations

        final int blockSize = 4096;
        final int retries = 7; // 7 * 3s + leeway ~= 30secs of test timeout

        final File apk = new File(createApkPath(TEST_APK));
        final int blocks = (int) (apk.length() / blockSize);

        for (int i = 0; i < retries; ++i) {
            final int skipBlock = random.nextInt(blocks);
            Log.i(TAG, ""skipBlock: "" + skipBlock + "" out of "" + blocks);
            try {
                installWithBlockFilter((block -> block.getType() == PendingBlock.Type.SIGNATURE_TREE
                        || block.getBlockIndex() != skipBlock));
                if (isAppInstalled(TEST_APP_PACKAGE)) {
                    uninstallPackageSilently(TEST_APP_PACKAGE);
                }
            } catch (RuntimeException re) {
                Log.i(TAG, ""RuntimeException: "", re);
                assertTrue(re.toString(), re.getCause() instanceof IOException);
            } catch (IOException e) {
                Log.i(TAG, ""IOException: "", e);
                throw new IOException(""Skipped block: "" + skipBlock + "", randomSeed: "" + randomSeed,
                        e);
            }
        }
    }

    public void installWithBlockFilter(IBlockFilter blockFilter) throws Exception {
        final String apk = createApkPath(TEST_APK);
        final String idsig = createApkPath(TEST_APK_IDSIG);
        mSession =
                new IncrementalI"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerShellCommandIncrementalTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PackageManagerShellCommandIncrementalTest"	"testInstallWithStreamingAndCompression"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/pm/cts/PackageManagerShellCommandIncrementalTest.java]:[permission]:[2]:method_text:[dentity();        }        assertTrue(isAppInstalled(TEST_APP_PACKAGE));    }    @LargeTest   ]) :|: 
    public void testInstallWithStreamingAndCompression() throws Exception {
        final String apk = createApkPath(TEST_APK);
        final String idsig = createApkPath(TEST_APK_IDSIG);
        mSession =
                new IncrementalInstallSession.Builder()
                        .addApk(Paths.get(apk), Paths.get(idsig))
                        .addExtraArgs(""-t"", ""-i"", CTS_PACKAGE_NAME)
                        .setLogger(new IncrementalDeviceConnection.Logger())
                        .setBlockTransformer(new CompressingBlockTransformer())
                        .build();
        getUiAutomation().adoptShellPermissionIdentity();
        try {
            mSession.start(Executors.newSingleThreadExecutor(),
                    IncrementalDeviceConnection.Factory.reliable());
            mSession.waitForInstallCompleted(30, TimeUnit.SECONDS);
        } finally {
            getUiAutomation().dropShellPermissionIdentity();
        }
        assertTrue(isAppInstalled(TEST_APP_PACKAGE));
    }

    @LargeTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerShellCommandIncrementalTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PackageManagerShellCommandIncrementalTest"	"testInstallWithStreamingUnreliableConnection"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/pm/cts/PackageManagerShellCommandIncrementalTest.java]:[permission]:[2]:method_text:[       } finally {            getUiAutomation().dropShellPermissionIdentity();        }    }   ]) :|: 
    public void testInstallWithStreamingUnreliableConnection() throws Exception {
        final String apk = createApkPath(TEST_APK);
        final String idsig = createApkPath(TEST_APK_IDSIG);
        mSession =
                new IncrementalInstallSession.Builder()
                        .addApk(Paths.get(apk), Paths.get(idsig))
                        .addExtraArgs(""-t"", ""-i"", CTS_PACKAGE_NAME)
                        .setLogger(new IncrementalDeviceConnection.Logger())
                        .build();
        getUiAutomation().adoptShellPermissionIdentity();
        try {
            mSession.start(Executors.newSingleThreadExecutor(),
                    IncrementalDeviceConnection.Factory.ureliable());
            mSession.waitForInstallCompleted(30, TimeUnit.SECONDS);
        } catch (Exception ignored) {
            // Ignore, we are looking for crashes anyway.
        } finally {
            getUiAutomation().dropShellPermissionIdentity();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerShellCommandIncrementalTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PackageManagerShellCommandIncrementalTest"	"testInstallWithIdSigStreamPerUidTimeoutsIncompleteData"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/pm/cts/PackageManagerShellCommandIncrementalTest.java]:[permission]:[2]:method_text:[inally {            executeShellCommand(""atrace --async_stop"");        }    }    @LargeTest   ]) :|: 
    public void testInstallWithIdSigStreamPerUidTimeoutsIncompleteData() throws Exception {
        checkIncrementalDeliveryV2Feature();

        mSession =
                new IncrementalInstallSession.Builder()
                        .addApk(Paths.get(createApkPath(TEST_APK)),
                                Paths.get(createApkPath(TEST_APK_IDSIG)))
                        .addApk(Paths.get(createApkPath(TEST_APK_SPLIT0)),
                                Paths.get(createApkPath(TEST_APK_SPLIT0_IDSIG)))
                        .addApk(Paths.get(createApkPath(TEST_APK_SPLIT1)),
                                Paths.get(createApkPath(TEST_APK_SPLIT1_IDSIG)))
                        .addExtraArgs(""-t"", ""-i"", CTS_PACKAGE_NAME)
                        .setLogger(new IncrementalDeviceConnection.Logger())
                        .build();

        executeShellCommand(""atrace --async_start -b 1024 -c adb"");
        try {
            setDeviceProperty(""incfs_default_timeouts"", ""5000000:5000000:5000000"");
            setDeviceProperty(""known_digesters_list"", CTS_PACKAGE_NAME);

            final int beforeReadDelayMs = 1000;
            Thread.currentThread().sleep(beforeReadDelayMs);

            // Partially install the apk+split0+split1.
            getUiAutomation().adoptShellPermissionIdentity();
            try {
                mSession.start(Executors.newSingleThreadExecutor(),
                        IncrementalDeviceConnection.Factory.reliable());
                mSession.waitForInstallCompleted(30, TimeUnit.SECONDS);
                assertEquals(""base, config.hdpi, config.mdpi"", getSplits(TEST_APP_PACKAGE));
            } finally {
                getUiAutomation().dropShellPermissionIdentity();
            }

            // Try to read a split and see if we are throttled.
            final File apkToRead = getSplit(""split_config.mdpi.apk"");
            final long readTime0 = readAndReportTime(apkToRead, 1000);

            assertTrue(
                    ""Must"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerShellCommandIncrementalTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.PackageManagerShellCommandIncrementalTest"	"testInstallSysTraceNoReadlogs"	"CtsContentTestCases"	"1: permission"	"([2:/android/content/pm/cts/PackageManagerShellCommandIncrementalTest.java]:[permission]:[2]:method_text:[ng value) throws Exception {        executeShellCommand(""setprop "" + name + "" "" + value);    }}]) :|: 
    public void testInstallSysTraceNoReadlogs() throws Exception {
        setSystemProperty(""debug.incremental.enforce_readlogs_max_interval_for_system_dataloaders"",
                ""1"");
        setSystemProperty(""debug.incremental.readlogs_max_interval_sec"", ""0"");

        final int atraceDumpIterations = 30;
        final int atraceDumpDelayMs = 100;
        final String expected = ""|page_read:"";

        // We don't expect any readlogs with 0sec interval.
        assertFalse(
                ""Page reads ("" + expected + "") were found in atrace dump"",
                checkSysTraceForSubstring(TEST_APK, expected, atraceDumpIterations,
                        atraceDumpDelayMs));
    }

    private boolean checkSysTraceForSubstring(String testApk, final String expected,
            int atraceDumpIterations, int atraceDumpDelayMs) throws Exception {
        final int installIterations = 3;
        return checkSysTrace(
                installIterations,
                atraceDumpIterations,
                atraceDumpDelayMs,
                () -> installPackage(testApk),
                (stdout) -> stdout.contains(expected));
    }

    private boolean checkSysTrace(
            int installIterations,
            int atraceDumpIterations,
            int atraceDumpDelayMs,
            final Callable<Void> installer,
            final Function<String, Boolean> checker)
            throws Exception {
        final int beforeReadDelayMs = 1000;

        final CompletableFuture<Boolean> result = new CompletableFuture<>();
        final Thread readFromProcess = new Thread(() -> {
            try {
                executeShellCommand(""atrace --async_start -b 10240 -c adb"");
                try {
                    for (int i = 0; i < atraceDumpIterations; ++i) {
                        final String stdout = executeShellCommand(""atrace --async_dump"");
                        try {
                            if (checker.apply(stdout)) {
                                re"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/PackageManagerShellCommandIncrementalTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.FeatureTest"	"testManagedProfileSupported"	"CtsContentTestCases"	"1: managed_users"	"([1:/android/content/pm/cts/FeatureTest.java]:[managed_users]:[1]:method_text:[GbDevice()    private boolean lessThanTwoGbDevice() {        return mTotalMemory < TWO_GB;    }}]) :|: public void testManagedProfileSupported() throws Exception {
        // Managed profiles only required if device admin feature is supported
        if (!mSupportsDeviceAdmin) {
            Log.w(TAG, ""Skipping testManagedProfileSupported"");
            return;
        }

        if (mSupportsManagedProfiles) {
            // Managed profiles supported nothing to check.
            return;
        }

        // Managed profiles only required for handheld devices
        if (!isHandheldDevice()) {
            return;
        }

        // Skip the tests for non-emulated sdcard
        if (!Environment.isExternalStorageEmulated()) {
            return;
        }

        // Skip the tests for devices with less than 2GB of ram available
        if (lessThanTwoGbDevice()) {
            return;
        }

        fail(""Device should support managed profiles, but ""
                + PackageManager.FEATURE_MANAGED_USERS + "" is not enabled"");
    }

    /**
     * The CDD defines a handheld device as one that has a battery and a screen size between
     * 2.5 and 8 inches.
     */
    private boolean isHandheldDevice() throws Exception {
        double screenInches = getScreenSizeInInches();
        return deviceHasBattery() && screenInches >= 2.5 && screenInches <= 8.0;
    }

    private boolean deviceHasBattery() {
        final Intent batteryInfo = getContext().registerReceiver(null,
                new IntentFilter(Intent.ACTION_BATTERY_CHANGED));
        return batteryInfo.getBooleanExtra(BatteryManager.EXTRA_PRESENT, true);
    }

    private double getScreenSizeInInches() {
        DisplayMetrics dm = new DisplayMetrics();
        mWindowManager.getDefaultDisplay().getMetrics(dm);
        double widthInInchesSquared = Math.pow(dm.widthPixels/dm.xdpi,2);
        double heightInInchesSquared = Math.pow(dm.heightPixels/dm.ydpi,2);
        return Math.sqrt(widthInInchesSquared + heightInInchesSquared);
    }

    // Implementation copied from CoreGmsAppsTest#twoGbDevice("	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/FeatureTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.ProviderInfoTest"	"testProviderMetaData"	"CtsContentTestCases"	"1: permission"	"([8:/android/content/pm/cts/ProviderInfoTest.java]:[permission]:[8]:method_text:[.initOrder, actual.initOrder);        assertEquals(expected.isSyncable, actual.isSyncable);    }}]) :|: public void testProviderMetaData() {
        final ProviderInfo info = getContext().getPackageManager()
                .resolveContentProvider(""android.content.cts.fileprovider"",
                        PackageManager.GET_META_DATA);
        final XmlResourceParser in = info.loadXmlMetaData(
                getContext().getPackageManager(), ""android.support.FILE_PROVIDER_PATHS"");
        try {
            assertNotNull(in);
        } finally {
            IoUtils.closeQuietly(in);
        }
    }

    private void checkProviderInfoMethods(ProviderInfo providerInfo, Parcel p) {
        // Test toString, describeContents
        assertNotNull(providerInfo.toString());
        assertEquals(0, providerInfo.describeContents());

        // Test ProviderInfo(ProviderInfo orig)
        ProviderInfo infoFromExisted = new ProviderInfo(providerInfo);
        checkInfoSame(providerInfo, infoFromExisted);

        // Test writeToParcel
        providerInfo.writeToParcel(p, 0);
        p.setDataPosition(0);
        ProviderInfo infoFromParcel = ProviderInfo.CREATOR.createFromParcel(p);
        checkInfoSame(providerInfo, infoFromParcel);
        p.recycle();
    }

    private void checkInfoSame(ProviderInfo expected, ProviderInfo actual) {
        assertEquals(expected.name, actual.name);
        assertEquals(expected.authority, actual.authority);
        assertEquals(expected.readPermission, actual.readPermission);
        assertEquals(expected.writePermission, actual.writePermission);
        assertEquals(expected.grantUriPermissions, actual.grantUriPermissions);
        assertEquals(expected.uriPermissionPatterns, actual.uriPermissionPatterns);
        assertEquals(expected.multiprocess, actual.multiprocess);
        assertEquals(expected.initOrder, actual.initOrder);
        assertEquals(expected.isSyncable, actual.isSyncable);
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/ProviderInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.content.CtsSyncAccountAccessOtherCertTestCases"	"disallowSyncAdapterRunInBackgroundAndDataInBackground"	"CtsSyncAccountAccessOtherCertTestCases"	"1: permission"	"([4:/com/android/cts/content/CtsSyncAccountAccessOtherCertTestCases.java]:[permission]:[4]:method_text:[t scroll through notifications to find permission request ""            + ""b/147410068"")     */   ]) :|: /*
 *.
 */

package com.android.cts.content;

import static com.android.cts.content.Utils.ALWAYS_SYNCABLE_AUTHORITY;
import static com.android.cts.content.Utils.SYNC_TIMEOUT_MILLIS;
import static com.android.cts.content.Utils.allowSyncAdapterRunInBackgroundAndDataInBackground;
import static com.android.cts.content.Utils.disallowSyncAdapterRunInBackgroundAndDataInBackground;
import static com.android.cts.content.Utils.getUiDevice;
import static com.android.cts.content.Utils.hasDataConnection;
import static com.android.cts.content.Utils.hasNotificationSupport;
import static com.android.cts.content.Utils.isWatch;
import static com.android.cts.content.Utils.requestSync;
import static com.android.cts.content.Utils.withAccount;

import static org.junit.Assume.assumeFalse;
import static org.junit.Assume.assumeTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.timeout;
import static org.mockito.Mockito.verify;

import android.app.ActivityManager;
import android.content.AbstractThreadedSyncAdapter;
import android.content.ContentResolver;
import android.content.Context;
import android.content.SyncRequest;
import android.content.res.Configuration;
import android.support.test.uiautomator.By;
import android.support.test.uiautomator.UiDevice;
import android.support.test.uiautomator.UiObject2;
import android.support.test.uiautomator.Until;
import android.util.Log;

import androidx.test.InstrumentationRegistry;
import androidx.test.rule.ActivityTestRule;
import androidx.test.runner.AndroidJUnit4;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TestRule;
import org.junit.runner.RunWith;

import java.io.ByteArrayOutputStream;
import java.util.regex.Pattern;

/**
 * Tests whether a sync adapter can access accounts.
 */
@RunWith(AndroidJUnit4.class)
public class CtsSyncAccountAccessOtherCertTestCases {
    private static final long UI_TIME"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/CtsSyncAccountAccessOtherCertTests/src/com/android/cts/content/CtsSyncAccountAccessOtherCertTestCases.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.cts.content.CtsSyncAccountAccessOtherCertTestCases"	"testAccountAccess_otherCertAsAuthenticatorCanNotSeeAccount"	"CtsSyncAccountAccessOtherCertTestCases"	"1: permission"	"([10:/com/android/cts/content/CtsSyncAccountAccessOtherCertTestCases.java]:[permission]:[10]:method_text:[                 Configuration.UI_MODE_TYPE_MASK) == Configuration.UI_MODE_TYPE_VR_HEADSET);    }}]) :|: 
    public void testAccountAccess_otherCertAsAuthenticatorCanNotSeeAccount() throws Exception {
        assumeTrue(hasDataConnection());
        assumeTrue(hasNotificationSupport());
        assumeFalse(isRunningInVR());
        assumeFalse(isWatch());

        // If running in a test harness the Account Manager never denies access to an account. Hence
        // the permission request will not trigger. b/72114924
        assumeFalse(ActivityManager.isRunningInTestHarness());

        try (AutoCloseable ignored = withAccount(activity.getActivity())) {
            AbstractThreadedSyncAdapter adapter = AlwaysSyncableSyncService.getInstance(
                    activity.getActivity()).setNewDelegate();

            SyncRequest request = requestSync(ALWAYS_SYNCABLE_AUTHORITY);
            Log.i(LOG_TAG, ""Sync requested "" + request);

            Thread.sleep(SYNC_TIMEOUT_MILLIS);
            verify(adapter, never()).onPerformSync(any(), any(), any(), any(), any());
            Log.i(LOG_TAG, ""Did not get onPerformSync"");

            UiDevice uiDevice = getUiDevice();
            if (isWatch()) {
                UiObject2 notification = findPermissionNotificationInStream(uiDevice);
                notification.click();
                UiObject2 openButton = uiDevice.wait(
                        Until.findObject(By.text(OPEN_NOTIFICATION_WATCH)), UI_TIMEOUT_MILLIS);
                if (openButton != null) {
                    // older sysui may not have the ""open"" button
                    openButton.click();
                }
            } else {
                uiDevice.openNotification();
                int scrollUps = 0;

                while (true) {
                    try {
                        UiObject2 permissionRequest = uiDevice.wait(
                                Until.findObject(By.text(PERMISSION_REQUESTED)), UI_TIMEOUT_MILLIS);

                        permissionRequest.click();
                        break;
                    } catch (Throwab"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/CtsSyncAccountAccessOtherCertTests/src/com/android/cts/content/CtsSyncAccountAccessOtherCertTestCases.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.tests.securefrpinstall.SecureFrpInstallTest"	"adoptShellPermissions"	"CtsSecureFrpInstallTestCases"	"1: permission"	"([11:/com/android/tests/securefrpinstall/SecureFrpInstallTest.java]:[permission]:[11]:method_text:[ecureFrp(false);    }    /** Tests a SecurityException is thrown while in secure FRP mode. */   ]) :|: /*
 *.
 */

package com.android.tests.atomicinstall;

import static org.junit.Assert.fail;

import android.Manifest;
import android.content.pm.PackageManager;

import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.SystemUtil;
import com.android.cts.install.lib.Install;
import com.android.cts.install.lib.TestApp;
import com.android.cts.install.lib.Uninstall;

import org.junit.After;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

/** Tests for package installation while Secure FRP mode is enabled. */
@RunWith(JUnit4.class)
public class SecureFrpInstallTest {

    private static PackageManager sPackageManager;

    private static void adoptShellPermissions() {
        InstrumentationRegistry
                .getInstrumentation()
                .getUiAutomation()
                .adoptShellPermissionIdentity(
                        Manifest.permission.INSTALL_PACKAGES, Manifest.permission.DELETE_PACKAGES);
    }

    private static void dropShellPermissions() {
        InstrumentationRegistry
                .getInstrumentation()
                .getUiAutomation()
                .dropShellPermissionIdentity();
    }

    private static void setSecureFrp(boolean secureFrp) throws Exception {
        adoptShellPermissions();
        SystemUtil.runShellCommand(InstrumentationRegistry.getInstrumentation(),
                ""settings put --user 0 secure secure_frp_mode "" + (secureFrp ? ""1"" : ""0""));
        dropShellPermissions();
    }

    private static void assertInstalled() throws Exception {
        sPackageManager.getPackageInfo(TestApp.A, 0);
    }

    private static void assertNotInstalled() {
        try {
            sPackageManager.getPackageInfo(TestApp.A, 0);
            fail(""Package should not be installed"");
        } catch (PackageManager.NameNotFoundException expected) {
        }
    }

    @BeforeClass
    public stati"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/pm/SecureFrp/src/com/android/tests/securefrpinstall/SecureFrpInstallTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.tests.securefrpinstall.SecureFrpInstallTest"	"testPackageInstallApi"	"CtsSecureFrpInstallTestCases"	"1: permission"	"([1:/com/android/tests/securefrpinstall/SecureFrpInstallTest.java]:[permission]:[1]:method_text:[    /** Tests can install when granted INSTALL_PACKAGES permission; even in secure FRP mode. */   ]) :|: 
    public void testPackageInstallApi() throws Exception {
        setSecureFrp(true);
        try {
            Install.single(TestApp.A1).commit();
            fail(""Expected a SecurityException"");
        } catch (SecurityException expected) {
        }
        assertNotInstalled();
    }

    /** Tests can install when granted INSTALL_PACKAGES permission; even in secure FRP mode. */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/pm/SecureFrp/src/com/android/tests/securefrpinstall/SecureFrpInstallTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"com.android.tests.securefrpinstall.SecureFrpInstallTest"	"testPackageInstallApiAsShell"	"CtsSecureFrpInstallTestCases"	"1: permission"	"([2:/com/android/tests/securefrpinstall/SecureFrpInstallTest.java]:[permission]:[2]:method_text:[tall.single(TestApp.A1).commit();        dropShellPermissions();        assertInstalled();    }}]) :|: 
    public void testPackageInstallApiAsShell() throws Exception {
        setSecureFrp(true);
        adoptShellPermissions();
        Install.single(TestApp.A1).commit();
        dropShellPermissions();
        assertInstalled();
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/content/pm/SecureFrp/src/com/android/tests/securefrpinstall/SecureFrpInstallTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.usage.cts.NetworkUsageStatsTest"	"getIsDefault"	"CtsUsageStatsTestCases"	"2: INTERNET permission"	"([2:/android/app/usage/cts/NetworkUsageStatsTest.java]:[permission]:[2]:method_text:[er) -> telephonyManager.getSubscriberId());        }        return """";    }    @AppModeFull   ]) :|: public void test/**
 * Copyright (C) 2015 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License""); you may not
 * use this file except in compliance with the License. You may obtain a copy
 * of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

package android.app.usage.cts;

import android.app.AppOpsManager;
import android.app.usage.NetworkStatsManager;
import android.app.usage.NetworkStats;
import android.content.Context;
import android.content.pm.PackageManager;
import android.net.ConnectivityManager;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkInfo;
import android.net.NetworkRequest;
import android.net.TrafficStats;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.ParcelFileDescriptor;
import android.os.Process;
import android.os.RemoteException;
import android.os.SystemClock;
import android.platform.test.annotations.AppModeFull;
import android.telephony.TelephonyManager;
import android.test.InstrumentationTestCase;
import android.util.Log;

import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;
import java.net.UnknownHostException;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Scanner;
import java.net.HttpURLConnection;

import libcore.io.IoUtils;
import libcore.io.Streams;

import static android.app.usage.NetworkStats.Bucket.DEFAULT_NETWORK_ALL;
import static andro"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/NetworkUsageStatsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.usage.cts.UsageStatsTest"	"isAppStandbyEnabled"	"CtsUsageStatsTestCases"	"1: permission"	"([3:/android/app/usage/cts/UsageStatsTest.java]:[permission]:[3]:method_text:[ity(clazz);        }    }    @AppModeFull(reason = ""No usage events access in instant apps"")   ]) :|: /**
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License""); you may not
 * use this file except in compliance with the License. You may obtain a copy
 * of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

package android.app.usage.cts;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeFalse;
import static org.junit.Assume.assumeTrue;

import android.app.Activity;
import android.app.ActivityManager;
import android.app.AppOpsManager;
import android.app.KeyguardManager;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.usage.EventStats;
import android.app.usage.UsageEvents;
import android.app.usage.UsageEvents.Event;
import android.app.usage.UsageStats;
import android.app.usage.UsageStatsManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.content.pm.PackageManager;
import android.os.IBinder;
import android.os.Parcel;
import android.os.SystemClock;
import android.os.UserHandle;
import android.os.UserManager;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.AppModeInstant;
import android.provider.Settings;
import android.server.wm.WindowManagerState"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.usage.cts.UsageStatsTest"	"testLastTimeAnyComponentUsed_bindServiceShouldBeDetected"	"CtsUsageStatsTestCases"	"1: permission"	"([1:/android/app/usage/cts/UsageStatsTest.java]:[permission]:[1]:method_text:[e / DAY);        });    }    @AppModeFull(reason = ""No usage events access in instant apps"")   ]) :|: 
    public void testLastTimeAnyComponentUsed_bindServiceShouldBeDetected() throws Exception {
        mUiDevice.wakeUp();
        dismissKeyguard(); // also want to start out with the keyguard dismissed.

        final long startTime = System.currentTimeMillis();
        bindToTestService();
        final long endTime = System.currentTimeMillis();

        verifyLastTimeAnyComponentUsedWithinRange(startTime, endTime, TEST_APP_PKG);
    }

    private void verifyLastTimeAnyComponentUsedWithinRange(
            long startTime, long endTime, String targetPackage) {
        final Map<String, UsageStats> map = mUsageStatsManager.queryAndAggregateUsageStats(
                startTime, endTime);
        final UsageStats stats = map.get(targetPackage);
        assertNotNull(stats);
        final long lastTimeAnyComponentUsed = stats.getLastTimeAnyComponentUsed();
        assertLessThan(startTime, lastTimeAnyComponentUsed);
        assertLessThan(lastTimeAnyComponentUsed, endTime);

        SystemUtil.runWithShellPermissionIdentity(()-> {
            final long lastDayAnyComponentUsedGlobal =
                    mUsageStatsManager.getLastTimeAnyComponentUsed(targetPackage) / DAY;
            assertLessThanOrEqual(startTime / DAY, lastDayAnyComponentUsedGlobal);
            assertLessThanOrEqual(lastDayAnyComponentUsedGlobal, endTime / DAY);
        });
    }

    @AppModeFull(reason = ""No usage events access in instant apps"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.usage.cts.UsageStatsTest"	"testLastTimeAnyComponentUsed_JobServiceShouldBeIgnored"	"CtsUsageStatsTestCases"	"1: permission"	"([1:/android/app/usage/cts/UsageStatsTest.java]:[permission]:[1]:method_text:[e / DAY);        });    }    @AppModeFull(reason = ""No usage events access in instant apps"")   ]) :|: 
    public void testLastTimeAnyComponentUsed_JobServiceShouldBeIgnored() throws Exception {
        mUiDevice.wakeUp();
        dismissKeyguard(); // also want to start out with the keyguard dismissed.

        final long startTime = System.currentTimeMillis();
        runJobImmediately();
        waitUntil(TestJob.hasJobStarted, /* expected */ true);

        final Map<String, UsageStats> map = mUsageStatsManager.queryAndAggregateUsageStats(
                startTime, System.currentTimeMillis());
        final UsageStats stats = map.get(mTargetPackage);
        if (stats != null) {
            final long lastTimeAnyComponentUsed = stats.getLastTimeAnyComponentUsed();
            // Check that the usage is NOT detected.
            assertLessThanOrEqual(lastTimeAnyComponentUsed, startTime);
        }

        SystemUtil.runWithShellPermissionIdentity(()-> {
            final long lastDayAnyComponentUsedGlobal =
                    mUsageStatsManager.getLastTimeAnyComponentUsed(mTargetPackage) / DAY;
            // Check that the usage is NOT detected.
            assertLessThanOrEqual(lastDayAnyComponentUsedGlobal, startTime / DAY);
        });
    }

    @AppModeFull(reason = ""No usage events access in instant apps"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.usage.cts.UsageStatsTest"	"testLastTimeAnyComponentUsedGlobal_withoutPermission"	"CtsUsageStatsTestCases"	"1: permission"	"([2:/android/app/usage/cts/UsageStatsTest.java]:[permission]:[2]:method_text:[// Expected        }    }    @AppModeFull(reason = ""No usage events access in instant apps"")   ]) :|: 
    public void testLastTimeAnyComponentUsedGlobal_withoutPermission() throws Exception {
        try{
            mUsageStatsManager.getLastTimeAnyComponentUsed(mTargetPackage);
            fail(""Query across users should require INTERACT_ACROSS_USERS permission"");
        } catch (SecurityException se) {
            // Expected
        }
    }

    @AppModeFull(reason = ""No usage events access in instant apps"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.usage.cts.UsageStatsTest"	"testQueryEventsForSelf"	"CtsUsageStatsTestCases"	"1: permission"	"([1:/android/app/usage/cts/UsageStatsTest.java]:[permission]:[1]:method_text:[ the time, thereby allowing this test to set the time using the UIAutomator.     */    @Ignore   ]) :|: 
    public void testQueryEventsForSelf() throws Exception {
        setAppOpsMode(""ignore""); // To ensure permission is not required
        // Time drifts of 2s are expected inside usage stats
        final long start = System.currentTimeMillis() - 2_000;
        setStandByBucket(mTargetPackage, ""rare"");
        Thread.sleep(100);
        setStandByBucket(mTargetPackage, ""working_set"");
        Thread.sleep(100);
        final long end = System.currentTimeMillis() + 2_000;
        final UsageEvents events = mUsageStatsManager.queryEventsForSelf(start, end);
        long rareTimeStamp = end + 1; // Initializing as rareTimeStamp > workingTimeStamp
        long workingTimeStamp = start - 1;
        int numEvents = 0;
        while (events.hasNextEvent()) {
            UsageEvents.Event event = new UsageEvents.Event();
            assertTrue(events.getNextEvent(event));
            numEvents++;
            assertEquals(""Event for a different package"", mTargetPackage, event.getPackageName());
            if (event.getEventType() == Event.STANDBY_BUCKET_CHANGED) {
                if (event.getAppStandbyBucket() == UsageStatsManager.STANDBY_BUCKET_RARE) {
                    rareTimeStamp = event.getTimeStamp();
                }
                else if (event.getAppStandbyBucket() == UsageStatsManager
                        .STANDBY_BUCKET_WORKING_SET) {
                    workingTimeStamp = event.getTimeStamp();
                }
            }
        }
        assertTrue(""Only "" + numEvents + "" events returned"", numEvents >= 2);
        assertLessThan(rareTimeStamp, workingTimeStamp);
    }

    /**
     * We can't run this test because we are unable to change the system time.
     * It would be nice to add a shell command or other to allow the shell user
     * to set the time, thereby allowing this test to set the time using the UIAutomator.
     */
    @Ignore"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.usage.cts.UsageStatsTest"	"testNoAccessSilentlyFails"	"CtsUsageStatsTestCases"	"1: permission"	"([1:/android/app/usage/cts/UsageStatsTest.java]:[permission]:[1]:method_text:[   Thread.sleep(500);    }    @AppModeFull(reason = ""No usage events access in instant apps"")   ]) :|: 
    public void testNoAccessSilentlyFails() throws Exception {
        final long startTime = System.currentTimeMillis() - MINUTE;

        launchSubActivity(android.app.usage.cts.Activities.ActivityOne.class);
        launchSubActivity(android.app.usage.cts.Activities.ActivityThree.class);

        final long endTime = System.currentTimeMillis();
        List<UsageStats> stats = mUsageStatsManager.queryUsageStats(UsageStatsManager.INTERVAL_BEST,
                startTime, endTime);
        assertFalse(stats.isEmpty());

        // We set the mode to ignore because our package has the PACKAGE_USAGE_STATS permission,
        // and default would allow in this case.
        setAppOpsMode(""ignore"");

        stats = mUsageStatsManager.queryUsageStats(UsageStatsManager.INTERVAL_BEST,
                startTime, endTime);
        assertTrue(stats.isEmpty());
    }

    private void generateAndSendNotification() throws Exception {
        final NotificationManager mNotificationManager =
                (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
        final NotificationChannel mChannel = new NotificationChannel(CHANNEL_ID, ""Channel"",
                NotificationManager.IMPORTANCE_DEFAULT);
        // Configure the notification channel.
        mChannel.setDescription(""Test channel"");
        mNotificationManager.createNotificationChannel(mChannel);
        final Notification.Builder mBuilder =
                new Notification.Builder(mContext, CHANNEL_ID)
                        .setSmallIcon(R.drawable.ic_notification)
                        .setContentTitle(""My notification"")
                        .setContentText(""Hello World!"");
        final PendingIntent pi = PendingIntent.getActivity(mContext, 1,
                new Intent(Settings.ACTION_SETTINGS), PendingIntent.FLAG_IMMUTABLE);
        mBuilder.setContentIntent(pi);
        mNotificationManager.notify(1, mBuilder.build());
        Thread.sleep(500);
    }

    @AppModeFull(r"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.usage.cts.UsageStatsTest"	"testCrossUserQuery_withPermission"	"CtsUsageStatsTestCases"	"1: permission"	"([2:/android/app/usage/cts/UsageStatsTest.java]:[permission]:[2]:method_text:[cleanup done in @After    }    @AppModeFull(reason = ""No usage stats access in instant apps"")   ]) :|: 
    public void testCrossUserQuery_withPermission() throws Exception {
        assumeTrue(UserManager.supportsMultipleUsers());
        final long startTime = System.currentTimeMillis();
        // Create user
        final int userId = createUser(""Test User"");
        startUser(userId, true);
        installExistingPackageAsUser(mContext.getPackageName(), userId);

        // Query as Shell
        SystemUtil.runWithShellPermissionIdentity(() -> {
            final UserHandle otherUser = UserHandle.of(userId);
            final Context userContext = mContext.createContextAsUser(otherUser, 0);

            final UsageStatsManager usmOther = userContext.getSystemService(
                    UsageStatsManager.class);

            waitUntil(() -> {
                final List<UsageStats> stats = usmOther.queryUsageStats(
                        UsageStatsManager.INTERVAL_DAILY, startTime, System.currentTimeMillis());
                return stats.isEmpty();
            }, false);
        });
        // user cleanup done in @After
    }

    @AppModeFull(reason = ""No usage stats access in instant apps"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.usage.cts.UsageStatsTest"	"testCrossUserQuery_withoutPermission"	"CtsUsageStatsTestCases"	"1: permission"	"([3:/android/app/usage/cts/UsageStatsTest.java]:[permission]:[3]:method_text:[t apps    @AppModeFull(reason = ""Test APK Activity not found when installed as an instant app"")   ]) :|: 
    public void testCrossUserQuery_withoutPermission() throws Exception {
        assumeTrue(UserManager.supportsMultipleUsers());
        final long startTime = System.currentTimeMillis();
        // Create user
        final int userId = createUser(""Test User"");
        startUser(userId, true);
        installExistingPackageAsUser(mContext.getPackageName(), userId);

        SystemUtil.runWithShellPermissionIdentity(() -> {
            mOtherUserContext = mContext.createContextAsUser(UserHandle.of(userId), 0);
            mOtherUsageStats = mOtherUserContext.getSystemService(UsageStatsManager.class);
        });

        try {
            mOtherUsageStats.queryUsageStats(UsageStatsManager.INTERVAL_DAILY, startTime,
                    System.currentTimeMillis());
            fail(""Query across users should require INTERACT_ACROSS_USERS permission"");
        } catch (SecurityException se) {
            // Expected
        }

        // user cleanup done in @After
    }

    // TODO(148887416): get this test to work for instant apps
    @AppModeFull(reason = ""Test APK Activity not found when installed as an instant app"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.usage.cts.UsageStatsTest"	"testIsAppInactive"	"CtsUsageStatsTestCases"	"1: permission"	"([8:/android/app/usage/cts/UsageStatsTest.java]:[permission]:[8]:method_text:[t apps    @AppModeFull(reason = ""Test APK Activity not found when installed as an instant app"")   ]) :|: 
    public void testIsAppInactive() throws Exception {
        assumeTrue(""Test only works on devices with a battery"", BatteryUtils.hasBattery());

        setStandByBucket(mTargetPackage, ""rare"");

        try {
            BatteryUtils.runDumpsysBatteryUnplug();

            waitUntil(() -> mUsageStatsManager.isAppInactive(mTargetPackage), true);
            assertFalse(
                    ""App without PACKAGE_USAGE_STATS permission should always receive false for ""
                            + ""isAppInactive"",
                    isAppInactiveAsPermissionlessApp(mTargetPackage));

            launchSubActivity(Activities.ActivityOne.class);

            waitUntil(() -> mUsageStatsManager.isAppInactive(mTargetPackage), false);
            assertFalse(
                    ""App without PACKAGE_USAGE_STATS permission should always receive false for ""
                            + ""isAppInactive"",
                    isAppInactiveAsPermissionlessApp(mTargetPackage));

            mUiDevice.pressHome();
            setStandByBucket(TEST_APP_PKG, ""rare"");
            // Querying for self does not require the PACKAGE_USAGE_STATS
            waitUntil(() -> mUsageStatsManager.isAppInactive(TEST_APP_PKG), true);
            assertTrue(
                    ""App without PACKAGE_USAGE_STATS permission should be able to call ""
                            + ""isAppInactive for itself"",
                    isAppInactiveAsPermissionlessApp(TEST_APP_PKG));

            launchTestActivity(TEST_APP_PKG, TEST_APP_CLASS);

            waitUntil(() -> mUsageStatsManager.isAppInactive(TEST_APP_PKG), false);
            assertFalse(
                    ""App without PACKAGE_USAGE_STATS permission should be able to call ""
                            + ""isAppInactive for itself"",
                    isAppInactiveAsPermissionlessApp(TEST_APP_PKG));

        } finally {
            BatteryUtils.runDumpsysBatteryReset();
        }
    }

    // TODO(148887416): get this test to work for inst"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.usage.cts.UsageStatsTest"	"testObserveUsagePermissionForRegisterObserver"	"CtsUsageStatsTestCases"	"1: permission"	"([4:/android/app/usage/cts/UsageStatsTest.java]:[permission]:[4]:method_text:[n."");        } catch (SecurityException e) {            // Exception expected        }    }   ]) :|: 
    public void testObserveUsagePermissionForRegisterObserver() {
        final int observerId = 0;
        final String[] packages = new String[] {""com.android.settings""};

        try {
            mUsageStatsManager.registerAppUsageObserver(observerId, packages,
                    1, java.util.concurrent.TimeUnit.HOURS, null);
            fail(""Expected SecurityException for an app not holding OBSERVE_APP_USAGE permission."");
        } catch (SecurityException e) {
            // Exception expected
        }

        try {
            mUsageStatsManager.registerUsageSessionObserver(observerId, packages,
                    Duration.ofHours(1), Duration.ofSeconds(10), null, null);
            fail(""Expected SecurityException for an app not holding OBSERVE_APP_USAGE permission."");
        } catch (SecurityException e) {
            // Exception expected
        }

        try {
            mUsageStatsManager.registerAppUsageLimitObserver(observerId, packages,
                    Duration.ofHours(1), Duration.ofHours(0), null);
            fail(""Expected SecurityException for an app not holding OBSERVE_APP_USAGE permission."");
        } catch (SecurityException e) {
            // Exception expected
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.usage.cts.UsageStatsTest"	"testObserveUsagePermissionForUnregisterObserver"	"CtsUsageStatsTestCases"	"1: permission"	"([4:/android/app/usage/cts/UsageStatsTest.java]:[permission]:[4]:method_text:[on expected        }    }    @AppModeFull(reason = ""No usage events access in instant apps"")   ]) :|: 
    public void testObserveUsagePermissionForUnregisterObserver() {
        final int observerId = 0;

        try {
            mUsageStatsManager.unregisterAppUsageObserver(observerId);
            fail(""Expected SecurityException for an app not holding OBSERVE_APP_USAGE permission."");
        } catch (SecurityException e) {
            // Exception expected
        }

        try {
            mUsageStatsManager.unregisterUsageSessionObserver(observerId);
            fail(""Expected SecurityException for an app not holding OBSERVE_APP_USAGE permission."");
        } catch (SecurityException e) {
            // Exception expected
        }

        try {
            mUsageStatsManager.unregisterAppUsageLimitObserver(observerId);
            fail(""Expected SecurityException for an app not holding OBSERVE_APP_USAGE permission."");
        } catch (SecurityException e) {
            // Exception expected
        }
    }

    @AppModeFull(reason = ""No usage events access in instant apps"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.usage.cts.UsageStatsTest"	"testUsageSourceAttribution"	"CtsUsageStatsTestCases"	"1: permission"	"([1:/android/app/usage/cts/UsageStatsTest.java]:[permission]:[1]:method_text:[kage, true, TIMEOUT);    }    @AppModeFull(reason = ""No usage events access in instant apps"")   ]) :|: 
    public void testUsageSourceAttribution() throws Exception {
        mUiDevice.wakeUp();
        dismissKeyguard(); // also want to start out with the keyguard dismissed.
        mUiDevice.pressHome();

        setUsageSourceSetting(Integer.toString(UsageStatsManager.USAGE_SOURCE_CURRENT_ACTIVITY));
        launchSubActivity(TaskRootActivity.class);
        // Usage should be attributed to the test app package
        assertAppOrTokenUsed(TaskRootActivity.TEST_APP_PKG, true, TIMEOUT);

        SystemUtil.runWithShellPermissionIdentity(() -> mAm.forceStopPackage(TEST_APP_PKG));

        setUsageSourceSetting(Integer.toString(UsageStatsManager.USAGE_SOURCE_TASK_ROOT_ACTIVITY));
        launchSubActivity(TaskRootActivity.class);
        // Usage should be attributed to this package
        assertAppOrTokenUsed(mTargetPackage, true, TIMEOUT);
    }

    @AppModeFull(reason = ""No usage events access in instant apps"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.usage.cts.UsageStatsTest"	"testTaskRootAttribution_finishingTaskRoot"	"CtsUsageStatsTestCases"	"1: permission"	"([1:/android/app/usage/cts/UsageStatsTest.java]:[permission]:[1]:method_text:[IMEOUT);        assertAppOrTokenUsed(TEST_APP2_PKG, false, TIMEOUT);    }    @AppModeInstant   ]) :|: 
    public void testTaskRootAttribution_finishingTaskRoot() throws Exception {
        setUsageSourceSetting(Integer.toString(UsageStatsManager.USAGE_SOURCE_TASK_ROOT_ACTIVITY));
        mUiDevice.wakeUp();
        dismissKeyguard(); // also want to start out with the keyguard dismissed.

        launchTestActivity(TEST_APP2_PKG, TEST_APP2_CLASS_FINISHING_TASK_ROOT);
        // Wait until the nested activity gets started
        mUiDevice.wait(Until.hasObject(By.clazz(TEST_APP_PKG, TEST_APP_CLASS)), TIMEOUT);

        // Usage should be attributed to the task root app package
        assertAppOrTokenUsed(TEST_APP_PKG, false, TIMEOUT);
        assertAppOrTokenUsed(TEST_APP2_PKG, true, TIMEOUT);
        SystemUtil.runWithShellPermissionIdentity(() -> mAm.forceStopPackage(TEST_APP_PKG));
        mUiDevice.wait(Until.gone(By.clazz(TEST_APP_PKG, TEST_APP_CLASS)), TIMEOUT);

        // Usage should no longer be tracked
        assertAppOrTokenUsed(TEST_APP_PKG, false, TIMEOUT);
        assertAppOrTokenUsed(TEST_APP2_PKG, false, TIMEOUT);
    }

    @AppModeInstant"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.usage.cts.UsageStatsTest"	"testSuddenDestroy"	"CtsUsageStatsTestCases"	"1: permission"	"([1:/android/app/usage/cts/UsageStatsTest.java]:[permission]:[1]:method_text:[ty stops"", 1, stops);    }    @AppModeFull(reason = ""No usage events access in instant apps"")   ]) :|: 
    public void testSuddenDestroy() throws Exception {
        mUiDevice.wakeUp();
        dismissKeyguard(); // also want to start out with the keyguard dismissed.
        mUiDevice.pressHome();

        final long startTime = System.currentTimeMillis();

        launchTestActivity(TEST_APP_PKG, TEST_APP_CLASS);
        SystemClock.sleep(500);

        // Destroy the activity
        SystemUtil.runWithShellPermissionIdentity(() -> mAm.forceStopPackage(TEST_APP_PKG));
        mUiDevice.wait(Until.gone(By.clazz(TEST_APP_PKG, TEST_APP_CLASS)), TIMEOUT);
        SystemClock.sleep(500);

        final long endTime = System.currentTimeMillis();
        final UsageEvents events = mUsageStatsManager.queryEvents(startTime, endTime);

        int resumes = 0;
        int stops = 0;

        while (events.hasNextEvent()) {
            final UsageEvents.Event event = new UsageEvents.Event();
            assertTrue(events.getNextEvent(event));

            if(TEST_APP_PKG.equals(event.getPackageName())) {
                switch (event.mEventType) {
                    case Event.ACTIVITY_RESUMED:
                        assertNotNull(""ACTIVITY_RESUMED event Task Root should not be null"",
                                event.getTaskRootPackageName());
                        resumes++;
                        break;
                    case Event.ACTIVITY_STOPPED:
                        assertNotNull(""ACTIVITY_STOPPED event Task Root should not be null"",
                                event.getTaskRootPackageName());
                        stops++;
                        break;
                }
            }
        }
        assertEquals(""Unexpected number of activity resumes"", 1, resumes);
        assertEquals(""Unexpected number of activity stops"", 1, stops);
    }

    @AppModeFull(reason = ""No usage events access in instant apps"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.usage.cts.UsageStatsTest"	"testLocusIdEventsVisibility"	"CtsUsageStatsTestCases"	"1: permission"	"([5:/android/app/usage/cts/UsageStatsTest.java]:[permission]:[5]:method_text:[        } catch(Exception e) {                return true;            }        }, false);    }}]) :|: 
    public void testLocusIdEventsVisibility() throws Exception {
        final long startTime = System.currentTimeMillis();
        startAndDestroyActivityWithLocus();
        final long endTime = System.currentTimeMillis();

        final UsageEvents restrictedEvents = mUsageStatsManager.queryEvents(startTime, endTime);
        final UsageEvents allEvents = queryEventsAsShell(startTime, endTime);
        verifyLocusIdEventVisibility(restrictedEvents, false);
        verifyLocusIdEventVisibility(allEvents, true);
    }

    private void startAndDestroyActivityWithLocus() {
        launchTestActivity(TEST_APP_PKG, TEST_APP_CLASS_LOCUS);
        SystemClock.sleep(500);

        // Destroy the activity
        SystemUtil.runWithShellPermissionIdentity(() -> mAm.forceStopPackage(TEST_APP_PKG));
        mUiDevice.wait(Until.gone(By.clazz(TEST_APP_PKG, TEST_APP_CLASS_LOCUS)), TIMEOUT);
        SystemClock.sleep(500);
    }

    private void verifyLocusIdEventVisibility(UsageEvents events, boolean hasPermission) {
        int locuses = 0;
        while (events.hasNextEvent()) {
            final Event event = new UsageEvents.Event();
            assertTrue(events.getNextEvent(event));

            if (TEST_APP_PKG.equals(event.getPackageName())
                    && event.mEventType == Event.LOCUS_ID_SET) {
                locuses++;
            }
        }

        if (hasPermission) {
            assertEquals(""LOCUS_ID_SET events were not visible."", 2, locuses);
        } else {
            assertEquals(""LOCUS_ID_SET events were visible."", 0, locuses);
        }
    }

    /**
     * Assert on an app or token's usage state.
     *
     * @param entity name of the app or token
     * @param expected expected usage state, true for in use, false for not in use
     */
    private void assertAppOrTokenUsed(String entity, boolean expected, long timeout)
            throws IOException {
        final long realtimeTimeout = SystemClock.elapsedRealtime() + timeout;
        Str"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/UsageStatsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.usb.cts.UsbManagerApiTest"	"test_UsbApiSetGetCurrentFunctionsSys"	"CtsUsbManagerTestCases"	"1: permission"	"([5:/android/usb/cts/UsbManagerApiTest.java]:[permission]:[5]:method_text:[n on setCurrentFunctions"");        }    }    /**     * Verify NO SecurityException.     */   ]) :|: 
    public void test_UsbApiSetGetCurrentFunctionsSys() throws Exception {
        // Adopt MANAGE_USB permission.
        mUiAutomation.adoptShellPermissionIdentity(MANAGE_USB);

        // Should pass with permission.
        mUsbManagerSys.setCurrentFunctions(UsbManager.FUNCTION_NONE);
        Assert.assertEquals(""CurrentFunctions mismatched: "", UsbManager.FUNCTION_NONE,
                mUsbManagerSys.getCurrentFunctions());

        // Drop MANAGE_USB permission.
        mUiAutomation.dropShellPermissionIdentity();

        try {
            mUsbManagerSys.getCurrentFunctions();
            Assert.fail(""Expecting SecurityException on getCurrentFunctions."");
        } catch (SecurityException secEx) {
            Log.d(TAG, ""Expected SecurityException on getCurrentFunctions"");
        }

        try {
            mUsbManagerSys.setCurrentFunctions(UsbManager.FUNCTION_NONE);
            Assert.fail(""Expecting SecurityException on setCurrentFunctions."");
        } catch (SecurityException secEx) {
            Log.d(TAG, ""Expected SecurityException on setCurrentFunctions"");
        }
    }

    /**
     * Verify NO SecurityException.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/usb/src/android/usb/cts/UsbManagerApiTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.usb.cts.UsbManagerApiTest"	"test_UsbApiForUsbGadgetHal"	"CtsUsbManagerTestCases"	"1: permission"	"([5:/android/usb/cts/UsbManagerApiTest.java]:[permission]:[5]:method_text:[ on getGadgetHalVersion."");        }    }    /**     * Verify NO SecurityException.     */   ]) :|: 
    public void test_UsbApiForUsbGadgetHal() throws Exception {
        // Adopt MANAGE_USB permission.
        mUiAutomation.adoptShellPermissionIdentity(MANAGE_USB);

        // Should pass with permission.
        int version = mUsbManagerSys.getGadgetHalVersion();
        int usbBandwidth = mUsbManagerSys.getUsbBandwidthMbps();
        if (version > UsbManager.GADGET_HAL_V1_1) {
            Assert.assertTrue(usbBandwidth > UsbManager.USB_DATA_TRANSFER_RATE_UNKNOWN);
        } else {
            Assert.assertEquals(usbBandwidth, UsbManager.USB_DATA_TRANSFER_RATE_UNKNOWN);
        }

        // Drop MANAGE_USB permission.
        mUiAutomation.dropShellPermissionIdentity();

        try {
            mUsbManagerSys.getGadgetHalVersion();
            Assert.fail(""Expecting SecurityException on getGadgetHalVersion."");
        } catch (SecurityException secEx) {
            Log.d(TAG, ""Expected SecurityException on getGadgetHalVersion."");
        }
    }

    /**
     * Verify NO SecurityException.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/usb/src/android/usb/cts/UsbManagerApiTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.usb.cts.UsbManagerApiTest"	"test_UsbApiForUsbHal"	"CtsUsbManagerTestCases"	"1: permission"	"([5:/android/usb/cts/UsbManagerApiTest.java]:[permission]:[5]:method_text:[ecEx) {            Log.d(TAG, ""Expected SecurityException on getUsbHalVersion."");        }    }}]) :|: 
    public void test_UsbApiForUsbHal() throws Exception {
        // Adopt MANAGE_USB permission.
        mUiAutomation.adoptShellPermissionIdentity(MANAGE_USB);

        // Should pass with permission.
        int version = mUsbManagerSys.getUsbHalVersion();
        if (version == USB_HAL_LATEST_VERSION) {
            Log.d(TAG, ""Running with the latest HAL version"");
        } else if (version == UsbManager.USB_HAL_NOT_SUPPORTED) {
            Log.d(TAG, ""Not supported HAL version"");
        }
        else {
            Log.d(TAG, ""Not the latest HAL version"");
        }

        // Drop MANAGE_USB permission.
        mUiAutomation.dropShellPermissionIdentity();

        try {
            mUsbManagerSys.getUsbHalVersion();
            Assert.fail(""Expecting SecurityException on getUsbHalVersion."");
        } catch (SecurityException secEx) {
            Log.d(TAG, ""Expected SecurityException on getUsbHalVersion."");
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/usb/src/android/usb/cts/UsbManagerApiTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.hardware.hdmi.cts.HdmiControlManagerTest"	"testHdmiCecPermissionRequired"	"CtsHardwareTestCases"	"1: permission"	"([2:/android/hardware/hdmi/cts/HdmiControlManagerTest.java]:[permission]:[2]:method_text:[      .dropShellPermissionIdentity();        mHdmiControlManager.getConnectedDevices();    }   ]) :|: (expected = SecurityException.class)
    public void testHdmiCecPermissionRequired() {
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .dropShellPermissionIdentity();

        mHdmiControlManager.getConnectedDevices();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/hardware/src/android/hardware/hdmi/cts/HdmiControlManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.hardware.hdmi.cts.HdmiSwitchClientTest"	"ArrayList"	"CtsHardwareTestCases"	"1: permission"	"([3:/android/hardware/hdmi/cts/HdmiSwitchClientTest.java]:[permission]:[3]:method_text:[sNotNull();    }    @After    public void tearDown() {        mExpectedInfo.clear();    }   ]) :|: /*
 *.
 */

package android.hardware.hdmi.cts;

import static com.google.common.truth.Truth.assertThat;

import android.hardware.hdmi.HdmiControlManager;
import android.hardware.hdmi.HdmiControlServiceWrapper;
import android.hardware.hdmi.HdmiPortInfo;
import android.hardware.hdmi.HdmiSwitchClient;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SmallTest;

import com.android.compatibility.common.util.AdoptShellPermissionsRule;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.ArrayList;
import java.util.List;

@RunWith(AndroidJUnit4.class)
@SmallTest
public class HdmiSwitchClientTest {

    private HdmiControlManager mManager;
    private HdmiSwitchClient mHdmiSwitchClient;
    private HdmiControlServiceWrapper mService;
    private final List<HdmiPortInfo> mExpectedInfo = new ArrayList();

    @Rule
    public final AdoptShellPermissionsRule shellPermRule = new AdoptShellPermissionsRule();

    @Before
    public void setUp() {
        mService = new HdmiControlServiceWrapper();
        int[] types = {HdmiControlServiceWrapper.DEVICE_PURE_CEC_SWITCH};
        mService.setDeviceTypes(types);

        mManager = mService.createHdmiControlManager();
        mHdmiSwitchClient = mManager.getSwitchClient();
        assertThat(mManager).isNotNull();
        assertThat(mHdmiSwitchClient).isNotNull();
    }

    @After
    public void tearDown() {
        mExpectedInfo.clear();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/hardware/src/android/hardware/hdmi/cts/HdmiSwitchClientTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.hardware.lights.cts.LightsManagerTest"	"dropShellPermissionIdentity"	"CtsHardwareTestCases"	"1: permission"	"([3:/android/hardware/lights/cts/LightsManagerTest.java]:[permission]:[3]:method_text:[ry.getInstrumentation().getUiAutomation()                .dropShellPermissionIdentity();    }   ]) :|: /*
 *.
 */

package android.hardware.lights.cts.tests;

import static android.hardware.lights.LightsRequest.Builder;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import android.content.Context;
import android.hardware.lights.Light;
import android.hardware.lights.LightState;
import android.hardware.lights.LightsManager;

import androidx.test.InstrumentationRegistry;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SmallTest;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;

@RunWith(AndroidJUnit4.class)
@SmallTest
public class LightsManagerTest {

    private static final int ON_TAN = 0xffd2b48c;
    private static final int ON_RED = 0xffff0000;
    private static final LightState STATE_TAN = new LightState(ON_TAN);
    private static final LightState STATE_RED = new LightState(ON_RED);
    private static final int HIGH_PRIORITY = Integer.MAX_VALUE;

    private LightsManager mManager;
    private List<Light> mLights;

    @Before
    public void setUp() {
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(
                        android.Manifest.permission.CONTROL_DEVICE_LIGHTS);

        final Context context = InstrumentationRegistry.getTargetContext();
        mManager = context.getSystemService(LightsManager.class);
        mLights = mManager.getLights();
    }

    @After
    public void tearDown() {
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .dropShellPermissionIdentity();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/hardware/src/android/hardware/lights/cts/LightsManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.hardware.lights.cts.LightsManagerTest"	"testControlLightsPermissionIsRequiredToUseLights"	"CtsHardwareTestCases"	"1: permission"	"([2:/android/hardware/lights/cts/LightsManagerTest.java]:[permission]:[2]:method_text:[o be thrown for openSession()"");        } catch (SecurityException expected) {        }    }   ]) :|: 
    public void testControlLightsPermissionIsRequiredToUseLights() {
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .dropShellPermissionIdentity();
        try {
            mManager.getLights();
            fail(""Expected SecurityException to be thrown for getLights()"");
        } catch (SecurityException expected) {
        }

        try (LightsManager.LightsSession session = mManager.openSession()) {
            fail(""Expected SecurityException to be thrown for openSession()"");
        } catch (SecurityException expected) {
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/hardware/src/android/hardware/lights/cts/LightsManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.hardware.input.cts.tests.UsbVoiceCommandTest"	"UsbVoiceCommandTest"	"CtsHardwareTestCases"	"1: permission"	"([2:/android/hardware/input/cts/tests/UsbVoiceCommandTest.java]:[permission]:[2]:method_text:[      setPackageState(true);        mExcludedPackages.clear();        super.tearDown();    }   ]) :|: /*
 *.
 */

package android.hardware.input.cts.tests;

import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;

import static org.junit.Assume.assumeFalse;

import android.app.UiAutomation;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.content.res.Resources;
import android.hardware.cts.R;
import android.hardware.input.cts.InputAssistantActivity;
import android.server.wm.WindowManagerStateHelper;
import android.speech.RecognizerIntent;
import android.support.test.uiautomator.UiDevice;

import androidx.test.InstrumentationRegistry;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SmallTest;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.ArrayList;
import java.util.List;

@SmallTest
@RunWith(AndroidJUnit4.class)
public class UsbVoiceCommandTest extends InputHidTestCase {
    private static final String TAG = ""UsbVoiceCommandTest"";

    private final UiDevice mUiDevice =
            UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
    private final UiAutomation mUiAutomation =
            InstrumentationRegistry.getInstrumentation().getUiAutomation();
    private final PackageManager mPackageManager =
            InstrumentationRegistry.getInstrumentation().getContext().getPackageManager();
    private final Context mContext = InstrumentationRegistry.getInstrumentation().getContext();
    private final Intent mVoiceIntent;
    private final Intent mWebIntent;
    private final List<String> mExcludedPackages = new ArrayList<String>();

    // Simulates the behavior of Google Gamepad with Voice Command buttons.
    public UsbVoiceCommandTest() {
        super(R.raw.google_gamepad_usb_register);
        mVoiceIntent = new Intent(RecognizerIntent.ACTION_VOICE_"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/UsbVoiceCommandTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony5.cts.TelephonyManagerReadNonDangerousPermissionTest"	"testReadNonDangerousPermission"	""	"1: permission"	"([1:/android/telephony5/cts/TelephonyManagerReadNonDangerousPermissionTest.java]:[permission]:[1]:method_text:[ityException e) {            fail(""should not fail with READ_BASIC_PHONE_STATE"");        }    }}]) :|: 
    public void testReadNonDangerousPermission() throws Exception {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }

        try {
            if (mTelephonyManager.getDataNetworkType() == TelephonyManager.NETWORK_TYPE_UNKNOWN
                || mTelephonyManager.getVoiceNetworkType()
                    == TelephonyManager.NETWORK_TYPE_UNKNOWN) {
                fail(""should not fail with READ_BASIC_PHONE_STATE"");
            }
            mTelephonyManager.isDataEnabled();
            mTelephonyManager.isDataRoamingEnabled();
            mTelephonyManager.isDataEnabledForReason(TelephonyManager.DATA_ENABLED_REASON_POLICY);
            mTelephonyManager.isDataConnectionAllowed();

        } catch (SecurityException e) {
            fail(""should not fail with READ_BASIC_PHONE_STATE"");
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony5/src/android/telephony5/cts/TelephonyManagerReadNonDangerousPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony2.cts.TelephonyManagerNoPermissionTest"	"testGetCallState_redirectToTelecom"	"CtsTelephony2TestCases"	"1: permission"	"([2:/android/telephony2/cts/TelephonyManagerNoPermissionTest.java]:[permission]:[2]:method_text:[ is enabled."");        } catch (SecurityException e) {            // expected        }    }   ]) :|: 
    public void testGetCallState_redirectToTelecom() throws Exception {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }

        TelephonyUtils.enableCompatCommand(InstrumentationRegistry.getInstrumentation(),
                TelephonyUtils.CTS_APP_PACKAGE2,
                TelephonyUtils.ENABLE_GET_CALL_STATE_PERMISSION_PROTECTION_STRING);
        try {
            mTelephonyManager.getCallState();
            fail(""TelephonyManager#getCallState must require READ_PHONE_STATE if ""
                    + ""TelecomManager#ENABLE_GET_CALL_STATE_PERMISSION_PROTECTION is enabled."");
        } catch (SecurityException e) {
            // expected
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony2/src/android/telephony2/cts/TelephonyManagerNoPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony2.cts.TelephonyManagerNoPermissionTest"	"testGetCallStateForSubscription"	"CtsTelephony2TestCases"	"1: permission"	"([2:/android/telephony2/cts/TelephonyManagerNoPermissionTest.java]:[permission]:[2]:method_text:[    + ""enabled."");        } catch (SecurityException e) {            // expected        }    }}]) :|: 
    public void testGetCallStateForSubscription() throws Exception {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            return;
        }

        TelephonyUtils.enableCompatCommand(InstrumentationRegistry.getInstrumentation(),
                TelephonyUtils.CTS_APP_PACKAGE2,
                TelephonyUtils.ENABLE_GET_CALL_STATE_PERMISSION_PROTECTION_STRING);
        try {
            mTelephonyManager.getCallStateForSubscription();
            fail(""TelephonyManager#getCallStateForSubscription must require READ_PHONE_STATE ""
                    + ""if TelecomManager#ENABLE_GET_CALL_STATE_PERMISSION_PROTECTION is ""
                    + ""enabled."");
        } catch (SecurityException e) {
            // expected
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony2/src/android/telephony2/cts/TelephonyManagerNoPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony2.cts.CallStateListenerPermissionTest"	"testRegisterWithNoCallLogPermission"	"CtsTelephony2TestCases"	"1: permission"	"([2:/android/telephony2/cts/CallStateListenerPermissionTest.java]:[permission]:[2]:method_text:[);    }    /**     * Test Call State listener requires READ_PHONE_STATE for API 31+.     */   ]) :|: 
    public void testRegisterWithNoCallLogPermission() {
        if (!mContext.getPackageManager().hasSystemFeature(FEATURE_TELEPHONY)) {
            return;
        }

        TelephonyManager telephonyManager = mContext.getSystemService(TelephonyManager.class);
        assertNotNull(telephonyManager);

        MyTelephonyCallback callback = new MyTelephonyCallback();
        runWithShellPermissionIdentity(
                () -> telephonyManager.registerTelephonyCallback(mSimpleExecutor, callback));


        try {
            mCallStateReceivedLatch.await(10000, TimeUnit.MILLISECONDS);
        } catch (InterruptedException e) {
            fail(""Expected to receive call state callback"");
        }

        assertTrue(mReceivedCallback);
    }

    /**
     * Test Call State listener requires READ_PHONE_STATE for API 31+.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony2/src/android/telephony2/cts/CallStateListenerPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony2.cts.CallStateListenerPermissionTest"	"testCallStatePermission"	"CtsTelephony2TestCases"	"1: permission"	"([5:/android/telephony2/cts/CallStateListenerPermissionTest.java]:[permission]:[5]:method_text:[               TelephonyUtils.ENABLE_GET_CALL_STATE_PERMISSION_PROTECTION_STRING);        }    }}]) :|: 
    public void testCallStatePermission() throws Exception {
        if (!mContext.getPackageManager().hasSystemFeature(FEATURE_TELEPHONY)) {
            return;
        }

        TelephonyManager telephonyManager = mContext.getSystemService(TelephonyManager.class);
        assertNotNull(telephonyManager);
        MyTelephonyCallback callback = new MyTelephonyCallback();

        try {
            TelephonyUtils.enableCompatCommand(InstrumentationRegistry.getInstrumentation(),
                    TelephonyUtils.CTS_APP_PACKAGE2,
                    TelephonyUtils.ENABLE_GET_CALL_STATE_PERMISSION_PROTECTION_STRING);
            try {
                telephonyManager.registerTelephonyCallback(mSimpleExecutor, callback);
                fail(""TelephonyCallback.CallStateListener must require READ_PHONE_STATE when ""
                        + ""TelecomManager#ENABLE_GET_CALL_STATE_PERMISSION_PROTECTION is enabled."");
            } catch (SecurityException e) {
                // Expected
            }
            try {
                telephonyManager.listen(new PhoneStateListener(Runnable::run),
                        PhoneStateListener.LISTEN_CALL_STATE);
                fail(""PhoneStateListener#onCallStateChanged must require READ_PHONE_STATE when ""
                        + ""TelecomManager#ENABLE_GET_CALL_STATE_PERMISSION_PROTECTION is enabled."");
            } catch (SecurityException e) {
                // Expected
            }
        } finally {
            TelephonyUtils.resetCompatCommand(InstrumentationRegistry.getInstrumentation(),
                    TelephonyUtils.CTS_APP_PACKAGE2,
                    TelephonyUtils.ENABLE_GET_CALL_STATE_PERMISSION_PROTECTION_STRING);
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony2/src/android/telephony2/cts/CallStateListenerPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.provider.cts.BlockedNumberContractTest"	"testProviderInteractionsAsRegularApp_fails"	"CtsProviderTestCases"	"1: permission"	"([3:/android/provider/cts/BlockedNumberContractTest.java]:[permission]:[3]:method_text:[       }        assertTrue(BlockedNumberContract.canCurrentUserBlockNumbers(mContext));    }   ]) :|: public void testProviderInteractionsAsRegularApp_fails() {
        if (!mIsSystemUser) {
            Log.i(TAG, ""skipping BlockedNumberContractTest"");
            return;
        }
        TelephonyManager telephonyManager = mContext.getSystemService(TelephonyManager.class);
        try {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                    .adoptShellPermissionIdentity(
                            ""android.permission.READ_PRIVILEGED_PHONE_STATE"");
            // Don't run this test if we're carrier privileged.
            if (telephonyManager.checkCarrierPrivilegesForPackage(mContext.getPackageName())
                            == TelephonyManager.CARRIER_PRIVILEGE_STATUS_HAS_ACCESS) {
                    return;
            }
        } catch (SecurityException e) {
            fail(""TelephonyManager#checkCarrierPrivilegesForPackage requires ""
                    + "" READ_PRIVILEGED_PHONE_STATE"");
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                    .dropShellPermissionIdentity();
        }

        try {
            mAddedUris.add(mContentResolver.insert(
                    BlockedNumbers.CONTENT_URI, getContentValues(""1234567890"")));
            fail(""Should throw SecurityException"");
        } catch (SecurityException expected) {
        }

        try {
            mContentResolver.query(BlockedNumbers.CONTENT_URI, null, null, null, null);
            fail(""Should throw SecurityException"");
        } catch (SecurityException expected) {
        }

        try {
            mContentResolver.update(
                    BlockedNumbers.CONTENT_URI, getContentValues(""123""), null, null);
            fail(""Should throw SecurityException"");
        } catch (SecurityException expected) {
        }

        try {
            BlockedNumberContract.isBlocked(mContext, ""123"");
            fail(""Should throw SecurityException"");
        } catch (SecurityException expecte"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/BlockedNumberContractTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.provider.cts.settings.SettingsTest"	"testCheckWriteSettingsOperation"	"CtsProviderTestCases"	"1: permission"	"([3:/android/provider/cts/settings/SettingsTest.java]:[permission]:[3]:method_text:[   private Context getContext() {        return InstrumentationRegistry.getTargetContext();    }}]) :|: 
    public void testCheckWriteSettingsOperation() throws Exception {
        final int myUid = Binder.getCallingUid();
        final String callingPackage = InstrumentationRegistry.getTargetContext().getPackageName();
        // Verify write settings permission.
        Settings.checkAndNoteWriteSettingsOperation(getContext(), myUid, callingPackage,
                true /* throwException */);

        // Verify SecurityException throw if uid do not match callingPackage.
        final int otherUid = myUid + 1;
        try {
            Settings.checkAndNoteWriteSettingsOperation(getContext(), otherUid, callingPackage,
                    true /* throwException */);
            fail(""Expect SecurityException because uid "" + otherUid + "" do not belong to ""
                    + callingPackage);
        } catch (SecurityException se) { }

        // Verify SecurityException throw if calling package do not have WRITE_SETTINGS permission.
        try {
            final String fakeCallingPackage = ""android.provider.cts.fakepackagename"";
            Settings.checkAndNoteWriteSettingsOperation(getContext(), myUid, fakeCallingPackage,
                    true /* throwException */);
            fail(""Expect throwing SecurityException due to no WRITE_SETTINGS permission"");
        } catch (SecurityException se) { }

    }

    private Instrumentation getInstrumentation() {
        return InstrumentationRegistry.getInstrumentation();
    }

    private Context getContext() {
        return InstrumentationRegistry.getTargetContext();
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/settings/SettingsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.provider.cts.settings.Settings_NameValueTableTest"	"AdoptShellPermissionsRule"	"CtsProviderTestCases"	"1: permission"	"([3:/android/provider/cts/settings/Settings_NameValueTableTest.java]:[permission]:[3]:method_text:[    @Rule    public AdoptShellPermissionsRule shellPermRule = new AdoptShellPermissionsRule();   ]) :|: /*
 *.
 */

package android.provider.cts.settings;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;

import android.content.ContentResolver;
import android.database.Cursor;
import android.net.Uri;
import android.provider.Settings;
import android.provider.Settings.NameValueTable;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.AdoptShellPermissionsRule;

import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(AndroidJUnit4.class)
public class Settings_NameValueTableTest {

    @Rule
    public AdoptShellPermissionsRule shellPermRule = new AdoptShellPermissionsRule();"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/settings/Settings_NameValueTableTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.provider.cts.contacts.CallLogTest"	"testLocationStorageAndRetrieval"	"CtsProviderTestCases"	"1: permission"	"([5:/android/provider/cts/contacts/CallLogTest.java]:[permission]:[5]:method_text:[{            ShellUtils.runShellCommand(""telecom set-default-dialer default"");        }    }   ]) :|: public void testLocationStorageAndRetrieval() {
        Context context = getInstrumentation().getContext();

        if (!context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            // This is tied to default-dialer, so don't test if the device doesn't have telephony.
            return;
        }

        UserHandle currentUser = UserHandle.of(
                ShellIdentityUtils.invokeStaticMethodWithShellPermissions(
                        () -> ActivityManager.getCurrentUser()));
        CallLog.AddCallParams.AddCallParametersBuilder builder =
                new CallLog.AddCallParams.AddCallParametersBuilder();
        builder.setAddForAllUsers(false);
        builder.setUserToBeInsertedTo(currentUser);
        // Some random spot in the North Atlantic
        double lat = 24.877323;
        double lon = -68.952545;
        builder.setLatitude(lat);
        builder.setLongitude(lon);
        ShellUtils.runShellCommand(""telecom set-default-dialer %s"",
                getInstrumentation().getContext().getPackageName());

        try {
            Uri uri;
            getInstrumentation().getUiAutomation()
                    .adoptShellPermissionIdentity(Manifest.permission.INTERACT_ACROSS_USERS,
                            Manifest.permission.READ_VOICEMAIL);
            try {
                uri = CallLog.Calls.addCall(context, builder.build());
            } finally {
                getInstrumentation().getUiAutomation().dropShellPermissionIdentity();
            }
            assertNotNull(uri);

            Cursor cursor = context.getContentResolver().query(
                    uri, new String[]{CallLog.Calls.LOCATION}, null, null);
            assertEquals(1, cursor.getCount());
            cursor.moveToFirst();
            String locationUriString = cursor.getString(
                    cursor.getColumnIndex(CallLog.Calls.LOCATION));
            assertNotNull(locationUriString);

            Uri locationUri = Uri.parse(l"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/contacts/CallLogTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.provider.cts.contacts.VoicemailContractTest"	"testForeignUpdate_dirty"	"CtsProviderTestCases"	"1: permission"	"([1:/android/provider/cts/contacts/VoicemailContractTest.java]:[permission]:[1]:method_text:[           cursor.moveToFirst();            assertEquals(1, cursor.getInt(0));        }    }   ]) :|: public void testForeignUpdate_dirty() throws Exception {
        if (!hasTelephony(getInstrumentation().getContext())) {
            Log.d(TAG, ""skipping test that requires telephony feature"");
            return;
        }
        // only the default dialer has WRITE_VOICEMAIL permission, which can modify voicemails of
        // a foreign source package.
        setTestAsDefaultDialer();
        ContentValues values = new ContentValues();
        values.put(Voicemails.SOURCE_PACKAGE, FOREIGN_SOURCE);

        Uri uri = mVoicemailProvider.insert(Voicemails.buildSourceUri(FOREIGN_SOURCE), values);

        ContentValues updateValues = new ContentValues();
        updateValues.put(Voicemails.IS_READ, ""1"");
        mVoicemailProvider.update(uri, updateValues, null, null);

        try (Cursor cursor = mVoicemailProvider
                .query(uri, new String[] {Voicemails.DIRTY}, null, null, null)) {
            cursor.moveToFirst();
            assertEquals(1, cursor.getInt(0));
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/contacts/VoicemailContractTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.provider.cts.contacts.VoicemailContractTest"	"testForeignUpdate_retainDirty_notDirty"	"CtsProviderTestCases"	"1: permission"	"([1:/android/provider/cts/contacts/VoicemailContractTest.java]:[permission]:[1]:method_text:[           cursor.moveToFirst();            assertEquals(0, cursor.getInt(0));        }    }   ]) :|: public void testForeignUpdate_retainDirty_notDirty() throws Exception {
        if (!hasTelephony(getInstrumentation().getContext())) {
            Log.d(TAG, ""skipping test that requires telephony feature"");
            return;
        }
        // only the default dialer has WRITE_VOICEMAIL permission, which can modify voicemails of
        // a foreign source package.
        setTestAsDefaultDialer();
        ContentValues values = new ContentValues();
        values.put(Voicemails.SOURCE_PACKAGE, FOREIGN_SOURCE);

        Uri uri = mVoicemailProvider.insert(Voicemails.buildSourceUri(FOREIGN_SOURCE), values);

        ContentValues newValues = new ContentValues();
        newValues.put(Voicemails.TRANSCRIPTION, ""foo"");
        newValues.put(Voicemails.DIRTY, Voicemails.DIRTY_RETAIN);

        mVoicemailProvider.update(uri, newValues, null, null);

        try (Cursor cursor = mVoicemailProvider
                .query(uri, new String[] {Voicemails.DIRTY}, null, null, null)) {
            cursor.moveToFirst();
            assertEquals(0, cursor.getInt(0));
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/contacts/VoicemailContractTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.provider.cts.contacts.VoicemailContractTest"	"testVoicemailTablePermissions"	"CtsProviderTestCases"	"1: permission"	"([1:/android/provider/cts/contacts/VoicemailContractTest.java]:[permission]:[1]:method_text:[own."");        } catch (SecurityException e) {            // Expected result.        }    }   ]) :|: public void testVoicemailTablePermissions() throws Exception {
        ContentValues value = new ContentValues();
        value.put(Voicemails.NUMBER, ""0123456789"");
        value.put(Voicemails.SOURCE_PACKAGE, ""some.other.package"");
        try {
            mVoicemailProvider.insert(mVoicemailContentUri, value);
            fail(""Expected SecurityException. None thrown."");
        } catch (SecurityException e) {
            // Expected result.
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/contacts/VoicemailContractTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.provider.cts.contacts.VoicemailContractTest"	"testStatusTablePermissions"	"CtsProviderTestCases"	"1: permission"	"([1:/android/provider/cts/contacts/VoicemailContractTest.java]:[permission]:[1]:method_text:[           } catch (Exception ignored) {                // Quietly.            }        }    }}]) :|: public void testStatusTablePermissions() throws Exception {
        ContentValues value = new ContentValues();
        value.put(Status.CONFIGURATION_STATE, Status.CONFIGURATION_STATE_OK);
        value.put(Status.SOURCE_PACKAGE, ""some.other.package"");
        try {
            mStatusProvider.insert(mStatusContentUri, value);
            fail(""Expected SecurityException. None thrown."");
        } catch (SecurityException e) {
            // Expected result.
        }
    }

    private static boolean hasTelephony(Context context) {
        final PackageManager packageManager = context.getPackageManager();
        return packageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY) &&
                packageManager.hasSystemFeature(PackageManager.FEATURE_CONNECTION_SERVICE);
    }

    private void setTestAsDefaultDialer() throws Exception {
        assertTrue(mPreviousDefaultDialer == null);
        mPreviousDefaultDialer = getDefaultDialer(getInstrumentation());
        setDefaultDialer(getInstrumentation(), PACKAGE);
    }

    private static String setDefaultDialer(Instrumentation instrumentation, String packageName)
            throws Exception {
        return executeShellCommand(instrumentation, COMMAND_SET_DEFAULT_DIALER + packageName);
    }

    private static String getDefaultDialer(Instrumentation instrumentation) throws Exception {
        return executeShellCommand(instrumentation, COMMAND_GET_DEFAULT_DIALER);
    }

    /**
     * Executes the given shell command and returns the output in a string. Note that even if we
     * don't care about the output, we have to read the stream completely to make the command
     * execute.
     */
    private static String executeShellCommand(Instrumentation instrumentation,
            String command) throws Exception {
        final ParcelFileDescriptor parcelFileDescriptor =
                instrumentation.getUiAutomation().executeShellCommand(command);
        BufferedReader bufferedReader = null;"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/contacts/VoicemailContractTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.provider.cts.media.MediaStoreTest"	"dropShellPermissionIdentity"	"CtsProviderTestCases"	"1: permission"	"([1:/android/provider/cts/media/MediaStoreTest.java]:[permission]:[1]:method_text:[dentity();    }    /**     * Sure this is pointless, but czars demand test coverage.     */   ]) :|: /*
 *.
 */

package android.provider.cts.media;

import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import android.Manifest;
import android.app.AppOpsManager;
import android.content.ContentResolver;
import android.content.Context;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.ProviderInfo;
import android.database.Cursor;
import android.net.Uri;
import android.os.Build;
import android.os.Process;
import android.os.storage.StorageManager;
import android.os.storage.StorageVolume;
import android.provider.BaseColumns;
import android.provider.MediaStore;
import android.provider.MediaStore.MediaColumns;
import android.provider.cts.ProviderTestUtils;
import android.provider.cts.R;
import android.util.Log;

import androidx.annotation.NonNull;
import androidx.test.InstrumentationRegistry;
import androidx.test.filters.SdkSuppress;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameter;
import org.junit.runners.Parameterized.Parameters;

import java.util.Set;

@SdkSuppress(minSdkVersion = Build.VERSION_CODES.R)
@RunWith(Parameterized.class)
public class MediaStoreTest {
    static final String TAG = ""MediaStoreTest"";

    private static final long SIZE_DELTA = 32_000;
    private static final String[] SYSTEM_GALERY_APPOPS = {
            AppOpsManager.OPSTR_WRITE_MEDIA_IMAGES, AppOpsManager.OPSTR_WRITE_MEDIA_VIDEO};

    private Context mContext;
    private ContentResolver mContentResolver;

    private Uri mExternalImages;

    @Parameter(0)
    public String mVolumeName;"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/media/MediaStoreTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.provider.cts.media.MediaStoreTest"	"testLegacy"	"CtsProviderTestCases"	"1: permission"	"([4:/android/provider/cts/media/MediaStoreTest.java]:[permission]:[4]:method_text:[ess legacy MediaProvider must have no services"",                legacyPackage.services);    }   ]) :|: 
    public void testLegacy() throws Exception {
        final ProviderInfo legacy = getContext().getPackageManager()
                .resolveContentProvider(MediaStore.AUTHORITY_LEGACY, 0);
        if (legacy == null) {
            if (Build.VERSION.DEVICE_INITIAL_SDK_INT >= Build.VERSION_CODES.R) {
                // If we're a brand new device, we don't require a legacy
                // provider, since there's nothing to upgrade
                return;
            } else {
                fail(""Upgrading devices must have a legacy MediaProvider at ""
                        + ""MediaStore.AUTHORITY_LEGACY to upgrade user data from"");
            }
        }

        // Verify that legacy provider is protected
        assertEquals(""Legacy provider at MediaStore.AUTHORITY_LEGACY must protect its data"",
                android.Manifest.permission.WRITE_MEDIA_STORAGE, legacy.readPermission);
        assertEquals(""Legacy provider at MediaStore.AUTHORITY_LEGACY must protect its data"",
                android.Manifest.permission.WRITE_MEDIA_STORAGE, legacy.writePermission);

        // And finally verify that legacy provider is headless
        final PackageInfo legacyPackage = getContext().getPackageManager().getPackageInfo(
                legacy.packageName, PackageManager.GET_ACTIVITIES | PackageManager.GET_PROVIDERS
                        | PackageManager.GET_RECEIVERS | PackageManager.GET_SERVICES);
        assertEmpty(""Headless legacy MediaProvider must have no activities"",
                legacyPackage.activities);
        assertEquals(""Headless legacy MediaProvider must have exactly one provider"",
                1, legacyPackage.providers.length);
        assertEmpty(""Headless legacy MediaProvider must have no receivers"",
                legacyPackage.receivers);
        assertEmpty(""Headless legacy MediaProvider must have no services"",
                legacyPackage.services);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/media/MediaStoreTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.provider.cts.media.MediaStoreTest"	"testCanManageMedia"	"CtsProviderTestCases"	"1: permission"	"([4:/android/provider/cts/media/MediaStoreTest.java]:[permission]:[4]:method_text:[ray) {        if (array != null && array.length > 0) {            fail(message);        }    }}]) :|: 
    @SdkSuppress(minSdkVersion = 31, codeName = ""S"")
    public void testCanManageMedia() throws Exception {
        final String opString = AppOpsManager.permissionToOp(Manifest.permission.MANAGE_MEDIA);

        // no access
        assertThat(MediaStore.canManageMedia(getContext())).isFalse();
        try {
            // grant access
            setAppOpsModeForUid(Process.myUid(), AppOpsManager.MODE_ALLOWED, opString);

            assertThat(MediaStore.canManageMedia(getContext())).isTrue();
        } finally {
            setAppOpsModeForUid(Process.myUid(), AppOpsManager.MODE_ERRORED, opString);
        }
        // no access
        assertThat(MediaStore.canManageMedia(getContext())).isFalse();
    }

    private void setAppOpsModeForUid(int uid, int mode, @NonNull String... ops) {
        getInstrumentation().getUiAutomation().adoptShellPermissionIdentity(null);
        try {
            for (String op : ops) {
                getContext().getSystemService(AppOpsManager.class).setUidMode(op, uid, mode);
            }
        } finally {
            getInstrumentation().getUiAutomation().dropShellPermissionIdentity();
        }
    }

    private static <T> void assertEmpty(String message, T[] array) {
        if (array != null && array.length > 0) {
            fail(message);
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/media/MediaStoreTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.provider.cts.media.MediaStore_Images_MediaTest"	"testLocationRedaction"	"CtsProviderTestCases"	"1: permission"	"([2:/android/provider/cts/media/MediaStore_Images_MediaTest.java]:[permission]:[2]:method_text:[SS_MEDIA_LOCATION"");        } catch (UnsupportedOperationException expected) {        }    }   ]) :|: 
    public void testLocationRedaction() throws Exception {
        final Uri publishUri = ProviderTestUtils.stageMedia(R.raw.lg_g4_iso_800_jpg, mExternalImages,
                ""image/jpeg"");
        final Uri originalUri = MediaStore.setRequireOriginal(publishUri);

        // Since we own the image, we should be able to see the Exif data that
        // we ourselves contributed
        try (InputStream is = mContentResolver.openInputStream(publishUri)) {
            final ExifInterface exif = new ExifInterface(is);
            final float[] latLong = new float[2];
            exif.getLatLong(latLong);
            assertEquals(53.83451, latLong[0], 0.001);
            assertEquals(10.69585, latLong[1], 0.001);

            String xmp = exif.getAttribute(ExifInterface.TAG_XMP);
            assertTrue(""Failed to read XMP longitude"", xmp.contains(""53,50.070500N""));
            assertTrue(""Failed to read XMP latitude"", xmp.contains(""10,41.751000E""));
            assertTrue(""Failed to read non-location XMP"", xmp.contains(""LensDefaults""));
        }
        // As owner, we should be able to request the original bytes
        try (ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(originalUri, ""r"")) {
        }

        // Revoke location access and remove ownership, which means that location should be redacted
        ProviderTestUtils.revokeMediaLocationPermission(mContext);
        ProviderTestUtils.clearOwner(publishUri);
        try (InputStream is = mContentResolver.openInputStream(publishUri)) {
            final ExifInterface exif = new ExifInterface(is);
            final float[] latLong = new float[2];
            exif.getLatLong(latLong);
            assertEquals(0, latLong[0], 0.001);
            assertEquals(0, latLong[1], 0.001);

            String xmp = exif.getAttribute(ExifInterface.TAG_XMP);
            assertFalse(""Failed to redact XMP longitude"", xmp.contains(""53,50.070500N""));
            assertFalse(""Failed to redact XMP latitude"", xmp."	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/media/MediaStore_Images_MediaTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.provider.cts.media.MediaStore_Video_MediaTest"	"testOriginalAccess"	"CtsProviderTestCases"	"1: permission"	"([2:/android/provider/cts/media/MediaStore_Video_MediaTest.java]:[permission]:[2]:method_text:[SS_MEDIA_LOCATION"");        } catch (UnsupportedOperationException expected) {        }    }   ]) :|: 
    public void testOriginalAccess() throws Exception {
        final Uri publishUri = ProviderTestUtils.stageMedia(R.raw.testvideo_meta, mExternalVideo,
                ""video/mp4"");
        final Uri originalUri = MediaStore.setRequireOriginal(publishUri);

        // As owner, we should be able to request the original bytes
        try (ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(originalUri, ""r"")) {
        }

        // Revoke location access and remove ownership, which means that location should be redacted
        ProviderTestUtils.revokeMediaLocationPermission(mContext);
        ProviderTestUtils.clearOwner(publishUri);

        // We can't request original bytes unless we have permission
        try (ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(originalUri, ""r"")) {
            fail(""Able to read original content without ACCESS_MEDIA_LOCATION"");
        } catch (UnsupportedOperationException expected) {
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/media/MediaStore_Video_MediaTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.provider.cts.media.MediaStore_Video_MediaTest"	"testXmpLocationRedaction"	"CtsProviderTestCases"	"1: permission"	"([1:/android/provider/cts/media/MediaStore_Video_MediaTest.java]:[permission]:[1]:method_text:[           assertTrue(""Redacted non-location XMP"", xmp.contains(""13166/7763""));        }    }   ]) :|: 
    public void testXmpLocationRedaction() throws Exception {
        final Uri publishUri = ProviderTestUtils.stageMedia(R.raw.testvideo_meta, mExternalVideo,
                ""video/mp4"");

        try (InputStream in = mContentResolver.openInputStream(publishUri);
                ByteArrayOutputStream out = new ByteArrayOutputStream()) {
            FileUtils.copy(in, out);
            byte[] bytes = out.toByteArray();
            byte[] xmpBytes = Arrays.copyOfRange(bytes, 3269, 3269 + 13197);
            String xmp = new String(xmpBytes);
            assertTrue(""Failed to read XMP longitude"", xmp.contains(""10,41.751000E""));
            assertTrue(""Failed to read XMP latitude"", xmp.contains(""53,50.070500N""));
            assertTrue(""Failed to read non-location XMP"", xmp.contains(""13166/7763""));
        }

        // Revoke location access and remove ownership, which means that location should be redacted
        ProviderTestUtils.revokeMediaLocationPermission(mContext);
        ProviderTestUtils.clearOwner(publishUri);

        try (InputStream in = mContentResolver.openInputStream(publishUri);
                ByteArrayOutputStream out = new ByteArrayOutputStream()) {
            FileUtils.copy(in, out);
            byte[] bytes = out.toByteArray();
            byte[] xmpBytes = Arrays.copyOfRange(bytes, 3269, 3269 + 13197);
            String xmp = new String(xmpBytes);
            assertFalse(""Failed to redact XMP longitude"", xmp.contains(""10,41.751000E""));
            assertFalse(""Failed to redact XMP latitude"", xmp.contains(""53,50.070500N""));
            assertTrue(""Redacted non-location XMP"", xmp.contains(""13166/7763""));
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/media/MediaStore_Video_MediaTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.provider.cts.media.MediaStore_Video_MediaTest"	"testIsoLocationRedaction"	"CtsProviderTestCases"	"1: permission"	"([1:/android/provider/cts/media/MediaStore_Video_MediaTest.java]:[permission]:[1]:method_text:[extractMetadata(MediaMetadataRetriever.METADATA_KEY_NUM_TRACKS));            }        }    }   ]) :|: 
    @AsbSecurityTest(cveBugId = 134155286)
    public void testIsoLocationRedaction() throws Exception {
        // These videos have all had their ISO location metadata (in the (c)xyz box) artificially
        // modified to +58.0000+011.0000 (middle of Skagerrak).
        int[] videoIds = new int[] {
            R.raw.testvideo_meta,
            R.raw.moov_at_end,
            R.raw.moov_at_end_zero_len,
        };
        Uri[] uris = new Uri[videoIds.length];
        for (int i = 0; i < videoIds.length; i++) {
            uris[i] = ProviderTestUtils.stageMedia(videoIds[i], mExternalVideo, ""video/mp4"");
        }

        for (int i = 0; i < uris.length; i++) {
            // Since we own the video, we should be able to see the location
            // we ourselves contributed
            try (ParcelFileDescriptor pfd = mContentResolver.openFile(uris[i], ""r"", null);
                    MediaMetadataRetriever mmr = new MediaMetadataRetriever()) {
                mmr.setDataSource(pfd.getFileDescriptor());
                assertEquals(""+58.0000+011.0000/"",
                        mmr.extractMetadata(MediaMetadataRetriever.METADATA_KEY_LOCATION));
                assertEquals(""2"",
                    mmr.extractMetadata(MediaMetadataRetriever.METADATA_KEY_NUM_TRACKS));
            }
        }

        // Revoke location access and remove ownership, which means that location should be redacted
        ProviderTestUtils.revokeMediaLocationPermission(mContext);

        for (int i = 0; i < uris.length; i++) {
            ProviderTestUtils.clearOwner(uris[i]);

            try (ParcelFileDescriptor pfd = mContentResolver.openFile(uris[i], ""r"", null);
                    MediaMetadataRetriever mmr = new MediaMetadataRetriever()) {
                mmr.setDataSource(pfd.getFileDescriptor());
                assertEquals(null,
                        mmr.extractMetadata(MediaMetadataRetriever.METADATA_KEY_LOCATION));
                assertEquals(""2"",
                    mmr."	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/media/MediaStore_Video_MediaTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest22.kt"	"BaseUsePermissionTest"	"CtsPermission3TestCases"	"1: permission"	"([7:/android/permission3/cts/PermissionTest22.kt]:[permission]:[7]:method_text:[yControlled())        installPackage(APP_APK_PATH_22)        approvePermissionReview()    }   ]) :|: /*
 *.
 */

package android.permission3.cts

import org.junit.Assume
import org.junit.Before
import org.junit.Test

/**
 * Runtime permission behavior tests for apps targeting API 22.
 */
class PermissionTest22 : BaseUsePermissionTest() {

    @Before
    fun installApp22AndApprovePermissionReview() {
        Assume.assumeFalse(packageManager.arePermissionsIndividuallyControlled())

        installPackage(APP_APK_PATH_22)
        approvePermissionReview()
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest22.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest22.kt"	"testCompatDefault"	"CtsPermission3TestCases"	"1: permission"	"([5:/android/permission3/cts/PermissionTest22.kt]:[permission]:[5]:method_text:[ndroid.Manifest.permission.WRITE_CALENDAR, true)        assertAppHasCalendarAccess(true)    }   ]) :|: 
    fun testCompatDefault() {
        // Legacy permission model appears granted
        assertAppHasPermission(android.Manifest.permission.READ_CALENDAR, true)
        assertAppHasPermission(android.Manifest.permission.WRITE_CALENDAR, true)
        assertAppHasCalendarAccess(true)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest22.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest22.kt"	"testCompatRevoked"	"CtsPermission3TestCases"	"1: permission"	"([8:/android/permission3/cts/PermissionTest22.kt]:[permission]:[8]:method_text:[        // Read/write access should be ignored        assertAppHasCalendarAccess(false)    }   ]) :|: 
    fun testCompatRevoked() {
        // Revoke the permission
        revokeAppPermissions(android.Manifest.permission.WRITE_CALENDAR, isLegacyApp = true)

        // Legacy permission model appears granted
        assertAppHasPermission(android.Manifest.permission.READ_CALENDAR, true)
        assertAppHasPermission(android.Manifest.permission.WRITE_CALENDAR, true)
        // Read/write access should be ignored
        assertAppHasCalendarAccess(false)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest22.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest22.kt"	"testNoRuntimePrompt"	"CtsPermission3TestCases"	"1: permission"	"([4:/android/permission3/cts/PermissionTest22.kt]:[permission]:[4]:method_text:[Result(            arrayOf(android.Manifest.permission.SEND_SMS), emptyArray()        ) {}    }}]) :|: 
    fun testNoRuntimePrompt() {
        // Request the permission and do nothing
        // Expect the permission is not granted
        requestAppPermissionsAndAssertResult(
            arrayOf(android.Manifest.permission.SEND_SMS), emptyArray()
        ) {}
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest22.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.NoPermissionTest.kt"	"BaseUsePermissionTest"	"CtsPermission3TestCases"	"1: permission"	"([3:/android/permission3/cts/NoPermissionTest.kt]:[permission]:[3]:method_text:[unner.RunWith@RunWith(AndroidJUnit4::class)class NoPermissionTest : BaseUsePermissionTest() {   ]) :|: /*
 *.
 */

package android.permission3.cts

import android.app.Activity
import androidx.test.runner.AndroidJUnit4
import org.junit.Test
import org.junit.runner.RunWith

@RunWith(AndroidJUnit4::class)
class NoPermissionTest : BaseUsePermissionTest() {"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/NoPermissionTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionUpgradeTest.kt"	"BaseUsePermissionTest"	"CtsPermission3TestCases"	"1: permission"	"([4:/android/permission3/cts/PermissionUpgradeTest.kt]:[permission]:[4]:method_text:[ behavior tests for upgrading apps. */class PermissionUpgradeTest : BaseUsePermissionTest() {   ]) :|: /*
 *.
 */

package android.permission3.cts

import org.junit.Assume
import org.junit.Test

/**
 * Runtime permission behavior tests for upgrading apps.
 */
class PermissionUpgradeTest : BaseUsePermissionTest() {"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionUpgradeTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionUpgradeTest.kt"	"testUpgradeKeepsPermissions"	"CtsPermission3TestCases"	"1: permission"	"([33:/android/permission3/cts/PermissionUpgradeTest.kt]:[permission]:[33]:method_text:[fun assertAllPermissionsGrantedOnUpgrade() {        assertAppHasAllOrNoPermissions(true)    }   ]) :|: 
    fun testUpgradeKeepsPermissions() {
        Assume.assumeFalse(packageManager.arePermissionsIndividuallyControlled())

        installPackage(APP_APK_PATH_22)

        approvePermissionReview()

        assertAllPermissionsGrantedByDefault()

        installPackage(APP_APK_PATH_23, reinstall = true)

        assertAllPermissionsGrantedOnUpgrade()
    }

    private fun assertAllPermissionsGrantedByDefault() {
        arrayOf(
            android.Manifest.permission.SEND_SMS,
            android.Manifest.permission.RECEIVE_SMS,
            // The APK does not request READ_CONTACTS because of other tests
            android.Manifest.permission.WRITE_CONTACTS,
            android.Manifest.permission.READ_CALENDAR,
            android.Manifest.permission.WRITE_CALENDAR,
            android.Manifest.permission.READ_SMS,
            android.Manifest.permission.RECEIVE_WAP_PUSH,
            android.Manifest.permission.RECEIVE_MMS,
            ""android.permission.READ_CELL_BROADCASTS"",
            android.Manifest.permission.READ_EXTERNAL_STORAGE,
            android.Manifest.permission.WRITE_EXTERNAL_STORAGE,
            android.Manifest.permission.ACCESS_FINE_LOCATION,
            android.Manifest.permission.ACCESS_COARSE_LOCATION,
            android.Manifest.permission.READ_PHONE_STATE,
            android.Manifest.permission.CALL_PHONE,
            android.Manifest.permission.READ_CALL_LOG,
            android.Manifest.permission.WRITE_CALL_LOG,
            android.Manifest.permission.ADD_VOICEMAIL,
            android.Manifest.permission.USE_SIP,
            android.Manifest.permission.PROCESS_OUTGOING_CALLS,
            android.Manifest.permission.CAMERA,
            android.Manifest.permission.BODY_SENSORS,
            // Split permissions
            android.Manifest.permission.ACCESS_BACKGROUND_LOCATION
        ).forEach {
            assertAppHasPermission(it, true)
        }
    }

    private fun assertAllPermissionsGrantedOnUpgrade() {
        assertAppHa"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionUpgradeTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionUpgradeTest.kt"	"testNoDowngradePermissionModel"	"CtsPermission3TestCases"	"1: permission"	"([1:/android/permission3/cts/PermissionUpgradeTest.kt]:[permission]:[1]:method_text:[PATH_23)        installPackage(APP_APK_PATH_22, reinstall = true, expectSuccess = false)    }   ]) :|: 
    fun testNoDowngradePermissionModel() {
        installPackage(APP_APK_PATH_23)
        installPackage(APP_APK_PATH_22, reinstall = true, expectSuccess = false)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionUpgradeTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionUpgradeTest.kt"	"testRevokePropagatedOnUpgradeOldToNewModel"	"CtsPermission3TestCases"	"1: permission"	"([7:/android/permission3/cts/PermissionUpgradeTest.kt]:[permission]:[7]:method_text:[ true)        assertAppHasPermission(android.Manifest.permission.WRITE_CALENDAR, false)    }   ]) :|: 
    fun testRevokePropagatedOnUpgradeOldToNewModel() {
        Assume.assumeFalse(packageManager.arePermissionsIndividuallyControlled())

        installPackage(APP_APK_PATH_22)

        approvePermissionReview()

        // Revoke a permission
        revokeAppPermissions(android.Manifest.permission.WRITE_CALENDAR, isLegacyApp = true)

        installPackage(APP_APK_PATH_23, reinstall = true)

        assertAppHasPermission(android.Manifest.permission.WRITE_CALENDAR, false)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionUpgradeTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionUpgradeTest.kt"	"testRevokePropagatedOnUpgradeNewToNewModel"	"CtsPermission3TestCases"	"1: permission"	"([46:/android/permission3/cts/PermissionUpgradeTest.kt]:[permission]:[46]:method_text:[RAGE        ).forEach {            assertAppHasPermission(it, expectPermissions)        }    }}]) :|: 
    fun testRevokePropagatedOnUpgradeNewToNewModel() {
        installPackage(APP_APK_PATH_23)

        // Make sure we don't have the permission
        assertAppHasPermission(android.Manifest.permission.READ_CALENDAR, false)
        assertAppHasPermission(android.Manifest.permission.READ_EXTERNAL_STORAGE, false)

        // Request the permission and allow it
        // Make sure the permission is granted
        requestAppPermissionsAndAssertResult(android.Manifest.permission.READ_CALENDAR to true) {
            clickPermissionRequestAllowButton()
        }

        installPackage(APP_APK_PATH_23, reinstall = true)

        // Make sure the permission is still granted after the upgrade
        assertAppHasPermission(android.Manifest.permission.READ_CALENDAR, true)
        // Also make sure one of the not granted permissions is still not granted
        assertAppHasPermission(android.Manifest.permission.READ_EXTERNAL_STORAGE, false)
    }

    private fun assertAppHasAllOrNoPermissions(expectPermissions: Boolean) {
        arrayOf(
            android.Manifest.permission.SEND_SMS,
            android.Manifest.permission.RECEIVE_SMS,
            android.Manifest.permission.RECEIVE_WAP_PUSH,
            android.Manifest.permission.RECEIVE_MMS,
            android.Manifest.permission.READ_CALENDAR,
            android.Manifest.permission.WRITE_CALENDAR,
            android.Manifest.permission.WRITE_CONTACTS,
            android.Manifest.permission.READ_SMS,
            android.Manifest.permission.READ_PHONE_STATE,
            android.Manifest.permission.READ_CALL_LOG,
            android.Manifest.permission.WRITE_CALL_LOG,
            android.Manifest.permission.ADD_VOICEMAIL,
            android.Manifest.permission.CALL_PHONE,
            android.Manifest.permission.USE_SIP,
            android.Manifest.permission.PROCESS_OUTGOING_CALLS,
            android.Manifest.permission.RECORD_AUDIO,
            android.Manifest.permission.ACCESS_FINE_LOCATION,
            a"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionUpgradeTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionPolicyTest25.kt"	"BasePermissionTest"	"CtsPermission3TestCases"	"1: permission"	"([7:/android/permission3/cts/PermissionPolicyTest25.kt]:[permission]:[7]:method_text:[  fun uninstallApp() {        uninstallPackage(APP_PACKAGE_NAME, requireSuccess = false)    }   ]) :|: /*
 *.
 */

package android.permission3.cts

import android.app.Activity
import android.content.ComponentName
import android.content.Intent
import org.junit.After
import org.junit.Assert.assertEquals
import org.junit.Before
import org.junit.Test
import java.util.concurrent.TimeUnit

/**
 * Tests for the platform permission policy around apps targeting API 25.
 */
class PermissionPolicyTest25 : BasePermissionTest() {
    companion object {
        const val APP_APK_PATH_25 = ""$APK_DIRECTORY/CtsPermissionPolicyApp25.apk""
        const val APP_PACKAGE_NAME = ""android.permission3.cts.permissionpolicy""
    }

    @Before
    fun installApp25() {
        uninstallPackage(APP_PACKAGE_NAME, requireSuccess = false)
        installPackage(APP_APK_PATH_25)
    }

    @After
    fun uninstallApp() {
        uninstallPackage(APP_PACKAGE_NAME, requireSuccess = false)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionPolicyTest25.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionPolicyTest25.kt"	"testNoProtectionFlagsAddedToNonSignatureProtectionPermissions"	"CtsPermission3TestCases"	"1: permission"	"([1:/android/permission3/cts/PermissionPolicyTest25.kt]:[permission]:[1]:method_text:[     assertEquals("""", result.resultData!!.getStringExtra(""$APP_PACKAGE_NAME.ERROR_MESSAGE""))    }}]) :|: 
    fun testNoProtectionFlagsAddedToNonSignatureProtectionPermissions() {
        val future = startActivityForFuture(
            Intent().apply {
                component = ComponentName(
                    APP_PACKAGE_NAME, ""$APP_PACKAGE_NAME.TestProtectionFlagsActivity""
                )
            }
        )
        val result = future.get(TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)
        assertEquals(Activity.RESULT_OK, result.resultCode)
        assertEquals("""", result.resultData!!.getStringExtra(""$APP_PACKAGE_NAME.ERROR_MESSAGE""))
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionPolicyTest25.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionReviewTest.kt"	"BaseUsePermissionTest"	"CtsPermission3TestCases"	"1: permission"	"([4:/android/permission3/cts/PermissionReviewTest.kt]:[permission]:[4]:method_text:[   fun installApp22CalendarOnly() {        installPackage(APP_APK_PATH_22_CALENDAR_ONLY)    }   ]) :|: /*
 *.
 */

package android.permission3.cts

import android.app.Activity
import android.content.ComponentName
import android.content.Intent
import android.content.pm.PackageManager
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.os.ResultReceiver
import android.support.test.uiautomator.By
import androidx.test.runner.AndroidJUnit4
import org.junit.Assert.assertEquals
import org.junit.Assert.assertNull
import org.junit.Assume
import org.junit.Before
import org.junit.Test
import org.junit.runner.RunWith
import java.util.concurrent.LinkedBlockingQueue
import java.util.concurrent.TimeUnit

@RunWith(AndroidJUnit4::class)
class PermissionReviewTest : BaseUsePermissionTest() {

    @Before
    fun assumeNotIndividuallyControlled() {
        Assume.assumeFalse(packageManager.arePermissionsIndividuallyControlled())
    }

    @Before
    fun installApp22CalendarOnly() {
        installPackage(APP_APK_PATH_22_CALENDAR_ONLY)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionReviewTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionReviewTest.kt"	"testDenyCalendarDuringReview"	"CtsPermission3TestCases"	"1: permission"	"([1:/android/permission3/cts/PermissionReviewTest.kt]:[permission]:[1]:method_text:[ue()        }        clearTargetSdkWarning()        assertAppHasCalendarAccess(false)    }   ]) :|: 
    fun testDenyCalendarDuringReview() {
        startAppActivityAndAssertResultCode(Activity.RESULT_OK) {
            // Deny
            click(By.text(""Calendar""))
            // Confirm deny
            click(By.res(""android:id/button1""))

            clickPermissionReviewContinue()
        }

        clearTargetSdkWarning()
        assertAppHasCalendarAccess(false)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionReviewTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionReviewTest.kt"	"testDenyGrantCalendarDuringReview"	"CtsPermission3TestCases"	"1: permission"	"([1:/android/permission3/cts/PermissionReviewTest.kt]:[permission]:[1]:method_text:[nue()        }        clearTargetSdkWarning()        assertAppHasCalendarAccess(true)    }   ]) :|: 
    fun testDenyGrantCalendarDuringReview() {
        startAppActivityAndAssertResultCode(Activity.RESULT_OK) {
            // Deny
            click(By.text(""Calendar""))
            // Confirm deny
            click(By.res(""android:id/button1""))

            // Grant
            click(By.text(""Calendar""))

            clickPermissionReviewContinue()
        }

        clearTargetSdkWarning()
        assertAppHasCalendarAccess(true)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionReviewTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionReviewTest.kt"	"testDenyGrantDenyCalendarDuringReview"	"CtsPermission3TestCases"	"1: permission"	"([1:/android/permission3/cts/PermissionReviewTest.kt]:[permission]:[1]:method_text:[ue()        }        clearTargetSdkWarning()        assertAppHasCalendarAccess(false)    }   ]) :|: 
    fun testDenyGrantDenyCalendarDuringReview() {
        startAppActivityAndAssertResultCode(Activity.RESULT_OK) {
            // Deny
            click(By.text(""Calendar""))
            // Confirm deny
            click(By.res(""android:id/button1""))

            // Grant
            click(By.text(""Calendar""))

            // Deny
            click(By.text(""Calendar""))

            clickPermissionReviewContinue()
        }

        clearTargetSdkWarning()
        assertAppHasCalendarAccess(false)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionReviewTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionReviewTest.kt"	"testCancelReview"	"CtsPermission3TestCases"	"1: permission"	"([3:/android/permission3/cts/PermissionReviewTest.kt]:[permission]:[3]:method_text:[ review        approvePermissionReview()        assertAppDoesNotNeedPermissionReview()    }   ]) :|: 
    fun testCancelReview() {
        // Start APK_22_ONLY_CALENDAR, but cancel review
        cancelPermissionReview()

        // Start APK_22_ONLY_CALENDAR again, now approve review
        approvePermissionReview()

        assertAppDoesNotNeedPermissionReview()
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionReviewTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionReviewTest.kt"	"testReviewPermissionWhenServiceIsBound"	"CtsPermission3TestCases"	"1: permission"	"([8:/android/permission3/cts/PermissionReviewTest.kt]:[permission]:[8]:method_text:[ageManager.PERMISSION_GRANTED, results.poll(TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)        )    }}]) :|: 
    fun testReviewPermissionWhenServiceIsBound() {
        val results = LinkedBlockingQueue<Int>()
        // We are starting a activity instead of the service directly, because
        // the service comes from a different app than the CTS tests.
        // This app will be considered idle on devices that have idling enabled (automotive),
        // and the service wouldn't be allowed to be started without the activity.
        activityRule.launchActivity(null).startActivity(
            Intent().apply {
                component = ComponentName(
                    APP_PACKAGE_NAME, ""$APP_PACKAGE_NAME.StartCheckPermissionServiceActivity""
                )
                putExtra(
                    ""$APP_PACKAGE_NAME.RESULT"",
                    object : ResultReceiver(Handler(Looper.getMainLooper())) {
                        override fun onReceiveResult(resultCode: Int, resultData: Bundle?) {
                            results.offer(resultCode)
                        }
                    }
                )
                putExtra(
                    ""$APP_PACKAGE_NAME.PERMISSION"", android.Manifest.permission.READ_CALENDAR
                )
            }
        )

        // Service is not started before permission are reviewed
        assertNull(results.poll(UNEXPECTED_TIMEOUT_MILLIS.toLong(), TimeUnit.MILLISECONDS))

        clickPermissionReviewContinue()

        // Service should be started after permission review
        assertEquals(
            PackageManager.PERMISSION_GRANTED, results.poll(TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)
        )
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionReviewTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest30WithBluetooth.kt"	"BaseUsePermissionTest"	"CtsPermission3TestCases"	"1: permission"	"([15:/android/permission3/cts/PermissionTest30WithBluetooth.kt]:[permission]:[15]:method_text:[ertTrue(BTAdapterUtils.disableAdapter(bluetoothAdapter, context))            }        }    }   ]) :|: /*
 *.
 */

package android.permission3.cts

import android.Manifest.permission.ACCESS_BACKGROUND_LOCATION
import android.Manifest.permission.ACCESS_FINE_LOCATION
import android.Manifest.permission.BLUETOOTH_SCAN
import android.app.AppOpsManager
import android.bluetooth.BluetoothAdapter
import android.bluetooth.BluetoothManager
import android.bluetooth.cts.BTAdapterUtils
import android.content.Intent
import android.content.pm.PackageManager
import android.content.pm.PackageManager.FLAG_PERMISSION_REVOKED_COMPAT
import android.os.Build
import android.os.Process
import androidx.test.InstrumentationRegistry
import androidx.test.filters.SdkSuppress
import com.android.compatibility.common.util.SystemUtil.runShellCommandOrThrow
import com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity
import junit.framework.Assert.assertEquals
import junit.framework.Assert.assertTrue
import junit.framework.AssertionFailedError
import org.junit.After
import org.junit.Assert.assertNotEquals
import org.junit.Assume.assumeTrue
import org.junit.Before
import org.junit.Test

/**
 * Runtime Bluetooth-permission behavior of apps targeting API 30
 */
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.S, codeName = ""S"")
class PermissionTest30WithBluetooth : BaseUsePermissionTest() {

    private val TEST_APP_AUTHORITY =
        ""android.permission3.cts.usepermission.AccessBluetoothOnCommand""
    private val TEST_APP_PKG =
        ""android.permission3.cts.usepermission""
    private lateinit var bluetoothAdapter: BluetoothAdapter
    private var bluetoothAdapterWasEnabled: Boolean = false

    private enum class BluetoothScanResult {
        UNKNOWN, ERROR, EXCEPTION, EMPTY, FILTERED, FULL
    }

    @Before
    fun installApp() {
        installPackage(APP_APK_PATH_30_WITH_BLUETOOTH)
    }

    private fun reinstallApp() {
        installPackage(APP_APK_PATH_30_WITH_BLUETOOTH, reinstall = true)
    }

    @Before
    fun enableBluetooth() {
        assumeTrue(supportsBluet"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest30WithBluetooth.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest30WithBluetooth.kt"	"testGivenBluetoothIsDeniedWhenScanIsAttemptedThenThenGetEmptyScanResult"	"CtsPermission3TestCases"	"1: permission"	"([4:/android/permission3/cts/PermissionTest30WithBluetooth.kt]:[permission]:[4]:method_text:[      throw AssertionFailedError(""Expected to be EMPTY or ERROR, but was $res"")        }    }   ]) :|: 
    fun testGivenBluetoothIsDeniedWhenScanIsAttemptedThenThenGetEmptyScanResult() {
        assertBluetoothRevokedCompatState(revoked = false)
        // Should return empty while the app does not have location
        assertEquals(BluetoothScanResult.EMPTY, scanForBluetoothDevices())

        uiAutomation.grantRuntimePermission(TEST_APP_PKG, ACCESS_FINE_LOCATION)
        uiAutomation.grantRuntimePermission(TEST_APP_PKG, ACCESS_BACKGROUND_LOCATION)
        runWithShellPermissionIdentity {
            context.getSystemService(AppOpsManager::class.java)!!.setUidMode(
                AppOpsManager.OPSTR_FINE_LOCATION,
                packageManager.getPackageUid(context.packageName, 0), AppOpsManager.MODE_ALLOWED)
        }

        assertEquals(BluetoothScanResult.FULL, scanForBluetoothDevices())
        revokeAppPermissions(BLUETOOTH_SCAN, isLegacyApp = true)
        assertBluetoothRevokedCompatState(revoked = true)
        val res = scanForBluetoothDevices()
        if (res != BluetoothScanResult.ERROR && res != BluetoothScanResult.EMPTY) {
            throw AssertionFailedError(""Expected to be EMPTY or ERROR, but was $res"")
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest30WithBluetooth.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest30WithBluetooth.kt"	"testRevokedCompatPersistsOnReinstall"	"CtsPermission3TestCases"	"1: permission"	"([4:/android/permission3/cts/PermissionTest30WithBluetooth.kt]:[permission]:[4]:method_text:[vity service"" +        "" com.android.bluetooth/.btservice.AdapterService set-test-mode disabled"")}]) :|: 
    fun testRevokedCompatPersistsOnReinstall() {
        assertBluetoothRevokedCompatState(revoked = false)
        revokeAppPermissions(BLUETOOTH_SCAN, isLegacyApp = true)
        assertBluetoothRevokedCompatState(revoked = true)
        reinstallApp()
        assertBluetoothRevokedCompatState(revoked = true)
        installApp()
        assertBluetoothRevokedCompatState(revoked = true)
    }

    private fun assertBluetoothRevokedCompatState(revoked: Boolean = true) {
        runWithShellPermissionIdentity {
            val flag = context.packageManager.getPermissionFlags(BLUETOOTH_SCAN,
                TEST_APP_PKG, Process.myUserHandle()) and FLAG_PERMISSION_REVOKED_COMPAT
            if (revoked) {
                assertNotEquals(0, flag)
            } else {
                assertEquals(0, flag)
            }
        }
    }
    private fun scanForBluetoothDevices(): BluetoothScanResult {
        val resolver = InstrumentationRegistry.getTargetContext().getContentResolver()
        val result = resolver.call(TEST_APP_AUTHORITY, """", null, null)
        return BluetoothScanResult.values()[result!!.getInt(Intent.EXTRA_INDEX)]
    }

    private fun supportsBluetooth(): Boolean =
        context.packageManager.hasSystemFeature(PackageManager.FEATURE_BLUETOOTH)

    private fun enableTestMode() = runShellCommandOrThrow(""dumpsys activity service"" +
        "" com.android.bluetooth/.btservice.AdapterService set-test-mode enabled"")

    private fun disableTestMode() = runShellCommandOrThrow(""dumpsys activity service"" +
        "" com.android.bluetooth/.btservice.AdapterService set-test-mode disabled"")
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest30WithBluetooth.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionHistoryTest.kt"	"BasePermissionTest"	"CtsPermission3TestCases"	"1: permission"	"([11:/android/permission3/cts/PermissionHistoryTest.kt]:[permission]:[11]:method_text:[quireSuccess = false)        uninstallPackage(APP2_PACKAGE_NAME, requireSuccess = false)    }   ]) :|: /*
 *.
 */

package android.permission3.cts

import android.Manifest
import android.content.Intent
import android.os.Build
import android.support.test.uiautomator.By
import androidx.test.filters.SdkSuppress
import com.android.compatibility.common.util.SystemUtil
import org.junit.After
import org.junit.Before
import org.junit.Ignore
import org.junit.Test

private const val APP_LABEL_1 = ""CtsMicAccess""
private const val APP_LABEL_2 = ""CtsMicAccess2""
private const val INTENT_ACTION_1 = ""test.action.USE_MIC""
private const val INTENT_ACTION_2 = ""test.action.USE_MIC_2""
private const val PERMISSION_CONTROLLER_PACKAGE_ID_PREFIX = ""com.android.permissioncontroller:id/""
private const val HISTORY_PREFERENCE_ICON = ""permission_history_icon""
private const val HISTORY_PREFERENCE_TIME = ""permission_history_time""
private const val SHOW_SYSTEM = ""Show system""
private const val MORE_OPTIONS = ""More options""

@SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)
class PermissionHistoryTest : BasePermissionTest() {
    private val micLabel = packageManager.getPermissionGroupInfo(
            Manifest.permission_group.MICROPHONE, 0).loadLabel(packageManager).toString()

    @Before
    fun installApps() {
        uninstallPackage(APP_PACKAGE_NAME, requireSuccess = false)
        uninstallPackage(APP2_PACKAGE_NAME, requireSuccess = false)
        installPackage(APP_APK_PATH, grantRuntimePermissions = true)
        installPackage(APP2_APK_PATH, grantRuntimePermissions = true)
    }

    @After
    fun uninstallApps() {
        uninstallPackage(APP_PACKAGE_NAME, requireSuccess = false)
        uninstallPackage(APP2_PACKAGE_NAME, requireSuccess = false)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionHistoryTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionHistoryTest.kt"	"testMicrophoneTimelineWithOneApp"	"CtsPermission3TestCases"	"1: permission"	"([2:/android/permission3/cts/PermissionHistoryTest.kt]:[permission]:[2]:method_text:[ROLLER_PACKAGE_ID_PREFIX + HISTORY_PREFERENCE_TIME))    }    @Ignore(""b/186656826#comment27"")   ]) :|: 
    fun testMicrophoneTimelineWithOneApp() {
        openMicrophoneApp(INTENT_ACTION_1)
        waitFindObject(By.textContains(APP_LABEL_1))

        openMicrophoneTimeline()
        waitFindObject(By.descContains(micLabel))
        waitFindObject(By.textContains(APP_LABEL_1))
        waitFindObject(By.res(
                PERMISSION_CONTROLLER_PACKAGE_ID_PREFIX + HISTORY_PREFERENCE_ICON))
        waitFindObject(By.res(
                PERMISSION_CONTROLLER_PACKAGE_ID_PREFIX + HISTORY_PREFERENCE_TIME))
    }

    @Ignore(""b/186656826#comment27"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionHistoryTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionHistoryTest.kt"	"testCameraTimelineWithMultipleApps"	"CtsPermission3TestCases"	"1: permission"	"([6:/android/permission3/cts/PermissionHistoryTest.kt]:[permission]:[6]:method_text:[p2.apk""        const val APP2_PACKAGE_NAME = ""android.permission3.cts.accessmicrophoneapp2""    }}]) :|: 
    fun testCameraTimelineWithMultipleApps() {
        openMicrophoneApp(INTENT_ACTION_1)
        waitFindObject(By.textContains(APP_LABEL_1))

        openMicrophoneApp(INTENT_ACTION_2)
        waitFindObject(By.textContains(APP_LABEL_2))

        openMicrophoneTimeline()
        waitFindObject(By.descContains(micLabel))
        waitFindObject(By.textContains(APP_LABEL_1))
        waitFindObject(By.textContains(APP_LABEL_2))
    }

    private fun openMicrophoneApp(intentAction: String) {
        context.startActivity(Intent(intentAction).apply {
            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        })
    }

    private fun openMicrophoneTimeline() {
        SystemUtil.runWithShellPermissionIdentity {
            context.startActivity(Intent(Intent.ACTION_REVIEW_PERMISSION_HISTORY).apply {
                putExtra(Intent.EXTRA_PERMISSION_GROUP_NAME, Manifest.permission_group.MICROPHONE)
                addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            })
        }
    }

    companion object {
        const val APP_APK_PATH = ""$APK_DIRECTORY/CtsAccessMicrophoneApp.apk""
        const val APP_PACKAGE_NAME = ""android.permission3.cts.accessmicrophoneapp""
        const val APP2_APK_PATH = ""$APK_DIRECTORY/CtsAccessMicrophoneApp2.apk""
        const val APP2_PACKAGE_NAME = ""android.permission3.cts.accessmicrophoneapp2""
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionHistoryTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest23.kt"	"BaseUsePermissionTest"	"CtsPermission3TestCases"	"1: permission"	"([7:/android/permission3/cts/PermissionTest23.kt]:[permission]:[7]:method_text:[name""    }    @Before    fun installApp23() {        installPackage(APP_APK_PATH_23)    }   ]) :|: /*
 *.
 */

package android.permission3.cts

import androidx.test.filters.FlakyTest
import com.android.modules.utils.build.SdkLevel
import org.junit.Assume
import org.junit.Before
import org.junit.Test

/**
 * Runtime permission behavior tests for apps targeting API 23.
 */
class PermissionTest23 : BaseUsePermissionTest() {
    companion object {
        private const val NON_EXISTENT_PERMISSION = ""permission.does.not.exist""
        private const val INVALID_PERMISSION = ""$APP_PACKAGE_NAME.abadname""
    }

    @Before
    fun installApp23() {
        installPackage(APP_APK_PATH_23)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest23.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest23.kt"	"testDefault"	"CtsPermission3TestCases"	"1: permission"	"([2:/android/permission3/cts/PermissionTest23.kt]:[permission]:[2]:method_text:[/ New permission model is denied by default        assertAppHasAllOrNoPermissions(false)    }   ]) :|: 
    fun testDefault() {
        // New permission model is denied by default
        assertAppHasAllOrNoPermissions(false)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest23.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest23.kt"	"testGranted"	"CtsPermission3TestCases"	"1: permission"	"([6:/android/permission3/cts/PermissionTest23.kt]:[permission]:[6]:method_text:[ndroid.Manifest.permission.WRITE_CALENDAR, true)        assertAppHasCalendarAccess(true)    }   ]) :|: 
    fun testGranted() {
        grantAppPermissions(android.Manifest.permission.READ_CALENDAR)

        // Read/write access should be allowed
        assertAppHasPermission(android.Manifest.permission.READ_CALENDAR, true)
        assertAppHasPermission(android.Manifest.permission.WRITE_CALENDAR, true)
        assertAppHasCalendarAccess(true)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest23.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest23.kt"	"testInteractiveGrant"	"CtsPermission3TestCases"	"1: permission"	"([10:/android/permission3/cts/PermissionTest23.kt]:[permission]:[10]:method_text:[    }        // We should have permission now!        assertAppHasCalendarAccess(true)    }   ]) :|: 
    fun testInteractiveGrant() {
        // Start out without permission
        assertAppHasPermission(android.Manifest.permission.READ_CALENDAR, false)
        assertAppHasPermission(android.Manifest.permission.WRITE_CALENDAR, false)
        assertAppHasCalendarAccess(false)

        // Go through normal grant flow
        requestAppPermissionsAndAssertResult(
            android.Manifest.permission.READ_CALENDAR to true,
            android.Manifest.permission.WRITE_CALENDAR to true
        ) {
            clickPermissionRequestAllowButton()
        }

        // We should have permission now!
        assertAppHasCalendarAccess(true)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest23.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest23.kt"	"testRuntimeGroupGrantSpecificity"	"CtsPermission3TestCases"	"1: permission"	"([14:/android/permission3/cts/PermissionTest23.kt]:[permission]:[14]:method_text:[ granted        assertAppHasPermission(android.Manifest.permission.READ_CONTACTS, false)    }   ]) :|: 
    fun testRuntimeGroupGrantSpecificity() {
        // Start out without permission
        assertAppHasPermission(android.Manifest.permission.READ_CONTACTS, false)
        assertAppHasPermission(android.Manifest.permission.WRITE_CONTACTS, false)

        // Request only one permission from the 'contacts' permission group
        // Expect the permission is granted
        requestAppPermissionsAndAssertResult(android.Manifest.permission.WRITE_CONTACTS to true) {
            clickPermissionRequestAllowButton()
        }

        // Make sure no undeclared as used permissions are granted
        assertAppHasPermission(android.Manifest.permission.READ_CONTACTS, false)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest23.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest23.kt"	"testCancelledPermissionRequest"	"CtsPermission3TestCases"	"1: permission"	"([9:/android/permission3/cts/PermissionTest23.kt]:[permission]:[9]:method_text:[ssion.WRITE_CONTACTS to false) {            clickPermissionRequestDenyButton()        }    }   ]) :|: 
    fun testCancelledPermissionRequest() {
        // Make sure we don't have the permission
        assertAppHasPermission(android.Manifest.permission.WRITE_CONTACTS, false)

        // Request the permission and cancel the request
        // Expect the permission is not granted
        requestAppPermissionsAndAssertResult(android.Manifest.permission.WRITE_CONTACTS to false) {
            clickPermissionRequestDenyButton()
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest23.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest23.kt"	"testRequestGrantedPermission"	"CtsPermission3TestCases"	"1: permission"	"([13:/android/permission3/cts/PermissionTest23.kt]:[permission]:[13]:method_text:[questAppPermissionsAndAssertResult(android.Manifest.permission.WRITE_CONTACTS to true) {}    }   ]) :|: 
    fun testRequestGrantedPermission() {
        // Make sure we don't have the permission
        assertAppHasPermission(android.Manifest.permission.WRITE_CONTACTS, false)

        // Request the permission and allow it
        // Expect the permission is granted
        requestAppPermissionsAndAssertResult(android.Manifest.permission.WRITE_CONTACTS to true) {
            clickPermissionRequestAllowButton()
        }

        // Request the permission and do nothing
        // Expect the permission is granted
        requestAppPermissionsAndAssertResult(android.Manifest.permission.WRITE_CONTACTS to true) {}
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest23.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest23.kt"	"testDenialWithPrejudice"	"CtsPermission3TestCases"	"1: permission"	"([17:/android/permission3/cts/PermissionTest23.kt]:[permission]:[17]:method_text:[onsAndAssertResult(android.Manifest.permission.WRITE_CONTACTS to false) {}    }    @FlakyTest   ]) :|: 
    fun testDenialWithPrejudice() {
        // Make sure we don't have the permission
        assertAppHasPermission(android.Manifest.permission.WRITE_CONTACTS, false)

        // Request the permission and deny it
        // Expect the permission is not granted
        requestAppPermissionsAndAssertResult(android.Manifest.permission.WRITE_CONTACTS to false) {
            clickPermissionRequestDenyButton()
        }

        // Request the permission and choose don't ask again
        // Expect the permission is not granted
        requestAppPermissionsAndAssertResult(android.Manifest.permission.WRITE_CONTACTS to false) {
            denyPermissionRequestWithPrejudice()
        }

        // Request the permission and do nothing
        // Expect the permission is not granted
        requestAppPermissionsAndAssertResult(android.Manifest.permission.WRITE_CONTACTS to false) {}
    }

    @FlakyTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest23.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest23.kt"	"testRevokeAffectsWholeGroup"	"CtsPermission3TestCases"	"1: permission"	"([14:/android/permission3/cts/PermissionTest23.kt]:[permission]:[14]:method_text:[ false)        assertAppHasPermission(android.Manifest.permission.WRITE_CALENDAR, false)    }   ]) :|: 
    fun testRevokeAffectsWholeGroup() {
        // Grant the group
        grantAppPermissions(android.Manifest.permission.READ_CALENDAR)

        // Make sure we have the permissions
        assertAppHasPermission(android.Manifest.permission.READ_CALENDAR, true)
        assertAppHasPermission(android.Manifest.permission.WRITE_CALENDAR, true)

        // Revoke the group
        revokeAppPermissions(android.Manifest.permission.READ_CALENDAR)

        // Make sure we don't have the permissions
        assertAppHasPermission(android.Manifest.permission.READ_CALENDAR, false)
        assertAppHasPermission(android.Manifest.permission.WRITE_CALENDAR, false)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest23.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest23.kt"	"testGrantPreviouslyRevokedWithPrejudiceShowsPrompt"	"CtsPermission3TestCases"	"1: permission"	"([26:/android/permission3/cts/PermissionTest23.kt]:[permission]:[26]:method_text:[     } else {                clickPermissionRequestAllowButton()            }        }    }   ]) :|: 
    fun testGrantPreviouslyRevokedWithPrejudiceShowsPrompt() {
        // Make sure we don't have the permission
        assertAppHasPermission(android.Manifest.permission.CAMERA, false)

        // Request the permission and deny it
        // Expect the permission is not granted
        requestAppPermissionsAndAssertResult(android.Manifest.permission.CAMERA to false) {
            clickPermissionRequestDenyButton()
        }

        // Request the permission and choose don't ask again
        // Expect the permission is not granted
        requestAppPermissionsAndAssertResult(android.Manifest.permission.CAMERA to false) {
            denyPermissionRequestWithPrejudice()
        }

        // Clear the denial with prejudice
        grantAppPermissions(android.Manifest.permission.CAMERA)
        revokeAppPermissions(android.Manifest.permission.CAMERA)

        // Make sure we don't have the permission
        assertAppHasPermission(android.Manifest.permission.CAMERA, false)

        // Request the permission and allow it
        // Make sure the permission is granted
        requestAppPermissionsAndAssertResult(android.Manifest.permission.CAMERA to true) {
            if (SdkLevel.isAtLeastS()) {
                clickPermissionRequestAllowForegroundButton()
            } else {
                clickPermissionRequestAllowButton()
            }
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest23.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest23.kt"	"testRequestNonRuntimePermission"	"CtsPermission3TestCases"	"1: permission"	"([8:/android/permission3/cts/PermissionTest23.kt]:[permission]:[8]:method_text:[tResult(            android.Manifest.permission.BIND_PRINT_SERVICE to false        ) {}    }   ]) :|: 
    fun testRequestNonRuntimePermission() {
        // Make sure we don't have the permission
        assertAppHasPermission(android.Manifest.permission.BIND_PRINT_SERVICE, false)

        // Request the permission and do nothing
        // Expect the permission is not granted
        requestAppPermissionsAndAssertResult(
            android.Manifest.permission.BIND_PRINT_SERVICE to false
        ) {}
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest23.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest23.kt"	"testRequestNonExistentPermission"	"CtsPermission3TestCases"	"1: permission"	"([8:/android/permission3/cts/PermissionTest23.kt]:[permission]:[8]:method_text:[granted        requestAppPermissionsAndAssertResult(NON_EXISTENT_PERMISSION to false) {}    }   ]) :|: 
    fun testRequestNonExistentPermission() {
        // Make sure we don't have the permission
        assertAppHasPermission(NON_EXISTENT_PERMISSION, false)

        // Request the permission and do nothing
        // Expect the permission is not granted
        requestAppPermissionsAndAssertResult(NON_EXISTENT_PERMISSION to false) {}
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest23.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest23.kt"	"testRequestPermissionFromTwoGroups"	"CtsPermission3TestCases"	"1: permission"	"([21:/android/permission3/cts/PermissionTest23.kt]:[permission]:[21]:method_text:[granted.        assertAppHasPermission(android.Manifest.permission.READ_CONTACTS, false)    }   ]) :|: 
    fun testRequestPermissionFromTwoGroups() {
        // Make sure we don't have the permissions
        assertAppHasPermission(android.Manifest.permission.WRITE_CONTACTS, false)
        assertAppHasPermission(android.Manifest.permission.WRITE_CALENDAR, false)
        assertAppHasPermission(android.Manifest.permission.READ_CALENDAR, false)

        // Request the permission and allow it
        // Expect the permission are granted
        val result = requestAppPermissionsAndAssertResult(
            android.Manifest.permission.WRITE_CONTACTS to true,
            android.Manifest.permission.WRITE_CALENDAR to true
        ) {
            clickPermissionRequestAllowButton()
            clickPermissionRequestAllowButton()
        }

        // In API < N_MR1 all permissions of a group are granted. I.e. the grant was ""expanded""
        assertAppHasPermission(android.Manifest.permission.READ_CALENDAR, true)
        // Even the contacts group was expanded, the read-calendar permission is not in the
        // manifest, hence not granted.
        assertAppHasPermission(android.Manifest.permission.READ_CONTACTS, false)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest23.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest23.kt"	"testNoResidualPermissionsOnUninstall"	"CtsPermission3TestCases"	"1: permission"	"([21:/android/permission3/cts/PermissionTest23.kt]:[permission]:[21]:method_text:[d after uninstalling and installing the app        assertAppHasAllOrNoPermissions(false)    }   ]) :|: (timeout = 120000)
    @FlakyTest
    fun testNoResidualPermissionsOnUninstall() {
        Assume.assumeFalse(packageManager.arePermissionsIndividuallyControlled())

        // Grant all permissions
        grantAppPermissions(
            android.Manifest.permission.WRITE_CALENDAR,
            android.Manifest.permission.WRITE_CONTACTS,
            android.Manifest.permission.READ_SMS,
            android.Manifest.permission.CALL_PHONE,
            android.Manifest.permission.RECORD_AUDIO,
            android.Manifest.permission.BODY_SENSORS,
            android.Manifest.permission.CAMERA,
            android.Manifest.permission.READ_EXTERNAL_STORAGE, targetSdk = 23
        )
        // Don't use UI for granting location permission as this shows another dialog
        uiAutomation.grantRuntimePermission(
            APP_PACKAGE_NAME, android.Manifest.permission.ACCESS_FINE_LOCATION
        )
        uiAutomation.grantRuntimePermission(
            APP_PACKAGE_NAME, android.Manifest.permission.ACCESS_COARSE_LOCATION
        )
        uiAutomation.grantRuntimePermission(
            APP_PACKAGE_NAME, android.Manifest.permission.ACCESS_BACKGROUND_LOCATION
        )

        uninstallPackage(APP_PACKAGE_NAME)
        installPackage(APP_APK_PATH_23)

        // Make no permissions are granted after uninstalling and installing the app
        assertAppHasAllOrNoPermissions(false)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest23.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest23.kt"	"testNullPermissionRequest"	"CtsPermission3TestCases"	"1: permission"	"([2:/android/permission3/cts/PermissionTest23.kt]:[permission]:[2]:method_text:[ through normal grant flow        requestAppPermissionsAndAssertResult(null to false) {}    }   ]) :|: 
    fun testNullPermissionRequest() {
        // Go through normal grant flow
        requestAppPermissionsAndAssertResult(null to false) {}
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest23.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest23.kt"	"testNullAndRealPermission"	"CtsPermission3TestCases"	"1: permission"	"([14:/android/permission3/cts/PermissionTest23.kt]:[permission]:[14]:method_text:[uestAllowButton()            }            clickPermissionRequestAllowButton()        }    }   ]) :|: 
    fun testNullAndRealPermission() {
        // Make sure we don't have the permissions
        assertAppHasPermission(android.Manifest.permission.WRITE_CONTACTS, false)
        assertAppHasPermission(android.Manifest.permission.RECORD_AUDIO, false)

        // Request the permission and allow it
        // Expect the permission are granted
        requestAppPermissionsAndAssertResult(
            null to false,
            android.Manifest.permission.WRITE_CONTACTS to true,
            null to false,
            android.Manifest.permission.RECORD_AUDIO to true
        ) {
            if (SdkLevel.isAtLeastS()) {
                clickPermissionRequestAllowForegroundButton()
            } else {
                clickPermissionRequestAllowButton()
            }
            clickPermissionRequestAllowButton()
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest23.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest23.kt"	"testInvalidPermission"	"CtsPermission3TestCases"	"1: permission"	"([38:/android/permission3/cts/PermissionTest23.kt]:[permission]:[38]:method_text:[RAGE        ).forEach {            assertAppHasPermission(it, expectPermissions)        }    }}]) :|: 
    fun testInvalidPermission() {
        // Request the permission and allow it
        // Expect the permission is not granted
        requestAppPermissionsAndAssertResult(INVALID_PERMISSION to false) {}
    }

    private fun denyPermissionRequestWithPrejudice() {
        if (isTv || isWatch) {
            clickPermissionRequestDontAskAgainButton()
        } else {
            clickPermissionRequestDenyAndDontAskAgainButton()
        }
    }

    private fun assertAppHasAllOrNoPermissions(expectPermissions: Boolean) {
        arrayOf(
            android.Manifest.permission.SEND_SMS,
            android.Manifest.permission.RECEIVE_SMS,
            android.Manifest.permission.RECEIVE_WAP_PUSH,
            android.Manifest.permission.RECEIVE_MMS,
            android.Manifest.permission.READ_CALENDAR,
            android.Manifest.permission.WRITE_CALENDAR,
            android.Manifest.permission.WRITE_CONTACTS,
            android.Manifest.permission.READ_SMS,
            android.Manifest.permission.READ_PHONE_STATE,
            android.Manifest.permission.READ_CALL_LOG,
            android.Manifest.permission.WRITE_CALL_LOG,
            android.Manifest.permission.ADD_VOICEMAIL,
            android.Manifest.permission.CALL_PHONE,
            android.Manifest.permission.USE_SIP,
            android.Manifest.permission.PROCESS_OUTGOING_CALLS,
            android.Manifest.permission.RECORD_AUDIO,
            android.Manifest.permission.ACCESS_FINE_LOCATION,
            android.Manifest.permission.ACCESS_COARSE_LOCATION,
            android.Manifest.permission.CAMERA,
            android.Manifest.permission.BODY_SENSORS,
            android.Manifest.permission.READ_CELL_BROADCASTS,
            // Split permissions
            android.Manifest.permission.ACCESS_BACKGROUND_LOCATION,
            // Storage permissions
            android.Manifest.permission.READ_EXTERNAL_STORAGE,
            android.Manifest.permission.WRITE_EXTERNAL_STORAGE
        ).forEach {"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest23.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionUsageInfoTest.kt"	"BaseUsePermissionTest"	"CtsPermission3TestCases"	"1: permission"	"([5:/android/permission3/cts/PermissionUsageInfoTest.kt]:[permission]:[5]:method_text:[ch)    }    @Before    fun installApp() {        installPackage(APP_APK_PATH_LATEST)    }   ]) :|: /*
 *.
 */

package android.permission3.cts

import android.content.Intent
import android.support.test.uiautomator.By
import com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity
import org.junit.Assume.assumeFalse
import org.junit.Before
import org.junit.Test

/**
 * Tests permission usage info action.
 */
class PermissionUsageInfoTest : BaseUsePermissionTest() {
    @Before
    fun assumeHandheld() {
        assumeFalse(isAutomotive)
        assumeFalse(isTv)
        assumeFalse(isWatch)
    }

    @Before
    fun installApp() {
        installPackage(APP_APK_PATH_LATEST)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionUsageInfoTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionUsageInfoTest.kt"	"testPermissionUsageInfo"	"CtsPermission3TestCases"	"1: permission"	"([4:/android/permission3/cts/PermissionUsageInfoTest.kt]:[permission]:[4]:method_text:[ }            )        }        click(By.res(""com.android.permissioncontroller:id/icon""))    }}]) :|: 
    fun testPermissionUsageInfo() {
        runWithShellPermissionIdentity {
            context.startActivity(
                Intent(Intent.ACTION_MANAGE_APP_PERMISSIONS).apply {
                    putExtra(Intent.EXTRA_PACKAGE_NAME, APP_PACKAGE_NAME)
                    addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                }
            )
        }
        click(By.res(""com.android.permissioncontroller:id/icon""))
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionUsageInfoTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionSplitTest.kt"	"BaseUsePermissionTest"	"CtsPermission3TestCases"	"1: permission"	"([5:/android/permission3/cts/PermissionSplitTest.kt]:[permission]:[5]:method_text:[: BaseUsePermissionTest() {    @Before    fun assumeNotTv() {        assumeFalse(isTv)    }   ]) :|: /*
 *.
 */

package android.permission3.cts

import org.junit.Assume.assumeFalse
import org.junit.Before
import org.junit.Test

/**
 * Runtime permission behavior tests for permission splits.
 */
class PermissionSplitTest : BaseUsePermissionTest() {
    @Before
    fun assumeNotTv() {
        assumeFalse(isTv)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionSplitTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionSplitTest.kt"	"testPermissionSplit28"	"CtsPermission3TestCases"	"1: permission"	"([2:/android/permission3/cts/PermissionSplitTest.kt]:[permission]:[2]:method_text:[t28() {        installPackage(APP_APK_PATH_28)        testLocationPermissionSplit(true)    }   ]) :|: 
    fun testPermissionSplit28() {
        installPackage(APP_APK_PATH_28)
        testLocationPermissionSplit(true)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionSplitTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionSplitTest.kt"	"testPermissionNotSplit29"	"CtsPermission3TestCases"	"1: permission"	"([2:/android/permission3/cts/PermissionSplitTest.kt]:[permission]:[2]:method_text:[29() {        installPackage(APP_APK_PATH_29)        testLocationPermissionSplit(false)    }   ]) :|: 
    fun testPermissionNotSplit29() {
        installPackage(APP_APK_PATH_29)
        testLocationPermissionSplit(false)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionSplitTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionSplitTest.kt"	"testPermissionNotSplit30"	"CtsPermission3TestCases"	"1: permission"	"([2:/android/permission3/cts/PermissionSplitTest.kt]:[permission]:[2]:method_text:[30() {        installPackage(APP_APK_PATH_30)        testLocationPermissionSplit(false)    }   ]) :|: 
    fun testPermissionNotSplit30() {
        installPackage(APP_APK_PATH_30)
        testLocationPermissionSplit(false)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionSplitTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionSplitTest.kt"	"testPermissionNotSplitLatest"	"CtsPermission3TestCases"	"1: permission"	"([13:/android/permission3/cts/PermissionSplitTest.kt]:[permission]:[13]:method_text:[ assertAppHasPermission(android.Manifest.permission.ACCESS_BACKGROUND_LOCATION, expectSplit)    }}]) :|: 
    fun testPermissionNotSplitLatest() {
        installPackage(APP_APK_PATH_LATEST)
        testLocationPermissionSplit(false)
    }

    private fun testLocationPermissionSplit(expectSplit: Boolean) {
        assertAppHasPermission(android.Manifest.permission.ACCESS_FINE_LOCATION, false)
        assertAppHasPermission(android.Manifest.permission.ACCESS_BACKGROUND_LOCATION, false)

        requestAppPermissionsAndAssertResult(
                android.Manifest.permission.ACCESS_FINE_LOCATION to true
        ) {
            if (expectSplit) {
                clickPermissionRequestSettingsLinkAndAllowAlways()
            } else {
                clickPermissionRequestAllowForegroundButton()
            }
        }

        assertAppHasPermission(android.Manifest.permission.ACCESS_BACKGROUND_LOCATION, expectSplit)
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionSplitTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTapjackingTest.kt"	"BaseUsePermissionTest"	"CtsPermission3TestCases"	"1: permission"	"([5:/android/permission3/cts/PermissionTapjackingTest.kt]:[permission]:[5]:method_text:[   @Before    fun installAppLatest() {        installPackage(APP_APK_PATH_WITH_OVERLAY)    }   ]) :|: /*
 *.
 */

package android.permission3.cts

import android.Manifest.permission.ACCESS_FINE_LOCATION
import android.content.Intent
import android.content.pm.PackageManager
import android.graphics.Point
import android.support.test.uiautomator.By
import com.android.compatibility.common.util.SystemUtil
import org.junit.Assume.assumeFalse
import org.junit.Before
import org.junit.Test

/**
 * Tests permissions can't be tapjacked
 */
class PermissionTapjackingTest : BaseUsePermissionTest() {

    @Before
    fun installAppLatest() {
        installPackage(APP_APK_PATH_WITH_OVERLAY)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTapjackingTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTapjackingTest.kt"	"testTapjackGrantDialog_fullOverlay"	"CtsPermission3TestCases"	"1: permission"	"([6:/android/permission3/cts/PermissionTapjackingTest.kt]:[permission]:[6]:method_text:[s(""android.permission3.cts.usepermission:id/overlay""))        tryClicking(buttonCenter)    }   ]) :|: 
    fun testTapjackGrantDialog_fullOverlay() {
        // PermissionController for television uses a floating window.
        assumeFalse(isTv)

        assertAppHasPermission(ACCESS_FINE_LOCATION, false)
        requestAppPermissionsForNoResult(ACCESS_FINE_LOCATION) {}

        val buttonCenter = waitFindObject(By.text(
                getPermissionControllerString(ALLOW_FOREGROUND_BUTTON_TEXT))).visibleCenter

        // Wait for overlay to hide the dialog
        context.sendBroadcast(Intent(ACTION_SHOW_OVERLAY)
                .putExtra(EXTRA_FULL_OVERLAY, true))
        waitFindObject(By.res(""android.permission3.cts.usepermission:id/overlay""))

        tryClicking(buttonCenter)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTapjackingTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTapjackingTest.kt"	"testTapjackGrantDialog_partialOverlay"	"CtsPermission3TestCases"	"1: permission"	"([32:/android/permission3/cts/PermissionTapjackingTest.kt]:[permission]:[32]:method_text:[     const val MESSAGE_BOTTOM = ""android.permission3.cts.usepermission.extra.MESSAGE_BOTTOM""    }}]) :|: 
    fun testTapjackGrantDialog_partialOverlay() {
        // PermissionController for television uses a floating window.
        assumeFalse(isTv)
        // Automotive doesn't support detecting partial overlays yet: b/192088266
        assumeFalse(isAutomotive)

        assertAppHasPermission(ACCESS_FINE_LOCATION, false)
        requestAppPermissionsForNoResult(ACCESS_FINE_LOCATION) {}

        val buttonCenter = waitFindObject(By.text(
                getPermissionControllerString(ALLOW_FOREGROUND_BUTTON_TEXT))).visibleCenter
        val dialogBounds = waitFindObject(By.res(
                ""com.android.permissioncontroller"", ""grant_dialog"")).visibleBounds
        val messageBottom = waitFindObject(By.res(
                ""com.android.permissioncontroller"", ""permission_message"")).visibleBounds.bottom

        // Wait for overlay to hide the dialog
        context.sendBroadcast(Intent(ACTION_SHOW_OVERLAY)
                .putExtra(EXTRA_FULL_OVERLAY, false)
                .putExtra(DIALOG_LEFT, dialogBounds.left)
                .putExtra(DIALOG_TOP, dialogBounds.top)
                .putExtra(DIALOG_RIGHT, dialogBounds.right)
                .putExtra(MESSAGE_BOTTOM, messageBottom))
        waitFindObject(By.res(""android.permission3.cts.usepermission:id/overlay""))

        tryClicking(buttonCenter)
    }

    private fun tryClicking(buttonCenter: Point) {
        try {
            // Try to grant the permission, this should fail
            SystemUtil.eventually({
                if (packageManager.checkPermission(ACCESS_FINE_LOCATION, APP_PACKAGE_NAME) ==
                        PackageManager.PERMISSION_DENIED) {
                    uiDevice.click(buttonCenter.x, buttonCenter.y)
                    Thread.sleep(100)
                }
                assertAppHasPermission(ACCESS_FINE_LOCATION, true)
            }, 10000)
        } catch (e: RuntimeException) {
            // expected
        }
        // Permission should not be granted
        assertAppHasPer"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTapjackingTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionGroupTest.kt"	"BaseUsePermissionTest"	"CtsPermission3TestCases"	"1: permission"	"([5:/android/permission3/cts/PermissionGroupTest.kt]:[permission]:[5]:method_text:[ behavior tests for permission groups. */class PermissionGroupTest : BaseUsePermissionTest() {   ]) :|: /*
 *.
 */

package android.permission3.cts

import org.junit.Test

/**
 * Runtime permission behavior tests for permission groups.
 */
class PermissionGroupTest : BaseUsePermissionTest() {"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionGroupTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionGroupTest.kt"	"testPartiallyGrantedGroupExpansion"	"CtsPermission3TestCases"	"1: permission"	"([28:/android/permission3/cts/PermissionGroupTest.kt]:[permission]:[28]:method_text:[    }        assertAppHasPermission(android.Manifest.permission.SEND_SMS, expectExpansion)    }}]) :|: 
    fun testPartiallyGrantedGroupExpansion() {
        installPackage(APP_APK_PATH_30)

        // Start out without permission
        assertAppHasPermission(android.Manifest.permission.RECEIVE_SMS, false)
        assertAppHasPermission(android.Manifest.permission.SEND_SMS, false)

        // Grant only RECEIVE_SMS
        uiAutomation.grantRuntimePermission(APP_PACKAGE_NAME,
            android.Manifest.permission.RECEIVE_SMS)
 assertAppHasPermission(android.Manifest.permission.RECEIVE_SMS, true)

        // Request both permissions, and expect that SEND_SMS is granted
        requestAppPermissionsAndAssertResult(android.Manifest.permission.RECEIVE_SMS to true,
            android.Manifest.permission.SEND_SMS to true) { }

        assertAppHasPermission(android.Manifest.permission.SEND_SMS, true)
    }

    private fun testRuntimeGroupGrantExpansion(expectExpansion: Boolean) {
        // Start out without permission
        assertAppHasPermission(android.Manifest.permission.RECEIVE_SMS, false)
        assertAppHasPermission(android.Manifest.permission.SEND_SMS, false)

        // Request only one permission from the 'SMS' permission group at runtime,
        // but two from this group are <uses-permission> in the manifest
        requestAppPermissionsAndAssertResult(android.Manifest.permission.RECEIVE_SMS to true) {
            clickPermissionRequestAllowButton()
        }

        assertAppHasPermission(android.Manifest.permission.SEND_SMS, expectExpansion)
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionGroupTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest29.kt"	"BaseUsePermissionTest"	"CtsPermission3TestCases"	"1: permission"	"([9:/android/permission3/cts/PermissionTest29.kt]:[permission]:[9]:method_text:[    assertAppHasPermission(android.Manifest.permission.ACCESS_BACKGROUND_LOCATION, false)    }   ]) :|: /*
 *.
 */

package android.permission3.cts

import android.support.test.uiautomator.By
import androidx.test.filters.FlakyTest
import com.android.compatibility.common.util.SystemUtil.eventually
import org.junit.Assume.assumeFalse
import org.junit.Before
import org.junit.Test

/**
 * Runtime permission behavior tests for apps targeting API 29.
 */
class PermissionTest29 : BaseUsePermissionTest() {
    @Before
    fun assumeNotTv() {
        assumeFalse(isTv)
    }

    @Before
    fun installApp29() {
        installPackage(APP_APK_PATH_29)
    }

    @Before
    fun assertAppHasNoPermissions() {
        assertAppHasPermission(android.Manifest.permission.ACCESS_FINE_LOCATION, false)
        assertAppHasPermission(android.Manifest.permission.ACCESS_BACKGROUND_LOCATION, false)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest29.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest29.kt"	"testRequestOnlyBackgroundNotPossible"	"CtsPermission3TestCases"	"1: permission"	"([4:/android/permission3/cts/PermissionTest29.kt]:[permission]:[4]:method_text:[    assertAppHasPermission(android.Manifest.permission.ACCESS_BACKGROUND_LOCATION, false)    }   ]) :|: 
    fun testRequestOnlyBackgroundNotPossible() {
        requestAppPermissionsAndAssertResult(
            android.Manifest.permission.ACCESS_BACKGROUND_LOCATION to false
        ) {}

        assertAppHasPermission(android.Manifest.permission.ACCESS_BACKGROUND_LOCATION, false)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest29.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest29.kt"	"testRequestBoth"	"CtsPermission3TestCases"	"1: permission"	"([4:/android/permission3/cts/PermissionTest29.kt]:[permission]:[4]:method_text:[true        ) {            clickPermissionRequestSettingsLinkAndAllowAlways()        }    }   ]) :|: 
    fun testRequestBoth() {
        requestAppPermissionsAndAssertResult(
            android.Manifest.permission.ACCESS_FINE_LOCATION to true,
            android.Manifest.permission.ACCESS_BACKGROUND_LOCATION to true
        ) {
            clickPermissionRequestSettingsLinkAndAllowAlways()
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest29.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest29.kt"	"testRequestBothInSequence"	"CtsPermission3TestCases"	"1: permission"	"([10:/android/permission3/cts/PermissionTest29.kt]:[permission]:[10]:method_text:[}        assertAppHasPermission(android.Manifest.permission.ACCESS_FINE_LOCATION, true)    }   ]) :|: 
    fun testRequestBothInSequence() {
        // Step 1: request foreground only
        requestAppPermissionsAndAssertResult(
            android.Manifest.permission.ACCESS_FINE_LOCATION to true
        ) {
            clickPermissionRequestAllowForegroundButton()
        }

        assertAppHasPermission(android.Manifest.permission.ACCESS_BACKGROUND_LOCATION, false)

        // Step 2: request background only
        requestAppPermissionsAndAssertResult(
            android.Manifest.permission.ACCESS_BACKGROUND_LOCATION to true
        ) {
            clickPermissionRequestSettingsLinkAndAllowAlways()
        }

        assertAppHasPermission(android.Manifest.permission.ACCESS_FINE_LOCATION, true)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest29.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest29.kt"	"testRequestBothButGrantInSequence"	"CtsPermission3TestCases"	"1: permission"	"([8:/android/permission3/cts/PermissionTest29.kt]:[permission]:[8]:method_text:[{            clickPermissionRequestSettingsLinkAndAllowAlways()        }    }    @FlakyTest   ]) :|: 
    fun testRequestBothButGrantInSequence() {
        // Step 1: grant foreground only
        requestAppPermissionsAndAssertResult(
            android.Manifest.permission.ACCESS_FINE_LOCATION to true,
            android.Manifest.permission.ACCESS_BACKGROUND_LOCATION to false
        ) {
            clickPermissionRequestAllowForegroundButton()
        }

        // Step 2: grant background
        requestAppPermissionsAndAssertResult(
            android.Manifest.permission.ACCESS_FINE_LOCATION to true,
            android.Manifest.permission.ACCESS_BACKGROUND_LOCATION to true
        ) {
            clickPermissionRequestSettingsLinkAndAllowAlways()
        }
    }

    @FlakyTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest29.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest29.kt"	"testDenyBackgroundWithPrejudice"	"CtsPermission3TestCases"	"1: permission"	"([11:/android/permission3/cts/PermissionTest29.kt]:[permission]:[11]:method_text:[droid.Manifest.permission.ACCESS_BACKGROUND_LOCATION to false        ) {}    }    @FlakyTest   ]) :|: 
    fun testDenyBackgroundWithPrejudice() {
        // Step 1: deny the first time
        requestAppPermissionsAndAssertResult(
            android.Manifest.permission.ACCESS_FINE_LOCATION to false,
            android.Manifest.permission.ACCESS_BACKGROUND_LOCATION to false
        ) {
            clickPermissionRequestDenyButton()
        }

        // Step 2: deny with prejudice
        requestAppPermissionsAndAssertResult(
            android.Manifest.permission.ACCESS_FINE_LOCATION to false,
            android.Manifest.permission.ACCESS_BACKGROUND_LOCATION to false
        ) {
            clickPermissionRequestDenyAndDontAskAgainButton()
        }

        // Step 3: All further requests should be denied automatically
        requestAppPermissionsAndAssertResult(
            android.Manifest.permission.ACCESS_FINE_LOCATION to false,
            android.Manifest.permission.ACCESS_BACKGROUND_LOCATION to false
        ) {}
    }

    @FlakyTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest29.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest29.kt"	"testGrantDialogToSettingsNoOp"	"CtsPermission3TestCases"	"1: permission"	"([18:/android/permission3/cts/PermissionTest29.kt]:[permission]:[18]:method_text:[droid.permissioncontroller:id/grant_dialog""), 100)            }        }    }    @FlakyTest   ]) :|: 
    fun testGrantDialogToSettingsNoOp() {
        // Step 1: Request both, go to settings, do nothing
        requestAppPermissionsAndAssertResult(
            android.Manifest.permission.ACCESS_FINE_LOCATION to true,
            android.Manifest.permission.ACCESS_BACKGROUND_LOCATION to false
        ) {
            openSettingsThenDoNothingThenLeave()

            assertAppHasPermission(android.Manifest.permission.ACCESS_FINE_LOCATION, false)
            assertAppHasPermission(android.Manifest.permission.ACCESS_BACKGROUND_LOCATION, false)

            clickPermissionRequestAllowForegroundButton()
        }

        // Step 2: Upgrade foreground to background, go to settings, do nothing
        requestAppPermissionsAndAssertResult(
            android.Manifest.permission.ACCESS_FINE_LOCATION to true,
            android.Manifest.permission.ACCESS_BACKGROUND_LOCATION to false
        ) {
            openSettingsThenDoNothingThenLeave()

            assertAppHasPermission(android.Manifest.permission.ACCESS_FINE_LOCATION, true)
            assertAppHasPermission(android.Manifest.permission.ACCESS_BACKGROUND_LOCATION, false)

            clickPermissionRequestNoUpgradeAndDontAskAgainButton()
        }
    }

    private fun openSettingsThenDoNothingThenLeave() {
        clickPermissionRequestSettingsLink()
        eventually {
            pressBack()
            if (isAutomotive) {
                waitFindObject(By.textContains(""Allow in settings.""), 100)
            } else {
                waitFindObject(By.res(""com.android.permissioncontroller:id/grant_dialog""), 100)
            }
        }
    }

    @FlakyTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest29.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest29.kt"	"testGrantDialogToSettingsDowngrade"	"CtsPermission3TestCases"	"1: permission"	"([13:/android/permission3/cts/PermissionTest29.kt]:[permission]:[13]:method_text:[       assertAppHasPermission(android.Manifest.permission.ACCESS_BACKGROUND_LOCATION, false)    }}]) :|: 
    fun testGrantDialogToSettingsDowngrade() {
        // Request upgrade, downgrade permission to denied in settings
        requestAppPermissionsAndAssertResult(
            android.Manifest.permission.ACCESS_FINE_LOCATION to true,
            android.Manifest.permission.ACCESS_BACKGROUND_LOCATION to false
        ) {
            clickPermissionRequestAllowForegroundButton()
        }

        requestAppPermissions(
            android.Manifest.permission.ACCESS_FINE_LOCATION,
            android.Manifest.permission.ACCESS_BACKGROUND_LOCATION
        ) {
            clickPermissionRequestSettingsLinkAndDeny()
            waitForIdle()
            pressBack()
        }

        assertAppHasPermission(android.Manifest.permission.ACCESS_FINE_LOCATION, false)
        assertAppHasPermission(android.Manifest.permission.ACCESS_BACKGROUND_LOCATION, false)
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest29.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest30.kt"	"BaseUsePermissionTest"	"CtsPermission3TestCases"	"1: permission"	"([6:/android/permission3/cts/PermissionTest30.kt]:[permission]:[6]:method_text:[ermission behavior apps targeting API 30 */class PermissionTest30 : BaseUsePermissionTest() {   ]) :|: /*
 *.
 */

package android.permission3.cts

import android.Manifest.permission.ACCESS_BACKGROUND_LOCATION
import android.Manifest.permission.ACCESS_FINE_LOCATION
import org.junit.Test

/**
 * Runtime permission behavior apps targeting API 30
 */
class PermissionTest30 : BaseUsePermissionTest() {"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest30.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest30.kt"	"testCantRequestFgAndBgAtOnce"	"CtsPermission3TestCases"	"1: permission"	"([3:/android/permission3/cts/PermissionTest30.kt]:[permission]:[3]:method_text:[_LOCATION to false) {            // Do nothing, should be automatically denied        }    }   ]) :|: 
    fun testCantRequestFgAndBgAtOnce() {
        installPackage(APP_APK_PATH_30_WITH_BACKGROUND)
        assertAppHasPermission(ACCESS_FINE_LOCATION, false)
        assertAppHasPermission(ACCESS_BACKGROUND_LOCATION, false)

        requestAppPermissionsAndAssertResult(ACCESS_FINE_LOCATION to false,
                ACCESS_BACKGROUND_LOCATION to false) {
            // Do nothing, should be automatically denied
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest30.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission3.cts.PermissionTest30.kt"	"testRequestBothInSequence"	"CtsPermission3TestCases"	"1: permission"	"([5:/android/permission3/cts/PermissionTest30.kt]:[permission]:[5]:method_text:[    clickAllowAlwaysInSettings()            waitForIdle()            pressBack()        }    }}]) :|: 
    fun testRequestBothInSequence() {
        installPackage(APP_APK_PATH_30_WITH_BACKGROUND)
        assertAppHasPermission(ACCESS_FINE_LOCATION, false)
        assertAppHasPermission(ACCESS_BACKGROUND_LOCATION, false)

        requestAppPermissionsAndAssertResult(ACCESS_FINE_LOCATION to true) {
            clickPermissionRequestAllowForegroundButton()
        }

        requestAppPermissionsAndAssertResult(ACCESS_BACKGROUND_LOCATION to true) {
            clickAllowAlwaysInSettings()
            waitForIdle()
            pressBack()
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission3/src/android/permission3/cts/PermissionTest30.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appwidget.cts.AppWidgetTest"	"testBindAppWidget"	"CtsAppWidgetTestCases"	"1: permission"	"([4:/android/appwidget/cts/AppWidgetTest.java]:[permission]:[4]:method_text:[);        }    }    @AppModeFull(reason = ""Instant apps cannot provide or host app widgets"")   ]) :|: 
    public void testBindAppWidget() throws Exception {
        // Create a host and start listening.
        AppWidgetHost host = new AppWidgetHost(getInstrumentation().getTargetContext(), 0);
        host.deleteHost();
        host.startListening();

        // Allocate an app widget id to bind.
        final int appWidgetId = host.allocateAppWidgetId();

        // Grab a provider we defined to be bound.
        AppWidgetProviderInfo provider = getFirstAppWidgetProviderInfo();

        // Bind the widget.
        boolean widgetBound = getAppWidgetManager().bindAppWidgetIdIfAllowed(appWidgetId,
                provider.getProfile(), provider.provider, null);
        assertFalse(widgetBound);

        // Well, app do not have this permission unless explicitly granted
        // by the user. Now we will pretend for the user and grant it.
        grantBindAppWidgetPermission();

        try {
            // Bind the widget as we have a permission for that.
            widgetBound = getAppWidgetManager().bindAppWidgetIdIfAllowed(
                    appWidgetId, provider.getProfile(), provider.provider, null);
            assertTrue(widgetBound);

            // Deallocate the app widget id.
            host.deleteAppWidgetId(appWidgetId);
        } finally {
            // Clean up.
            host.deleteAppWidgetId(appWidgetId);
            host.deleteHost();
            revokeBindAppWidgetPermission();
        }
    }

    @AppModeFull(reason = ""Instant apps cannot provide or host app widgets"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appwidget/src/android/appwidget/cts/AppWidgetTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appwidget.cts.AppWidgetTest"	"testAppWidgetProviderCallbacks"	"CtsAppWidgetTestCases"	"1: permission"	"([2:/android/appwidget/cts/AppWidgetTest.java]:[permission]:[2]:method_text:[);        }    }    @AppModeFull(reason = ""Instant apps cannot provide or host app widgets"")   ]) :|: 
    public void testAppWidgetProviderCallbacks() throws Exception {
        AtomicInteger invocationCounter = new AtomicInteger();

        // Set a mock to intercept provider callbacks.
        AppWidgetProviderCallbacks callbacks = createAppWidgetProviderCallbacks(invocationCounter);
        FirstAppWidgetProvider.setCallbacks(callbacks);

        int firstAppWidgetId = 0;
        int secondAppWidgetId = 0;

        final Bundle firstOptions;
        final Bundle secondOptions;

        // Create a host and start listening.
        AppWidgetHost host = new AppWidgetHost(getInstrumentation().getTargetContext(), 0);
        host.deleteHost();
        host.startListening();

        // We want to bind a widget.
        grantBindAppWidgetPermission();
        try {
            // Allocate the first widget id to bind.
            firstAppWidgetId = host.allocateAppWidgetId();

            // Grab a provider we defined to be bound.
            AppWidgetProviderInfo provider = getFirstAppWidgetProviderInfo();

            // Bind the first widget.
            getAppWidgetManager().bindAppWidgetIdIfAllowed(firstAppWidgetId,
                    provider.getProfile(), provider.provider, null);

            // Wait for onEnabled and onUpdate
            waitForCallCount(invocationCounter, 2);

            // Update the first widget options.
            firstOptions = new Bundle();
            firstOptions.putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH, 1);
            firstOptions.putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, 2);
            firstOptions.putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH, 3);
            firstOptions.putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT, 4);
            getAppWidgetManager().updateAppWidgetOptions(firstAppWidgetId, firstOptions);

            // Wait for onAppWidgetOptionsChanged
            waitForCallCount(invocationCounter, 3);

            // Allocate the second app widget id to bind.
            secondAppWidge"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appwidget/src/android/appwidget/cts/AppWidgetTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appwidget.cts.AppWidgetTest"	"testTwoAppWidgetProviderCallbacks"	"CtsAppWidgetTestCases"	"1: permission"	"([2:/android/appwidget/cts/AppWidgetTest.java]:[permission]:[2]:method_text:[);        }    }    @AppModeFull(reason = ""Instant apps cannot provide or host app widgets"")   ]) :|: 
    public void testTwoAppWidgetProviderCallbacks() throws Exception {
        AtomicInteger invocationCounter = new AtomicInteger();

        // Set a mock to intercept first provider callbacks.
        AppWidgetProviderCallbacks firstCallbacks = createAppWidgetProviderCallbacks(
                invocationCounter);
        FirstAppWidgetProvider.setCallbacks(firstCallbacks);

        // Set a mock to intercept second provider callbacks.
        AppWidgetProviderCallbacks secondCallbacks = createAppWidgetProviderCallbacks(
                invocationCounter);
        SecondAppWidgetProvider.setCallbacks(secondCallbacks);

        int firstAppWidgetId = 0;
        int secondAppWidgetId = 0;

        // Create a host and start listening.
        AppWidgetHost host = new AppWidgetHost(getInstrumentation().getTargetContext(), 0);
        host.deleteHost();
        host.startListening();

        // We want to bind widgets.
        grantBindAppWidgetPermission();
        try {
            // Allocate the first widget id to bind.
            firstAppWidgetId = host.allocateAppWidgetId();

            // Allocate the second widget id to bind.
            secondAppWidgetId = host.allocateAppWidgetId();

            // Grab the first provider we defined to be bound.
            AppWidgetProviderInfo firstProvider = getFirstAppWidgetProviderInfo();

            // Bind the first widget.
            getAppWidgetManager().bindAppWidgetIdIfAllowed(firstAppWidgetId,
                    firstProvider.getProfile(), firstProvider.provider, null);

            // Wait for onEnabled and onUpdate
            waitForCallCount(invocationCounter, 2);

            // Grab the second provider we defined to be bound.
            AppWidgetProviderInfo secondProvider = getSecondAppWidgetProviderInfo();

            // Bind the second widget.
            getAppWidgetManager().bindAppWidgetIdIfAllowed(secondAppWidgetId,
                    secondProvider.getProfile(), secondProvider.provider, nu"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appwidget/src/android/appwidget/cts/AppWidgetTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appwidget.cts.AppWidgetTest"	"testGetAppWidgetIdsForProvider"	"CtsAppWidgetTestCases"	"1: permission"	"([2:/android/appwidget/cts/AppWidgetTest.java]:[permission]:[2]:method_text:[);        }    }    @AppModeFull(reason = ""Instant apps cannot provide or host app widgets"")   ]) :|: 
    public void testGetAppWidgetIdsForProvider() throws Exception {
        // We want to bind widgets.
        grantBindAppWidgetPermission();

        // Create a host and start listening.
        AppWidgetHost host = new AppWidgetHost(
                getInstrumentation().getTargetContext(), 0);
        host.deleteHost();
        host.startListening();

        int firstAppWidgetId = 0;
        int secondAppWidgetId = 0;

        try {
            // Grab the provider we defined to be bound.
            AppWidgetProviderInfo provider = getFirstAppWidgetProviderInfo();

            // Initially we have no widgets.
            int[] widgetsIds = getAppWidgetManager().getAppWidgetIds(provider.provider);
            assertTrue(widgetsIds.length == 0);

            // Allocate the first widget id to bind.
            firstAppWidgetId = host.allocateAppWidgetId();

            // Bind the first widget.
            getAppWidgetManager().bindAppWidgetIdIfAllowed(firstAppWidgetId,
                    provider.getProfile(), provider.provider, null);

            // Allocate the second widget id to bind.
            secondAppWidgetId = host.allocateAppWidgetId();

            // Bind the second widget.
            getAppWidgetManager().bindAppWidgetIdIfAllowed(secondAppWidgetId,
                    provider.getProfile(), provider.provider, null);

            // Now we have two widgets,
            widgetsIds = getAppWidgetManager().getAppWidgetIds(provider.provider);
            assertTrue(Arrays.equals(widgetsIds, new int[]{firstAppWidgetId, secondAppWidgetId}));
        } finally {
            // Clean up.
            host.deleteAppWidgetId(firstAppWidgetId);
            host.deleteAppWidgetId(secondAppWidgetId);
            host.deleteHost();
            revokeBindAppWidgetPermission();
        }
    }

    @AppModeFull(reason = ""Instant apps cannot provide or host app widgets"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appwidget/src/android/appwidget/cts/AppWidgetTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appwidget.cts.AppWidgetTest"	"testGetAppWidgetInfo"	"CtsAppWidgetTestCases"	"1: permission"	"([2:/android/appwidget/cts/AppWidgetTest.java]:[permission]:[2]:method_text:[);        }    }    @AppModeFull(reason = ""Instant apps cannot provide or host app widgets"")   ]) :|: 
    public void testGetAppWidgetInfo() throws Exception {
        // We want to bind widgets.
        grantBindAppWidgetPermission();

        // Create a host and start listening.
        AppWidgetHost host = new AppWidgetHost(
                getInstrumentation().getTargetContext(), 0);
        host.deleteHost();
        host.startListening();

        int appWidgetId = 0;

        try {
            // Allocate an widget id to bind.
            appWidgetId = host.allocateAppWidgetId();

            // The widget is not bound, so no info.
            AppWidgetProviderInfo foundProvider = getAppWidgetManager()
                    .getAppWidgetInfo(appWidgetId);
            assertNull(foundProvider);

            // Grab the provider we defined to be bound.
            AppWidgetProviderInfo provider = getFirstAppWidgetProviderInfo();

            // Bind the app widget.
            getAppWidgetManager().bindAppWidgetIdIfAllowed(appWidgetId,
                    provider.getProfile(), provider.provider, null);

            // The widget is bound, so the provider info should be there.
            foundProvider = getAppWidgetManager().getAppWidgetInfo(appWidgetId);
            assertEquals(provider.provider, foundProvider.provider);
            assertEquals(provider.getProfile(), foundProvider.getProfile());

            Context context = getInstrumentation().getTargetContext();

            // Let us make sure the provider info is sane.
            String label = foundProvider.loadLabel(context.getPackageManager());
            assertTrue(!TextUtils.isEmpty(label));

            Drawable icon = foundProvider.loadIcon(context, DisplayMetrics.DENSITY_DEFAULT);
            assertNotNull(icon);

            Drawable previewImage = foundProvider.loadPreviewImage(context, 0);
            assertNotNull(previewImage);

            assertThat(foundProvider.loadDescription(context)).isEqualTo(""Widget description"");

            assertThat(foundProvider.previewLayout).isEqualTo(R"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appwidget/src/android/appwidget/cts/AppWidgetTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appwidget.cts.AppWidgetTest"	"testGetAppWidgetOptions"	"CtsAppWidgetTestCases"	"1: permission"	"([2:/android/appwidget/cts/AppWidgetTest.java]:[permission]:[2]:method_text:[);        }    }    @AppModeFull(reason = ""Instant apps cannot provide or host app widgets"")   ]) :|: 
    public void testGetAppWidgetOptions() throws Exception {
        // We want to bind widgets.
        grantBindAppWidgetPermission();

        // Create a host and start listening.
        AppWidgetHost host = new AppWidgetHost(
                getInstrumentation().getTargetContext(), 0);
        host.deleteHost();
        host.startListening();

        int appWidgetId = 0;

        try {
            // Grab the provider we defined to be bound.
            AppWidgetProviderInfo provider = getFirstAppWidgetProviderInfo();

            // Allocate an widget id to bind.
            appWidgetId = host.allocateAppWidgetId();

            // Initially we have no options.
            Bundle foundOptions = getAppWidgetManager().getAppWidgetOptions(appWidgetId);
            assertTrue(foundOptions.isEmpty());

            // We want to set the options when binding.
            Bundle setOptions = new Bundle();
            setOptions.putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH, 1);
            setOptions.putInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT, 2);
            setOptions.putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH, 3);
            setOptions.putInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT, 4);

            // Bind the app widget.
            getAppWidgetManager().bindAppWidgetIdIfAllowed(appWidgetId,
                    provider.getProfile(), provider.provider, setOptions);

            // Make sure we get the options used when binding.
            foundOptions = getAppWidgetManager().getAppWidgetOptions(appWidgetId);
            assertTrue(equalOptions(setOptions, foundOptions));
        } finally {
            // Clean up.
            host.deleteAppWidgetId(appWidgetId);
            host.deleteHost();
            revokeBindAppWidgetPermission();
        }
    }

    @AppModeFull(reason = ""Instant apps cannot provide or host app widgets"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appwidget/src/android/appwidget/cts/AppWidgetTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appwidget.cts.AppWidgetTest"	"testDeleteHost"	"CtsAppWidgetTestCases"	"1: permission"	"([2:/android/appwidget/cts/AppWidgetTest.java]:[permission]:[2]:method_text:[);        }    }    @AppModeFull(reason = ""Instant apps cannot provide or host app widgets"")   ]) :|: 
    public void testDeleteHost() throws Exception {
        // We want to bind widgets.
        grantBindAppWidgetPermission();

        // Create a host and start listening.
        AppWidgetHost host = new AppWidgetHost(
                getInstrumentation().getTargetContext(), 0);
        host.deleteHost();
        host.startListening();

        int appWidgetId = 0;

        try {
            // Allocate an widget id to bind.
            appWidgetId = host.allocateAppWidgetId();

            // Grab the provider we defined to be bound.
            AppWidgetProviderInfo provider = getFirstAppWidgetProviderInfo();

            // Bind the app widget.
            getAppWidgetManager().bindAppWidgetIdIfAllowed(appWidgetId,
                    provider.getProfile(), provider.provider, null);

            // The widget should be there.
            int[] widgetIds = getAppWidgetManager().getAppWidgetIds(provider.provider);
            assertTrue(Arrays.equals(widgetIds, new int[]{appWidgetId}));

            // Delete the host.
            host.deleteHost();

            // The host is gone and with it the widgets.
            widgetIds = getAppWidgetManager().getAppWidgetIds(provider.provider);
            assertTrue(widgetIds.length == 0);
        } finally {
            // Clean up.
            host.deleteAppWidgetId(appWidgetId);
            host.deleteHost();
            revokeBindAppWidgetPermission();
        }
    }

    @AppModeFull(reason = ""Instant apps cannot provide or host app widgets"")"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appwidget/src/android/appwidget/cts/AppWidgetTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appwidget.cts.AppWidgetTest"	"testDeleteHosts"	"CtsAppWidgetTestCases"	"1: permission"	"([2:/android/appwidget/cts/AppWidgetTest.java]:[permission]:[2]:method_text:[);        }    }    @AppModeFull(reason = ""Instant apps cannot provide or host app widgets"")   ]) :|: 
    public void testDeleteHosts() throws Exception {
        // We want to bind widgets.
        grantBindAppWidgetPermission();

        // Create the first host and start listening.
        AppWidgetHost firstHost = new AppWidgetHost(
                getInstrumentation().getTargetContext(), 0);
        firstHost.deleteHost();
        firstHost.startListening();

        // Create the second host and start listening.
        AppWidgetHost secondHost = new AppWidgetHost(
                getInstrumentation().getTargetContext(), 1);
        secondHost.deleteHost();
        secondHost.startListening();

        int firstAppWidgetId = 0;
        int secondAppWidgetId = 0;

        try {
            // Grab the provider we defined to be bound.
            AppWidgetProviderInfo provider = getFirstAppWidgetProviderInfo();

            // Allocate the first widget id to bind.
            firstAppWidgetId = firstHost.allocateAppWidgetId();

            // Bind the first app widget.
            getAppWidgetManager().bindAppWidgetIdIfAllowed(firstAppWidgetId,
                    provider.getProfile(), provider.provider, null);

            // Allocate the second widget id to bind.
            secondAppWidgetId = secondHost.allocateAppWidgetId();

            // Bind the second app widget.
            getAppWidgetManager().bindAppWidgetIdIfAllowed(secondAppWidgetId,
                    provider.getProfile(), provider.provider, null);

            // The widgets should be there.
            int[] widgetIds = getAppWidgetManager().getAppWidgetIds(provider.provider);
            assertTrue(Arrays.equals(widgetIds, new int[]{firstAppWidgetId, secondAppWidgetId}));

            // Delete all hosts.
            AppWidgetHost.deleteAllHosts();

            // The hosts are gone and with it the widgets.
            widgetIds = getAppWidgetManager().getAppWidgetIds(provider.provider);
            assertTrue(widgetIds.length == 0);
        } finally {
            // Clean up."	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appwidget/src/android/appwidget/cts/AppWidgetTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appwidget.cts.AppWidgetTest"	"testOnProvidersChanged"	"CtsAppWidgetTestCases"	"1: permission"	"([2:/android/appwidget/cts/AppWidgetTest.java]:[permission]:[2]:method_text:[);        }    }    @AppModeFull(reason = ""Instant apps cannot provide or host app widgets"")   ]) :|: 
    public void testOnProvidersChanged() throws Exception {
        // We want to bind widgets.
        grantBindAppWidgetPermission();

        final AtomicInteger onProvidersChangedCallCounter = new AtomicInteger();

        // Create a host and start listening.
        AppWidgetHost host = new AppWidgetHost(
                getInstrumentation().getTargetContext(), 0) {
            @Override
            public void onProvidersChanged() {
                synchronized (mLock) {
                    onProvidersChangedCallCounter.incrementAndGet();
                    mLock.notifyAll();
                }
            }
        };
        host.deleteHost();
        host.startListening();

        int appWidgetId = 0;

        try {
            // Grab the provider we defined to be bound.
            AppWidgetProviderInfo firstLookupProvider = getFirstAppWidgetProviderInfo();

            // Allocate a widget id to bind.
            appWidgetId = host.allocateAppWidgetId();

            // Bind the first app widget.
            getAppWidgetManager().bindAppWidgetIdIfAllowed(appWidgetId,
                    firstLookupProvider.getProfile(), firstLookupProvider.provider, null);

            // Disable the provider we just bound to.
            PackageManager packageManager = getInstrumentation().getTargetContext()
                    .getApplicationContext().getPackageManager();
            packageManager.setComponentEnabledSetting(firstLookupProvider.provider,
                    PackageManager.COMPONENT_ENABLED_STATE_DISABLED,
                    PackageManager.DONT_KILL_APP);

            // Wait for the package change to propagate.
            waitForCallCount(onProvidersChangedCallCounter, 1);

            // The provider should not be present anymore.
            AppWidgetProviderInfo secondLookupProvider = getFirstAppWidgetProviderInfo();
            assertNull(secondLookupProvider);

            // Enable the provider we disabled.
            packageManager.setComp"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appwidget/src/android/appwidget/cts/AppWidgetTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appwidget.cts.AppWidgetTest"	"testAppWidgetRemoved"	"CtsAppWidgetTestCases"	"1: permission"	"([2:/android/appwidget/cts/AppWidgetTest.java]:[permission]:[2]:method_text:[);        }    }    @AppModeFull(reason = ""Instant apps cannot provide or host app widgets"")   ]) :|: 
    public void testAppWidgetRemoved() throws Exception {

        // We want to bind widgets.
        grantBindAppWidgetPermission();

        final AtomicInteger onAppWidgetRemovedCounter = new AtomicInteger();
        IntConsumer callback = mock(IntConsumer.class);

        // Create a host and start listening.
        AppWidgetHost host = new AppWidgetHost(
            getInstrumentation().getTargetContext(), 0) {
            @Override
            public void onAppWidgetRemoved(int widgetId) {
                synchronized (mLock) {
                    onAppWidgetRemovedCounter.incrementAndGet();
                    mLock.notifyAll();
                    callback.accept(widgetId);
                }
            }
        };
        host.deleteHost();
        host.startListening();

        int firstAppWidgetId = 0;
        int secondAppWidgetId = 0;

        try {
            // Grab the provider we defined to be bound.
            AppWidgetProviderInfo firstProviderInfo = getFirstAppWidgetProviderInfo();
            AppWidgetProviderInfo secondProviderInfo = getSecondAppWidgetProviderInfo();

            // Allocate widget id to bind.
            firstAppWidgetId = host.allocateAppWidgetId();
            secondAppWidgetId = host.allocateAppWidgetId();

            //create listeners
            MyAppWidgetHostView.OnUpdateAppWidgetListener secondAppHostViewListener =
                mock(MyAppWidgetHostView.OnUpdateAppWidgetListener.class);

            // Bind the first app widget.
            getAppWidgetManager().bindAppWidgetIdIfAllowed(firstAppWidgetId,
                firstProviderInfo.getProfile(), firstProviderInfo.provider, null);
            getAppWidgetManager().bindAppWidgetIdIfAllowed(secondAppWidgetId,
                secondProviderInfo.getProfile(), secondProviderInfo.provider, null);

            // Disable the first widget while host is listening
            PackageManager packageManager = getInstrumentation().getTargetContext()"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appwidget/src/android/appwidget/cts/AppWidgetTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appwidget.cts.AppWidgetTest"	"testUpdateAppWidgetViaComponentName"	"CtsAppWidgetTestCases"	"1: permission"	"([2:/android/appwidget/cts/AppWidgetTest.java]:[permission]:[2]:method_text:[);        }    }    @AppModeFull(reason = ""Instant apps cannot provide or host app widgets"")   ]) :|: 
    public void testUpdateAppWidgetViaComponentName() throws Exception {
        // We want to bind widgets.
        grantBindAppWidgetPermission();

        final AtomicInteger updateAppWidgetCallCount = new AtomicInteger();

        // Create a host and start listening.
        AppWidgetHost host = new AppWidgetHost(
                getInstrumentation().getTargetContext(), 0) {
            @Override
            protected AppWidgetHostView onCreateView(Context context, int appWidgetId,
                    AppWidgetProviderInfo appWidget) {
                return new MyAppWidgetHostView(context);
            }
        };
        host.deleteHost();
        host.startListening();

        int firstAppWidgetId = 0;
        int secondAppWidgetId = 0;

        try {
            // Grab the provider to be bound.
            AppWidgetProviderInfo provider = getFirstAppWidgetProviderInfo();

            // Allocate the first widget id to bind.
            firstAppWidgetId = host.allocateAppWidgetId();

            // Bind the first app widget.
            getAppWidgetManager().bindAppWidgetIdIfAllowed(firstAppWidgetId,
                    provider.getProfile(), provider.provider, null);

            // Create the first host view.
            MyAppWidgetHostView firstHostView = (MyAppWidgetHostView) host.createView(
                    getInstrumentation().getContext(), firstAppWidgetId, provider);
            MyAppWidgetHostView.OnUpdateAppWidgetListener firstAppHostViewListener =
                    mock(MyAppWidgetHostView.OnUpdateAppWidgetListener.class);
            firstHostView.setOnUpdateAppWidgetListener(firstAppHostViewListener);

            // Allocate the second widget id to bind.
            secondAppWidgetId = host.allocateAppWidgetId();

            // Bind the second app widget.
            getAppWidgetManager().bindAppWidgetIdIfAllowed(secondAppWidgetId,
                    provider.getProfile(), provider.provider, null);

            // Create the second"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appwidget/src/android/appwidget/cts/AppWidgetTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appwidget.cts.AppWidgetTest"	"testUpdateAppWidgetViaWidgetId"	"CtsAppWidgetTestCases"	"1: permission"	"([2:/android/appwidget/cts/AppWidgetTest.java]:[permission]:[2]:method_text:[);        }    }    @AppModeFull(reason = ""Instant apps cannot provide or host app widgets"")   ]) :|: 
    public void testUpdateAppWidgetViaWidgetId() throws Exception {
        // We want to bind widgets.
        grantBindAppWidgetPermission();

        final AtomicInteger updateAppWidgetCallCount = new AtomicInteger();

        // Create a host and start listening.
        AppWidgetHost host = new AppWidgetHost(
                getInstrumentation().getTargetContext(), 0) {
            @Override
            protected AppWidgetHostView onCreateView(Context context, int appWidgetId,
                    AppWidgetProviderInfo appWidget) {
                return new MyAppWidgetHostView(context);
            }
        };
        host.deleteHost();
        host.startListening();

        int firstAppWidgetId = 0;

        try {
            // Grab the provider to be bound.
            AppWidgetProviderInfo provider = getFirstAppWidgetProviderInfo();

            // Allocate the first widget id to bind.
            firstAppWidgetId = host.allocateAppWidgetId();

            // Bind the first app widget.
            getAppWidgetManager().bindAppWidgetIdIfAllowed(firstAppWidgetId,
                    provider.getProfile(), provider.provider, null);

            // Create the first host view.
            MyAppWidgetHostView hostView = (MyAppWidgetHostView) host.createView(
                    getInstrumentation().getContext(), firstAppWidgetId, provider);
            MyAppWidgetHostView.OnUpdateAppWidgetListener appHostViewListener =
                    mock(MyAppWidgetHostView.OnUpdateAppWidgetListener.class);
            doAnswer(new Answer<Void>() {
                @Override
                public Void answer(InvocationOnMock invocation) throws Throwable {
                    synchronized (mLock) {
                        updateAppWidgetCallCount.incrementAndGet();
                        mLock.notifyAll();
                    }
                    return null;
                }
            }).when(appHostViewListener).onUpdateAppWidget(any(RemoteViews.class));"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appwidget/src/android/appwidget/cts/AppWidgetTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appwidget.cts.AppWidgetTest"	"testUpdateAppWidgetViaWidgetIds"	"CtsAppWidgetTestCases"	"1: permission"	"([2:/android/appwidget/cts/AppWidgetTest.java]:[permission]:[2]:method_text:[);        }    }    @AppModeFull(reason = ""Instant apps cannot provide or host app widgets"")   ]) :|: 
    public void testUpdateAppWidgetViaWidgetIds() throws Exception {
        // We want to bind widgets.
        grantBindAppWidgetPermission();

        final AtomicInteger onUpdateAppWidgetCallCount = new AtomicInteger();

        // Create a host and start listening.
        AppWidgetHost host = new AppWidgetHost(
                getInstrumentation().getTargetContext(), 0) {
            @Override
            protected AppWidgetHostView onCreateView(Context context, int appWidgetId,
                    AppWidgetProviderInfo appWidget) {
                return new MyAppWidgetHostView(context);
            }
        };
        host.deleteHost();
        host.startListening();

        int firstAppWidgetId = 0;
        int secondAppWidgetId = 0;

        try {
            // Grab the provider to be bound.
            AppWidgetProviderInfo provider = getFirstAppWidgetProviderInfo();

            // Allocate the first widget id to bind.
            firstAppWidgetId = host.allocateAppWidgetId();

            // Bind the first app widget.
            getAppWidgetManager().bindAppWidgetIdIfAllowed(firstAppWidgetId,
                    provider.getProfile(), provider.provider, null);

            // Create the first host view.
            MyAppWidgetHostView firstHostView = (MyAppWidgetHostView) host.createView(
                    getInstrumentation().getContext(), firstAppWidgetId, provider);
            MyAppWidgetHostView.OnUpdateAppWidgetListener firstAppHostViewListener =
                    mock(MyAppWidgetHostView.OnUpdateAppWidgetListener.class);
            firstHostView.setOnUpdateAppWidgetListener(firstAppHostViewListener);

            // Allocate the second widget id to bind.
            secondAppWidgetId = host.allocateAppWidgetId();

            // Bind the second app widget.
            getAppWidgetManager().bindAppWidgetIdIfAllowed(secondAppWidgetId,
                    provider.getProfile(), provider.provider, null);

            // Create the second ho"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appwidget/src/android/appwidget/cts/AppWidgetTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appwidget.cts.AppWidgetTest"	"testPartiallyUpdateAppWidgetViaWidgetId"	"CtsAppWidgetTestCases"	"1: permission"	"([2:/android/appwidget/cts/AppWidgetTest.java]:[permission]:[2]:method_text:[);        }    }    @AppModeFull(reason = ""Instant apps cannot provide or host app widgets"")   ]) :|: 
    public void testPartiallyUpdateAppWidgetViaWidgetId() throws Exception {
        // We want to bind widgets.
        grantBindAppWidgetPermission();

        final AtomicInteger updateAppWidgetCallCount = new AtomicInteger();

        // Create a host and start listening.
        AppWidgetHost host = new AppWidgetHost(
                getInstrumentation().getTargetContext(), 0) {
            @Override
            protected AppWidgetHostView onCreateView(Context context, int appWidgetId,
                    AppWidgetProviderInfo appWidget) {
                return new MyAppWidgetHostView(context);
            }
        };
        host.deleteHost();
        host.startListening();

        int firstAppWidgetId = 0;

        try {
            // Grab the provider to be bound.
            AppWidgetProviderInfo provider = getFirstAppWidgetProviderInfo();

            // Allocate the first widget id to bind.
            firstAppWidgetId = host.allocateAppWidgetId();

            // Bind the first app widget.
            getAppWidgetManager().bindAppWidgetIdIfAllowed(firstAppWidgetId,
                    provider.getProfile(), provider.provider, null);

            // Create the first host view.
            MyAppWidgetHostView hostView = (MyAppWidgetHostView) host.createView(
                    getInstrumentation().getContext(), firstAppWidgetId, provider);
            MyAppWidgetHostView.OnUpdateAppWidgetListener appHostViewListener =
                    mock(MyAppWidgetHostView.OnUpdateAppWidgetListener.class);
            doAnswer(new Answer<Void>() {
                @Override
                public Void answer(InvocationOnMock invocation) throws Throwable {
                    synchronized (mLock) {
                        updateAppWidgetCallCount.incrementAndGet();
                        mLock.notifyAll();
                    }
                    return null;
                }
            }).when(appHostViewListener).onUpdateAppWidget(any(RemoteViews.class));"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appwidget/src/android/appwidget/cts/AppWidgetTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appwidget.cts.AppWidgetTest"	"testPartiallyUpdateAppWidgetViaWidgetIds"	"CtsAppWidgetTestCases"	"1: permission"	"([2:/android/appwidget/cts/AppWidgetTest.java]:[permission]:[2]:method_text:[);        }    }    @AppModeFull(reason = ""Instant apps cannot provide or host app widgets"")   ]) :|: 
    public void testPartiallyUpdateAppWidgetViaWidgetIds() throws Exception {
        // We want to bind widgets.
        grantBindAppWidgetPermission();

        final AtomicInteger firstAppWidgetCallCounter = new AtomicInteger();
        final AtomicInteger secondAppWidgetCallCounter = new AtomicInteger();

        // Create a host and start listening.
        AppWidgetHost host = new AppWidgetHost(
                getInstrumentation().getTargetContext(), 0) {
            @Override
            protected AppWidgetHostView onCreateView(Context context, int appWidgetId,
                    AppWidgetProviderInfo appWidget) {
                return new MyAppWidgetHostView(context);
            }
        };
        host.deleteHost();
        host.startListening();

        int firstAppWidgetId = 0;
        int secondAppWidgetId = 0;

        try {
            // Grab the provider to be bound.
            AppWidgetProviderInfo provider = getFirstAppWidgetProviderInfo();

            // Allocate the first widget id to bind.
            firstAppWidgetId = host.allocateAppWidgetId();

            // Bind the first app widget.
            getAppWidgetManager().bindAppWidgetIdIfAllowed(firstAppWidgetId,
                    provider.getProfile(), provider.provider, null);

            // Create the first host view.
            MyAppWidgetHostView firstHostView = (MyAppWidgetHostView) host.createView(
                    getInstrumentation().getContext(), firstAppWidgetId, provider);
            MyAppWidgetHostView.OnUpdateAppWidgetListener firstAppHostViewListener =
                    mock(MyAppWidgetHostView.OnUpdateAppWidgetListener.class);
            doAnswer(new Answer<Void>() {
                @Override
                public Void answer(InvocationOnMock invocation) throws Throwable {
                    synchronized (mLock) {
                        firstAppWidgetCallCounter.incrementAndGet();
                        mLock.notifyAll();
                    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appwidget/src/android/appwidget/cts/AppWidgetTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appwidget.cts.AppWidgetTest"	"testCollectionWidgets"	"CtsAppWidgetTestCases"	"1: permission"	"([2:/android/appwidget/cts/AppWidgetTest.java]:[permission]:[2]:method_text:[);        }    }    @AppModeFull(reason = ""Instant apps cannot provide or host app widgets"")   ]) :|: 
    public void testCollectionWidgets() throws Exception {
        // We want to bind widgets.
        grantBindAppWidgetPermission();

        final AtomicInteger invocationCounter = new AtomicInteger();
        final Context context = getInstrumentation().getTargetContext();

        // Create a host and start listening.
        final AppWidgetHost host = new AppWidgetHost(context, 0);
        host.deleteHost();
        host.startListening();

        final int appWidgetId;

        try {
            // Configure the provider behavior.
            AppWidgetProviderCallbacks callbacks = createAppWidgetProviderCallbacks(
                    invocationCounter);
            doAnswer(new Answer<Void>() {
                @Override
                public Void answer(InvocationOnMock invocation) throws Throwable {
                    final int appWidgetId = ((int[]) invocation.getArguments()[2])[0];

                    Intent intent = new Intent(context, MyAppWidgetService.class);
                    intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);
                    intent.setData(Uri.parse(intent.toUri(Intent.URI_INTENT_SCHEME)));

                    RemoteViews removeViews = new RemoteViews(context.getPackageName(),
                            R.layout.collection_widget_layout);
                    removeViews.setRemoteAdapter(R.id.stack_view, intent);

                    getAppWidgetManager().updateAppWidget(appWidgetId, removeViews);

                    synchronized (mLock) {
                        invocationCounter.incrementAndGet();
                        mLock.notifyAll();
                    }

                    return null;
                }
            }).when(callbacks).onUpdate(any(Context.class), any(AppWidgetManager.class),
                    any(int[].class));
            FirstAppWidgetProvider.setCallbacks(callbacks);

            // Grab the provider to be bound.
            final AppWidgetProviderInfo provider = getFirstAppW"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appwidget/src/android/appwidget/cts/AppWidgetTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appwidget.cts.WidgetTransitionTest"	"grantBindAppWidgetPermission"	"CtsAppWidgetTestCases"	"1: permission"	"([3:/android/appwidget/cts/WidgetTransitionTest.java]:[permission]:[3]:method_text:[ivity, mAppWidgetId, providerInfo);        mActivity.setContentView(mAppWidgetHostView);    }   ]) :|: /*
 *.
 */
package android.appwidget.cts;

import static android.view.View.FIND_VIEWS_WITH_TEXT;

import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import android.app.PendingIntent;
import android.app.SharedElementCallback;
import android.appwidget.AppWidgetHost;
import android.appwidget.AppWidgetHostView;
import android.appwidget.AppWidgetManager;
import android.appwidget.AppWidgetProviderInfo;
import android.appwidget.cts.activity.EmptyActivity;
import android.appwidget.cts.activity.TransitionActivity;
import android.appwidget.cts.service.MyAppWidgetService;
import android.content.Context;
import android.content.Intent;
import android.graphics.Rect;
import android.net.Uri;
import android.platform.test.annotations.AppModeFull;
import android.util.ArrayMap;
import android.view.View;
import android.view.ViewTreeObserver.OnGlobalLayoutListener;
import android.widget.ListView;
import android.widget.RemoteViews;
import android.widget.RemoteViewsService;

import androidx.test.filters.LargeTest;
import androidx.test.rule.ActivityTestRule;
import androidx.test.runner.AndroidJUnit4;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.function.Predicate;

/**
 * Test AppWidgets transitions.
 */
@LargeTest
@AppModeFull
@RunWith(AndroidJUnit4.class)
public class WidgetTransitionTest extends AppWidgetTestCase {

    private static final String CLICK_ACTION = WidgetTransitionTest.class.getSimpleName();

    @Rule
    public ActivityTestRule<EmptyActivity"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appwidget/src/android/appwidget/cts/WidgetTransitionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appwidget.cts.DarkTextThemeTest"	"grantBindAppWidgetPermission"	"CtsAppWidgetTestCases"	"1: permission"	"([3:/android/appwidget/cts/DarkTextThemeTest.java]:[permission]:[3]:method_text:[ivity, mAppWidgetId, providerInfo);        mActivity.setContentView(mAppWidgetHostView);    }   ]) :|: /*
 *.
 */
package android.appwidget.cts;

import static android.view.View.FIND_VIEWS_WITH_TEXT;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import android.appwidget.AppWidgetHost;
import android.appwidget.AppWidgetHostView;
import android.appwidget.AppWidgetManager;
import android.appwidget.AppWidgetProviderInfo;
import android.appwidget.cts.activity.EmptyActivity;
import android.appwidget.cts.service.MyAppWidgetService;
import android.content.Context;
import android.content.Intent;
import android.graphics.Color;
import android.graphics.drawable.ColorDrawable;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.platform.test.annotations.AppModeFull;
import android.util.ArrayMap;
import android.view.View;
import android.view.ViewTreeObserver.OnGlobalLayoutListener;
import android.widget.ListView;
import android.widget.RemoteViews;
import android.widget.RemoteViewsService;

import androidx.test.filters.LargeTest;
import androidx.test.rule.ActivityTestRule;
import androidx.test.runner.AndroidJUnit4;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.ArrayList;
import java.util.concurrent.CountDownLatch;
import java.util.function.Predicate;

/**
 * Test AppWidgets dark text theme
 */
@LargeTest
@AppModeFull
@RunWith(AndroidJUnit4.class)
public class DarkTextThemeTest extends AppWidgetTestCase {

    @Rule
    public ActivityTestRule<EmptyActivity> mActivityRule =
            new ActivityTestRule<>(EmptyActivity.class);

    private boolean mHasAppWidgets;

    private EmptyActivity mActivity;

    private AppWidgetHost mAppWidgetHost;

    private MyHostView mAppWidgetHostView;
    private int mAppWidgetId;

    @Before
    public"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appwidget/src/android/appwidget/cts/DarkTextThemeTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.appwidget.cts.CollectionAppWidgetTest"	"grantBindAppWidgetPermission"	"CtsAppWidgetTestCases"	"1: permission"	"([3:/android/appwidget/cts/CollectionAppWidgetTest.java]:[permission]:[3]:method_text:[nAppWidgetProvider.class.getName());        return getProviderInfo(firstComponentName);    }   ]) :|: /*
 *.
 */
package android.appwidget.cts;

import static android.appwidget.cts.provider.CollectionAppWidgetProvider.BROADCAST_ACTION;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import android.app.Instrumentation;
import android.appwidget.AppWidgetHost;
import android.appwidget.AppWidgetHostView;
import android.appwidget.AppWidgetManager;
import android.appwidget.AppWidgetProviderInfo;
import android.appwidget.cts.activity.EmptyActivity;
import android.appwidget.cts.provider.CollectionAppWidgetProvider;
import android.appwidget.cts.service.MyAppWidgetService;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.platform.test.annotations.AppModeFull;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AbsListView;
import android.widget.CompoundButton;
import android.widget.ListView;
import android.widget.RemoteViews;
import android.widget.RemoteViewsService;
import android.widget.StackView;

import androidx.test.InstrumentationRegistry;
import androidx.test.filters.LargeTest;
import androidx.test.rule.ActivityTestRule;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.PollingCheck;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.invocation.InvocationOnMock;
import org.mockito.stubbing.Answer;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Predicate;

/**
 * Test AppWid"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/appwidget/src/android/appwidget/cts/CollectionAppWidgetTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.carrierapi.cts.NetworkScanApiTest"	"werePreconditionsSatisfied"	"CtsCarrierApiTestCases"	"1: permission"	"([10:/android/carrierapi/cts/NetworkScanApiTest.java]:[permission]:[10]:method_text:[ radioAccessSpecifier;    }    /** Tests that the device properly requests a network scan. */   ]) :|: /*
 *.
 */
package android.carrierapi.cts;

import static android.Manifest.permission.ACCESS_BACKGROUND_LOCATION;
import static android.Manifest.permission.ACCESS_FINE_LOCATION;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.fail;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.location.LocationManager;
import android.os.AsyncTask;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Message;
import android.os.Parcel;
import android.os.Process;
import android.os.UserHandle;
import android.telephony.AccessNetworkConstants;
import android.telephony.CellInfo;
import android.telephony.CellInfoGsm;
import android.telephony.CellInfoLte;
import android.telephony.CellInfoWcdma;
import android.telephony.NetworkScan;
import android.telephony.NetworkScanRequest;
import android.telephony.RadioAccessSpecifier;
import android.telephony.TelephonyManager;
import android.telephony.TelephonyScanManager;
import android.util.Log;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

/**
 * Unit tests for {@link TelephonyManager}'s network scan APIs.
 *
 * <p>Test using `atest CtsCarrierApiTestCases:NetworkScanApiTest` or `make cts -j64 && cts-tradefed
 * run cts -m CtsCarrierApiTestCases --test android.carrierapi.cts.NetworkScanApiTest`
 */
@RunWith(AndroidJUnit4.class)
public class NetworkScanApiTest extends BaseCarrierApiTest {
    priva"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/carrierapi/src/android/carrierapi/cts/NetworkScanApiTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.carrierapi.cts.NetworkScanApiTest"	"testRequestNetworkScanLocationOffFail"	"CtsCarrierApiTestCases"	"1: permission"	"([2:/android/carrierapi/cts/NetworkScanApiTest.java]:[permission]:[2]:method_text:[InfoCallback was interrupted: "" + ex);        }        return resultsCallback.cellInfo;    }   ]) :|: 
    public void testRequestNetworkScanLocationOffFail() {
        requestNetworkScanLocationOffHelper(true, true);
    }

    public void requestNetworkScanLocationOffHelper(
            boolean includeBandsAndChannels, boolean useSpecialScanPermission) {
        mNetworkScanRequest = buildNetworkScanRequest(includeBandsAndChannels);

        boolean isLocationSwitchOn = getAndSetLocationSwitch(false);
        try {
            mNetworkScanCallback = new NetworkScanCallbackImpl();
            Message startNetworkScan =
                    mHandler.obtainMessage(EVENT_NETWORK_SCAN_START, useSpecialScanPermission);
            setReady(false);
            startNetworkScan.sendToTarget();
            waitUntilReady();
            if (includeBandsAndChannels) {
                // If we included the bands when location is off, expect a security error and
                // nothing else.
                assertThat(mNetworkScanStatus).isEqualTo(EVENT_SCAN_DENIED);
                return;
            }

            Log.d(TAG, ""mNetworkScanStatus: "" + mNetworkScanStatus);
            assertWithMessage(
                            ""The final scan status is ""
                                    + mNetworkScanStatus
                                    + "" with error code ""
                                    + mErrorCode
                                    + "", not ScanCompleted""
                                    + "" or ScanError with an error code ERROR_MODEM_UNAVAILABLE or""
                                    + "" ERROR_UNSUPPORTED"")
                    .that(isScanStatusValid())
                    .isTrue();
        } finally {
            getAndSetLocationSwitch(isLocationSwitchOn);
        }
    }

    private NetworkScanRequest buildNetworkScanRequest(boolean includeBandsAndChannels) {
        // Make sure that there should be at least one entry.
        List<CellInfo> allCellInfo = getCellInfo();
        List<RadioAccessSpecifier> radioAccessSpecifier = new ArrayList<"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/carrierapi/src/android/carrierapi/cts/NetworkScanApiTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.carrierapi.cts.NetworkScanApiTest"	"testNetworkScanPermission"	"CtsCarrierApiTestCases"	"1: permission"	"([6:/android/carrierapi/cts/NetworkScanApiTest.java]:[permission]:[6]:method_text:[cs.add(""310120"");        return mccMncs;    }    /** To test its constructor and getters. */   ]) :|: 
    public void testNetworkScanPermission() {
        PackageManager pm = getContext().getPackageManager();

        List<Integer> specialUids =
                Arrays.asList(Process.SYSTEM_UID, Process.PHONE_UID, Process.SHELL_UID);

        List<PackageInfo> holding =
                pm.getPackagesHoldingPermissions(
                        new String[] {NETWORK_SCAN_PERMISSION},
                        PackageManager.MATCH_DISABLED_COMPONENTS);

        List<Integer> nonSpecialPackages =
                holding.stream()
                        .map(
                                pi -> {
                                    try {
                                        return pm.getPackageUid(pi.packageName, 0);
                                    } catch (PackageManager.NameNotFoundException e) {
                                        return Process.INVALID_UID;
                                    }
                                })
                        .filter(uid -> !specialUids.contains(UserHandle.getAppId(uid)))
                        .collect(Collectors.toList());

        assertWithMessage(
                        ""Only one app on the device is allowed to hold the NETWORK_SCAN""
                                + "" permission."")
                .that(nonSpecialPackages.size())
                .isAtMost(1);
    }

    private boolean getAndSetLocationSwitch(boolean enabled) {
        CountDownLatch locationChangeLatch = new CountDownLatch(1);
        BroadcastReceiver locationModeChangeReceiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                if (LocationManager.MODE_CHANGED_ACTION.equals(intent.getAction())
                        && intent.getBooleanExtra(LocationManager.EXTRA_LOCATION_ENABLED, !enabled)
                        == enabled) {
                    locationChangeLatch.countDown();
                }
            }
        };

        InstrumentationRegistr"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/carrierapi/src/android/carrierapi/cts/NetworkScanApiTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.carrierapi.cts.CarrierApiTest"	"testUpdateAvailableNetworksWithCarrierPrivilege"	"CtsCarrierApiTestCases"	"1: permission"	"([1:/android/carrierapi/cts/CarrierApiTest.java]:[permission]:[1]:method_text:[eption e) {            Log.d(TAG, ""InterruptedException while waiting: "" + e);        }    }   ]) :|: 
    public void testUpdateAvailableNetworksWithCarrierPrivilege() {
        int subIdWithCarrierPrivilege = getFirstActivateCarrierPrivilegedSubscriptionId();
        int activeSubscriptionInfoCount =
                ShellIdentityUtils.invokeMethodWithShellPermissions(
                        mSubscriptionManager, (tm) -> tm.getActiveSubscriptionInfoCount());
        if (mTelephonyManager.getPhoneCount() == 1) {
            return;
        }

        /* TODO: b/145993690 */
        if (mTelephonyManager.getPhoneCount() == 2 && activeSubscriptionInfoCount != 2) {
            /* This test requires two SIM cards */
            return;
        }
        if (subIdWithCarrierPrivilege == SubscriptionManager.INVALID_SUBSCRIPTION_ID) {
            /* This test requires SIM with carrier privilege */
            return;
        }

        List<SubscriptionInfo> subscriptionInfoList =
                mSubscriptionManager.getOpportunisticSubscriptions();
        List<String> mccMncs = new ArrayList<String>();
        List<Integer> bands = new ArrayList<Integer>();
        List<AvailableNetworkInfo> availableNetworkInfos = new ArrayList<AvailableNetworkInfo>();
        Consumer<Integer> callbackSuccess = CarrierApiTest::assertUpdateAvailableNetworkSuccess;
        Consumer<Integer> callbackNoOpportunisticSubAvailable =
                CarrierApiTest::assertUpdateAvailableNetworkNoOpportunisticSubAvailable;
        Consumer<Integer> setOpCallbackSuccess = CarrierApiTest::assertSetOpportunisticSubSuccess;
        if (subscriptionInfoList == null
                || subscriptionInfoList.size() == 0
                || !mSubscriptionManager.isActiveSubscriptionId(
                        subscriptionInfoList.get(0).getSubscriptionId())) {
            try {
                AvailableNetworkInfo availableNetworkInfo =
                        new AvailableNetworkInfo(
                                subIdWithCarrierPrivilege,
                                AvailableNetworkInfo.PRIORITY_"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/carrierapi/src/android/carrierapi/cts/CarrierApiTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.carrierapi.cts.CarrierApiTest"	"testGetNetworkSelectionMode"	"CtsCarrierApiTestCases"	"1: permission"	"([1:/android/carrierapi/cts/CarrierApiTest.java]:[permission]:[1]:method_text:[SecurityException e) {            fail(NO_CARRIER_PRIVILEGES_FAILURE_MESSAGE);        }    }   ]) :|: 
    public void testGetNetworkSelectionMode() throws Exception {
        try {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(
                    mTelephonyManager, (tm) -> tm.setNetworkSelectionModeAutomatic());
            int networkMode = mTelephonyManager.getNetworkSelectionMode();
            assertThat(networkMode).isEqualTo(TelephonyManager.NETWORK_SELECTION_MODE_AUTO);
        } catch (SecurityException e) {
            fail(NO_CARRIER_PRIVILEGES_FAILURE_MESSAGE);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/carrierapi/src/android/carrierapi/cts/CarrierApiTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.carrierapi.cts.CarrierApiTest"	"testAddSubscriptionToExistingGroupForMultipleSims"	"CtsCarrierApiTestCases"	"1: permission"	"([4:/android/carrierapi/cts/CarrierApiTest.java]:[permission]:[4]:method_text:[ng group.     *     * <p>This test required the device has more than one subscription.     */   ]) :|: 
    public void testAddSubscriptionToExistingGroupForMultipleSims() {
        if (mTelephonyManager.getPhoneCount() < DSDS_PHONE_COUNT
                || mSubscriptionManager.getActiveSubscriptionInfoList().size() < DSDS_PHONE_COUNT) {
            // This test requires at least two active subscriptions.
            return;
        }

        // Set subscription group with current sub Id.
        int subId = SubscriptionManager.getDefaultDataSubscriptionId();
        if (subId == SubscriptionManager.INVALID_SUBSCRIPTION_ID) return;
        ParcelUuid uuid = ShellIdentityUtils.invokeMethodWithShellPermissions(mSubscriptionManager,
                (sm) -> sm.createSubscriptionGroup(Arrays.asList(subId)));

        try {
            // Get all active subscriptions.
            List<SubscriptionInfo> activeSubInfos =
                    ShellIdentityUtils.invokeMethodWithShellPermissions(mSubscriptionManager,
                    (sm) -> sm.getActiveSubscriptionInfoList());

            List<Integer> activeSubGroup = getSubscriptionIdList(activeSubInfos);
            activeSubGroup.removeIf(id -> id == subId);

            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mSubscriptionManager,
                    (sm) -> sm.addSubscriptionsIntoGroup(activeSubGroup, uuid));

            List<Integer> infoList = ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mSubscriptionManager,
                    (sm) -> getSubscriptionIdList(sm.getSubscriptionsInGroup(uuid)));

            activeSubGroup.add(subId);
            assertThat(infoList).containsExactlyElementsIn(activeSubGroup);
        } finally {
            removeSubscriptionsFromGroup(uuid);
        }
    }

    /**
     * This test verifies that {@link SubscriptionManager#addSubscriptionsIntoGroup(List,
     * ParcelUuid)}} correctly add some additional subscriptions to the existing group.
     *
     * <p>This test required the device has more than one subscription.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/carrierapi/src/android/carrierapi/cts/CarrierApiTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.carrierapi.cts.CarrierApiTest"	"testSendEnvelopeWithStatus"	"CtsCarrierApiTestCases"	"1: permission"	"([1:/android/carrierapi/cts/CarrierApiTest.java]:[permission]:[1]:method_text:[ithout {@link     * android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}.     */   ]) :|: 
    public void testSendEnvelopeWithStatus() {
        // STATUS apdu as hex String
        String envelope =
                CLA_STATUS_STRING
                        + COMMAND_STATUS_STRING
                        + ""00"" // p1: no indication of application status
                        + ""00""; // p2: identical parameters to
        String response = mTelephonyManager.sendEnvelopeWithStatus(envelope);

        // TODO(b/137963715): add more specific assertions on response from TelMan#sendEnvelope
        assertWithMessage(""sendEnvelopeWithStatus is null for envelope=%s"", envelope)
                .that(response)
                .isNotNull();
    }

    /**
     * This test checks that applications with carrier privilege can set/clear signal strength
     * update request via {@link
     * TelephonyManager#setSignalStrengthUpdateRequest(SignalStrengthUpdateRequest)} and {@link
     * TelephonyManager#clearSignalStrengthUpdateRequest} without {@link
     * android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/carrierapi/src/android/carrierapi/cts/CarrierApiTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.carrierapi.cts.CarrierApiTest"	"testSetClearSignalStrengthUpdateRequest"	"CtsCarrierApiTestCases"	"1: permission"	"([3:/android/carrierapi/cts/CarrierApiTest.java]:[permission]:[3]:method_text:[ruptedException {            return mReceiveLatch.await(30, TimeUnit.SECONDS);        }    }   ]) :|: 
    public void testSetClearSignalStrengthUpdateRequest() {
        final SignalStrengthUpdateRequest request =
                new SignalStrengthUpdateRequest.Builder()
                        .setSignalThresholdInfos(
                                List.of(
                                        new SignalThresholdInfo.Builder()
                                                .setRadioAccessNetworkType(
                                                        AccessNetworkConstants.AccessNetworkType
                                                                .GERAN)
                                                .setSignalMeasurementType(
                                                        SignalThresholdInfo
                                                                .SIGNAL_MEASUREMENT_TYPE_RSSI)
                                                .setThresholds(new int[] {-113, -103, -97, -51})
                                                .build()))
                        .setReportingRequestedWhileIdle(true)
                        .build();
        try {
            mTelephonyManager.setSignalStrengthUpdateRequest(request);
        } finally {
            mTelephonyManager.clearSignalStrengthUpdateRequest(request);
        }
    }

    private void verifyValidIccOpenLogicalChannelResponse(IccOpenLogicalChannelResponse response) {
        // The assigned channel should be between the min and max allowed channel numbers
        int channel = response.getChannel();
        assertThat(channel).isIn(Range.closed(MIN_LOGICAL_CHANNEL, MAX_LOGICAL_CHANNEL));
        assertThat(response.getStatus()).isEqualTo(STATUS_NO_ERROR);
        assertThat(response.getSelectResponse()).isEqualTo(STATUS_NORMAL);
    }

    private void removeSubscriptionsFromGroup(ParcelUuid uuid) {
        List<SubscriptionInfo> infoList = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mSubscriptionManager,
                (sm) -> (sm.getSubscriptionsInGroup("	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/carrierapi/src/android/carrierapi/cts/CarrierApiTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission4.cts.CameraMicIndicatorsPermissionTest.kt"	"DisableAnimationRule"	"CtsPermission4TestCases"	"1: permission"	"([12:/android/permission4/cts/CameraMicIndicatorsPermissionTest.kt]:[permission]:[12]:method_text:[a(USE_HOTWORD, useHotword)            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)        })    }   ]) :|: /*
 *.
 */
package android.permission4.cts

import android.Manifest
import android.app.Instrumentation
import android.app.UiAutomation
import android.app.compat.CompatChanges
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.hardware.camera2.CameraManager
import android.os.Process
import android.provider.DeviceConfig
import android.provider.Settings
import android.server.wm.WindowManagerStateHelper
import android.support.test.uiautomator.By
import android.support.test.uiautomator.UiDevice
import android.support.test.uiautomator.UiSelector
import androidx.test.platform.app.InstrumentationRegistry
import com.android.compatibility.common.util.DisableAnimationRule
import com.android.compatibility.common.util.SystemUtil.*
import org.junit.After
import org.junit.Assert.*
import org.junit.Assume.assumeFalse
import org.junit.Assume.assumeTrue
import org.junit.Before
import org.junit.Rule
import org.junit.Test

private const val APP_LABEL = ""CtsCameraMicAccess""
private const val USE_CAMERA = ""use_camera""
private const val USE_MICROPHONE = ""use_microphone""
private const val USE_HOTWORD = ""use_hotword""
private const val INTENT_ACTION = ""test.action.USE_CAMERA_OR_MIC""
private const val PRIVACY_CHIP_ID = ""com.android.systemui:id/privacy_chip""
private const val INDICATORS_FLAG = ""camera_mic_icons_enabled""
private const val PERMISSION_INDICATORS_NOT_PRESENT = 162547999L
private const val IDLE_TIMEOUT_MILLIS: Long = 1000
private const val UNEXPECTED_TIMEOUT_MILLIS = 1000
private const val TIMEOUT_MILLIS: Long = 20000
private const val TV_MIC_INDICATOR_WINDOW_TITLE = ""MicrophoneCaptureIndicator""

class CameraMicIndicatorsPermissionTest {
    private val instrumentation: Instrumentation = InstrumentationRegistry.getInstrumentation()
    private val context: Context = instrumentation.context
    private val uiAutomation: UiAutomation = instrumentation.uiAutomation
    private val uiDevice: UiDevice = UiDevice.getInstan"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission4/src/android/permission4/cts/CameraMicIndicatorsPermissionTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.time.cts.TimeManagerTest"	"AdoptShellPermissionsRule"	"CtsTimeTestCases"	"1: permission"	"([5:/android/app/time/cts/TimeManagerTest.java]:[permission]:[5]:method_text:[ener}, makes changes     * to the configuration and checks that the listener is called.     */   ]) :|: /*
 *.
 */

package android.app.time.cts;

import static android.app.time.cts.shell.DeviceConfigKeys.NAMESPACE_SYSTEM_TIME;
import static android.app.time.cts.shell.DeviceConfigShellHelper.SYNC_DISABLED_MODE_UNTIL_REBOOT;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import android.app.Instrumentation;
import android.app.time.Capabilities;
import android.app.time.ExternalTimeSuggestion;
import android.app.time.TimeManager;
import android.app.time.TimeZoneCapabilities;
import android.app.time.TimeZoneCapabilitiesAndConfig;
import android.app.time.TimeZoneConfiguration;
import android.app.time.cts.shell.DeviceConfigKeys;
import android.app.time.cts.shell.DeviceConfigShellHelper;
import android.app.time.cts.shell.DeviceShellCommandExecutor;
import android.app.time.cts.shell.device.InstrumentationShellCommandExecutor;
import android.content.Context;
import android.location.LocationManager;
import android.os.SystemClock;
import android.os.UserHandle;

import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.AdoptShellPermissionsRule;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicInteger;

/** In-process tests for {@link TimeManager} and associated classes. */
public class TimeManagerTest {

    /**
     * This rule adopts the Shell process permissions, needed because MANAGE_TIME_AND_ZONE_DETECTION
     * and SUGGEST_EXTERNAL_TIME required by {@link TimeManager} are privileged permissions.
     */
    @Rule
    public final AdoptShellPermissionsRule shellPermRule = new AdoptShellPermissionsRule();

    private DeviceConfigShellHelper mDeviceConfigShellHelper"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/time/src/android/app/time/cts/TimeManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.shortcutmanager.ShortcutManagerSpoofingTest"	"testSpoofingLauncher"	"CtsShortcutManagerTestCases"	"1: permission"	"([3:/android/content/pm/cts/shortcutmanager/ShortcutManagerSpoofingTest.java]:[permission]:[3]:method_text:[       );        assertCallbackNotReceived(c0_1);        assertCallbackNotReceived(c0_3);    }}]) :|: public void testSpoofingLauncher() {
        final LauncherApps.Callback c0_1 = mock(LauncherApps.Callback.class);
        final LauncherApps.Callback c0_2 = mock(LauncherApps.Callback.class);
        final LauncherApps.Callback c0_3 = mock(LauncherApps.Callback.class);
        final Handler h = new Handler(Looper.getMainLooper());

        runWithCaller(mLauncherContext1, () -> getLauncherApps().registerCallback(c0_1, h));
        runWithCaller(mLauncherContext2, () -> getLauncherApps().registerCallback(c0_2, h));
        runWithCaller(mLauncherContext3, () -> getLauncherApps().registerCallback(c0_3, h));

        // Change the default launcher
        setDefaultLauncher(getInstrumentation(), mLauncherContext2);

        dumpsysShortcut(getInstrumentation());

        runWithCaller(mLauncherContext1,
                () -> assertFalse(getLauncherApps().hasShortcutHostPermission()));
        runWithCaller(mLauncherContext2,
                () -> assertTrue(getLauncherApps().hasShortcutHostPermission()));
        runWithCaller(mLauncherContext3,
                () -> assertFalse(getLauncherApps().hasShortcutHostPermission()));

        // Call a publisher API and make sure only launcher2 gets it.

        resetAll(list(c0_1, c0_2, c0_3));

        runWithCaller(mPackageContext1, () -> {
            ShortcutInfo s1 = makeShortcut(""s1"", ""title1"");
            getManager().setDynamicShortcuts(list(s1));
        });

        // Because of the handlers, callback calls are not synchronous.
        waitUntil(""Launcher 2 didn't receive message"", () ->
                checkAssertSuccess(() ->
                        assertCallbackReceived(c0_2, android.os.Process.myUserHandle(),
                                mPackageContext1.getPackageName(), ""s1"")
                )
        );

        assertCallbackNotReceived(c0_1);
        assertCallbackNotReceived(c0_3);
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/shortcutmanager/src/android/content/pm/cts/shortcutmanager/ShortcutManagerSpoofingTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.shortcutmanager.ShortcutManagerSpoofDetectionTest"	"testLauncherSpoofing"	"CtsShortcutManagerTestCases"	"1: permission"	"([2:/android/content/pm/cts/shortcutmanager/ShortcutManagerSpoofDetectionTest.java]:[permission]:[2]:method_text:[ntext1.getPackageName(), ""s1"",                    null, null, getUserHandle());        });    }}]) :|: public void testLauncherSpoofing() {
        assertCallingPackageMismatch(""hasShortcutHostPermission"", mLauncherContext4, () -> {
            getLauncherApps().hasShortcutHostPermission();
        });

        assertCallingPackageMismatch(""registerCallback"", mLauncherContext4, () -> {
            final LauncherApps.Callback c = mock(LauncherApps.Callback.class);
            getLauncherApps().registerCallback(c, new Handler(Looper.getMainLooper()));
        });

        assertCallingPackageMismatch(""getShortcuts"", mLauncherContext4, () -> {
            ShortcutQuery q = new ShortcutQuery();
            getLauncherApps().getShortcuts(q, getUserHandle());
        });

        assertCallingPackageMismatch(""pinShortcuts"", mLauncherContext4, () -> {
            getLauncherApps().pinShortcuts(
                    mPackageContext1.getPackageName(), list(), getUserHandle());
        });

        assertCallingPackageMismatch(""startShortcut 1"", mLauncherContext4, () -> {
            getLauncherApps().startShortcut(makeShortcut(""s""), null, null);
        });
        assertCallingPackageMismatch(""startShortcut 2"", mLauncherContext4, () -> {
            getLauncherApps().startShortcut(mPackageContext1.getPackageName(), ""s1"",
                    null, null, getUserHandle());
        });
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/shortcutmanager/src/android/content/pm/cts/shortcutmanager/ShortcutManagerSpoofDetectionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.shortcutmanager.ShortcutManagerUsageTest"	"testReportShortcutUsed"	"CtsShortcutManagerTestCases"	"1: permission"	"([1:/android/content/pm/cts/shortcutmanager/ShortcutManagerUsageTest.java]:[permission]:[1]:method_text:[ents(start3, end3)),                mPackageContext1.getPackageName(), idNonexistance));    }   ]) :|: public void testReportShortcutUsed() throws InterruptedException {

        runWithCallerWithStrictMode(mPackageContext1, () -> {
            enableManifestActivity(""Launcher_manifest_2"", true);

            retryUntil(() -> getManager().getManifestShortcuts().size() > 0,
                    ""Manifest shortcuts didn't show up"");
        });

        final String id1 = generateRandomId(""id1"");
        final String id2 = generateRandomId(""id2"");
        final String id3 = generateRandomId(""id3"");

        final String idManifest = ""ms21"";
        final String idNonexistance = ""nonexistence"";

        runWithCallerWithStrictMode(mPackageContext1, () -> {
            assertTrue(getManager().setDynamicShortcuts(list(
                    makeShortcut(id1),
                    makeShortcut(id2)
            )));
        });
        runWithCallerWithStrictMode(mPackageContext2, () -> {
            assertTrue(getManager().setDynamicShortcuts(list(
                    makeShortcut(id1),
                    makeShortcut(id3)
            )));
        });

        // Report usage.
        final long start1 = System.currentTimeMillis() - USAGE_STATS_RANGE_ALLOWANCE;
        runWithCallerWithStrictMode(mPackageContext2, () -> getManager().reportShortcutUsed(id3));
        final long end1 = System.currentTimeMillis() + USAGE_STATS_RANGE_ALLOWANCE;

        // Check the log.
        checkEventReported(start1, end1, mPackageContext2, id3, ""Events weren't populated"");

        // Report usage.
        final long start2 = System.currentTimeMillis() - USAGE_STATS_RANGE_ALLOWANCE;
        runWithCallerWithStrictMode(mPackageContext1, () -> getManager().reportShortcutUsed(id1));
        final long end2 = System.currentTimeMillis() + USAGE_STATS_RANGE_ALLOWANCE;

        // Check the log.
        checkEventReported(start2, end2, mPackageContext1, id1, ""Events weren't populated"");

        // Report usage.
        final long start3 = System.currentTimeMillis() - USAGE_STATS_RANGE_ALLOWANCE;"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/shortcutmanager/src/android/content/pm/cts/shortcutmanager/ShortcutManagerUsageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.shortcutmanager.ShortcutManagerUsageTest"	"testShortcutInvocationEventIsNotVisible"	"CtsShortcutManagerTestCases"	"1: permission"	"([1:/android/content/pm/cts/shortcutmanager/ShortcutManagerUsageTest.java]:[permission]:[1]:method_text:[yEvents(start, end)), packageContext.getPackageName(), id),                failureMessage);    }}]) :|: public void testShortcutInvocationEventIsNotVisible() {
        final String id1 = generateRandomId(""id1"");
        final String id2 = generateRandomId(""id2"");
        runWithCallerWithStrictMode(mPackageContext1,
                () -> assertTrue(getManager().setDynamicShortcuts(
                        list(makeShortcut(id1), makeShortcut(id2)))));

        // report shortcut usage
        final long start = System.currentTimeMillis() - USAGE_STATS_RANGE_ALLOWANCE;
        runWithCallerWithStrictMode(mPackageContext1, () -> getManager().reportShortcutUsed(id1));
        final long end = System.currentTimeMillis() + USAGE_STATS_RANGE_ALLOWANCE;

        // SHORTCUT_INVOCATION event should not be visible
        assertFalse(""SHORTCUT_INVOCATION event was visible."",
                hasEvent(mUsageStatsManager.queryEvents(start, end),
                        mPackageContext1.getPackageName(), id1));
    }

    private void checkEventReported(long start, long end, Context packageContext, String id,
            String failureMessage) {
        retryUntil(() -> hasEvent(
                ShellIdentityUtils.invokeMethodWithShellPermissions(mUsageStatsManager,
                        (usm) -> usm.queryEvents(start, end)), packageContext.getPackageName(), id),
                failureMessage);
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/shortcutmanager/src/android/content/pm/cts/shortcutmanager/ShortcutManagerUsageTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.content.pm.cts.shortcutmanager.ShortcutManagerMultiLauncherTest"	"testPinShortcuts"	"CtsShortcutManagerTestCases"	"1: permission"	"([1:/android/content/pm/cts/shortcutmanager/ShortcutManagerMultiLauncherTest.java]:[permission]:[1]:method_text:[text2.getPackageName()))                    .haveIds(""s1"", ""s2"", ""s3"", ""ms32"");        });    }}]) :|: public void testPinShortcuts() {
        runWithCaller(mPackageContext1, () -> {
            enableManifestActivity(""Launcher_manifest_1"", true);
            enableManifestActivity(""Launcher_manifest_2"", true);

            retryUntil(() -> getManager().getManifestShortcuts().size() == 3,
                    ""Manifest shortcuts didn't show up"");

            assertTrue(getManager().setDynamicShortcuts(list(
                    makeShortcut(""s1""),
                    makeShortcut(""s2""),
                    makeShortcut(""s3""),
                    makeShortcut(""s4""),
                    makeShortcut(""s5"")
            )));
            assertWith(getManager().getDynamicShortcuts())
                    .haveIds(""s1"", ""s2"", ""s3"", ""s4"", ""s5"")
                    .areAllDynamic()
                    .areAllEnabled();
            assertWith(getManager().getManifestShortcuts())
                    .haveIds(""ms1"", ""ms21"", ""ms22"")
                    .areAllManifest()
                    .areAllEnabled();
        });
        runWithCaller(mPackageContext2, () -> {
            enableManifestActivity(""Launcher_manifest_1"", true);
            enableManifestActivity(""Launcher_manifest_3"", true);

            retryUntil(() -> getManager().getManifestShortcuts().size() == 3,
                    ""Manifest shortcuts didn't show up"");

            assertTrue(getManager().setDynamicShortcuts(list(
                    makeShortcut(""s1""),
                    makeShortcut(""s2""),
                    makeShortcut(""s3""),
                    makeShortcut(""s4""),
                    makeShortcut(""s5"")
            )));
            assertWith(getManager().getDynamicShortcuts())
                    .haveIds(""s1"", ""s2"", ""s3"", ""s4"", ""s5"")
                    .areAllDynamic()
                    .areAllEnabled();
            assertWith(getManager().getManifestShortcuts())
                    .haveIds(""ms1"", ""ms31"", ""ms32"")
                    .areAllManifest()
                    .areAllEnabled();"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/shortcutmanager/src/android/content/pm/cts/shortcutmanager/ShortcutManagerMultiLauncherTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.ConnectedNetworkScorerTest"	"isNotNull"	"CtsWifiTestCases"	"1: permission"	"([12:/android/net/wifi/cts/ConnectedNetworkScorerTest.java]:[permission]:[12]:method_text:[ilityStatsEntry} retrieved from     * {@link WifiManager.OnWifiUsabilityStatsListener}.     */   ]) :|: /*
 *.
 */

package android.net.wifi.cts;

import static android.Manifest.permission.CONNECTIVITY_INTERNAL;
import static android.Manifest.permission.NETWORK_SETTINGS;
import static android.Manifest.permission.READ_WIFI_CREDENTIAL;
import static android.Manifest.permission.WIFI_UPDATE_USABILITY_STATS_SCORE;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PAID;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PRIVATE;
import static android.net.wifi.WifiUsabilityStatsEntry.ContentionTimeStats;
import static android.net.wifi.WifiUsabilityStatsEntry.RadioStats;
import static android.net.wifi.WifiUsabilityStatsEntry.RateStats;
import static android.net.wifi.WifiUsabilityStatsEntry.PROBE_STATUS_FAILURE;
import static android.net.wifi.WifiUsabilityStatsEntry.PROBE_STATUS_NO_PROBE;
import static android.net.wifi.WifiUsabilityStatsEntry.PROBE_STATUS_SUCCESS;
import static android.net.wifi.WifiUsabilityStatsEntry.PROBE_STATUS_UNKNOWN;
import static android.net.wifi.WifiUsabilityStatsEntry.WME_ACCESS_CATEGORY_BE;
import static android.net.wifi.WifiUsabilityStatsEntry.WME_ACCESS_CATEGORY_BK;
import static android.net.wifi.WifiUsabilityStatsEntry.WME_ACCESS_CATEGORY_VI;
import static android.net.wifi.WifiUsabilityStatsEntry.WME_ACCESS_CATEGORY_VO;
import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import android.annotation.NonNull;
import android.app.UiAutomation;
import android.content.Context;
import android.net.ConnectivityManager;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSpecifier;
import android.net.wifi.WifiNetworkSuggestion;
import android.net.wifi.W"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConnectedNetworkScorerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.ConnectedNetworkScorerTest"	"testWifiUsabilityStatsEntry"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/ConnectedNetworkScorerTest.java]:[permission]:[2]:method_text:[* Tests the {@link android.net.wifi.WifiManager#updateWifiUsabilityScore(int, int, int)}     */   ]) :|: 
    public void testWifiUsabilityStatsEntry() throws Exception {
        // Usability stats collection only supported by vendor version Q and above.
        if (!PropertyUtil.isVendorApiLevelAtLeast(Build.VERSION_CODES.Q)) {
            return;
        }
        CountDownLatch countDownLatch = new CountDownLatch(1);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        TestUsabilityStatsListener usabilityStatsListener =
                new TestUsabilityStatsListener(countDownLatch);
        try {
            uiAutomation.adoptShellPermissionIdentity();
            mWifiManager.addOnWifiUsabilityStatsListener(
                    Executors.newSingleThreadExecutor(), usabilityStatsListener);
            // Wait for new usability stats (while connected & screen on this is triggered
            // by platform periodically).
            assertThat(countDownLatch.await(TIMEOUT, TimeUnit.MILLISECONDS)).isTrue();

            assertThat(usabilityStatsListener.statsEntry).isNotNull();
            WifiUsabilityStatsEntry statsEntry = usabilityStatsListener.statsEntry;

            assertThat(statsEntry.getTimeStampMillis()).isGreaterThan(0L);
            assertThat(statsEntry.getRssi()).isLessThan(0);
            assertThat(statsEntry.getLinkSpeedMbps()).isAtLeast(0);
            assertThat(statsEntry.getTotalTxSuccess()).isAtLeast(0L);
            assertThat(statsEntry.getTotalTxRetries()).isAtLeast(0L);
            assertThat(statsEntry.getTotalTxBad()).isAtLeast(0L);
            assertThat(statsEntry.getTotalRxSuccess()).isAtLeast(0L);
            if (mWifiManager.isEnhancedPowerReportingSupported()) {
                assertThat(statsEntry.getTotalRadioOnTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalRadioTxTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalRadioRxTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalScanTimeMillis()).isAtLeast(0L"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConnectedNetworkScorerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.ConnectedNetworkScorerTest"	"testUpdateWifiUsabilityScore"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/ConnectedNetworkScorerTest.java]:[permission]:[2]:method_text:[#setWifiScoringEnabled(boolean)}     */    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)   ]) :|: 
    public void testUpdateWifiUsabilityScore() throws Exception {
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // update scoring with dummy values.
            mWifiManager.updateWifiUsabilityScore(0, 50, 50);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests the {@link android.net.wifi.WifiManager#setWifiScoringEnabled(boolean)}
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConnectedNetworkScorerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.ConnectedNetworkScorerTest"	"testSetWifiScoringEnabled"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/ConnectedNetworkScorerTest.java]:[permission]:[2]:method_text:[* {@link android.net.wifi.WifiConnectedNetworkScorer#onStart(WifiConnectedSessionInfo)}.     */   ]) :|: 
    public void testSetWifiScoringEnabled() throws Exception {
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            assertTrue(mWifiManager.setWifiScoringEnabled(true));
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    private static abstract class TestConnectedNetworkScorer implements
            WifiManager.WifiConnectedNetworkScorer {
        protected CountDownLatch mCountDownLatch;
        public Integer startSessionId;
        public Integer stopSessionId;
        public WifiManager.ScoreUpdateObserver scoreUpdateObserver;
        public boolean isUserSelected;

        TestConnectedNetworkScorer(CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onStop(int sessionId) {
            synchronized (mCountDownLatch) {
                this.stopSessionId = sessionId;
                mCountDownLatch.countDown();
            }
        }

        @Override
        public void onSetScoreUpdateObserver(WifiManager.ScoreUpdateObserver observerImpl) {
            synchronized (mCountDownLatch) {
                this.scoreUpdateObserver = observerImpl;
            }
        }

        public void resetCountDownLatch(CountDownLatch countDownLatch) {
            synchronized (mCountDownLatch) {
                mCountDownLatch = countDownLatch;
            }
        }
    }

    private static class TestConnectedNetworkScorerWithSessionId extends
            TestConnectedNetworkScorer {
        TestConnectedNetworkScorerWithSessionId(CountDownLatch countDownLatch) {
            super(countDownLatch);
            isUserSelected = false;
        }

        @Override
        public void onStart(int sessionId) {
            synchronized (mCountDownLatch) {
                this.startSessionId = sessionId;
                mCountDow"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConnectedNetworkScorerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.ConnectedNetworkScorerTest"	"testConnectedNetworkScorerWithSessionId"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/ConnectedNetworkScorerTest.java]:[permission]:[2]:method_text:[r works even after wifi restart.     */    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)   ]) :|: 
    public void testConnectedNetworkScorerWithSessionId() throws Exception {
        CountDownLatch countDownLatchScorer = new CountDownLatch(1);
        TestConnectedNetworkScorerWithSessionId connectedNetworkScorer =
                new TestConnectedNetworkScorerWithSessionId(countDownLatchScorer);
        testSetWifiConnectedNetworkScorer(connectedNetworkScorer, countDownLatchScorer);
    }

    /**
     * Note: We could write more interesting test cases (if the device has a mobile connection), but
     * that would make the test flaky. The default network/route selection on the device is not just
     * controlled by the wifi scorer input, but also based on params which are controlled by
     * other parts of the platform (likely in connectivity service) and hence will behave
     * differently on OEM devices.
     */
    private void testSetWifiConnectedNetworkScorer(
            TestConnectedNetworkScorer connectedNetworkScorer,
                    CountDownLatch countDownLatchScorer) throws Exception {
        CountDownLatch countDownLatchUsabilityStats = new CountDownLatch(1);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        TestUsabilityStatsListener usabilityStatsListener =
                new TestUsabilityStatsListener(countDownLatchUsabilityStats);
        boolean disconnected = false;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // Clear any external scorer already active on the device.
            mWifiManager.clearWifiConnectedNetworkScorer();
            Thread.sleep(500);

            mWifiManager.setWifiConnectedNetworkScorer(
                    Executors.newSingleThreadExecutor(), connectedNetworkScorer);
            // Since we're already connected, wait for onStart to be invoked.
            assertThat(countDownLatchScorer.await(TIMEOUT, TimeUnit.MILLISECONDS)).isTrue();

            assertThat(connectedNetworkScorer.startSessionId).isAtLeast(0);"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConnectedNetworkScorerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.ConnectedNetworkScorerTest"	"testSetWifiConnectedNetworkScorerOnSubsystemRestart"	"CtsWifiTestCases"	"1: permission"	"([4:/android/net/wifi/cts/ConnectedNetworkScorerTest.java]:[permission]:[4]:method_text:[  *     * Verifies that the external scorer is not notified for local only connections.     */   ]) :|: 
    public void testSetWifiConnectedNetworkScorerOnSubsystemRestart() throws Exception {
        CountDownLatch countDownLatchScorer = new CountDownLatch(1);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        TestConnectedNetworkScorerWithSessionInfo connectedNetworkScorer =
                new TestConnectedNetworkScorerWithSessionInfo(countDownLatchScorer);
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // Clear any external scorer already active on the device.
            mWifiManager.clearWifiConnectedNetworkScorer();
            Thread.sleep(500);

            mWifiManager.setWifiConnectedNetworkScorer(
                    Executors.newSingleThreadExecutor(), connectedNetworkScorer);
            // Since we're already connected, wait for onStart to be invoked.
            assertThat(countDownLatchScorer.await(TIMEOUT, TimeUnit.MILLISECONDS)).isTrue();

            int prevSessionId = connectedNetworkScorer.startSessionId;
            WifiManager.ScoreUpdateObserver prevScoreUpdateObserver =
                    connectedNetworkScorer.scoreUpdateObserver;

            // Expect one stop followed by one start after the restart

            // Ensure that we got an onStop() for the previous connection when restart is invoked.
            countDownLatchScorer = new CountDownLatch(1);
            connectedNetworkScorer.resetCountDownLatch(countDownLatchScorer);

            // Restart wifi subsystem.
            mWifiManager.restartWifiSubsystem();
            // Wait for the device to connect back.
            PollingCheck.check(
                    ""Wifi not connected"",
                    WIFI_CONNECT_TIMEOUT_MILLIS * 2,
                    () -> mWifiManager.getConnectionInfo().getNetworkId() != -1);

            assertThat(countDownLatchScorer.await(TIMEOUT, TimeUnit.MILLISECONDS)).isTrue();
            assertThat(connectedNetworkScorer.stopSessionId).isEqualTo(prevSessi"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConnectedNetworkScorerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.EasyConnectStatusCallbackTest"	"testConfiguratorInitiatorOnFailure"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/EasyConnectStatusCallbackTest.java]:[permission]:[2]:method_text:[* Since Easy Connect requires 2 devices, start Easy Connect session and expect an error.     */   ]) :|: public void testConfiguratorInitiatorOnFailure() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!mWifiManager.isEasyConnectSupported()) {
            // skip the test if Easy Connect is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            WifiConfiguration config;
            config = new WifiConfiguration();
            config.SSID = TEST_SSID;
            config.preSharedKey = TEST_PASSPHRASE;
            config.setSecurityParams(SECURITY_TYPE_PSK);
            int networkId = mWifiManager.addNetwork(config);
            assertFalse(networkId == -1);
            synchronized (mLock) {
                mWifiManager.startEasyConnectAsConfiguratorInitiator(TEST_DPP_URI, networkId,
                        EASY_CONNECT_NETWORK_ROLE_STA, mExecutor, mEasyConnectStatusCallback);
                // Note: A long delay is necessary because there is no enrollee, and the system
                // tries to discover it. We will wait for a timeout error to occur.
                mLock.wait(TEST_WAIT_DURATION_MS);
            }
            mWifiManager.removeNetwork(networkId);
            assertTrue(mOnFailureCallback);
            assertEquals(EASY_CONNECT_EVENT_FAILURE_TIMEOUT, mErrorCode);
            mWifiManager.stopEasyConnectSession();
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link android.net.wifi.EasyConnectStatusCallback} class.
     *
     * Since Easy Connect requires 2 devices, start Easy Connect session and expect an error.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/EasyConnectStatusCallbackTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.EasyConnectStatusCallbackTest"	"testEnrolleeInitiatorOnFailure"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/EasyConnectStatusCallbackTest.java]:[permission]:[2]:method_text:[sion and expect a     * DPP URI     */    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)   ]) :|: public void testEnrolleeInitiatorOnFailure() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!mWifiManager.isEasyConnectSupported()) {
            // skip the test if Easy Connect is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            synchronized (mLock) {
                mWifiManager.startEasyConnectAsEnrolleeInitiator(TEST_DPP_URI, mExecutor,
                        mEasyConnectStatusCallback);
                // Note: A long delay is necessary because there is no configurator, and the system
                // tries to discover it. We will wait for a timeout error to occur.
                mLock.wait(TEST_WAIT_DURATION_MS);
            }
            assertTrue(mOnFailureCallback);
            assertEquals(EASY_CONNECT_EVENT_FAILURE_TIMEOUT, mErrorCode);
            mWifiManager.stopEasyConnectSession();
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link android.net.wifi.EasyConnectStatusCallback#onBootstrapUriGenerated} callback.
     *
     * Since Easy Connect requires 2 devices, start Easy Connect responder session and expect a
     * DPP URI
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/EasyConnectStatusCallbackTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.EasyConnectStatusCallbackTest"	"testEnrolleeResponderUriGeneration"	"CtsWifiTestCases"	"1: permission"	"([4:/android/net/wifi/cts/EasyConnectStatusCallbackTest.java]:[permission]:[4]:method_text:[h (IllegalArgumentException expected) {}        uiAutomation.dropShellPermissionIdentity();    }}]) :|: public void testEnrolleeResponderUriGeneration() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!mWifiManager.isEasyConnectEnrolleeResponderModeSupported()) {
            // skip the test if Easy Connect Enrollee responder mode is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            synchronized (mLock) {
                assertTrue(mWifiManager.getEasyConnectMaxAllowedResponderDeviceInfoLength()
                        > TEST_DEVICE_INFO.length());
                mWifiManager.startEasyConnectAsEnrolleeResponder(TEST_DEVICE_INFO,
                        EASY_CONNECT_CRYPTOGRAPHY_CURVE_PRIME256V1, mExecutor,
                        mEasyConnectStatusCallback);
                // Wait for supplicant to generate DPP URI and trigger the callback function to
                // provide the generated URI.
                mLock.wait(TEST_WAIT_DURATION_MS);
            }
            assertTrue(mOnBootstrapUriGeneratedCallback);
            mWifiManager.stopEasyConnectSession();
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Test that {@link WifiManager#startEasyConnectAsEnrolleeResponder(String, int, Executor,
     * EasyConnectStatusCallback)} throws illegal argument exception on passing a wrong device
     * info.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)
    public void
           testStartEasyConnectAsEnrolleeResponderThrowsIllegalArgumentExceptionOnWrongDeviceInfo()
           throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!mWifiManager.isEasyConnectEnrolleeResponderMode"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/EasyConnectStatusCallbackTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.TestHelper"	"isEmpty"	"CtsWifiTestCases"	"2: INTERNET permission"	"([10:/android/net/wifi/cts/TestHelper.java]:[permission]:[10]:method_text:[ult.WIFI_BAND_60_GHZ;        } else {            return ScanResult.UNSPECIFIED;        }    }}]) :|: public void test/*
 *.
 */

package android.net.wifi.cts;

import static android.Manifest.permission.CONNECTIVITY_INTERNAL;
import static android.Manifest.permission.NETWORK_SETTINGS;
import static android.net.ConnectivityManager.NetworkCallback.FLAG_INCLUDE_LOCATION_INFO;
import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PAID;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PRIVATE;
import static android.net.NetworkCapabilities.TRANSPORT_WIFI;
import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.fail;

import android.annotation.NonNull;
import android.app.UiAutomation;
import android.content.Context;
import android.net.ConnectivityManager;
import android.net.MacAddress;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.wifi.ScanResult;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSpecifier;
import android.net.wifi.WifiNetworkSuggestion;
import android.os.Build;
import android.os.WorkSource;
import android.support.test.uiautomator.UiDevice;
import android.text.TextUtils;
import android.util.Log;

import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ApiLevelUtil;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Class to hold helper methods that are repeated across wifi CTS tests.
 */
public class TestHelper {
    private static final String TAG = ""WifiTestHelper"";

    private final Context mContext;
    priva"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/TestHelper.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiBackupRestoreTest"	"isNotNull"	"CtsWifiTestCases"	"1: permission"	"([7:/android/net/wifi/cts/WifiBackupRestoreTest.java]:[permission]:[7]:method_text:[     * a no-op, will only ensure that the device does not crash when invoking the API's.     */   ]) :|: /*
 *.
 */

package android.net.wifi.cts;

import static android.content.pm.PackageManager.PERMISSION_GRANTED;
import static android.net.wifi.WifiConfiguration.METERED_OVERRIDE_METERED;
import static android.net.wifi.WifiConfiguration.METERED_OVERRIDE_NONE;
import static android.net.wifi.WifiConfiguration.METERED_OVERRIDE_NOT_METERED;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeTrue;

import android.app.UiAutomation;
import android.content.Context;
import android.net.IpConfiguration;
import android.net.LinkAddress;
import android.net.ProxyInfo;
import android.net.StaticIpConfiguration;
import android.net.Uri;
import android.net.wifi.SoftApConfiguration;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiEnterpriseConfig;
import android.net.wifi.WifiManager;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;
import android.util.Log;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SmallTest;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;
import com.android.compatibility.common.util.ThrowingRunnable;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.DataInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Tests for wifi backup/restore functionality.
 */
@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@SmallTest
@RunWith(AndroidJUnit4.class)
public c"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiBackupRestoreTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiBackupRestoreTest"	"testCanRestoreBackupData"	"CtsWifiTestCases"	"1: permission"	"([6:/android/net/wifi/cts/WifiBackupRestoreTest.java]:[permission]:[6]:method_text:[retrieveSoftApBackupData()} &     * {@link WifiManager#restoreSoftApBackupData(byte[])}     */   ]) :|: 
    public void testCanRestoreBackupData() {
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        WifiConfiguration origNetwork = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();

            // Pick a regular saved network to modify (non-enterprise, non-Passpoint)
            origNetwork = mWifiManager.getConfiguredNetworks().stream()
                    .filter(n -> {
                        boolean canOverrideConfig = mContext.checkPermission(
                                android.Manifest.permission.OVERRIDE_WIFI_CONFIG, -1, n.creatorUid)
                                == PERMISSION_GRANTED;
                        return canOverrideConfig && !isEnterprise(n) && !n.isPasspoint();
                    })
                    .findAny()
                    .orElse(null);
            if (origNetwork == null) {
                Log.e(TAG, ""Need a non-enterprise and non-Passpoint network created by an app ""
                        + ""holding OVERRIDE_WIFI_CONFIG permission to fully evaluate the ""
                        + ""functionality"");
            }

            // Retrieve backup data.
            byte[] backupData = mWifiManager.retrieveBackupData();

            if (origNetwork != null) {
                // Modify the metered bit.
                final String origNetworkSsid = origNetwork.SSID;
                WifiConfiguration modNetwork = new WifiConfiguration(origNetwork);
                flipMeteredOverride(modNetwork);
                int networkId = mWifiManager.updateNetwork(modNetwork);
                assertThat(networkId).isEqualTo(origNetwork.networkId);
                assertThat(mWifiManager.getConfiguredNetworks()
                        .stream()
                        .filter(n -> n.SSID.equals(origNetworkSsid))
                        .findAny()
                        .get().meteredOverride)
                        .isNotEqualTo(origNetwork.meteredOverride);"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiBackupRestoreTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiBackupRestoreTest"	"testCanRestoreSoftApBackupData"	"CtsWifiTestCases"	"1: permission"	"([4:/android/net/wifi/cts/WifiBackupRestoreTest.java]:[permission]:[4]:method_text:[ is deserialized correctly from AOSP     * legacy supplicant/ipconf backup data format.     */   ]) :|: 
    public void testCanRestoreSoftApBackupData() {
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        SoftApConfiguration origSoftApConfig = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();


            // get soft ap configuration and set it back to update configuration to user
            // configuration.
            mWifiManager.setSoftApConfiguration(mWifiManager.getSoftApConfiguration());

            // Retrieve original soft ap config.
            origSoftApConfig = mWifiManager.getSoftApConfiguration();

            // Retrieve backup data.
            byte[] backupData = mWifiManager.retrieveSoftApBackupData();

            // Modify softap config and set it.
            String origSsid = origSoftApConfig.getSsid();
            char lastOrigSsidChar = origSsid.charAt(origSsid.length() - 1);
            String updatedSsid = new StringBuilder(origSsid.substring(0, origSsid.length() - 1))
                    .append((lastOrigSsidChar == 'a' || lastOrigSsidChar == 'A') ? 'b' : 'a')
                    .toString();
            SoftApConfiguration modSoftApConfig = new SoftApConfiguration.Builder(origSoftApConfig)
                    .setSsid(updatedSsid)
                    .build();
            mWifiManager.setSoftApConfiguration(modSoftApConfig);
            // Ensure that it does not match the orig softap config.
            assertThat(mWifiManager.getSoftApConfiguration()).isNotEqualTo(origSoftApConfig);

            // Restore the original backup data & ensure that the orig softap config is restored.
            mWifiManager.restoreSoftApBackupData(backupData);
            assertThat(mWifiManager.getSoftApConfiguration()).isEqualTo(origSoftApConfig);
        } finally {
            if (origSoftApConfig != null) {
                mWifiManager.setSoftApConfiguration(origSoftApConfig);
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiBackupRestoreTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.ScanResultTest"	"isNotNull"	"CtsWifiTestCases"	"1: permission"	"([6:/android/net/wifi/cts/ScanResultTest.java]:[permission]:[6]:method_text:[          mMySync.wait(WAIT_MSEC);        return mMySync.expectedState == expectedState;    }   ]) :|: public void test/*
 *.
 */

package android.net.wifi.cts;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import java.nio.ByteBuffer;
import java.util.List;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.wifi.ScanResult;
import android.net.wifi.ScanResult.InformationElement;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiManager.WifiLock;
import android.platform.test.annotations.AppModeFull;
import android.test.AndroidTestCase;

import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
public class ScanResultTest extends WifiJUnit3TestBase {
    private static class MySync {
        int expectedState = STATE_NULL;
    }

    private WifiManager mWifiManager;
    private WifiLock mWifiLock;
    private static MySync mMySync;
    private boolean mWasVerboseLoggingEnabled;
    private boolean mWasScanThrottleEnabled;

    private static final int STATE_NULL = 0;
    private static final int STATE_WIFI_CHANGING = 1;
    private static final int STATE_WIFI_CHANGED = 2;
    private static final int STATE_START_SCAN = 3;
    private static final int STATE_SCAN_RESULTS_AVAILABLE = 4;
    private static final int STATE_SCAN_FAILURE = 5;

    private static final String TAG = ""WifiInfoTest"";
    private static final int TIMEOUT_MSEC = 6000;
    private static final int WAIT_MSEC = 60;
    private static final int ENABLE_WAIT_MSEC = 10000;
    private static final int SCAN_WAIT_MSEC = 10000;
    private static final int SCAN_MAX_RETRY_COUNT = 6;
    private static final int SCAN_FIND_BSSID_MAX_RETRY_COUNT = 5;
    private static final long SCAN_FIND_BSS"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ScanResultTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.ScanResultTest"	"testScanResultMatchesWifiInfo"	"CtsWifiTestCases"	"1: permission"	"([1:/android/net/wifi/cts/ScanResultTest.java]:[permission]:[1]:method_text:[sidQuoted);        assertThat(currentNetwork.frequency).isEqualTo(wifiInfo.getFrequency());    }}]) :|: public void testScanResultMatchesWifiInfo() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // ensure Wifi is connected
        ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.reconnect());
        PollingCheck.check(
                ""Wifi not connected"",
                WIFI_CONNECT_TIMEOUT_MILLIS,
                () -> mWifiManager.getConnectionInfo().getNetworkId() != -1);

        final WifiInfo wifiInfo = mWifiManager.getConnectionInfo();
        assertThat(wifiInfo).isNotNull();

        ScanResult currentNetwork = null;
        for (int i = 0; i < SCAN_FIND_BSSID_MAX_RETRY_COUNT; i++) {
            scanAndWait();
            final List<ScanResult> scanResults = mWifiManager.getScanResults();
            currentNetwork = scanResults.stream().filter(r -> r.BSSID.equals(wifiInfo.getBSSID()))
                    .findAny().orElse(null);

            if (currentNetwork != null) {
                break;
            }
            Thread.sleep(SCAN_FIND_BSSID_WAIT_MSEC);
        }
        assertWithMessage(""Current network not found in scan results"")
                .that(currentNetwork).isNotNull();

        String wifiInfoSsidQuoted = wifiInfo.getSSID();
        String scanResultSsidUnquoted = currentNetwork.SSID;

        assertWithMessage(
                ""SSID mismatch: make sure this isn't a hidden network or an SSID containing ""
                        + ""non-UTF-8 characters - neither is supported by this CTS test."")
                .that(""\"""" + scanResultSsidUnquoted + ""\"""")
                .isEqualTo(wifiInfoSsidQuoted);
        assertThat(currentNetwork.frequency).isEqualTo(wifiInfo.getFrequency());
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ScanResultTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.MultiStaConcurrencyWifiNetworkSpecifierTest"	"isStaConcurrencyForLocalOnlyConnectionsSupported"	"CtsWifiTestCases"	"1: permission"	"([14:/android/net/wifi/cts/MultiStaConcurrencyWifiNetworkSpecifierTest.java]:[permission]:[14]:method_text:[ to a network using peer to peer API.     * 3. Verify that both connections are active.     */   ]) :|: /*
 *.
 */

package android.net.wifi.cts;

import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeTrue;

import android.content.Context;
import android.content.pm.PackageManager;
import android.location.LocationManager;
import android.net.ConnectivityManager;
import android.net.NetworkRequest;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSpecifier;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.LargeTest;
import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;

/**
 * Tests multiple concurrent connection flow on devices that support multi STA concurrency
 * (indicated via {@link WifiManager#isStaConcurrencyForLocalOnlyConnectionsSupported()}.
 *
 * Tests the entire connection flow using {@link WifiNetworkSpecifier} embedded in a
 * {@link NetworkRequest} & passed into {@link ConnectivityManager#requestNetwork(NetworkRequest,
 * ConnectivityManager.NetworkCallback)} along with a concurrent internet connection using
 * {@link WifiManager#connect(int, WifiManager.ActionListener)}.
 *
 * Assumes that all the saved networks is either open/WPA1/WPA2/WPA3 authenticated network.
 *
 * TODO(b/177591382): Refactor some of the utilities to a separate file that are copied over from
 * WifiManagerTest & WifiNetworkSpecifierTest.
 */
@SdkSuppress(minSdkVer"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyWifiNetworkSpecifierTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.ConcurrencyTest"	"ActionListener"	"CtsWifiTestCases"	"2: INTERNET permission"	"([4:/android/net/wifi/cts/ConcurrencyTest.java]:[permission]:[4]:method_text:[ED, mMySync.expectedP2pState);        removeAllPersistentGroups();        return true;    }   ]) :|: public void test/*
 *.
 */

package android.net.wifi.cts;

import static org.junit.Assert.assertNotEquals;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.net.ConnectivityManager;
import android.net.ConnectivityManager.NetworkCallback;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkInfo;
import android.net.NetworkRequest;
import android.net.wifi.WifiManager;
import android.net.wifi.p2p.WifiP2pDevice;
import android.net.wifi.p2p.WifiP2pGroup;
import android.net.wifi.p2p.WifiP2pGroupList;
import android.net.wifi.p2p.WifiP2pInfo;
import android.net.wifi.p2p.WifiP2pManager;
import android.net.wifi.p2p.nsd.WifiP2pServiceInfo;
import android.net.wifi.p2p.nsd.WifiP2pUpnpServiceInfo;
import android.provider.Settings;
import android.platform.test.annotations.AppModeFull;
import android.test.AndroidTestCase;
import android.util.Log;

import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

import java.util.Arrays;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
public class ConcurrencyTest extends WifiJUnit3TestBase {
    private class MySync {
        static final int WIFI_STATE = 0;
        static final int P2P_STATE = 1;
        static final int DISCOVERY_STATE = 2;
        static final int NETWORK_INFO = 3;

        public BitSet pendingSync = new BitSet();

        public int expectedWifiState;
        public int expectedP2pState;
        public int expectedDiscoveryState;
        public NetworkInfo expectedNetworkInfo;
    }

    private class MyResponse {
        public"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConcurrencyTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.ConcurrencyTest"	"testSetDeviceName"	"CtsWifiTestCases"	"1: permission"	"([3:/android/net/wifi/cts/ConcurrencyTest.java]:[permission]:[3]:method_text:[orServiceResponse(mMyResponse));        });        return mMyResponse.persistentGroups;    }   ]) :|: public void testSetDeviceName() {
        if (!setupWifiP2p()) {
            return;
        }

        String testDeviceName = ""test"";
        String originalDeviceName = getDeviceName();
        assertNotNull(originalDeviceName);

        resetResponse(mMyResponse);
        ShellIdentityUtils.invokeWithShellPermissions(() -> {
            mWifiP2pManager.setDeviceName(
                    mWifiP2pChannel, testDeviceName, mActionListener);
            assertTrue(waitForServiceResponse(mMyResponse));
            assertTrue(mMyResponse.success);
        });

        String currentDeviceName = getDeviceName();
        assertEquals(testDeviceName, currentDeviceName);

        // restore the device name at the end
        resetResponse(mMyResponse);
        ShellIdentityUtils.invokeWithShellPermissions(() -> {
            mWifiP2pManager.setDeviceName(
                    mWifiP2pChannel, originalDeviceName, mActionListener);
            assertTrue(waitForServiceResponse(mMyResponse));
            assertTrue(mMyResponse.success);
        });
    }

    private WifiP2pGroupList getPersistentGroups() {
        resetResponse(mMyResponse);
        ShellIdentityUtils.invokeWithShellPermissions(() -> {
            mWifiP2pManager.requestPersistentGroupInfo(mWifiP2pChannel,
                    new WifiP2pManager.PersistentGroupInfoListener() {
                        @Override
                        public void onPersistentGroupInfoAvailable(WifiP2pGroupList groups) {
                            synchronized (mMyResponse) {
                                mMyResponse.persistentGroups = groups;
                                mMyResponse.valid = true;
                                mMyResponse.notify();
                            }
                        }
                    });
            assertTrue(waitForServiceResponse(mMyResponse));
        });
        return mMyResponse.persistentGroups;
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConcurrencyTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.ConcurrencyTest"	"testPersistentGroupOperation"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/ConcurrencyTest.java]:[permission]:[2]:method_text:[tNull(persistentGroups);        assertEquals(0, persistentGroups.getGroupList().size());    }   ]) :|: public void testPersistentGroupOperation() {
        if (!setupWifiP2p()) {
            return;
        }

        resetResponse(mMyResponse);
        mWifiP2pManager.createGroup(mWifiP2pChannel, mActionListener);
        assertTrue(waitForServiceResponse(mMyResponse));
        assertTrue(mMyResponse.success);

        // The first network state might be IDLE due to
        // lazy initialization, but not CONNECTED.
        for (int i = 0; i < 2; i++) {
            assertTrue(waitForBroadcasts(MySync.NETWORK_INFO));
            assertNotNull(mMySync.expectedNetworkInfo);
            if (NetworkInfo.DetailedState.CONNECTED ==
                    mMySync.expectedNetworkInfo.getDetailedState()) {
                break;
            }
            assertEquals(NetworkInfo.DetailedState.IDLE,
                    mMySync.expectedNetworkInfo.getDetailedState());
        }
        assertEquals(NetworkInfo.DetailedState.CONNECTED,
                mMySync.expectedNetworkInfo.getDetailedState());

        resetResponse(mMyResponse);
        mWifiP2pManager.removeGroup(mWifiP2pChannel, mActionListener);
        assertTrue(waitForServiceResponse(mMyResponse));
        assertTrue(mMyResponse.success);
        assertTrue(waitForBroadcasts(MySync.NETWORK_INFO));
        assertNotNull(mMySync.expectedNetworkInfo);
        assertEquals(NetworkInfo.DetailedState.DISCONNECTED,
                mMySync.expectedNetworkInfo.getDetailedState());

        WifiP2pGroupList persistentGroups = getPersistentGroups();
        assertNotNull(persistentGroups);
        assertEquals(1, persistentGroups.getGroupList().size());

        resetResponse(mMyResponse);
        final int firstNetworkId = persistentGroups.getGroupList().get(0).getNetworkId();
        ShellIdentityUtils.invokeWithShellPermissions(() -> {
            mWifiP2pManager.deletePersistentGroup(mWifiP2pChannel,
                    firstNetworkId,
                    mActionListener);
            assertTrue(waitForServiceResponse(mMyResp"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConcurrencyTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.ConcurrencyTest"	"testP2pListening"	"CtsWifiTestCases"	"1: permission"	"([3:/android/net/wifi/cts/ConcurrencyTest.java]:[permission]:[3]:method_text:[orServiceResponse(mMyResponse));            assertTrue(mMyResponse.success);        });    }   ]) :|: public void testP2pListening() {
        if (!setupWifiP2p()) {
            return;
        }

        resetResponse(mMyResponse);
        ShellIdentityUtils.invokeWithShellPermissions(() -> {
            mWifiP2pManager.setWifiP2pChannels(mWifiP2pChannel, 6, 11, mActionListener);
            assertTrue(waitForServiceResponse(mMyResponse));
            assertTrue(mMyResponse.success);
        });

        resetResponse(mMyResponse);
        ShellIdentityUtils.invokeWithShellPermissions(() -> {
            mWifiP2pManager.startListening(mWifiP2pChannel, mActionListener);
            assertTrue(waitForServiceResponse(mMyResponse));
            assertTrue(mMyResponse.success);
        });

        resetResponse(mMyResponse);
        ShellIdentityUtils.invokeWithShellPermissions(() -> {
            mWifiP2pManager.stopListening(mWifiP2pChannel, mActionListener);
            assertTrue(waitForServiceResponse(mMyResponse));
            assertTrue(mMyResponse.success);
        });
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConcurrencyTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiNetworkSpecifierTest"	"testWifiBandInNetworkCallback"	"CtsWifiTestCases"	"1: INTERNET"	"([4:/android/net/wifi/cts/WifiNetworkSpecifierTest.java]:[INTERNET]:[4]:method_text:[the device (that     * can provide internet connectivity) when the request is released.     */   ]) :|: 
    public void testWifiBandInNetworkCallback() throws Exception {
        // Enable all networks and wait for Internet connectivity to be restored.
        // The callbacks in this test will match the existing network as soon as they are filed.
        enableAllSavedNetworks(mWifiManager);
        mTestHelper.assertWifiInternetConnectionAvailable();

        final LinkedBlockingQueue<Pair<Integer, Integer>> results = new LinkedBlockingQueue<>();
        final int[] bands = { ScanResult.WIFI_BAND_24_GHZ, ScanResult.WIFI_BAND_5_GHZ,
                ScanResult.WIFI_BAND_6_GHZ, ScanResult.WIFI_BAND_60_GHZ };
        final ArrayList<NetworkCallback> registeredCallbacks = new ArrayList<>();
        for (final int band : bands) {
            final NetworkCallback callback = new NetworkCallback() {
                @Override public void onCapabilitiesChanged(final Network net,
                        final NetworkCapabilities caps) {
                    results.offer(new Pair(band, TestHelper.getBandFromFrequency(
                            ((WifiInfo) caps.getTransportInfo()).getFrequency())));
                }
            };

            final WifiNetworkSpecifier specifier =
                    new WifiNetworkSpecifier.Builder().setBand(band).build();
            assertThat(specifier.getBand()).isEqualTo(band);

            final NetworkRequest request = new NetworkRequest.Builder()
                .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                .setNetworkSpecifier(specifier)
                .build();
            mConnectivityManager.registerNetworkCallback(request, callback);
            registeredCallbacks.add(callback);
        }

        try {
            // There should be at least one network callback about availability of the wifi network
            // on the right band. If the device is currently connected to multiple WiFi networks,
            // there will be"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSpecifierTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiNetworkSpecifierTest"	"testEnsureAutoConnectToInternetConnectionOnRelease"	"CtsWifiTestCases"	"1: INTERNET"	"([4:/android/net/wifi/cts/WifiNetworkSpecifierTest.java]:[INTERNET]:[4]:method_text:[e networks.     * Note: Can't do end to end tests for such networks in CTS environment.     */   ]) :|: 
    public void testEnsureAutoConnectToInternetConnectionOnRelease() throws Exception {
        WifiNetworkSpecifier specifier =
                TestHelper.createSpecifierBuilderWithCredentialFromSavedNetwork(
                        sTestNetwork)
                        .build();
        testSuccessfulConnectionWithSpecifier(specifier);

        // Now release the network request.
        mConnectivityManager.unregisterNetworkCallback(mNrNetworkCallback);
        mNrNetworkCallback = null;

        // Enable all saved networks on the device
        enableAllSavedNetworks(mWifiManager);
        try {
            // Wait for the device to auto-connect back to some saved or suggested network (which
            // can provide internet connectivity.
            // Note: On devices with concurrency support, this may return true immediately (since
            // the internet connection may be present concurrently).
            mTestHelper.assertWifiInternetConnectionAvailable();
        } finally {
            // need to always disable saved networks again since the other tests in this class
            // assume it
            disableAllSavedNetworks(mWifiManager);
        }
    }

    /**
     * Tests the builder for WPA2 enterprise networks.
     * Note: Can't do end to end tests for such networks in CTS environment.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSpecifierTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiNetworkSpecifierTest"	"isNotNull"	"CtsWifiTestCases"	"1: permission"	"([15:/android/net/wifi/cts/WifiNetworkSpecifierTest.java]:[permission]:[15]:method_text:[    /**     * Tests the entire connection flow using a specific SSID in the specifier.     */   ]) :|: /*
 *.
 */

package android.net.wifi.cts;

import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeTrue;

import android.annotation.NonNull;
import android.content.Context;
import android.net.ConnectivityManager;
import android.net.ConnectivityManager.NetworkCallback;
import android.net.MacAddress;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.NetworkSpecifier;
import android.net.wifi.ScanResult;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiEnterpriseConfig;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSpecifier;
import android.os.Build;
import android.os.PatternMatcher;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;
import android.util.Pair;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.LargeTest;
import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.List;
import java"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSpecifierTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiInfoTest"	"testWifiInfoProperties"	"CtsWifiTestCases"	"1: permission"	"([1:/android/net/wifi/cts/WifiInfoTest.java]:[permission]:[1]:method_text:[ that was set, and that     * calling build multiple times returns different instances.     */   ]) :|: public void testWifiInfoProperties() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // ensure Wifi is connected
        ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.reconnect());
        PollingCheck.check(
                ""Wifi not connected - Please ensure there is a saved network in range of this ""
                        + ""device"",
                WIFI_CONNECT_TIMEOUT_MILLIS,
                () -> mWifiManager.getConnectionInfo().getNetworkId() != -1);

        // this test case should in Wifi environment
        WifiInfo wifiInfo = mWifiManager.getConnectionInfo();

        testWifiInfoPropertiesWhileConnected(wifiInfo);

        setWifiEnabled(false);

        PollingCheck.check(""getNetworkId not -1"", 20000,
                () -> mWifiManager.getConnectionInfo().getNetworkId() == -1);

        PollingCheck.check(""getWifiState not disabled"", 20000,
                () -> mWifiManager.getWifiState() == WifiManager.WIFI_STATE_DISABLED);
    }

    private void testWifiInfoPropertiesWhileConnected(WifiInfo wifiInfo) {
        assertThat(wifiInfo).isNotNull();
        assertThat(wifiInfo.toString()).isNotNull();
        SupplicantState.isValidState(wifiInfo.getSupplicantState());
        WifiInfo.getDetailedStateOf(SupplicantState.DISCONNECTED);
        String ssid = wifiInfo.getSSID();
        if (!ssid.startsWith(""0x"") && !ssid.equals(WifiManager.UNKNOWN_SSID)) {
            // Non-hex string should be quoted
            assertThat(ssid).startsWith(""\"""");
            assertThat(ssid).endsWith(""\"""");
        }

        assertThat(wifiInfo.getBSSID()).isNotNull();
        assertThat(wifiInfo.getFrequency()).isGreaterThan(0);
        assertThat(wifiInfo.getMacAddress()).isNotNull();

        wifiInfo.getRssi();
        wifiInfo.getIpAddress();
        wifiInfo.getHiddenSSID();
        wifiInfo.getScore();

        // null for"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"	"isStaConcurrencyForRestrictedConnectionsSupported"	"CtsWifiTestCases"	"1: permission"	"([14:/android/net/wifi/cts/MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest.java]:[permission]:[14]:method_text:[work using restricted suggestion API.     * 3. Verify that both connections are active.     */   ]) :|: /*
 *.
 */

package android.net.wifi.cts;

import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PAID;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PRIVATE;
import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeTrue;

import android.content.Context;
import android.content.pm.PackageManager;
import android.location.LocationManager;
import android.net.ConnectivityManager;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSuggestion;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.LargeTest;
import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;
import java.util.Set;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;

/**
 * Tests multiple concurrent connection flow on devices that support multi STA concurrency
 * (indicated via {@link WifiManager#isStaConcurrencyForRestrictedConnectionsSupported()}.
 *
 * Tests the entire connection flow using {@link WifiNetworkSuggestion} which has
 * {@link WifiNetworkSuggestion.Builder#setOemPaid(boolean)} or
 * {@link WifiNetworkSuggestion.Builder#setOemPrivate(boolean)} set along with a concurrent internet
 * connection using {@link WifiManager#connect(int, WifiManager.ActionListener)}.
 *
 * Assumes that all the saved networks is either"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"isLocationEnabled"	"CtsWifiTestCases"	"1: permission"	"([15:/android/net/wifi/cts/WifiNetworkSuggestionTest.java]:[permission]:[15]:method_text:[   }    /**     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.     */   ]) :|: /*
 *.
 */

package android.net.wifi.cts;

import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PAID;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PRIVATE;
import static android.net.wifi.WifiEnterpriseConfig.Eap.AKA;
import static android.net.wifi.WifiEnterpriseConfig.Eap.WAPI_CERT;
import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import android.content.Context;
import android.content.pm.PackageManager;
import android.location.LocationManager;
import android.net.ConnectivityManager;
import android.net.MacAddress;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiEnterpriseConfig;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSuggestion;
import android.net.wifi.hotspot2.PasspointConfiguration;
import android.net.wifi.hotspot2.pps.Credential;
import android.net.wifi.hotspot2.pps.HomeSp;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;
import android.telephony.TelephonyManager;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.LargeTest;
import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.Run"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"isNotNull"	"CtsWifiTestCases"	"1: permission"	"([11:/android/net/wifi/cts/WifiLocationInfoTest.java]:[permission]:[11]:method_text:[E_NAME,                WIFI_LOCATION_TEST_APP_RETRIEVE_TRANSPORT_INFO_SERVICE), status);    }   ]) :|: /*
 *.
 */

package android.net.wifi.cts;

import static android.Manifest.permission.ACCESS_BACKGROUND_LOCATION;
import static android.Manifest.permission.ACCESS_FINE_LOCATION;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeTrue;

import android.content.ComponentName;
import android.content.Context;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SdkSuppress;
import androidx.test.filters.SmallTest;
import androidx.test.platform.app.InstrumentationRegistry;
import androidx.test.rule.ActivityTestRule;

import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;

/**
 * Tests location sensitive APIs exposed by Wi-Fi.
 * Ensures that permissions on these APIs are properly enforced.
 */
@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@SmallTest
@RunWith(AndroidJUnit4.class)
public class WifiLocationInfoTest extends WifiJUnit4TestBase {
    private static final String TAG = ""WifiLocationInfoTest"";

    private static final String WIFI_LOCATION_TEST_APP_APK_PATH =
            ""/data/local/tmp/cts/wifi/CtsWifiLocationTestApp.apk"";
    private static final String WIFI_LOCATION_TEST_APP_PACKAGE_NAME =
            ""android.net.wifi.cts.app"";
    private static final String WIFI_LOCATION_TEST_APP_TRIGGER_SCAN_ACTIVITY =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".TriggerScanAndReturnStatusActivity"";
    private static final String WIFI_LOCATION_TEST_APP_TRIGGER_SCAN_SERVICE ="	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanTriggerNotAllowedForForegroundActivityWithNoLocationPermission"	"CtsWifiTestCases"	"1: permission"	"([1:/android/net/wifi/cts/WifiLocationInfoTest.java]:[permission]:[1]:method_text:[n()            throws Exception {        triggerScanFgActivityAndAssertStatusIs(false);    }   ]) :|: 
    public void testScanTriggerNotAllowedForForegroundActivityWithNoLocationPermission()
            throws Exception {
        triggerScanFgActivityAndAssertStatusIs(false);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanTriggerAllowedForForegroundActivityWithFineLocationPermission"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiLocationInfoTest.java]:[permission]:[2]:method_text:[ACKAGE_NAME, ACCESS_FINE_LOCATION);        triggerScanFgActivityAndAssertStatusIs(true);    }   ]) :|: 
    public void testScanTriggerAllowedForForegroundActivityWithFineLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        triggerScanFgActivityAndAssertStatusIs(true);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanTriggerAllowedForBackgroundServiceWithBackgroundLocationPermission"	"CtsWifiTestCases"	"1: permission"	"([3:/android/net/wifi/cts/WifiLocationInfoTest.java]:[permission]:[3]:method_text:[E_NAME, ACCESS_BACKGROUND_LOCATION);        triggerScanBgServiceAndAssertStatusIs(true);    }   ]) :|: 
    public void testScanTriggerAllowedForBackgroundServiceWithBackgroundLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_BACKGROUND_LOCATION);
        triggerScanBgServiceAndAssertStatusIs(true);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanTriggerNotAllowedForBackgroundServiceWithFineLocationPermission"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiLocationInfoTest.java]:[permission]:[2]:method_text:[ACKAGE_NAME, ACCESS_FINE_LOCATION);        triggerScanBgServiceAndAssertStatusIs(false);    }   ]) :|: 
    public void testScanTriggerNotAllowedForBackgroundServiceWithFineLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        triggerScanBgServiceAndAssertStatusIs(false);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanResultsRetrievalNotAllowedForForegroundActivityWithNoLocationPermission"	"CtsWifiTestCases"	"1: permission"	"([1:/android/net/wifi/cts/WifiLocationInfoTest.java]:[permission]:[1]:method_text:[        throws Exception {        retrieveScanResultsFgActivityAndAssertStatusIs(false);    }   ]) :|: 
    public void testScanResultsRetrievalNotAllowedForForegroundActivityWithNoLocationPermission()
            throws Exception {
        retrieveScanResultsFgActivityAndAssertStatusIs(false);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanResultsRetrievalAllowedForForegroundActivityWithFineLocationPermission"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiLocationInfoTest.java]:[permission]:[2]:method_text:[AME, ACCESS_FINE_LOCATION);        retrieveScanResultsFgActivityAndAssertStatusIs(true);    }   ]) :|: 
    public void testScanResultsRetrievalAllowedForForegroundActivityWithFineLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        retrieveScanResultsFgActivityAndAssertStatusIs(true);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanResultsRetrievalAllowedForBackgroundServiceWithBackgroundLocationPermission"	"CtsWifiTestCases"	"1: permission"	"([3:/android/net/wifi/cts/WifiLocationInfoTest.java]:[permission]:[3]:method_text:[ACCESS_BACKGROUND_LOCATION);        retrieveScanResultsBgServiceAndAssertStatusIs(true);    }   ]) :|: 
    public void testScanResultsRetrievalAllowedForBackgroundServiceWithBackgroundLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_BACKGROUND_LOCATION);
        retrieveScanResultsBgServiceAndAssertStatusIs(true);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanResultsRetrievalNotAllowedForBackgroundServiceWithFineLocationPermission"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiLocationInfoTest.java]:[permission]:[2]:method_text:[AME, ACCESS_FINE_LOCATION);        retrieveScanResultsBgServiceAndAssertStatusIs(false);    }   ]) :|: 
    public void testScanResultsRetrievalNotAllowedForBackgroundServiceWithFineLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        retrieveScanResultsBgServiceAndAssertStatusIs(false);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testConnectionInfoRetrievalNotAllowedForForegroundActivityWithNoLocationPermission"	"CtsWifiTestCases"	"1: permission"	"([1:/android/net/wifi/cts/WifiLocationInfoTest.java]:[permission]:[1]:method_text:[     throws Exception {        retrieveConnectionInfoFgActivityAndAssertStatusIs(false);    }   ]) :|: 
    public void testConnectionInfoRetrievalNotAllowedForForegroundActivityWithNoLocationPermission()
            throws Exception {
        retrieveConnectionInfoFgActivityAndAssertStatusIs(false);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testConnectionInfoRetrievalAllowedForForegroundActivityWithFineLocationPermission"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiLocationInfoTest.java]:[permission]:[2]:method_text:[, ACCESS_FINE_LOCATION);        retrieveConnectionInfoFgActivityAndAssertStatusIs(true);    }   ]) :|: 
    public void testConnectionInfoRetrievalAllowedForForegroundActivityWithFineLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        retrieveConnectionInfoFgActivityAndAssertStatusIs(true);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testConnectionInfoRetrievalAllowedForBackgroundServiceWithBackgroundLocationPermission"	"CtsWifiTestCases"	"1: permission"	"([3:/android/net/wifi/cts/WifiLocationInfoTest.java]:[permission]:[3]:method_text:[ESS_BACKGROUND_LOCATION);        retrieveConnectionInfoBgServiceAndAssertStatusIs(true);    }   ]) :|: 
    public void
        testConnectionInfoRetrievalAllowedForBackgroundServiceWithBackgroundLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_BACKGROUND_LOCATION);
        retrieveConnectionInfoBgServiceAndAssertStatusIs(true);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testConnectionInfoRetrievalNotAllowedForBackgroundServiceWithFineLocationPermission"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiLocationInfoTest.java]:[permission]:[2]:method_text:[gServiceAndAssertStatusIs(false);    }    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)   ]) :|: 
    public void
        testConnectionInfoRetrievalNotAllowedForBackgroundServiceWithFineLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        retrieveConnectionInfoBgServiceAndAssertStatusIs(false);
    }

    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testTransportInfoRetrievalNotAllowedForForegroundActivityWithNoLocationPermission"	"CtsWifiTestCases"	"1: permission"	"([1:/android/net/wifi/cts/WifiLocationInfoTest.java]:[permission]:[1]:method_text:[ActivityAndAssertStatusIs(false);    }    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)   ]) :|: 
    public void testTransportInfoRetrievalNotAllowedForForegroundActivityWithNoLocationPermission()
            throws Exception {
        retrieveTransportInfoFgActivityAndAssertStatusIs(false);
    }

    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testTransportInfoRetrievalAllowedForForegroundActivityWithFineLocationPermission"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiLocationInfoTest.java]:[permission]:[2]:method_text:[gActivityAndAssertStatusIs(true);    }    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)   ]) :|: 
    public void testTransportInfoRetrievalAllowedForForegroundActivityWithFineLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        retrieveTransportInfoFgActivityAndAssertStatusIs(true);
    }

    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testTransportInfoRetrievalAllowedForBackgroundServiceWithBackgroundLocationPermission"	"CtsWifiTestCases"	"1: permission"	"([3:/android/net/wifi/cts/WifiLocationInfoTest.java]:[permission]:[3]:method_text:[BgServiceAndAssertStatusIs(true);    }    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)   ]) :|: 
    public void
    testTransportInfoRetrievalAllowedForBackgroundServiceWithBackgroundLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_BACKGROUND_LOCATION);
        retrieveTransportInfoBgServiceAndAssertStatusIs(true);
    }

    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testTransportInfoRetrievalNotAllowedForBackgroundServiceWithFineLocationPermission"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiLocationInfoTest.java]:[permission]:[2]:method_text:[NAME, ACCESS_FINE_LOCATION);        retrieveTransportInfoBgServiceAndAssertStatusIs(false);    }}]) :|: 
    public void
    testTransportInfoRetrievalNotAllowedForBackgroundServiceWithFineLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        retrieveTransportInfoBgServiceAndAssertStatusIs(false);
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"ProvisioningCallback"	"CtsWifiTestCases"	"1: permission"	"([9:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[9]:method_text:[);        }        return -1;    }    /**     * Test creation of WifiManager Lock.     */   ]) :|: public void test/*
 *.
 */

package android.net.wifi.cts;

import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_METERED;
import static android.net.NetworkCapabilities.TRANSPORT_WIFI;
import static android.net.wifi.WifiAvailableChannel.OP_MODE_SAP;
import static android.net.wifi.WifiAvailableChannel.OP_MODE_STA;
import static android.net.wifi.WifiConfiguration.INVALID_NETWORK_ID;
import static android.net.wifi.WifiManager.COEX_RESTRICTION_SOFTAP;
import static android.net.wifi.WifiManager.COEX_RESTRICTION_WIFI_AWARE;
import static android.net.wifi.WifiManager.COEX_RESTRICTION_WIFI_DIRECT;
import static android.net.wifi.WifiScanner.WIFI_BAND_24_GHZ;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.assertNotEquals;

import android.annotation.NonNull;
import android.app.UiAutomation;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.net.ConnectivityManager;
import android.net.MacAddress;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkInfo;
import android.net.NetworkRequest;
import android.net.TetheringManager;
import android.net.Uri;
import android.net.wifi.CoexUnsafeChannel;
import android.net.wifi.ScanResult;
import android.net.wifi.SoftApCapability;
import android.net.wifi.SoftApConfiguration;
import android.net.wifi.SoftApInfo;
import android.net.wifi.WifiAvailableChannel;
import android.net.wifi.WifiClient;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiEnterpriseConfig;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiManager.SubsystemRestartTrackingCallback;
import android.net.wifi.WifiManager.WifiLock;
impor"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testRestartWifiSubsystemShouldFailNoPermission"	"CtsWifiTestCases"	"1: permission"	"([1:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[1]:method_text:[erify transition through states.     */    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)   ]) :|: public void testRestartWifiSubsystemShouldFailNoPermission() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        try {
            mWifiManager.restartWifiSubsystem();
            fail(""The restartWifiSubsystem should not succeed - privileged call"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Restart WiFi subsystem and verify transition through states.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testRestartWifiSubsystem"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[2]:method_text:[able properties     * 2.DhcpInfo properties     * 3.wifi state     * 4.ConnectionInfo     */   ]) :|: public void testRestartWifiSubsystem() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mSubsystemRestartStatus = 0; // 0: uninitialized
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            mWifiManager.registerSubsystemRestartTrackingCallback(mExecutor,
                    mSubsystemRestartTrackingCallback);
            synchronized (mLock) {
                mWifiManager.restartWifiSubsystem();
                mLock.wait(TEST_WAIT_DURATION_MS);
            }
            assertEquals(mSubsystemRestartStatus, 1); // 1: restarting
            waitForExpectedWifiState(false);
            assertFalse(mWifiManager.isWifiEnabled());
            synchronized (mLock) {
                mLock.wait(TEST_WAIT_DURATION_MS);
                assertEquals(mSubsystemRestartStatus, 2); // 2: restarted
            }
            waitForExpectedWifiState(true);
            assertTrue(mWifiManager.isWifiEnabled());
        } finally {
            // cleanup
            mWifiManager.unregisterSubsystemRestartTrackingCallback(
                    mSubsystemRestartTrackingCallback);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * test point of wifiManager properties:
     * 1.enable properties
     * 2.DhcpInfo properties
     * 3.wifi state
     * 4.ConnectionInfo
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testCalculateSignalLevel"	"CtsWifiTestCases"	"1: permission"	"([3:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[3]:method_text:[ith proper permissions.     *     * Note: Location mode must be enabled for this test.     */   ]) :|: public void testCalculateSignalLevel() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        int maxSignalLevel = mWifiManager.getMaxSignalLevel();

        int prevSignalLevel = 0;
        for (int rssi = -150; rssi <= 50; rssi++) {
            int signalLevel = mWifiManager.calculateSignalLevel(rssi);

            // between [0, maxSignalLevel]
            assertWithMessage(""For RSSI=%s"", rssi).that(signalLevel).isAtLeast(0);
            assertWithMessage(""For RSSI=%s"", rssi).that(signalLevel).isAtMost(maxSignalLevel);

            // calculateSignalLevel(rssi) <= calculateSignalLevel(rssi + 1)
            assertWithMessage(""For RSSI=%s"", rssi).that(signalLevel).isAtLeast(prevSignalLevel);
            prevSignalLevel = signalLevel;
        }
    }

    public class TestWifiVerboseLoggingStatusChangedListener implements
            WifiManager.WifiVerboseLoggingStatusChangedListener {
        public int numCalls;
        public boolean status;

        @Override
        public void onWifiVerboseLoggingStatusChanged(boolean enabled) {
            numCalls++;
            status = enabled;
        }
    }

    public class TestSoftApCallback implements WifiManager.SoftApCallback {
        Object softApLock;
        int currentState;
        int currentFailureReason;
        List<SoftApInfo> apInfoList = new ArrayList<>();
        SoftApInfo apInfoOnSingleApMode;
        Map<SoftApInfo, List<WifiClient>> apInfoClients = new HashMap<>();
        List<WifiClient> currentClientList;
        SoftApCapability currentSoftApCapability;
        MacAddress lastBlockedClientMacAddress;
        int lastBlockedClientReason;
        boolean onStateChangedCalled = false;
        boolean onSoftApCapabilityChangedCalled = false;
        boolean onConnectedClientCalled = false;
        boolean onConnectedClientChangedWithInfoCalled = false;
        boolean onBlockedClientConnectingCalled"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testAddNetworkResultCreation"	"CtsWifiTestCases"	"1: permission"	"([1:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[1]:method_text:[leged(WifiConfiguration)} throws a     * SecurityException when called by a normal app.     */   ]) :|: public void testAddNetworkResultCreation() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        int statusCode = WifiManager.AddNetworkResult.STATUS_NO_PERMISSION;
        int networkId = 5;
        WifiManager.AddNetworkResult result = new WifiManager.AddNetworkResult(
            statusCode, networkId);
        assertEquals(""statusCode should match"", statusCode, result.statusCode);
        assertEquals(""networkId should match"", networkId, result.networkId);
    }

    /**
     * Verify that {@link WifiManager#addNetworkPrivileged(WifiConfiguration)} throws a
     * SecurityException when called by a normal app.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testAddNetworkPrivilegedBadInput"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[2]:method_text:[ailure status code when adding an enterprise config with mandatory fields not filled in.     */   ]) :|: public void testAddNetworkPrivilegedBadInput() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            mWifiManager.addNetworkPrivileged(null);
            fail(""Expected IllegalArgumentException"");
        } catch (IllegalArgumentException e) {
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Verify {@link WifiManager#addNetworkPrivileged(WifiConfiguration)} returns the proper
     * failure status code when adding an enterprise config with mandatory fields not filled in.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testAddNetworkPrivilegedFailureBadEnterpriseConfig"	"CtsWifiTestCases"	"1: permission"	"([3:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[3]:method_text:[ivileged(WifiConfiguration)} works properly when the     * calling app has permissions.     */   ]) :|: public void testAddNetworkPrivilegedFailureBadEnterpriseConfig() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            WifiConfiguration wifiConfiguration = new WifiConfiguration();
            wifiConfiguration.SSID = SSID1;
            wifiConfiguration.setSecurityParams(WifiConfiguration.SECURITY_TYPE_EAP_WPA3_ENTERPRISE);
            wifiConfiguration.enterpriseConfig.setEapMethod(WifiEnterpriseConfig.Eap.TTLS);
            WifiManager.AddNetworkResult result =
                    mWifiManager.addNetworkPrivileged(wifiConfiguration);
            assertEquals(WifiManager.AddNetworkResult.STATUS_INVALID_CONFIGURATION_ENTERPRISE,
                    result.statusCode);
            assertEquals(-1, result.networkId);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Verify {@link WifiManager#addNetworkPrivileged(WifiConfiguration)} works properly when the
     * calling app has permissions.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testAddNetworkPrivilegedSuccess"	"CtsWifiTestCases"	"1: permission"	"([3:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[3]:method_text:[uration)} works     * with merging types properly when the calling app has permissions.     */   ]) :|: public void testAddNetworkPrivilegedSuccess() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        WifiManager.AddNetworkResult result = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            WifiConfiguration newOpenNetwork = new WifiConfiguration();
            newOpenNetwork.SSID = ""\"""" + TEST_SSID_UNQUOTED + ""\"""";
            result = mWifiManager.addNetworkPrivileged(newOpenNetwork);
            assertEquals(WifiManager.AddNetworkResult.STATUS_SUCCESS, result.statusCode);
            assertTrue(result.networkId >= 0);
            List<WifiConfiguration> configuredNetworks = mWifiManager.getConfiguredNetworks();
            boolean found = false;
            for (WifiConfiguration config : configuredNetworks) {
                if (config.networkId == result.networkId
                        && config.SSID.equals(newOpenNetwork.SSID)) {
                    found = true;
                    break;
                }
            }
            assertTrue(""addNetworkPrivileged returns success""
                    + ""but the network is not found in getConfiguredNetworks"", found);

            List<WifiConfiguration> privilegedConfiguredNetworks =
                    mWifiManager.getPrivilegedConfiguredNetworks();
            found = false;
            for (WifiConfiguration config : privilegedConfiguredNetworks) {
                if (config.networkId == result.networkId
                        && config.SSID.equals(newOpenNetwork.SSID)) {
                    found = true;
                    break;
                }
            }
            assertTrue(""addNetworkPrivileg"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testAddNetworkPrivilegedMergingTypeSuccess"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[2]:method_text:[spot request at a time.     *     * Note: Location mode must be enabled for this test.     */   ]) :|: public void testAddNetworkPrivilegedMergingTypeSuccess() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        List<WifiConfiguration> testConfigs = new ArrayList<>();
        testConfigs.add(createConfig(""test-open-owe-jdur"", WifiConfiguration.SECURITY_TYPE_OPEN));
        testConfigs.add(createConfig(""test-open-owe-jdur"", WifiConfiguration.SECURITY_TYPE_OWE));
        testConfigs.add(createConfig(""test-psk-sae-ijfe"", WifiConfiguration.SECURITY_TYPE_PSK));
        testConfigs.add(createConfig(""test-psk-sae-ijfe"", WifiConfiguration.SECURITY_TYPE_SAE));
        testConfigs.add(createConfig(""test-wpa2e-wpa3e-plki"",
                WifiConfiguration.SECURITY_TYPE_EAP));
        testConfigs.add(createConfig(""test-wpa2e-wpa3e-plki"",
                WifiConfiguration.SECURITY_TYPE_EAP_WPA3_ENTERPRISE));
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            final int originalConfiguredNetworksNumber = mWifiManager.getConfiguredNetworks().size();
            final int originalPrivilegedConfiguredNetworksNumber =
                    mWifiManager.getPrivilegedConfiguredNetworks().size();
            final int originalCallerConfiguredNetworksNumber =
                mWifiManager.getCallerConfiguredNetworks().size();
            for (WifiConfiguration c: testConfigs) {
                WifiManager.AddNetworkResult result = mWifiManager.addNetworkPrivileged(c);
                assertEquals(WifiManager.AddNetworkResult.STATUS_SUCCESS, result.statusCode);
                assertTrue(result.networkId >= 0);
                c.networkId = result.networkId;
            }
            List<WifiCon"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testStartLocalOnlyHotspotWithConfigBssid"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[2]:method_text:[ck(capabilityCallback);            uiAutomation.dropShellPermissionIdentity();        }    }   ]) :|: public void testStartLocalOnlyHotspotWithConfigBssid() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // check that softap mode is supported by the device
        if (!mWifiManager.isPortableHotspotSupported()) {
            return;
        }

        TestExecutor executor = new TestExecutor();
        TestLocalOnlyHotspotCallback callback = new TestLocalOnlyHotspotCallback(mLock);
        TestSoftApCallback capabilityCallback = new TestSoftApCallback(mLock);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        boolean wifiEnabled = mWifiManager.isWifiEnabled();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            verifyRegisterSoftApCallback(executor, capabilityCallback);
            SoftApConfiguration.Builder customConfigBuilder = new SoftApConfiguration.Builder()
                    .setSsid(TEST_SSID_UNQUOTED)
                    .setPassphrase(TEST_PASSPHRASE, SoftApConfiguration.SECURITY_TYPE_WPA2_PSK);

            boolean isSupportCustomizedMac = capabilityCallback.getCurrentSoftApCapability()
                        .areFeaturesSupported(
                        SoftApCapability.SOFTAP_FEATURE_MAC_ADDRESS_CUSTOMIZATION)
                    && PropertyUtil.isVndkApiLevelNewerThan(Build.VERSION_CODES.S);
            if (isSupportCustomizedMac) {
                customConfigBuilder.setBssid(TEST_MAC);
            }
            SoftApConfiguration customConfig = customConfigBuilder.build();

            mWifiManager.startLocalOnlyHotspot(customConfig, executor, callback);
            // now wait for callback
            Thread.sleep(TEST_WAIT_DURATION_MS);

            // Verify callback is run on the supplied executor
            assertFalse(callback.onStartedCalled);
            executor.runAll();
            assertTrue(callback.onStartedCalled);"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testStartLocalOnlyHotspotWithNullBssidConfig"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[2]:method_text:[     * Verify that changing the mac randomization setting of a Passpoint configuration.     */   ]) :|: public void testStartLocalOnlyHotspotWithNullBssidConfig() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // check that softap mode is supported by the device
        if (!mWifiManager.isPortableHotspotSupported()) {
            return;
        }
        SoftApConfiguration customConfig = new SoftApConfiguration.Builder()
                .setSsid(TEST_SSID_UNQUOTED)
                .setPassphrase(TEST_PASSPHRASE, SoftApConfiguration.SECURITY_TYPE_WPA2_PSK)
                .build();
        TestExecutor executor = new TestExecutor();
        TestLocalOnlyHotspotCallback callback = new TestLocalOnlyHotspotCallback(mLock);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        boolean wifiEnabled = mWifiManager.isWifiEnabled();
        try {
            uiAutomation.adoptShellPermissionIdentity();

            mWifiManager.startLocalOnlyHotspot(customConfig, executor, callback);
            // now wait for callback
            Thread.sleep(TEST_WAIT_DURATION_MS);

            // Verify callback is run on the supplied executor
            assertFalse(callback.onStartedCalled);
            executor.runAll();
            assertTrue(callback.onStartedCalled);

            assertNotNull(callback.reservation);
            SoftApConfiguration softApConfig = callback.reservation.getSoftApConfiguration();
            assertNotNull(softApConfig);
            assertEquals(TEST_SSID_UNQUOTED, softApConfig.getSsid());
            assertEquals(TEST_PASSPHRASE, softApConfig.getPassphrase());
        } finally {
            // clean up
            stopLocalOnlyHotspot(callback, wifiEnabled);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Read the content of the given resource file into a String.
     *
     * @param filename String name of the file
     * @return String"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testMacRandomizationSettingPasspoint"	"CtsWifiTestCases"	"1: permission"	"([5:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[5]:method_text:[ce it would give those     * apps extremely broad access to connectivity functionality.     */   ]) :|: public void testMacRandomizationSettingPasspoint() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        String configStr = loadResourceFile(PASSPOINT_INSTALLATION_FILE_WITH_CA_CERT);
        PasspointConfiguration config =
                ConfigParser.parsePasspointConfig(TYPE_WIFI_CONFIG, configStr.getBytes());
        String fqdn = config.getHomeSp().getFqdn();
        String uniqueId = config.getUniqueId();
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();

            mWifiManager.addOrUpdatePasspointConfiguration(config);
            PasspointConfiguration passpointConfig = getTargetPasspointConfiguration(
                    mWifiManager.getPasspointConfigurations(), uniqueId);
            assertNotNull(""The installed passpoint profile is missing"", passpointConfig);
            assertTrue(""Mac randomization should be enabled for passpoint networks by default."",
                    passpointConfig.isMacRandomizationEnabled());

            mWifiManager.setMacRandomizationSettingPasspointEnabled(fqdn, false);
            passpointConfig = getTargetPasspointConfiguration(
                    mWifiManager.getPasspointConfigurations(), uniqueId);
            assertNotNull(""The installed passpoint profile is missing"", passpointConfig);
            assertFalse(""Mac randomization should be disabled by the API call."",
                    passpointConfig.isMacRandomizationEnabled());
        } finally {
            // Clean up
            mWifiManager.removePasspointConfiguration(fqdn);
            uiAutomation.dropShellPermissionIdentity();
        }
    }
    /**
     * Verify that the {@link android.Manifest.permission#NETWORK_STACK} permission is never held by
     * any package.
     * <p>
     * No apps should <em>ever</em> attempt"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testNetworkStackPermission"	"CtsWifiTestCases"	"1: permission"	"([8:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[8]:method_text:[ intended to be granted to only those apps with direct user     * access and no others.     */   ]) :|: public void testNetworkStackPermission() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        final PackageManager pm = getContext().getPackageManager();

        final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[] {
                android.Manifest.permission.NETWORK_STACK
        }, PackageManager.MATCH_UNINSTALLED_PACKAGES);
        for (PackageInfo pi : holding) {
            fail(""The NETWORK_STACK permission must not be held by "" + pi.packageName
                    + "" and must be revoked for security reasons"");
        }
    }

    /**
     * Verify that the {@link android.Manifest.permission#NETWORK_SETTINGS} permission is
     * never held by any package.
     * <p>
     * Only Settings, SysUi, NetworkStack and shell apps should <em>ever</em> attempt to acquire
     * this permission, since it would give those apps extremely broad access to connectivity
     * functionality.  The permission is intended to be granted to only those apps with direct user
     * access and no others.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testNetworkSettingsPermission"	"CtsWifiTestCases"	"1: permission"	"([14:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[14]:method_text:[unctionality.  The permission is intended to be granted to only the device setup wizard.     */   ]) :|: public void testNetworkSettingsPermission() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        final PackageManager pm = getContext().getPackageManager();

        final ArraySet<String> allowedPackages = new ArraySet();
        final ArraySet<Integer> allowedUIDs = new ArraySet();
        // explicitly add allowed UIDs
        allowedUIDs.add(Process.SYSTEM_UID);
        allowedUIDs.add(Process.SHELL_UID);
        allowedUIDs.add(Process.PHONE_UID);
        allowedUIDs.add(Process.NETWORK_STACK_UID);
        allowedUIDs.add(Process.NFC_UID);

        // only quick settings is allowed to bind to the BIND_QUICK_SETTINGS_TILE permission, using
        // this fact to determined allowed package name for sysui. This is a signature permission,
        // so allow any package with this permission.
        final List<PackageInfo> sysuiPackages = pm.getPackagesHoldingPermissions(new String[] {
                android.Manifest.permission.BIND_QUICK_SETTINGS_TILE
        }, PackageManager.MATCH_UNINSTALLED_PACKAGES);
        for (PackageInfo info : sysuiPackages) {
            allowedPackages.add(info.packageName);
        }

        // the captive portal flow also currently holds the NETWORK_SETTINGS permission
        final Intent intent = new Intent(ConnectivityManager.ACTION_CAPTIVE_PORTAL_SIGN_IN);
        final ResolveInfo ri = pm.resolveActivity(intent, PackageManager.MATCH_DISABLED_COMPONENTS);
        if (ri != null) {
            allowedPackages.add(ri.activityInfo.packageName);
        }

        final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[] {
                android.Manifest.permission.NETWORK_SETTINGS
        }, PackageManager.MATCH_UNINSTALLED_PACKAGES);
        StringBuilder stringBuilder = new StringBuilder();
        for (PackageInfo pi : holding) {
            String packageName = pi.packageName;

            // this is an ex"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testNetworkSetupWizardPermission"	"CtsWifiTestCases"	"1: permission"	"([8:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[8]:method_text:[The permission is intended to be granted to only the device managed     * provisioning.     */   ]) :|: public void testNetworkSetupWizardPermission() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        final ArraySet<String> allowedPackages = new ArraySet();

        final PackageManager pm = getContext().getPackageManager();

        final Intent intent = new Intent(Intent.ACTION_MAIN);
        intent.addCategory(Intent.CATEGORY_SETUP_WIZARD);
        final ResolveInfo ri = pm.resolveActivity(intent, PackageManager.MATCH_DISABLED_COMPONENTS);
        String validPkg = """";
        if (ri != null) {
            allowedPackages.add(ri.activityInfo.packageName);
            validPkg = ri.activityInfo.packageName;
        }

        final Intent preIntent = new Intent(""com.android.setupwizard.OEM_PRE_SETUP"");
        preIntent.addCategory(Intent.CATEGORY_DEFAULT);
        final ResolveInfo preRi = pm
            .resolveActivity(preIntent, PackageManager.MATCH_DISABLED_COMPONENTS);
        String prePackageName = """";
        if (null != preRi) {
            prePackageName = preRi.activityInfo.packageName;
        }

        final Intent postIntent = new Intent(""com.android.setupwizard.OEM_POST_SETUP"");
        postIntent.addCategory(Intent.CATEGORY_DEFAULT);
        final ResolveInfo postRi = pm
            .resolveActivity(postIntent, PackageManager.MATCH_DISABLED_COMPONENTS);
        String postPackageName = """";
        if (null != postRi) {
            postPackageName = postRi.activityInfo.packageName;
        }
        if (!TextUtils.isEmpty(prePackageName) && !TextUtils.isEmpty(postPackageName)
            && prePackageName.equals(postPackageName)) {
            allowedPackages.add(prePackageName);
        }

        final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[]{
            android.Manifest.permission.NETWORK_SETUP_WIZARD
        }, PackageManager.MATCH_UNINSTALLED_PACKAGES);
        for (PackageInfo pi : holding) {
            if (!"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testNetworkManagedProvisioningPermission"	"CtsWifiTestCases"	"1: permission"	"([6:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[6]:method_text:[on#WIFI_SET_DEVICE_MOBILITY_STATE} permission     * is held by at most one application.     */   ]) :|: public void testNetworkManagedProvisioningPermission() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        final PackageManager pm = getContext().getPackageManager();

        // TODO(b/115980767): Using hardcoded package name. Need a better mechanism to find the
        // managed provisioning app.
        // Ensure that the package exists.
        final Intent intent = new Intent(Intent.ACTION_MAIN);
        intent.setPackage(MANAGED_PROVISIONING_PACKAGE_NAME);
        final ResolveInfo ri = pm.resolveActivity(intent, PackageManager.MATCH_DISABLED_COMPONENTS);
        String validPkg = """";
        if (ri != null) {
            validPkg = ri.activityInfo.packageName;
        }

        final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[] {
                android.Manifest.permission.NETWORK_MANAGED_PROVISIONING
        }, PackageManager.MATCH_UNINSTALLED_PACKAGES);
        for (PackageInfo pi : holding) {
            if (!Objects.equals(pi.packageName, validPkg)) {
                fail(""The NETWORK_MANAGED_PROVISIONING permission must not be held by ""
                        + pi.packageName + "" and must be revoked for security reasons [""
                        + validPkg +""]"");
            }
        }
    }

    /**
     * Verify that the {@link android.Manifest.permission#WIFI_SET_DEVICE_MOBILITY_STATE} permission
     * is held by at most one application.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testWifiSetDeviceMobilityStatePermission"	"CtsWifiTestCases"	"1: permission"	"([6:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[6]:method_text:[sion#NETWORK_CARRIER_PROVISIONING} permission     * is held by at most one application.     */   ]) :|: public void testWifiSetDeviceMobilityStatePermission() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        final PackageManager pm = getContext().getPackageManager();

        final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[] {
                android.Manifest.permission.WIFI_SET_DEVICE_MOBILITY_STATE
        }, PackageManager.MATCH_UNINSTALLED_PACKAGES);

        List<String> uniquePackageNames = holding
                .stream()
                .map(pi -> pi.packageName)
                .distinct()
                .collect(Collectors.toList());

        if (uniquePackageNames.size() > 1) {
            fail(""The WIFI_SET_DEVICE_MOBILITY_STATE permission must not be held by more than one ""
                    + ""application, but is held by "" + uniquePackageNames.size() + "" applications: ""
                    + String.join("", "", uniquePackageNames));
        }
    }

    /**
     * Verify that the {@link android.Manifest.permission#NETWORK_CARRIER_PROVISIONING} permission
     * is held by at most one application.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testNetworkCarrierProvisioningPermission"	"CtsWifiTestCases"	"1: permission"	"([6:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[6]:method_text:[WIFI_UPDATE_USABILITY_STATS_SCORE}     * permission is held by at most one application.     */   ]) :|: public void testNetworkCarrierProvisioningPermission() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        final PackageManager pm = getContext().getPackageManager();

        final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[] {
                android.Manifest.permission.NETWORK_CARRIER_PROVISIONING
        }, PackageManager.MATCH_UNINSTALLED_PACKAGES);

        List<String> uniquePackageNames = holding
                .stream()
                .map(pi -> pi.packageName)
                .distinct()
                .collect(Collectors.toList());

        if (uniquePackageNames.size() > 2) {
            fail(""The NETWORK_CARRIER_PROVISIONING permission must not be held by more than two ""
                    + ""applications, but is held by "" + uniquePackageNames.size() + "" applications: ""
                    + String.join("", "", uniquePackageNames));
        }
    }

    /**
     * Verify that the {@link android.Manifest.permission#WIFI_UPDATE_USABILITY_STATS_SCORE}
     * permission is held by at most one application.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testUpdateWifiUsabilityStatsScorePermission"	"CtsWifiTestCases"	"1: permission"	"([7:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[7]:method_text:[een turns off while wifi is disabled     * but location is on.     * @throws Exception     */   ]) :|: public void testUpdateWifiUsabilityStatsScorePermission() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        final PackageManager pm = getContext().getPackageManager();

        final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[] {
                android.Manifest.permission.WIFI_UPDATE_USABILITY_STATS_SCORE
        }, PackageManager.MATCH_UNINSTALLED_PACKAGES);

        Set<String> uniqueNonSystemPackageNames = new HashSet<>();
        for (PackageInfo pi : holding) {
            String packageName = pi.packageName;
            // Shell is allowed to hold this permission for testing.
            int uid = -1;
            try {
                uid = pm.getPackageUidAsUser(packageName, UserHandle.USER_SYSTEM);
            } catch (PackageManager.NameNotFoundException e) {
                continue;
            }
            if (uid == Process.SHELL_UID) continue;

            uniqueNonSystemPackageNames.add(packageName);
        }

        if (uniqueNonSystemPackageNames.size() > 1) {
            fail(""The WIFI_UPDATE_USABILITY_STATS_SCORE permission must not be held by more than ""
                + ""one application, but is held by "" + uniqueNonSystemPackageNames.size()
                + "" applications: "" + String.join("", "", uniqueNonSystemPackageNames));
        }
    }

    private void turnScreenOnNoDelay() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_WAKEUP"");
        mUiDevice.executeShellCommand(""wm dismiss-keyguard"");
    }

    private void turnScreenOn() throws Exception {
        turnScreenOnNoDelay();
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE);
    }

    private void turnScreenOffNoDelay() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_SLEEP"");
    }

    private void turnS"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testTetheredBridgedAp"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[2]:method_text:[rectly.     * @throws Exception     */    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)   ]) :|: public void testTetheredBridgedAp() throws Exception {
        // check that softap bridged mode is supported by the device
        if (!mWifiManager.isBridgedApConcurrencySupported()) {
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        TestExecutor executor = new TestExecutor();
        TestSoftApCallback callback = new TestSoftApCallback(mLock);
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // Off/On Wifi to make sure that we get the supported channel
            turnOffWifiAndTetheredHotspotIfEnabled();
            mWifiManager.setWifiEnabled(true);
            PollingCheck.check(
                ""Wifi turn on failed!"", 2_000,
                () -> mWifiManager.isWifiEnabled() == true);
            turnOffWifiAndTetheredHotspotIfEnabled();
            verifyRegisterSoftApCallback(executor, callback);
            int[] testBands = {SoftApConfiguration.BAND_2GHZ,
                    SoftApConfiguration.BAND_5GHZ};
            int[] expectedBands = {SoftApConfiguration.BAND_2GHZ,
                    SoftApConfiguration.BAND_2GHZ | SoftApConfiguration.BAND_5GHZ};
            // Test bridged SoftApConfiguration set and get (setBands)
            SoftApConfiguration testSoftApConfig = new SoftApConfiguration.Builder()
                    .setSsid(TEST_SSID_UNQUOTED)
                    .setPassphrase(TEST_PASSPHRASE, SoftApConfiguration.SECURITY_TYPE_WPA2_PSK)
                    .setBands(expectedBands)
                    .build();
            boolean shouldFallbackToSingleAp = shouldFallbackToSingleAp(testBands,
                    callback.getCurrentSoftApCapability());
            verifySetGetSoftApConfig(testSoftApConfig);

            // start tethering which used to verify startTetheredHotspot
            mTetheringManager.startTethering(ConnectivityManager.TETHERING_WIFI, executor,
                new TetheringManager.StartTetheringCallb"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testTetheredBridgedApWifiForcedChannel"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[2]:method_text:[tap capability callback to test different     * configuration.     * @throws Exception     */   ]) :|: public void testTetheredBridgedApWifiForcedChannel() throws Exception {
        // check that softap bridged mode is supported by the device
        if (!mWifiManager.isBridgedApConcurrencySupported()) {
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        TestExecutor executor = new TestExecutor();
        TestSoftApCallback callback = new TestSoftApCallback(mLock);
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // Off/On Wifi to make sure that we get the supported channel
            turnOffWifiAndTetheredHotspotIfEnabled();
            mWifiManager.setWifiEnabled(true);
            PollingCheck.check(
                ""Wifi turn on failed!"", 2_000,
                () -> mWifiManager.isWifiEnabled() == true);
            turnOffWifiAndTetheredHotspotIfEnabled();
            verifyRegisterSoftApCallback(executor, callback);

            boolean shouldFallbackToSingleAp = shouldFallbackToSingleAp(
                    new int[] {SoftApConfiguration.BAND_2GHZ, SoftApConfiguration.BAND_5GHZ},
                    callback.getCurrentSoftApCapability());

            // Test when there are supported channels in both of the bands.
            if (!shouldFallbackToSingleAp) {
                // Test bridged SoftApConfiguration set and get (setChannels)
                SparseIntArray dual_channels = new SparseIntArray(2);
                dual_channels.put(SoftApConfiguration.BAND_2GHZ,
                        callback.getCurrentSoftApCapability()
                        .getSupportedChannelList(SoftApConfiguration.BAND_2GHZ)[0]);
                dual_channels.put(SoftApConfiguration.BAND_5GHZ,
                        callback.getCurrentSoftApCapability()
                        .getSupportedChannelList(SoftApConfiguration.BAND_5GHZ)[0]);
                SoftApConfiguration testSoftApConfig = new SoftApConfiguration.Builder()
                        .setSsid"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testSetGetSoftApConfigurationAndSoftApCapabilityCallback"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[2]:method_text:[ Verify that startTetheredHotspot with specific channel config.     * @throws Exception     */   ]) :|: public void testSetGetSoftApConfigurationAndSoftApCapabilityCallback() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // check that softap mode is supported by the device
        if (!mWifiManager.isPortableHotspotSupported()) {
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        TestExecutor executor = new TestExecutor();
        TestSoftApCallback callback = new TestSoftApCallback(mLock);
        try {
            uiAutomation.adoptShellPermissionIdentity();
            turnOffWifiAndTetheredHotspotIfEnabled();
            verifyRegisterSoftApCallback(executor, callback);

            SoftApConfiguration.Builder softApConfigBuilder = new SoftApConfiguration.Builder()
                    .setSsid(TEST_SSID_UNQUOTED)
                    .setPassphrase(TEST_PASSPHRASE, SoftApConfiguration.SECURITY_TYPE_WPA2_PSK)
                    .setAutoShutdownEnabled(true)
                    .setShutdownTimeoutMillis(100000)
                    .setBand(getAvailableBandAndChannelForTesting(
                            callback.getCurrentSoftApCapability()).keyAt(0))
                    .setHiddenSsid(false);

            // Test SoftApConfiguration set and get
            verifySetGetSoftApConfig(softApConfigBuilder.build());

            boolean isSupportCustomizedMac = callback.getCurrentSoftApCapability()
                        .areFeaturesSupported(
                        SoftApCapability.SOFTAP_FEATURE_MAC_ADDRESS_CUSTOMIZATION)
                    && PropertyUtil.isVndkApiLevelNewerThan(Build.VERSION_CODES.S);

            //Test MAC_ADDRESS_CUSTOMIZATION supported config
            if (isSupportCustomizedMac) {
                softApConfigBuilder.setBssid(TEST_MAC)
                        .setMacRandomizationSetting(SoftApConfiguration.RANDOMIZATION_NONE);"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testStartTetheredHotspotWithChannelConfigAndSoftApStateAndInfoCallback"	"CtsWifiTestCases"	"1: permission"	"([5:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[5]:method_text:[fiManager#connect(int, WifiManager.ActionListener)} to an existing saved     * network.     */   ]) :|: public void testStartTetheredHotspotWithChannelConfigAndSoftApStateAndInfoCallback()
            throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // check that softap mode is supported by the device
        if (!mWifiManager.isPortableHotspotSupported()) {
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        TestExecutor executor = new TestExecutor();
        TestSoftApCallback callback = new TestSoftApCallback(mLock);
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // check that tethering is supported by the device
            if (!mTetheringManager.isTetheringSupported()) {
                return;
            }
            turnOffWifiAndTetheredHotspotIfEnabled();
            verifyRegisterSoftApCallback(executor, callback);

            SparseIntArray testBandsAndChannels = getAvailableBandAndChannelForTesting(
                    callback.getCurrentSoftApCapability());

            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                assertNotEquals(0, testBandsAndChannels.size());
            }
            boolean isSupportCustomizedMac = callback.getCurrentSoftApCapability()
                    .areFeaturesSupported(
                    SoftApCapability.SOFTAP_FEATURE_MAC_ADDRESS_CUSTOMIZATION)
                    && PropertyUtil.isVndkApiLevelNewerThan(Build.VERSION_CODES.S);

            SoftApConfiguration.Builder testSoftApConfigBuilder = new SoftApConfiguration.Builder()
                    .setSsid(TEST_SSID_UNQUOTED)
                    .setPassphrase(TEST_PASSPHRASE, SoftApConfiguration.SECURITY_TYPE_WPA2_PSK)
                    .setChannel(testBandsAndChannels.valueAt(0), testBandsAndChannels.keyAt(0));

            if (isSupportCustomizedMac) testSoftApConfigBuilder.setBssid(TEST_MAC);"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testSave"	"CtsWifiTestCases"	"1: permission"	"([3:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[3]:method_text:[er)} by adding/removing a new     * network.     */    @AsbSecurityTest(cveBugId = 159373687)   ]) :|: public void testSave() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        TestActionListener actionListener = new TestActionListener(mLock);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        List<WifiConfiguration> savedNetworks = null;
        WifiConfiguration currentConfig = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // These below API's only work with privileged permissions (obtained via shell identity
            // for test)

            // Trigger a scan & wait for connection to one of the saved networks.
            mWifiManager.startScan();
            waitForConnection();

            WifiInfo wifiInfo = mWifiManager.getConnectionInfo();

            // find the current network's WifiConfiguration
            currentConfig = mWifiManager.getConfiguredNetworks()
                    .stream()
                    .filter(config -> config.networkId == wifiInfo.getNetworkId())
                    .findAny()
                    .get();

            // Ensure that the current network is not metered.
            assertNotEquals(""Ensure that the saved network is configured as unmetered"",
                    currentConfig.meteredOverride,
                    WifiConfiguration.METERED_OVERRIDE_METERED);

            // Check the network capabilities to ensure that the network is marked not metered.
            waitForNetworkCallbackAndCheckForMeteredness(false);

            // Now mark the network metered and save.
            synchronized (mLock) {
                try {
                    WifiConfiguration modSavedNetwork = new WifiConfiguration(currentConfig);
                    modSavedNetwork.meteredOverride = WifiConfiguration.METERED_OVERRIDE_METERED;
                    mWifiManager.save(modSavedNetwork, actionListener);"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testForget"	"CtsWifiTestCases"	"1: permission"	"([3:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[3]:method_text:[ryMacAddresses()} returns at least one valid MAC address.     */    @VirtualDeviceNotSupported   ]) :|: public void testForget() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        TestActionListener actionListener = new TestActionListener(mLock);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        int newNetworkId = INVALID_NETWORK_ID;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // These below API's only work with privileged permissions (obtained via shell identity
            // for test)
            List<WifiConfiguration> savedNetworks = mWifiManager.getConfiguredNetworks();

            WifiConfiguration newOpenNetwork = new WifiConfiguration();
            newOpenNetwork.SSID = ""\"""" + TEST_SSID_UNQUOTED + ""\"""";
            newNetworkId = mWifiManager.addNetwork(newOpenNetwork);
            assertNotEquals(INVALID_NETWORK_ID, newNetworkId);

            // Multi-type configurations might be converted to more than 1 configuration.
            assertThat(savedNetworks.size() < mWifiManager.getConfiguredNetworks().size()).isTrue();

            // Need an effectively-final holder because we need to modify inner Intent in callback.
            class IntentHolder {
                Intent intent;
            }
            IntentHolder intentHolder = new IntentHolder();
            mContext.registerReceiver(new BroadcastReceiver() {
                @Override
                public void onReceive(Context context, Intent intent) {
                    Log.i(TAG, ""Received CONFIGURED_NETWORKS_CHANGED_ACTION broadcast: "" + intent);
                    intentHolder.intent = intent;
                }
            }, new IntentFilter(WifiManager.CONFIGURED_NETWORKS_CHANGED_ACTION));

            // Now remove the network
            synchronized (mLock) {
                try {
                    mWifiManager.forget(newNetworkId, actionListener);
                    // n"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testGetFactoryMacAddresses"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[2]:method_text:[    /**     * Tests {@link WifiManager#isApMacRandomizationSupported()} does not crash.     */   ]) :|: public void testGetFactoryMacAddresses() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        TestActionListener actionListener = new TestActionListener(mLock);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        int newNetworkId = INVALID_NETWORK_ID;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // Obtain the factory MAC address
            String[] macAddresses = mWifiManager.getFactoryMacAddresses();
            assertTrue(""At list one MAC address should be returned."", macAddresses.length > 0);
            try {
                MacAddress mac = MacAddress.fromString(macAddresses[0]);
                assertNotEquals(WifiInfo.DEFAULT_MAC_ADDRESS, mac);
                assertFalse(MacAddressUtils.isMulticastAddress(mac));
            } catch (IllegalArgumentException e) {
                fail(""Factory MAC address is invalid"");
            }
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#isApMacRandomizationSupported()} does not crash.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testPnoScan"	"CtsWifiTestCases"	"1: permission"	"([5:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[5]:method_text:[     }    }    /**     * Tests {@link WifiManager#isTdlsSupported()} does not crash.     */   ]) :|: public void testPnoScan() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!mWifiManager.isPreferredNetworkOffloadSupported()) {
            // skip the test if PNO scanning is not supported
            return;
        }

        // make sure we're connected
        waitForConnection();

        WifiInfo currentNetwork = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getConnectionInfo);

        // disable all networks that aren't already disabled
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getConfiguredNetworks);
        Set<Integer> disabledNetworkIds = new HashSet<>();
        for (WifiConfiguration config : savedNetworks) {
            if (config.getNetworkSelectionStatus().getNetworkSelectionDisableReason()
                    == WifiConfiguration.NetworkSelectionStatus.DISABLED_NONE) {
                ShellIdentityUtils.invokeWithShellPermissions(
                        () -> mWifiManager.disableNetwork(config.networkId));
                disabledNetworkIds.add(config.networkId);
            }
        }

        try {
            // wait for disconnection from current network
            waitForDisconnection();

            // turn screen off
            turnScreenOffNoDelay();

            // re-enable the current network - this will trigger PNO
            ShellIdentityUtils.invokeWithShellPermissions(
                    () -> mWifiManager.enableNetwork(currentNetwork.getNetworkId(), false));
            disabledNetworkIds.remove(currentNetwork.getNetworkId());

            // PNO should reconnect us back to the network we disconnected from
            waitForConnection();
        } finally {
            // re-enable disabled networks
            for (int disabledNetworkId : disabledNetworkIds) {
                ShellIdentity"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testTrafficStateCallback"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[2]:method_text:[r#setScanAlwaysAvailable(boolean)} &     * {@link WifiManager#isScanAlwaysAvailable()}.     */   ]) :|: public void testTrafficStateCallback() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        TestTrafficStateCallback callback = new TestTrafficStateCallback();
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // Trigger a scan & wait for connection to one of the saved networks.
            mWifiManager.startScan();
            waitForConnection();

            // Turn screen on for wifi traffic polling.
            turnScreenOn();
            mWifiManager.registerTrafficStateCallback(
                    Executors.newSingleThreadExecutor(), callback);
            // Send some traffic to trigger the traffic state change callbacks.
            sendTraffic();
            // now wait for callback
            boolean success = callback.latch.await(TEST_WAIT_DURATION_MS, TimeUnit.MILLISECONDS);
            // check if we got the state changed callback with both data in and out
            assertTrue(success);
        } finally {
            turnScreenOff();
            mWifiManager.unregisterTrafficStateCallback(callback);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#setScanAlwaysAvailable(boolean)} &
     * {@link WifiManager#isScanAlwaysAvailable()}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testScanAlwaysAvailable"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[2]:method_text:[r#setScanThrottleEnabled(boolean)} &     * {@link WifiManager#isScanThrottleEnabled()}.     */   ]) :|: public void testScanAlwaysAvailable() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        Boolean currState = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            currState = mWifiManager.isScanAlwaysAvailable();
            boolean newState = !currState;
            mWifiManager.setScanAlwaysAvailable(newState);
            PollingCheck.check(
                    ""Wifi settings toggle failed!"",
                    DURATION_SETTINGS_TOGGLE,
                    () -> mWifiManager.isScanAlwaysAvailable() == newState);
            assertEquals(newState, mWifiManager.isScanAlwaysAvailable());
        } finally {
            if (currState != null) mWifiManager.setScanAlwaysAvailable(currState);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#setScanThrottleEnabled(boolean)} &
     * {@link WifiManager#isScanThrottleEnabled()}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testScanThrottleEnabled"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[2]:method_text:[nager#setAutoWakeupEnabled(boolean)} &     * {@link WifiManager#isAutoWakeupEnabled()}.     */   ]) :|: public void testScanThrottleEnabled() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        Boolean currState = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            currState = mWifiManager.isScanThrottleEnabled();
            boolean newState = !currState;
            mWifiManager.setScanThrottleEnabled(newState);
            PollingCheck.check(
                    ""Wifi settings toggle failed!"",
                    DURATION_SETTINGS_TOGGLE,
                    () -> mWifiManager.isScanThrottleEnabled() == newState);
            assertEquals(newState, mWifiManager.isScanThrottleEnabled());
        } finally {
            if (currState != null) mWifiManager.setScanThrottleEnabled(currState);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#setAutoWakeupEnabled(boolean)} &
     * {@link WifiManager#isAutoWakeupEnabled()}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testAutoWakeUpEnabled"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[2]:method_text:[tVerboseLoggingEnabled(boolean)} &     * {@link WifiManager#isVerboseLoggingEnabled()}.     */   ]) :|: public void testAutoWakeUpEnabled() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        Boolean currState = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            currState = mWifiManager.isAutoWakeupEnabled();
            boolean newState = !currState;
            mWifiManager.setAutoWakeupEnabled(newState);
            PollingCheck.check(
                    ""Wifi settings toggle failed!"",
                    DURATION_SETTINGS_TOGGLE,
                    () -> mWifiManager.isAutoWakeupEnabled() == newState);
            assertEquals(newState, mWifiManager.isAutoWakeupEnabled());
        } finally {
            if (currState != null) mWifiManager.setAutoWakeupEnabled(currState);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#setVerboseLoggingEnabled(boolean)} &
     * {@link WifiManager#isVerboseLoggingEnabled()}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testVerboseLoggingEnabled"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[2]:method_text:[;        }    }    /**     * Tests {@link WifiManager#setVerboseLoggingLevel(int)}.     */   ]) :|: public void testVerboseLoggingEnabled() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        Boolean currState = null;
        TestWifiVerboseLoggingStatusChangedListener listener =
                WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext) ?
                new TestWifiVerboseLoggingStatusChangedListener() : null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            if (listener != null) {
                mWifiManager.addWifiVerboseLoggingStatusChangedListener(mExecutor, listener);
            }
            currState = mWifiManager.isVerboseLoggingEnabled();
            boolean newState = !currState;
            if (listener != null) {
                assertEquals(0, listener.numCalls);
            }
            mWifiManager.setVerboseLoggingEnabled(newState);
            PollingCheck.check(
                    ""Wifi verbose logging toggle failed!"",
                    DURATION_SETTINGS_TOGGLE,
                    () -> mWifiManager.isVerboseLoggingEnabled() == newState);
            if (listener != null) {
                PollingCheck.check(
                        ""Verbose logging listener timeout"",
                        DURATION_SETTINGS_TOGGLE,
                        () -> listener.status == newState && listener.numCalls == 1);
            }
        } finally {
            if (currState != null) mWifiManager.setVerboseLoggingEnabled(currState);
            if (listener != null) {
                mWifiManager.removeWifiVerboseLoggingStatusChangedListener(listener);
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#setVerboseLoggingLevel(int)}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testSetVerboseLogging"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[2]:method_text:[ngLevel(int)} for show key mode.     */    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)   ]) :|: public void testSetVerboseLogging() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        Boolean currState = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            currState = mWifiManager.isVerboseLoggingEnabled();

            mWifiManager.setVerboseLoggingLevel(WifiManager.VERBOSE_LOGGING_LEVEL_ENABLED);
            assertTrue(mWifiManager.isVerboseLoggingEnabled());
            assertEquals(WifiManager.VERBOSE_LOGGING_LEVEL_ENABLED,
                    mWifiManager.getVerboseLoggingLevel());

            mWifiManager.setVerboseLoggingLevel(WifiManager.VERBOSE_LOGGING_LEVEL_DISABLED);
            assertFalse(mWifiManager.isVerboseLoggingEnabled());
            assertEquals(WifiManager.VERBOSE_LOGGING_LEVEL_DISABLED,
                    mWifiManager.getVerboseLoggingLevel());
        } finally {
            if (currState != null) mWifiManager.setVerboseLoggingEnabled(currState);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Test {@link WifiManager#setVerboseLoggingLevel(int)} for show key mode.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testSetVerboseLoggingShowKeyModeNonUserBuild"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[2]:method_text:[ngLevel(int)} for show key mode.     */    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)   ]) :|: public void testSetVerboseLoggingShowKeyModeNonUserBuild() throws Exception {
        if (Build.TYPE.equals(""user"")) return;
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        Boolean currState = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            currState = mWifiManager.isVerboseLoggingEnabled();

            mWifiManager.setVerboseLoggingLevel(WifiManager.VERBOSE_LOGGING_LEVEL_ENABLED_SHOW_KEY);
            assertTrue(mWifiManager.isVerboseLoggingEnabled());
            assertEquals(WifiManager.VERBOSE_LOGGING_LEVEL_ENABLED_SHOW_KEY,
                    mWifiManager.getVerboseLoggingLevel());
        } finally {
            if (currState != null) mWifiManager.setVerboseLoggingEnabled(currState);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Test {@link WifiManager#setVerboseLoggingLevel(int)} for show key mode.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testSetVerboseLoggingShowKeyModeUserBuild"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[2]:method_text:[u add the     * networks back after reset, the ownership of saved networks will change.     */   ]) :|: public void testSetVerboseLoggingShowKeyModeUserBuild() throws Exception {
        if (!Build.TYPE.equals(""user"")) return;
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        Boolean currState = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            currState = mWifiManager.isVerboseLoggingEnabled();

            mWifiManager.setVerboseLoggingLevel(WifiManager.VERBOSE_LOGGING_LEVEL_ENABLED_SHOW_KEY);
            assertTrue(mWifiManager.isVerboseLoggingEnabled());
            assertEquals(WifiManager.VERBOSE_LOGGING_LEVEL_ENABLED_SHOW_KEY,
                    mWifiManager.getVerboseLoggingLevel());
            fail(""Verbosing logging show key mode should not be allowed for user build."");
        } catch (SecurityException e) {
            // expected
        } finally {
            if (currState != null) mWifiManager.setVerboseLoggingEnabled(currState);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#factoryReset()} cannot be invoked from a non-privileged app.
     *
     * Note: This intentionally does not test the full reset functionality because it causes
     * the existing saved networks on the device to be lost after the test. If you add the
     * networks back after reset, the ownership of saved networks will change.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testFactoryReset"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[2]:method_text:[ash.     * TODO(b/150891569): deprecate it in Android S, this API is not used anywhere.     */   ]) :|: public void testFactoryReset() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        List<WifiConfiguration> beforeSavedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getConfiguredNetworks);
        try {
            mWifiManager.factoryReset();
            fail(""Factory reset should not be allowed for non-privileged apps"");
        } catch (SecurityException e) {
            // expected
        }
        List<WifiConfiguration> afterSavedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getConfiguredNetworks);
        assertEquals(beforeSavedNetworks.size(), afterSavedNetworks.size());
    }

    /**
     * Test {@link WifiNetworkConnectionStatistics} does not crash.
     * TODO(b/150891569): deprecate it in Android S, this API is not used anywhere.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testStartAndStopRestrictingAutoJoinToSubscriptionId"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[2]:method_text:[ }    /**     * Test that the wifi country code is either null, or a length-2 string.     */   ]) :|: public void testStartAndStopRestrictingAutoJoinToSubscriptionId() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        startScan();
        waitForConnection();
        int fakeSubscriptionId = 5;
        ShellIdentityUtils.invokeWithShellPermissions(() ->
                mWifiManager.startRestrictingAutoJoinToSubscriptionId(fakeSubscriptionId));
        startScan();
        ensureNotConnected();
        ShellIdentityUtils.invokeWithShellPermissions(() ->
                mWifiManager.stopRestrictingAutoJoinToSubscriptionId());
        startScan();
        waitForConnection();
    }

    /**
     * Test that the wifi country code is either null, or a length-2 string.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testGetCountryCode"	"CtsWifiTestCases"	"1: permission"	"([1:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[1]:method_text:[kCallback} when connected to a Wifi network,     * and returns null when not connected.     */   ]) :|: public void testGetCountryCode() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        String wifiCountryCode = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getCountryCode);

        if (wifiCountryCode == null) {
            return;
        }
        assertEquals(2, wifiCountryCode.length());

        // assert that the country code is all uppercase
        assertEquals(wifiCountryCode.toUpperCase(Locale.US), wifiCountryCode);

        // skip if Telephony is unsupported
        if (!WifiFeature.isTelephonySupported(getContext())) {
            return;
        }

        String telephonyCountryCode = getContext().getSystemService(TelephonyManager.class)
                .getNetworkCountryIso();

        // skip if Telephony country code is unavailable
        if (telephonyCountryCode == null || telephonyCountryCode.isEmpty()) {
            return;
        }

        assertEquals(telephonyCountryCode, wifiCountryCode.toLowerCase(Locale.US));
    }

    /**
     * Test that {@link WifiManager#getCurrentNetwork()} returns a Network obeject consistent
     * with {@link ConnectivityManager#registerNetworkCallback} when connected to a Wifi network,
     * and returns null when not connected.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testGetCurrentNetwork"	"CtsWifiTestCases"	"1: permission"	"([3:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[3]:method_text:[));    }    /**     * Tests {@link WifiManager#isWpa3SaeSupported()} does not crash.     */   ]) :|: public void testGetCurrentNetwork() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // ensure Wifi is connected
        ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.reconnect());
        PollingCheck.check(
                ""Wifi not connected - Please ensure there is a saved network in range of this ""
                        + ""device"",
                WIFI_CONNECT_TIMEOUT_MILLIS,
                () -> mWifiManager.getConnectionInfo().getNetworkId() != -1);

        Network wifiCurrentNetwork = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getCurrentNetwork);
        assertNotNull(wifiCurrentNetwork);

        TestNetworkCallback networkCallbackListener = new TestNetworkCallback(mLock);
        synchronized (mLock) {
            try {
                // File a request for wifi network.
                mConnectivityManager.registerNetworkCallback(
                        new NetworkRequest.Builder()
                                .addTransportType(TRANSPORT_WIFI)
                                .build(),
                        networkCallbackListener);
                // now wait for callback
                mLock.wait(TEST_WAIT_DURATION_MS);
            } catch (InterruptedException e) {
            }
        }
        assertTrue(networkCallbackListener.onAvailableCalled);
        Network connectivityCurrentNetwork = networkCallbackListener.network;
        assertEquals(connectivityCurrentNetwork, wifiCurrentNetwork);

        setWifiEnabled(false);
        PollingCheck.check(
                ""Wifi not disconnected!"",
                20000,
                () -> mWifiManager.getConnectionInfo().getNetworkId() == -1);

        assertNull(ShellIdentityUtils.invokeWithShellPermissions(mWifiManager::getCurrentNetwork));
    }

    /**
     * Tests {@link WifiManager#isWpa3SaeSupported()} does not c"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testAddOrUpdatePasspointConfiguration"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[2]:method_text:[ Use API change     * metered override, verify Passpoint configuration changes with it.     */   ]) :|: public void testAddOrUpdatePasspointConfiguration() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // Create and install a Passpoint configuration
        PasspointConfiguration passpointConfiguration = createPasspointConfiguration();
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            mWifiManager.addOrUpdatePasspointConfiguration(passpointConfiguration);

            // Compare configurations
            List<PasspointConfiguration> configurations = mWifiManager.getPasspointConfigurations();
            assertNotNull(""The installed passpoint profile is missing"", configurations);
            assertEquals(passpointConfiguration, getTargetPasspointConfiguration(configurations,
                    passpointConfiguration.getUniqueId()));
        } finally {
            // Clean up
            mWifiManager.removePasspointConfiguration(passpointConfiguration.getHomeSp().getFqdn());
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#setPasspointMeteredOverride(String, int)}
     * adds a Passpoint configuration correctly, check the default metered setting. Use API change
     * metered override, verify Passpoint configuration changes with it.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testSetPasspointMeteredOverride"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[2]:method_text:[}     * starts a subscription provisioning, and confirm a status callback invoked once.     */   ]) :|: public void testSetPasspointMeteredOverride() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // Create and install a Passpoint configuration
        PasspointConfiguration passpointConfiguration = createPasspointConfiguration();
        String fqdn = passpointConfiguration.getHomeSp().getFqdn();
        String uniqueId = passpointConfiguration.getUniqueId();
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();

        try {
            uiAutomation.adoptShellPermissionIdentity();
            mWifiManager.addOrUpdatePasspointConfiguration(passpointConfiguration);
            PasspointConfiguration saved = getTargetPasspointConfiguration(
                    mWifiManager.getPasspointConfigurations(), uniqueId);
            assertNotNull(""The installed passpoint profile is missing"", saved);
            // Verify meter override setting.
            assertEquals(""Metered overrider default should be none"",
                    WifiConfiguration.METERED_OVERRIDE_NONE, saved.getMeteredOverride());
            // Change the meter override setting.
            mWifiManager.setPasspointMeteredOverride(fqdn,
                    WifiConfiguration.METERED_OVERRIDE_METERED);
            // Verify passpoint config change with the new setting.
            saved = getTargetPasspointConfiguration(
                    mWifiManager.getPasspointConfigurations(), uniqueId);
            assertNotNull(""The installed passpoint profile is missing"", saved);
            assertEquals(""Metered override should be metered"",
                    WifiConfiguration.METERED_OVERRIDE_METERED, saved.getMeteredOverride());
        } finally {
            // Clean up
            mWifiManager.removePasspointConfiguration(fqdn);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests that
     * {@link Wif"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testStartSubscriptionProvisioning"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[2]:method_text:[**     * Tests {@link WifiManager#setTdlsEnabled(InetAddress, boolean)} does not crash.     */   ]) :|: public void testStartSubscriptionProvisioning() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // Using Java reflection to construct an OsuProvider instance because its constructor is
        // hidden and not available to apps.
        Class<?> osuProviderClass = Class.forName(""android.net.wifi.hotspot2.OsuProvider"");
        Constructor<?> osuProviderClassConstructor = osuProviderClass.getConstructor(String.class,
                Map.class, String.class, Uri.class, String.class, List.class);

        OsuProvider osuProvider = (OsuProvider) osuProviderClassConstructor.newInstance(TEST_SSID,
                TEST_FRIENDLY_NAMES, TEST_SERVICE_DESCRIPTION, TEST_SERVER_URI, TEST_NAI,
                TEST_METHOD_LIST);

        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            synchronized (mLock) {
                // Start a subscription provisioning for a non-existent Passpoint R2 AP
                mWifiManager.startSubscriptionProvisioning(osuProvider, mExecutor,
                        mProvisioningCallback);
                mLock.wait(TEST_WAIT_DURATION_MS);
            }
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }

        // Expect only a single callback event, connecting. Since AP doesn't exist, it ends here
        assertEquals(ProvisioningCallback.OSU_STATUS_AP_CONNECTING, mProvisioningStatus);
        // No failure callbacks expected
        assertEquals(0, mProvisioningFailureStatus);
        // No completion callback expected
        assertFalse(mProvisioningComplete);
    }

    /**
     * Tests {@link WifiManager#setTdlsEnabled(InetAddress, boolean)} does not crash.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testGetAllWifiConfigForMatchedNetworkSuggestion"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[2]:method_text:[y());    }    /**     * Tests {@link WifiManager#getMatchingScanResults(List, List)}     */   ]) :|: public void testGetAllWifiConfigForMatchedNetworkSuggestion() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        ScanResult scanResult = new ScanResult();
        scanResult.SSID = TEST_SSID;
        scanResult.capabilities = TEST_PSK_CAP;
        scanResult.BSSID = TEST_BSSID;
        List<ScanResult> testList = Arrays.asList(scanResult);
        WifiNetworkSuggestion suggestion = new WifiNetworkSuggestion.Builder()
                .setSsid(TEST_SSID).setWpa2Passphrase(TEST_PASSPHRASE).build();

        assertEquals(WifiManager.STATUS_NETWORK_SUGGESTIONS_SUCCESS,
                mWifiManager.addNetworkSuggestions(Arrays.asList(suggestion)));
        List<WifiConfiguration> matchedResult;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            matchedResult = mWifiManager
                    .getWifiConfigForMatchedNetworkSuggestionsSharedWithUser(testList);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
        // As suggestion is not approved, will return empty list.
        assertTrue(matchedResult.isEmpty());
    }

    /**
     * Tests {@link WifiManager#getMatchingScanResults(List, List)}
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testDisableEphemeralNetwork"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[2]:method_text:[;        }    }    /**     * Tests {@link WifiManager#allowAutojoin(int, boolean)}.     */   ]) :|: public void testDisableEphemeralNetwork() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // Trigger a scan & wait for connection to one of the saved networks.
        mWifiManager.startScan();
        waitForConnection();

        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        List<WifiConfiguration> savedNetworks = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // Temporarily disable on all networks.
            savedNetworks = mWifiManager.getConfiguredNetworks();
            for (WifiConfiguration network : savedNetworks) {
                mWifiManager.disableEphemeralNetwork(network.SSID);
            }
            // trigger a disconnect and wait for disconnect.
            mWifiManager.disconnect();
            waitForDisconnection();

            // Now trigger scan and ensure that the device does not connect to any networks.
            mWifiManager.startScan();
            ensureNotConnected();
        } finally {
            uiAutomation.dropShellPermissionIdentity();
            setWifiEnabled(false);
        }
    }

    /**
     * Tests {@link WifiManager#allowAutojoin(int, boolean)}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testAllowAutojoin"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[2]:method_text:[    }    /**     * Tests {@link WifiManager#allowAutojoinPasspoint(String, boolean)}.     */   ]) :|: public void testAllowAutojoin() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // Trigger a scan & wait for connection to one of the saved networks.
        mWifiManager.startScan();
        waitForConnection();

        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        List<WifiConfiguration> savedNetworks = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // disable autojoin on all networks.
            savedNetworks = mWifiManager.getConfiguredNetworks();
            for (WifiConfiguration network : savedNetworks) {
                mWifiManager.allowAutojoin(network.networkId, false);
            }
            // trigger a disconnect and wait for disconnect.
            mWifiManager.disconnect();
            waitForDisconnection();

            // Now trigger scan and ensure that the device does not connect to any networks.
            mWifiManager.startScan();
            ensureNotConnected();

            // Now enable autojoin on all networks.
            for (WifiConfiguration network : savedNetworks) {
                mWifiManager.allowAutojoin(network.networkId, true);
            }

            // Trigger a scan & wait for connection to one of the saved networks.
            mWifiManager.startScan();
            waitForConnection();
        } finally {
            // Restore auto join state.
            if (savedNetworks != null) {
                for (WifiConfiguration network : savedNetworks) {
                    mWifiManager.allowAutojoin(network.networkId, network.allowAutojoin);
                }
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#allowAutojoinPasspoint(String, boolean)}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testAllowAutojoinPasspoint"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[2]:method_text:[        }    }    /**     * Tests {@link WifiManager#allowAutojoinGlobal(boolean)}.     */   ]) :|: public void testAllowAutojoinPasspoint() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        PasspointConfiguration passpointConfiguration = createPasspointConfiguration();
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            mWifiManager.addOrUpdatePasspointConfiguration(passpointConfiguration);
            // Turn off auto-join
            mWifiManager.allowAutojoinPasspoint(
                    passpointConfiguration.getHomeSp().getFqdn(), false);
            // Turn on auto-join
            mWifiManager.allowAutojoinPasspoint(
                    passpointConfiguration.getHomeSp().getFqdn(), true);
        } finally {
            mWifiManager.removePasspointConfiguration(passpointConfiguration.getHomeSp().getFqdn());
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#allowAutojoinGlobal(boolean)}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testAllowAutojoinGlobal"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[2]:method_text:[     }    }    /**     * Tests {@link WifiManager#isWapiSupported()} does not crash.     */   ]) :|: public void testAllowAutojoinGlobal() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // Trigger a scan & wait for connection to one of the saved networks.
        mWifiManager.startScan();
        waitForConnection();

        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // disable autojoin on all networks.
            mWifiManager.allowAutojoinGlobal(false);

            // trigger a disconnect and wait for disconnect.
            mWifiManager.disconnect();
            waitForDisconnection();

            // Now trigger scan and ensure that the device does not connect to any networks.
            mWifiManager.startScan();
            ensureNotConnected();

            // Now enable autojoin on all networks.
            mWifiManager.allowAutojoinGlobal(true);

            // Trigger a scan & wait for connection to one of the saved networks.
            mWifiManager.startScan();
            waitForConnection();
        } finally {
            // Re-enable auto join if the test fails for some reason.
            mWifiManager.allowAutojoinGlobal(true);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#isWapiSupported()} does not crash.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testIs60GhzBandSupportedOnSOrNewer"	"CtsWifiTestCases"	"1: permission"	"([1:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[1]:method_text:[he needed privileged permissions     */    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)   ]) :|: public void testIs60GhzBandSupportedOnSOrNewer() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // check for 60ghz support with wifi enabled
        boolean isSupportedWhenWifiEnabled = mWifiManager.is60GHzBandSupported();

        // Check for 60GHz support with wifi disabled
        setWifiEnabled(false);
        PollingCheck.check(
                ""Wifi not disabled!"",
                20000,
                () -> !mWifiManager.isWifiEnabled());
        boolean isSupportedWhenWifiDisabled = mWifiManager.is60GHzBandSupported();

        // If Support is true when WiFi is disable, then it has to be true when it is enabled.
        // Note, the reverse is a valid case.
        if (isSupportedWhenWifiDisabled) {
            assertTrue(isSupportedWhenWifiEnabled);
        }
    }

    public class TestCoexCallback extends WifiManager.CoexCallback {
        private Object mCoexLock;
        private int mOnCoexUnsafeChannelChangedCount;
        private List<CoexUnsafeChannel> mCoexUnsafeChannels;
        private int mCoexRestrictions;

        TestCoexCallback(Object lock) {
            mCoexLock = lock;
        }

        @Override
        public void onCoexUnsafeChannelsChanged(
                    @NonNull List<CoexUnsafeChannel> unsafeChannels, int restrictions) {
            synchronized (mCoexLock) {
                mCoexUnsafeChannels = unsafeChannels;
                mCoexRestrictions = restrictions;
                mOnCoexUnsafeChannelChangedCount++;
                mCoexLock.notify();
            }
        }

        public int getOnCoexUnsafeChannelChangedCount() {
            synchronized (mCoexLock) {
                return mOnCoexUnsafeChannelChangedCount;
            }
        }

        public List<CoexUnsafeChannel> getCoexUnsafeChannels() {
            return mCoexUnsafeChannels;
        }

        public int getCoexRestrictions() {"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testCoexMethodsShouldFailNoPermission"	"CtsWifiTestCases"	"1: permission"	"([1:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[1]:method_text:[d, no-op is also valid behavior.     */    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)   ]) :|: public void testCoexMethodsShouldFailNoPermission() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        try {
            mWifiManager.setCoexUnsafeChannels(Collections.emptyList(), 0);
            fail(""setCoexUnsafeChannels should not succeed - privileged call"");
        } catch (SecurityException e) {
            // expected
        }
        final TestCoexCallback callback = new TestCoexCallback(mLock);
        try {
            mWifiManager.registerCoexCallback(mExecutor, callback);
            fail(""registerCoexCallback should not succeed - privileged call"");
        } catch (SecurityException e) {
            // expected
        }
        try {
            mWifiManager.unregisterCoexCallback(callback);
            fail(""unregisterCoexCallback should not succeed - privileged call"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Test that coex-related methods succeed in setting the current unsafe channels and notifying
     * the listener. Since the default coex algorithm may be enabled, no-op is also valid behavior.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testListenOnCoexUnsafeChannels"	"CtsWifiTestCases"	"1: permission"	"([3:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[3]:method_text:[ork configurations are rejected.     */    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)   ]) :|: public void testListenOnCoexUnsafeChannels() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // These below API's only work with privileged permissions (obtained via shell identity
        // for test)
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        List<CoexUnsafeChannel> prevUnsafeChannels = null;
        int prevRestrictions = -1;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            final TestCoexCallback callback = new TestCoexCallback(mLock);
            final List<CoexUnsafeChannel> testUnsafeChannels = new ArrayList<>();
            testUnsafeChannels.add(new CoexUnsafeChannel(WIFI_BAND_24_GHZ, 6));
            final int testRestrictions = COEX_RESTRICTION_WIFI_DIRECT
                    | COEX_RESTRICTION_SOFTAP | COEX_RESTRICTION_WIFI_AWARE;
            synchronized (mLock) {
                try {
                    mWifiManager.registerCoexCallback(mExecutor, callback);
                    // Callback should be called after registering
                    mLock.wait(TEST_WAIT_DURATION_MS);
                    assertEquals(1, callback.getOnCoexUnsafeChannelChangedCount());
                    // Store the previous coex channels and set new coex channels
                    prevUnsafeChannels = callback.getCoexUnsafeChannels();
                    prevRestrictions = callback.getCoexRestrictions();
                    mWifiManager.setCoexUnsafeChannels(testUnsafeChannels, testRestrictions);
                    mLock.wait(TEST_WAIT_DURATION_MS);
                    // Unregister callback and try setting again
                    mWifiManager.unregisterCoexCallback(callback);
                    mWifiManager.setCoexUnsafeChannels(testUnsafeChannels, testRestrictions);
                    // Callback should not be called here since it was unregistered."	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testInsecureEnterpriseConfigurationsRejected"	"CtsWifiTestCases"	"1: permission"	"([3:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[3]:method_text:[     * Tests {@link WifiManager#isPasspointTermsAndConditionsSupported)} does not crash.     */   ]) :|: public void testInsecureEnterpriseConfigurationsRejected() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        WifiConfiguration wifiConfiguration = new WifiConfiguration();
        wifiConfiguration.SSID = SSID1;
        wifiConfiguration.setSecurityParams(WifiConfiguration.SECURITY_TYPE_EAP_WPA3_ENTERPRISE);
        wifiConfiguration.enterpriseConfig.setEapMethod(WifiEnterpriseConfig.Eap.TTLS);
        int networkId = INVALID_NETWORK_ID;

        // These below API's only work with privileged permissions (obtained via shell identity
        // for test)
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();

            // Verify that an insecure network is rejected
            assertEquals(INVALID_NETWORK_ID, mWifiManager.addNetwork(wifiConfiguration));

            // Now configure it correctly with a Root CA cert and domain name
            wifiConfiguration.enterpriseConfig.setCaCertificate(FakeKeys.CA_CERT0);
            wifiConfiguration.enterpriseConfig.setAltSubjectMatch(TEST_DOM_SUBJECT_MATCH);

            // Verify that the network is added
            networkId = mWifiManager.addNetwork(wifiConfiguration);
            assertNotEquals(INVALID_NETWORK_ID, networkId);

            // Verify that the update API accepts configurations configured securely
            wifiConfiguration.networkId = networkId;
            assertEquals(networkId, mWifiManager.updateNetwork(wifiConfiguration));

            // Now clear the security configuration
            wifiConfiguration.enterpriseConfig.setCaCertificate(null);
            wifiConfiguration.enterpriseConfig.setAltSubjectMatch(null);

            // Verify that the update API rejects insecure configurations
            assertEquals(INVALID_NETWORK_ID, mWifiManager.updateNetwork(wi"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsPasspointTermsAndConditionsSupported"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[2]:method_text:[is not even given to shell user.     */    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)   ]) :|: public void testIsPasspointTermsAndConditionsSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        mWifiManager.isPasspointTermsAndConditionsSupported();
    }

    /**
     * Test that call to {@link WifiManager#setOverrideCountryCode()},
     * {@link WifiManager#clearOverrideCountryCode()} and
     * {@link WifiManager#setDefaultCountryCode()} need privileged permission
     * and the permission is not even given to shell user.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testManageCountryCodeMethodsFailWithoutPermissions"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[2]:method_text:[    }    /**     * Tests {@link WifiManager#flushPasspointAnqpCache)} does not crash.     */   ]) :|: public void testManageCountryCodeMethodsFailWithoutPermissions() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        ShellIdentityUtils.invokeWithShellPermissions(() -> {
            try {
                mWifiManager.setOverrideCountryCode(TEST_COUNTRY_CODE);
                fail(""setOverrideCountryCode() expected to fail - privileged call"");
            } catch (SecurityException e) {
                // expected
            }

            try {
                mWifiManager.clearOverrideCountryCode();
                fail(""clearOverrideCountryCode() expected to fail - privileged call"");
            } catch (SecurityException e) {
                // expected
            }

            try {
                mWifiManager.setDefaultCountryCode(TEST_COUNTRY_CODE);
                fail(""setDefaultCountryCode() expected to fail - privileged call"");
            } catch (SecurityException e) {
                // expected
            }
        });
    }

    /**
     * Tests {@link WifiManager#flushPasspointAnqpCache)} does not crash.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testFlushPasspointAnqpCache"	"CtsWifiTestCases"	"1: permission"	"([3:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[3]:method_text:[    /**     * Tests {@link WifiManager#isDecoratedIdentitySupported)} does not crash.     */   ]) :|: public void testFlushPasspointAnqpCache() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        // The below API only works with privileged permissions (obtained via shell identity
        // for test)
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            mWifiManager.flushPasspointAnqpCache();
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#isDecoratedIdentitySupported)} does not crash.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testSetCarrierNetworkOffloadEnabled"	"CtsWifiTestCases"	"1: permission"	"([3:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[3]:method_text:[ if the release is older than S.     */    @SdkSuppress(maxSdkVersion = Build.VERSION_CODES.R)   ]) :|: public void testSetCarrierNetworkOffloadEnabled() {
        if (!WifiFeature.isWifiSupported(getContext())
                || !WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        assertTrue(mWifiManager.isCarrierNetworkOffloadEnabled(TEST_SUB_ID, false));
        // The below API only works with privileged permissions (obtained via shell identity
        // for test)
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            mWifiManager.setCarrierNetworkOffloadEnabled(TEST_SUB_ID, false, false);
            assertFalse(mWifiManager.isCarrierNetworkOffloadEnabled(TEST_SUB_ID, false));
        } finally {
            mWifiManager.setCarrierNetworkOffloadEnabled(TEST_SUB_ID, false, true);
            uiAutomation.dropShellPermissionIdentity();
        }
        assertTrue(mWifiManager.isCarrierNetworkOffloadEnabled(TEST_SUB_ID, false));
    }

   /**
     * Test that {@link WifiManager#getUsableChannels(int, int)},
     * {@link WifiManager#getAllowedChannels(int, int)}
     * throws UnsupportedOperationException if the release is older than S.
     */
    @SdkSuppress(maxSdkVersion = Build.VERSION_CODES.R)"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testGetAllowedChannels"	"CtsWifiTestCases"	"1: permission"	"([3:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[3]:method_text:[nels(int, int))} does not crash.     */    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)   ]) :|: public void testGetAllowedChannels() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // The below API only works with privileged permissions (obtained via shell identity
        // for test)
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {

            WifiAvailableChannel channel = new WifiAvailableChannel(2412, OP_MODE_SAP);
            assertEquals(channel.getFrequencyMhz(), 2412);
            assertEquals(channel.getOperationalModes(), OP_MODE_SAP);
            final List<Integer> valid24GhzFreqs = Arrays.asList(
                2412, 2417, 2422, 2427, 2432, 2437, 2442,
                2447, 2452, 2457, 2462, 2467, 2472, 2484);
            Set<Integer> supported24GhzFreqs = new HashSet<Integer>();
            uiAutomation.adoptShellPermissionIdentity();
            List<WifiAvailableChannel> allowedChannels =
                mWifiManager.getAllowedChannels(WIFI_BAND_24_GHZ, OP_MODE_STA);
            assertNotNull(allowedChannels);
            for (WifiAvailableChannel ch : allowedChannels) {
                //Must contain a valid 2.4GHz frequency
                assertTrue(valid24GhzFreqs.contains(ch.getFrequencyMhz()));
                if(ch.getFrequencyMhz() <= 2462) {
                    //Channels 1-11 are supported for STA in all countries
                    assertEquals(ch.getOperationalModes() & OP_MODE_STA, OP_MODE_STA);
                    supported24GhzFreqs.add(ch.getFrequencyMhz());
                }
            }
            //Channels 1-11 are supported for STA in all countries
            assertEquals(supported24GhzFreqs.size(), 11);
        } catch (UnsupportedOperationException ex) {
            //expected if the device does not support this API
        } catch (Exception ex) {
            fail(""getAllowedChannels unexpected Exception "" + ex);
        } finally"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.cts.WifiManagerTest"	"testGetUsableChannels"	"CtsWifiTestCases"	"1: permission"	"([3:/android/net/wifi/cts/WifiManagerTest.java]:[permission]:[3]:method_text:[eature is enabled on the device.     */    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)   ]) :|: public void testGetUsableChannels() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // The below API only works with privileged permissions (obtained via shell identity
        // for test)
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            List<WifiAvailableChannel> usableChannels =
                mWifiManager.getUsableChannels(WIFI_BAND_24_GHZ, OP_MODE_STA);
            //There must be at least one usable channel in 2.4GHz band
            assertFalse(usableChannels.isEmpty());
        } catch (UnsupportedOperationException ex) {
            //expected if the device does not support this API
        } catch (Exception ex) {
            fail(""getUsableChannels unexpected Exception "" + ex);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Validate that the Passpoint feature is enabled on the device.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.aware.cts.SingleDeviceTest"	"waitForListener"	"CtsWifiTestCases"	"1: permission"	"([3:/android/net/wifi/aware/cts/SingleDeviceTest.java]:[permission]:[3]:method_text:[t in the CDD. However, the tested values are     *   based on the Wi-Fi Aware protocol.     */   ]) :|: public void test/*
 *.
 */

package android.net.wifi.aware.cts;

import static org.junit.Assert.assertNotEquals;
import static org.mockito.Mockito.mock;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.location.LocationManager;
import android.net.ConnectivityManager;
import android.net.MacAddress;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.wifi.WifiManager;
import android.net.wifi.aware.AttachCallback;
import android.net.wifi.aware.AwareResources;
import android.net.wifi.aware.Characteristics;
import android.net.wifi.aware.DiscoverySession;
import android.net.wifi.aware.DiscoverySessionCallback;
import android.net.wifi.aware.IdentityChangedListener;
import android.net.wifi.aware.ParcelablePeerHandle;
import android.net.wifi.aware.PeerHandle;
import android.net.wifi.aware.PublishConfig;
import android.net.wifi.aware.PublishDiscoverySession;
import android.net.wifi.aware.SubscribeConfig;
import android.net.wifi.aware.SubscribeDiscoverySession;
import android.net.wifi.aware.WifiAwareManager;
import android.net.wifi.aware.WifiAwareNetworkSpecifier;
import android.net.wifi.aware.WifiAwareSession;
import android.net.wifi.cts.WifiBuildCompat;
import android.net.wifi.cts.WifiJUnit3TestBase;
import android.os.Build;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Parcel;
import android.platform.test.annotations.AppModeFull;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * Wi-Fi Aware CTS test suite: si"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/aware/cts/SingleDeviceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.wifi.nl80211.cts.WifiNl80211ManagerTest"	"testCountryCodeChangeListener"	"CtsWifiTestCases"	"1: permission"	"([2:/android/net/wifi/nl80211/cts/WifiNl80211ManagerTest.java]:[permission]:[2]:method_text:[ener));        manager.unregisterCountryCodeChangedListener(testCountryCodeChangeListener);    }}]) :|: 
    public void testCountryCodeChangeListener() {
        TestCountryCodeChangeListener testCountryCodeChangeListener =
                new TestCountryCodeChangeListener();
        TestExecutor executor = new TestExecutor();
        WifiManager wifiManager = mContext.getSystemService(WifiManager.class);
        // Enable wifi to trigger country code change
        wifiManager.setWifiEnabled(true);
        WifiNl80211Manager manager = mContext.getSystemService(WifiNl80211Manager.class);
        // Register listener and unregister listener for API coverage only.
        // Since current cts don't have sufficient permission to call WifiNl80211Manager API.
        // Assert register fail because the CTS don't have sufficient permission to call
        // WifiNl80211Manager API which are guarded by selinux.
        assertFalse(manager.registerCountryCodeChangedListener(executor,
                testCountryCodeChangeListener));
        manager.unregisterCountryCodeChangedListener(testCountryCodeChangeListener);
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/nl80211/cts/WifiNl80211ManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.graphics.cts.SetFrameRateTest"	"adoptShellPermissionIdentity"	"CtsGraphicsTestCases"	"1: permission"	"([5:/android/graphics/cts/SetFrameRateTest.java]:[permission]:[5]:method_text:[yToken(mFrameRateFlexibilityToken);            mFrameRateFlexibilityToken = 0;        }    }   ]) :|: /*
 *.
 */

package android.graphics.cts;

import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;

import static org.junit.Assert.assertTrue;

import android.app.UiAutomation;
import android.content.Context;
import android.util.Log;
import android.view.Surface;
import android.view.SurfaceControl;

import androidx.test.filters.MediumTest;
import androidx.test.rule.ActivityTestRule;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.DisplayUtil;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

@MediumTest
@RunWith(AndroidJUnit4.class)
public class SetFrameRateTest {
    private static String TAG = ""SetFrameRateTest"";

    @Rule
    public ActivityTestRule<FrameRateCtsActivity> mActivityRule =
            new ActivityTestRule<>(FrameRateCtsActivity.class);
    private long mFrameRateFlexibilityToken;

    @Before
    public void setUp() throws Exception {
        // Surface flinger requires the ACCESS_SURFACE_FLINGER permission to acquire a frame
        // rate flexibility token. Switch to shell permission identity so we'll have the
        // necessary permission when surface flinger checks.
        UiAutomation uiAutomation = getInstrumentation().getUiAutomation();
        uiAutomation.adoptShellPermissionIdentity();

        Context context = getInstrumentation().getTargetContext();
        assertTrue(""Physical display is expected."", DisplayUtil.isDisplayConnected(context));

        try {
            // Take ownership of the frame rate flexibility token, if we were able
            // to get one - we'll release it in tearDown().
            mFrameRateFlexibilityToken = SurfaceControl.acquireFrameRateFlexibilityToken();
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }

        if (mFrameRateFlexibilityToken == 0) {
            Log.e(TAG, ""Failed to acquire frame rate flexibility tok"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/cts/SetFrameRateTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.graphics.fonts.DataDirPermissionTest"	"testDataFontDirPermission"	"CtsGraphicsTestCases"	"1: permission"	"([1:/android/graphics/fonts/DataDirPermissionTest.java]:[permission]:[1]:method_text:[     assertThat(file.canRead()).isFalse();        assertThat(file.canWrite()).isFalse();    }   ]) :|: 
    public void testDataFontDirPermission() {
        File file = new File(FONT_DATA_DIR);
        assertThat(file.isDirectory()).isTrue();
        assertThat(file.canRead()).isFalse();
        assertThat(file.canWrite()).isFalse();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/fonts/DataDirPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.graphics.fonts.DataDirPermissionTest"	"testDataFontFilesDirPermission"	"CtsGraphicsTestCases"	"1: permission"	"([1:/android/graphics/fonts/DataDirPermissionTest.java]:[permission]:[1]:method_text:[     assertThat(file.canRead()).isFalse();        assertThat(file.canWrite()).isFalse();    }   ]) :|: 
    public void testDataFontFilesDirPermission() {
        File file = new File(FONT_DATA_FILES_DIR);
        assertThat(file.isDirectory()).isTrue();
        assertThat(file.canRead()).isFalse();
        assertThat(file.canWrite()).isFalse();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/fonts/DataDirPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.multiuser.cts.UserManagerTest"	"testCloneUser"	"CtsMultiUserTestCases"	"1: permission"	"([5:/android/multiuser/cts/UserManagerTest.java]:[permission]:[5]:method_text:[e();            mInstrumentation.getUiAutomation().dropShellPermissionIdentity();        }    }}]) :|: 
    @SystemUserOnly(reason = ""Profiles are only supported on system user."")
    public void testCloneUser() throws Exception {
        // Need CREATE_USERS permission to create user in test
        mInstrumentation.getUiAutomation().adoptShellPermissionIdentity(
                Manifest.permission.CREATE_USERS, Manifest.permission.INTERACT_ACROSS_USERS);
        Set<String> disallowedPackages = new HashSet<String>();
        UserHandle userHandle = mUserManager.createProfile(
                ""Clone user"", UserManager.USER_TYPE_PROFILE_CLONE, disallowedPackages);
        assertThat(userHandle).isNotNull();

        try {
            final Context userContext = mContext.createPackageContextAsUser(""system"", 0,
                    userHandle);
            final UserManager cloneUserManager = userContext.getSystemService(UserManager.class);
            assertThat(cloneUserManager.isMediaSharedWithParent()).isTrue();
            assertThat(cloneUserManager.isCloneProfile()).isTrue();

            List<UserInfo> list = mUserManager.getUsers(true, true, true);
            List<UserInfo> cloneUsers = list.stream().filter(
                    user -> (user.id == userHandle.getIdentifier()
                            && user.isCloneProfile()))
                    .collect(Collectors.toList());
            assertThat(cloneUsers.size()).isEqualTo(1);
        } finally {
            assertThat(mUserManager.removeUser(userHandle)).isTrue();
            mInstrumentation.getUiAutomation().dropShellPermissionIdentity();
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/multiuser/src/android/multiuser/cts/UserManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"setUpTest"	"CtsPermission5TestCases"	"1: permission"	"([6:/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt]:[permission]:[6]:method_text:[appOpsManager.clearHistory()            appOpsManager.resetHistoryParameters()        }    }   ]) :|: /*
 *.
 */
package android.permission5.cts

import android.Manifest
import android.app.AppOpsManager
import android.app.Instrumentation
import android.content.AttributionSource
import android.content.ComponentName
import android.content.ContentValues
import android.content.Context
import android.content.ContextParams
import android.content.Intent
import android.content.pm.PackageManager.FEATURE_LEANBACK
import android.net.Uri
import android.os.Bundle
import android.os.Process
import android.os.RemoteCallback
import android.os.SystemClock
import android.os.UserHandle
import android.permission.PermissionManager
import android.platform.test.annotations.AppModeFull
import android.provider.CalendarContract
import android.provider.CallLog
import android.provider.ContactsContract
import android.provider.Telephony
import android.speech.RecognitionListener
import android.speech.SpeechRecognizer
import androidx.test.platform.app.InstrumentationRegistry
import com.android.compatibility.common.util.SystemUtil
import com.google.common.truth.Truth.assertThat
import org.junit.After
import org.junit.Assume.assumeFalse
import org.junit.Before
import org.junit.Test
import org.mockito.ArgumentMatcher
import org.mockito.Mockito.eq
import org.mockito.Mockito.inOrder
import org.mockito.Mockito.intThat
import org.mockito.Mockito.isNull
import org.mockito.Mockito.mock
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicReference
import java.util.concurrent.locks.ReentrantLock
import java.util.function.Consumer

@AppModeFull(reason = ""Instant apps cannot hold READ_CONTACTS/READ_CALENDAR/READ_SMS/READ_CALL_LOG"")
class RuntimePermissionsAppOpTrackingTest {

    @Before
    fun setUpTest() {
        val appOpsManager = context.getSystemService(AppOpsManager::class.java)!!
        SystemUtil.runWithShellPermissionIdentity {
            appOpsManager.clearHistory()
            appOpsManager.setHistoryParameters("	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testSelfContactsAccess"	"CtsPermission5TestCases"	"1: permission"	"([1:/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt]:[permission]:[1]:method_text:[ContactsContract.Contacts.CONTENT_URI,                Manifest.permission.READ_CONTACTS)    }   ]) :|: 
    @Throws(Exception::class)
    fun testSelfContactsAccess() {
        testSelfAccess(ContactsContract.Contacts.CONTENT_URI,
                Manifest.permission.READ_CONTACTS)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testSelfCalendarAccess"	"CtsPermission5TestCases"	"1: permission"	"([1:/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt]:[permission]:[1]:method_text:[alendarContract.Calendars.CONTENT_URI,                Manifest.permission.READ_CALENDAR)    }   ]) :|: 
    @Throws(Exception::class)
    fun testSelfCalendarAccess() {
        testSelfAccess(CalendarContract.Calendars.CONTENT_URI,
                Manifest.permission.READ_CALENDAR)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testSelfSmsAccess"	"CtsPermission5TestCases"	"1: permission"	"([1:/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt]:[permission]:[1]:method_text:[  testSelfAccess(Telephony.Sms.CONTENT_URI,                Manifest.permission.READ_SMS)    }   ]) :|: 
    @Throws(Exception::class)
    fun testSelfSmsAccess() {
        assumeNotTv()
        testSelfAccess(Telephony.Sms.CONTENT_URI,
                Manifest.permission.READ_SMS)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testSelfCallLogAccess"	"CtsPermission5TestCases"	"1: permission"	"([4:/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt]:[permission]:[4]:method_text:[eceiverAccessCount*/ 0, /*checkAccessor*/ true,                /*fromDatasource*/ false)    }   ]) :|: 
    @Throws(Exception::class)
    fun testSelfCallLogAccess() {
        testSelfAccess(CallLog.Calls.CONTENT_URI,
                Manifest.permission.READ_CALL_LOG)
    }

    @Throws(Exception::class)
    private fun testSelfAccess(uri: Uri, permission: String) {
        val context = createAttributionContext(ACCESSOR_ATTRIBUTION_TAG, null, null)
        val beginEndMillis = System.currentTimeMillis()
        context.contentResolver.query(uri, null, null, null)!!.close()
        val endTimeMillis = System.currentTimeMillis()

        assertNotRunningOpAccess(AppOpsManager.permissionToOp(permission)!!,
                beginEndMillis, endTimeMillis, context.attributionSource,
                /*accessorForeground*/ true, /*receiverForeground*/ false,
                /*accessorTrusted*/ true, /*accessorAccessCount*/ 1,
                /*receiverAccessCount*/ 0, /*checkAccessor*/ true,
                /*fromDatasource*/ false)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testSelfCalendarWrite"	"CtsPermission5TestCases"	"1: permission"	"([1:/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt]:[permission]:[1]:method_text:[lendarContract.Calendars.CONTENT_URI,                Manifest.permission.WRITE_CALENDAR)    }   ]) :|: 
    @Throws(Exception::class)
    fun testSelfCalendarWrite() {
        testSelfWrite(CalendarContract.Calendars.CONTENT_URI,
                Manifest.permission.WRITE_CALENDAR)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testSelfCallLogWrite"	"CtsPermission5TestCases"	"1: permission"	"([4:/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt]:[permission]:[4]:method_text:[eceiverAccessCount*/ 0, /*checkAccessor*/ true,                /*fromDatasource*/ false)    }   ]) :|: 
    @Throws(Exception::class)
    fun testSelfCallLogWrite() {
        testSelfWrite(CallLog.Calls.CONTENT_URI,
                Manifest.permission.WRITE_CALL_LOG)
    }

    @Throws(Exception::class)
    private fun testSelfWrite(uri: Uri, permission: String) {
        val context = createAttributionContext(ACCESSOR_ATTRIBUTION_TAG, null, null)
        val beginEndMillis = System.currentTimeMillis()
        context.contentResolver.insert(uri, ContentValues())
        val endTimeMillis = System.currentTimeMillis()

        assertNotRunningOpAccess(AppOpsManager.permissionToOp(permission)!!,
                beginEndMillis, endTimeMillis, context.attributionSource,
                /*accessorForeground*/ true, /*receiverForeground*/ false,
                /*accessorTrusted*/ true, /*accessorAccessCount*/ 1,
                /*receiverAccessCount*/ 0, /*checkAccessor*/ true,
                /*fromDatasource*/ false)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testUntrustedContactsAccessAttributeToAnother"	"CtsPermission5TestCases"	"1: permission"	"([1:/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt]:[permission]:[1]:method_text:[ContactsContract.Contacts.CONTENT_URI,                Manifest.permission.READ_CONTACTS)    }   ]) :|: 
    @Throws(Exception::class)
    fun testUntrustedContactsAccessAttributeToAnother() {
        testUntrustedAccessAttributeToAnother(ContactsContract.Contacts.CONTENT_URI,
                Manifest.permission.READ_CONTACTS)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testUntrustedCalendarAccessAttributeToAnother"	"CtsPermission5TestCases"	"1: permission"	"([1:/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt]:[permission]:[1]:method_text:[alendarContract.Calendars.CONTENT_URI,                Manifest.permission.READ_CALENDAR)    }   ]) :|: 
    @Throws(Exception::class)
    fun testUntrustedCalendarAccessAttributeToAnother() {
        testUntrustedAccessAttributeToAnother(CalendarContract.Calendars.CONTENT_URI,
                Manifest.permission.READ_CALENDAR)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testUntrustedSmsAccessAttributeToAnother"	"CtsPermission5TestCases"	"1: permission"	"([1:/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt]:[permission]:[1]:method_text:[tributeToAnother(Telephony.Sms.CONTENT_URI,                Manifest.permission.READ_SMS)    }   ]) :|: 
    @Throws(Exception::class)
    fun testUntrustedSmsAccessAttributeToAnother() {
        assumeNotTv()
        testUntrustedAccessAttributeToAnother(Telephony.Sms.CONTENT_URI,
                Manifest.permission.READ_SMS)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testUntrustedCallLogAccessAttributeToAnother"	"CtsPermission5TestCases"	"1: permission"	"([4:/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt]:[permission]:[4]:method_text:[ceiverAccessCount*/ 1, /*checkAccessor*/ false,                /*fromDatasource*/ false)    }   ]) :|: 
    @Throws(Exception::class)
    fun testUntrustedCallLogAccessAttributeToAnother() {
        testUntrustedAccessAttributeToAnother(CallLog.Calls.CONTENT_URI,
                Manifest.permission.READ_CALL_LOG)
    }

    @Throws(Exception::class)
    private fun testUntrustedAccessAttributeToAnother(uri: Uri, permission: String) {
        val context = createAttributionContext(ACCESSOR_ATTRIBUTION_TAG,
                RECEIVER_PACKAGE_NAME, RECEIVER_ATTRIBUTION_TAG)
        val beginEndMillis = System.currentTimeMillis()
        context.contentResolver.query(uri, null, null, null)!!.close()
        val endTimeMillis = System.currentTimeMillis()

        assertNotRunningOpAccess(AppOpsManager.permissionToOp(permission)!!,
                beginEndMillis, endTimeMillis, context.attributionSource,
                /*accessorForeground*/ true, /*receiverForeground*/ false,
                /*accessorTrusted*/ false, /*accessorAccessCount*/ 1,
                /*receiverAccessCount*/ 1, /*checkAccessor*/ false,
                /*fromDatasource*/ false)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testUntrustedContactsAccessAttributeToAnotherThroughIntermediary"	"CtsPermission5TestCases"	"1: permission"	"([1:/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt]:[permission]:[1]:method_text:[ContactsContract.Contacts.CONTENT_URI,                Manifest.permission.READ_CONTACTS)    }   ]) :|: 
    @Throws(Exception::class)
    fun testUntrustedContactsAccessAttributeToAnotherThroughIntermediary() {
        testUntrustedAccessAttributeToAnotherThroughIntermediary(
                ContactsContract.Contacts.CONTENT_URI,
                Manifest.permission.READ_CONTACTS)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testUntrustedCalendarAccessAttributeToAnotherThroughIntermediary"	"CtsPermission5TestCases"	"1: permission"	"([1:/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt]:[permission]:[1]:method_text:[alendarContract.Calendars.CONTENT_URI,                Manifest.permission.READ_CALENDAR)    }   ]) :|: 
    @Throws(Exception::class)
    fun testUntrustedCalendarAccessAttributeToAnotherThroughIntermediary() {
        testUntrustedAccessAttributeToAnotherThroughIntermediary(
                CalendarContract.Calendars.CONTENT_URI,
                Manifest.permission.READ_CALENDAR)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testUntrustedSmsAccessAttributeToAnotherThroughIntermediary"	"CtsPermission5TestCases"	"1: permission"	"([1:/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt]:[permission]:[1]:method_text:[                Telephony.Sms.CONTENT_URI,                Manifest.permission.READ_SMS)    }   ]) :|: 
    @Throws(Exception::class)
    fun testUntrustedSmsAccessAttributeToAnotherThroughIntermediary() {
        assumeNotTv()
        testUntrustedAccessAttributeToAnotherThroughIntermediary(
                Telephony.Sms.CONTENT_URI,
                Manifest.permission.READ_SMS)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testUntrustedCallLogAccessAttributeToAnotherThroughIntermediary"	"CtsPermission5TestCases"	"1: permission"	"([6:/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt]:[permission]:[6]:method_text:[unt*/ 1, /*checkAccessor*/ false,                    /*fromDatasource*/ false)        }    }   ]) :|: 
    @Throws(Exception::class)
    fun testUntrustedCallLogAccessAttributeToAnotherThroughIntermediary() {
        testUntrustedAccessAttributeToAnotherThroughIntermediary(
                CallLog.Calls.CONTENT_URI,
                Manifest.permission.READ_CALL_LOG)
    }

    @Throws(Exception::class)
    private fun testUntrustedAccessAttributeToAnotherThroughIntermediary(
        uri: Uri,
        permission: String
    ) {
        runWithAuxiliaryApps {
            val nextAttributionSource = startBlamedAppActivity()

            val intermediaryContext = context.createContext(ContextParams.Builder()
                    .setNextAttributionSource(nextAttributionSource)
                    .setAttributionTag(ACCESSOR_ATTRIBUTION_TAG)
                    .build())

            val beginEndMillis = System.currentTimeMillis()
            intermediaryContext.contentResolver.query(uri, null, null, null)!!.close()
            val endTimeMillis = System.currentTimeMillis()

            // Assert first stage access
            assertNotRunningOpAccess(AppOpsManager.permissionToOp(permission)!!,
                    beginEndMillis, endTimeMillis, intermediaryContext.attributionSource,
                    /*accessorForeground*/ true, /*receiverForeground*/ true,
                    /*accessorTrusted*/ false, /*accessorAccessCount*/ 1,
                    /*receiverAccessCount*/ 1, /*checkAccessor*/ false,
                    /*fromDatasource*/ false)

            // Assert second stage access
            assertNotRunningOpAccess(AppOpsManager.permissionToOp(permission)!!,
                    beginEndMillis, endTimeMillis, nextAttributionSource,
                    /*accessorForeground*/ true, /*receiverForeground*/ false,
                    /*accessorTrusted*/ false, /*accessorAccessCount*/ 1,
                    /*receiverAccessCount*/ 1, /*checkAccessor*/ false,
                    /*fromDatasource*/ false)
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testTrustedAccessContactsAttributeToAnother"	"CtsPermission5TestCases"	"1: permission"	"([1:/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt]:[permission]:[1]:method_text:[ContactsContract.Contacts.CONTENT_URI,                Manifest.permission.READ_CONTACTS)    }   ]) :|: 
    @Throws(Exception::class)
    fun testTrustedAccessContactsAttributeToAnother() {
        testTrustedAccessAttributeToAnother(ContactsContract.Contacts.CONTENT_URI,
                Manifest.permission.READ_CONTACTS)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testTrustedAccessCalendarAttributeToAnother"	"CtsPermission5TestCases"	"1: permission"	"([1:/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt]:[permission]:[1]:method_text:[alendarContract.Calendars.CONTENT_URI,                Manifest.permission.READ_CALENDAR)    }   ]) :|: 
    @Throws(Exception::class)
    fun testTrustedAccessCalendarAttributeToAnother() {
        testTrustedAccessAttributeToAnother(CalendarContract.Calendars.CONTENT_URI,
                Manifest.permission.READ_CALENDAR)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testTrustedAccessSmsAttributeToAnother"	"CtsPermission5TestCases"	"1: permission"	"([1:/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt]:[permission]:[1]:method_text:[tributeToAnother(Telephony.Sms.CONTENT_URI,                Manifest.permission.READ_SMS)    }   ]) :|: 
    @Throws(Exception::class)
    fun testTrustedAccessSmsAttributeToAnother() {
        assumeNotTv()
        testTrustedAccessAttributeToAnother(Telephony.Sms.CONTENT_URI,
                Manifest.permission.READ_SMS)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testTrustedAccessCallLogAttributeToAnother"	"CtsPermission5TestCases"	"1: permission"	"([7:/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt]:[permission]:[7]:method_text:[ceiverAccessCount*/ 1, /*checkAccessor*/ false,                /*fromDatasource*/ false)    }   ]) :|: 
    @Throws(Exception::class)
    fun testTrustedAccessCallLogAttributeToAnother() {
        testTrustedAccessAttributeToAnother(CallLog.Calls.CONTENT_URI,
                Manifest.permission.READ_CALL_LOG)
    }

    @Throws(Exception::class)
    private fun testTrustedAccessAttributeToAnother(uri: Uri, permission: String) {
        val context = createAttributionContext(ACCESSOR_ATTRIBUTION_TAG,
                RECEIVER_PACKAGE_NAME, RECEIVER_ATTRIBUTION_TAG)
        val beginEndMillis = System.currentTimeMillis()
        SystemUtil.runWithShellPermissionIdentity {
            context.contentResolver.query(uri, null, null, null)!!.close()
        }
        val endTimeMillis = System.currentTimeMillis()

        // Calculate the shellUid to account for running this from a secondary user.
        val shellUid = UserHandle.getUid(Process.myUserHandle().identifier,
            UserHandle.getAppId(Process.SHELL_UID))
        // Since we use adopt the shell permission identity we need to adjust
        // the permission identity to have the shell as the accessor.
        assertNotRunningOpAccess(AppOpsManager.permissionToOp(permission)!!,
                beginEndMillis, endTimeMillis, AttributionSource(shellUid,
                SHELL_PACKAGE_NAME, context.attributionTag, null,
                context.attributionSource.next),
                /*accessorForeground*/ false, /*receiverForeground*/ false,
                /*accessorTrusted*/ true, /*accessorAccessCount*/ 1,
                /*receiverAccessCount*/ 1, /*checkAccessor*/ false,
                /*fromDatasource*/ false)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testMicRecognitionInjectRecoWithoutAttribution"	"CtsPermission5TestCases"	"1: permission"	"([3:/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt]:[permission]:[3]:method_text:[  instrumentation.runOnMainSync { recognizerRef.get().destroy() }            }        }    }   ]) :|: 
    @Throws(Exception::class)
    fun testMicRecognitionInjectRecoWithoutAttribution() {
        runWithAuxiliaryApps {
            startBlamedAppActivity()

            val context = createAttributionContext(ACCESSOR_ATTRIBUTION_TAG,
                    RECEIVER_PACKAGE_NAME, RECEIVER_ATTRIBUTION_TAG)

            val listener = mock(AppOpsManager.OnOpActiveChangedListener::class.java)
            val appopsManager = context.getSystemService(AppOpsManager::class.java)
            SystemUtil.runWithShellPermissionIdentity<Unit> {
                appopsManager!!.startWatchingActive(arrayOf(AppOpsManager.OPSTR_RECORD_AUDIO),
                        context.mainExecutor, listener)
            }

            val speechStartTime = System.currentTimeMillis()
            val recognizerRef = AtomicReference<SpeechRecognizer>()
            var currentOperationComplete = CountDownLatch(1)

            instrumentation.runOnMainSync {
                val recognizer = SpeechRecognizer.createSpeechRecognizer(context,
                        ComponentName(RECEIVER2_PACKAGE_NAME, RECOGNITION_SERVICE))

                recognizer.setRecognitionListener(object : RecognitionListener {
                    override fun onReadyForSpeech(params: Bundle?) {}
                    override fun onRmsChanged(rmsdB: Float) {}
                    override fun onBufferReceived(buffer: ByteArray?) {
                        currentOperationComplete.countDown()
                    }
                    override fun onPartialResults(partialResults: Bundle?) {}
                    override fun onEvent(eventType: Int, params: Bundle?) {}
                    override fun onError(error: Int) {}
                    override fun onResults(results: Bundle?) {}
                    override fun onBeginningOfSpeech() {}
                    override fun onEndOfSpeech() {}
                })

                val recoIntent = Intent()
                recoIntent.putExtra(OPERATION, OPERATION_INJECT_RECO_WITHOUT_AT"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission5.cts.RuntimePermissionsAppOpTrackingTest.kt"	"testMicRecognitionMicRecoWithAttribution"	"CtsPermission5TestCases"	"1: permission"	"([11:/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt]:[permission]:[11]:method_text:[ attributionSourceRef.get()        }        private fun assumeNotTv() = assumeFalse(isTv)    }}]) :|: 
    @Throws(Exception::class)
    fun testMicRecognitionMicRecoWithAttribution() {
        runWithAuxiliaryApps {
            startBlamedAppActivity()

            val context = createAttributionContext(ACCESSOR_ATTRIBUTION_TAG,
                    RECEIVER_PACKAGE_NAME, RECEIVER_ATTRIBUTION_TAG)

            val listener = mock(AppOpsManager.OnOpActiveChangedListener::class.java)
            val appopsManager = context.getSystemService(AppOpsManager::class.java)
            SystemUtil.runWithShellPermissionIdentity<Unit> {
                appopsManager!!.startWatchingActive(arrayOf(AppOpsManager.OPSTR_RECORD_AUDIO),
                        context.mainExecutor, listener)
            }

            val speechStartTime = System.currentTimeMillis()
            val recognizerRef = AtomicReference<SpeechRecognizer>()
            var currentOperationComplete = CountDownLatch(1)

            instrumentation.runOnMainSync {
                val recognizer = SpeechRecognizer.createSpeechRecognizer(context,
                        ComponentName(RECEIVER2_PACKAGE_NAME, RECOGNITION_SERVICE))

                recognizer.setRecognitionListener(object : RecognitionListener {
                    override fun onReadyForSpeech(params: Bundle?) {}
                    override fun onRmsChanged(rmsdB: Float) {}
                    override fun onBufferReceived(buffer: ByteArray?) {
                        currentOperationComplete.countDown()
                    }
                    override fun onPartialResults(partialResults: Bundle?) {}
                    override fun onEvent(eventType: Int, params: Bundle?) {}
                    override fun onError(error: Int) {}
                    override fun onResults(results: Bundle?) {}
                    override fun onBeginningOfSpeech() {}
                    override fun onEndOfSpeech() {}
                })

                val recoIntent = Intent()
                recoIntent.putExtra(OPERATION, OPERATION_MIC_RECO_WITH_ATTRIBUTION)"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RuntimePermissionsAppOpTrackingTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission5.cts.RenouncedPermissionsTest.kt"	"testRenouncePermissionsChain"	"CtsPermission5TestCases"	"1: permission"	"([10:/android/permission5/cts/RenouncedPermissionsTest.kt]:[permission]:[10]:method_text:[Contract.Contacts.CONTENT_URI,                    null, null, null)!!.close()        })    }   ]) :|: 
    @Throws(Exception::class)
    @AppModeFull(reason=""Instant apps cannot hold READ_CALENDAR/READ_CONTACTS permissions"")
    fun testRenouncePermissionsChain() {
        val receiverAttributionSource = getShellAttributionSourceWithRenouncedPermissions()
        val activity = createActivityWithAttributionContext(receiverAttributionSource)

        // Out app has the permissions
        assertThat(activity.checkSelfPermission(Manifest.permission.READ_CALENDAR))
                .isEqualTo(PackageManager.PERMISSION_GRANTED)
        assertThat(activity.checkSelfPermission(Manifest.permission.READ_CONTACTS))
                .isEqualTo(PackageManager.PERMISSION_GRANTED)

        // Accessing the data should also fail (for us and next in the data flow)
        assertThrows(SecurityException::class.java, ThrowingRunnable{
            activity.contentResolver.query(CalendarContract.Calendars.CONTENT_URI,
                    null, null, null)!!.close()
        })
        assertThrows(SecurityException::class.java, ThrowingRunnable{
            activity.contentResolver.query(ContactsContract.Contacts.CONTENT_URI,
                    null, null, null)!!.close()
        })
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RenouncedPermissionsTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission5.cts.RenouncedPermissionsTest.kt"	"testCannotRenouncePermissionsWithoutPermission"	"CtsPermission5TestCases"	"1: permission"	"([8:/android/permission5/cts/RenouncedPermissionsTest.kt]:[permission]:[8]:method_text:[ributionContext(/*receiverAttributionSource*/ null,                renouncedPermissions)    }   ]) :|: (expected = SecurityException::class)
    fun testCannotRenouncePermissionsWithoutPermission() {
        val renouncedPermissions = ArraySet<String>()
        renouncedPermissions.add(Manifest.permission.READ_CONTACTS);

        // Trying to renounce permissions with no permission throws
        createActivityWithAttributionContext(/*receiverAttributionSource*/ null,
                renouncedPermissions)
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RenouncedPermissionsTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.permission5.cts.RenouncedPermissionsTest.kt"	"testCannotRequestRenouncePermissions"	"CtsPermission5TestCases"	"1: permission"	"([23:/android/permission5/cts/RenouncedPermissionsTest.kt]:[permission]:[23]:method_text:[  shellAttributionSource)            }            return shellAttributionSource        }    }}]) :|: (expected = IllegalArgumentException::class)
    fun testCannotRequestRenouncePermissions() {
        val renouncedPermissions = ArraySet<String>()
        renouncedPermissions.add(Manifest.permission.READ_CONTACTS);
        val activity = createActivityWithAttributionSource(AttributionSource(Process.myUid(),
                context.packageName, null, renouncedPermissions, null))

        // Requesting renounced permissions throws
        activity.requestPermissions(arrayOf(Manifest.permission.READ_CONTACTS), 1)
    }

    fun createActivityWithAttributionContext(receiverAttributionSource: AttributionSource?,
            renouncedPermissions: Set<String>? = null) : Activity {
        val contextParams = ContextParams.Builder()
                .setRenouncedPermissions(renouncedPermissions)
                .setNextAttributionSource(receiverAttributionSource)
                .build()
        return createActivityWithContextParams(contextParams)
    }

    fun createActivityWithAttributionSource(attributionSource: AttributionSource) : Activity {
        val mockActivity = Mockito.mock(Activity::class.java)
        `when`(mockActivity.getAttributionSource()).thenReturn(attributionSource)
        return mockActivity
    }

    fun createActivityWithContextParams(contextParams: ContextParams) : Activity {
        val activityReference = AtomicReference<NoOpActivity>()
        instrumentation.runOnMainSync {
            activityReference.set(NoOpActivity())
        }
        val activity = activityReference.get()
        activity.attachBaseContext(context.createContext(contextParams))
        return activity
    }

    companion object {
        private val context: Context
            get () = InstrumentationRegistry.getInstrumentation().getContext()

        private val instrumentation: Instrumentation
            get () = InstrumentationRegistry.getInstrumentation()

        fun getShellAttributionSourceWithRenouncedPermissions() : AttributionSource {
            // Let'"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/permission5/src/android/permission5/cts/RenouncedPermissionsTest.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.voiceinteraction.cts.HotwordDetectionServiceBasicTest"	"testVoiceInteractionService_withoutManageHotwordDetectionPermission_triggerFailure"	"CtsVoiceInteractionTestCases"	"1: permission"	"([2:/android/voiceinteraction/cts/HotwordDetectionServiceBasicTest.java]:[permission]:[2]:method_text:[SULT_INTENT,                Utils.HOTWORD_DETECTION_SERVICE_TRIGGER_SECURITY_EXCEPTION);    }   ]) :|: 
    public void testVoiceInteractionService_withoutManageHotwordDetectionPermission_triggerFailure()
            throws Throwable {
        testHotwordDetection(Utils.VIS_WITHOUT_MANAGE_HOTWORD_DETECTION_PERMISSION_TEST,
                Utils.HOTWORD_DETECTION_SERVICE_TRIGGER_RESULT_INTENT,
                Utils.HOTWORD_DETECTION_SERVICE_TRIGGER_SECURITY_EXCEPTION);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/voiceinteraction/src/android/voiceinteraction/cts/HotwordDetectionServiceBasicTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.voiceinteraction.cts.HotwordDetectionServiceBasicTest"	"testVoiceInteractionService_holdBindHotwordDetectionPermission_triggerFailure"	"CtsVoiceInteractionTestCases"	"1: permission"	"([2:/android/voiceinteraction/cts/HotwordDetectionServiceBasicTest.java]:[permission]:[2]:method_text:[SULT_INTENT,                Utils.HOTWORD_DETECTION_SERVICE_TRIGGER_SECURITY_EXCEPTION);    }   ]) :|: 
    public void testVoiceInteractionService_holdBindHotwordDetectionPermission_triggerFailure()
            throws Throwable {
        testHotwordDetection(Utils.VIS_HOLD_BIND_HOTWORD_DETECTION_PERMISSION_TEST,
                Utils.HOTWORD_DETECTION_SERVICE_TRIGGER_RESULT_INTENT,
                Utils.HOTWORD_DETECTION_SERVICE_TRIGGER_SECURITY_EXCEPTION);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/voiceinteraction/src/android/voiceinteraction/cts/HotwordDetectionServiceBasicTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.voiceinteraction.cts.HotwordDetectionServiceBasicTest"	"testHotwordDetectionService_concurrentCapture"	"CtsVoiceInteractionTestCases"	"1: permission"	"([1:/android/voiceinteraction/cts/HotwordDetectionServiceBasicTest.java]:[permission]:[1]:method_text:[rver.            } finally {                record.release();            }        });    }   ]) :|: 
    @RequiresDevice
    public void testHotwordDetectionService_concurrentCapture() throws Throwable {
        // Create SoftwareHotwordDetector and wait the HotwordDetectionService ready
        testHotwordDetection(Utils.HOTWORD_DETECTION_SERVICE_FROM_SOFTWARE_TRIGGER_TEST,
                Utils.HOTWORD_DETECTION_SERVICE_TRIGGER_RESULT_INTENT,
                Utils.HOTWORD_DETECTION_SERVICE_TRIGGER_SUCCESS);

        SystemUtil.runWithShellPermissionIdentity(() -> {
            AudioRecord record =
                    new AudioRecord.Builder()
                            .setAudioAttributes(
                                    new AudioAttributes.Builder()
                                            .setInternalCapturePreset(MediaRecorder.AudioSource.MIC)
                                            .build())
                            .setAudioFormat(
                                    new AudioFormat.Builder()
                                            .setChannelMask(AudioFormat.CHANNEL_IN_MONO)
                                            .setEncoding(AudioFormat.ENCODING_PCM_16BIT)
                                            .build())
                            .setBufferSizeInBytes(10240) // something large enough to not fail
                            .build();
            assertThat(record.getState()).isEqualTo(AudioRecord.STATE_INITIALIZED);

            try {
                record.startRecording();
                verifyDetectedResult(
                        performAndGetDetectionResult(
                                Utils.HOTWORD_DETECTION_SERVICE_MIC_ONDETECT_TEST),
                        MainHotwordDetectionService.DETECTED_RESULT);
                // TODO: Test that it still works after restarting the process or killing audio
                //  server.
            } finally {
                record.release();
            }
        });
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/voiceinteraction/src/android/voiceinteraction/cts/HotwordDetectionServiceBasicTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.voiceinteraction.cts.HotwordDetectionServiceBasicTest"	"testHotwordDetectionService_processDied_triggerOnError"	"CtsVoiceInteractionTestCases"	"1: permission"	"([2:/android/voiceinteraction/cts/HotwordDetectionServiceBasicTest.java]:[permission]:[2]:method_text:[ion.cts/""                + ""android.voiceinteraction.service.BasicVoiceInteractionService"";    }}]) :|: 
    public void testHotwordDetectionService_processDied_triggerOnError()
            throws Throwable {
        // Create AlwaysOnHotwordDetector and wait the HotwordDetectionService ready
        testHotwordDetection(Utils.HOTWORD_DETECTION_SERVICE_TRIGGER_TEST,
                Utils.HOTWORD_DETECTION_SERVICE_TRIGGER_RESULT_INTENT,
                Utils.HOTWORD_DETECTION_SERVICE_TRIGGER_SUCCESS);

        // Use AlwaysOnHotwordDetector to test process died of HotwordDetectionService
        testHotwordDetection(Utils.HOTWORD_DETECTION_SERVICE_PROCESS_DIED_TEST,
                Utils.HOTWORD_DETECTION_SERVICE_TRIGGER_RESULT_INTENT,
                Utils.HOTWORD_DETECTION_SERVICE_GET_ERROR);
    }

    private void testHotwordDetection(int testType, String expectedIntent, int expectedResult) {
        final BlockingBroadcastReceiver receiver = new BlockingBroadcastReceiver(mContext,
                expectedIntent);
        receiver.register();
        perform(testType);
        final Intent intent = receiver.awaitForBroadcast(TIMEOUT_MS);
        receiver.unregisterQuietly();

        assertThat(intent).isNotNull();
        assertThat(intent.getIntExtra(Utils.KEY_TEST_RESULT, -1)).isEqualTo(expectedResult);
    }

    @NonNull
    private Parcelable performAndGetDetectionResult(int testType) {
        final BlockingBroadcastReceiver receiver = new BlockingBroadcastReceiver(mContext,
                Utils.HOTWORD_DETECTION_SERVICE_ONDETECT_RESULT_INTENT);
        receiver.register();
        perform(testType);
        final Intent intent = receiver.awaitForBroadcast(TIMEOUT_MS);
        receiver.unregisterQuietly();

        assertThat(intent).isNotNull();
        final Parcelable result = intent.getParcelableExtra(Utils.KEY_TEST_RESULT);
        assertThat(result).isNotNull();
        return result;
    }

    private void perform(int testType) {
        mActivityTestRule.getScenario().onActivity(
                activity -> activity.triggerHotwordDetectionServiceTe"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/voiceinteraction/src/android/voiceinteraction/cts/HotwordDetectionServiceBasicTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.voiceinteraction.cts.VoiceInteractionRoleTest"	"getAssistRoleHolders"	"CtsVoiceInteractionTestCases"	"1: permission"	"([2:/android/voiceinteraction/cts/VoiceInteractionRoleTest.java]:[permission]:[2]:method_text:[is singleton role            addAssistRoleHolder(mOriginalRoleHolders.get(0));        }    }   ]) :|: /*
 *.
 */

package android.voiceinteraction.cts;

import static com.android.compatibility.common.util.SystemUtil.callWithShellPermissionIdentity;
import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;

import static com.google.common.truth.Truth.assertThat;

import android.app.role.RoleManager;
import android.content.ComponentName;
import android.content.Context;
import android.os.Process;
import android.platform.test.annotations.AppModeFull;
import android.provider.Settings;
import android.text.TextUtils;
import android.util.Log;

import androidx.test.core.app.ApplicationProvider;
import androidx.test.ext.junit.runners.AndroidJUnit4;

import com.android.compatibility.common.util.PollingCheck;

import org.junit.After;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;

/**
 * Tests for successfully changing ROLE_ASSISTANT. The test focuses on changing ROLE_ASSISTANT role,
 * the target voice interaction services do nothing during the test.
 */
@AppModeFull(reason = ""No need for testing role for instant app"")
@RunWith(AndroidJUnit4.class)
public class VoiceInteractionRoleTest {

    private static final String TAG = ""VoiceInteractionRoleTest"";

    private static final long TIMEOUT_MILLIS = 15 * 1000;
    private static final String VOICE_INTERACTION_HAS_RECOGNITION_SERVICE =
            ""android.voiceinteraction.service"";
    private static final String VOICE_INTERACTION_NO_RECOGNITION_SERVICE =
            ""android.voiceinteraction.norecognition"";

    private static Context sContext;
    private static RoleManager sRoleManager;

    List<String> mOriginalRoleHolders;

    @BeforeClass
    public static void oneTimeSetup() {
        sContext = ApplicationProvider.getApplicationContext()"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/voiceinteraction/src/android/voiceinteraction/cts/VoiceInteractionRoleTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.voiceinteraction.cts.VoiceInteractionRoleTest"	"testAssistRole_noRecognitionService"	"CtsVoiceInteractionTestCases"	"1: permission"	"([3:/android/voiceinteraction/cts/VoiceInteractionRoleTest.java]:[permission]:[3]:method_text:[g.i(TAG, mMethodName + "" result "" + successful);            complete(successful);        }    }}]) :|: 
    public void testAssistRole_noRecognitionService() throws Exception {
        roleTestingForPackage(VOICE_INTERACTION_NO_RECOGNITION_SERVICE, /* hasRecognition= */
                false);
    }

    // TODO: Use helpers and move the assertion in Test instead of move together
    private void roleTestingForPackage(String packageName, boolean hasRecognition)
            throws Exception {
        assertThat(getAssistRoleHolders()).doesNotContain(packageName);

        addAssistRoleHolder(packageName);
        if (mOriginalRoleHolders != null && mOriginalRoleHolders.size() > 0) {
            String originalHolder = mOriginalRoleHolders.get(0);
            removeAssistRoleHolder(originalHolder);
            assertThat(getAssistRoleHolders()).doesNotContain(originalHolder);
        }
        assertThat(getAssistRoleHolders()).containsExactly(packageName);

        Callable<Boolean> condition = hasRecognition
                ? () -> !TextUtils.isEmpty(Settings.Secure.getString(sContext.getContentResolver(),
                Settings.Secure.VOICE_INTERACTION_SERVICE))
                : () -> """".equals(Settings.Secure.getString(sContext.getContentResolver(),
                        Settings.Secure.VOICE_INTERACTION_SERVICE));
        PollingCheck.check(""Make sure that Settings VOICE_INTERACTION_SERVICE ""
                + ""becomes available."", 500, condition);
        final String curVoiceInteractionComponentName = Settings.Secure.getString(
                sContext.getContentResolver(),
                Settings.Secure.VOICE_INTERACTION_SERVICE);
        String curVoiceInteractionPackageName = """";
        if (!TextUtils.isEmpty(curVoiceInteractionComponentName)) {
            curVoiceInteractionPackageName =
                    ComponentName.unflattenFromString(
                            curVoiceInteractionComponentName).getPackageName();
        }
        assertThat(curVoiceInteractionPackageName).isEqualTo(hasRecognition ? packageName : """");

        removeAssistRole"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/voiceinteraction/src/android/voiceinteraction/cts/VoiceInteractionRoleTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.widget.cts.TextClockTest"	"testUpdate12_24"	"CtsWidgetTestCases"	"1: permission"	"([1:/android/widget/cts/TextClockTest.java]:[permission]:[1]:method_text:[) {                throw new RuntimeException(t.getMessage());            }        });    }   ]) :|: 
    public void testUpdate12_24() throws Throwable {
        grantWriteSettingsPermission();

        mActivityRule.runOnUiThread(() -> {
            mTextClock.setFormat12Hour(""h"");
            mTextClock.setFormat24Hour(""H"");
            mTextClock.disableClockTick();
        });

        final ContentResolver resolver = mActivity.getContentResolver();
        Calendar mNow = Calendar.getInstance();
        mNow.setTimeInMillis(System.currentTimeMillis()); // just like TextClock uses

        // make sure the clock is showing some time > 12pm and not near midnight
        for (String id : TimeZone.getAvailableIDs()) {
            final TimeZone timeZone = TimeZone.getTimeZone(id);
            mNow.setTimeZone(timeZone);
            int hour = mNow.get(Calendar.HOUR_OF_DAY);
            if (hour < 22 && hour > 12) {
                mActivityRule.runOnUiThread(() -> {
                    mTextClock.setTimeZone(id);
                });
                break;
            }
        }

        // If the time was already set to 12, we want it to start at locale-specified
        if (mDefaultTime1224 != null) {
            final CountDownLatch changeDefault = registerForChanges(Settings.System.TIME_12_24);
            mActivityRule.runOnUiThread(() -> {
                Settings.System.putString(resolver, Settings.System.TIME_12_24, null);
            });
            assertTrue(changeDefault.await(1, TimeUnit.SECONDS));
        }

        // Change to 12-hour mode
        final CountDownLatch change12 = registerForChanges(Settings.System.TIME_12_24);
        mActivityRule.runOnUiThread(() -> {
            Settings.System.putInt(resolver, Settings.System.TIME_12_24, 12);
        });
        assertTrue(change12.await(1, TimeUnit.SECONDS));

        // Must poll here because there are no timing guarantees for ContentObserver notification
        PollingCheck.waitFor(() -> {
            final MutableBoolean ok = new MutableBoolean(false);
            try {
                mAc"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextClockTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.widget.cts.TextClockTest"	"testNoChange"	"CtsWidgetTestCases"	"1: permission"	"([2:/android/widget/cts/TextClockTest.java]:[permission]:[2]:method_text:[ackageName() + "" ""                        + AppOpsManager.OPSTR_WRITE_SETTINGS + "" allow"");    }}]) :|: 
    public void testNoChange() throws Throwable {
        grantWriteSettingsPermission();
        mActivityRule.runOnUiThread(() -> mTextClock.disableClockTick());
        final ContentResolver resolver = mActivity.getContentResolver();

        // Now test that it isn't updated when a non-12/24 hour setting is set
        mActivityRule.runOnUiThread(() -> mTextClock.setText(""Nothing""));

        mActivityRule.runOnUiThread(() -> assertEquals(""Nothing"", mTextClock.getText().toString()));

        final CountDownLatch otherChange = registerForChanges(Settings.System.TEXT_AUTO_CAPS);
        mActivityRule.runOnUiThread(() -> {
            int oldAutoCaps = Settings.System.getInt(resolver, Settings.System.TEXT_AUTO_CAPS,
                    1);
            try {
                int newAutoCaps = oldAutoCaps == 0 ? 1 : 0;
                Settings.System.putInt(resolver, Settings.System.TEXT_AUTO_CAPS, newAutoCaps);
            } finally {
                Settings.System.putInt(resolver, Settings.System.TEXT_AUTO_CAPS, oldAutoCaps);
            }
        });

        assertTrue(otherChange.await(1, TimeUnit.SECONDS));

        mActivityRule.runOnUiThread(() -> assertEquals(""Nothing"", mTextClock.getText().toString()));
    }

    private CountDownLatch registerForChanges(String setting) throws Throwable {
        final CountDownLatch latch = new CountDownLatch(1);

        mActivityRule.runOnUiThread(() -> {
            final ContentResolver resolver = mActivity.getContentResolver();
            Uri uri = Settings.System.getUriFor(setting);
            resolver.registerContentObserver(uri, true,
                    new ContentObserver(new Handler()) {
                        @Override
                        public void onChange(boolean selfChange) {
                            countDownAndRemove();
                        }

                        private void countDownAndRemove() {
                            latch.countDown();
                            resolver.unr"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextClockTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.widget.cts.ToastTest"	"testRateLimitingToastsWhenInBackground"	"CtsWidgetTestCases"	"1: permission"	"([1:/android/widget/cts/ToastTest.java]:[permission]:[1]:method_text:[.sleep(sleepTime);                totalTimeSpentMs += sleepTime;            }        }    }   ]) :|: 
    public void testRateLimitingToastsWhenInBackground() throws Throwable {
        // enable rate limiting to test it
        SystemUtil.runWithShellPermissionIdentity(() -> mNotificationManager
                .setToastRateLimitingEnabled(true));
        // move to background
        mActivityRule.finishActivity();

        long totalTimeSpentMs = 0;
        int shownToastsNum = 0;
        // We add additional 3 seconds just to be sure we get into the next window.
        long additionalWaitTime = 3_000L;

        for (int i = 0; i < TOAST_RATE_LIMITS.length; i++) {
            int currentToastNum = TOAST_RATE_LIMITS[i] - shownToastsNum;
            List<TextToastInfo> toasts =
                    createTextToasts(currentToastNum + 1, ""Text"", Toast.LENGTH_SHORT);
            long startTime = SystemClock.elapsedRealtime();
            showToasts(toasts);

            assertTextToastsShownAndHidden(toasts.subList(0, currentToastNum));
            assertTextToastNotShown(toasts.get(currentToastNum));
            long endTime = SystemClock.elapsedRealtime();

            // We won't check after the last limit, no need to sleep then.
            if (i != TOAST_RATE_LIMITS.length - 1) {
                totalTimeSpentMs += endTime - startTime;
                shownToastsNum += currentToastNum;
                long sleepTime = Math.max(
                        TOAST_WINDOW_SIZES_MS[i] - totalTimeSpentMs + additionalWaitTime, 0);
                SystemClock.sleep(sleepTime);
                totalTimeSpentMs += sleepTime;
            }
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/ToastTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.widget.cts.ToastTest"	"testDontRateLimitToastsWhenInForeground"	"CtsWidgetTestCases"	"1: permission"	"([1:/android/widget/cts/ToastTest.java]:[permission]:[1]:method_text:[ENGTH_SHORT);        showToasts(toasts);        assertTextToastsShownAndHidden(toasts);    }   ]) :|: 
    public void testDontRateLimitToastsWhenInForeground() throws Throwable {
        // enable rate limiting to test it
        SystemUtil.runWithShellPermissionIdentity(() -> mNotificationManager
                .setToastRateLimitingEnabled(true));

        List<TextToastInfo> toasts =
                createTextToasts(TOAST_RATE_LIMITS[0] + 1, ""Text"", Toast.LENGTH_SHORT);
        showToasts(toasts);
        assertTextToastsShownAndHidden(toasts);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/ToastTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.widget.cts.ToastTest"	"testAppWithUnlimitedToastsPermissionCanPostUnlimitedToasts"	"CtsWidgetTestCases"	"1: permission"	"([5:/android/widget/cts/ToastTest.java]:[permission]:[5]:method_text:[().getParent() != null;        }    }    interface ToastInfo {        Toast getToast();    }}]) :|: 
    public void testAppWithUnlimitedToastsPermissionCanPostUnlimitedToasts() throws Throwable {
        // enable rate limiting to test it
        SystemUtil.runWithShellPermissionIdentity(() -> mNotificationManager
                .setToastRateLimitingEnabled(true));
        // move to background
        mActivityRule.finishActivity();

        int highestToastRateLimit = TOAST_RATE_LIMITS[TOAST_RATE_LIMITS.length - 1];
        List<TextToastInfo> toasts = createTextToasts(highestToastRateLimit + 1, ""Text"",
                Toast.LENGTH_SHORT);

        // We have to show one by one to avoid max number of toasts enqueued by a single package at
        // a time.
        for (TextToastInfo t : toasts) {
            // The shell has the android.permission.UNLIMITED_TOASTS permission.
            SystemUtil.runWithShellPermissionIdentity(() -> {
                try {
                    showToast(t);
                } catch (Throwable throwable) {
                    throw new RuntimeException(throwable);
                }
            });
            assertTextToastShownAndHidden(t);
        }
    }

    /** Create given number of text toasts with the same given text and length. */
    private List<TextToastInfo> createTextToasts(int num, String text, int length)
            throws Throwable {
        List<TextToastInfo> toasts = new ArrayList<>();
        mActivityRule.runOnUiThread(() -> {
            toasts.addAll(Stream
                    .generate(() -> TextToastInfo.create(mContext, text, length))
                    .limit(num)
                    .collect(toList()));
        });
        return toasts;
    }

    /** Create given number of custom toasts with the same given text and length. */
    private List<CustomToastInfo> createCustomToasts(int num, String text, int length)
            throws Throwable {
        List<CustomToastInfo> toasts = new ArrayList<>();
        mActivityRule.runOnUiThread(() -> {
            toasts.addAll(Stream"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/ToastTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.telephony3.cts.TelephonyManagerTest"	"testDeviceIdentifiersAreNotAccessible"	"CtsTelephony3TestCases"	"1: permission"	"([13:/android/telephony3/cts/TelephonyManagerTest.java]:[permission]:[13]:method_text:[ce identifiers, caught ""                    + ""SecurityException instead: "" + e);        }    }}]) :|: 
    @AsbSecurityTest(cveBugId = 173421434)
    public void testDeviceIdentifiersAreNotAccessible() throws Exception {
        // Apps with the READ_PHONE_STATE permission should no longer have access to device
        // identifiers. If an app's target SDK is less than Q and it has been granted the
        // READ_PHONE_STATE permission then a null value should be returned when querying for device
        // identifiers; this test verifies a null value is returned for device identifier queries.
        try {
            assertNull(
                    ""An app targeting pre-Q with the READ_PHONE_STATE permission granted must ""
                            + ""receive null when invoking getDeviceId"",
                    mTelephonyManager.getDeviceId());
            assertNull(
                    ""An app targeting pre-Q with the READ_PHONE_STATE permission granted must ""
                            + ""receive null when invoking getImei"",
                    mTelephonyManager.getImei());
            assertNull(
                    ""An app targeting pre-Q with the READ_PHONE_STATE permission granted must ""
                            + ""receive null when invoking getMeid"",
                    mTelephonyManager.getMeid());
            assertNull(
                    ""An app targeting pre-Q with the READ_PHONE_STATE permission granted must ""
                            + ""receive null when invoking getSubscriberId"",
                    mTelephonyManager.getSubscriberId());
            assertNull(
                    ""An app targeting pre-Q with the READ_PHONE_STATE permission granted must ""
                            + ""receive null when invoking getSimSerialNumber"",
                    mTelephonyManager.getSimSerialNumber());
            assertNull(
                    ""An app targeting pre-Q with the READ_PHONE_STATE permission granted must ""
                            + ""receive null when invoking getNai"",
                    mTelephonyManager.getNai());
            /"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony3/src/android/telephony3/cts/TelephonyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.activityrecognition.cts.ActivityRecognizerAttributionTags.kt"	"setUpTest"	"CtsActivityRecognitionTestCases"	"1: permission"	"([4:/android/activityrecognition/cts/ActivityRecognizerAttributionTags.kt]:[permission]:[4]:method_text:[cutor) {            latch.countDown()        }        latch.await(5, TimeUnit.SECONDS)    }   ]) :|: /*
 *.
 */
package android.activityrecognition.cts

import android.Manifest
import android.app.AppOpsManager
import android.app.Instrumentation
import android.app.UiAutomation
import android.app.role.RoleManager
import android.content.Context
import android.os.Process
import android.os.UserHandle
import android.platform.test.annotations.AppModeFull
import androidx.test.platform.app.InstrumentationRegistry
import com.android.compatibility.common.util.SystemUtil
import org.junit.After
import org.junit.Assert.fail
import org.junit.Before
import org.junit.Test
import java.util.concurrent.CountDownLatch
import java.util.concurrent.TimeUnit

@AppModeFull(reason=""Instant apps have no access to the RoleManager"")
class RenouncedPermissionsTest {

    var oldActivityRecognizers: List<String>? = null
        get() { return field }
        set(value) { field = value }

    @Before
    fun makeSelfActivityRecognizer() {
        SystemUtil.runWithShellPermissionIdentity {
            val roleManager = context.getSystemService(RoleManager::class.java)!!
            oldActivityRecognizers = roleManager.getRoleHolders(
                    RoleManager.ROLE_SYSTEM_ACTIVITY_RECOGNIZER)
            roleManager.isBypassingRoleQualification = true
            addActivityRecognizer(context.packageName)
        }
    }

    @After
    fun restoreActivityRecognizers() {
        if (oldActivityRecognizers != null) {
            SystemUtil.runWithShellPermissionIdentity {
                for (oldActivityRecongizer in oldActivityRecognizers!!) {
                    addActivityRecognizer(oldActivityRecongizer)
                }
                val roleManager = context.getSystemService(RoleManager::class.java)!!
                roleManager.isBypassingRoleQualification = false
            }
        }
    }

    @Before
    fun setUpTest() {
        val appOpsManager = context.getSystemService(AppOpsManager::class.java)!!
        SystemUtil.runWithShellPermissionIdentity {
            appOpsManage"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/activityrecognition/src/android/activityrecognition/cts/ActivityRecognizerAttributionTags.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.activityrecognition.cts.ActivityRecognizerAttributionTags.kt"	"testActivityRecognitionAttributionTagBlaming"	"CtsActivityRecognitionTestCases"	"1: permission"	"([3:/android/activityrecognition/cts/ActivityRecognizerAttributionTags.kt]:[permission]:[3]:method_text:[mentation: Instrumentation            get () = InstrumentationRegistry.getInstrumentation()    }}]) :|: 
    fun testActivityRecognitionAttributionTagBlaming() {
        // Using an AR allow listed tag
        var timeBeforeArAccess = System.currentTimeMillis()
        accessActivityRecognition(VALID_AR_ATTRIBUTION_TAG)
        assertNotedOpsSinceLastArAccess(timeBeforeArAccess, /*expectedOp*/
                AppOpsManager.OPSTR_ACTIVITY_RECOGNITION_SOURCE, /*unexpectedOp*/
                AppOpsManager.OPSTR_ACTIVITY_RECOGNITION)

        // Using an AR not allow listed tag
        timeBeforeArAccess = System.currentTimeMillis()
        accessActivityRecognition(INVALID_AR_ATTRIBUTION_TAG)
        assertNotedOpsSinceLastArAccess(timeBeforeArAccess, /*expectedOp*/
                AppOpsManager.OPSTR_ACTIVITY_RECOGNITION, /*unexpectedOp*/
                AppOpsManager.OPSTR_ACTIVITY_RECOGNITION_SOURCE)
    }

    fun accessActivityRecognition(attributionTag: String) {
        val appOpsManager = context.getSystemService(AppOpsManager::class.java)
        appOpsManager?.noteOp(AppOpsManager.OPSTR_ACTIVITY_RECOGNITION, Process.myUid(),
                context.packageName, attributionTag, /*message*/ null)
    }

    fun assertNotedOpsSinceLastArAccess(timeBeforeArAccess: Long,
            expectedOp: String, unexpectedOp: String) {
        val automation: UiAutomation = instrumentation.getUiAutomation()
        automation.adoptShellPermissionIdentity(Manifest.permission.GET_APP_OPS_STATS)
        try {
            val appOpsManager: AppOpsManager = context.getSystemService(AppOpsManager::class.java)!!
            val affectedPackageOps = appOpsManager.getPackagesForOps(
                    arrayOf(expectedOp, unexpectedOp))
            val packageCount = affectedPackageOps.size
            for (i in 0 until packageCount) {
                val packageOps = affectedPackageOps[i]
                if (!context.getPackageName().equals(packageOps.packageName)) {
                    continue
                }
                // We are pulling stats only for one app op."	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/activityrecognition/src/android/activityrecognition/cts/ActivityRecognizerAttributionTags.kt"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.gamemanager.cts.GameManagerTest"	"testGetGameModeUnsupported"	"CtsGameManagerTestCases"	"1: permission"	"([1:/android/gamemanager/cts/GameManagerTest.java]:[permission]:[1]:method_text:[ode() returns the correct value when forcing the Game Mode to     * GAME_MODE_STANDARD.     */   ]) :|: 
    public void testGetGameModeUnsupported() {
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mGameManager,
                (gameManager) -> gameManager.setGameMode(mActivity.getPackageName(),
                        GameManager.GAME_MODE_UNSUPPORTED));

        int gameMode = mActivity.getGameMode();

        Assert.assertEquals(""Game Manager returned incorrect value."",
                GameManager.GAME_MODE_UNSUPPORTED, gameMode);
    }

    /**
     * Test that GameManager::getGameMode() returns the correct value when forcing the Game Mode to
     * GAME_MODE_STANDARD.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/gamemanager/src/android/gamemanager/cts/GameManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.gamemanager.cts.GameManagerTest"	"testGetGameModeStandard"	"CtsGameManagerTestCases"	"1: permission"	"([1:/android/gamemanager/cts/GameManagerTest.java]:[permission]:[1]:method_text:[() returns the correct value when forcing the Game Mode to     * GAME_MODE_PERFORMANCE.     */   ]) :|: 
    public void testGetGameModeStandard() {
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mGameManager,
                (gameManager) -> gameManager.setGameMode(mActivity.getPackageName(),
                        GameManager.GAME_MODE_STANDARD));

        int gameMode = mActivity.getGameMode();

        Assert.assertEquals(""Game Manager returned incorrect value."",
                GameManager.GAME_MODE_STANDARD, gameMode);
    }

    /**
     * Test that GameManager::getGameMode() returns the correct value when forcing the Game Mode to
     * GAME_MODE_PERFORMANCE.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/gamemanager/src/android/gamemanager/cts/GameManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.gamemanager.cts.GameManagerTest"	"testGetGameModePerformance"	"CtsGameManagerTestCases"	"1: permission"	"([1:/android/gamemanager/cts/GameManagerTest.java]:[permission]:[1]:method_text:[Mode() returns the correct value when forcing the Game Mode to     * GAME_MODE_BATTERY.     */   ]) :|: 
    public void testGetGameModePerformance() {
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mGameManager,
                (gameManager) -> gameManager.setGameMode(mActivity.getPackageName(),
                        GameManager.GAME_MODE_PERFORMANCE));

        int gameMode = mActivity.getGameMode();

        Assert.assertEquals(""Game Manager returned incorrect value."",
                GameManager.GAME_MODE_PERFORMANCE, gameMode);
    }

    /**
     * Test that GameManager::getGameMode() returns the correct value when forcing the Game Mode to
     * GAME_MODE_BATTERY.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/gamemanager/src/android/gamemanager/cts/GameManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.gamemanager.cts.GameManagerTest"	"testGetGameModeBattery"	"CtsGameManagerTestCases"	"1: permission"	"([1:/android/gamemanager/cts/GameManagerTest.java]:[permission]:[1]:method_text:[anager returned incorrect value."",                GameManager.GAME_MODE_BATTERY, gameMode);    }}]) :|: 
    public void testGetGameModeBattery() {
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mGameManager,
                (gameManager) -> gameManager.setGameMode(mActivity.getPackageName(),
                        GameManager.GAME_MODE_BATTERY));

        int gameMode = mActivity.getGameMode();

        Assert.assertEquals(""Game Manager returned incorrect value."",
                GameManager.GAME_MODE_BATTERY, gameMode);
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/gamemanager/src/android/gamemanager/cts/GameManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.voicerecognition.cts.AbstractRecognitionServiceTest"	"testStartListening"	"CtsVoiceRecognitionTestCases"	"1: permission"	"([1:/android/voicerecognition/cts/AbstractRecognitionServiceTest.java]:[permission]:[1]:method_text:[r to avoid the test becoming flaky.        SystemClock.sleep(INDICATOR_DISMISS_TIMEOUT);    }   ]) :|: 
    public void testStartListening() throws Throwable {
        setCurrentRecognizer(mActivity.mRecognizer, CTS_VOICE_RECOGNITION_SERVICE);
        mUiDevice.waitForIdle();

        mActivity.startListening();
        try {
            // startListening() will call noteProxyOpNoTrow(), if the permission check pass then the
            // RecognitionService.onStartListening() will be called. Otherwise, a TimeoutException
            // will be thrown.
            assertThat(mActivity.mCountDownLatch.await(WAIT_TIMEOUT_MS, TimeUnit.MILLISECONDS)).isTrue();
        } catch (InterruptedException e) {
            assertWithMessage(""onStartListening() not called. "" + e).fail();
        }
        // Wait for the privacy indicator to disappear to avoid the test becoming flaky.
        SystemClock.sleep(INDICATOR_DISMISS_TIMEOUT);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/voiceRecognition/src/android/voicerecognition/cts/AbstractRecognitionServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.voicerecognition.cts.RecognitionServiceMicIndicatorTest"	"testTrustedRecognitionServiceCanBlameCallingApp"	"CtsVoiceRecognitionTestCases"	"1: permission"	"([4:/android/voicerecognition/cts/RecognitionServiceMicIndicatorTest.java]:[permission]:[4]:method_text:[.getPackageManager();        return pm.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);    }}]) :|: 
    public void testTrustedRecognitionServiceCanBlameCallingApp() throws Throwable {
        // We treat trusted if the current voice recognizer is also a preinstalled app. This is a
        // trusted case.
        boolean hasPreInstalledRecognizer = hasPreInstalledRecognizer(
                getComponentPackageNameFromString(mOriginalVoiceRecognizer));
        assumeTrue(""No preinstalled recognizer."", hasPreInstalledRecognizer);

        // verify that the trusted app can blame the calling app mic access
        testVoiceRecognitionServiceBlameCallingApp(/* trustVoiceService */ true);
    }

    private void testVoiceRecognitionServiceBlameCallingApp(boolean trustVoiceService)
            throws Throwable {
        // Start SpeechRecognition
        mActivity.startListening();

        if (isTv()) {
            assertTvIndicatorsShown(trustVoiceService);
        } else {
            assertPrivacyChipAndIndicatorsPresent(trustVoiceService);
        }
    }

    private void assertTvIndicatorsShown(boolean trustVoiceService) {
        Log.v(TAG, ""assertTvIndicatorsShown"");
        final WindowManagerStateHelper wmState = new WindowManagerStateHelper();
        wmState.waitFor(
                state -> {
                    if (trustVoiceService) {
                        return state.containsWindow(TV_MIC_INDICATOR_WINDOW_TITLE)
                                && state.isWindowVisible(TV_MIC_INDICATOR_WINDOW_TITLE);
                    } else {
                        return !state.containsWindow(TV_MIC_INDICATOR_WINDOW_TITLE);
                    }
                },
                ""Waiting for the mic indicator window to come up"");
    }

    private void assertPrivacyChipAndIndicatorsPresent(boolean trustVoiceService) {
        // Open notification and verify the privacy indicator is shown
        mUiDevice.openQuickSettings();
        SystemClock.sleep(UI_WAIT_TIMEOUT);

        final UiObject2 privacyChip =
                mUiDevice.findObject(By.res(PRIVACY_"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/voiceRecognition/src/android/voicerecognition/cts/RecognitionServiceMicIndicatorTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.tv.tuner.cts.TunerTest"	"adoptShellPermissionIdentity"	"CtsTvTestCases"	"1: permission"	"([1:/android/media/tv/tuner/cts/TunerTest.java]:[permission]:[1]:method_text:[       if (mTuner != null) {          mTuner.close();          mTuner = null;        }    }   ]) :|: /*
 *.
 */

package android.media.tv.tuner.cts;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import android.content.Context;
import android.content.pm.PackageManager;
import android.media.tv.tuner.DemuxCapabilities;
import android.media.tv.tuner.Descrambler;
import android.media.tv.tuner.Lnb;
import android.media.tv.tuner.LnbCallback;
import android.media.tv.tuner.Tuner;
import android.media.tv.tuner.TunerVersionChecker;
import android.media.tv.tuner.dvr.DvrPlayback;
import android.media.tv.tuner.dvr.DvrRecorder;
import android.media.tv.tuner.dvr.OnPlaybackStatusChangedListener;
import android.media.tv.tuner.dvr.OnRecordStatusChangedListener;
import android.media.tv.tuner.filter.AlpFilterConfiguration;
import android.media.tv.tuner.filter.AudioDescriptor;
import android.media.tv.tuner.filter.AvSettings;
import android.media.tv.tuner.filter.DownloadEvent;
import android.media.tv.tuner.filter.DownloadSettings;
import android.media.tv.tuner.filter.Filter;
import android.media.tv.tuner.filter.FilterCallback;
import android.media.tv.tuner.filter.FilterConfiguration;
import android.media.tv.tuner.filter.FilterEvent;
import android.media.tv.tuner.filter.IpCidChangeEvent;
import android.media.tv.tuner.filter.IpFilterConfiguration;
import android.media.tv.tuner.filter.IpPayloadEvent;
import android.media.tv.tuner.filter.MediaEvent;
import android.media.tv.tuner.filter.MmtpFilterConfiguration;
import android.media.tv.tuner.filter.MmtpRecordEvent;
import android.media.tv.tuner.filter.PesEvent;
import android.media.tv.tuner.filter.PesSettings;
import android.media.tv.tuner.filter.RecordSettings;
import android.media.tv.tuner.filter.RestartEvent;
import android.media.tv.tuner.filter.ScramblingStatusEvent;
import android.media.tv.tuner.filter.SectionEvent;
import android.media.tv.tuner.filter.Section"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/tv/src/android/media/tv/tuner/cts/TunerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.tv.tuner.cts.TunerFrontendTest"	"adoptShellPermissionIdentity"	"CtsTvTestCases"	"1: permission"	"([1:/android/media/tv/tuner/cts/TunerFrontendTest.java]:[permission]:[1]:method_text:[       if (mTuner != null) {          mTuner.close();          mTuner = null;        }    }   ]) :|: /*
 *.
 */

package android.media.tv.tuner.cts;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import android.content.Context;
import android.content.pm.PackageManager;
import android.media.tv.tuner.Tuner;
import android.media.tv.tuner.TunerVersionChecker;
import android.media.tv.tuner.frontend.AnalogFrontendCapabilities;
import android.media.tv.tuner.frontend.AnalogFrontendSettings;
import android.media.tv.tuner.frontend.Atsc3FrontendCapabilities;
import android.media.tv.tuner.frontend.Atsc3FrontendSettings;
import android.media.tv.tuner.frontend.Atsc3PlpSettings;
import android.media.tv.tuner.frontend.AtscFrontendCapabilities;
import android.media.tv.tuner.frontend.AtscFrontendSettings;
import android.media.tv.tuner.frontend.DtmbFrontendCapabilities;
import android.media.tv.tuner.frontend.DtmbFrontendSettings;
import android.media.tv.tuner.frontend.DvbcFrontendCapabilities;
import android.media.tv.tuner.frontend.DvbcFrontendSettings;
import android.media.tv.tuner.frontend.DvbsCodeRate;
import android.media.tv.tuner.frontend.DvbsFrontendCapabilities;
import android.media.tv.tuner.frontend.DvbsFrontendSettings;
import android.media.tv.tuner.frontend.DvbtFrontendCapabilities;
import android.media.tv.tuner.frontend.DvbtFrontendSettings;
import android.media.tv.tuner.frontend.FrontendCapabilities;
import android.media.tv.tuner.frontend.FrontendInfo;
import android.media.tv.tuner.frontend.FrontendSettings;
import android.media.tv.tuner.frontend.Isdbs3FrontendCapabilities;
import android.media.tv.tuner.frontend.Isdbs3FrontendSettings;
import android.media.tv.tuner.frontend.IsdbsFrontendCapabilities;
import android.media.tv.tuner.frontend.IsdbsFrontendSettings;
import android.media.tv.tuner.frontend.IsdbtFrontendCapabilities;
import android.media.tv.tuner.frontend.IsdbtFrontendSettings"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/tv/src/android/media/tv/tuner/cts/TunerFrontendTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.tv.tuner.cts.TunerDvrTest"	"adoptShellPermissionIdentity"	"CtsTvTestCases"	"1: permission"	"([1:/android/media/tv/tuner/cts/TunerDvrTest.java]:[permission]:[1]:method_text:[       if (mTuner != null) {          mTuner.close();          mTuner = null;        }    }   ]) :|: /*
 *.
 */

package android.media.tv.tuner.cts;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;

import android.content.Context;
import android.content.pm.PackageManager;
import android.media.tv.tuner.Tuner;
import android.media.tv.tuner.dvr.DvrPlayback;
import android.media.tv.tuner.dvr.DvrRecorder;
import android.media.tv.tuner.dvr.DvrSettings;
import android.media.tv.tuner.dvr.OnPlaybackStatusChangedListener;
import android.media.tv.tuner.dvr.OnRecordStatusChangedListener;
import android.media.tv.tuner.filter.Filter;
import android.media.tv.tuner.filter.FilterCallback;
import android.media.tv.tuner.filter.FilterConfiguration;
import android.media.tv.tuner.filter.FilterEvent;
import android.media.tv.tuner.filter.RecordSettings;
import android.media.tv.tuner.filter.Settings;
import android.media.tv.tuner.filter.TsFilterConfiguration;
import android.os.ParcelFileDescriptor;

import androidx.test.InstrumentationRegistry;
import androidx.test.filters.SmallTest;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.RequiredFeatureRule;

import org.junit.After;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.File;
import java.io.RandomAccessFile;
import java.util.concurrent.Executor;

@RunWith(AndroidJUnit4.class)
@SmallTest
public class TunerDvrTest {
    private static final String TAG = ""MediaTunerDvrTest"";

    @Rule
    public RequiredFeatureRule featureRule = new RequiredFeatureRule(
            PackageManager.FEATURE_TUNER);

    private Context mContext;
    private Tuner mTuner;

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getTargetContext();
        InstrumentationRegistry
                .getInstrumentation().getUiAutomation().adoptShellPermissionIdentity();
        mTuner = new Tuner(mContext, null, 100);
    }

    @After
    publi"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/tv/src/android/media/tv/tuner/cts/TunerDvrTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.tv.tuner.cts.TunerFilterTest"	"adoptShellPermissionIdentity"	"CtsTvTestCases"	"1: permission"	"([1:/android/media/tv/tuner/cts/TunerFilterTest.java]:[permission]:[1]:method_text:[       if (mTuner != null) {          mTuner.close();          mTuner = null;        }    }   ]) :|: /*
 *.
 */

package android.media.tv.tuner.cts;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import android.content.Context;
import android.content.pm.PackageManager;
import android.media.tv.tuner.Tuner;
import android.media.tv.tuner.TunerVersionChecker;
import android.media.tv.tuner.filter.AlpFilterConfiguration;
import android.media.tv.tuner.filter.AvSettings;
import android.media.tv.tuner.filter.DownloadSettings;
import android.media.tv.tuner.filter.Filter;
import android.media.tv.tuner.filter.IpFilterConfiguration;
import android.media.tv.tuner.filter.MmtpFilterConfiguration;
import android.media.tv.tuner.filter.PesSettings;
import android.media.tv.tuner.filter.RecordSettings;
import android.media.tv.tuner.filter.SectionSettingsWithSectionBits;
import android.media.tv.tuner.filter.SectionSettingsWithTableInfo;
import android.media.tv.tuner.filter.TlvFilterConfiguration;
import android.media.tv.tuner.filter.TsFilterConfiguration;

import androidx.test.InstrumentationRegistry;
import androidx.test.filters.SmallTest;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.RequiredFeatureRule;

import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(AndroidJUnit4.class)
@SmallTest
public class TunerFilterTest {
    private static final String TAG = ""MediaTunerFilterTest"";

    @Rule
    public RequiredFeatureRule featureRule = new RequiredFeatureRule(
            PackageManager.FEATURE_TUNER);

    private Context mContext;
    private Tuner mTuner;

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getTargetContext();
        InstrumentationRegistry
                .getInstrumentation().getUiAutomation().adoptShellPermissionIdentity();
        mTuner = new Tuner(mConte"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/tv/src/android/media/tv/tuner/cts/TunerFilterTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.tv.cts.TvContractTest"	"testRecordedProgramsTable"	"CtsTvTestCases"	"1: permission"	"([3:/android/media/tv/cts/TvContractTest.java]:[permission]:[3]:method_text:[uri);        } catch (SecurityException e) {            // Expected exception        }    }   ]) :|: public void testRecordedProgramsTable() throws Exception {
        if (!Utils.hasTvInputFramework(getContext())) {
            return;
        }
        // Set-up: add a channel.
        ContentValues values = createDummyChannelValues(mInputId, false);
        Uri channelUri = mContentResolver.insert(mChannelsUri, values);
        long channelId = ContentUris.parseId(channelUri);

        verifyRecordedProgramsTable(RecordedPrograms.CONTENT_URI, channelId);
    }

    private void verifyQueryWithSortOrder(Uri uri, final String[] projection,
            String sortOrder) throws Exception {
        try {
            getContext().getContentResolver().query(uri, projection, null, null, sortOrder);
        } catch (SecurityException e) {
            fail(""Setting sort order shoud be allowed for "" + uri);
        }
    }

    private void verifyQueryWithSelection(Uri uri, final String[] projection,
            String selection) throws Exception {
        try {
            getContext().getContentResolver().query(uri, projection, selection, null, null);
            fail(""Setting selection should fail without ACCESS_ALL_EPG_DATA permission for "" + uri);
        } catch (SecurityException e) {
            // Expected exception
        }
    }

    private void verifyUpdateWithSelection(Uri uri, String selection) throws Exception {
        try {
            ContentValues values = new ContentValues();
            getContext().getContentResolver().update(uri, values, selection, null);
            fail(""Setting selection should fail without ACCESS_ALL_EPG_DATA permission for "" + uri);
        } catch (SecurityException e) {
            // Expected exception
        }
    }

    private void verifyDeleteWithSelection(Uri uri, String selection) throws Exception {
        try {
            getContext().getContentResolver().delete(uri, selection, null);
            fail(""Setting selection should fail without ACCESS_ALL_EPG_DATA permission for "" + uri);
        } catch (SecurityExcept"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/tv/src/android/media/tv/cts/TvContractTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.tv.cts.TvContractTest"	"testAllEpgPermissionBlocksSortOrderOnQuery_Channels"	"CtsTvTestCases"	"1: permission"	"([1:/android/media/tv/cts/TvContractTest.java]:[permission]:[1]:method_text:[       verifyQueryWithSortOrder(Channels.CONTENT_URI, projection, Channels._ID + "" ASC"");    }   ]) :|: public void testAllEpgPermissionBlocksSortOrderOnQuery_Channels() throws Exception {
        if (!Utils.hasTvInputFramework(getContext())) {
            return;
        }
        final String[] projection = { Channels._ID };
        verifyQueryWithSortOrder(Channels.CONTENT_URI, projection, Channels._ID + "" ASC"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/tv/src/android/media/tv/cts/TvContractTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.tv.cts.TvContractTest"	"testAllEpgPermissionBlocksSelectionOnQuery_Channels"	"CtsTvTestCases"	"1: permission"	"([1:/android/media/tv/cts/TvContractTest.java]:[permission]:[1]:method_text:[        verifyQueryWithSelection(Channels.CONTENT_URI, projection, Channels._ID + "">0"");    }   ]) :|: public void testAllEpgPermissionBlocksSelectionOnQuery_Channels() throws Exception {
        if (!Utils.hasTvInputFramework(getContext())) {
            return;
        }
        final String[] projection = { Channels._ID };
        verifyQueryWithSelection(Channels.CONTENT_URI, projection, Channels._ID + "">0"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/tv/src/android/media/tv/cts/TvContractTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.tv.cts.TvContractTest"	"testAllEpgPermissionBlocksSelectionOnUpdate_Channels"	"CtsTvTestCases"	"1: permission"	"([1:/android/media/tv/cts/TvContractTest.java]:[permission]:[1]:method_text:[;        }        verifyUpdateWithSelection(Channels.CONTENT_URI, Channels._ID + "">0"");    }   ]) :|: public void testAllEpgPermissionBlocksSelectionOnUpdate_Channels() throws Exception {
        if (!Utils.hasTvInputFramework(getContext())) {
            return;
        }
        verifyUpdateWithSelection(Channels.CONTENT_URI, Channels._ID + "">0"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/tv/src/android/media/tv/cts/TvContractTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.tv.cts.TvContractTest"	"testAllEpgPermissionBlocksSelectionOnDelete_Channels"	"CtsTvTestCases"	"1: permission"	"([1:/android/media/tv/cts/TvContractTest.java]:[permission]:[1]:method_text:[;        }        verifyDeleteWithSelection(Channels.CONTENT_URI, Channels._ID + "">0"");    }   ]) :|: public void testAllEpgPermissionBlocksSelectionOnDelete_Channels() throws Exception {
        if (!Utils.hasTvInputFramework(getContext())) {
            return;
        }
        verifyDeleteWithSelection(Channels.CONTENT_URI, Channels._ID + "">0"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/tv/src/android/media/tv/cts/TvContractTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.tv.cts.TvContractTest"	"testAllEpgPermissionBlocksSortOrderOnQuery_Programs"	"CtsTvTestCases"	"1: permission"	"([1:/android/media/tv/cts/TvContractTest.java]:[permission]:[1]:method_text:[       verifyQueryWithSortOrder(Programs.CONTENT_URI, projection, Programs._ID + "" ASC"");    }   ]) :|: public void testAllEpgPermissionBlocksSortOrderOnQuery_Programs() throws Exception {
        if (!Utils.hasTvInputFramework(getContext())) {
            return;
        }
        final String[] projection = { Programs._ID };
        verifyQueryWithSortOrder(Programs.CONTENT_URI, projection, Programs._ID + "" ASC"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/tv/src/android/media/tv/cts/TvContractTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.tv.cts.TvContractTest"	"testAllEpgPermissionBlocksSelectionOnQuery_Programs"	"CtsTvTestCases"	"1: permission"	"([1:/android/media/tv/cts/TvContractTest.java]:[permission]:[1]:method_text:[        verifyQueryWithSelection(Programs.CONTENT_URI, projection, Programs._ID + "">0"");    }   ]) :|: public void testAllEpgPermissionBlocksSelectionOnQuery_Programs() throws Exception {
        if (!Utils.hasTvInputFramework(getContext())) {
            return;
        }
        final String[] projection = { Channels._ID };
        verifyQueryWithSelection(Programs.CONTENT_URI, projection, Programs._ID + "">0"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/tv/src/android/media/tv/cts/TvContractTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.tv.cts.TvContractTest"	"testAllEpgPermissionBlocksSelectionOnUpdate_Programs"	"CtsTvTestCases"	"1: permission"	"([1:/android/media/tv/cts/TvContractTest.java]:[permission]:[1]:method_text:[;        }        verifyUpdateWithSelection(Programs.CONTENT_URI, Programs._ID + "">0"");    }   ]) :|: public void testAllEpgPermissionBlocksSelectionOnUpdate_Programs() throws Exception {
        if (!Utils.hasTvInputFramework(getContext())) {
            return;
        }
        verifyUpdateWithSelection(Programs.CONTENT_URI, Programs._ID + "">0"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/tv/src/android/media/tv/cts/TvContractTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.tv.cts.TvContractTest"	"testAllEpgPermissionBlocksSelectionOnDelete_Programs"	"CtsTvTestCases"	"1: permission"	"([1:/android/media/tv/cts/TvContractTest.java]:[permission]:[1]:method_text:[;        }        verifyDeleteWithSelection(Programs.CONTENT_URI, Programs._ID + "">0"");    }   ]) :|: public void testAllEpgPermissionBlocksSelectionOnDelete_Programs() throws Exception {
        if (!Utils.hasTvInputFramework(getContext())) {
            return;
        }
        verifyDeleteWithSelection(Programs.CONTENT_URI, Programs._ID + "">0"");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/tv/src/android/media/tv/cts/TvContractTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.tv.cts.TvInputManagerTest"	"TvInputManagerTest"	"CtsTvTestCases"	"1: permission"	"([3:/android/media/tv/cts/TvInputManagerTest.java]:[permission]:[3]:method_text:[get(0);                assertEquals(expectedInfo, callbackInfo);            }        }    }   ]) :|: public void test/*
 *.
 */

package android.media.tv.cts;

import android.app.Activity;
import android.app.Instrumentation;
import android.content.ComponentName;
import android.content.Context;
import android.content.pm.PackageManager;
import android.database.Cursor;
import android.media.AudioManager;
import android.media.tv.cts.TvViewTest.MockCallback;
import android.media.tv.TunedInfo;
import android.media.tv.TvContentRating;
import android.media.tv.TvContract;
import android.media.tv.TvInputHardwareInfo;
import android.media.tv.TvInputInfo;
import android.media.tv.TvInputManager;
import android.media.tv.TvInputManager.Hardware;
import android.media.tv.TvInputManager.HardwareCallback;
import android.media.tv.TvInputService;
import android.media.tv.TvStreamConfig;
import android.media.tv.TvView;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.test.ActivityInstrumentationTestCase2;
import android.tv.cts.R;

import com.android.compatibility.common.util.PollingCheck;

import androidx.test.InstrumentationRegistry;

import java.io.IOException;
import java.util.ArrayList;
import java.util.concurrent.Executor;
import java.util.List;

import org.xmlpull.v1.XmlPullParserException;

/**
 * Test for {@link android.media.tv.TvInputManager}.
 */
public class TvInputManagerTest extends ActivityInstrumentationTestCase2<TvViewStubActivity> {
    /** The maximum time to wait for an operation. */
    private static final long TIME_OUT_MS = 15000L;

    private static final String[] VALID_TV_INPUT_SERVICES = {
        StubTunerTvInputService.class.getName()
    };
    private static final String[] INVALID_TV_INPUT_SERVICES = {
        NoMetadataTvInputService.class.getName(), NoPermissionTvInputService.class.getName()
    };
    private static final TvContentRating DUMMY_RATING = TvContentRating.createRating(
            ""com.android.tv"", ""US_TV"", ""US_TV_PG"", ""US_TV_D"", ""US_TV_L"");

    private String mStubId;
    private TvInputManager mMa"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/tv/src/android/media/tv/cts/TvInputManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.uidisolation.cts.PermissionTestService"	"startTests"	"CtsUidIsolationTestCases"	"1: permission"	"([17:/android/uidisolation/cts/PermissionTestService.java]:[permission]:[17]:method_text:[      if (webServer != null) {                webServer.shutdown();            }        }    }}]) :|: public void test/*
 *.
 */

package android.uidisolation.cts;

import android.app.Service;
import android.content.Intent;
import android.os.AsyncTask;
import android.os.Handler;
import android.os.IBinder;
import android.os.Message;
import android.os.Messenger;
import android.os.RemoteException;
import android.util.Log;
import android.webkit.cts.CtsTestServer;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;

public class PermissionTestService extends Service {
    private static String TAG = PermissionTestService.class.getName();

    static final String FILE_NAME = ""test_file"";

    // Message receieved from the client.
    static final int MSG_START_TEST = 1;

    // Messages sent to the client.
    static final int MSG_NOTIFY_TEST_SUCCESS = 2;
    static final int MSG_NOTIFY_TEST_FAILURE = 3;

    // The different tests types we run.
    static final int FILE_READ_TEST = 1;
    static final int FILE_WRITE_TEST = 2;
    static final int NETWORK_ACCESS_TEST = 3;

    private Messenger mClient;

    // Whether we expect to have permissions to access files, network...
    boolean mExpectPermissionsAllowed = true;

    class IncomingHandler extends Handler {
        private PermissionTestService mService;

        IncomingHandler(PermissionTestService service) {
            mService = service;
        }

        @Override
        public void handleMessage(Message msg) {
            if (msg.what != MSG_START_TEST) {
                Log.e(TAG, ""PermissionTestService received bad message: "" + msg.what);
                super.handleMessage(msg);
                return;
            }
            mService.mClient = msg.replyTo;
            mService.startTests();
        }
    }

    final Messenger mMessenger = new Messenger(new IncomingHandler(this));

    class NetworkTestAsyncTask e"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/uidisolation/src/android/uidisolation/cts/PermissionTestService.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.uidisolation.cts.IsolatedServiceTest"	"IsolatedServiceTest"	"CtsUidIsolationTestCases"	"1: permission"	"([2:/android/uidisolation/cts/IsolatedServiceTest.java]:[permission]:[2]:method_text:[ror: No success status available."", success);        assertTrue(success.booleanValue());    }   ]) :|: public void test/*
 *.
 */

package android.uidisolation.cts;

import android.app.Activity;
import android.app.Instrumentation;
import android.platform.test.annotations.AppModeFull;
import android.test.ActivityInstrumentationTestCase2;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;

public class IsolatedServiceTest extends ActivityInstrumentationTestCase2<ServiceRunnerActivity> {

    private ServiceRunnerActivity mActivity;

    private Instrumentation mInstrumentation;

    // The time we are ready to wait for the service to be done running the tests.
    private static int SERVICE_TIMEOUT = 15000;

    public IsolatedServiceTest() {
        super(ServiceRunnerActivity.class);
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mInstrumentation = getInstrumentation();
        mActivity = getActivity();

        // We create a file with some content, the test will try to access it.
        FileOutputStream fos = mActivity.openFileOutput(PermissionTestService.FILE_NAME, 0);
        byte[] content = new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
        fos.write(content, 0, content.length);
        fos.close();
    }

    @Override
    protected void tearDown() throws Exception {
        try {
            File f = mActivity.getFileStreamPath(PermissionTestService.FILE_NAME);
            f.delete();
            mActivity.finish();
        } finally {
            super.tearDown();
        }
    }

    private void runServiceTest(final boolean isolated) {
        mInstrumentation.runOnMainSync(new Runnable() {
            public void run() {
                if (isolated) {
                    mActivity.startIsolatedService();
                } else {
                    mActivity.startNonIsolatedService();
                }
            }
        });
        synchronized (mActivity) {
            if (mActivity.getSuccess() == null) {
                try {
                    mActivity.wait(S"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/uidisolation/src/android/uidisolation/cts/IsolatedServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.KeyguardInitialLockTest"	"testSetInitialLockPermission"	"CtsAndroidAppTestCases"	"1: permission"	"([4:/android/app/cts/KeyguardInitialLockTest.java]:[permission]:[4]:method_text:[  + "" and must be revoked for security reasons ["" + validPkg + ""]"");            }        }    }}]) :|: public void testSetInitialLockPermission() {
        final ArraySet<String> allowedPackages = new ArraySet();
        Intent intent = new Intent(Intent.ACTION_MAIN);
        intent.addCategory(Intent.CATEGORY_SETUP_WIZARD);
        PackageManager pm = getContext().getPackageManager();
        final List<ResolveInfo> activities =
                pm.queryIntentActivities(intent, PackageManager.MATCH_DISABLED_COMPONENTS);
        String validPkg = """";
        for (ResolveInfo ri : activities) {
            if (ri != null) {
                allowedPackages.add(ri.activityInfo.packageName);
                validPkg = ri.activityInfo.packageName;
            }
        }
        final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[]{
                android.Manifest.permission.SET_INITIAL_LOCK
        }, PackageManager.MATCH_UNINSTALLED_PACKAGES);
        for (PackageInfo pi : holding) {
            if (!allowedPackages.contains(pi.packageName)) {
                fail(""The SET_INITIAL_LOCK permission must not be held by "" + pi.packageName
                        + "" and must be revoked for security reasons ["" + validPkg + ""]"");
            }
        }
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/app/src/android/app/cts/KeyguardInitialLockTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ApplyOverrideConfigurationTest"	"ApplyOverrideConfigurationTest"	"CtsAndroidAppTestCases"	"1: permission"	"([1:/android/app/cts/ApplyOverrideConfigurationTest.java]:[permission]:[1]:method_text:[n().setRotation(UiAutomation.ROTATION_UNFREEZE);        super.tearDown();    }    @SmallTest   ]) :|: public void test/*
 * Copyright (C) 2016 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License""); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package android.app.cts;

import android.app.UiAutomation;
import android.content.Context;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.test.ActivityInstrumentationTestCase2;

import androidx.test.filters.SmallTest;

import java.util.concurrent.Future;

/**
 * Tests the {@link android.view.ContextThemeWrapper#applyOverrideConfiguration(Configuration)}
 * method and how it affects the Activity's resources and lifecycle callbacks.
 */
public class ApplyOverrideConfigurationTest extends
        ActivityInstrumentationTestCase2<ApplyOverrideConfigurationActivity> {
    public ApplyOverrideConfigurationTest() {
        super(ApplyOverrideConfigurationActivity.class);
    }

    @Override
    public void setUp() throws Exception {
        super.setUp();
        getInstrumentation().getUiAutomation().setRotation(UiAutomation.ROTATION_FREEZE_0);
    }

    @Override
    public void tearDown() throws Exception {
        getInstrumentation().getUiAutomation().setRotation(UiAutomation.ROTATION_UNFREEZE);
        super.tearDown();
    }

    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/app/src/android/app/cts/ApplyOverrideConfigurationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.display.cts.DisplayTest"	"finish"	"CtsDisplayTestCases"	"1: permission"	"([10:/android/display/cts/DisplayTest.java]:[permission]:[10]:method_text:[     * Verify that the getDisplays method returns both a default and an overlay display.     */   ]) :|: /*
 *.
 */

package android.display.cts;

import static android.content.pm.PackageManager.FEATURE_LEANBACK;
import static android.view.Display.DEFAULT_DISPLAY;

import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;

import static org.junit.Assert.*;
import static org.junit.Assume.*;

import android.Manifest;
import android.app.Activity;
import android.app.Instrumentation;
import android.app.Presentation;
import android.app.UiModeManager;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.graphics.Color;
import android.graphics.ColorSpace;
import android.graphics.PixelFormat;
import android.graphics.Point;
import android.hardware.display.DeviceProductInfo;
import android.hardware.display.DisplayManager;
import android.hardware.display.DisplayManager.DisplayListener;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.os.IBinder;
import android.os.Looper;
import android.os.ParcelFileDescriptor;
import android.os.SystemProperties;
import android.platform.test.annotations.Presubmit;
import android.provider.Settings;
import android.text.TextUtils;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.Display;
import android.view.Display.HdrCapabilities;
import android.view.SurfaceControl;
import android.view.View;
import android.view.ViewGroup;
import android.view.WindowManager;

import androidx.test.InstrumentationRegistry;
import androidx.test.rule.ActivityTestRule;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.AdoptShellPermissionsRule;
import com.android.compatibility.common.util.DisplayUtil;
import com.android.compatibility.common.util.PropertyUtil;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.FileInputStream;
import ja"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/display/src/android/display/cts/DisplayTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.display.cts.DisplayTest"	"testFailBrightnessChangeWithoutPermission"	"CtsDisplayTestCases"	"1: permission"	"([1:/android/display/cts/DisplayTest.java]:[permission]:[1]:method_text:[N_BRIGHTNESS, originalValue);            } catch (Exception e) {            }        }    }   ]) :|: 
    public void testFailBrightnessChangeWithoutPermission() throws Exception {
        final DisplayTestActivity activity = launchActivity(mDisplayTestActivity);
        final int originalValue = Settings.System.getInt(mContext.getContentResolver(),
                Settings.System.SCREEN_BRIGHTNESS, BRIGHTNESS_MAX);

        try {
            final int valueToSet = originalValue > 128 ? 40 : 200;  // sufficiently different value
            boolean wasSet = setBrightness(((float) valueToSet) / BRIGHTNESS_MAX);

            assertFalse(wasSet);
            int newValue = Settings.System.getInt(mContext.getContentResolver(),
                    Settings.System.SCREEN_BRIGHTNESS, BRIGHTNESS_MAX);
            assertEquals(originalValue, newValue);  // verify that setting the new value failed.
        } finally {
            try {
                // Clean up just in case the test fails and we did actually manage to change the
                // brightness.
                Settings.System.putInt(mContext.getContentResolver(),
                        Settings.System.SCREEN_BRIGHTNESS, originalValue);
            } catch (Exception e) {
            }
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/display/src/android/display/cts/DisplayTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.display.cts.BrightnessTest"	"testBrightnessSliderTracking"	"CtsDisplayTestCases"	"1: permission"	"([5:/android/display/cts/BrightnessTest.java]:[permission]:[5]:method_text:[tSystemSetting(Settings.System.SCREEN_BRIGHTNESS_MODE, previousBrightnessMode);        }    }   ]) :|: 
    public void testBrightnessSliderTracking() throws InterruptedException {
        // Don't run as there is no app that has permission to access slider usage.
        assumeTrue(
                numberOfSystemAppsWithPermission(Manifest.permission.BRIGHTNESS_SLIDER_USAGE) > 0);

        int previousBrightness = getSystemSetting(Settings.System.SCREEN_BRIGHTNESS);
        int previousBrightnessMode =
                getSystemSetting(Settings.System.SCREEN_BRIGHTNESS_MODE);
        try {
            setSystemSetting(Settings.System.SCREEN_BRIGHTNESS_MODE,
                    Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
            int mode = getSystemSetting(Settings.System.SCREEN_BRIGHTNESS_MODE);
            assertEquals(Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC, mode);

            grantPermission(Manifest.permission.BRIGHTNESS_SLIDER_USAGE);

            // Setup and remember some initial state.
            recordSliderEvents();
            waitForFirstSliderEvent();
            setSystemSetting(Settings.System.SCREEN_BRIGHTNESS, 20);
            getNewEvents(1);

            // Update brightness
            setSystemSetting(Settings.System.SCREEN_BRIGHTNESS, 60);

            // Check we got a slider event for the change.
            List<BrightnessChangeEvent> newEvents = getNewEvents(1);
            assertEquals(1, newEvents.size());
            BrightnessChangeEvent firstEvent = newEvents.get(0);
            assertValidLuxData(firstEvent);

            // Update brightness again
            setSystemSetting(Settings.System.SCREEN_BRIGHTNESS, 200);

            // Check we get a second slider event.
            newEvents = getNewEvents(1);
            assertEquals(1, newEvents.size());
            BrightnessChangeEvent secondEvent = newEvents.get(0);
            assertValidLuxData(secondEvent);
            assertEquals(secondEvent.lastBrightness, firstEvent.brightness, 1.0f);
            assertTrue(secondEvent.isUserSetBrightness);
            a"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/display/src/android/display/cts/BrightnessTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.display.cts.BrightnessTest"	"testNoTrackingForManualBrightness"	"CtsDisplayTestCases"	"1: permission"	"([5:/android/display/cts/BrightnessTest.java]:[permission]:[5]:method_text:[tSystemSetting(Settings.System.SCREEN_BRIGHTNESS_MODE, previousBrightnessMode);        }    }   ]) :|: 
    public void testNoTrackingForManualBrightness() throws InterruptedException {
        // Don't run as there is no app that has permission to access slider usage.
        assumeTrue(
                numberOfSystemAppsWithPermission(Manifest.permission.BRIGHTNESS_SLIDER_USAGE) > 0);

        int previousBrightness = getSystemSetting(Settings.System.SCREEN_BRIGHTNESS);
        int previousBrightnessMode =
                getSystemSetting(Settings.System.SCREEN_BRIGHTNESS_MODE);
        try {
            setSystemSetting(Settings.System.SCREEN_BRIGHTNESS_MODE,
                    Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL);
            int mode = getSystemSetting(Settings.System.SCREEN_BRIGHTNESS_MODE);
            assertEquals(Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, mode);

            grantPermission(Manifest.permission.BRIGHTNESS_SLIDER_USAGE);

            // Setup and remember some initial state.
            recordSliderEvents();
            setSystemSetting(Settings.System.SCREEN_BRIGHTNESS, 20);
            assertTrue(getNewEvents().isEmpty());

            // Then change the brightness
            setSystemSetting(Settings.System.SCREEN_BRIGHTNESS, 80);
            Thread.sleep(200);
            // There shouldn't be any events.
            assertTrue(getNewEvents().isEmpty());
        } finally {
            setSystemSetting(Settings.System.SCREEN_BRIGHTNESS, previousBrightness);
            setSystemSetting(Settings.System.SCREEN_BRIGHTNESS_MODE, previousBrightnessMode);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/display/src/android/display/cts/BrightnessTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.display.cts.BrightnessTest"	"testNoColorSampleData"	"CtsDisplayTestCases"	"1: permission"	"([10:/android/display/cts/BrightnessTest.java]:[permission]:[10]:method_text:[tSystemSetting(Settings.System.SCREEN_BRIGHTNESS_MODE, previousBrightnessMode);        }    }   ]) :|: 
    public void testNoColorSampleData() throws InterruptedException {
          // Don't run as there is no app that has permission to access slider usage.
        assumeTrue(
                numberOfSystemAppsWithPermission(Manifest.permission.BRIGHTNESS_SLIDER_USAGE) > 0);

        // Don't run as there is no app that has permission to push curves.
        assumeTrue(numberOfSystemAppsWithPermission(
                Manifest.permission.CONFIGURE_DISPLAY_BRIGHTNESS) > 0);

        int previousBrightness = getSystemSetting(Settings.System.SCREEN_BRIGHTNESS);
        int previousBrightnessMode =
                getSystemSetting(Settings.System.SCREEN_BRIGHTNESS_MODE);
        try {
            setSystemSetting(Settings.System.SCREEN_BRIGHTNESS_MODE,
                    Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
            int mode = getSystemSetting(Settings.System.SCREEN_BRIGHTNESS_MODE);
            assertEquals(Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC, mode);

            grantPermission(Manifest.permission.BRIGHTNESS_SLIDER_USAGE);
            grantPermission(Manifest.permission.CONFIGURE_DISPLAY_BRIGHTNESS);

            // Set brightness config to not sample color.
            BrightnessConfiguration config =
                    new BrightnessConfiguration.Builder(
                            new float[]{0.0f, 1000.0f},new float[]{20.0f, 500.0f})
                            .setShouldCollectColorSamples(false).build();
            mDisplayManager.setBrightnessConfiguration(config);

            // Setup and generate one slider event.
            recordSliderEvents();
            waitForFirstSliderEvent();
            setSystemSetting(Settings.System.SCREEN_BRIGHTNESS, 20);
            List<BrightnessChangeEvent> newEvents = getNewEvents(1);

            // No color samples.
            assertEquals(0, newEvents.get(0).colorSampleDuration);
            assertNull(newEvents.get(0).colorValueBuckets);

            // No test for sampling color as"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/display/src/android/display/cts/BrightnessTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.display.cts.BrightnessTest"	"testSliderUsagePermission"	"CtsDisplayTestCases"	"1: permission"	"([3:/android/display/cts/BrightnessTest.java]:[permission]:[3]:method_text:[urityException e) {            // Expected            return;        }        fail();    }   ]) :|: 
    public void testSliderUsagePermission() {
        revokePermission(Manifest.permission.BRIGHTNESS_SLIDER_USAGE);

        try {
            mDisplayManager.getBrightnessEvents();
        } catch (SecurityException e) {
            // Expected
            return;
        }
        fail();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/display/src/android/display/cts/BrightnessTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.display.cts.BrightnessTest"	"testConfigureBrightnessPermission"	"CtsDisplayTestCases"	"1: permission"	"([3:/android/display/cts/BrightnessTest.java]:[permission]:[3]:method_text:[urityException e) {            // Expected            return;        }        fail();    }   ]) :|: 
    public void testConfigureBrightnessPermission() {
        revokePermission(Manifest.permission.CONFIGURE_DISPLAY_BRIGHTNESS);

        BrightnessConfiguration config =
            new BrightnessConfiguration.Builder(
                    new float[]{0.0f, 1000.0f},new float[]{20.0f, 500.0f})
                .setDescription(""some test"").build();

        try {
            mDisplayManager.setBrightnessConfiguration(config);
        } catch (SecurityException e) {
            // Expected
            return;
        }
        fail();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/display/src/android/display/cts/BrightnessTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.display.cts.BrightnessTest"	"testSetGetSimpleCurve"	"CtsDisplayTestCases"	"1: permission"	"([5:/android/display/cts/BrightnessTest.java]:[permission]:[5]:method_text:[       assertEquals(mDisplayManager.getDefaultBrightnessConfiguration(), returnedConfig);    }   ]) :|: 
    public void testSetGetSimpleCurve() {
        // Don't run as there is no app that has permission to push curves.
        assumeTrue(numberOfSystemAppsWithPermission(
                Manifest.permission.CONFIGURE_DISPLAY_BRIGHTNESS) > 0);

        grantPermission(Manifest.permission.CONFIGURE_DISPLAY_BRIGHTNESS);

        BrightnessConfiguration defaultConfig = mDisplayManager.getDefaultBrightnessConfiguration();

        BrightnessConfiguration config =
                new BrightnessConfiguration.Builder(
                        new float[]{0.0f, 1000.0f},new float[]{20.0f, 500.0f})
                        .addCorrectionByCategory(ApplicationInfo.CATEGORY_IMAGE,
                                BrightnessCorrection.createScaleAndTranslateLog(0.80f, 0.2f))
                        .addCorrectionByPackageName(""some.package.name"",
                                BrightnessCorrection.createScaleAndTranslateLog(0.70f, 0.1f))
                        .setShortTermModelTimeoutMillis(
                                defaultConfig.getShortTermModelTimeoutMillis() + 1000L)
                        .setShortTermModelLowerLuxMultiplier(
                                defaultConfig.getShortTermModelLowerLuxMultiplier() + 0.2f)
                        .setShortTermModelUpperLuxMultiplier(
                                defaultConfig.getShortTermModelUpperLuxMultiplier() + 0.3f)
                        .setDescription(""some test"").build();
        mDisplayManager.setBrightnessConfiguration(config);
        BrightnessConfiguration returnedConfig = mDisplayManager.getBrightnessConfiguration();
        assertEquals(config, returnedConfig);
        assertEquals(returnedConfig.getCorrectionByCategory(ApplicationInfo.CATEGORY_IMAGE),
                BrightnessCorrection.createScaleAndTranslateLog(0.80f, 0.2f));
        assertEquals(returnedConfig.getCorrectionByPackageName(""some.package.name""),
                BrightnessCorrection.createScaleAndTranslateLog(0.70f, 0.1f));
        as"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/display/src/android/display/cts/BrightnessTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.display.cts.BrightnessTest"	"testGetDefaultCurve"	"CtsDisplayTestCases"	"1: permission"	"([5:/android/display/cts/BrightnessTest.java]:[permission]:[5]:method_text:[< 24 * 60 * 60 * 1000L);        assertFalse(defaultConfig.shouldCollectColorSamples());    }   ]) :|: 
    public void testGetDefaultCurve()  {
        // Don't run as there is no app that has permission to push curves.
        assumeTrue(numberOfSystemAppsWithPermission(
                Manifest.permission.CONFIGURE_DISPLAY_BRIGHTNESS) > 0);

        grantPermission(Manifest.permission.CONFIGURE_DISPLAY_BRIGHTNESS);

        BrightnessConfiguration defaultConfig = mDisplayManager.getDefaultBrightnessConfiguration();
        // Must provide a default config if an app with CONFIGURE_DISPLAY_BRIGHTNESS exists.
        assertNotNull(defaultConfig);

        Pair<float[], float[]> curve = defaultConfig.getCurve();
        assertTrue(curve.first.length > 0);
        assertEquals(curve.first.length, curve.second.length);
        assertInRange(curve.first, 0, Float.MAX_VALUE);
        assertInRange(curve.second, 0, Float.MAX_VALUE);
        assertEquals(0.0, curve.first[0], 0.1);
        assertMonotonic(curve.first, true /*strictly increasing*/, ""lux"");
        assertMonotonic(curve.second, false /*strictly increasing*/, ""nits"");
        assertTrue(defaultConfig.getShortTermModelLowerLuxMultiplier() > 0.0f);
        assertTrue(defaultConfig.getShortTermModelLowerLuxMultiplier() < 10.0f);
        assertTrue(defaultConfig.getShortTermModelUpperLuxMultiplier() > 0.0f);
        assertTrue(defaultConfig.getShortTermModelUpperLuxMultiplier() < 10.0f);
        assertTrue(defaultConfig.getShortTermModelTimeoutMillis() > 0L);
        assertTrue(defaultConfig.getShortTermModelTimeoutMillis() < 24 * 60 * 60 * 1000L);
        assertFalse(defaultConfig.shouldCollectColorSamples());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/display/src/android/display/cts/BrightnessTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.display.cts.BrightnessTest"	"testSliderEventsReflectCurves"	"CtsDisplayTestCases"	"1: permission"	"([10:/android/display/cts/BrightnessTest.java]:[permission]:[10]:method_text:[tSystemSetting(Settings.System.SCREEN_BRIGHTNESS_MODE, previousBrightnessMode);        }    }   ]) :|: 
    public void testSliderEventsReflectCurves() throws InterruptedException {
        // Don't run as there is no app that has permission to access slider usage.
        assumeTrue(
                numberOfSystemAppsWithPermission(Manifest.permission.BRIGHTNESS_SLIDER_USAGE) > 0);
        // Don't run as there is no app that has permission to push curves.
        assumeTrue(numberOfSystemAppsWithPermission(
                Manifest.permission.CONFIGURE_DISPLAY_BRIGHTNESS) > 0);

        BrightnessConfiguration config =
                new BrightnessConfiguration.Builder(
                        new float[]{0.0f, 10000.0f},new float[]{15.0f, 400.0f})
                        .setDescription(""model:8"").build();

        int previousBrightness = getSystemSetting(Settings.System.SCREEN_BRIGHTNESS);
        int previousBrightnessMode =
                getSystemSetting(Settings.System.SCREEN_BRIGHTNESS_MODE);
        try {
            setSystemSetting(Settings.System.SCREEN_BRIGHTNESS_MODE,
                    Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
            int mode = getSystemSetting(Settings.System.SCREEN_BRIGHTNESS_MODE);
            assertEquals(Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC, mode);

            grantPermission(Manifest.permission.BRIGHTNESS_SLIDER_USAGE);
            grantPermission(Manifest.permission.CONFIGURE_DISPLAY_BRIGHTNESS);

            // Setup and remember some initial state.
            recordSliderEvents();
            waitForFirstSliderEvent();
            setSystemSetting(Settings.System.SCREEN_BRIGHTNESS, 20);
            getNewEvents(1);

            // Update brightness while we have a custom curve.
            mDisplayManager.setBrightnessConfiguration(config);
            setSystemSetting(Settings.System.SCREEN_BRIGHTNESS, 60);

            // Check we got a slider event for the change.
            List<BrightnessChangeEvent> newEvents = getNewEvents(1);
            assertEquals(1, newEvents.size());
            B"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/display/src/android/display/cts/BrightnessTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.display.cts.BrightnessTest"	"testAtMostOneAppHoldsBrightnessConfigurationPermission"	"CtsDisplayTestCases"	"1: permission"	"([16:/android/display/cts/BrightnessTest.java]:[permission]:[16]:method_text:[ame + "" values must be "" + condition);            }            prev = values[i];        }    }}]) :|: 
    public void testAtMostOneAppHoldsBrightnessConfigurationPermission() {
        assertTrue(numberOfSystemAppsWithPermission(
                    Manifest.permission.CONFIGURE_DISPLAY_BRIGHTNESS) < 2);
    }

    private void assertValidLuxData(BrightnessChangeEvent event) {
        assertNotNull(event.luxTimestamps);
        assertNotNull(event.luxValues);
        assertTrue(event.luxTimestamps.length > 0);
        assertEquals(event.luxValues.length, event.luxTimestamps.length);
        for (int i = 1; i < event.luxTimestamps.length; ++i) {
            assertTrue(event.luxTimestamps[i - 1] <= event.luxTimestamps[i]);
        }
        for (int i = 0; i < event.luxValues.length; ++i) {
            assertTrue(event.luxValues[i] >= 0.0f);
            assertTrue(event.luxValues[i] <= Float.MAX_VALUE);
            assertFalse(Float.isNaN(event.luxValues[i]));
        }
    }

    /**
     * Returns the number of system apps with the given permission.
     */
    private int numberOfSystemAppsWithPermission(String permission) {
        List<PackageInfo> packages = mContext.getPackageManager().getPackagesHoldingPermissions(
                new String[]{permission}, PackageManager.MATCH_SYSTEM_ONLY);
        packages.removeIf(packageInfo -> packageInfo.packageName.equals(""com.android.shell""));
        return packages.size();
    }

    private List<BrightnessChangeEvent> getNewEvents(int expected)
            throws InterruptedException {
        List<BrightnessChangeEvent> newEvents = new ArrayList<>();
        for (int i = 0; newEvents.size() < expected && i < 20; ++i) {
            if (i != 0) {
                Thread.sleep(100);
            }
            newEvents.addAll(getNewEvents());
        }
        return newEvents;
    }

    private List<BrightnessChangeEvent> getNewEvents() {
        List<BrightnessChangeEvent> newEvents = new ArrayList<>();
        List<BrightnessChangeEvent> events = mDisplayManager.getBrightnessEvents();
        for (BrightnessChangeEv"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/display/src/android/display/cts/BrightnessTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.display.cts.VirtualDisplayTest"	"ImageListener"	"CtsDisplayTestCases"	"1: permission"	"([6:/android/display/cts/VirtualDisplayTest.java]:[permission]:[6]:method_text:[ application can create a private virtual display and show     * its own windows on it.     */   ]) :|: /*
 *.
 */

package android.display.cts;

import static android.hardware.display.DisplayManager.VIRTUAL_DISPLAY_FLAG_SHOULD_SHOW_SYSTEM_DECORATIONS;
import static android.hardware.display.DisplayManager.VIRTUAL_DISPLAY_FLAG_TRUSTED;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import android.Manifest;
import android.app.Presentation;
import android.content.Context;
import android.graphics.Color;
import android.graphics.PixelFormat;
import android.graphics.Point;
import android.graphics.drawable.ColorDrawable;
import android.hardware.display.DisplayManager;
import android.hardware.display.VirtualDisplay;
import android.media.Image;
import android.media.ImageReader;
import android.os.Bundle;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Looper;
import android.os.SystemClock;
import android.platform.test.annotations.AsbSecurityTest;
import android.provider.Settings;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.Display;
import android.view.Surface;
import android.view.ViewGroup.LayoutParams;
import android.widget.ImageView;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.AdoptShellPermissionsRule;
import com.android.compatibility.common.util.SettingsStateKeeperRule;

import org.junit.After;
import org.junit.Before;
import org.junit.ClassRule;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.nio.ByteBuffer;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Tests that applications can create virtual displays and present content on them.
 *
 * This CTS test is unable to test public virtual displays since special permissi"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/display/src/android/display/cts/VirtualDisplayTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.display.cts.VirtualDisplayTest"	"testUntrustedSysDecorVirtualDisplay"	"CtsDisplayTestCases"	"1: permission"	"([1:/android/display/cts/VirtualDisplayTest.java]:[permission]:[1]:method_text:[usted virtual     * display without holding the permission {@code ADD_TRUSTED_DISPLAY}.     */   ]) :|: 
    public void testUntrustedSysDecorVirtualDisplay() throws Exception {
        VirtualDisplay virtualDisplay = mDisplayManager.createVirtualDisplay(NAME,
                WIDTH, HEIGHT, DENSITY, mSurface,
                VIRTUAL_DISPLAY_FLAG_SHOULD_SHOW_SYSTEM_DECORATIONS);
        assertNotNull(""virtual display must not be null"", virtualDisplay);

        Display display = virtualDisplay.getDisplay();
        try {
            // Verify that the created virtual display doesn't have flags
            // FLAG_SHOULD_SHOW_SYSTEM_DECORATIONS.
            assertDisplayRegistered(display, Display.FLAG_PRIVATE);
            assertEquals(mSurface, virtualDisplay.getSurface());

            // Show a private presentation on the display.
            assertDisplayCanShowPresentation(""private presentation window"",
                    display, BLUEISH, 0);
        } finally {
            virtualDisplay.release();
        }
        assertDisplayUnregistered(display);
    }

    /**
     * Ensures that throws {@link SecurityException} when an application creates a trusted virtual
     * display without holding the permission {@code ADD_TRUSTED_DISPLAY}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/display/src/android/display/cts/VirtualDisplayTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.display.cts.VirtualDisplayTest"	"testTrustedVirtualDisplay"	"CtsDisplayTestCases"	"1: permission"	"([1:/android/display/cts/VirtualDisplayTest.java]:[permission]:[1]:method_text:[lay is created without""                + ""holding the permission ADD_TRUSTED_DISPLAY."");    }   ]) :|: 
    public void testTrustedVirtualDisplay() throws Exception {
        try {
            VirtualDisplay virtualDisplay = mDisplayManager.createVirtualDisplay(NAME,
                    WIDTH, HEIGHT, DENSITY, mSurface, VIRTUAL_DISPLAY_FLAG_TRUSTED);
        } catch (SecurityException e) {
            // Expected.
            return;
        }
        fail(""SecurityException must be thrown if a trusted virtual display is created without""
                + ""holding the permission ADD_TRUSTED_DISPLAY."");
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/display/src/android/display/cts/VirtualDisplayTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.deviceconfig.cts.DeviceConfigApiTests"	"isInstantApp"	"CtsDeviceConfigTestCases"	"1: permission"	"([10:/android/deviceconfig/cts/DeviceConfigApiTests.java]:[permission]:[10]:method_text:[);    }    /**     * Checks that getting property which does not exist returns null.     */   ]) :|: /*
 *
 */

package android.deviceconfig.cts;

import static android.provider.Settings.RESET_MODE_PACKAGE_DEFAULTS;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;
import static org.junit.Assume.assumeTrue;
import static org.junit.Assert.fail;

import android.content.Context;
import android.os.SystemClock;
import android.os.UserHandle;
import android.provider.DeviceConfig;
import android.provider.DeviceConfig.OnPropertiesChangedListener;
import android.provider.DeviceConfig.Properties;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;

@RunWith(AndroidJUnit4.class)
public final class DeviceConfigApiTests {
    private static final String NAMESPACE1 = ""namespace1"";
    private static final String NAMESPACE2 = ""namespace2"";
    private static final String EMPTY_NAMESPACE = ""empty_namespace"";
    private static final String KEY1 = ""key1"";
    private static final String KEY2 = ""key2"";
    private static final String VALUE1 = ""value1"";
    private static final String VALUE2 = ""value2"";
    private static final String DEFAULT_VALUE = ""default_value"";

    private static final boolean DEFAULT_BOOLEAN_TRUE = true;
    private static final boolean DEFAULT_BOOLEAN_FALSE = false;
    private static final boolean BOOLEAN_TRUE = true;
    private static final boolean BOOLEAN_FALSE = false;
    private static final String INVALID_BOOLEAN = ""TR_UE"";

    private static final int DEFAULT_INT = 999;
    private static final int VALID_INT = 123;
    private static final String INVALID_INT = ""12E"";

    private static final long DEFAULT_LONG = 123456;
    private static final long VALID_LONG = 278724287;
    private s"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/deviceconfig/src/android/deviceconfig/cts/DeviceConfigApiTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.deviceconfig.cts.DeviceConfigApiPermissionTests"	"dropShellPermissionIdentityAfterTest"	"CtsDeviceConfigTestCases"	"1: permission"	"([8:/android/deviceconfig/cts/DeviceConfigApiPermissionTests.java]:[permission]:[8]:method_text:[ * permissions it cannot access any of DeviceConfig API methods     * @throws Exception     */   ]) :|: /*
 *.
 */

package android.deviceconfig.cts;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

import android.provider.DeviceConfig;
import android.provider.DeviceConfig.OnPropertiesChangedListener;
import android.provider.DeviceConfig.Properties;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import org.junit.After;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.concurrent.Executor;

@RunWith(AndroidJUnit4.class)
public final class DeviceConfigApiPermissionTests {
    private static final String NAMESPACE = ""namespace"";
    private static final String NAMESPACE2 = ""namespace2"";
    private static final String PUBLIC_NAMESPACE = ""textclassifier"";
    private static final String KEY = ""key"";
    private static final String KEY2 = ""key2"";
    private static final String VALUE = ""value"";

    private static final String WRITE_DEVICE_CONFIG_PERMISSION =
            ""android.permission.WRITE_DEVICE_CONFIG"";

    private static final String READ_DEVICE_CONFIG_PERMISSION =
            ""android.permission.READ_DEVICE_CONFIG"";

    private static final Executor EXECUTOR = InstrumentationRegistry.getContext().getMainExecutor();

    @After
    public void dropShellPermissionIdentityAfterTest() {
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .dropShellPermissionIdentity();
    }
    /**
     * Checks that when application does not have READ_DEVICE_CONFIG or WRITE_DEVICE_CONFIG
     * permissions it cannot access any of DeviceConfig API methods
     * @throws Exception
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/deviceconfig/src/android/deviceconfig/cts/DeviceConfigApiPermissionTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.deviceconfig.cts.DeviceConfigApiPermissionTests"	"testDeviceConfigWithoutPermissions"	"CtsDeviceConfigTestCases"	"1: permission"	"([9:/android/deviceconfig/cts/DeviceConfigApiPermissionTests.java]:[permission]:[9]:method_text:[NFIG permission it can access only     * setProperty() methods     * @throws Exception     */   ]) :|: 
    public void testDeviceConfigWithoutPermissions() {
        StringBuilder violations = new StringBuilder();

        // setters without write permission
        trySetPropertyWithoutWritePermission(violations);
        trySetPropertiesWithoutWritePermission(violations);

        // getters without read permission
        tryGetPropertyWithoutReadPermission(violations);
        tryGetPropertiesWithoutReadPermission(violations);
        tryAddOnPropertiesChangedListenerWithoutReadPermission(violations);

        // Bail if we found any violations
        if (violations.length() > 0) {
            fail(violations.toString());
        }
    }

    /**
     * Checks that when application has only WRITE_DEVICE_CONFIG permission it can access only
     * setProperty() methods
     * @throws Exception
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/deviceconfig/src/android/deviceconfig/cts/DeviceConfigApiPermissionTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.deviceconfig.cts.DeviceConfigApiPermissionTests"	"testDeviceConfigWithWritePermission"	"CtsDeviceConfigTestCases"	"1: permission"	"([11:/android/deviceconfig/cts/DeviceConfigApiPermissionTests.java]:[permission]:[11]:method_text:[    * getProperty() and addOnPropertiesChangeListener() methods     * @throws Exception     */   ]) :|: 
    public void testDeviceConfigWithWritePermission() {

        StringBuilder violations = new StringBuilder();
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(WRITE_DEVICE_CONFIG_PERMISSION);

        // setters with write permission
        trySetPropertyWithWritePermission(violations);
        trySetPropertiesWithWritePermission(violations);

        // getters without read permission
        tryGetPropertyWithoutReadPermission(violations);
        tryGetPropertiesWithoutReadPermission(violations);
        tryAddOnPropertiesChangedListenerWithoutReadPermission(violations);

        // Bail if we found any violations
        if (violations.length() > 0) {
            fail(violations.toString());
        }
    }

    /**
     * Checks that when application has only READ_DEVICE_CONFIG permission it can access only
     * getProperty() and addOnPropertiesChangeListener() methods
     * @throws Exception
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/deviceconfig/src/android/deviceconfig/cts/DeviceConfigApiPermissionTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.deviceconfig.cts.DeviceConfigApiPermissionTests"	"testDeviceConfigWithReadPermission"	"CtsDeviceConfigTestCases"	"1: permission"	"([11:/android/deviceconfig/cts/DeviceConfigApiPermissionTests.java]:[permission]:[11]:method_text:[RITE_DEVICE_CONFIG permissions     * it can access all methods     * @throws Exception     */   ]) :|: 
    public void testDeviceConfigWithReadPermission() {
        StringBuilder violations = new StringBuilder();

        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(READ_DEVICE_CONFIG_PERMISSION);

        // setters without write permission
        trySetPropertyWithoutWritePermission(violations);
        trySetPropertiesWithoutWritePermission(violations);

        // getters with read permission
        tryGetPropertyWithReadPermission(violations);
        tryGetPropertiesWithReadPermission(violations);
        tryAddOnPropertiesChangedListenerWithReadPermission(violations);

        // Bail if we found any violations
        if (violations.length() > 0) {
            fail(violations.toString());
        }
    }

    /**
     * Checks that when application has both READ_DEVICE_CONFIG and WRITE_DEVICE_CONFIG permissions
     * it can access all methods
     * @throws Exception
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/deviceconfig/src/android/deviceconfig/cts/DeviceConfigApiPermissionTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.deviceconfig.cts.DeviceConfigApiPermissionTests"	"testDeviceConfigWithAllPermissions"	"CtsDeviceConfigTestCases"	"1: permission"	"([12:/android/deviceconfig/cts/DeviceConfigApiPermissionTests.java]:[permission]:[12]:method_text:[on can still read from     * public namespaces in DeviceConfig     * @throws Exception     */   ]) :|: 
    public void testDeviceConfigWithAllPermissions() {
        StringBuilder violations = new StringBuilder();

        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(
                        WRITE_DEVICE_CONFIG_PERMISSION,
                        READ_DEVICE_CONFIG_PERMISSION);

        // setters with write permission
        trySetPropertyWithWritePermission(violations);
        trySetPropertiesWithWritePermission(violations);

        // getters with read permission
        String property = tryGetPropertyWithReadPermission(violations);
        assertEquals(""Value read from getProperty does not match written value."",
                VALUE, property);
        Properties properties = tryGetPropertiesWithReadPermission(violations);
        assertEquals(""Value read from getProperties does not match written value."",
                VALUE, properties.getString(KEY2, ""default_value""));
        tryAddOnPropertiesChangedListenerWithReadPermission(violations);

        // Bail if we found any violations
        if (violations.length() > 0) {
            fail(violations.toString());
        }
    }

    /**
     * Checks that when application that does not have read permission can still read from
     * public namespaces in DeviceConfig
     * @throws Exception
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/deviceconfig/src/android/deviceconfig/cts/DeviceConfigApiPermissionTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.deviceconfig.cts.DeviceConfigApiPermissionTests"	"testDeviceConfigPublicNamespacesWithoutReadPermission"	"CtsDeviceConfigTestCases"	"1: permission"	"([31:/android/deviceconfig/cts/DeviceConfigApiPermissionTests.java]:[permission]:[31]:method_text:[      Exception e) {        violations.append(message).append("": "").append(e).append(""\n"");    }}]) :|: 
    public void testDeviceConfigPublicNamespacesWithoutReadPermission() {
        // if permission is not yet available in the system, skip the test
        StringBuilder violations = new StringBuilder();

        try {
            DeviceConfig.setProperty(PUBLIC_NAMESPACE, KEY, VALUE, /*makeDefault=*/ false);
            violations.append(""DeviceConfig.setProperty() for public namespaces must not be ""
                    + ""accessible without WRITE_DEVICE_CONFIG permission\n"");
        } catch (SecurityException e) {
        }

        try {
            Properties properties =
                    new Properties.Builder(PUBLIC_NAMESPACE).setString(KEY2, VALUE).build();
            DeviceConfig.setProperties(properties);
            violations.append(""DeviceConfig.setProperties() for public namespaces must not be ""
                    + "" accessible without WRITE_DEVICE_CONFIG permission\n"");
        } catch (DeviceConfig.BadConfigException e) {
            addExceptionToViolations(violations, ""DeviceConfig.setProperties() should not throw ""
                    + ""BadConfigException without a known bad configuration"", e);
        } catch (SecurityException e) {
        }

        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(WRITE_DEVICE_CONFIG_PERMISSION);

        try {
            DeviceConfig.setProperty(PUBLIC_NAMESPACE, KEY, VALUE, /*makeDefault=*/ false);
        } catch (SecurityException e) {
            addExceptionToViolations(violations, ""DeviceConfig.setProperty() must be accessible ""
                    + ""with WRITE_DEVICE_CONFIG permission"", e);
        }

        try {
            Properties properties =
                    new Properties.Builder(PUBLIC_NAMESPACE).setString(KEY, VALUE).build();
            DeviceConfig.setProperties(properties);
        } catch (DeviceConfig.BadConfigException e) {
            addExceptionToViolations(violations, ""DeviceConfig.setProperties() should not"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/deviceconfig/src/android/deviceconfig/cts/DeviceConfigApiPermissionTests.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.slice.cts.SlicePermissionsTest"	"testGrant"	"CtsSliceTestCases"	"1: permission"	"([5:/android/slice/cts/SlicePermissionsTest.java]:[permission]:[5]:method_text:[ANTED,                mSliceManager.checkSlicePermission(BASE_URI, mTestPid, mTestUid));    }   ]) :|: 
    public void testGrant() {
        assumeFalse(isSliceDisabled);
        assertEquals(PERMISSION_DENIED,
                mSliceManager.checkSlicePermission(BASE_URI, mTestPid, mTestUid));

        mSliceManager.grantSlicePermission(mTestPkg, BASE_URI);

        assertEquals(PERMISSION_GRANTED,
                mSliceManager.checkSlicePermission(BASE_URI, mTestPid, mTestUid));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/slice/src/android/slice/cts/SlicePermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.slice.cts.SlicePermissionsTest"	"testGrantParent"	"CtsSliceTestCases"	"1: permission"	"([5:/android/slice/cts/SlicePermissionsTest.java]:[permission]:[5]:method_text:[ON_GRANTED,                mSliceManager.checkSlicePermission(uri, mTestPid, mTestUid));    }   ]) :|: 
    public void testGrantParent() {
        assumeFalse(isSliceDisabled);
        Uri uri = BASE_URI.buildUpon()
                .appendPath(""something"")
                .build();

        assertEquals(PERMISSION_DENIED,
                mSliceManager.checkSlicePermission(uri, mTestPid, mTestUid));

        mSliceManager.grantSlicePermission(mTestPkg, BASE_URI);

        assertEquals(PERMISSION_GRANTED,
                mSliceManager.checkSlicePermission(uri, mTestPid, mTestUid));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/slice/src/android/slice/cts/SlicePermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.slice.cts.SlicePermissionsTest"	"testGrantParentExpands"	"CtsSliceTestCases"	"1: permission"	"([12:/android/slice/cts/SlicePermissionsTest.java]:[permission]:[12]:method_text:[ANTED,                mSliceManager.checkSlicePermission(BASE_URI, mTestPid, mTestUid));    }   ]) :|: 
    public void testGrantParentExpands() {
        assumeFalse(isSliceDisabled);
        Uri uri = BASE_URI.buildUpon()
                .appendPath(""something"")
                .build();

        assertEquals(PERMISSION_DENIED,
                mSliceManager.checkSlicePermission(uri, mTestPid, mTestUid));

        mSliceManager.grantSlicePermission(mTestPkg, uri);

        // Only sub-path granted.
        assertEquals(PERMISSION_GRANTED,
                mSliceManager.checkSlicePermission(uri, mTestPid, mTestUid));
        assertEquals(PERMISSION_DENIED,
                mSliceManager.checkSlicePermission(BASE_URI, mTestPid, mTestUid));

        mSliceManager.grantSlicePermission(mTestPkg, BASE_URI);

        // Now all granted.
        assertEquals(PERMISSION_GRANTED,
                mSliceManager.checkSlicePermission(uri, mTestPid, mTestUid));
        assertEquals(PERMISSION_GRANTED,
                mSliceManager.checkSlicePermission(BASE_URI, mTestPid, mTestUid));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/slice/src/android/slice/cts/SlicePermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.slice.cts.SlicePermissionsTest"	"testGrantChild"	"CtsSliceTestCases"	"1: permission"	"([6:/android/slice/cts/SlicePermissionsTest.java]:[permission]:[6]:method_text:[ENIED,                mSliceManager.checkSlicePermission(BASE_URI, mTestPid, mTestUid));    }   ]) :|: 
    public void testGrantChild() {
        assumeFalse(isSliceDisabled);
        Uri uri = BASE_URI.buildUpon()
                .appendPath(""something"")
                .build();

        assertEquals(PERMISSION_DENIED,
                mSliceManager.checkSlicePermission(BASE_URI, mTestPid, mTestUid));

        mSliceManager.grantSlicePermission(mTestPkg, uri);

        // Still no permission because only a child was granted
        assertEquals(PERMISSION_DENIED,
                mSliceManager.checkSlicePermission(BASE_URI, mTestPid, mTestUid));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/slice/src/android/slice/cts/SlicePermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.slice.cts.SlicePermissionsTest"	"testRevoke"	"CtsSliceTestCases"	"1: permission"	"([8:/android/slice/cts/SlicePermissionsTest.java]:[permission]:[8]:method_text:[ENIED,                mSliceManager.checkSlicePermission(BASE_URI, mTestPid, mTestUid));    }   ]) :|: 
    public void testRevoke() {
        assumeFalse(isSliceDisabled);
        assertEquals(PERMISSION_DENIED,
                mSliceManager.checkSlicePermission(BASE_URI, mTestPid, mTestUid));

        mSliceManager.grantSlicePermission(mTestPkg, BASE_URI);

        assertEquals(PERMISSION_GRANTED,
                mSliceManager.checkSlicePermission(BASE_URI, mTestPid, mTestUid));

        mSliceManager.revokeSlicePermission(mTestPkg, BASE_URI);

        assertEquals(PERMISSION_DENIED,
                mSliceManager.checkSlicePermission(BASE_URI, mTestPid, mTestUid));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/slice/src/android/slice/cts/SlicePermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.slice.cts.SlicePermissionsTest"	"testRevokeParent"	"CtsSliceTestCases"	"1: permission"	"([8:/android/slice/cts/SlicePermissionsTest.java]:[permission]:[8]:method_text:[ION_DENIED,                mSliceManager.checkSlicePermission(uri, mTestPid, mTestUid));    }   ]) :|: 
    public void testRevokeParent() {
        assumeFalse(isSliceDisabled);
        Uri uri = BASE_URI.buildUpon()
                .appendPath(""something"")
                .build();
        assertEquals(PERMISSION_DENIED,
                mSliceManager.checkSlicePermission(uri, mTestPid, mTestUid));

        mSliceManager.grantSlicePermission(mTestPkg, uri);

        assertEquals(PERMISSION_GRANTED,
                mSliceManager.checkSlicePermission(uri, mTestPid, mTestUid));

        mSliceManager.revokeSlicePermission(mTestPkg, BASE_URI);

        // Revoked because parent was revoked
        assertEquals(PERMISSION_DENIED,
                mSliceManager.checkSlicePermission(uri, mTestPid, mTestUid));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/slice/src/android/slice/cts/SlicePermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.slice.cts.SlicePermissionsTest"	"testRevokeChild"	"CtsSliceTestCases"	"1: permission"	"([8:/android/slice/cts/SlicePermissionsTest.java]:[permission]:[8]:method_text:[GRANTED,                mSliceManager.checkSlicePermission(BASE_URI, mTestPid, mTestUid));    }}]) :|: 
    public void testRevokeChild() {
        assumeFalse(isSliceDisabled);
        Uri uri = BASE_URI.buildUpon()
                .appendPath(""something"")
                .build();
        assertEquals(PERMISSION_DENIED,
                mSliceManager.checkSlicePermission(BASE_URI, mTestPid, mTestUid));

        mSliceManager.grantSlicePermission(mTestPkg, BASE_URI);

        assertEquals(PERMISSION_GRANTED,
                mSliceManager.checkSlicePermission(BASE_URI, mTestPid, mTestUid));

        mSliceManager.revokeSlicePermission(mTestPkg, uri);

        // Not revoked because child was revoked.
        assertEquals(PERMISSION_GRANTED,
                mSliceManager.checkSlicePermission(BASE_URI, mTestPid, mTestUid));
    }

}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/slice/src/android/slice/cts/SlicePermissionsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.slice.cts.SliceManagerTest"	"testOnCreatePermissionSlice"	"CtsSliceTestCases"	"1: permission"	"([4:/android/slice/cts/SliceManagerTest.java]:[permission]:[4]:method_text:[ntation getInstrumentation() {        return InstrumentationRegistry.getInstrumentation();    }}]) :|: 
    public void testOnCreatePermissionSlice() {
        assumeFalse(isSliceDisabled);
        LocalSliceProvider.sAnswer = invocation -> {
            throw new SecurityException(""No slices allowed"");
        };
        try {
            Uri uri = BASE_URI.buildUpon().path(""permission"").build();
            PendingIntent intent = PendingIntent.getBroadcast(mContext, 0, new Intent(""""),
                    PendingIntent.FLAG_IMMUTABLE);

            when(LocalSliceProvider.sProxy.onCreatePermissionRequest(any())).thenReturn(intent);

            Slice s = mSliceManager.bindSlice(uri, Collections.emptySet());

            /// Make sure we get a callback for creating the intent.
            verify(LocalSliceProvider.sProxy).onCreatePermissionRequest(eq(uri));
            // Verify the intent we get back is the one we returned.
            PendingIntent i = findAction(s);
            assertTrue(intent == i);
        } finally {
            LocalSliceProvider.sAnswer = null;
        }
    }

    private PendingIntent findAction(Slice s) {
        for (SliceItem item : s.getItems()) {
            if (SliceItem.FORMAT_SLICE.equals(item.getFormat())) {
                return findAction(item.getSlice());
            }
            if (SliceItem.FORMAT_ACTION.equals(item.getFormat())) {
                return item.getAction();
            }
        }
        return null;
    }

    public static String getDefaultLauncher() throws Exception {
        final String PREFIX = ""Launcher: ComponentInfo{"";
        final String POSTFIX = ""}"";
        for (String s : runShellCommand(""cmd shortcut get-default-launcher"")) {
            if (s.startsWith(PREFIX) && s.endsWith(POSTFIX)) {
                return s.substring(PREFIX.length(), s.length() - POSTFIX.length());
            }
        }
        throw new Exception(""Default launcher not found"");
    }

    public static ArrayList<String> runShellCommand(String command) throws Exception {
        ParcelFileDescriptor pfd = getInstrumen"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/slice/src/android/slice/cts/SliceManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.media.mediatranscoding.cts.MediaTranscodingManagerTest"	"dropShellPermissionIdentity"	"CtsMediaTranscodingTestCases"	"1: permission"	"([3:/android/media/mediatranscoding/cts/MediaTranscodingManagerTest.java]:[permission]:[3]:method_text:[E);    }    /**     * Verify that setting null destination uri will throw exception.     */   ]) :|: public void test/*
 *.
 */

package android.media.mediatranscoding.cts;

import static org.testng.Assert.assertThrows;


import android.content.ContentResolver;
import android.content.Context;
import android.content.pm.PackageManager;
import android.content.res.AssetFileDescriptor;
import android.media.ApplicationMediaCapabilities;
import android.media.MediaCodec;
import android.media.MediaCodecInfo;
import android.media.MediaExtractor;
import android.media.MediaFormat;
import android.media.MediaTranscodingManager;
import android.media.MediaTranscodingManager.TranscodingRequest;
import android.media.MediaTranscodingManager.TranscodingSession;
import android.media.MediaTranscodingManager.VideoTranscodingRequest;
import android.net.Uri;
import android.os.Bundle;
import android.os.Environment;
import android.os.FileUtils;
import android.os.ParcelFileDescriptor;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.Presubmit;
import android.platform.test.annotations.RequiresDevice;
import android.provider.MediaStore;
import android.test.AndroidTestCase;
import android.util.Log;

import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.MediaUtils;

import org.junit.Test;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

@Presubmit
@RequiresDevice
@AppModeFull(reason = ""Instant apps cannot access the SD card"")
public class MediaTranscodingManagerTest extends AndroidTestCase {
    private static fi"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/mediatranscoding/src/android/media/mediatranscoding/cts/MediaTranscodingManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.util.cts.InstallUtilTest"	"dropShellPermissionIdentity"	"CtsUtilTestCases"	"1: permission"	"([6:/android/util/cts/InstallUtilTest.java]:[permission]:[6]:method_text:[1 == -1) break;                assertThat(buf1).isEqualTo(buf2);            }        }    }   ]) :|: /*
 *.
 */

package android.util.cts;

import static com.google.common.truth.Truth.assertThat;

import android.Manifest;
import android.content.pm.PackageInstaller;
import android.content.pm.PackageManager;
import android.platform.test.annotations.AppModeFull;

import androidx.test.filters.SmallTest;
import androidx.test.runner.AndroidJUnit4;

import com.android.cts.install.lib.Install;
import com.android.cts.install.lib.InstallUtils;
import com.android.cts.install.lib.LocalIntentSender;
import com.android.cts.install.lib.TestApp;
import com.android.cts.install.lib.Uninstall;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Field;

@SmallTest
@RunWith(AndroidJUnit4.class)
@AppModeFull(reason = ""Instant apps cannot create installer sessions"")
/**
 * Test for cts.install.lib.
 * <p>This test also tries to showcase how to use the library.
 */
public class InstallUtilTest {
    /**
     * Drops adopted shell permissions and uninstalls the test apps.
     */
    @After
    public void teardown() throws InterruptedException, IOException {
        // Good tests clean up after themselves.
        // Remember that other tests will be using the same test apps.
        Uninstall.packages(TestApp.A, TestApp.B);

        InstallUtils.dropShellPermissionIdentity();
    }

    /**
     * Adopts common permissions needed to test rollbacks and uninstalls the
     * test apps.
     */
    @Before
    public void setup() throws InterruptedException, IOException {
        InstallUtils.adoptShellPermissionIdentity(
                    Manifest.permission.INSTALL_PACKAGES,
                    Manifest.permission.DELETE_PACKAGES);
        // Better tests work regardless of whether other tests clean up after themselves or not.
        Uninstall.packages(TestApp.A, TestApp.B);
    }

    /**
     * Asserts that the resource streams h"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/tests/util/src/android/util/cts/InstallUtilTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.admin.cts.DevicePolicyManagerTest"	"testManagedProvisioningPreInstalled"	"CtsAdminTestCases"	"1: permission"	"([1:/android/admin/cts/DevicePolicyManagerTest.java]:[permission]:[1]:method_text:[ofile owner"")                || message.contains(""Calling identity is not authorized""));    }   ]) :|: public void testManagedProvisioningPreInstalled() throws Exception {
        if (mDeviceAdmin) {
            assertTrue(isPackageInstalledOnSystemImage(MANAGED_PROVISIONING_PKG));
        }
    }

    private void assertDeviceOwnerMessage(String message) {
        assertTrue(""message is: ""+ message, message.contains(""does not own the device"")
                || message.contains(""can only be called by the device owner"")
                || message.contains(""Calling identity is not authorized""));
    }

    private void assertOrganizationOwnedProfileOwnerMessage(String message) {
        assertTrue(""message is: "" + message, message.contains(
                ""is not the profile owner on organization-owned device"")
                || message.contains(""Calling identity is not authorized""));
    }

    private void assertDeviceOwnerOrManageUsersMessage(String message) {
        assertTrue(""message is: ""+ message, message.contains(""does not own the device"")
                || message.contains(""can only be called by the device owner"")
                || (message.startsWith(""Neither user "") && message.endsWith(
                        "" nor current process has android.permission.MANAGE_USERS.""))
                || message.contains(""Calling identity is not authorized""));
    }

    private void assertProfileOwnerMessage(String message) {
        assertTrue(""message is: ""+ message, message.contains(""does not own the profile"")
                || message.contains(""is not profile owner"")
                || message.contains(""Calling identity is not authorized""));
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/admin/src/android/admin/cts/DevicePolicyManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.DownloadManagerApi28Test"	"testAddCompletedDownload_publicDirs"	""	"1: permission"	"([2:/android/app/cts/DownloadManagerApi28Test.java]:[permission]:[2]:method_text:[quals(fileContents, rawFileContents);            assertRemoveDownload(id, 0);        }    }   ]) :|: 
    public void testAddCompletedDownload_publicDirs() throws Exception {
        final String[] filePaths = new String[] {
                createFile(Environment.getExternalStoragePublicDirectory(
                        Environment.DIRECTORY_DOWNLOADS), ""file1.txt"").getPath(),
                createFile(Environment.getExternalStoragePublicDirectory(
                        Environment.DIRECTORY_DOCUMENTS), ""file2.txt"").getPath(),
                ""/sdcard/Download/file3.txt"",
        };

        for (String path : filePaths) {
            final String fileContents = ""Test content:"" + path + ""_"" + System.nanoTime();

            final File file = new File(path);
            writeToFile(new File(path), fileContents);

            final long id = mDownloadManager.addCompletedDownload(file.getName(), ""Test desc"", true,
                    ""text/plain"", path, fileContents.getBytes().length, true);
            final String actualContents = readFromFile(mDownloadManager.openDownloadedFile(id));
            assertEquals(fileContents, actualContents);

            final Uri downloadUri = mDownloadManager.getUriForDownloadedFile(id);
            mContext.grantUriPermission(""com.android.shell"", downloadUri,
                    Intent.FLAG_GRANT_READ_URI_PERMISSION);
            final String rawFilePath = getRawFilePath(downloadUri);
            final String rawFileContents = readFromRawFile(rawFilePath);
            assertEquals(fileContents, rawFileContents);
            assertRemoveDownload(id, 0);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/DownloadManagerApi28Test/src/android/app/cts/DownloadManagerApi28Test.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerAppExitInfoTest"	"finish"	"CtsAppExitTestCases"	"1: permission"	"([1:/android/app/cts/ActivityManagerAppExitInfoTest.java]:[permission]:[1]:method_text:[Manager.class);        return am.getHistoricalProcessExitReasons(packageName, pid, max);    }   ]) :|: public void test/*
 *.
 */

package android.app.cts;

import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;

import android.app.ActivityManager;
import android.app.ActivityManager.RunningAppProcessInfo;
import android.app.ApplicationExitInfo;
import android.app.Instrumentation;
import android.app.cts.android.app.cts.tools.WatchUidRunner;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.ServiceConnection;
import android.externalservice.common.RunningServiceInfo;
import android.externalservice.common.ServiceMessages;
import android.os.AsyncTask;
import android.os.Binder;
import android.os.Bundle;
import android.os.DropBoxManager;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.IBinder;
import android.os.Looper;
import android.os.Message;
import android.os.Messenger;
import android.os.Process;
import android.os.SystemClock;
import android.os.UserHandle;
import android.os.UserManager;
import android.provider.Settings;
import android.server.wm.settings.SettingsSession;
import android.system.OsConstants;
import android.test.InstrumentationTestCase;
import android.text.TextUtils;
import android.util.DebugUtils;
import android.util.Log;
import android.util.Pair;

import com.android.compatibility.common.util.AmMonitor;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;
import com.android.internal.util.ArrayUtils;
import com.android.internal.util.MemInfoReader;
import com.android.server.os.TombstoneProtos.Tombstone;

import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

public final class ActivityManagerAppExitInfoTe"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/AppExitTest/src/android/app/cts/ActivityManagerAppExitInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerAppExitInfoTest"	"testExitCode"	"CtsAppExitTestCases"	"1: permission"	"([2:/android/app/cts/ActivityManagerAppExitInfoTest.java]:[permission]:[2]:method_text:[+"") == -1) {                break;            }        }        return memConsumers;    }   ]) :|: public void testExitCode() throws Exception {
        // Remove old records to avoid interference with the test.
        clearHistoricalExitInfo();

        long now = System.currentTimeMillis();
        // Start a process and let it call System.exit() right away.
        startService(ACTION_EXIT, STUB_SERVICE_NAME, true, false);

        long now2 = System.currentTimeMillis();
        // Query with the current package name, but the mStubPackagePid belongs to the
        // target package, so the below call should return an empty result.
        List<ApplicationExitInfo> list = null;
        try {
            list = mActivityManager.getHistoricalProcessExitReasons(
                    STUB_PACKAGE_NAME, mStubPackagePid, 1);
            fail(""Shouldn't be able to query other package"");
        } catch (SecurityException e) {
            // expected
        }

        // Now query with the advanced version
        try {
            list = getHistoricalProcessExitReasonsAsUser(STUB_PACKAGE_NAME,
                    mStubPackagePid, 1, mCurrentUserId);
            fail(""Shouldn't be able to query other package"");
        } catch (SecurityException e) {
            // expected
        }

        list = ShellIdentityUtils.invokeMethodWithShellPermissions(
                STUB_PACKAGE_NAME, mStubPackagePid, 1, mCurrentUserId,
                this::getHistoricalProcessExitReasonsAsUser,
                android.Manifest.permission.DUMP);

        assertTrue(list != null && list.size() == 1);
        verify(list.get(0), mStubPackagePid, mStubPackageUid, STUB_PACKAGE_NAME,
                ApplicationExitInfo.REASON_EXIT_SELF, EXIT_CODE, null, now, now2);
    }

    private List<ServiceConnection> fillUpMemoryAndCheck(
            final MemoryConsumerService.TestFuncInterface testFunc,
            final List<ApplicationExitInfo> list) throws Exception {
        final String procNamePrefix = ""memconsumer_"";
        final ArrayList<ServiceConnection> memConsumers = new ArrayList<"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/AppExitTest/src/android/app/cts/ActivityManagerAppExitInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerAppExitInfoTest"	"testLmkdKill"	"CtsAppExitTestCases"	"1: permission"	"([2:/android/app/cts/ActivityManagerAppExitInfoTest.java]:[permission]:[2]:method_text:[    ApplicationExitInfo.REASON_SIGNALED, OsConstants.SIGKILL, null, now, now2);        }    }   ]) :|: public void testLmkdKill() throws Exception {
        // Remove old records to avoid interference with the test.
        clearHistoricalExitInfo();

        long now = System.currentTimeMillis();
        boolean lmkdReportSupported = ActivityManager.isLowMemoryKillReportSupported();

        // Start a process and do nothing
        startService(ACTION_FINISH, STUB_SERVICE_NAME, false, false);

        final ArrayList<IBinder> memConsumers = new ArrayList<>();
        List<ApplicationExitInfo> list = new ArrayList<>();
        final MemoryConsumerService.TestFuncInterface testFunc =
                new MemoryConsumerService.TestFuncInterface(() -> {
                    final long token = Binder.clearCallingIdentity();
                    try {
                        List<ApplicationExitInfo> result =
                                ShellIdentityUtils.invokeMethodWithShellPermissions(
                                        STUB_PACKAGE_NAME, mStubPackagePid, 1,
                                        mActivityManager::getHistoricalProcessExitReasons,
                                        android.Manifest.permission.DUMP);
                        if (result != null && result.size() == 1) {
                            list.add(result.get(0));
                            return true;
                        }
                    } finally {
                        Binder.restoreCallingIdentity(token);
                    }
                    return false;
                });

        List<ServiceConnection> services = fillUpMemoryAndCheck(testFunc, list);

        // Unbind all the service connections firstly
        for (int i = services.size() - 1; i >= 0; i--) {
            mContext.unbindService(services.get(i));
        }

        long now2 = System.currentTimeMillis();
        assertTrue(list != null && list.size() == 1);
        ApplicationExitInfo info = list.get(0);
        assertNotNull(info);
        if (lmkdReportSupported) {
            verify(info, mS"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/AppExitTest/src/android/app/cts/ActivityManagerAppExitInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerAppExitInfoTest"	"testKillBySignal"	"CtsAppExitTestCases"	"1: permission"	"([2:/android/app/cts/ActivityManagerAppExitInfoTest.java]:[permission]:[2]:method_text:[              ApplicationExitInfo.REASON_SIGNALED, OsConstants.SIGKILL, null, now, now2);    }   ]) :|: public void testKillBySignal() throws Exception {
        // Remove old records to avoid interference with the test.
        clearHistoricalExitInfo();

        long now = System.currentTimeMillis();

        // Start a process and kill itself
        startService(ACTION_KILL, STUB_SERVICE_NAME, true, false);

        long now2 = System.currentTimeMillis();
        List<ApplicationExitInfo> list = ShellIdentityUtils.invokeMethodWithShellPermissions(
                STUB_PACKAGE_NAME, mStubPackagePid, 1,
                mActivityManager::getHistoricalProcessExitReasons,
                android.Manifest.permission.DUMP);

        assertTrue(list != null && list.size() == 1);
        verify(list.get(0), mStubPackagePid, mStubPackageUid, STUB_PACKAGE_NAME,
                ApplicationExitInfo.REASON_SIGNALED, OsConstants.SIGKILL, null, now, now2);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/AppExitTest/src/android/app/cts/ActivityManagerAppExitInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerAppExitInfoTest"	"testAnr"	"CtsAppExitTestCases"	"1: permission"	"([4:/android/app/cts/ActivityManagerAppExitInfoTest.java]:[permission]:[4]:method_text:[f(trace) >= 0);        monitor.finish();        mContext.unregisterReceiver(receiver);    }   ]) :|: public void testAnr() throws Exception {
        // Remove old records to avoid interference with the test.
        clearHistoricalExitInfo();

        final DropBoxManager dbox = mContext.getSystemService(DropBoxManager.class);
        final CountDownLatch dboxLatch = new CountDownLatch(1);
        final BroadcastReceiver receiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                final String tag_anr = ""data_app_anr"";
                if (tag_anr.equals(intent.getStringExtra(DropBoxManager.EXTRA_TAG))) {
                    mAnrEntry = dbox.getNextEntry(tag_anr, intent.getLongExtra(
                            DropBoxManager.EXTRA_TIME, 0) - 1);
                    dboxLatch.countDown();
                }
            }
        };
        mContext.registerReceiver(receiver,
                new IntentFilter(DropBoxManager.ACTION_DROPBOX_ENTRY_ADDED));
        final long timeout = Settings.Global.getInt(mContext.getContentResolver(),
                Settings.Global.BROADCAST_FG_CONSTANTS, 10 * 1000) * 3;

        long now = System.currentTimeMillis();

        // Start a process and block its main thread
        startService(ACTION_ANR, STUB_SERVICE_NAME, false, false);

        // Sleep for a while to make sure it's already blocking its main thread.
        sleep(WAITFOR_MSEC);

        AmMonitor monitor = new AmMonitor(mInstrumentation,
                new String[]{AmMonitor.WAIT_FOR_CRASHED});

        Intent intent = new Intent();
        intent.setComponent(new ComponentName(STUB_PACKAGE_NAME, STUB_RECEIVER_NAMWE));
        intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
        // This will result an ANR
        mContext.sendOrderedBroadcast(intent, null);

        // Wait for the early ANR
        monitor.waitFor(AmMonitor.WAIT_FOR_EARLY_ANR, timeout);
        // Continue, so we could collect ANR traces
        monitor.sendCommand(AmMonitor.CMD_CONTINUE);
        // Wait for th"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/AppExitTest/src/android/app/cts/ActivityManagerAppExitInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerAppExitInfoTest"	"testPermissionChange"	"CtsAppExitTestCases"	"1: permission"	"([11:/android/app/cts/ActivityManagerAppExitInfoTest.java]:[permission]:[11]:method_text:[ew StringBuilder()));    }    // A clone of testPermissionChange using a different revoke api   ]) :|: public void testPermissionChange() throws Exception {
        // Remove old records to avoid interference with the test.
        clearHistoricalExitInfo();

        // Grant the read calendar permission
        mInstrumentation.getUiAutomation().grantRuntimePermission(
                STUB_PACKAGE_NAME, android.Manifest.permission.READ_CALENDAR);
        long now = System.currentTimeMillis();

        // Start a process and do nothing
        startService(ACTION_FINISH, STUB_SERVICE_NAME, false, false);

        // Enable high frequency memory sampling
        executeShellCmd(""dumpsys procstats --start-testing"");
        // Sleep for a while to wait for the sampling of memory info
        sleep(10000);
        // Stop the high frequency memory sampling
        executeShellCmd(""dumpsys procstats --stop-testing"");
        // Get the memory info from it.
        String dump = executeShellCmd(""dumpsys activity processes "" + STUB_PACKAGE_NAME);
        assertNotNull(dump);
        final String lastPss = extractMemString(dump, "" lastPss="", ' ');
        final String lastRss = extractMemString(dump, "" lastRss="", '\n');

        // Revoke the read calendar permission
        mInstrumentation.getUiAutomation().revokeRuntimePermission(
                STUB_PACKAGE_NAME, android.Manifest.permission.READ_CALENDAR);
        waitForGone(mWatcher);
        long now2 = System.currentTimeMillis();

        List<ApplicationExitInfo> list = ShellIdentityUtils.invokeMethodWithShellPermissions(
                STUB_PACKAGE_NAME, mStubPackagePid, 1,
                mActivityManager::getHistoricalProcessExitReasons,
                android.Manifest.permission.DUMP);

        assertTrue(list != null && list.size() == 1);

        ApplicationExitInfo info = list.get(0);
        verify(info, mStubPackagePid, mStubPackageUid, STUB_PACKAGE_NAME,
                ApplicationExitInfo.REASON_PERMISSION_CHANGE, null, null, now, now2);

        // Also verify that we get the expected meminfo"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/AppExitTest/src/android/app/cts/ActivityManagerAppExitInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerAppExitInfoTest"	"testPermissionChangeWithReason"	"CtsAppExitTestCases"	"1: permission"	"([11:/android/app/cts/ActivityManagerAppExitInfoTest.java]:[permission]:[11]:method_text:[ebugUtils.sizeValueToString(                info.getRss() * 1024, new StringBuilder()));    }   ]) :|: public void testPermissionChangeWithReason() throws Exception {
        String revokeReason = ""test reason"";
        // Remove old records to avoid interference with the test.
        clearHistoricalExitInfo();

        // Grant the read calendar permission
        mInstrumentation.getUiAutomation().grantRuntimePermission(
                STUB_PACKAGE_NAME, android.Manifest.permission.READ_CALENDAR);
        long now = System.currentTimeMillis();

        // Start a process and do nothing
        startService(ACTION_FINISH, STUB_SERVICE_NAME, false, false);

        // Enable high frequency memory sampling
        executeShellCmd(""dumpsys procstats --start-testing"");
        // Sleep for a while to wait for the sampling of memory info
        sleep(10000);
        // Stop the high frequency memory sampling
        executeShellCmd(""dumpsys procstats --stop-testing"");
        // Get the memory info from it.
        String dump = executeShellCmd(""dumpsys activity processes "" + STUB_PACKAGE_NAME);
        assertNotNull(dump);
        final String lastPss = extractMemString(dump, "" lastPss="", ' ');
        final String lastRss = extractMemString(dump, "" lastRss="", '\n');

        // Revoke the read calendar permission
        runWithShellPermissionIdentity(() -> {
            mContext.getPackageManager().revokeRuntimePermission(STUB_PACKAGE_NAME,
                    android.Manifest.permission.READ_CALENDAR, Process.myUserHandle(),
                    revokeReason);
        });
        waitForGone(mWatcher);
        long now2 = System.currentTimeMillis();

        List<ApplicationExitInfo> list = ShellIdentityUtils.invokeMethodWithShellPermissions(
                STUB_PACKAGE_NAME, mStubPackagePid, 1,
                mActivityManager::getHistoricalProcessExitReasons,
                android.Manifest.permission.DUMP);

        assertTrue(list != null && list.size() == 1);

        ApplicationExitInfo info = list.get(0);
        verify(info, mStubPackagePid, mStubPackageU"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/AppExitTest/src/android/app/cts/ActivityManagerAppExitInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerAppExitInfoTest"	"testCrash"	"CtsAppExitTestCases"	"1: permission"	"([2:/android/app/cts/ActivityManagerAppExitInfoTest.java]:[permission]:[2]:method_text:[B_PACKAGE_NAME,                ApplicationExitInfo.REASON_CRASH, null, null, now, now2);    }   ]) :|: public void testCrash() throws Exception {
        // Remove old records to avoid interference with the test.
        clearHistoricalExitInfo();

        long now = System.currentTimeMillis();

        // Start a process and do nothing
        startService(ACTION_NONE, STUB_SERVICE_NAME, false, false);

        // Induce a crash
        executeShellCmd(""am crash "" + STUB_PACKAGE_NAME);
        waitForGone(mWatcher);
        long now2 = System.currentTimeMillis();

        List<ApplicationExitInfo> list = ShellIdentityUtils.invokeMethodWithShellPermissions(
                STUB_PACKAGE_NAME, mStubPackagePid, 1,
                mActivityManager::getHistoricalProcessExitReasons,
                android.Manifest.permission.DUMP);

        assertTrue(list != null && list.size() == 1);
        verify(list.get(0), mStubPackagePid, mStubPackageUid, STUB_PACKAGE_NAME,
                ApplicationExitInfo.REASON_CRASH, null, null, now, now2);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/AppExitTest/src/android/app/cts/ActivityManagerAppExitInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerAppExitInfoTest"	"testNativeCrash"	"CtsAppExitTestCases"	"1: permission"	"([4:/android/app/cts/ActivityManagerAppExitInfoTest.java]:[permission]:[4]:method_text:[ = Tombstone.parseFrom(trace);        assertEquals(tombstone.getPid(), mStubPackagePid);    }   ]) :|: public void testNativeCrash() throws Exception {
        // Remove old records to avoid interference with the test.
        clearHistoricalExitInfo();

        long now = System.currentTimeMillis();

        // Start a process and crash it
        startService(ACTION_NATIVE_CRASH, STUB_SERVICE_NAME, true, false);

        // Native crashes are handled asynchronously from the actual crash, so
        // it's possible for us to notice that the process crashed before an
        // actual tombstone exists.
        Thread.sleep(1000);

        long now2 = System.currentTimeMillis();
        List<ApplicationExitInfo> list = ShellIdentityUtils.invokeMethodWithShellPermissions(
                STUB_PACKAGE_NAME, mStubPackagePid, 1,
                mActivityManager::getHistoricalProcessExitReasons,
                android.Manifest.permission.DUMP);

        assertTrue(list != null && list.size() == 1);
        verify(list.get(0), mStubPackagePid, mStubPackageUid, STUB_PACKAGE_NAME,
                ApplicationExitInfo.REASON_CRASH_NATIVE, null, null, now, now2);

        InputStream trace = ShellIdentityUtils.invokeMethodWithShellPermissions(
                list.get(0),
                (i) -> {
                    try {
                        return i.getTraceInputStream();
                    } catch (IOException ex) {
                        return null;
                    }
                },
                android.Manifest.permission.DUMP);

        assertNotNull(trace);
        Tombstone tombstone = Tombstone.parseFrom(trace);
        assertEquals(tombstone.getPid(), mStubPackagePid);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/AppExitTest/src/android/app/cts/ActivityManagerAppExitInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerAppExitInfoTest"	"testUserRequested"	"CtsAppExitTestCases"	"1: permission"	"([2:/android/app/cts/ActivityManagerAppExitInfoTest.java]:[permission]:[2]:method_text:[_NAME,                ApplicationExitInfo.REASON_USER_REQUESTED, null, null, now, now2);    }   ]) :|: public void testUserRequested() throws Exception {
        // Remove old records to avoid interference with the test.
        clearHistoricalExitInfo();

        long now = System.currentTimeMillis();

        // Start a process and do nothing
        startService(ACTION_NONE, STUB_SERVICE_NAME, false, false);

        // Force stop the test package
        executeShellCmd(""am force-stop "" + STUB_PACKAGE_NAME);

        // Wait the process gone
        waitForGone(mWatcher);

        long now2 = System.currentTimeMillis();
        List<ApplicationExitInfo> list = ShellIdentityUtils.invokeMethodWithShellPermissions(
                STUB_PACKAGE_NAME, mStubPackagePid, 1,
                mActivityManager::getHistoricalProcessExitReasons,
                android.Manifest.permission.DUMP);

        assertTrue(list != null && list.size() == 1);
        verify(list.get(0), mStubPackagePid, mStubPackageUid, STUB_PACKAGE_NAME,
                ApplicationExitInfo.REASON_USER_REQUESTED, null, null, now, now2);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/AppExitTest/src/android/app/cts/ActivityManagerAppExitInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerAppExitInfoTest"	"testDependencyDied"	"CtsAppExitTestCases"	"1: permission"	"([4:/android/app/cts/ActivityManagerAppExitInfoTest.java]:[permission]:[4]:method_text:[NAME,                ApplicationExitInfo.REASON_DEPENDENCY_DIED, null, null, now, now2);    }   ]) :|: public void testDependencyDied() throws Exception {
        // Remove old records to avoid interference with the test.
        clearHistoricalExitInfo();

        // Start a process and acquire the provider
        startService(ACTION_ACQUIRE_STABLE_PROVIDER, STUB_SERVICE_NAME, false, false);

        final ActivityManager am = mContext.getSystemService(ActivityManager.class);
        long now = System.currentTimeMillis();
        final long timeout = now + WAITFOR_MSEC;
        int providerPid = -1;
        while (now < timeout && providerPid < 0) {
            sleep(1000);
            List<RunningAppProcessInfo> list = ShellIdentityUtils.invokeMethodWithShellPermissions(
                    am, (m) -> m.getRunningAppProcesses(),
                    android.Manifest.permission.REAL_GET_TASKS);
            for (RunningAppProcessInfo info: list) {
                if (info.processName.equals(STUB_REMOTE_ROCESS_NAME)) {
                    providerPid = info.pid;
                    break;
                }
            }
            now = System.currentTimeMillis();
        }
        assertTrue(providerPid > 0);

        now = System.currentTimeMillis();
        // Now let the provider exit itself
        startService(ACTION_KILL_PROVIDER, STUB_SERVICE_NAME, false, false, false, false, null);

        // Wait for both of the processes gone
        waitForGone(mWatcher);
        final long now2 = System.currentTimeMillis();

        List<ApplicationExitInfo> list = ShellIdentityUtils.invokeMethodWithShellPermissions(
                STUB_PACKAGE_NAME, mStubPackagePid, 1,
                mActivityManager::getHistoricalProcessExitReasons,
                android.Manifest.permission.DUMP);

        assertTrue(list != null && list.size() == 1);
        verify(list.get(0), mStubPackagePid, mStubPackageUid, STUB_PACKAGE_NAME,
                ApplicationExitInfo.REASON_DEPENDENCY_DIED, null, null, now, now2);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/AppExitTest/src/android/app/cts/ActivityManagerAppExitInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerAppExitInfoTest"	"testMultipleProcess"	"CtsAppExitTestCases"	"1: permission"	"([4:/android/app/cts/ActivityManagerAppExitInfoTest.java]:[permission]:[4]:method_text:[ = 0;            mOtherUserHandle = null;            mOtherUidWatcher = null;        }    }   ]) :|: public void testMultipleProcess() throws Exception {
        // Remove old records to avoid interference with the test.
        clearHistoricalExitInfo();

        long now = System.currentTimeMillis();

        // Start a process and kill itself
        startService(ACTION_KILL, STUB_SERVICE_NAME, true, false);

        long now2 = System.currentTimeMillis();

        // Start a remote process and exit
        startService(ACTION_EXIT, STUB_SERVICE_REMOTE_NAME, true, false);

        long now3 = System.currentTimeMillis();
        // Now to get the two reports
        List<ApplicationExitInfo> list = ShellIdentityUtils.invokeMethodWithShellPermissions(
                STUB_PACKAGE_NAME, 0, 2,
                mActivityManager::getHistoricalProcessExitReasons,
                android.Manifest.permission.DUMP);

        assertTrue(list != null && list.size() == 2);
        verify(list.get(0), mStubPackageRemotePid, mStubPackageUid, STUB_REMOTE_ROCESS_NAME,
                ApplicationExitInfo.REASON_EXIT_SELF, EXIT_CODE, null, now2, now3);
        verify(list.get(1), mStubPackagePid, mStubPackageUid, STUB_ROCESS_NAME,
                ApplicationExitInfo.REASON_SIGNALED, OsConstants.SIGKILL, null, now, now2);

        // If we only retrieve one report
        list = ShellIdentityUtils.invokeMethodWithShellPermissions(
                STUB_PACKAGE_NAME, 0, 1,
                mActivityManager::getHistoricalProcessExitReasons,
                android.Manifest.permission.DUMP);

        assertTrue(list != null && list.size() == 1);
        verify(list.get(0), mStubPackageRemotePid, mStubPackageUid, STUB_REMOTE_ROCESS_NAME,
                ApplicationExitInfo.REASON_EXIT_SELF, EXIT_CODE, null, now2, now3);
    }

    private RunningServiceInfo identifyService(Messenger service) throws Exception {
        final CountDownLatch latch = new CountDownLatch(1);
        class IdentifyHandler extends Handler {
            IdentifyHandler() {
                super(Looper.getMainLoope"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/AppExitTest/src/android/app/cts/ActivityManagerAppExitInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerAppExitInfoTest"	"testSecondaryUser"	"CtsAppExitTestCases"	"1: permission"	"([35:/android/app/cts/ActivityManagerAppExitInfoTest.java]:[permission]:[35]:method_text:[info.getProcessStateSummary(), cookie,                cookie == null ? 0 : cookie.length));    }}]) :|: public void testSecondaryUser() throws Exception {
        if (!mSupportMultipleUsers) {
            return;
        }

        // Remove old records to avoid interference with the test.
        clearHistoricalExitInfo();

        // Get the full user permission in order to start service as other user
        mInstrumentation.getUiAutomation().adoptShellPermissionIdentity(
                android.Manifest.permission.INTERACT_ACROSS_USERS,
                android.Manifest.permission.INTERACT_ACROSS_USERS_FULL);

        // Create the test user, we'll remove it during tearDown
        prepareTestUser();

        final byte[] cookie0 = {(byte) 0x00, (byte) 0x01, (byte) 0x02, (byte) 0x03,
                (byte) 0x04, (byte) 0x05, (byte) 0x06, (byte) 0x07};
        final byte[] cookie1 = {(byte) 0x01, (byte) 0x02, (byte) 0x03, (byte) 0x04,
                (byte) 0x05, (byte) 0x06, (byte) 0x07, (byte) 0x08};
        final byte[] cookie2 = {(byte) 0x02, (byte) 0x03, (byte) 0x04, (byte) 0x05,
                (byte) 0x06, (byte) 0x07, (byte) 0x08, (byte) 0x01};
        final byte[] cookie3 = {(byte) 0x03, (byte) 0x04, (byte) 0x05, (byte) 0x06,
                (byte) 0x07, (byte) 0x08, (byte) 0x01, (byte) 0x02};
        final byte[] cookie4 = {(byte) 0x04, (byte) 0x05, (byte) 0x06, (byte) 0x07,
                (byte) 0x08, (byte) 0x01, (byte) 0x02, (byte) 0x03};
        final byte[] cookie5 = null;

        long now = System.currentTimeMillis();

        // Start a process and do nothing
        startService(ACTION_NONE, STUB_SERVICE_NAME, false, true, false, true, cookie0);
        // request to exit by itself with a different cookie
        startService(ACTION_EXIT, STUB_SERVICE_NAME, true, false, false, true, cookie1);

        long now2 = System.currentTimeMillis();

        // Start the process in a secondary user and kill itself
        startService(ACTION_KILL, STUB_SERVICE_NAME, true, true, true, true, cookie2);

        long now3 = System.currentTimeMillis();"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/AppExitTest/src/android/app/cts/ActivityManagerAppExitInfoTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.CloseSystemDialogsTest"	"testCloseSystemDialogs_whenRunningAsShell_isSent"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/CloseSystemDialogsTest.java]:[permission]:[1]:method_text:[ntent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS)));        assertCloseSystemDialogsReceived();    }   ]) :|: 
    public void testCloseSystemDialogs_whenRunningAsShell_isSent() throws Exception {
        SystemUtil.runWithShellPermissionIdentity(
                () -> mContext.sendBroadcast(new Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS)));

        assertCloseSystemDialogsReceived();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/CloseSystemDialogsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.CloseSystemDialogsTest"	"testCloseSystemDialogsViaWindowManager_whenRunningAsShell_isSent"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/CloseSystemDialogsTest.java]:[permission]:[1]:method_text:[ assertThat(mFakeView.getNextCloseSystemDialogsCallReason(TIMEOUT_MS)).isEqualTo(REASON);    }   ]) :|: 
    public void testCloseSystemDialogsViaWindowManager_whenRunningAsShell_isSent()
            throws Exception {
        mService = getService(APP_SELF);

        SystemUtil.runWithShellPermissionIdentity(
                () -> mService.closeSystemDialogsViaWindowManager(REASON));

        assertThat(mFakeView.getNextCloseSystemDialogsCallReason(TIMEOUT_MS)).isEqualTo(REASON);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/CloseSystemDialogsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.CloseSystemDialogsTest"	"testCloseSystemDialogsViaActivityManager_whenRunningAsShell_isSent"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/CloseSystemDialogsTest.java]:[permission]:[1]:method_text:[ogsCallReason(TIMEOUT_MS)).isEqualTo(REASON);        assertCloseSystemDialogsReceived();    }   ]) :|: 
    public void testCloseSystemDialogsViaActivityManager_whenRunningAsShell_isSent()
            throws Exception {
        mService = getService(APP_SELF);

        SystemUtil.runWithShellPermissionIdentity(
                () -> mService.closeSystemDialogsViaActivityManager(REASON));

        assertThat(mFakeView.getNextCloseSystemDialogsCallReason(TIMEOUT_MS)).isEqualTo(REASON);
        assertCloseSystemDialogsReceived();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/CloseSystemDialogsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.CloseSystemDialogsTest"	"testCloseSystemDialogsViaActivityManager_whenTargetSdk30_isBlockedButDoesNotThrow"	"CtsAppTestCases"	"1: permission"	"([2:/android/app/cts/CloseSystemDialogsTest.java]:[permission]:[2]:method_text:[ult(int resultCode, Bundle resultData) {            mFuture.complete(resultCode);        }    }}]) :|: 
    public void testCloseSystemDialogsViaActivityManager_whenTargetSdk30_isBlockedButDoesNotThrow()
            throws Exception {
        mService = getService(APP_HELPER);

        mService.closeSystemDialogsViaActivityManager(REASON);

        assertThat(mFakeView.getNextCloseSystemDialogsCallReason(TIMEOUT_MS)).isEqualTo(null);
        assertCloseSystemDialogsNotReceived();
    }

    private void setTargetCurrent() {
        // The helper app has targetSdk=30, opting-in to changes emulates targeting latest sdk.
        compat(APP_COMPAT_ENABLE, ActivityManager.LOCK_DOWN_CLOSE_SYSTEM_DIALOGS, APP_HELPER);
        compat(APP_COMPAT_ENABLE, ""NOTIFICATION_TRAMPOLINE_BLOCK"", APP_HELPER);
    }

    private void assertCloseSystemDialogsNotReceived() {
        // If both broadcasts are sent, they will be received in order here since they are both
        // registered receivers in the ""bg"" queue in system_server and belong to the same app.
        // This is guaranteed by a series of handlers that are the same in both cases and due to the
        // fact that the binder that system_server uses to call into the app is the same (since the
        // app is the same) and one-way calls on the same binder object are ordered.
        mSentinelReceived = new ConditionVariable(false);
        Intent intent = new Intent(ACTION_SENTINEL);
        intent.setPackage(mContext.getPackageName());
        mContext.sendBroadcast(intent);
        mSentinelReceived.block();
        assertThat(mCloseSystemDialogsReceived.isDone()).isFalse();
    }

    private void assertCloseSystemDialogsReceived() throws Exception {
        mCloseSystemDialogsReceived.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
        // No TimeoutException thrown
    }

    private ICloseSystemDialogsTestsService getService(String packageName) throws Exception {
        ICloseSystemDialogsTestsService service =
                ICloseSystemDialogsTestsService.Stub.asInterface(
                        connect(packageName)"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/CloseSystemDialogsTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ServiceTest"	"uptimeMillis"	"CtsAppTestCases"	"1: permission"	"([5:/android/app/cts/ServiceTest.java]:[permission]:[5]:method_text:[               return super.onTransact(code, data, reply, flags);            }        }    }   ]) :|: public void test/*
 *.
 */

package android.app.cts;

import static android.app.stubs.LocalForegroundService.COMMAND_START_FOREGROUND;
import static android.app.stubs.LocalForegroundService.COMMAND_START_FOREGROUND_DEFER_NOTIFICATION;
import static android.app.stubs.LocalForegroundService.COMMAND_STOP_FOREGROUND_DETACH_NOTIFICATION;
import static android.app.stubs.LocalForegroundService.COMMAND_STOP_FOREGROUND_DONT_REMOVE_NOTIFICATION;

import android.app.Activity;
import android.app.ActivityManager;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.stubs.ActivityTestsBase;
import android.app.stubs.IsolatedService;
import android.app.stubs.LaunchpadActivity;
import android.app.stubs.LocalDeniedService;
import android.app.stubs.LocalForegroundService;
import android.app.stubs.LocalGrantedService;
import android.app.stubs.LocalPhoneCallService;
import android.app.stubs.LocalService;
import android.app.stubs.LocalStoppedService;
import android.app.stubs.NullService;
import android.app.stubs.R;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.Binder;
import android.os.Bundle;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.IBinder;
import android.os.Parcel;
import android.os.ParcelFileDescriptor;
import android.os.Process;
import android.os.RemoteException;
import android.os.SystemClock;
import android.os.UserHandle;
import android.service.notification.StatusBarNotification;
import android.test.suitebuilder.annotation.MediumTest;
import android.util.Log;
import android.util.SparseArray;

import androidx.test.InstrumentationRegistry;
import androidx.test.filters.FlakyTest;

import com.android.compatibility.common.util.IBinderParcelable;
import com.android.compatibility.common.util.SystemUtil;
import com.android.server"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ServiceTest"	"testLocalStartClassPermissions"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/ServiceTest.java]:[permission]:[1]:method_text:[lt(mLocalGrantedService);        startExpectResult(mLocalDeniedService);    }    @MediumTest   ]) :|: public void testLocalStartClassPermissions() throws Exception {
        startExpectResult(mLocalGrantedService);
        startExpectResult(mLocalDeniedService);
    }

    @MediumTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ServiceTest"	"testLocalStartActionPermissions"	"CtsAppTestCases"	"1: permission"	"([3:/android/app/cts/ServiceTest.java]:[permission]:[3]:method_text:[       startExpectResult(mLocalService_ApplicationDoesNotHavePermission);    }    @MediumTest   ]) :|: public void testLocalStartActionPermissions() throws Exception {
        startExpectResult(mLocalService_ApplicationHasPermission);
        startExpectResult(mLocalService_ApplicationDoesNotHavePermission);
    }

    @MediumTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ServiceTest"	"testLocalBindClassPermissions"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/ServiceTest.java]:[permission]:[1]:method_text:[ult(mLocalGrantedService);        bindExpectResult(mLocalDeniedService);    }    @MediumTest   ]) :|: public void testLocalBindClassPermissions() throws Exception {
        bindExpectResult(mLocalGrantedService);
        bindExpectResult(mLocalDeniedService);
    }

    @MediumTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ServiceTest"	"testLocalBindActionPermissions"	"CtsAppTestCases"	"1: permission"	"([3:/android/app/cts/ServiceTest.java]:[permission]:[3]:method_text:[        bindExpectResult(mLocalService_ApplicationDoesNotHavePermission);    }    @MediumTest   ]) :|: public void testLocalBindActionPermissions() throws Exception {
        bindExpectResult(mLocalService_ApplicationHasPermission);
        bindExpectResult(mLocalService_ApplicationDoesNotHavePermission);
    }

    @MediumTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ServiceTest"	"testLocalBindAutoClassPermissionGranted"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/ServiceTest.java]:[permission]:[1]:method_text:[() throws Exception {        bindAutoExpectResult(mLocalGrantedService);    }    @MediumTest   ]) :|: public void testLocalBindAutoClassPermissionGranted() throws Exception {
        bindAutoExpectResult(mLocalGrantedService);
    }

    @MediumTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ServiceTest"	"testLocalBindAutoActionPermissionGranted"	"CtsAppTestCases"	"1: permission"	"([2:/android/app/cts/ServiceTest.java]:[permission]:[2]:method_text:[n {        bindAutoExpectResult(mLocalService_ApplicationHasPermission);    }    @MediumTest   ]) :|: public void testLocalBindAutoActionPermissionGranted() throws Exception {
        bindAutoExpectResult(mLocalService_ApplicationHasPermission);
    }

    @MediumTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ServiceTest"	"testLocalUnbindTwice"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/ServiceTest.java]:[permission]:[1]:method_text:[ } catch (IllegalArgumentException e) {            // expected        }    }    @MediumTest   ]) :|: public void testLocalUnbindTwice() throws Exception {
        EmptyConnection conn = new EmptyConnection();
        mContext.bindService(
                mLocalService_ApplicationHasPermission, conn, 0);
        mContext.unbindService(conn);
        try {
            mContext.unbindService(conn);
            fail(""No exception thrown on the second unbind"");
        } catch (IllegalArgumentException e) {
            // expected
        }
    }

    @MediumTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ServiceTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testFgsLocationStartFromBG"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/ActivityManagerFgsBgStartTest.java]:[permission]:[1]:method_text:[tate, it can start FGSL in APP2, FGSL gets location capability.     * @throws Exception     */   ]) :|: 
    public void testFgsLocationStartFromBG() throws Exception {
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAITFOR_MSEC);

        try {
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGSL_RESULT);
            // APP1 is in BG state, Start FGSL in APP1, it won't get location capability.
            Bundle bundle = new Bundle();
            bundle.putInt(LocalForegroundServiceLocation.EXTRA_FOREGROUND_SERVICE_TYPE,
                    ServiceInfo.FOREGROUND_SERVICE_TYPE_LOCATION);
            // start FGSL.
            enableFgsRestriction(false, true, null);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE_LOCATION,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, bundle);
            // APP1 is in FGS state, but won't get location capability.
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE,
                    WatchUidRunner.STATE_FG_SERVICE,
                    new Integer(PROCESS_CAPABILITY_NETWORK));
            waiter.doWait(WAITFOR_MSEC);
            // stop FGSL
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE_LOCATION,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE,
                    WatchUidRunner.STATE_CACHED_EMPTY,
                    new Integer(PROCESS_CAPABILITY_NONE));

            waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            // APP1 is in FGS state,
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOR"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testFgsStartFromBGWithBindWithRestriction"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/ActivityManagerFgsBgStartTest.java]:[permission]:[1]:method_text:[* pass BG-Activity-launch ability to APP2, then APP2 can start APP2 FGS from background.     */   ]) :|: 
    public void testFgsStartFromBGWithBindWithRestriction() throws Exception {
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAITFOR_MSEC);

        try {
            enableFgsRestriction(true, true, null);
            // APP1 is in BG state, bind FGSL in APP1 first.
            CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_BIND_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            // Then start FGS in APP1
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            // APP1 does not enter FGS state
            try {
                waiter.doWait(WAITFOR_MSEC);
                fail(""Service should not enter foreground service state"");
            } catch (Exception e) {
            }

            // stop FGS
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            // unbind service.
            CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_UNBIND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY);
        } finally {
            uid1Watcher.finish();
        }
    }

    /**
     * Test BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS flag.
     * Shell has START_ACTIVITIES_FROM_BACKGROUND permission, it can use this bind flag to
     * pass BG-Activity-launch ability to APP2, t"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testFgsBindingFlagActivity"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/ActivityManagerFgsBgStartTest.java]:[permission]:[1]:method_text:[     * pass BG-FGS-launch ability to APP2, then APP2 can start APP3 FGS from background.     */   ]) :|: 
    public void testFgsBindingFlagActivity() throws Exception {
        testFgsBindingFlag(Context.BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS);
    }

    /**
     * Test BIND_ALLOW_FOREGROUND_SERVICE_STARTS_FROM_BACKGROUND flag.
     * Shell has START_FOREGROUND_SERVICES_FROM_BACKGROUND permission, it can use this bind flag to
     * pass BG-FGS-launch ability to APP2, then APP2 can start APP3 FGS from background.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testFgsBindingFlagFGS"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/ActivityManagerFgsBgStartTest.java]:[permission]:[1]:method_text:[ passed to APP2 by service binding, then APP2 can start     * APP3 FGS from background.     */   ]) :|: 
    public void testFgsBindingFlagFGS() throws Exception {
        testFgsBindingFlag(Context.BIND_ALLOW_FOREGROUND_SERVICE_STARTS_FROM_BACKGROUND);
    }

    /**
     * Test no binding flag.
     * Shell has START_FOREGROUND_SERVICES_FROM_BACKGROUND permission, without any bind flag,
     * the BG-FGS-launch ability can be passed to APP2 by service binding, then APP2 can start
     * APP3 FGS from background.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testFgsBindingFlagNone"	"CtsAppTestCases"	"1: permission"	"([5:/android/app/cts/ActivityManagerFgsBgStartTest.java]:[permission]:[5]:method_text:[  /**     * Test a FGS can start from BG if the app has SYSTEM_ALERT_WINDOW permission.     */   ]) :|: 
    public void testFgsBindingFlagNone() throws Exception {
        testFgsBindingFlag(0);
    }

    private void testFgsBindingFlag(int bindingFlag) throws Exception {
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        ApplicationInfo app2Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP2, 0);
        ApplicationInfo app3Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP3, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAITFOR_MSEC);
        WatchUidRunner uid2Watcher = new WatchUidRunner(mInstrumentation, app2Info.uid,
                WAITFOR_MSEC);
        WatchUidRunner uid3Watcher = new WatchUidRunner(mInstrumentation, app3Info.uid,
                WAITFOR_MSEC);
        try {
            // Enable the FGS background startForeground() restriction.
            enableFgsRestriction(true, true, null);

            // testapp is in background.
            // testapp binds to service in APP2, APP2 still in background state.
            final Intent intent = new Intent().setClassName(
                    PACKAGE_NAME_APP2, ""android.app.stubs.LocalService"");

            /*
            final ServiceConnection connection = new ServiceConnection() {
                @Override
                public void onServiceConnected(ComponentName name, IBinder service) {
                }
                @Override
                public void onServiceDisconnected(ComponentName name) {
                }
            };
            runWithShellPermissionIdentity(() -> {
                mTargetContext.bindService(intent, connection,
                        Context.BIND_AUTO_CREATE | Context.BIND_WAIVE_PRIORITY);
            });

            // APP2 can not start FGS in APP3.
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testFgsStartSystemAlertWindow"	"CtsAppTestCases"	"1: permission"	"([3:/android/app/cts/ActivityManagerFgsBgStartTest.java]:[permission]:[3]:method_text:[    }    /**     * Test a FGS can start from BG if the device is in retail demo mode.     */   ]) :|: 
    public void testFgsStartSystemAlertWindow() throws Exception {
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAITFOR_MSEC);
        try {
            // Enable the FGS background startForeground() restriction.
            enableFgsRestriction(true, true, null);
            // Start FGS in BG state.
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            // APP1 does not enter FGS state
            try {
                waiter.doWait(WAITFOR_MSEC);
                fail(""Service should not enter foreground service state"");
            } catch (Exception e) {
            }

            PermissionUtils.grantPermission(
                    PACKAGE_NAME_APP1, android.Manifest.permission.SYSTEM_ALERT_WINDOW);
            waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            // Now it can start FGS.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE);
            waiter.doWait(WAITFOR_MSEC);
            // Stop the FGS.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY);"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testFgsStartRetailDemoMode"	"CtsAppTestCases"	"1: permission"	"([3:/android/app/cts/ActivityManagerFgsBgStartTest.java]:[permission]:[3]:method_text:[t S, the    // framework throws a ForegroundServiceStartNotAllowedException with error message.   ]) :|: 
    // Change Settings.Global.DEVICE_DEMO_MODE on device may trigger other listener and put
    // the device in undesired state, for example, the battery charge level is set to 35%
    // permanently, ignore this test for now.
    @Ignore
    public void testFgsStartRetailDemoMode() throws Exception {
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAITFOR_MSEC);
        runWithShellPermissionIdentity(()-> {
            mOrigDeviceDemoMode = Settings.Global.getInt(mContext.getContentResolver(),
                    Settings.Global.DEVICE_DEMO_MODE, 0); });

        try {
            // Enable the FGS background startForeground() restriction.
            enableFgsRestriction(true, true, null);
            // Start FGS in BG state.
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            // APP1 does not enter FGS state
            try {
                waiter.doWait(WAITFOR_MSEC);
                fail(""Service should not enter foreground service state"");
            } catch (Exception e) {
            }

            runWithShellPermissionIdentity(()-> {
                Settings.Global.putInt(mContext.getContentResolver(),
                        Settings.Global.DEVICE_DEMO_MODE, 1); });
            waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            // Now it can start FGS.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testTempAllowListType"	"CtsAppTestCases"	"1: permission"	"([3:/android/app/cts/ActivityManagerFgsBgStartTest.java]:[permission]:[3]:method_text:[t a FGS can start from BG if the process had a visible activity recently.     */    @LargeTest   ]) :|: 
    public void testTempAllowListType() throws Exception {
        testTempAllowListTypeInternal(TEMPORARY_ALLOW_LIST_TYPE_FOREGROUND_SERVICE_NOT_ALLOWED);
        testTempAllowListTypeInternal(TEMPORARY_ALLOW_LIST_TYPE_FOREGROUND_SERVICE_ALLOWED);
    }

    private void testTempAllowListTypeInternal(int type) throws Exception {
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        ApplicationInfo app2Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP2, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAITFOR_MSEC);
        WatchUidRunner uid2Watcher = new WatchUidRunner(mInstrumentation, app2Info.uid,
                WAITFOR_MSEC);
        try {
            // Enable the FGS background startForeground() restriction.
            enableFgsRestriction(true, true, null);
            // Start FGS in BG state.
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP2, 0, null);
            // APP1 does not enter FGS state
            try {
                waiter.doWait(WAITFOR_MSEC);
                fail(""Service should not enter foreground service state"");
            } catch (Exception e) {
            }

            // Now it can start FGS.
            waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            runWithShellPermissionIdentity(()-> {
                final BroadcastOptions options = BroadcastOptions.makeBasic();
                // setTemporaryAppAllowlist API requires
                // START_FOREGROUND_SERVICES_FROM_BACKGROUND permission."	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testVisibleActivityGracePeriod"	"CtsAppTestCases"	"1: permission"	"([2:/android/app/cts/ActivityManagerFgsBgStartTest.java]:[permission]:[2]:method_text:[ depends on the service's app proc state.     * Test starService() -> startForeground()     */   ]) :|: 
    public void testVisibleActivityGracePeriod() throws Exception {
        ApplicationInfo app2Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP2, 0);
        WatchUidRunner uid2Watcher = new WatchUidRunner(mInstrumentation, app2Info.uid,
                WAITFOR_MSEC);
        final String namespaceActivityManager = ""activity_manager"";
        final String keyFgToBgFgsGraceDuration = ""fg_to_bg_fgs_grace_duration"";
        final long[] curFgToBgFgsGraceDuration = {-1};
        try {
            // Enable the FGS background startForeground() restriction.
            enableFgsRestriction(true, true, null);
            // Allow bg actvity start from APP1.
            allowBgActivityStart(PACKAGE_NAME_APP1, true);

            SystemUtil.runWithShellPermissionIdentity(() -> {
                curFgToBgFgsGraceDuration[0] = DeviceConfig.getInt(
                        namespaceActivityManager,
                        keyFgToBgFgsGraceDuration, -1);
                DeviceConfig.setProperty(namespaceActivityManager,
                        keyFgToBgFgsGraceDuration,
                        Long.toString(WAITFOR_MSEC), false);
            });

            testVisibleActivityGracePeriodInternal(uid2Watcher, ""KEYCODE_HOME"");
            testVisibleActivityGracePeriodInternal(uid2Watcher, ""KEYCODE_BACK"");
        } finally {
            uid2Watcher.finish();
            // Remove package from AllowList.
            allowBgActivityStart(PACKAGE_NAME_APP1, false);
            if (curFgToBgFgsGraceDuration[0] >= 0) {
                SystemUtil.runWithShellPermissionIdentity(() -> {
                    DeviceConfig.setProperty(namespaceActivityManager,
                            keyFgToBgFgsGraceDuration,
                            Long.toString(curFgToBgFgsGraceDuration[0]), false);
                });
            } else {
                CtsAppTestUtils.executeShellCmd(mInstrumentation,
                        ""device_config delete "" + na"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testPushMessagingOverQuota"	"CtsAppTestCases"	"1: permission"	"([2:/android/app/cts/ActivityManagerFgsBgStartTest.java]:[permission]:[2]:method_text:[     * All other reason codes, DeviceIdleController does not change temp allowlist type.     */   ]) :|: 
    public void testPushMessagingOverQuota() throws Exception {
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAITFOR_MSEC);
        try {
            // Enable the FGS background startForeground() restriction.
            enableFgsRestriction(true, true, null);
            // Default behavior is TEMPORARY_ALLOW_LIST_TYPE_FOREGROUND_SERVICE_NOT_ALLOWED.
            setPushMessagingOverQuotaBehavior(
                    TEMPORARY_ALLOW_LIST_TYPE_FOREGROUND_SERVICE_NOT_ALLOWED);
            // Start FGS in BG state.
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            // APP1 does not enter FGS state
            try {
                waiter.doWait(WAITFOR_MSEC);
                fail(""Service should not enter foreground service state"");
            } catch (Exception e) {
            }

            setPushMessagingOverQuotaBehavior(TEMPORARY_ALLOW_LIST_TYPE_NONE);
            waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            runWithShellPermissionIdentity(() -> {
                mContext.getSystemService(PowerExemptionManager.class).addToTemporaryAllowList(
                        PACKAGE_NAME_APP1, PowerExemptionManager.REASON_PUSH_MESSAGING_OVER_QUOTA,
                        """", TEMP_ALLOWLIST_DURATION_MS);
            });
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testTempAllowListReasonCode"	"CtsAppTestCases"	"1: permission"	"([3:/android/app/cts/ActivityManagerFgsBgStartTest.java]:[permission]:[3]:method_text:[default_input_method is exempted from BG-FGS-start restriction.     * @throws Exception     */   ]) :|: 
    public void testTempAllowListReasonCode() throws Exception {
        // FGS start is temp allowed.
        testTempAllowListReasonCodeInternal(REASON_PUSH_MESSAGING);
        // FGS start is not allowed.
        testTempAllowListReasonCodeInternal(REASON_PUSH_MESSAGING_OVER_QUOTA);
        // Temp allowlist itself is not allowed. REASON_DENIED is not exposed in
        // PowerExemptionManager, just use its value ""-1"" here.
        testTempAllowListReasonCodeInternal(-1);
    }

    private void testTempAllowListReasonCodeInternal(int reasonCode) throws Exception {
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        ApplicationInfo app2Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP2, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAITFOR_MSEC);
        WatchUidRunner uid2Watcher = new WatchUidRunner(mInstrumentation, app2Info.uid,
                WAITFOR_MSEC);
        try {
            // Enable the FGS background startForeground() restriction.
            enableFgsRestriction(true, true, null);
            // Now it can start FGS.
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            runWithShellPermissionIdentity(()-> {
                final BroadcastOptions options = BroadcastOptions.makeBasic();
                // setTemporaryAppAllowlist API requires
                // START_FOREGROUND_SERVICES_FROM_BACKGROUND permission.
                options.setTemporaryAppAllowlist(TEMP_ALLOWLIST_DURATION_MS,
                        TEMPORARY_ALLOW_LIST_TYPE_FOREGROUND_SERVICE_ALLOWED, reasonCode,
                        """");
                // Must use Shell to issue this command because Shell has
                // START_FOREGROUND_SERVICES_FROM_BACKGROUND permission."	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerFgsBgStartTest"	"testFgsStartInputMethod"	"CtsAppTestCases"	"1: permission"	"([12:/android/app/cts/ActivityManagerFgsBgStartTest.java]:[permission]:[12]:method_text:[OR,                            Integer.toString(type), false);                }        );    }}]) :|: 
    public void testFgsStartInputMethod() throws Exception {
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAITFOR_MSEC);
        final String defaultInputMethod = CtsAppTestUtils.executeShellCmd(mInstrumentation,
                ""settings get --user current secure default_input_method"");
        try {
            // Enable the FGS background startForeground() restriction.
            enableFgsRestriction(true, true, null);
            // Start FGS in BG state.
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            // APP1 does not enter FGS state
            try {
                waiter.doWait(WAITFOR_MSEC);
                fail(""Service should not enter foreground service state"");
            } catch (Exception e) {
            }

            // Change default_input_method to PACKAGE_NAME_APP1.
            final ComponentName cn = new ComponentName(PACKAGE_NAME_APP1, ""xxx"");
            CtsAppTestUtils.executeShellCmd(mInstrumentation,
                    ""settings put --user current secure default_input_method ""
                            + cn.flattenToShortString());

            waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_START_FGS_RESULT);
            // Now it can start FGS.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            uid1Watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunne"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerFgsBgStartTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.UiModeManagerTest"	"testNightModeInCarModeOnPowerSaveIsTransient"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/UiModeManagerTest.java]:[permission]:[1]:method_text:[R_CAR_MODE_PRIORITIZED permission can enter car mode     * while specifying a priority.     */   ]) :|: public void testNightModeInCarModeOnPowerSaveIsTransient() throws Throwable {
        if (mUiModeManager.isNightModeLocked() || !BatteryUtils.isBatterySaverSupported()) {
            Log.i(TAG, ""testNightModeInCarModeOnPowerSaveIsTransient skipped: ""
                    + ""night mode is locked or battery saver is not supported"");
            return;
        }

        BatteryUtils.runDumpsysBatteryUnplug();

        // Turn off battery saver, disable night mode
        BatteryUtils.enableBatterySaver(false);
        mUiModeManager.setNightMode(UiModeManager.MODE_NIGHT_NO);
        assertEquals(UiModeManager.MODE_NIGHT_NO, mUiModeManager.getNightMode());
        assertVisibleNightModeInConfiguration(Configuration.UI_MODE_NIGHT_NO);

        // Then enable battery saver to check night mode is made visible
        BatteryUtils.enableBatterySaver(true);
        assertEquals(UiModeManager.MODE_NIGHT_NO, mUiModeManager.getNightMode());
        assertVisibleNightModeInConfiguration(Configuration.UI_MODE_NIGHT_YES);

        // Then disable it, enable car mode, and check night mode is not visible
        BatteryUtils.enableBatterySaver(false);
        mUiModeManager.enableCarMode(0);
        assertEquals(Configuration.UI_MODE_TYPE_CAR, mUiModeManager.getCurrentModeType());
        assertVisibleNightModeInConfiguration(Configuration.UI_MODE_NIGHT_NO);

        // Enable battery saver, check that night mode is still not visible, overridden by car mode
        BatteryUtils.enableBatterySaver(true);
        assertEquals(UiModeManager.MODE_NIGHT_NO, mUiModeManager.getNightMode());
        assertVisibleNightModeInConfiguration(Configuration.UI_MODE_NIGHT_NO);

        // Disable car mode
        mUiModeManager.disableCarMode(0);

        // Toggle night mode to force propagation of uiMode update, since disabling car mode
        // is deferred to a broadcast.
        mUiModeManager.setNightMode(UiModeManager.MODE_NIGHT_YES);
        mUiModeManager.setNightMode(UiModeManager.MODE_"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/UiModeManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.UiModeManagerTest"	"testEnterCarModePrioritized"	"CtsAppTestCases"	"1: permission"	"([5:/android/app/cts/UiModeManagerTest.java]:[permission]:[5]:method_text:[ar mode API when the caller does not hold the correct     * permission to use that API.     */   ]) :|: public void testEnterCarModePrioritized() {
        if (mUiModeManager.isUiModeLocked()) {
            return;
        }

        runWithShellPermissionIdentity(() -> mUiModeManager.enableCarMode(100, 0),
                Manifest.permission.ENTER_CAR_MODE_PRIORITIZED);
        assertEquals(Configuration.UI_MODE_TYPE_CAR, mUiModeManager.getCurrentModeType());

        runWithShellPermissionIdentity(() -> mUiModeManager.disableCarMode(0),
                Manifest.permission.ENTER_CAR_MODE_PRIORITIZED);
        assertEquals(Configuration.UI_MODE_TYPE_NORMAL, mUiModeManager.getCurrentModeType());
    }

    /**
     * Attempts to use the prioritized car mode API when the caller does not hold the correct
     * permission to use that API.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/UiModeManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.UiModeManagerTest"	"testEnterCarModePrioritizedDenied"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/UiModeManagerTest.java]:[permission]:[1]:method_text:[OGGLE_AUTOMOTIVE_PROJECTION permission can request/release     * automotive projection.     */   ]) :|: public void testEnterCarModePrioritizedDenied() {
        if (mUiModeManager.isUiModeLocked()) {
            return;
        }
        try {
            mUiModeManager.enableCarMode(100, 0);
        } catch (SecurityException se) {
            // Expect exception.
            return;
        }
        fail(""Expected SecurityException"");
    }

    /**
     * Verifies that an app holding the TOGGLE_AUTOMOTIVE_PROJECTION permission can request/release
     * automotive projection.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/UiModeManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.UiModeManagerTest"	"testReadProjectionState_listener"	"CtsAppTestCases"	"1: permission"	"([13:/android/app/cts/UiModeManagerTest.java]:[permission]:[13]:method_text:[tempts to request automotive projection without TOGGLE_AUTOMOTIVE_PROJECTION permission.     */   ]) :|: public void testReadProjectionState_listener() throws Exception {
        // Use AtomicInteger so it can be effectively final.
        AtomicInteger activeProjectionTypes = new AtomicInteger();
        Set<String> projectingPackages = new ArraySet<>();
        AtomicInteger callbackInvocations = new AtomicInteger();
        UiModeManager.OnProjectionStateChangedListener listener = (t, pkgs) -> {
            Log.i(TAG, ""onProjectionStateChanged("" + t + "","" + pkgs + "")"");
            activeProjectionTypes.set(t);
            projectingPackages.clear();
            projectingPackages.addAll(pkgs);
            callbackInvocations.incrementAndGet();
        };

        requestAutomotiveProjection();
        runWithShellPermissionIdentity(() -> mUiModeManager.addOnProjectionStateChangedListener(
                UiModeManager.PROJECTION_TYPE_ALL, MoreExecutors.directExecutor(), listener),
                Manifest.permission.READ_PROJECTION_STATE);

        // Should have called back immediately, but the call might not have gotten here yet.
        CommonTestUtils.waitUntil(""Callback wasn't invoked on listener addition!"",
                MAX_WAIT_TIME_SECS, () -> callbackInvocations.get() == 1);
        assertEquals(UiModeManager.PROJECTION_TYPE_AUTOMOTIVE, activeProjectionTypes.get());
        assertEquals(1, projectingPackages.size());
        assertTrue(projectingPackages.contains(getContext().getPackageName()));

        // Callback should not be invoked again.
        requestAutomotiveProjection();
        Thread.sleep(MAX_WAIT_TIME_MS);
        assertEquals(1, callbackInvocations.get());

        releaseAutomotiveProjection();
        CommonTestUtils.waitUntil(""Callback wasn't invoked on projection release!"",
                MAX_WAIT_TIME_SECS, () -> callbackInvocations.get() == 2);
        assertEquals(UiModeManager.PROJECTION_TYPE_NONE, activeProjectionTypes.get());
        assertEquals(0, projectingPackages.size());

        // Again, no callback for noop call."	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/UiModeManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.UiModeManagerTest"	"testRequestAutomotiveProjectionDenied"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/UiModeManagerTest.java]:[permission]:[1]:method_text:[tempts to request automotive projection without TOGGLE_AUTOMOTIVE_PROJECTION permission.     */   ]) :|: public void testRequestAutomotiveProjectionDenied() {
        try {
            mUiModeManager.requestProjection(UiModeManager.PROJECTION_TYPE_AUTOMOTIVE);
        } catch (SecurityException se) {
            // Expect exception.
            return;
        }
        fail(""Expected SecurityException"");
    }

    /**
     * Attempts to request automotive projection without TOGGLE_AUTOMOTIVE_PROJECTION permission.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/UiModeManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.UiModeManagerTest"	"testReleaseNoProjectionTypes"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/UiModeManagerTest.java]:[permission]:[1]:method_text:[    /** Attempts to call getActiveProjectionTypes without READ_PROJECTION_STATE permission. */   ]) :|: public void testReleaseNoProjectionTypes() {
        try {
            mUiModeManager.releaseProjection(UiModeManager.PROJECTION_TYPE_NONE);
        } catch (IllegalArgumentException iae) {
            // Expect exception.
            return;
        }
        fail(""Expected IllegalArgumentException"");
    }

    /** Attempts to call getActiveProjectionTypes without READ_PROJECTION_STATE permission. */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/UiModeManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.UiModeManagerTest"	"testReadProjectionState_getActiveProjectionTypesDenied"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/UiModeManagerTest.java]:[permission]:[1]:method_text:[  }    /** Attempts to call getProjectingPackages without READ_PROJECTION_STATE permission. */   ]) :|: public void testReadProjectionState_getActiveProjectionTypesDenied() {
        try {
            mUiModeManager.getActiveProjectionTypes();
        } catch (SecurityException se) {
            // Expect exception.
            return;
        }
        fail(""Expected SecurityException"");
    }

    /** Attempts to call getProjectingPackages without READ_PROJECTION_STATE permission. */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/UiModeManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.UiModeManagerTest"	"testReadProjectionState_getProjectingPackagesDenied"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/UiModeManagerTest.java]:[permission]:[1]:method_text:[all addOnProjectionStateChangedListener without     * READ_PROJECTION_STATE permission.     */   ]) :|: public void testReadProjectionState_getProjectingPackagesDenied() {
        try {
            mUiModeManager.getProjectingPackages(UiModeManager.PROJECTION_TYPE_ALL);
        } catch (SecurityException se) {
            // Expect exception.
            return;
        }
        fail(""Expected SecurityException"");
    }

    /**
     * Attempts to call addOnProjectionStateChangedListener without
     * READ_PROJECTION_STATE permission.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/UiModeManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.UiModeManagerTest"	"testReadProjectionState_addOnProjectionStateChangedListenerDenied"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/UiModeManagerTest.java]:[permission]:[1]:method_text:[ removeOnProjectionStateChangedListener without     * READ_PROJECTION_STATE permission.     */   ]) :|: public void testReadProjectionState_addOnProjectionStateChangedListenerDenied() {
        try {
            mUiModeManager.addOnProjectionStateChangedListener(UiModeManager.PROJECTION_TYPE_ALL,
                    getContext().getMainExecutor(), (t, pkgs) -> { });
        } catch (SecurityException se) {
            // Expect exception.
            return;
        }
        fail(""Expected SecurityException"");
    }

    /**
     * Attempts to call removeOnProjectionStateChangedListener without
     * READ_PROJECTION_STATE permission.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/UiModeManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.UiModeManagerTest"	"testReadProjectionState_removeOnProjectionStateChangedListenerDenied"	"CtsAppTestCases"	"1: permission"	"([4:/android/app/cts/UiModeManagerTest.java]:[permission]:[4]:method_text:[ngAsUser(UserHandle.USER_SYSTEM, key)                : SettingsUtils.getSecureSetting(key);    }}]) :|: public void testReadProjectionState_removeOnProjectionStateChangedListenerDenied() {
        UiModeManager.OnProjectionStateChangedListener listener = (t, pkgs) -> { };
        runWithShellPermissionIdentity(() -> mUiModeManager.addOnProjectionStateChangedListener(
                UiModeManager.PROJECTION_TYPE_ALL, getContext().getMainExecutor(), listener),
                Manifest.permission.READ_PROJECTION_STATE);
        try {
            mUiModeManager.removeOnProjectionStateChangedListener(listener);
        } catch (SecurityException se) {
            // Expect exception.
            return;
        }
        fail(""Expected SecurityException"");
    }

    private boolean isAutomotive() {
        return getContext().getPackageManager().hasSystemFeature(
                PackageManager.FEATURE_AUTOMOTIVE);
    }

    private boolean isTelevision() {
        PackageManager pm = getContext().getPackageManager();
        return pm.hasSystemFeature(PackageManager.FEATURE_TELEVISION)
                || pm.hasSystemFeature(PackageManager.FEATURE_LEANBACK);
    }

    private boolean isWatch() {
        return getContext().getPackageManager().hasSystemFeature(
                PackageManager.FEATURE_WATCH);
    }

    private void doTestUiModeForAutomotive() throws Exception {
        assertEquals(Configuration.UI_MODE_TYPE_CAR, mUiModeManager.getCurrentModeType());
        assertTrue(mUiModeManager.isUiModeLocked());
        doTestLockedUiMode();
    }

    private void doTestUiModeGeneric() throws Exception {
        if (mUiModeManager.isUiModeLocked()) {
            doTestLockedUiMode();
        } else {
            doTestUnlockedUiMode();
        }
    }

    private void doTestLockedUiMode() throws Exception {
        int originalMode = mUiModeManager.getCurrentModeType();
        mUiModeManager.enableCarMode(0);
        assertEquals(originalMode, mUiModeManager.getCurrentModeType());
        mUiModeManager.disableCarMode(0);
        assertEquals(originalMode, mUiMo"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/UiModeManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerProcessStateTest"	"removeTestAppFromWhitelists"	"CtsAppTestCases"	"1: permission"	"([3:/android/app/cts/ActivityManagerProcessStateTest.java]:[permission]:[3]:method_text:[ * Test basic state changes as processes go up and down due to services running in them.     */   ]) :|: /*
 *.
 */

package android.app.cts;

import static android.app.ActivityManager.PROCESS_CAPABILITY_ALL;
import static android.app.ActivityManager.PROCESS_CAPABILITY_ALL_IMPLICIT;
import static android.app.ActivityManager.PROCESS_CAPABILITY_FOREGROUND_LOCATION;
import static android.app.ActivityManager.PROCESS_CAPABILITY_NETWORK;
import static android.app.ActivityManager.PROCESS_CAPABILITY_NONE;
import static android.app.ActivityManager.RunningAppProcessInfo.IMPORTANCE_CACHED;
import static android.app.ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND;
import static android.app.ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND_SERVICE;
import static android.app.ActivityManager.RunningAppProcessInfo.IMPORTANCE_GONE;
import static android.app.ActivityManager.RunningAppProcessInfo.IMPORTANCE_VISIBLE;
import static android.app.stubs.LocalForegroundService.ACTION_START_FGS_RESULT;
import static android.app.stubs.LocalForegroundServiceSticky.ACTION_RESTART_FGS_STICKY_RESULT;

import static junit.framework.Assert.assertEquals;
import static junit.framework.Assert.assertTrue;
import static junit.framework.Assert.fail;

import android.accessibilityservice.AccessibilityService;
import android.app.Activity;
import android.app.ActivityManager;
import android.app.AppOpsManager;
import android.app.Instrumentation;
import android.app.Service;
import android.app.cts.android.app.cts.tools.ServiceConnectionHandler;
import android.app.cts.android.app.cts.tools.ServiceProcessController;
import android.app.cts.android.app.cts.tools.SyncOrderedBroadcast;
import android.app.cts.android.app.cts.tools.UidImportanceListener;
import android.app.cts.android.app.cts.tools.WaitForBroadcast;
import android.app.cts.android.app.cts.tools.WatchUidRunner;
import android.app.stubs.CommandReceiver;
import android.app.stubs.LocalForegroundServiceLocation;
import android.app.stubs.LocalForegroundServiceSticky;
import android.app.stubs.ScreenOnActivity;
import android.content.BroadcastR"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerProcessStateTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerProcessStateTest"	"testUidImportanceListener"	"CtsAppTestCases"	"1: permission"	"([6:/android/app/cts/ActivityManagerProcessStateTest.java]:[permission]:[6]:method_text:[vents idle services from running but allows     * whitelisted apps to bypass the check.     */   ]) :|: 
    public void testUidImportanceListener() throws Exception {
        final Parcel data = Parcel.obtain();
        ServiceConnectionHandler conn = new ServiceConnectionHandler(mContext, mServiceIntent,
                WAIT_TIME);
        ServiceConnectionHandler conn2 = new ServiceConnectionHandler(mContext, mService2Intent,
                WAIT_TIME);

        ActivityManager am = mContext.getSystemService(ActivityManager.class);

        ApplicationInfo appInfo = mContext.getPackageManager().getApplicationInfo(
                SIMPLE_PACKAGE_NAME, 0);
        UidImportanceListener uidForegroundListener = new UidImportanceListener(mContext,
                appInfo.uid, ActivityManager.RunningAppProcessInfo.IMPORTANCE_SERVICE, WAIT_TIME);

        PermissionUtils.revokePermission(
                STUB_PACKAGE_NAME, android.Manifest.permission.PACKAGE_USAGE_STATS);
        boolean gotException = false;
        try {
            uidForegroundListener.register();
        } catch (SecurityException e) {
            gotException = true;
        }
        assertTrue(""Expected SecurityException thrown"", gotException);

        PermissionUtils.grantPermission(
                STUB_PACKAGE_NAME, android.Manifest.permission.PACKAGE_USAGE_STATS);
        /*
        Log.d(""XXXX"", ""Invoke: "" + cmd);
        Log.d(""XXXX"", ""Result: "" + result);
        Log.d(""XXXX"", SystemUtil.runShellCommand(mInstrumentation, ""dumpsys package ""
                + STUB_PACKAGE_NAME));
        */
        uidForegroundListener.register();

        UidImportanceListener uidGoneListener = new UidImportanceListener(mContext,
                appInfo.uid, IMPORTANCE_CACHED, WAIT_TIME);
        uidGoneListener.register();

        WatchUidRunner uidWatcher = new WatchUidRunner(mInstrumentation, appInfo.uid,
                WAIT_TIME);

        try {
            // First kill the processes to start out in a stable state.
            conn.bind();
            conn2.bind();
            IBinder service1 = con"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerProcessStateTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerProcessStateTest"	"testBackgroundCheckService"	"CtsAppTestCases"	"1: permission"	"([3:/android/app/cts/ActivityManagerProcessStateTest.java]:[permission]:[3]:method_text:[nd: first     * allowing a service to be started, then stopped by the system when idle.     */   ]) :|: 
    public void testBackgroundCheckService() throws Exception {
        final Parcel data = Parcel.obtain();
        Intent serviceIntent = new Intent();
        serviceIntent.setClassName(SIMPLE_PACKAGE_NAME,
                SIMPLE_PACKAGE_NAME + SIMPLE_SERVICE);
        ServiceConnectionHandler conn = new ServiceConnectionHandler(mContext, serviceIntent,
                WAIT_TIME);

        ActivityManager am = mContext.getSystemService(ActivityManager.class);

        PermissionUtils.grantPermission(
                STUB_PACKAGE_NAME, android.Manifest.permission.PACKAGE_USAGE_STATS);
        /*
        Log.d(""XXXX"", ""Invoke: "" + cmd);
        Log.d(""XXXX"", ""Result: "" + result);
        Log.d(""XXXX"", SystemUtil.runShellCommand(mInstrumentation, ""dumpsys package ""
                + STUB_PACKAGE_NAME));
        */

        ApplicationInfo appInfo = mContext.getPackageManager().getApplicationInfo(
                SIMPLE_PACKAGE_NAME, 0);

        UidImportanceListener uidForegroundListener = new UidImportanceListener(mContext,
                appInfo.uid, ActivityManager.RunningAppProcessInfo.IMPORTANCE_SERVICE, WAIT_TIME);
        uidForegroundListener.register();
        UidImportanceListener uidGoneListener = new UidImportanceListener(mContext,
                appInfo.uid, ActivityManager.RunningAppProcessInfo.IMPORTANCE_EMPTY, WAIT_TIME);
        uidGoneListener.register();

        WatchUidRunner uidWatcher = new WatchUidRunner(mInstrumentation, appInfo.uid,
                WAIT_TIME);

        final int userId = UserHandle.getUserId(appInfo.uid);

        // First kill the process to start out in a stable state.
        mContext.stopService(serviceIntent);
        conn.bind();
        IBinder service = conn.getServiceIBinder();
        conn.unbind();
        try {
            service.transact(IBinder.FIRST_CALL_TRANSACTION, data, null, 0);
        } catch (RemoteException e) {
        }
        service = null;

        // Wait for uid's process to go away."	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerProcessStateTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerProcessStateTest"	"testBackgroundCheckStopsService"	"CtsAppTestCases"	"1: permission"	"([3:/android/app/cts/ActivityManagerProcessStateTest.java]:[permission]:[3]:method_text:[t allow services to be started from broadcasts except when in     * the correct states.     */   ]) :|: 
    public void testBackgroundCheckStopsService() throws Exception {
        final Parcel data = Parcel.obtain();
        ServiceConnectionHandler conn = new ServiceConnectionHandler(mContext, mServiceIntent,
                WAIT_TIME);
        ServiceConnectionHandler conn2 = new ServiceConnectionHandler(mContext, mService2Intent,
                WAIT_TIME);

        ActivityManager am = mContext.getSystemService(ActivityManager.class);

        PermissionUtils.grantPermission(
                STUB_PACKAGE_NAME, android.Manifest.permission.PACKAGE_USAGE_STATS);
        /*
        Log.d(""XXXX"", ""Invoke: "" + cmd);
        Log.d(""XXXX"", ""Result: "" + result);
        Log.d(""XXXX"", SystemUtil.runShellCommand(mInstrumentation, ""dumpsys package ""
                + STUB_PACKAGE_NAME));
        */

        ApplicationInfo appInfo = mContext.getPackageManager().getApplicationInfo(
                SIMPLE_PACKAGE_NAME, 0);

        UidImportanceListener uidServiceListener = new UidImportanceListener(mContext,
                appInfo.uid, ActivityManager.RunningAppProcessInfo.IMPORTANCE_SERVICE, WAIT_TIME);
        uidServiceListener.register();
        UidImportanceListener uidGoneListener = new UidImportanceListener(mContext,
                appInfo.uid, IMPORTANCE_CACHED, WAIT_TIME);
        uidGoneListener.register();

        WatchUidRunner uidWatcher = new WatchUidRunner(mInstrumentation, appInfo.uid,
                WAIT_TIME);

        // First kill the process to start out in a stable state.
        mContext.stopService(mServiceIntent);
        mContext.stopService(mService2Intent);
        conn.bind();
        conn2.bind();
        IBinder service = conn.getServiceIBinder();
        IBinder service2 = conn2.getServiceIBinder();
        conn.unbind();
        conn2.unbind();
        try {
            service.transact(IBinder.FIRST_CALL_TRANSACTION, data, null, 0);
        } catch (RemoteException e) {
        }
        try {
            service2.transact(IBinder.FIRST"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerProcessStateTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerProcessStateTest"	"testBackgroundCheckBroadcastService"	"CtsAppTestCases"	"1: permission"	"([3:/android/app/cts/ActivityManagerProcessStateTest.java]:[permission]:[3]:method_text:[/**     * Test that background check does allow services to be started from activities.     */   ]) :|: 
    public void testBackgroundCheckBroadcastService() throws Exception {
        final Intent broadcastIntent = new Intent();
        broadcastIntent.setFlags(Intent.FLAG_RECEIVER_FOREGROUND);
        broadcastIntent.setClassName(SIMPLE_PACKAGE_NAME,
                SIMPLE_PACKAGE_NAME + SIMPLE_RECEIVER_START_SERVICE);

        PermissionUtils.grantPermission(
                STUB_PACKAGE_NAME, android.Manifest.permission.PACKAGE_USAGE_STATS);
        final ServiceProcessController controller = new ServiceProcessController(mContext,
                mInstrumentation, STUB_PACKAGE_NAME, mAllProcesses, WAIT_TIME);
        final ServiceConnectionHandler conn = new ServiceConnectionHandler(mContext,
                mServiceIntent, WAIT_TIME);
        final WatchUidRunner uidWatcher = controller.getUidWatcher();

        try {
            // First kill the process to start out in a stable state.
            controller.ensureProcessGone();

            // Do initial setup.
            controller.denyBackgroundOp();
            controller.makeUidIdle();
            controller.removeFromWhitelist();

            // We will use this to monitor when the service is running.
            conn.startMonitoring();

            // Try sending broadcast to start the service.  Should fail!
            SyncOrderedBroadcast br = new SyncOrderedBroadcast();
            broadcastIntent.putExtra(""service"", mServiceIntent);
            br.sendAndWait(mContext, broadcastIntent, Activity.RESULT_OK, null, null, WAIT_TIME);
            int brCode = br.getReceivedCode();
            if (brCode != Activity.RESULT_CANCELED) {
                fail(""Didn't fail starting service, result="" + brCode);
            }

            // Track the uid proc state changes from the broadcast (but not service execution)
            uidWatcher.waitFor(WatchUidRunner.CMD_IDLE, null, WAIT_TIME);
            uidWatcher.waitFor(WatchUidRunner.CMD_UNCACHED, null, WAIT_TIME);
            uidWatcher.expect(WatchUidRunner"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerProcessStateTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerProcessStateTest"	"testBackgroundCheckActivityService"	"CtsAppTestCases"	"1: permission"	"([3:/android/app/cts/ActivityManagerProcessStateTest.java]:[permission]:[3]:method_text:[   /**     * Test that the foreground service app op does prevent the foreground state.     */   ]) :|: 
    public void testBackgroundCheckActivityService() throws Exception {
        final Intent activityIntent = new Intent();
        activityIntent.setClassName(SIMPLE_PACKAGE_NAME,
                SIMPLE_PACKAGE_NAME + SIMPLE_ACTIVITY_START_SERVICE);
        activityIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        PermissionUtils.grantPermission(
                STUB_PACKAGE_NAME, android.Manifest.permission.PACKAGE_USAGE_STATS);
        final ServiceProcessController controller = new ServiceProcessController(mContext,
                mInstrumentation, STUB_PACKAGE_NAME, mAllProcesses, WAIT_TIME);
        final ServiceConnectionHandler conn = new ServiceConnectionHandler(mContext,
                mServiceIntent, WAIT_TIME);
        final WatchUidRunner uidWatcher = controller.getUidWatcher();

        try {
            // First kill the process to start out in a stable state.
            controller.ensureProcessGone();

            // Do initial setup.
            controller.denyBackgroundOp();
            controller.makeUidIdle();
            controller.removeFromWhitelist();

            // We will use this to monitor when the service is running.
            conn.startMonitoring();

            // Try starting activity that will start the service.  This should be okay.
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_SIMPLE_ACTIVITY_START_SERVICE_RESULT);
            activityIntent.putExtra(""service"", mServiceIntent);
            mTargetContext.startActivity(activityIntent);
            Intent resultIntent = waiter.doWait(WAIT_TIME * 2);
            int brCode = resultIntent.getIntExtra(""result"", Activity.RESULT_CANCELED);
            if (brCode != Activity.RESULT_FIRST_USER) {
                fail(""Failed starting service, result="" + brCode);
            }
            conn.waitForConnect();

            final String expectedActivityState = (CtsAppTestUtils.isScreenInteracti"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerProcessStateTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerProcessStateTest"	"testForegroundServiceAppOp"	"CtsAppTestCases"	"1: permission"	"([3:/android/app/cts/ActivityManagerProcessStateTest.java]:[permission]:[3]:method_text:[ound services demoted to     * ordinary service state when it is no longer the top app.     */   ]) :|: 
    public void testForegroundServiceAppOp() throws Exception {
        PermissionUtils.grantPermission(
                STUB_PACKAGE_NAME, android.Manifest.permission.PACKAGE_USAGE_STATS);
        // Use default timeout value 5000
        final ServiceProcessController controller = new ServiceProcessController(mContext,
                mInstrumentation, STUB_PACKAGE_NAME, mAllProcesses);
        // Use default timeout value 5000
        final ServiceConnectionHandler conn = new ServiceConnectionHandler(mContext,
                mServiceIntent);
        final WatchUidRunner uidWatcher = controller.getUidWatcher();

        try {
            // First kill the process to start out in a stable state.
            controller.ensureProcessGone();

            // Do initial setup.
            controller.makeUidIdle();
            controller.removeFromWhitelist();
            controller.setAppOpMode(AppOpsManager.OPSTR_START_FOREGROUND, ""allow"");

            // Put app on whitelist, to allow service to run.
            controller.addToWhitelist();

            // We will use this to monitor when the service is running.
            conn.startMonitoring();

            // -------- START SERVICE AND THEN SUCCESSFULLY GO TO FOREGROUND

            // Now start the service and wait for it to come up.
            mContext.startService(mServiceStartForegroundIntent);
            conn.waitForConnect();

            // Also make sure the uid state reports are as expected.
            uidWatcher.waitFor(WatchUidRunner.CMD_UNCACHED, null);
            uidWatcher.expect(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_SERVICE);
            uidWatcher.waitFor(WatchUidRunner.CMD_ACTIVE, null);
            uidWatcher.expect(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE);

            // Now take it out of foreground and confirm.
            mContext.startService(mServiceStopForegroundIntent);
            uidWatcher.expect(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.ST"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerProcessStateTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerProcessStateTest"	"testBgRestrictedForegroundService"	"CtsAppTestCases"	"1: permission"	"([3:/android/app/cts/ActivityManagerProcessStateTest.java]:[permission]:[3]:method_text:[* Test that a single ""can't save state"" app has the proper process management semantics.     */   ]) :|: 
    public void testBgRestrictedForegroundService() throws Exception {
        final Intent activityIntent = new Intent()
                .setClassName(SIMPLE_PACKAGE_NAME,
                        SIMPLE_PACKAGE_NAME + SIMPLE_ACTIVITY_START_FG_SERVICE)
                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        PermissionUtils.grantPermission(
                STUB_PACKAGE_NAME, android.Manifest.permission.PACKAGE_USAGE_STATS);
        final ServiceProcessController controller = new ServiceProcessController(mContext,
                mInstrumentation, STUB_PACKAGE_NAME, mAllProcesses, WAIT_TIME);
        final WatchUidRunner uidWatcher = controller.getUidWatcher();

        final Intent homeIntent = new Intent()
                .setAction(Intent.ACTION_MAIN)
                .addCategory(Intent.CATEGORY_HOME)
                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK
                        | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);

        final Intent serviceStartIntent = new Intent(mService3Intent)
                .setAction(ACTION_START_THEN_FG);
        activityIntent.putExtra(""service"", serviceStartIntent);
        boolean activityStarted = false;

        try {
            // First kill the process to start out in a stable state.
            controller.ensureProcessGone();

            // Do initial setup.
            controller.denyAnyInBackgroundOp();
            controller.makeUidIdle();
            controller.removeFromWhitelist();
            controller.setAppOpMode(AppOpsManager.OPSTR_START_FOREGROUND, ""allow"");

            // Start the activity, which will start the fg service as well, and wait
            // for the report that it's all up and running.
            WaitForBroadcast waiter = new WaitForBroadcast(mInstrumentation.getTargetContext());
            waiter.prepare(ACTION_SIMPLE_ACTIVITY_START_FG_SERVICE_RESULT);

            activityIntent.setAction(ACTION_SIMPLE_ACTIVITY_START_FG);
            mTargetContext.startActivity(activityInt"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerProcessStateTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerProcessStateTest"	"testCantSaveStateLaunchAndBackground"	"CtsAppTestCases"	"1: permission"	"([3:/android/app/cts/ActivityManagerProcessStateTest.java]:[permission]:[3]:method_text:[ /**     * Test that switching between two ""can't save state"" apps is handled properly.     */   ]) :|: 
    public void testCantSaveStateLaunchAndBackground() throws Exception {
        if (!supportsCantSaveState()) {
            return;
        }

        final Intent activityIntent = new Intent();
        activityIntent.setPackage(CANT_SAVE_STATE_1_PACKAGE_NAME);
        activityIntent.setAction(Intent.ACTION_MAIN);
        activityIntent.addCategory(Intent.CATEGORY_LAUNCHER);
        activityIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        final Intent homeIntent = new Intent();
        homeIntent.setAction(Intent.ACTION_MAIN);
        homeIntent.addCategory(Intent.CATEGORY_HOME);
        homeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        ActivityManager am = mContext.getSystemService(ActivityManager.class);

        PermissionUtils.grantPermission(
                STUB_PACKAGE_NAME, android.Manifest.permission.PACKAGE_USAGE_STATS);

        // We don't want to wait for the uid to actually go idle, we can force it now.
        String cmd = ""am make-uid-idle "" + CANT_SAVE_STATE_1_PACKAGE_NAME;
        String result = SystemUtil.runShellCommand(mInstrumentation, cmd);

        ApplicationInfo appInfo = mContext.getPackageManager().getApplicationInfo(
                CANT_SAVE_STATE_1_PACKAGE_NAME, 0);

        // This test is also using UidImportanceListener to make sure the correct
        // heavy-weight state is reported there.
        UidImportanceListener uidForegroundListener = new UidImportanceListener(mContext,
                appInfo.uid, IMPORTANCE_FOREGROUND,
                WAIT_TIME);
        uidForegroundListener.register();
        UidImportanceListener uidBackgroundListener = new UidImportanceListener(mContext,
                appInfo.uid, ActivityManager.RunningAppProcessInfo.IMPORTANCE_CANT_SAVE_STATE - 1,
                WAIT_TIME);
        uidBackgroundListener.register();
        UidImportanceListener uidCachedListener = new UidImportanceListener(mContext,
                appInfo.uid, ActivityManager.RunningAppProcessInfo.IMPOR"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerProcessStateTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerProcessStateTest"	"testCantSaveStateLaunchAndSwitch"	"CtsAppTestCases"	"1: permission"	"([3:/android/app/cts/ActivityManagerProcessStateTest.java]:[permission]:[3]:method_text:[ound service,     * app should go back to cached state.     *     * @throws Exception     */   ]) :|: 
    public void testCantSaveStateLaunchAndSwitch() throws Exception {
        if (!supportsCantSaveState()) {
            return;
        }

        final Intent activity1Intent = new Intent();
        activity1Intent.setPackage(CANT_SAVE_STATE_1_PACKAGE_NAME);
        activity1Intent.setAction(Intent.ACTION_MAIN);
        activity1Intent.addCategory(Intent.CATEGORY_LAUNCHER);
        activity1Intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        final Intent activity2Intent = new Intent();
        activity2Intent.setPackage(CANT_SAVE_STATE_2_PACKAGE_NAME);
        activity2Intent.setAction(Intent.ACTION_MAIN);
        activity2Intent.addCategory(Intent.CATEGORY_LAUNCHER);
        activity2Intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        final Intent homeIntent = new Intent();
        homeIntent.setAction(Intent.ACTION_MAIN);
        homeIntent.addCategory(Intent.CATEGORY_HOME);
        homeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        ActivityManager am = mContext.getSystemService(ActivityManager.class);
        UiDevice device = UiDevice.getInstance(mInstrumentation);

        PermissionUtils.grantPermission(
                STUB_PACKAGE_NAME, android.Manifest.permission.PACKAGE_USAGE_STATS);

        // We don't want to wait for the uid to actually go idle, we can force it now.
        String cmd = ""am make-uid-idle "" + CANT_SAVE_STATE_1_PACKAGE_NAME;
        String result = SystemUtil.runShellCommand(mInstrumentation, cmd);
        cmd = ""am make-uid-idle "" + CANT_SAVE_STATE_2_PACKAGE_NAME;
        result = SystemUtil.runShellCommand(mInstrumentation, cmd);

        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                CANT_SAVE_STATE_1_PACKAGE_NAME, 0);
        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAIT_TIME);

        ApplicationInfo app2Info = mContext.getPackageManager().getApplicationInfo(
                CANT_SAVE_STATE_2_PACKAGE_NAME, 0);"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerProcessStateTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerProcessStateTest"	"testFgsLocationBind"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/ActivityManagerProcessStateTest.java]:[permission]:[1]:method_text:[g.     * Bound app should be TOP w/flag and BTOP without flag.     * @throws Exception     */   ]) :|: 
    public void testFgsLocationBind() throws Exception {
        setupWatchers(3);

        try {
            // Put Package1 in TOP state, now it gets all capability (because the TOP process
            // gets all while-in-use permission (not from FGSL).
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_ACTIVITY,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);
            mWatchers[0].waitFor(WatchUidRunner.CMD_PROCSTATE,
                    WatchUidRunner.STATE_TOP,
                    new Integer(PROCESS_CAPABILITY_FOREGROUND_LOCATION
                            | PROCESS_CAPABILITY_ALL));

            // Start a FGS
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE,
                    mAppInfo[0].packageName, mAppInfo[0].packageName, 0, null);

            // Start a FGSL
            Bundle bundle = new Bundle();
            bundle.putInt(LocalForegroundServiceLocation.EXTRA_FOREGROUND_SERVICE_TYPE,
                    ServiceInfo.FOREGROUND_SERVICE_TYPE_LOCATION);
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_START_FOREGROUND_SERVICE_LOCATION,
                    mAppInfo[0].packageName, mAppInfo[0].packageName, 0, bundle);

            // Stop the activity.
            CommandReceiver.sendCommand(mContext,
                    CommandReceiver.COMMAND_STOP_ACTIVITY,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);

            mWatchers[0].waitFor(WatchUidRunner.CMD_PROCSTATE,
                    WatchUidRunner.STATE_FG_SERVICE,
                    new Integer(PROCESS_CAPABILITY_NETWORK | PROCESS_CAPABILITY_FOREGROUND_LOCATION
                            | PROCESS_CAPABILITY_ALL_IMPLICIT));

            // Bind App 0 -> App 1, verify doesn't include capability.
            CommandReceiver.sendCommand(mContext, CommandReceiver.COMMAND_BIND_SERVICE,"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerProcessStateTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerProcessStateTest"	"testCycleTop"	"CtsAppTestCases"	"1: permission"	"([9:/android/app/cts/ActivityManagerProcessStateTest.java]:[permission]:[9]:method_text:[       if (activity != null) {                activity.finish();            }        }    }   ]) :|: 
    public void testCycleTop() throws Exception {
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        ApplicationInfo app2Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP2, 0);
        ApplicationInfo app3Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP3, 0);

        PermissionUtils.grantPermission(
                PACKAGE_NAME_APP1, android.Manifest.permission.PACKAGE_USAGE_STATS);
        PermissionUtils.grantPermission(
                PACKAGE_NAME_APP2, android.Manifest.permission.PACKAGE_USAGE_STATS);
        PermissionUtils.grantPermission(
                PACKAGE_NAME_APP3, android.Manifest.permission.PACKAGE_USAGE_STATS);

        UidImportanceListener uid1Listener = new UidImportanceListener(mContext,
                app1Info.uid, IMPORTANCE_VISIBLE,
                WAITFOR_MSEC);
        uid1Listener.register();

        UidImportanceListener uid1ServiceListener = new UidImportanceListener(mContext,
                app1Info.uid, IMPORTANCE_CACHED,
                WAITFOR_MSEC);
        uid1ServiceListener.register();

        UidImportanceListener uid2Listener = new UidImportanceListener(mContext,
                app2Info.uid, IMPORTANCE_VISIBLE,
                WAITFOR_MSEC);
        uid2Listener.register();

        UidImportanceListener uid2ServiceListener = new UidImportanceListener(mContext,
                app2Info.uid, IMPORTANCE_CACHED,
                WAITFOR_MSEC);
        uid2ServiceListener.register();

        UidImportanceListener uid3Listener = new UidImportanceListener(mContext,
                app3Info.uid, ActivityManager.RunningAppProcessInfo.IMPORTANCE_SERVICE,
                WAITFOR_MSEC);
        uid3Listener.register();

        UidImportanceListener uid3ServiceListener = new UidImportanceListener(mContext,
                app3Info.uid, IMPORTANCE_CACHED,
                WAI"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerProcessStateTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerProcessStateTest"	"testCycleFgAppAndAlert"	"CtsAppTestCases"	"1: permission"	"([15:/android/app/cts/ActivityManagerProcessStateTest.java]:[permission]:[15]:method_text:[    /**     * Test FGS compatibility with START_STICKY flag.     * @throws Exception     */   ]) :|: 
    public void testCycleFgAppAndAlert() throws Exception {
        ApplicationInfo stubInfo = mContext.getPackageManager().getApplicationInfo(
                STUB_PACKAGE_NAME, 0);
        ApplicationInfo app1Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP1, 0);
        ApplicationInfo app2Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP2, 0);
        ApplicationInfo app3Info = mContext.getPackageManager().getApplicationInfo(
                PACKAGE_NAME_APP3, 0);

        PermissionUtils.grantPermission(
                STUB_PACKAGE_NAME, android.Manifest.permission.PACKAGE_USAGE_STATS);
        PermissionUtils.grantPermission(
                PACKAGE_NAME_APP1, android.Manifest.permission.PACKAGE_USAGE_STATS);
        PermissionUtils.grantPermission(
                PACKAGE_NAME_APP2, android.Manifest.permission.PACKAGE_USAGE_STATS);
        PermissionUtils.grantPermission(
                PACKAGE_NAME_APP3, android.Manifest.permission.PACKAGE_USAGE_STATS);

        UidImportanceListener stubListener = new UidImportanceListener(mContext,
                stubInfo.uid, ActivityManager.RunningAppProcessInfo.IMPORTANCE_PERCEPTIBLE,
                WAITFOR_MSEC);
        stubListener.register();

        UidImportanceListener uid1Listener = new UidImportanceListener(mContext,
                app1Info.uid, IMPORTANCE_VISIBLE,
                WAITFOR_MSEC);
        uid1Listener.register();

        UidImportanceListener uid2Listener = new UidImportanceListener(mContext,
                app2Info.uid, IMPORTANCE_VISIBLE,
                WAITFOR_MSEC);
        uid2Listener.register();

        UidImportanceListener uid3Listener = new UidImportanceListener(mContext,
                app3Info.uid, IMPORTANCE_VISIBLE,
                WAITFOR_MSEC);
        uid3Listener.register();

        WatchUidRunner uid1Watcher = new WatchUidRunner(mInstrumentation, app1Info.uid,
                WAITFOR_MSE"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerProcessStateTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerProcessStateTest"	"testForegroundService_malformedNotificationExtras"	"CtsAppTestCases"	"1: permission"	"([4:/android/app/cts/ActivityManagerProcessStateTest.java]:[permission]:[4]:method_text:[rtActivitySync(intent);        mInstrumentation.waitForIdleSync();        return activity;    }}]) :|: 
    public void testForegroundService_malformedNotificationExtras() throws Exception {
        PermissionUtils.grantPermission(
                STUB_PACKAGE_NAME, android.Manifest.permission.PACKAGE_USAGE_STATS);
        // Use default timeout value 5000
        final ServiceProcessController controller = new ServiceProcessController(mContext,
                mInstrumentation, STUB_PACKAGE_NAME, mAllProcesses);

        ApplicationInfo appInfo = mContext.getPackageManager().getApplicationInfo(
                SIMPLE_PACKAGE_NAME, 0);
        UidImportanceListener uidGoneListener = new UidImportanceListener(mContext,
                appInfo.uid, IMPORTANCE_CACHED, WAIT_TIME);
        uidGoneListener.register();

        ActivityManager am = mContext.getSystemService(ActivityManager.class);

        try {
            controller.ensureProcessGone();

            // Do initial setup.
            controller.makeUidIdle();
            controller.removeFromWhitelist();
            controller.setAppOpMode(AppOpsManager.OPSTR_START_FOREGROUND, ""allow"");

            // Put app on whitelist, to allow service to run.
            controller.addToWhitelist();

            // Add a bad extra to the FGS notification and try to start the service
            // keep key in sync with com.android.cts.launcherapps.simpleapp.SimpleService
            mServiceStartForegroundIntent.putExtra(""NotifExtras"", true);
            mContext.startService(mServiceStartForegroundIntent);

            // Make sure we crashed the process
            uidGoneListener.waitForValue(IMPORTANCE_GONE, IMPORTANCE_GONE);
            assertEquals(IMPORTANCE_GONE, am.getPackageImportance(SIMPLE_PACKAGE_NAME));
        } finally {
            mContext.stopService(mServiceStartForegroundIntent);
            controller.cleanup();
            controller.setAppOpMode(AppOpsManager.OPSTR_START_FOREGROUND, ""ignore"");
            controller.removeFromWhitelist();
        }
    }

    private void testFgsStickyInternal("	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerProcessStateTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.DownloadManagerTest"	"testAddCompletedDownload"	"CtsAppTestCases"	"1: permission"	"([2:/android/app/cts/DownloadManagerTest.java]:[permission]:[2]:method_text:[        assertEquals(fileContents, rawFileContents);        assertRemoveDownload(id, 0);    }   ]) :|: 
    public void testAddCompletedDownload() throws Exception {
        final String fileContents = ""RED;GREEN;BLUE"";
        final File file = createFile(mContext.getExternalFilesDir(null), ""colors.txt"");

        writeToFile(file, fileContents);

        final long id = mDownloadManager.addCompletedDownload(file.getName(), ""Test desc"", true,
                ""text/plain"", file.getPath(), fileContents.getBytes().length, true);
        final String actualContents = readFromFile(mDownloadManager.openDownloadedFile(id));
        assertEquals(fileContents, actualContents);

        final Uri downloadUri = mDownloadManager.getUriForDownloadedFile(id);
        mContext.grantUriPermission(""com.android.shell"", downloadUri,
                Intent.FLAG_GRANT_READ_URI_PERMISSION);
        final String rawFilePath = getRawFilePath(downloadUri);
        final String rawFileContents = readFromRawFile(rawFilePath);
        assertEquals(fileContents, rawFileContents);
        assertRemoveDownload(id, 0);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DownloadManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.DownloadManagerTest"	"testAddCompletedDownload_downloadDir"	"CtsAppTestCases"	"1: permission"	"([2:/android/app/cts/DownloadManagerTest.java]:[permission]:[2]:method_text:[        assertEquals(fileContents, rawFileContents);        assertRemoveDownload(id, 0);    }   ]) :|: 
    public void testAddCompletedDownload_downloadDir() throws Exception {
        final String path = createFile(Environment.getExternalStoragePublicDirectory(
                        Environment.DIRECTORY_DOWNLOADS), ""file1.txt"").getPath();

        final String fileContents = ""Test content:"" + path + ""_"" + System.nanoTime();

        final File file = new File(path);
        writeToFile(new File(path), fileContents);

        final long id = mDownloadManager.addCompletedDownload(file.getName(), ""Test desc"", true,
                ""text/plain"", path, fileContents.getBytes().length, true);
        final String actualContents = readFromFile(mDownloadManager.openDownloadedFile(id));
        assertEquals(fileContents, actualContents);

        final Uri downloadUri = mDownloadManager.getUriForDownloadedFile(id);
        mContext.grantUriPermission(""com.android.shell"", downloadUri,
                Intent.FLAG_GRANT_READ_URI_PERMISSION);
        final String rawFilePath = getRawFilePath(downloadUri);
        final String rawFileContents = readFromRawFile(rawFilePath);
        assertEquals(fileContents, rawFileContents);
        assertRemoveDownload(id, 0);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DownloadManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.DownloadManagerTest"	"testDownload_mediaScanned"	"CtsAppTestCases"	"1: permission"	"([2:/android/app/cts/DownloadManagerTest.java]:[permission]:[2]:method_text:[ finally {                mContext.unregisterReceiver(receiver);            }        }    }   ]) :|: 
    public void testDownload_mediaScanned() throws Exception {
        final String[] destinations = {
                Environment.DIRECTORY_MUSIC,
                Environment.DIRECTORY_DOWNLOADS,
        };
        final String[] subPaths = {
                ""testmp3.mp3"",
                ""testvideo.3gp"",
        };
        final Pair<String, String>[] expectedMediaAttributes = new Pair[] {
                Pair.create(MediaStore.Audio.AudioColumns.IS_MUSIC, ""1""),
                Pair.create(MediaStore.Video.VideoColumns.DURATION, ""11047""),
        };

        for (int i = 0; i < destinations.length; ++i) {
            final String destination = destinations[i];
            final String subPath = subPaths[i];

            final DownloadCompleteReceiver receiver = new DownloadCompleteReceiver();
            try {
                IntentFilter intentFilter = new IntentFilter(
                        DownloadManager.ACTION_DOWNLOAD_COMPLETE);
                mContext.registerReceiver(receiver, intentFilter);

                DownloadManager.Request requestPublic = new DownloadManager.Request(
                        getAssetUrl(subPath));
                requestPublic.setDestinationInExternalPublicDir(destination, subPath);
                long id = mDownloadManager.enqueue(requestPublic);

                int allDownloads = getTotalNumberDownloads();
                assertEquals(1, allDownloads);

                int countBeforeDownload = getExternalVolumeMediaStoreFilesCount();
                receiver.waitForDownloadComplete(SHORT_TIMEOUT, id);
                assertSuccessfulDownload(id, new File(
                        Environment.getExternalStoragePublicDirectory(destination), subPath));

                int countAfterDownload = getExternalVolumeMediaStoreFilesCount();
                // Asserts that only one row entry is added for 1 download
                assertEquals((countBeforeDownload + 1), countAfterDownload);
                final Uri downloadUri = mDow"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DownloadManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.DownloadManagerTest"	"testDownload_onMediaStoreDownloadsDeleted"	"CtsAppTestCases"	"1: permission"	"([11:/android/app/cts/DownloadManagerTest.java]:[permission]:[11]:method_text:[utStream(file)) {            FileUtils.copy(source, target);        }        return file;    }}]) :|: 
    public void testDownload_onMediaStoreDownloadsDeleted() throws Exception {
        // prepare file
        File file = new File(Environment.getExternalStoragePublicDirectory(
                Environment.DIRECTORY_DOWNLOADS), ""cts"" + System.nanoTime() + "".mp3"");
        try {
            stageFile(""testmp3.mp3"", file);
            Uri mediaStoreUri = MediaStore.scanFile(mContext.getContentResolver(), file);

            // setup for activity
            GetResultActivity activity = setUpForActivity();

            // call activity as we want uri permission grant on DownloadStorageProvider Uri
            final Intent intent = new Intent();
            intent.setAction(Intent.ACTION_OPEN_DOCUMENT);
            intent.addCategory(Intent.CATEGORY_OPENABLE);
            intent.setType(""*/*"");
            Uri rootUri = DocumentsContract.buildRootUri(DOWNLOAD_STORAGE_PROVIDER_AUTHORITY,
                    ""downloads"");
            intent.putExtra(DocumentsContract.EXTRA_INITIAL_URI, rootUri);
            activity.startActivityForResult(intent, REQUEST_CODE);
            mDevice.waitForIdle();

            findDocument(file.getName()).click();
            final GetResultActivity.Result result = activity.getResult();
            final Uri uri = result.data.getData();

            assertTrue(PERMISSION_GRANTED == checkUriPermission(uri));

            // onMediaStoreDownloadsDeleted API is called on MediaProvider#delete()
            // for download files. This API revokes grants on DownloadStorageProvider granted Uris
            LongSparseArray<String> lpa = new LongSparseArray<String>();
            final long mediaStoreId = Long.parseLong(getMediaStoreColumnValue(mediaStoreUri,
                    MediaStore.Files.FileColumns._ID));
            final String mimeType = getMediaStoreColumnValue(mediaStoreUri,
                    MediaStore.Files.FileColumns.MIME_TYPE);
            lpa.put(mediaStoreId, mimeType);
            // This API is permission protected"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DownloadManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerApi29Test"	"clearHistory"	"CtsAppTestCases"	"1: permission"	"([17:/android/app/cts/ActivityManagerApi29Test.java]:[permission]:[17]:method_text:[ * , even its capability is zero, it still has location access.     * @throws Exception     */   ]) :|: /*
 *.
 */
package android.app.cts;

import static android.Manifest.permission.ACCESS_COARSE_LOCATION;
import static android.app.ActivityManager.PROCESS_CAPABILITY_ALL;
import static android.app.ActivityManager.PROCESS_CAPABILITY_NONE;
import static android.app.AppOpsManager.MODE_ALLOWED;
import static android.app.AppOpsManager.MODE_FOREGROUND;
import static android.app.AppOpsManager.MODE_IGNORED;
import static android.app.AppOpsManager.OPSTR_CAMERA;
import static android.app.AppOpsManager.OPSTR_COARSE_LOCATION;
import static android.app.AppOpsManager.OPSTR_RECORD_AUDIO;
import static android.app.AppOpsManager.OP_FLAGS_ALL;
import static android.app.AppOpsManager.UID_STATE_FOREGROUND_SERVICE;
import static android.app.AppOpsManager.UID_STATE_TOP;

import static com.android.compatibility.common.util.SystemUtil.callWithShellPermissionIdentity;
import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;

import static org.junit.Assert.assertEquals;

import android.app.AppOpsManager;
import android.app.AppOpsManager.HistoricalOp;
import android.app.AppOpsManager.HistoricalOps;
import android.app.AppOpsManager.HistoricalOpsRequest;
import android.app.Instrumentation;
import android.app.cts.android.app.cts.tools.WaitForBroadcast;
import android.app.cts.android.app.cts.tools.WatchUidRunner;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager.NameNotFoundException;
import android.permission.cts.PermissionUtils;
import android.provider.DeviceConfig;
import android.provider.Settings;
import android.support.test.uiautomator.UiDevice;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import org.junit.After;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.concurrent.CompletableFuture;
import"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerApi29Test.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerApi29Test"	"testAppOpsHistoricalOps"	"CtsAppTestCases"	"1: permission"	"([2:/android/app/cts/ActivityManagerApi29Test.java]:[permission]:[2]:method_text:[ FGS started by TOP app can have OP_CAMERA and OP_RECORD_AUDIO.     * @throws Exception     */   ]) :|: 
    @Ignore(""because ag/13230961, FGS started in instrumentation are not subject to while-in-use ""
            + ""restriction"")
    public void testAppOpsHistoricalOps() throws Exception {
        runWithShellPermissionIdentity(
                () ->  sAppOps.setHistoryParameters(AppOpsManager.HISTORICAL_MODE_ENABLED_ACTIVE,
                        1000, 10)
        );
        WaitForBroadcast waiter = new WaitForBroadcast(sInstrumentation.getTargetContext());
        waiter.prepare(ACTION_SIMPLE_ACTIVITY_START_RESULT);
        startSimpleActivity();
        mUidWatcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_TOP,
                new Integer(PROCESS_CAPABILITY_ALL));
        waiter.doWait(WAITFOR_MSEC);

        waiter = new WaitForBroadcast(sInstrumentation.getTargetContext());
        waiter.prepare(ACTION_SERVICE_START_RESULT);
        startSimpleService();
        waiter.doWait(WAITFOR_MSEC);

        for (int i = 0; i < NOTEOP_COUNT; i++) {
            noteOp(OPSTR_COARSE_LOCATION);
        }

        stopSimpleActivity();
        // The callingPackage to start FGS is in background.
        mUidWatcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE,
                new Integer(PROCESS_CAPABILITY_NONE));
        for (int i = 0; i < NOTEOP_COUNT; i++) {
            noteOp(OPSTR_COARSE_LOCATION);
        }
        stopSimpleService();
        mUidWatcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY,
                new Integer(PROCESS_CAPABILITY_NONE));

        for (int i = 0; i < NOTEOP_COUNT; i++) {
            noteOp(OPSTR_COARSE_LOCATION);
        }
        runWithShellPermissionIdentity(() -> {
            CompletableFuture<HistoricalOps> ops = new CompletableFuture<>();
            HistoricalOpsRequest histOpsRequest = new HistoricalOpsRequest.Builder(
                    Instant.now().minus(1, ChronoUnit.HOURS).toEpochMilli(),
                    Long.MAX_VALUE)
                    .setU"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerApi29Test.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerApi29Test"	"testCameraWithAppOps"	"CtsAppTestCases"	"1: permission"	"([2:/android/app/cts/ActivityManagerApi29Test.java]:[permission]:[2]:method_text:[        () -> sAppOps.noteOp(opStr, sUid, PACKAGE_NAME,                        opStr, """"));    }}]) :|: 
    @Ignore(""because ag/13230961, FGS started in instrumentation are not subject to while-in-use ""
            + ""restriction"")
    public void testCameraWithAppOps() throws Exception {
        startSimpleService();
        // Wait for state and capability change.
        mUidWatcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE,
                new Integer(PROCESS_CAPABILITY_NONE));

        // Non-Top started FGS do not have while-in-use permission, camera/microphone access is
        // denied.
        assertEquals(MODE_IGNORED, noteOp(OPSTR_CAMERA));
        assertEquals(MODE_IGNORED, noteOp(OPSTR_RECORD_AUDIO));

        // Start an activity, put app in TOP.
        startSimpleActivity();
        // TOP process has all capabilities.
        mUidWatcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_TOP,
                new Integer(PROCESS_CAPABILITY_ALL));

        // Camera/microphone access is allowed because the app is TOP.
        assertEquals(MODE_ALLOWED, noteOp(OPSTR_CAMERA));
        assertEquals(MODE_ALLOWED, noteOp(OPSTR_RECORD_AUDIO));

        // Tell the activity to finalize.
        stopSimpleActivity();
        mUidWatcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_FG_SERVICE,
                new Integer(PROCESS_CAPABILITY_NONE));

        // App not in Top, camera/microphone access should be denied.
        assertEquals(MODE_IGNORED, noteOp(OPSTR_CAMERA));
        assertEquals(MODE_IGNORED, noteOp(OPSTR_RECORD_AUDIO));

        // Stop the foreground service.
        stopSimpleService();
        mUidWatcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_CACHED_EMPTY,
                new Integer(PROCESS_CAPABILITY_NONE));

        assertEquals(MODE_IGNORED, noteOp(OPSTR_CAMERA));
        assertEquals(MODE_IGNORED, noteOp(OPSTR_RECORD_AUDIO));
    }

    private int noteOp(String opStr) throws Exception {
        return callWithShellPermissionIdentity(
                () -> sAppOps.n"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerApi29Test.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerTest"	"testUpdateMccMncConfiguration"	"CtsAppTestCases"	"1: permission"	"([2:/android/app/cts/ActivityManagerTest.java]:[permission]:[2]:method_text:[ityManager#isUserAMonkey()} - verifies its false.     *     * TODO: test positive case     */   ]) :|: public void testUpdateMccMncConfiguration() throws Exception {
        if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            Log.i(TAG, ""testUpdateMccMncConfiguration skipped: no telephony available"");
            return;
        }

        // Store the original mcc mnc to set back
        String[] mccMncConfigOriginal = new String[2];
        // Store other configs to check they won't be affected
        Set<String> otherConfigsOriginal = new HashSet<>();
        getMccMncConfigsAndOthers(mccMncConfigOriginal, otherConfigsOriginal);

        String[] mccMncConfigToUpdate = new String[] {MCC_TO_UPDATE, MNC_TO_UPDATE};
        boolean success = ShellIdentityUtils.invokeMethodWithShellPermissions(mActivityManager,
                (am) -> am.updateMccMncConfiguration(mccMncConfigToUpdate[0],
                        mccMncConfigToUpdate[1]));

        if (success) {
            String[] mccMncConfigUpdated = new String[2];
            Set<String> otherConfigsUpdated = new HashSet<>();
            getMccMncConfigsAndOthers(mccMncConfigUpdated, otherConfigsUpdated);
            // Check the mcc mnc are updated as expected
            assertArrayEquals(mccMncConfigToUpdate, mccMncConfigUpdated);
            // Check other configs are not changed
            assertEquals(otherConfigsOriginal, otherConfigsUpdated);
        }

        // Set mcc mnc configs back in the end of the test
        ShellIdentityUtils.invokeMethodWithShellPermissions(mActivityManager,
                (am) -> am.updateMccMncConfiguration(mccMncConfigOriginal[0],
                        mccMncConfigOriginal[1]));
    }

    private void getMccMncConfigsAndOthers(String[] mccMncConfigs, Set<String> otherConfigs)
            throws Exception {
        String[] configs = SystemUtil.runShellCommand(
                mInstrumentation, SHELL_COMMAND_GET_CONFIG).split("" |\\-"");
        for (String config : configs) {
            if (config.startsWith(SHELL_COMMAND_RESULT_CONFI"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerTest"	"testHomeVisibilityListener"	"CtsAppTestCases"	"1: permission"	"([2:/android/app/cts/ActivityManagerTest.java]:[permission]:[2]:method_text:[ify that the TimeTrackingAPI works properly when switching away from the monitored task.     */   ]) :|: public void testHomeVisibilityListener() throws Exception {
        LinkedBlockingQueue<Boolean> currentHomeScreenVisibility = new LinkedBlockingQueue<>(2);
        HomeVisibilityListener homeVisibilityListener = new HomeVisibilityListener() {
            @Override
            public void onHomeVisibilityChanged(boolean isHomeActivityVisible) {
                currentHomeScreenVisibility.offer(isHomeActivityVisible);
            }
        };
        launchHome();
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mActivityManager,
                (am) -> am.addHomeVisibilityListener(Runnable::run, homeVisibilityListener));

        try {
            // Make sure we got the first notification that the home screen is visible.
            assertTrue(currentHomeScreenVisibility.poll(WAIT_TIME, TimeUnit.MILLISECONDS));
            // Launch a basic activity to obscure the home screen.
            Intent intent = new Intent(Intent.ACTION_MAIN);
            intent.setClassName(SIMPLE_PACKAGE_NAME, SIMPLE_PACKAGE_NAME + SIMPLE_ACTIVITY);
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            mTargetContext.startActivity(intent);

            // Make sure the observer reports the home screen as no longer visible
            assertFalse(currentHomeScreenVisibility.poll(WAIT_TIME, TimeUnit.MILLISECONDS));
        } finally {
            ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mActivityManager,
                    (am) -> am.removeHomeVisibilityListener(homeVisibilityListener));
        }
    }

    /**
     * Verify that the TimeTrackingAPI works properly when switching away from the monitored task.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerTest"	"testForceStopPackageWontRestartProcess"	"CtsAppTestCases"	"1: permission"	"([3:/android/app/cts/ActivityManagerTest.java]:[permission]:[3]:method_text:[ test is to verify that devices are patched with the fix in b/119327603 for b/115384617.     */   ]) :|: public void testForceStopPackageWontRestartProcess() throws Exception {
        // Ensure that there are no remaining component records of the test app package.
        SystemUtil.runWithShellPermissionIdentity(
                () -> mActivityManager.forceStopPackage(SIMPLE_PACKAGE_NAME));
        ActivityReceiverFilter appStartedReceiver = new ActivityReceiverFilter(
                ACTIVITY_LAUNCHED_ACTION);
        // Start an activity of another APK.
        Intent intent = new Intent();
        intent.setClassName(SIMPLE_PACKAGE_NAME, SIMPLE_PACKAGE_NAME + SIMPLE_ACTIVITY);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mTargetContext.startActivity(intent);
        assertEquals(RESULT_PASS, appStartedReceiver.waitForActivity());

        // Start a new activity in the same task. Here adds an action to make a different to intent
        // filter comparison so another same activity will be created.
        intent.setAction(Intent.ACTION_MAIN);
        mTargetContext.startActivity(intent);
        assertEquals(RESULT_PASS, appStartedReceiver.waitForActivity());
        appStartedReceiver.close();

        // Wait for the first activity to stop so its ActivityRecord.haveState will be true. The
        // condition is required to keep the activity record when its process is died.
        Thread.sleep(WAIT_TIME);

        // The package name is also the default name for the activity process.
        final String testProcess = SIMPLE_PACKAGE_NAME;
        Predicate<RunningAppProcessInfo> processNamePredicate =
                runningApp -> testProcess.equals(runningApp.processName);

        List<RunningAppProcessInfo> runningApps = SystemUtil.callWithShellPermissionIdentity(
                () -> mActivityManager.getRunningAppProcesses());
        assertTrue(""Process "" + testProcess + "" should be found in running process list"",
                runningApps.stream().anyMatch(processNamePredicate));

        runningApps = SystemUtil.callWithShellPermis"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerTest"	"testAppNotResponding"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/ActivityManagerTest.java]:[permission]:[1]:method_text:[     * Verifies the {@link android.app.ActivityManager#killProcessesWhenImperceptible}.     */   ]) :|: public void testAppNotResponding() throws Exception {
        // Setup the ANR monitor
        AmMonitor monitor = new AmMonitor(mInstrumentation,
                new String[]{AmMonitor.WAIT_FOR_CRASHED});

        // Now tell it goto ANR
        CommandReceiver.sendCommand(mTargetContext, CommandReceiver.COMMAND_SELF_INDUCED_ANR,
                PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);

        try {

            // Verify we got the ANR
            assertTrue(monitor.waitFor(AmMonitor.WAIT_FOR_EARLY_ANR, WAITFOR_MSEC));

            // Just kill the test app
            monitor.sendCommand(AmMonitor.CMD_KILL);
        } finally {
            // clean up
            monitor.finish();
            SystemUtil.runWithShellPermissionIdentity(() -> {
                mActivityManager.forceStopPackage(PACKAGE_NAME_APP1);
            });
        }
    }

    /*
     * Verifies the {@link android.app.ActivityManager#killProcessesWhenImperceptible}.
     */"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerTest"	"testKillingPidsOnImperceptible"	"CtsAppTestCases"	"1: permission"	"([4:/android/app/cts/ActivityManagerTest.java]:[permission]:[4]:method_text:[he system will kill app's child processes if they are using excessive cpu     */    @LargeTest   ]) :|: public void testKillingPidsOnImperceptible() throws Exception {
        // Start remote service process
        final String remoteProcessName = STUB_PACKAGE_NAME + "":remote"";
        Intent remoteIntent = new Intent(""android.app.REMOTESERVICE"");
        remoteIntent.setPackage(STUB_PACKAGE_NAME);
        mTargetContext.startService(remoteIntent);
        Thread.sleep(WAITFOR_MSEC);

        RunningAppProcessInfo remote = getRunningAppProcessInfo(remoteProcessName);
        assertNotNull(remote);

        ActivityReceiverFilter appStartedReceiver = new ActivityReceiverFilter(
                ACTIVITY_LAUNCHED_ACTION);
        boolean disabled = ""0"".equals(executeShellCommand(""cmd deviceidle enabled light""));
        try {
            if (disabled) {
                executeAndLogShellCommand(""cmd deviceidle enable light"");
            }
            final Intent intent = new Intent(Intent.ACTION_MAIN);
            intent.setClassName(SIMPLE_PACKAGE_NAME, SIMPLE_PACKAGE_NAME + SIMPLE_ACTIVITY);
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            mTargetContext.startActivity(intent);
            assertEquals(RESULT_PASS, appStartedReceiver.waitForActivity());

            RunningAppProcessInfo proc = getRunningAppProcessInfo(SIMPLE_PACKAGE_NAME);
            assertNotNull(proc);

            final String reason = ""cts"";

            try {
                mActivityManager.killProcessesWhenImperceptible(new int[]{proc.pid}, reason);
                fail(""Shouldn't have the permission"");
            } catch (SecurityException e) {
                // expected
            }

            final long defaultWaitForKillTimeout = 5_000;

            // Keep the device awake
            toggleScreenOn(true);

            // Kill the remote process
            SystemUtil.runWithShellPermissionIdentity(() -> {
                mActivityManager.killProcessesWhenImperceptible(new int[]{remote.pid}, reason);
            });

            // Kill the activity process"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerTest"	"testKillingAppChildProcess"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/ActivityManagerTest.java]:[permission]:[1]:method_text:[Verifies the system will trim app's child processes if there are too many     */    @LargeTest   ]) :|: public void testKillingAppChildProcess() throws Exception {
        final long powerCheckInterval = 5 * 1000;
        final long processGoneTimeout = powerCheckInterval * 4;
        final int waitForSec = 5 * 1000;
        final String activityManagerConstants = ""activity_manager_constants"";

        final SettingsSession<String> amSettings = new SettingsSession<>(
                Settings.Global.getUriFor(activityManagerConstants),
                Settings.Global::getString, Settings.Global::putString);

        final ApplicationInfo ai = mTargetContext.getPackageManager()
                .getApplicationInfo(PACKAGE_NAME_APP1, 0);
        final WatchUidRunner watcher = new WatchUidRunner(mInstrumentation, ai.uid, waitForSec);

        try {
            // Shorten the power check intervals
            amSettings.set(""power_check_interval="" + powerCheckInterval);

            // Make sure we could start activity from background
            SystemUtil.runShellCommand(mInstrumentation,
                    ""cmd deviceidle whitelist +"" + PACKAGE_NAME_APP1);

            // Keep the device awake
            toggleScreenOn(true);

            // Start an activity
            CommandReceiver.sendCommand(mTargetContext, CommandReceiver.COMMAND_START_ACTIVITY,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, null);

            watcher.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_TOP, null);

            // Spawn a light weight child process
            CountDownLatch startLatch = startChildProcessInPackage(PACKAGE_NAME_APP1,
                    new String[] {""/system/bin/sh"", ""-c"",  ""sleep 1000""});

            // Wait for the start of the child process
            assertTrue(""Failed to spawn child process"",
                    startLatch.await(waitForSec, TimeUnit.MILLISECONDS));

            // Stop the activity
            CommandReceiver.sendCommand(mTargetContext, CommandReceiver.COMMAND_STOP_ACTIVITY,
                    PACKAGE_NAME_APP1, PAC"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerTest"	"testTrimAppChildProcess"	"CtsAppTestCases"	"1: permission"	"([3:/android/app/cts/ActivityManagerTest.java]:[permission]:[3]:method_text:[AND_WAIT_FOR_CHILD_PROCESS_GONE, pkgName, pkgName, 0, extras);        return stopLatch;    }   ]) :|: public void testTrimAppChildProcess() throws Exception {
        final long powerCheckInterval = 5 * 1000;
        final long processGoneTimeout = powerCheckInterval * 4;
        final int waitForSec = 5 * 1000;
        final int maxPhantomProcessesNum = 2;
        final String namespaceActivityManager = ""activity_manager"";
        final String activityManagerConstants = ""activity_manager_constants"";
        final String maxPhantomProcesses = ""max_phantom_processes"";

        final SettingsSession<String> amSettings = new SettingsSession<>(
                Settings.Global.getUriFor(activityManagerConstants),
                Settings.Global::getString, Settings.Global::putString);
        final Bundle currentMax = new Bundle();
        final String keyCurrent = ""current"";

        ApplicationInfo ai = mTargetContext.getPackageManager()
                .getApplicationInfo(PACKAGE_NAME_APP1, 0);
        final WatchUidRunner watcher1 = new WatchUidRunner(mInstrumentation, ai.uid, waitForSec);
        ai = mTargetContext.getPackageManager().getApplicationInfo(PACKAGE_NAME_APP2, 0);
        final WatchUidRunner watcher2 = new WatchUidRunner(mInstrumentation, ai.uid, waitForSec);
        ai = mTargetContext.getPackageManager().getApplicationInfo(PACKAGE_NAME_APP3, 0);
        final WatchUidRunner watcher3 = new WatchUidRunner(mInstrumentation, ai.uid, waitForSec);

        try {
            // Shorten the power check intervals
            amSettings.set(""power_check_interval="" + powerCheckInterval);

            // Reduce the maximum phantom processes allowance
            SystemUtil.runWithShellPermissionIdentity(() -> {
                int current = DeviceConfig.getInt(namespaceActivityManager,
                        maxPhantomProcesses, -1);
                currentMax.putInt(keyCurrent, current);
                DeviceConfig.setProperty(namespaceActivityManager,
                        maxPhantomProcesses,
                        Integer.toString(maxPhantomProcessesNum"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerTest"	"testTrimMemActivityFg"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/ActivityManagerTest.java]:[permission]:[1]:method_text:[atcher1.finish();            watcher2.finish();            watcher3.finish();        }    }   ]) :|: public void testTrimMemActivityFg() throws Exception {
        final int waitForSec = 5 * 1000;
        final ApplicationInfo ai1 = mTargetContext.getPackageManager()
                .getApplicationInfo(PACKAGE_NAME_APP1, 0);
        final WatchUidRunner watcher1 = new WatchUidRunner(mInstrumentation, ai1.uid, waitForSec);

        final ApplicationInfo ai2 = mTargetContext.getPackageManager()
                .getApplicationInfo(PACKAGE_NAME_APP2, 0);
        final WatchUidRunner watcher2 = new WatchUidRunner(mInstrumentation, ai2.uid, waitForSec);

        final ApplicationInfo ai3 = mTargetContext.getPackageManager()
                .getApplicationInfo(CANT_SAVE_STATE_1_PACKAGE_NAME, 0);
        final WatchUidRunner watcher3 = new WatchUidRunner(mInstrumentation, ai3.uid, waitForSec);

        final CountDownLatch[] latchHolder = new CountDownLatch[1];
        final int[] levelHolder = new int[1];
        final Bundle extras = initWaitingForTrimLevel(latchHolder, levelHolder);
        try {
            // Make sure we could start activity from background
            SystemUtil.runShellCommand(mInstrumentation,
                    ""cmd deviceidle whitelist +"" + PACKAGE_NAME_APP1);

            // Override the memory pressure level, force it staying at normal.
            SystemUtil.runShellCommand(mInstrumentation, ""am memory-factor set NORMAL"");

            // Keep the device awake
            toggleScreenOn(true);

            latchHolder[0] = new CountDownLatch(1);

            // Start an activity
            CommandReceiver.sendCommand(mTargetContext, CommandReceiver.COMMAND_START_ACTIVITY,
                    PACKAGE_NAME_APP1, PACKAGE_NAME_APP1, 0, extras);

            watcher1.waitFor(WatchUidRunner.CMD_PROCSTATE, WatchUidRunner.STATE_TOP, null);

            // Force the memory pressure to moderate
            SystemUtil.runShellCommand(mInstrumentation, ""am memory-factor set MODERATE"");
            assertTrue(""Failed to wait for the trim memory event"","	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerTest"	"testTrimMemActivityBg"	"CtsAppTestCases"	"1: permission"	"([2:/android/app/cts/ActivityManagerTest.java]:[permission]:[2]:method_text:[          mActivityManager.forceStopPackage(PACKAGE_NAME_APP1);            });        }    }   ]) :|: public void testTrimMemActivityBg() throws Exception {
        final int minLru = 8;
        final int waitForSec = 30 * 1000;
        final String prefix = ""trimmem_"";
        final CountDownLatch[] latchHolder = new CountDownLatch[1];
        final String pkgName = PACKAGE_NAME_APP1;
        final ArrayMap<String, Pair<int[], ServiceConnection>> procName2Level = new ArrayMap<>();
        int startSeq = 0;

        try {
            // Kill all background processes
            SystemUtil.runShellCommand(mInstrumentation, ""am kill-all"");

            // Override the memory pressure level, force it staying at normal.
            SystemUtil.runShellCommand(mInstrumentation, ""am memory-factor set NORMAL"");

            List<String> lru;
            // Start a new isolated service once a time, and then check the lru list
            do {
                final String instanceName = prefix + startSeq++;
                final int[] levelHolder = new int[1];

                // Spawn the new isolated service
                final ServiceConnection conn = TrimMemService.bindToTrimMemService(
                        pkgName, instanceName, latchHolder, levelHolder, mTargetContext);

                // Get the list of all cached apps
                lru = getCachedAppsLru();
                assertTrue(lru.size() > 0);

                for (int i = lru.size() - 1; i >= 0; i--) {
                    String p = lru.get(i);
                    if (p.indexOf(instanceName) != -1) {
                        // This is the new one we just created
                        procName2Level.put(p, new Pair<>(levelHolder, conn));
                        break;
                    }
                }
                if (lru.size() < minLru) {
                    continue;
                }
                if (lru.get(0).indexOf(pkgName) != -1) {
                    // Okay now the very least recent used cached process is one of ours
                    break;
                } else {"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.ActivityManagerTest"	"testServiceDoneLRUPosition"	"CtsAppTestCases"	"1: permission"	"([2:/android/app/cts/ActivityManagerTest.java]:[permission]:[2]:method_text:[!(result = supplier.get()) && SystemClock.uptimeMillis() < deadLine);        return result;    }}]) :|: public void testServiceDoneLRUPosition() throws Exception {
        ApplicationInfo ai = mTargetContext.getPackageManager()
                .getApplicationInfo(PACKAGE_NAME_APP1, 0);
        final WatchUidRunner watcher1 = new WatchUidRunner(mInstrumentation, ai.uid, WAITFOR_MSEC);
        ai = mTargetContext.getPackageManager().getApplicationInfo(PACKAGE_NAME_APP2, 0);
        final WatchUidRunner watcher2 = new WatchUidRunner(mInstrumentation, ai.uid, WAITFOR_MSEC);
        ai = mTargetContext.getPackageManager().getApplicationInfo(PACKAGE_NAME_APP3, 0);
        final WatchUidRunner watcher3 = new WatchUidRunner(mInstrumentation, ai.uid, WAITFOR_MSEC);
        final HandlerThread handlerThread = new HandlerThread(""worker"");
        final Messenger[] controllerHolder = new Messenger[1];
        final CountDownLatch[] countDownLatchHolder = new CountDownLatch[1];
        handlerThread.start();
        final Messenger messenger = new Messenger(new Handler(handlerThread.getLooper(), msg -> {
            final Bundle bundle = (Bundle) msg.obj;
            final IBinder binder = bundle.getBinder(CommandReceiver.EXTRA_MESSENGER);
            if (binder != null) {
                controllerHolder[0] = new Messenger(binder);
                countDownLatchHolder[0].countDown();
            }
            return true;
        }));

        try {
            // Make sure we could start activity from background
            SystemUtil.runShellCommand(mInstrumentation,
                    ""cmd deviceidle whitelist +"" + PACKAGE_NAME_APP1);
            SystemUtil.runShellCommand(mInstrumentation,
                    ""cmd deviceidle whitelist +"" + PACKAGE_NAME_APP2);
            SystemUtil.runShellCommand(mInstrumentation,
                    ""cmd deviceidle whitelist +"" + PACKAGE_NAME_APP3);

            // Keep the device awake
            toggleScreenOn(true);

            // Start a FGS in app1
            final Bundle extras = new Bundle();
            countDownLatchHolder[0] ="	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/ActivityManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.PendingIntentTest"	"testGetIntentComponentAndType"	"CtsAppTestCases"	"1: permission"	"([4:/android/app/cts/PendingIntentTest.java]:[permission]:[4]:method_text:[ } else {            fail(""Cannot resolve foreground service pending intent"");        }    }   ]) :|: public void testGetIntentComponentAndType() {
        Intent broadcastReceiverIntent = new Intent(MockReceiver.MOCKACTION);
        broadcastReceiverIntent.setClass(mContext, MockReceiver.class);
        PendingIntent broadcastReceiverPI = PendingIntent.getBroadcast(mContext, 1,
                broadcastReceiverIntent,
                PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE);
        assertTrue(broadcastReceiverPI.isBroadcast());
        assertFalse(broadcastReceiverPI.isActivity());
        assertFalse(broadcastReceiverPI.isForegroundService());
        assertFalse(broadcastReceiverPI.isService());

        List<ResolveInfo> broadcastReceiverResolveInfos =
                ShellIdentityUtils.invokeMethodWithShellPermissions(broadcastReceiverPI,
                        (pi) -> pi.queryIntentComponents(0));
        if (broadcastReceiverResolveInfos != null && broadcastReceiverResolveInfos.size() > 0) {
            ResolveInfo resolveInfo = broadcastReceiverResolveInfos.get(0);
            assertNotNull(resolveInfo.activityInfo);
            assertEquals(MockReceiver.class.getPackageName(), resolveInfo.activityInfo.packageName);
            assertEquals(MockReceiver.class.getName(), resolveInfo.activityInfo.name);
        } else {
            fail(""Cannot resolve broadcast receiver pending intent"");
        }

        Intent activityIntent = new Intent();
        activityIntent.setClass(mContext, MockActivity.class);
        PendingIntent activityPI = PendingIntent.getActivity(mContext, 1,
                activityIntent, PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_IMMUTABLE);
        assertTrue(activityPI.isActivity());
        assertFalse(activityPI.isBroadcast());
        assertFalse(activityPI.isForegroundService());
        assertFalse(activityPI.isService());

        List<ResolveInfo> activityResolveInfos =
                ShellIdentityUtils.invokeMethodWithShellPermissions(activityPI,
                        (pi) -> pi.queryIn"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/PendingIntentTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.KeyguardManagerTest"	"KeyguardManagerTest"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/KeyguardManagerTest.java]:[permission]:[1]:method_text:[eyguardManagerTest() {        super(""android.app.stubs"", KeyguardManagerActivity.class);    }   ]) :|: public void test/*
 *.
 */

package android.app.cts;

import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;

import android.app.KeyguardManager;
import android.app.stubs.KeyguardManagerActivity;
import android.content.Context;
import android.test.ActivityInstrumentationTestCase2;

import java.lang.reflect.Method;
import java.util.concurrent.CountDownLatch;

public class KeyguardManagerTest
        extends ActivityInstrumentationTestCase2<KeyguardManagerActivity> {

    private static final String TAG = ""KeyguardManagerTest"";

    public KeyguardManagerTest() {
        super(""android.app.stubs"", KeyguardManagerActivity.class);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/KeyguardManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.KeyguardManagerTest"	"testPrivateNotificationsAllowed"	"CtsAppTestCases"	"1: permission"	"([2:/android/app/cts/KeyguardManagerTest.java]:[permission]:[2]:method_text:[     }, ""android.permission.CONTROL_KEYGUARD_SECURE_NOTIFICATIONS"");        signal.await();    }}]) :|: public void testPrivateNotificationsAllowed() throws Exception {
        Context c = getInstrumentation().getContext();
        KeyguardManager keyguardManager = (KeyguardManager) c.getSystemService(
                Context.KEYGUARD_SERVICE);
        Method set = KeyguardManager.class.getMethod(
                ""setPrivateNotificationsAllowed"", boolean.class);
        Method get = KeyguardManager.class.getMethod(""getPrivateNotificationsAllowed"");
        CountDownLatch signal = new CountDownLatch(1);
        runWithShellPermissionIdentity(() -> {
                set.invoke(keyguardManager, false);
                assertFalse((boolean) get.invoke(keyguardManager));
                set.invoke(keyguardManager, true);
                assertTrue((boolean) get.invoke(keyguardManager));
                signal.countDown();
        }, ""android.permission.CONTROL_KEYGUARD_SECURE_NOTIFICATIONS"");
        signal.await();
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/KeyguardManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.StatusBarManagerTest"	"isWatch"	"CtsAppTestCases"	"1: permission"	"([7:/android/app/cts/StatusBarManagerTest.java]:[permission]:[7]:method_text:[    /**     * Test StatusBarManager.setDisabledForSetup(true)     * @throws Exception     */   ]) :|: /*
 *.
 */

package android.app.cts;

import static androidx.test.InstrumentationRegistry.getInstrumentation;

import static org.junit.Assert.assertTrue;
import static org.junit.Assume.assumeFalse;

import android.app.StatusBarManager;
import android.app.StatusBarManager.DisableInfo;
import android.app.UiAutomation;
import android.content.Context;
import android.content.pm.PackageManager;
import android.view.KeyEvent;

import androidx.test.InstrumentationRegistry;
import androidx.test.filters.SmallTest;
import androidx.test.runner.AndroidJUnit4;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

@RunWith(AndroidJUnit4.class)
@SmallTest
public class StatusBarManagerTest {
    private static final String PERMISSION_STATUS_BAR = ""android.permission.STATUS_BAR"";

    private StatusBarManager mStatusBarManager;
    private Context mContext;
    private UiAutomation mUiAutomation;

    private boolean isWatch() {
        return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH);
    }

    /**
     * Setup
     * @throws Exception
     */
    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getContext();
        assumeFalse(""Status bar service not supported"", isWatch());
        mStatusBarManager = (StatusBarManager) mContext.getSystemService(
                Context.STATUS_BAR_SERVICE);
        mUiAutomation = getInstrumentation().getUiAutomation();
        mUiAutomation.adoptShellPermissionIdentity(PERMISSION_STATUS_BAR);
    }

    @After
    public void tearDown() {

        if (mStatusBarManager != null) {
            // Adopt again since tests could've dropped it
            mUiAutomation.adoptShellPermissionIdentity(PERMISSION_STATUS_BAR);
            mStatusBarManager.setDisabledForSetup(false);
        }
        mUiAutomation.dropShellPermissionIdentity();
    }


    /**
     * Test StatusBarManager.setDisabledForSetup(true)
     * @throw"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/StatusBarManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.StatusBarManagerTest"	"testCollapsePanels_withoutStatusBarPermission_throws"	"CtsAppTestCases"	"1: permission"	"([2:/android/app/cts/StatusBarManagerTest.java]:[permission]:[2]:method_text:[mUiAutomation.dropShellPermissionIdentity();        mStatusBarManager.collapsePanels();    }   ]) :|: (expected = SecurityException.class)
    public void testCollapsePanels_withoutStatusBarPermission_throws() throws Exception {
        // We've adopted shell identity for STATUS_BAR in setUp(), so drop it now
        mUiAutomation.dropShellPermissionIdentity();

        mStatusBarManager.collapsePanels();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/StatusBarManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.StatusBarManagerTest"	"testCollapsePanels_withStatusBarPermission_doesNotThrow"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/StatusBarManagerTest.java]:[permission]:[1]:method_text:[n setUp()        mStatusBarManager.collapsePanels();        // Nothing thrown, passed    }   ]) :|: 
    public void testCollapsePanels_withStatusBarPermission_doesNotThrow() throws Exception {
        // We've adopted shell identity for STATUS_BAR in setUp()

        mStatusBarManager.collapsePanels();

        // Nothing thrown, passed
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/StatusBarManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.StatusBarManagerTest"	"testTogglePanel_withoutStatusBarPermission_throws"	"CtsAppTestCases"	"1: permission"	"([2:/android/app/cts/StatusBarManagerTest.java]:[permission]:[2]:method_text:[   mUiAutomation.dropShellPermissionIdentity();        mStatusBarManager.togglePanel();    }   ]) :|: (expected = SecurityException.class)
    public void testTogglePanel_withoutStatusBarPermission_throws() throws Exception {
        // We've adopted shell identity for STATUS_BAR in setUp(), so drop it now
        mUiAutomation.dropShellPermissionIdentity();

        mStatusBarManager.togglePanel();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/StatusBarManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.StatusBarManagerTest"	"testTogglePanel_withStatusBarPermission_doesNotThrow"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/StatusBarManagerTest.java]:[permission]:[1]:method_text:[R in setUp()        mStatusBarManager.togglePanel();        // Nothing thrown, passed    }   ]) :|: 
    public void testTogglePanel_withStatusBarPermission_doesNotThrow() throws Exception {
        // We've adopted shell identity for STATUS_BAR in setUp()

        mStatusBarManager.togglePanel();

        // Nothing thrown, passed
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/StatusBarManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.StatusBarManagerTest"	"testHandleSystemKey_withoutStatusBarPermission_throws"	"CtsAppTestCases"	"1: permission"	"([2:/android/app/cts/StatusBarManagerTest.java]:[permission]:[2]:method_text:[ity();        mStatusBarManager.handleSystemKey(KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP);    }   ]) :|: (expected = SecurityException.class)
    public void testHandleSystemKey_withoutStatusBarPermission_throws() throws Exception {
        // We've adopted shell identity for STATUS_BAR in setUp(), so drop it now
        mUiAutomation.dropShellPermissionIdentity();

        mStatusBarManager.handleSystemKey(KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/StatusBarManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.StatusBarManagerTest"	"testHandleSystemKey_withStatusBarPermission_doesNotThrow"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/StatusBarManagerTest.java]:[permission]:[1]:method_text:[r.handleSystemKey(KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP);        // Nothing thrown, passed    }}]) :|: 
    public void testHandleSystemKey_withStatusBarPermission_doesNotThrow() throws Exception {
        // We've adopted shell identity for STATUS_BAR in setUp()

        mStatusBarManager.handleSystemKey(KeyEvent.KEYCODE_SYSTEM_NAVIGATION_UP);

        // Nothing thrown, passed
    }
}"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/StatusBarManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.NotificationManagerTest"	"isGroup"	"CtsAppTestCases"	"1: permission"	"([4:/android/app/cts/NotificationManagerTest.java]:[permission]:[4]:method_text:[oid deactivateGracePeriod() {        UiDevice.getInstance(mInstrumentation).pressHome();    }   ]) :|: public void test/*
 *.
 */

package android.app.cts;

import static android.app.Notification.FLAG_BUBBLE;
import static android.app.NotificationManager.BUBBLE_PREFERENCE_ALL;
import static android.app.NotificationManager.BUBBLE_PREFERENCE_NONE;
import static android.app.NotificationManager.BUBBLE_PREFERENCE_SELECTED;
import static android.app.NotificationManager.IMPORTANCE_DEFAULT;
import static android.app.NotificationManager.IMPORTANCE_HIGH;
import static android.app.NotificationManager.IMPORTANCE_LOW;
import static android.app.NotificationManager.IMPORTANCE_MIN;
import static android.app.NotificationManager.IMPORTANCE_NONE;
import static android.app.NotificationManager.IMPORTANCE_UNSPECIFIED;
import static android.app.NotificationManager.INTERRUPTION_FILTER_ALARMS;
import static android.app.NotificationManager.INTERRUPTION_FILTER_ALL;
import static android.app.NotificationManager.INTERRUPTION_FILTER_NONE;
import static android.app.NotificationManager.INTERRUPTION_FILTER_PRIORITY;
import static android.app.NotificationManager.Policy.CONVERSATION_SENDERS_ANYONE;
import static android.app.NotificationManager.Policy.CONVERSATION_SENDERS_NONE;
import static android.app.NotificationManager.Policy.PRIORITY_CATEGORY_ALARMS;
import static android.app.NotificationManager.Policy.PRIORITY_CATEGORY_CALLS;
import static android.app.NotificationManager.Policy.PRIORITY_CATEGORY_CONVERSATIONS;
import static android.app.NotificationManager.Policy.PRIORITY_CATEGORY_EVENTS;
import static android.app.NotificationManager.Policy.PRIORITY_CATEGORY_MEDIA;
import static android.app.NotificationManager.Policy.PRIORITY_CATEGORY_MESSAGES;
import static android.app.NotificationManager.Policy.PRIORITY_CATEGORY_REMINDERS;
import static android.app.NotificationManager.Policy.PRIORITY_CATEGORY_SYSTEM;
import static android.app.NotificationManager.Policy.SUPPRESSED_EFFECT_AMBIENT;
import static android.app.NotificationManager.Policy.SUPPRESSED_EFFECT_FULL_SCREEN_INTENT;
import static android.app.N"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/NotificationManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.NotificationManagerTest"	"testSuspendPackage_withoutShellPermission"	"CtsAppTestCases"	"1: permission"	"([3:/android/app/cts/NotificationManagerTest.java]:[permission]:[3]:method_text:[atch (InterruptedException e) {            fail(""Unsuccessful shell command"");        }    }   ]) :|: public void testSuspendPackage_withoutShellPermission() throws Exception {
        if (mActivityManager.isLowRamDevice() && !mPackageManager.hasSystemFeature(FEATURE_WATCH)) {
            return;
        }

        try {
            Process proc = Runtime.getRuntime().exec(""cmd notification suspend_package ""
                    + mContext.getPackageName());

            // read output of command
            BufferedReader reader =
                    new BufferedReader(new InputStreamReader(proc.getInputStream()));
            StringBuilder output = new StringBuilder();
            String line = reader.readLine();
            while (line != null) {
                output.append(line);
                line = reader.readLine();
            }
            reader.close();
            final String outputString = output.toString();

            proc.waitFor();

            // check that the output string had an error / disallowed call since it didn't have
            // shell permission to suspend the package
            assertTrue(outputString, outputString.contains(""error""));
            assertTrue(outputString, outputString.contains(""permission denied""));
        } catch (InterruptedException e) {
            fail(""Unsuccessful shell command"");
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/NotificationManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.NotificationManagerTest"	"testShowBadging_ranking"	"CtsAppTestCases"	"1: permission"	"([3:/android/app/cts/NotificationManagerTest.java]:[permission]:[3]:method_text:[                       Settings.Secure.NOTIFICATION_BADGING, originalBadging));        }    }   ]) :|: public void testShowBadging_ranking() throws Exception {
        final int originalBadging = Settings.Secure.getInt(
                mContext.getContentResolver(), Settings.Secure.NOTIFICATION_BADGING);

        SystemUtil.runWithShellPermissionIdentity(() ->
                Settings.Secure.putInt(mContext.getContentResolver(),
                        Settings.Secure.NOTIFICATION_BADGING, 1));
        assertEquals(1, Settings.Secure.getInt(
                mContext.getContentResolver(), Settings.Secure.NOTIFICATION_BADGING));

        toggleListenerAccess(true);
        Thread.sleep(500); // wait for listener to be allowed

        mListener = TestNotificationListener.getInstance();
        assertNotNull(mListener);
        try {
            sendNotification(1, R.drawable.black);
            Thread.sleep(500); // wait for notification listener to receive notification
            NotificationListenerService.RankingMap rankingMap = mListener.mRankingMap;
            NotificationListenerService.Ranking outRanking =
                    new NotificationListenerService.Ranking();
            for (String key : rankingMap.getOrderedKeys()) {
                if (key.contains(mListener.getPackageName())) {
                    rankingMap.getRanking(key, outRanking);
                    assertTrue(outRanking.canShowBadge());
                }
            }

            // turn off badging globally
            SystemUtil.runWithShellPermissionIdentity(() ->
                    Settings.Secure.putInt(mContext.getContentResolver(),
                            Settings.Secure.NOTIFICATION_BADGING, 0));

            Thread.sleep(500); // wait for ranking update

            rankingMap = mListener.mRankingMap;
            outRanking = new NotificationListenerService.Ranking();
            for (String key : rankingMap.getOrderedKeys()) {
                if (key.contains(mListener.getPackageName())) {
                    assertFalse(outRanking.canShowBadge());
                }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/NotificationManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.NotificationManagerTest"	"testPostFullScreenIntent_permission"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/NotificationManagerTest.java]:[permission]:[1]:method_text:[       assertEquals(notification.fullScreenIntent, n.getNotification().fullScreenIntent);    }   ]) :|: public void testPostFullScreenIntent_permission() {
        int id = 6000;

        final Notification notification =
                new Notification.Builder(mContext, NOTIFICATION_CHANNEL_ID)
                        .setSmallIcon(R.drawable.black)
                        .setWhen(System.currentTimeMillis())
                        .setFullScreenIntent(getPendingIntent(), true)
                        .setContentText(""This is #FSI notification"")
                        .setContentIntent(getPendingIntent())
                        .build();
        mNotificationManager.notify(id, notification);

        StatusBarNotification n = findPostedNotification(id, false);
        assertNotNull(n);
        assertEquals(notification.fullScreenIntent, n.getNotification().fullScreenIntent);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/NotificationManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.NotificationManagerTest"	"testNotificationDelegate_grantAndPost"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/NotificationManagerTest.java]:[permission]:[1]:method_text:[VITY_NEW_TASK);        mContext.startActivity(revokeIntent);        Thread.sleep(1000);    }   ]) :|: public void testNotificationDelegate_grantAndPost() throws Exception {
        // grant this test permission to post
        final Intent activityIntent = new Intent();
        activityIntent.setPackage(DELEGATOR);
        activityIntent.setAction(Intent.ACTION_MAIN);
        activityIntent.addCategory(Intent.CATEGORY_LAUNCHER);
        activityIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        // wait for the activity to launch and finish
        mContext.startActivity(activityIntent);
        Thread.sleep(mActivityManager.isLowRamDevice() ? 1500 : 1000);

        // send notification
        Notification n = new Notification.Builder(mContext, ""channel"")
                .setSmallIcon(android.R.id.icon)
                .build();
        mNotificationManager.notifyAsPackage(DELEGATOR, ""tag"", 0, n);

        assertNotNull(findPostedNotification(0, false));
        final Intent revokeIntent = new Intent();
        revokeIntent.setClassName(DELEGATOR, REVOKE_CLASS);
        revokeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(revokeIntent);
        Thread.sleep(1000);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/NotificationManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.NotificationManagerTest"	"testNotificationDelegate_grantAndPostAndCancel"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/NotificationManagerTest.java]:[permission]:[1]:method_text:[VITY_NEW_TASK);        mContext.startActivity(revokeIntent);        Thread.sleep(1000);    }   ]) :|: public void testNotificationDelegate_grantAndPostAndCancel() throws Exception {
        // grant this test permission to post
        final Intent activityIntent = new Intent();
        activityIntent.setPackage(DELEGATOR);
        activityIntent.setAction(Intent.ACTION_MAIN);
        activityIntent.addCategory(Intent.CATEGORY_LAUNCHER);
        activityIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        // wait for the activity to launch and finish
        mContext.startActivity(activityIntent);
        Thread.sleep(1000);

        // send notification
        Notification n = new Notification.Builder(mContext, ""channel"")
                .setSmallIcon(android.R.id.icon)
                .build();
        mNotificationManager.notifyAsPackage(DELEGATOR, ""toBeCanceled"", 10000, n);
        assertNotNull(findPostedNotification(10000, false));
        mNotificationManager.cancelAsPackage(DELEGATOR, ""toBeCanceled"", 10000);
        assertNotificationCancelled(10000, false);
        final Intent revokeIntent = new Intent();
        revokeIntent.setClassName(DELEGATOR, REVOKE_CLASS);
        revokeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(revokeIntent);
        Thread.sleep(1000);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/NotificationManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.NotificationManagerTest"	"testNotificationDelegate_cannotCancelNotificationsPostedByDelegator"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/NotificationManagerTest.java]:[permission]:[1]:method_text:[VITY_NEW_TASK);        mContext.startActivity(revokeIntent);        Thread.sleep(1000);    }   ]) :|: public void testNotificationDelegate_cannotCancelNotificationsPostedByDelegator()
            throws Exception {
        toggleListenerAccess(true);
        Thread.sleep(500); // wait for listener to be allowed

        mListener = TestNotificationListener.getInstance();
        assertNotNull(mListener);

        // grant this test permission to post
        final Intent activityIntent = new Intent();
        activityIntent.setClassName(DELEGATOR, DELEGATE_POST_CLASS);
        activityIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        mContext.startActivity(activityIntent);

        Thread.sleep(1000);

        assertNotNull(findPostedNotification(9, true));

        try {
            mNotificationManager.cancelAsPackage(DELEGATOR, null, 9);
            fail(""Delegate should not be able to cancel notification they did not post"");
        } catch (SecurityException e) {
            // yay
        }

        // double check that the notification does still exist
        assertNotNull(findPostedNotification(9, true));

        final Intent revokeIntent = new Intent();
        revokeIntent.setClassName(DELEGATOR, REVOKE_CLASS);
        revokeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(revokeIntent);
        Thread.sleep(1000);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/NotificationManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.NotificationManagerTest"	"testNotificationDelegate_grantAndReadChannels"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/NotificationManagerTest.java]:[permission]:[1]:method_text:[IVITY_NEW_TASK);        mContext.startActivity(revokeIntent);        Thread.sleep(500);    }   ]) :|: public void testNotificationDelegate_grantAndReadChannels() throws Exception {
        // grant this test permission to post
        final Intent activityIntent = new Intent();
        activityIntent.setPackage(DELEGATOR);
        activityIntent.setAction(Intent.ACTION_MAIN);
        activityIntent.addCategory(Intent.CATEGORY_LAUNCHER);
        activityIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        // wait for the activity to launch and finish
        mContext.startActivity(activityIntent);
        Thread.sleep(500);

        List<NotificationChannel> channels =
                mContext.createPackageContextAsUser(DELEGATOR, /* flags= */ 0, mContext.getUser())
                        .getSystemService(NotificationManager.class)
                        .getNotificationChannels();

        assertNotNull(channels);

        final Intent revokeIntent = new Intent();
        revokeIntent.setClassName(DELEGATOR, REVOKE_CLASS);
        revokeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(revokeIntent);
        Thread.sleep(500);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/NotificationManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.NotificationManagerTest"	"testNotificationDelegate_grantAndReadChannel"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/NotificationManagerTest.java]:[permission]:[1]:method_text:[IVITY_NEW_TASK);        mContext.startActivity(revokeIntent);        Thread.sleep(500);    }   ]) :|: public void testNotificationDelegate_grantAndReadChannel() throws Exception {
        // grant this test permission to post
        final Intent activityIntent = new Intent();
        activityIntent.setPackage(DELEGATOR);
        activityIntent.setAction(Intent.ACTION_MAIN);
        activityIntent.addCategory(Intent.CATEGORY_LAUNCHER);
        activityIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        // wait for the activity to launch and finish
        mContext.startActivity(activityIntent);
        Thread.sleep(2000);

        NotificationChannel channel =
                mContext.createPackageContextAsUser(DELEGATOR, /* flags= */ 0, mContext.getUser())
                        .getSystemService(NotificationManager.class)
                        .getNotificationChannel(""channel"");

        assertNotNull(channel);

        final Intent revokeIntent = new Intent();
        revokeIntent.setClassName(DELEGATOR, REVOKE_CLASS);
        revokeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(revokeIntent);
        Thread.sleep(500);
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/NotificationManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.NotificationManagerTest"	"testNotificationDelegate_grantAndRevoke"	"CtsAppTestCases"	"1: permission"	"([2:/android/app/cts/NotificationManagerTest.java]:[permission]:[2]:method_text:[ermission revoked"");        } catch (SecurityException e) {            // yay        }    }   ]) :|: public void testNotificationDelegate_grantAndRevoke() throws Exception {
        // grant this test permission to post
        final Intent activityIntent = new Intent();
        activityIntent.setPackage(DELEGATOR);
        activityIntent.setAction(Intent.ACTION_MAIN);
        activityIntent.addCategory(Intent.CATEGORY_LAUNCHER);
        activityIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        mContext.startActivity(activityIntent);
        Thread.sleep(500);

        assertTrue(mNotificationManager.canNotifyAsPackage(DELEGATOR));

        final Intent revokeIntent = new Intent();
        revokeIntent.setClassName(DELEGATOR, REVOKE_CLASS);
        revokeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(revokeIntent);
        Thread.sleep(500);

        try {
            // send notification
            Notification n = new Notification.Builder(mContext, ""channel"")
                    .setSmallIcon(android.R.id.icon)
                    .build();
            mNotificationManager.notifyAsPackage(DELEGATOR, ""tag"", 0, n);
            fail(""Should not be able to post as a delegate when permission revoked"");
        } catch (SecurityException e) {
            // yay
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/NotificationManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.NotificationManagerTest"	"testMatchesCallFilter"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/NotificationManagerTest.java]:[permission]:[1]:method_text:[firm that the optional methods of TestNotificationListener still exist and     * don't fail. */   ]) :|: public void testMatchesCallFilter() throws Exception {
        // allow all callers
        toggleNotificationPolicyAccess(mContext.getPackageName(),
                InstrumentationRegistry.getInstrumentation(), true);
        Policy origPolicy = mNotificationManager.getNotificationPolicy();
        Uri aliceUri = null;
        try {
            NotificationManager.Policy currPolicy = mNotificationManager.getNotificationPolicy();
            NotificationManager.Policy newPolicy = new NotificationManager.Policy(
                    NotificationManager.Policy.PRIORITY_CATEGORY_CALLS
                            | NotificationManager.Policy.PRIORITY_CATEGORY_REPEAT_CALLERS,
                    NotificationManager.Policy.PRIORITY_SENDERS_ANY,
                    currPolicy.priorityMessageSenders,
                    currPolicy.suppressedVisualEffects);
            mNotificationManager.setNotificationPolicy(newPolicy);

            // add a contact
            String ALICE = ""Alice"";
            String ALICE_PHONE = ""+16175551212"";
            String ALICE_EMAIL = ""alice@_foo._bar"";

            insertSingleContact(ALICE, ALICE_PHONE, ALICE_EMAIL, false);

            final Bundle peopleExtras = new Bundle();
            ArrayList<Person> personList = new ArrayList<>();
            aliceUri = lookupContact(ALICE_PHONE);
            personList.add(new Person.Builder().setUri(aliceUri.toString()).build());
            peopleExtras.putParcelableArrayList(Notification.EXTRA_PEOPLE_LIST, personList);
            SystemUtil.runWithShellPermissionIdentity(() ->
                    assertTrue(mNotificationManager.matchesCallFilter(peopleExtras)));
        } finally {
            mNotificationManager.setNotificationPolicy(origPolicy);
            if (aliceUri != null) {
                // delete the contact
                deleteSingleContact(aliceUri);
            }
        }

    }

    /* Confirm that the optional methods of TestNotificationListener still exist and
     * don't"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/NotificationManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.NotificationManagerTest"	"testNotificationUriPermissionsGranted"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/NotificationManagerTest.java]:[permission]:[1]:method_text:[     performNotificationProviderAction(""reset"");            Thread.sleep(500);        }    }   ]) :|: public void testNotificationUriPermissionsGranted() throws Exception {
        Uri background7Uri = Uri.parse(
                ""content://com.android.test.notificationprovider.provider/background7.png"");
        Uri background8Uri = Uri.parse(
                ""content://com.android.test.notificationprovider.provider/background8.png"");

        toggleListenerAccess(true);
        Thread.sleep(500); // wait for listener to be allowed

        mListener = TestNotificationListener.getInstance();
        assertNotNull(mListener);

        try {
            // Post #7
            performNotificationProviderAction(""send-7"");

            assertEquals(background7Uri, getNotificationBackgroundImageUri(7));
            assertNotificationCancelled(8, true);
            assertAccessible(background7Uri);
            assertInaccessible(background8Uri);

            // Post #8
            performNotificationProviderAction(""send-8"");

            assertEquals(background7Uri, getNotificationBackgroundImageUri(7));
            assertEquals(background8Uri, getNotificationBackgroundImageUri(8));
            assertAccessible(background7Uri);
            assertAccessible(background8Uri);

            // Cancel #7
            performNotificationProviderAction(""cancel-7"");

            assertNotificationCancelled(7, true);
            assertEquals(background8Uri, getNotificationBackgroundImageUri(8));
            assertInaccessible(background7Uri);
            assertAccessible(background8Uri);

            // Cancel #8
            performNotificationProviderAction(""cancel-8"");

            assertNotificationCancelled(7, true);
            assertNotificationCancelled(8, true);
            assertInaccessible(background7Uri);
            assertInaccessible(background8Uri);

        } finally {
            // Clean up -- reset any remaining notifications
            performNotificationProviderAction(""reset"");
            Thread.sleep(500);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/NotificationManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.NotificationManagerTest"	"testNotificationUriPermissionsGrantedToNewListeners"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/NotificationManagerTest.java]:[permission]:[1]:method_text:[  performNotificationProviderAction(""cancel-7"");            Thread.sleep(500);        }    }   ]) :|: public void testNotificationUriPermissionsGrantedToNewListeners() throws Exception {
        Uri background7Uri = Uri.parse(
                ""content://com.android.test.notificationprovider.provider/background7.png"");

        try {
            // Post #7
            performNotificationProviderAction(""send-7"");

            Thread.sleep(500);
            // Don't have access the notification yet, but we can test the URI
            assertInaccessible(background7Uri);

            toggleListenerAccess(true);
            Thread.sleep(500); // wait for listener to be allowed

            mListener = TestNotificationListener.getInstance();
            assertNotNull(mListener);

            assertEquals(background7Uri, getNotificationBackgroundImageUri(7));
            assertAccessible(background7Uri);

        } finally {
            // Clean Up -- Cancel #7
            performNotificationProviderAction(""cancel-7"");
            Thread.sleep(500);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/NotificationManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.NotificationManagerTest"	"testNotificationUriPermissionsRevokedFromRemovedListeners"	"CtsAppTestCases"	"1: permission"	"([2:/android/app/cts/NotificationManagerTest.java]:[permission]:[2]:method_text:[edException e) {            }            fail(""failed to connec to service"");        }    }   ]) :|: public void testNotificationUriPermissionsRevokedFromRemovedListeners() throws Exception {
        Uri background7Uri = Uri.parse(
                ""content://com.android.test.notificationprovider.provider/background7.png"");

        toggleListenerAccess(true);
        Thread.sleep(500); // wait for listener to be allowed

        try {
            // Post #7
            performNotificationProviderAction(""send-7"");

            mListener = TestNotificationListener.getInstance();
            assertNotNull(mListener);

            assertEquals(background7Uri, getNotificationBackgroundImageUri(7));
            assertAccessible(background7Uri);

            // Remove the listener to ensure permissions get revoked
            toggleListenerAccess(false);
            Thread.sleep(500); // wait for listener to be disabled

            assertInaccessible(background7Uri);

        } finally {
            // Clean Up -- Cancel #7
            performNotificationProviderAction(""cancel-7"");
            Thread.sleep(500);
        }
    }

    private class NotificationListenerConnection implements ServiceConnection {
        private final Semaphore mSemaphore = new Semaphore(0);

        @Override
        public void onServiceConnected(ComponentName className, IBinder service) {
            mNotificationUriAccessService = INotificationUriAccessService.Stub.asInterface(service);
            mSemaphore.release();
        }

        @Override
        public void onServiceDisconnected(ComponentName className) {
            mNotificationUriAccessService = null;
        }

        public void waitForService() {
            try {
                if (mSemaphore.tryAcquire(5, TimeUnit.SECONDS)) {
                    return;
                }
            } catch (InterruptedException e) {
            }
            fail(""failed to connec to service"");
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/NotificationManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.NotificationManagerTest"	"testNotificationUriPermissionsRevokedOnlyFromRemovedListeners"	"CtsAppTestCases"	"1: permission"	"([6:/android/app/cts/NotificationManagerTest.java]:[permission]:[6]:method_text:[;        } catch (Exception e) {            throw new CompletionException(e);        }    }   ]) :|: public void testNotificationUriPermissionsRevokedOnlyFromRemovedListeners() throws Exception {
        Uri background7Uri = Uri.parse(
                ""content://com.android.test.notificationprovider.provider/background7.png"");

        // Connect to a service in the NotificationListener app which allows us to validate URI
        // permissions granted to a second app, so that we show that permissions aren't being
        // revoked too broadly.
        final Intent intent = new Intent();
        intent.setComponent(new ComponentName(""com.android.test.notificationlistener"",
                ""com.android.test.notificationlistener.NotificationUriAccessService""));
        NotificationListenerConnection connection = new NotificationListenerConnection();
        mContext.bindService(intent, connection, Context.BIND_AUTO_CREATE);
        connection.waitForService();

        // Before starting the test, make sure the service works, that there is no listener, and
        // that the URI starts inaccessible to that process.
        mNotificationUriAccessService.ensureNotificationListenerServiceConnected(false);
        assertFalse(mNotificationUriAccessService.isFileUriAccessible(background7Uri));

        // Give the NotificationListener app access to notifications, and validate that.
        toggleExternalListenerAccess(new ComponentName(""com.android.test.notificationlistener"",
                ""com.android.test.notificationlistener.TestNotificationListener""), true);
        Thread.sleep(500);
        mNotificationUriAccessService.ensureNotificationListenerServiceConnected(true);
        assertFalse(mNotificationUriAccessService.isFileUriAccessible(background7Uri));

        // Give the test app access to notifications, and get that listener
        toggleListenerAccess(true);
        Thread.sleep(500); // wait for listener to be allowed
        mListener = TestNotificationListener.getInstance();
        assertNotNull(mListener);

        try {
            try {"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/NotificationManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.NotificationManagerTest"	"testDemoteConversationChannel"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/NotificationManagerTest.java]:[permission]:[1]:method_text:[er.getNotificationChannel(                channel.getId(), conversationId).isDemoted());    }   ]) :|: public void testDemoteConversationChannel() {
        final NotificationChannel channel =
                new NotificationChannel(mId, ""Messages"", IMPORTANCE_DEFAULT);

        String conversationId = ""person a"";

        final NotificationChannel conversationChannel =
                new NotificationChannel(mId + ""child"",
                        ""Messages from "" + conversationId, IMPORTANCE_DEFAULT);
        conversationChannel.setConversationId(channel.getId(), conversationId);

        mNotificationManager.createNotificationChannel(channel);
        mNotificationManager.createNotificationChannel(conversationChannel);

        conversationChannel.setDemoted(true);

        SystemUtil.runWithShellPermissionIdentity(() ->
                mNotificationManager.updateNotificationChannel(
                        mContext.getPackageName(), android.os.Process.myUid(), channel));

        assertEquals(false, mNotificationManager.getNotificationChannel(
                channel.getId(), conversationId).isDemoted());
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/NotificationManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.NotificationManagerTest"	"testGrantRevokeNotificationManagerApis_works"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/cts/NotificationManagerTest.java]:[permission]:[1]:method_text:[tEnabledNotificationListeners(),                    hasItem(componentName));        });    }   ]) :|: public void testGrantRevokeNotificationManagerApis_works() {
        SystemUtil.runWithShellPermissionIdentity(() -> {
            ComponentName componentName = TestNotificationListener.getComponentName();
            mNotificationManager.setNotificationListenerAccessGranted(
                    componentName, true, true);

            assertThat(
                    mNotificationManager.getEnabledNotificationListeners(),
                    hasItem(componentName));

            mNotificationManager.setNotificationListenerAccessGranted(
                    componentName, false, false);

            assertThat(
                    ""Non-user-set changes should not override user-set"",
                    mNotificationManager.getEnabledNotificationListeners(),
                    hasItem(componentName));
        });
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/NotificationManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.cts.NotificationManagerTest"	"testGrantRevokeNotificationManagerApis_exclusiveToPermissionController"	"CtsAppTestCases"	"1: permission"	"([6:/android/app/cts/NotificationManagerTest.java]:[permission]:[6]:method_text:[            + Manifest.permission.MANAGE_NOTIFICATION_LISTENERS);            }        }    }   ]) :|: public void testGrantRevokeNotificationManagerApis_exclusiveToPermissionController() {
        List<PackageInfo> allPackages = mPackageManager.getInstalledPackages(
                PackageManager.MATCH_DISABLED_COMPONENTS
                        | PackageManager.MATCH_DISABLED_UNTIL_USED_COMPONENTS);
        List<String> allowedPackages = Arrays.asList(
                mPackageManager.getPermissionControllerPackageName(),
                ""com.android.shell"");
        for (PackageInfo pkg : allPackages) {
            if (!pkg.applicationInfo.isSystemApp()
                    && mPackageManager.checkPermission(
                            Manifest.permission.MANAGE_NOTIFICATION_LISTENERS, pkg.packageName)
                            == PackageManager.PERMISSION_GRANTED
                    && !allowedPackages.contains(pkg.packageName)) {
                fail(pkg.packageName + "" can't hold ""
                        + Manifest.permission.MANAGE_NOTIFICATION_LISTENERS);
            }
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/NotificationManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.people.cts.PeopleManagerTest"	"testIsConversationWithoutPermission"	"CtsAppTestCases"	"1: permission"	"([1:/android/app/people/cts/PeopleManagerTest.java]:[permission]:[1]:method_text:[ted SecurityException"");        } catch (Exception e) {            //expected        }    }   ]) :|: public void testIsConversationWithoutPermission() throws Exception {
        try {
            mPeopleManager.isConversation(mContext.getPackageName(), SHARE_SHORTCUT_ID);
            fail(""Expected SecurityException"");
        } catch (Exception e) {
            //expected
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/people/cts/PeopleManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.people.cts.PeopleManagerTest"	"testIsConversationWithPermission"	"CtsAppTestCases"	"1: permission"	"([4:/android/app/people/cts/PeopleManagerTest.java]:[permission]:[4]:method_text:[rumentation().getUiAutomation()                .dropShellPermissionIdentity();        }    }   ]) :|: public void testIsConversationWithPermission() throws Exception {
        try {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(""android.permission.READ_PEOPLE_DATA"");

            // Shortcut exists and has label
            assertTrue(mPeopleManager.isConversation(
                    mContext.getPackageName(), SHARE_SHORTCUT_ID));
            // Shortcut doesn't exist
            assertFalse(mPeopleManager.isConversation(
                    mContext.getPackageName(), SHARE_SHORTCUT_ID + 1));
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .dropShellPermissionIdentity();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/people/cts/PeopleManagerTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.app.stubs.LocalActivityManagerTestHelper"	"LocalActivityManagerTestHelper"	""	"1: permission"	"([1:/android/app/stubs/LocalActivityManagerTestHelper.java]:[permission]:[1]:method_text:[    private void pass() {        sResult.setResult(CTSResult.RESULT_OK);        finish();    }}]) :|: public void test/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License""); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package android.app.stubs;


import android.app.Activity;
import android.app.ActivityGroup;
import android.app.LocalActivityManager;
import android.content.Intent;
import android.os.Bundle;
import android.view.Window;

import com.android.compatibility.common.util.CTSResult;

public class LocalActivityManagerTestHelper extends ActivityGroup {

    public static final String ACTION_DISPATCH_RESUME = ""dispatchResume"";
    public static final String ACTION_START_ACTIVITY = ""startActivity"";
    public static final String ACTION_DISPATCH_CREATE = ""dispatchCreate"";
    public static final String ACTION_DISPATCH_STOP = ""dispatchStop"";
    public static final String ACTION_DISPATCH_PAUSE_TRUE = ""dispatchPauseTrue"";
    public static final String ACTION_DISPATCH_PAUSE_FALSE = ""dispatchPauseFalse"";
    public static final String ACTION_SAVE_INSTANCE_STATE = ""saveInstanceState"";
    public static final String ACTION_DISPATCH_DESTROY = ""dispatchDestroy"";
    public static final String ACTION_REMOVE_ALL_ACTIVITY = ""removeAllActivities"";

    private String mCurrentAction;
    private LocalActivityManager mLocalActivityManager;

    private static CTSResult sResult;

    public static void setResult(CTSResult cr) {
        sResult = cr;
    }

    public LocalActivityManagerTestHelper() {
        super();
    }

    @Override
    protected void onCreate(Bundle"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/app/app/src/android/app/stubs/LocalActivityManagerTestHelper.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.net.cts.legacy.api22.permission.NoNetworkStatePermissionTest"	"testStartUsingNetworkFeature"	"CtsNetTestCases"	"1: permission"	"([3:/android/net/cts/legacy/api22/permission/NoNetworkStatePermissionTest.java]:[permission]:[3]:method_text:[ssion:     *   {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.     */    @SmallTest   ]) :|: public void testStartUsingNetworkFeature() {
        try {
            mConnectivityManager.startUsingNetworkFeature(TEST_NETWORK_TYPE, TEST_FEATURE);
            fail(""ConnectivityManager.startUsingNetworkFeature didn't throw SecurityException as""
                    + "" expected"");
        } catch (SecurityException e) {
            // expected
        }
    }

    /**
     * Verify that ConnectivityManager#requestRouteToHost() requires permissions.
     * <p>Requires Permission:
     *   {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.
     */
    @SmallTest"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/netlegacy22.permission/src/android/net/cts/legacy/api22/permission/NoNetworkStatePermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.location.cts.privileged.GnssLocationValuesTest"	"dropShellPermissionIdentity"	"CtsLocationPrivilegedTestCases"	"1: permission"	"([3:/android/location/cts/privileged/GnssLocationValuesTest.java]:[permission]:[3]:method_text:[* 2. Get low-power GNSS locations.     * 3. Check whether all fields' value make sense.     */   ]) :|: public void test/*
 *.
 */

package android.location.cts.privileged;

import android.Manifest;
import android.location.Location;
import android.location.cts.common.GnssTestCase;
import android.location.cts.common.SoftAssert;
import android.location.cts.common.TestLocationListener;
import android.location.cts.common.TestLocationManager;
import android.location.cts.common.TestMeasurementUtil;
import android.os.Build;
import android.util.Log;

import androidx.test.InstrumentationRegistry;

import org.junit.Assert;

/**
 * Test the {@link Location} values.
 *
 * Test steps:
 * 1. Register for location updates.
 * 2. Wait for {@link #LOCATION_TO_COLLECT_COUNT} locations.
 *          3.1 Confirm locations have been found.
 * 3. Get LastKnownLocation, verified all fields are in the correct range.
 */
public class GnssLocationValuesTest extends GnssTestCase {

    private static final String TAG = ""GnssLocationValuesTest"";
    private static final int LOCATION_TO_COLLECT_COUNT = 5;
    private TestLocationListener mLocationListener;
    // TODO(b/65458848): Re-tighten the limit to 0.001 when sufficient devices in the market comply
    private static final double MINIMUM_SPEED_FOR_BEARING = 1.000;
    private static final int MIN_ANDROID_SDK_VERSION_REQUIRED = Build.VERSION_CODES.O;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(Manifest.permission.LOCATION_HARDWARE);
        mTestLocationManager = new TestLocationManager(getContext());
        mLocationListener = new TestLocationListener(LOCATION_TO_COLLECT_COUNT);
    }

    @Override
    protected void tearDown() throws Exception {
        // Unregister listeners
        if (mLocationListener != null) {
            mTestLocationManager.removeLocationUpdates(mLocationListener);
        }

        InstrumentationRegistry.getInstrumentation().getUiAutomation()"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/location/location_privileged/src/android/location/cts/privileged/GnssLocationValuesTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.location.cts.privileged.GnssMeasurementRequestTest"	"dropShellPermissionIdentity"	"CtsLocationPrivilegedTestCases"	"1: permission"	"([3:/android/location/cts/privileged/GnssMeasurementRequestTest.java]:[permission]:[3]:method_text:[tion()                .getUiAutomation()                .dropShellPermissionIdentity();    }   ]) :|: package android.location.cts.privileged;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import android.Manifest;
import android.content.Context;
import android.location.GnssMeasurementRequest;
import android.location.LocationManager;
import android.os.Parcel;

import androidx.test.core.app.ApplicationProvider;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.platform.app.InstrumentationRegistry;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Tests fundamental functionality of {@link GnssMeasurementRequest} class. This includes writing
 * and reading from parcel, and verifying computed values and getters.
 */
@RunWith(AndroidJUnit4.class)
public class GnssMeasurementRequestTest {

    private Context mContext;
    private LocationManager mLocationManager;

    @Before
    public void setUp() throws Exception {
        mContext = ApplicationProvider.getApplicationContext();
        mLocationManager = mContext.getSystemService(LocationManager.class);
        assertNotNull(mLocationManager);

        InstrumentationRegistry.getInstrumentation()
                .getUiAutomation()
                .adoptShellPermissionIdentity(Manifest.permission.LOCATION_HARDWARE);
    }

    @After
    public void tearDown() throws Exception {
        InstrumentationRegistry.getInstrumentation()
                .getUiAutomation()
                .dropShellPermissionIdentity();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/location/location_privileged/src/android/location/cts/privileged/GnssMeasurementRequestTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.location.cts.privileged.PrivilegedLocationPermissionTest"	"dropShellPermissionIdentity"	"CtsLocationPrivilegedTestCases"	"1: permission"	"([4:/android/location/cts/privileged/PrivilegedLocationPermissionTest.java]:[permission]:[4]:method_text:[ry.getInstrumentation().getUiAutomation()                .dropShellPermissionIdentity();    }   ]) :|: /*
 *.
 */

package android.location.cts.privileged;

import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.assertNotNull;

import android.Manifest;
import android.content.Context;
import android.location.LocationManager;
import android.os.Build.VERSION;
import android.os.Build.VERSION_CODES;

import androidx.test.core.app.ApplicationProvider;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.platform.app.InstrumentationRegistry;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;


@RunWith(AndroidJUnit4.class)
public class PrivilegedLocationPermissionTest {

    private Context mContext;
    private LocationManager mLocationManager;

    @Before
    public void setUp() throws Exception {
        mContext = ApplicationProvider.getApplicationContext();
        mLocationManager = mContext.getSystemService(LocationManager.class);
        assertNotNull(mLocationManager);

        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(Manifest.permission.LOCATION_HARDWARE);
    }

    @After
    public void tearDown() throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .dropShellPermissionIdentity();
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/location/location_privileged/src/android/location/cts/privileged/PrivilegedLocationPermissionTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.location.cts.privileged.GnssMeasurementRegistrationTest"	"dropShellPermissionIdentity"	"CtsLocationPrivilegedTestCases"	"1: permission"	"([3:/android/location/cts/privileged/GnssMeasurementRegistrationTest.java]:[permission]:[3]:method_text:[();    }    /**     * Test GPS measurements registration with full tracking enabled.     */   ]) :|: public void test/*
 *.
 */

package android.location.cts.privileged;

import android.Manifest;
import android.location.GnssMeasurementRequest;
import android.location.GnssMeasurementsEvent;
import android.location.GnssRequest;
import android.location.Location;
import android.location.cts.common.GnssTestCase;
import android.location.cts.common.SoftAssert;
import android.location.cts.common.TestGnssMeasurementListener;
import android.location.cts.common.TestLocationListener;
import android.location.cts.common.TestLocationManager;
import android.location.cts.common.TestMeasurementUtil;
import android.util.Log;

import androidx.test.InstrumentationRegistry;

import java.util.List;

/**
 * Test for {@link GnssMeasurementsEvent.Callback} registration.
 *
 * Test steps:
 * 1. Register a listener for {@link GnssMeasurementsEvent}s.
 * 2. Check {@link GnssMeasurementsEvent} status: if the status is not
 *    {@link GnssMeasurementsEvent.Callback#STATUS_READY}, the test will fail and because one of
 *    the following reasons:
 *          2.1 the device does not support the feature,
 *          2.2 Location or GPS is disabled in the device.
 * 3. If at least one {@link GnssMeasurementsEvent} is received, the test will pass.
 * 4. If no {@link GnssMeasurementsEvent} are received, then check if the device can receive
 *    measurements only when {@link Location} is requested. This is done by performing the following
 *    steps:
 *          4.1 Register for location updates.
 *          4.2 Wait for {@link TestLocationListener#onLocationChanged(Location)}}.
 *          4.3 If at least one {@link GnssMeasurementsEvent} is received, the test will pass.
 *          4.4 If no {@link Location} is received this will mean that the device is located
 *              indoor. If we receive a {@link Location}, it mean that
 *              {@link GnssMeasurementsEvent}s are provided only if the application registers for
 *              location updates as well.
 */
public class GnssMeasurem"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/location/location_privileged/src/android/location/cts/privileged/GnssMeasurementRegistrationTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.location.cts.privileged.GnssMeasurementValuesTest"	"dropShellPermissionIdentity"	"CtsLocationPrivilegedTestCases"	"1: permission"	"([3:/android/location/cts/privileged/GnssMeasurementValuesTest.java]:[permission]:[3]:method_text:[or the measurements received.     * This tests uses actual data retrieved from GPS HAL.     */   ]) :|: package android.location.cts.privileged;

import static org.junit.Assert.assertNotNull;

import android.Manifest;
import android.content.Context;
import android.location.GnssCapabilities;
import android.location.GnssMeasurement;
import android.location.GnssMeasurementRequest;
import android.location.GnssMeasurementsEvent;
import android.location.cts.common.SoftAssert;
import android.location.cts.common.TestGnssMeasurementListener;
import android.location.cts.common.TestLocationListener;
import android.location.cts.common.TestLocationManager;
import android.location.cts.common.TestMeasurementUtil;
import android.util.Log;

import androidx.test.core.app.ApplicationProvider;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.platform.app.InstrumentationRegistry;

import java.util.List;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Test the {@link GnssMeasurement} values.
 *
 * 1. Register for location updates.
 * 2. Register a listener for {@link GnssMeasurementsEvent}s.
 * 3. Wait for {@link #LOCATION_TO_COLLECT_COUNT} locations.
 *        3.1 Confirm locations have been found.
 * 4. Check {@link GnssMeasurementsEvent} status: if the status is not
 *    {@link GnssMeasurementsEvent.Callback#STATUS_READY}, the test will be skipped if the device
 *    does not support the GPS feature.
 * 5. Verify {@link GnssMeasurement}s, the test will fail if any of the fields is not populated
 *    or in the expected range.
 */
@RunWith(AndroidJUnit4.class)
public class GnssMeasurementValuesTest {

    private static final String TAG = ""GnssMeasValuesTest"";
    private static final int LOCATION_TO_COLLECT_COUNT = 20;

    private Context mContext;
    private TestGnssMeasurementListener mMeasurementListener;
    private TestLocationListener mLocationListener;
    private TestLocationManager mTestLocationManager;

    @Before
    public void setUp() throws Exception {
        mContext = Applica"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/location/location_privileged/src/android/location/cts/privileged/GnssMeasurementValuesTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.location.cts.fine.LocationManagerFineTest"	"currentTimeMillis"	"CtsLocationFineTestCases"	"1: permission"	"([1:/android/location/cts/fine/LocationManagerFineTest.java]:[permission]:[1]:method_text:[ LocationUtils.registerMockLocationProvider(getInstrumentation(),                false);    }   ]) :|: /*
 *.
 */

package android.location.cts.fine;

import static android.Manifest.permission.WRITE_SECURE_SETTINGS;
import static android.content.pm.PackageManager.FEATURE_AUTOMOTIVE;
import static android.location.LocationManager.EXTRA_PROVIDER_ENABLED;
import static android.location.LocationManager.EXTRA_PROVIDER_NAME;
import static android.location.LocationManager.FUSED_PROVIDER;
import static android.location.LocationManager.GPS_PROVIDER;
import static android.location.LocationManager.NETWORK_PROVIDER;
import static android.location.LocationManager.PASSIVE_PROVIDER;
import static android.location.LocationManager.PROVIDERS_CHANGED_ACTION;
import static android.location.LocationRequest.PASSIVE_INTERVAL;
import static android.os.PowerManager.LOCATION_MODE_ALL_DISABLED_WHEN_SCREEN_OFF;
import static android.os.PowerManager.LOCATION_MODE_GPS_DISABLED_WHEN_SCREEN_OFF;
import static android.os.PowerManager.LOCATION_MODE_THROTTLE_REQUESTS_WHEN_SCREEN_OFF;

import static androidx.test.ext.truth.content.IntentSubject.assertThat;
import static androidx.test.ext.truth.location.LocationSubject.assertThat;
import static androidx.test.platform.app.InstrumentationRegistry.getInstrumentation;

import static com.android.compatibility.common.util.LocationUtils.createLocation;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeFalse;
import static org.junit.Assume.assumeTrue;

import android.Manifest;
import android.annotation.NonNull;
import android.app.AppOpsManager;
import android.app.PendingIntent;
import android.app.UiAutomation;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.location.Criteria;
import android.location.GnssMeasurementsEvent;
import android.location.GnssNavigationMessage;
import android.location.GnssStatus;
import android.locati"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/location/location_fine/src/android/location/cts/fine/LocationManagerFineTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.location.cts.fine.LocationManagerFineTest"	"testRequestLocationUpdates_LocationSettingsIgnored"	"CtsLocationFineTestCases"	"1: permission"	"([2:/android/location/cts/fine/LocationManagerFineTest.java]:[permission]:[2]:method_text:[        assertThat(capture.getNextLocation(FAILURE_TIMEOUT_MS)).isEqualTo(loc);        }    }   ]) :|: 
    public void testRequestLocationUpdates_LocationSettingsIgnored() throws Exception {
        try (LocationListenerCapture capture = new LocationListenerCapture(mContext);
             DeviceConfigStateHelper locationDeviceConfigStateHelper =
                     new DeviceConfigStateHelper(DeviceConfig.NAMESPACE_LOCATION)) {

            locationDeviceConfigStateHelper.set(IGNORE_SETTINGS_ALLOWLIST,
                    mContext.getPackageName());

            getInstrumentation().getUiAutomation()
                    .adoptShellPermissionIdentity(WRITE_SECURE_SETTINGS);
            try {
                mManager.requestLocationUpdates(
                        TEST_PROVIDER,
                        new LocationRequest.Builder(0)
                                .setLocationSettingsIgnored(true)
                                .build(),
                        Executors.newSingleThreadExecutor(),
                        capture);
            } finally {
                getInstrumentation().getUiAutomation().dropShellPermissionIdentity();
            }

            // turn off provider
            mManager.setTestProviderEnabled(TEST_PROVIDER, false);

            // test that all restrictions are bypassed
            Location loc = createLocation(TEST_PROVIDER, mRandom);
            mManager.setTestProviderLocation(TEST_PROVIDER, loc);
            assertThat(capture.getNextLocation(FAILURE_TIMEOUT_MS)).isEqualTo(loc);
            loc = createLocation(TEST_PROVIDER, mRandom);
            mManager.setTestProviderLocation(TEST_PROVIDER, loc);
            assertThat(capture.getNextLocation(FAILURE_TIMEOUT_MS)).isEqualTo(loc);
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/location/location_fine/src/android/location/cts/fine/LocationManagerFineTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.location.cts.fine.LocationManagerFineTest"	"testAddProviderRequestListener"	"CtsLocationFineTestCases"	"1: permission"	"([3:/android/location/cts/fine/LocationManagerFineTest.java]:[permission]:[3]:method_text:[ntation().getUiAutomation()                    .dropShellPermissionIdentity();        }    }   ]) :|: 
    public void testAddProviderRequestListener() throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(Manifest.permission.LOCATION_HARDWARE);

        try (ProviderRequestChangedListenerCapture requestlistener =
                     new ProviderRequestChangedListenerCapture(mContext);
             LocationListenerCapture locationListener = new LocationListenerCapture(mContext)) {
            mManager.addProviderRequestChangedListener(Executors.newSingleThreadExecutor(),
                    requestlistener);
            mManager.requestLocationUpdates(TEST_PROVIDER, 0, 0,
                    Executors.newSingleThreadExecutor(), locationListener);

            assertThat(requestlistener.getNextProviderRequest(TIMEOUT_MS)).isNotNull();
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                    .dropShellPermissionIdentity();
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/location/location_fine/src/android/location/cts/fine/LocationManagerFineTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.location.cts.fine.LocationManagerFineTest"	"testRequestGpsUpdates_B9758659"	"CtsLocationFineTestCases"	"1: permission"	"([1:/android/location/cts/fine/LocationManagerFineTest.java]:[permission]:[1]:method_text:[hat(location.distanceTo(networkLocation)).isGreaterThan(1000.0f);            }        }    }   ]) :|: 
    @AppModeFull(reason = ""Instant apps can't hold ACCESS_LOCATION_EXTRA_COMMANDS permission"")
    public void testRequestGpsUpdates_B9758659() throws Exception {
        assumeTrue(mManager.hasProvider(GPS_PROVIDER));

        // test for b/9758659, where the gps provider may reuse network provider positions creating
        // an unnatural feedback loop
        assertThat(mManager.isProviderEnabled(GPS_PROVIDER)).isTrue();

        Location networkLocation = createLocation(NETWORK_PROVIDER, mRandom);

        mManager.addTestProvider(NETWORK_PROVIDER,
                false,
                false,
                false,
                false,
                true,
                true,
                true,
                Criteria.POWER_LOW,
                Criteria.ACCURACY_COARSE);
        mManager.setTestProviderEnabled(NETWORK_PROVIDER, true);
        mManager.setTestProviderLocation(NETWORK_PROVIDER, networkLocation);

        // reset gps provider to give it a cold start scenario
        mManager.sendExtraCommand(GPS_PROVIDER, ""delete_aiding_data"", null);

        try (LocationListenerCapture capture = new LocationListenerCapture(mContext)) {
            mManager.requestLocationUpdates(
                    GPS_PROVIDER,
                    new LocationRequest.Builder(0).build(),
                    Executors.newSingleThreadExecutor(),
                    capture);

            Location location = capture.getNextLocation(TIMEOUT_MS);
            if (location != null) {
                assertThat(location.distanceTo(networkLocation)).isGreaterThan(1000.0f);
            }
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/location/location_fine/src/android/location/cts/fine/LocationManagerFineTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.location.cts.fine.LocationManagerFineTest"	"testSendExtraCommand"	"CtsLocationFineTestCases"	"1: permission"	"([1:/android/location/cts/fine/LocationManagerFineTest.java]:[permission]:[1]:method_text:[null!"");        } catch (IllegalArgumentException e) {            // expected        }    }   ]) :|: 
    @AppModeFull(reason = ""Instant apps can't hold ACCESS_LOCATION_EXTRA_COMMANDS permission"")
    public void testSendExtraCommand() {
        for (String provider : mManager.getAllProviders()) {
            boolean res = mManager.sendExtraCommand(provider, ""dontCrash"", null);
            assertThat(res).isTrue();

            try {
                mManager.sendExtraCommand(provider, null, null);
                fail(""Should throw IllegalArgumentException if command is null!"");
            } catch (IllegalArgumentException e) {
                // expected
            }
        }

        try {
            mManager.sendExtraCommand(null, ""crash"", null);
            fail(""Should throw IllegalArgumentException if provider is null!"");
        } catch (IllegalArgumentException e) {
            // expected
        }
    }"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/location/location_fine/src/android/location/cts/fine/LocationManagerFineTest.java"	""	""	""
"9.1  . Permissions"	"9.1"	"C-4-2"	"9.1/C-4-2"	"permission.INTERNET managed_users Intelligence"	"""android.software.managed_users MUST NOT have android.permission.INTERNET permission"""	""	"android.location.cts.fine.LocationManagerFineTest"	"testRequestLocationUpdatesNoteOps_simultaneousRequests"	"CtsLocationFineTestCases"	"1: permission permission"	"([6:/android/location/cts/fine/LocationManagerFineTest.java]:[permission]:[6]:method_text:[        }        } finally {            automation.dropShellPermissionIdentity();        }    }]) :|: 
    public void testRequestLocationUpdatesNoteOps_simultaneousRequests() {
        Context attributionContextFast =
                mContext.createAttributionContext(VALID_LOCATION_ATTRIBUTION_TAG);
        Context attributionContextSlow =
                mContext.createAttributionContext(ANOTHER_VALID_LOCATION_ATTRIBUTION_TAG);
        Location loc1 = createLocation(TEST_PROVIDER, mRandom);
        Location loc2 = createLocation(TEST_PROVIDER, mRandom);

        try (LocationListenerCapture fastCapture =
                     new LocationListenerCapture(attributionContextFast);
             LocationListenerCapture slowCapture =
                     new LocationListenerCapture(attributionContextSlow)) {
            attributionContextFast
                    .getSystemService(LocationManager.class)
                    .requestLocationUpdates(
                            TEST_PROVIDER,
                            new LocationRequest.Builder(0).build(),
                            Runnable::run,
                            fastCapture);
            attributionContextSlow
                    .getSystemService(LocationManager.class)
                    .requestLocationUpdates(
                            TEST_PROVIDER,
                            new LocationRequest.Builder(600000).build(),
                            Runnable::run,
                            slowCapture);

            // Set initial location.
            long timeBeforeLocationAccess = System.currentTimeMillis();
            mManager.setTestProviderLocation(TEST_PROVIDER, loc1);
            assertNotedOpsSinceLastLocationAccess(
                    timeBeforeLocationAccess,
                    /* expectedOp */ AppOpsManager.OPSTR_FINE_LOCATION,
                    /* unexpectedOp */ AppOpsManager.OPSTR_FINE_LOCATION_SOURCE,
                   VALID_LOCATION_ATTRIBUTION_TAG);

            // Verify noteOp for the fast request.
            timeBeforeLocationAccess = System.currentTimeMillis();"	"9.1/C-4-2 INTERNET android.permission.INTERNET Intelligence permission.INTERNET android.software.managed android.software.managed_users managed_users 9.1 permission re_tag:(?<!/)C\-4\-2"	"/home/gpoor/cts-12-source/cts/tests/location/location_fine/src/android/location/cts/fine/LocationManagerFineTest.java"	""	""	""
