"Section"	"section_id"	"req_id"	"full_key"	"manual_search_terms"	"requirement"	"Test Availability"	"class_def"	"method"	"module"	"matched_terms"	"methods_string"	"file_name"	"Comment(internal) e.g. why a test is not possible"	"CTS Bug Id"	"Test Level"
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"test.java.com.android.eventlib.premade.EventLibDeviceAdminReceiverTest"	"TestApis"	""	"2: system user"	"/*
 *.
 */

package com.android.eventlib.premade;

import static com.google.common.truth.Truth.assertThat;

import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;

import com.android.bedstead.nene.TestApis;
import com.android.bedstead.nene.devicepolicy.DeviceOwner;
import com.android.bedstead.nene.devicepolicy.ProfileOwner;
import com.android.bedstead.nene.users.UserReference;
import com.android.eventlib.EventLogs;
import com.android.eventlib.events.deviceadminreceivers.DeviceAdminDisableRequestedEvent;
import com.android.eventlib.events.deviceadminreceivers.DeviceAdminDisabledEvent;
import com.android.eventlib.events.deviceadminreceivers.DeviceAdminEnabledEvent;
import com.android.eventlib.events.deviceadminreceivers.DeviceAdminPasswordChangedEvent;
import com.android.eventlib.events.deviceadminreceivers.DeviceAdminPasswordFailedEvent;
import com.android.eventlib.events.deviceadminreceivers.DeviceAdminPasswordSucceededEvent;
import com.android.eventlib.events.deviceadminreceivers.DeviceAdminSystemUpdatePendingEvent;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

@RunWith(JUnit4.class)
public class EventLibDeviceAdminReceiverTest {

    private static final TestApis sTestApis = new TestApis();
    private static final Context sContext = sTestApis.context().instrumentedContext();
    private static final ComponentName DEVICE_ADMIN_COMPONENT =
            new ComponentName(
                    sContext.getPackageName(), EventLibDeviceAdminReceiver.class.getName());
    private static final UserReference sUser = sTestApis.users().instrumented();
    private static final DevicePolicyManager sDevicePolicyManager =
            sContext.getSystemService(DevicePolicyManager.class);
    private static final Intent sIntent = new Intent();

    @Before
    public void setUp() {
        EventLogs.resetLogs();
    }"	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/eventlib/src/test/java/com/android/eventlib/premade/EventLibDeviceAdminReceiverTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"test.java.com.android.eventlib.premade.EventLibDeviceAdminReceiverTest"	"currentTimeMillis"	""	"1: system"	"public void systemUpdatePending_logsSystemUpdatePendingEvent() {
        EventLibDeviceAdminReceiver receiver = new EventLibDeviceAdminReceiver();
        long receivedTime = System.currentTimeMillis();

        receiver.onSystemUpdatePending(sContext, sIntent, receivedTime);

        EventLogs<DeviceAdminSystemUpdatePendingEvent> eventLogs =
                DeviceAdminSystemUpdatePendingEvent.queryPackage(sContext.getPackageName());
        assertThat(eventLogs.poll().receivedTime()).isEqualTo(receivedTime);
    }
}"	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/eventlib/src/test/java/com/android/eventlib/premade/EventLibDeviceAdminReceiverTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"test.java.com.android.eventlib.premade.EventLibDeviceAdminReceiverTest"	"isNotNull"	""	"1: user user"	"public void enableProfileOwner_logsEnabledEvent() {
        ProfileOwner profileOwner =
                sTestApis.devicePolicy().setProfileOwner(sUser, DEVICE_ADMIN_COMPONENT);

        try {
            EventLogs<DeviceAdminEnabledEvent> eventLogs =
                    DeviceAdminEnabledEvent.queryPackage(sContext.getPackageName());

            assertThat(eventLogs.poll()).isNotNull();
        } finally {
            profileOwner.remove();
        }
    }"	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/eventlib/src/test/java/com/android/eventlib/premade/EventLibDeviceAdminReceiverTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.vr.cts.VrFeaturesTest"	"testSustainedPerformanceModeSupported"	"CtsVrTestCases"	"2: ui system"	"public void testSustainedPerformanceModeSupported() {
        mActivity = getActivity();
        PowerManager pm = (PowerManager) mActivity.getSystemService(Context.POWER_SERVICE);
        boolean hasVrModeHighPerf = mActivity.getPackageManager().hasSystemFeature(
                PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE);
        boolean hasSustainedPerformanceMode = pm.isSustainedPerformanceModeSupported();
        if (hasVrModeHighPerf) {
            assertTrue(""FEATURE_VR_MODE_HIGH_PERFORMANCE requires support for sustained performance mode"",
                    hasSustainedPerformanceMode);
        }
    }
}"	"/home/gpoor/cts-12-source/cts/tests/vr/src/android/vr/cts/VrFeaturesTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.vr.cts.VrFeaturesTest"	"testLacksDeprecatedVrModeFeature"	"CtsVrTestCases"	"1: system"	"public void testLacksDeprecatedVrModeFeature() {
        mActivity = getActivity();
        boolean hasVrMode = mActivity.getPackageManager().hasSystemFeature(
                PackageManager.FEATURE_VR_MODE);
        boolean hasVrModeHighPerf = mActivity.getPackageManager().hasSystemFeature(
                PackageManager.FEATURE_VR_MODE_HIGH_PERFORMANCE);
        if (hasVrMode || hasVrModeHighPerf) {
            assertTrue(""FEATURE_VR_MODE and FEATURE_VR_MODE_HIGH_PERFORMANCE must be used together"",
                    hasVrMode && hasVrModeHighPerf);
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/vr/src/android/vr/cts/VrFeaturesTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.content.pm.cts.InstantAppTest"	"testInstantAppResolverQuery"	"CtsContentTestCases"	"2: direct system"	"public void testInstantAppResolverQuery() {
        final Intent resolverIntent = new Intent(Intent.ACTION_RESOLVE_INSTANT_APP_PACKAGE);
        final int resolveFlags =
                MATCH_DIRECT_BOOT_AWARE
                | MATCH_DIRECT_BOOT_UNAWARE
                | MATCH_SYSTEM_ONLY;
        final List<ResolveInfo> matches =
                mPackageManager.queryIntentServices(resolverIntent, resolveFlags);
        assertTrue(matches == null || matches.size() <= 1);
    }

    /** Ensure only one resolver is defined */"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/InstantAppTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.content.pm.cts.InstantAppTest"	"testInstantAppInstallerQuery"	"CtsContentTestCases"	"2: direct system"	"public void testInstantAppInstallerQuery() {
        final Intent intent = new Intent(Intent.ACTION_INSTALL_INSTANT_APP_PACKAGE);
        intent.addCategory(Intent.CATEGORY_DEFAULT);
        intent.setDataAndType(Uri.fromFile(new File(""foo.apk"")), PACKAGE_MIME_TYPE);
        final int resolveFlags =
                MATCH_DIRECT_BOOT_AWARE
                | MATCH_DIRECT_BOOT_UNAWARE
                | MATCH_SYSTEM_ONLY;
        final List<ResolveInfo> matches =
                mPackageManager.queryIntentActivities(intent, resolveFlags);
        assertTrue(matches == null || matches.size() <= 1);
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/pm/cts/InstantAppTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.mediadrm.cts.MediaDrmClearkeyTest"	"MediaDrmClearkeyTest"	"CtsMediaDrmTestCases"	"2: ui system"	"public void test/*
 *.
 */
package android.mediadrm.cts;

import android.media.MediaCodecInfo.CodecCapabilities;
import android.media.MediaDrm;
import android.media.MediaDrm.KeyStatus;
import android.media.MediaDrm.MediaDrmStateException;
import android.media.MediaDrmException;
import android.media.MediaFormat;
import android.media.NotProvisionedException;
import android.media.ResourceBusyException;
import android.media.UnsupportedSchemeException;
import android.media.cts.AudioManagerStub;
import android.media.cts.AudioManagerStubHelper;
import android.media.cts.CodecState;
import android.media.cts.ConnectionStatus;
import android.media.cts.IConnectionStatus;
import android.media.cts.InputSurface;
import android.media.cts.InputSurfaceInterface;
import android.media.cts.MediaCodecClearKeyPlayer;
import android.media.cts.MediaCodecPlayerTestBase;
import android.media.cts.MediaCodecWrapper;
import android.media.cts.MediaTimeProvider;
import android.media.cts.MediaStubActivity;
import android.media.cts.NdkInputSurface;
import android.media.cts.NdkMediaCodec;
import android.media.cts.TestUtils.Monitor;
import android.net.Uri;
import android.os.Build;
import android.os.Looper;
import android.platform.test.annotations.Presubmit;
import android.util.Base64;
import android.util.Log;

import android.view.Surface;

import com.android.compatibility.common.util.ApiLevelUtil;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Set;
import java.util.UUID;
import java.util.Vector;

import androidx.annotation.NonNull;
import androidx.test.filters.SdkSuppress;


/**
 * Tests of MediaPlayer streaming capabilities.
 */
public class MediaDrmClearkeyTest extends MediaCodecPlayerTestBase<MediaStubActivity> {

    private static final String TAG = MediaDrmClearkeyTest.class.getSimpleName();

    // Add additional keys here if the content has more keys.
    private static final byte[] CLEAR_KEY_CENC = {
            (byte)0x3f, (byte)0x0a, (byte)0x33, (byte)0xf3, (byte)0x40, (byte)0x98, (byte)0xb9, (byte)0xe2,
            (byte)0x2b, (byte)0xc0, (byte)0x78, (byte)0xe0, (byte)0xa1, (byte)0xb5, (byte)0xe8, (byte)0x54 };

    private static final byte[] CLEAR_KEY_WEBM = ""_CLEAR_KEY_WEBM_"".getBytes();

    private static final int NUMBER_OF_SECURE_STOPS = 10;
    private static final int VIDEO_WIDTH_CENC = 1280;
    private static final int VIDEO_HEIGHT_CENC = 720;
    private static final int VIDEO_WIDTH_WEBM = 352;
    private static final int VIDEO_HEIGHT_WEBM = 288;
    private static final int VIDEO_WIDTH_MPEG2TS = 320;
    private static final int VIDEO_HEIGHT_MPEG2TS = 240;
    private static final String MIME_VIDEO_AVC = MediaFormat.MIMETYPE_VIDEO_AVC;
    private static final String MIME_VIDEO_VP8 = MediaFormat.MIMETYPE_VIDEO_VP8;

    // Property Keys
    private static final String ALGORITHMS_PROPERTY_KEY = MediaDrm.PROPERTY_ALGORITHMS;
    private static final String DESCRIPTION_PROPERTY_KEY = MediaDrm.PROPERTY_DESCRIPTION;
    private static final String DEVICEID_PROPERTY_KEY = ""deviceId"";
    private static final String INVALID_PROPERTY_KEY = ""invalid property key"";
    private static final String LISTENER_TEST_SUPPORT_PROPERTY_KEY = ""listenerTestSupport"";
    private static final String VENDOR_PROPERTY_KEY = MediaDrm.PROPERTY_VENDOR;
    private static final String VERSION_PROPERTY_KEY = MediaDrm.PROPERTY_VERSION;

    // Error message
    private static final String ERR_MSG_CRYPTO_SCHEME_NOT_SUPPORTED = ""Crypto scheme is not supported"";

    private static final String CENC_AUDIO_PATH = ""/clear/h264/llama/llama_aac_audio.mp4"";
    private static final String CENC_VIDEO_PATH = ""/clearkey/llama_h264_main_720p_8000.mp4"";
    private static final Uri WEBM_URL = Uri.parse(
            ""android.resource://android.mediadrm.cts/"" + R.raw.video_320x240_webm_vp8_800kbps_30fps_vorbis_stereo_128kbps_44100hz_crypt);
    private static final Uri MPEG2TS_SCRAMBLED_URL = Uri.parse(
            ""android.resource://android.mediadrm.cts/"" + R.raw.segment000001_scrambled);
    private static final Uri MPEG2TS_CLEAR_URL = Uri.parse(
            ""android.resource://android.mediadrm.cts/"" + R.raw.segment000001);

    private static final UUID COMMON_PSSH_SCHEME_UUID =
            new UUID(0x1077efecc0b24d02L, 0xace33c1e52e2fb4bL);
    private static final UUID CLEARKEY_SCHEME_UUID =
            new UUID(0xe2719d58a985b3c9L, 0x781ab030af78d30eL);

    private byte[] mDrmInitData;
    private byte[] mKeySetId;
    private byte[] mSessionId;
    private Monitor mSessionMonitor = new Monitor();
    private Looper mLooper;
    private MediaDrm mDrm = null;
    private final Object mLock = new Object();
    private boolean mEventListenerCalled;
    private boolean mExpirationUpdateReceived;
    private boolean mLostStateReceived;

    private static boolean sIsAtLeastS = ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S);

    public MediaDrmClearkeyTest() {
        super(MediaStubActivity.class);
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        if (false == deviceHasMediaDrm()) {
            tearDown();
        }
    }

    @Override
    protected void tearDown() throws Exception {
        super.tearDown();
    }

    private boolean deviceHasMediaDrm() {
        // ClearKey is introduced after KitKat.
        if (ApiLevelUtil.isAtMost(android.os.Build.VERSION_CODES.KITKAT)) {
            return false;
        }
        return true;
    }

    /**
     * Extracts key ids from the pssh blob returned by getKeyRequest() and
     * places it in keyIds.
     * keyRequestBlob format (section 5.1.3.1):
     * https://dvcs.w3.org/hg/html-media/raw-file/default/encrypted-media/encrypted-media.html#clear-key
     *
     * @return size of keyIds vector that contains the key ids, 0 for error
     */
    private static int getKeyIds(byte[] keyRequestBlob, Vector<String> keyIds) {
        if (0 == keyRequestBlob.length || keyIds == null)
            return 0;

        String jsonLicenseRequest = new String(keyRequestBlob);
        keyIds.clear();

        try {
            JSONObject license = new JSONObject(jsonLicenseRequest);
            final JSONArray ids = license.getJSONArray(""kids"");
            for (int i = 0; i < ids.length(); ++i) {
                keyIds.add(ids.getString(i));
            }
        } catch (JSONException e) {
            Log.e(TAG, ""Invalid JSON license = "" + jsonLicenseRequest);
            return 0;
        }
        return keyIds.size();
    }

    /**
     * Creates the JSON Web Key string.
     *
     * @return JSON Web Key string.
     */
    private static String createJsonWebKeySet(
            Vector<String> keyIds, Vector<String> keys, int keyType) {
        String jwkSet = ""{\""keys\"":["";
        for (int i = 0; i < keyIds.size(); ++i) {
            String id = new String(keyIds.get(i).getBytes(Charset.forName(""UTF-8"")));
            String key = new String(keys.get(i).getBytes(Charset.forName(""UTF-8"")));

            jwkSet += ""{\""kty\"":\""oct\"",\""kid\"":\"""" + id +
                    ""\"",\""k\"":\"""" + key + ""\""}"";
        }
        jwkSet += ""], \""type\"":"";
        if (keyType == MediaDrm.KEY_TYPE_OFFLINE || keyType == MediaDrm.KEY_TYPE_RELEASE) {
            jwkSet += ""\""persistent-license\"" }"";
        } else {
            jwkSet += ""\""temporary\"" }"";
        }
        return jwkSet;
    }

    /**
     * Retrieves clear key ids from getKeyRequest(), create JSON Web Key
     * set and send it to the CDM via provideKeyResponse().
     *
     * @return key set ID
     */
    public static byte[] retrieveKeys(MediaDrm drm, String initDataType,
            byte[] sessionId, byte[] drmInitData, int keyType, byte[][] clearKeyIds) {
        MediaDrm.KeyRequest drmRequest = null;
        try {
            drmRequest = drm.getKeyRequest(sessionId, drmInitData, initDataType,
                    keyType, null);
        } catch (Exception e) {
            e.printStackTrace();
            Log.i(TAG, ""Failed to get key request: "" + e.toString());
        }
        if (drmRequest == null) {
            Log.e(TAG, ""Failed getKeyRequest"");
            return null;
        }

        Vector<String> keyIds = new Vector<String>();
        if (0 == getKeyIds(drmRequest.getData(), keyIds)) {
            Log.e(TAG, ""No key ids found in initData"");
            return null;
        }

        if (clearKeyIds.length != keyIds.size()) {
            Log.e(TAG, ""Mismatch number of key ids and keys: ids="" +
                    keyIds.size() + "", keys="" + clearKeyIds.length);
            return null;
        }

        // Base64 encodes clearkeys. Keys are known to the application.
        Vector<String> keys = new Vector<String>();
        for (int i = 0; i < clearKeyIds.length; ++i) {
            String clearKey = Base64.encodeToString(clearKeyIds[i],
                    Base64.NO_PADDING | Base64.NO_WRAP);
            keys.add(clearKey);
        }

        String jwkSet = createJsonWebKeySet(keyIds, keys, keyType);
        byte[] jsonResponse = jwkSet.getBytes(Charset.forName(""UTF-8""));

        try {
            try {
                return drm.provideKeyResponse(sessionId, jsonResponse);
            } catch (IllegalStateException e) {
                Log.e(TAG, ""Failed to provide key response: "" + e.toString());
            }
        } catch (Exception e) {
            e.printStackTrace();
            Log.e(TAG, ""Failed to provide key response: "" + e.toString());
        }
        return null;
    }

    /**
     * Retrieves clear key ids from getKeyRequest(), create JSON Web Key
     * set and send it to the CDM via provideKeyResponse().
     */
    private void getKeys(MediaDrm drm, String initDataType,
            byte[] sessionId, byte[] drmInitData, int keyType, byte[][] clearKeyIds) {
        mKeySetId = retrieveKeys(drm, initDataType, sessionId, drmInitData, keyType, clearKeyIds);
    }

    private @NonNull MediaDrm startDrm(final byte[][] clearKeyIds, final String initDataType,
                                       final UUID drmSchemeUuid, int keyType) {
        if (!MediaDrm.isCryptoSchemeSupported(drmSchemeUuid)) {
            throw new Error(ERR_MSG_CRYPTO_SCHEME_NOT_SUPPORTED);
        }

        new Thread() {
            @Override
            public void run() {
                if (mDrm != null) {
                    Log.e(TAG, ""Failed to startDrm: already started"");
                    return;
                }
                // Set up a looper to handle events
                Looper.prepare();

                // Save the looper so that we can terminate this thread
                // after we are done with it.
                mLooper = Looper.myLooper();

                try {
                    mDrm = new MediaDrm(drmSchemeUuid);
                } catch (MediaDrmException e) {
                    Log.e(TAG, ""Failed to create MediaDrm: "" + e.getMessage());
                    return;
                }

                synchronized(mLock) {
                    mDrm.setOnEventListener(new MediaDrm.OnEventListener() {
                            @Override
                            public void onEvent(MediaDrm md, byte[] sid, int event,
                                    int extra, byte[] data) {
                                if (md != mDrm) {
                                    Log.e(TAG, ""onEvent callback: drm object mismatch"");
                                    return;
                                } else if (!Arrays.equals(mSessionId, sid)) {
                                    Log.e(TAG, ""onEvent callback: sessionId mismatch: |"" +
                                            Arrays.toString(mSessionId) + ""| vs |"" + Arrays.toString(sid) + ""|"");
                                    return;
                                }

                                mEventListenerCalled = true;
                                if (event == MediaDrm.EVENT_PROVISION_REQUIRED) {
                                    Log.i(TAG, ""MediaDrm event: Provision required"");
                                } else if (event == MediaDrm.EVENT_KEY_REQUIRED) {
                                    Log.i(TAG, ""MediaDrm event: Key required"");
                                    getKeys(mDrm, initDataType, mSessionId, mDrmInitData,
                                            keyType, clearKeyIds);
                                } else if (event == MediaDrm.EVENT_KEY_EXPIRED) {
                                    Log.i(TAG, ""MediaDrm event: Key expired"");
                                    getKeys(mDrm, initDataType, mSessionId, mDrmInitData,
                                            keyType, clearKeyIds);
                                } else if (event == MediaDrm.EVENT_VENDOR_DEFINED) {
                                    Log.i(TAG, ""MediaDrm event: Vendor defined"");
                                } else if (event == MediaDrm.EVENT_SESSION_RECLAIMED) {
                                    Log.i(TAG, ""MediaDrm event: Session reclaimed"");
                                } else {
                                    Log.e(TAG, ""MediaDrm event not supported: "" + event);
                                }
                            }
                        });
                    mDrm.setOnExpirationUpdateListener(new MediaDrm.OnExpirationUpdateListener() {
                            @Override
                            public void onExpirationUpdate(MediaDrm md, byte[] sid, long expirationTime) {
                                if (md != mDrm) {
                                    Log.e(TAG, ""onExpirationUpdate callback: drm object mismatch"");
                                } else if (!Arrays.equals(mSessionId, sid)) {
                                    Log.e(TAG, ""onExpirationUpdate callback: sessionId mismatch: |"" +
                                            Arrays.toString(mSessionId) + ""| vs |"" + Arrays.toString(sid) + ""|"");
                                } else {
                                    mExpirationUpdateReceived = true;
                                }
                            }
                        }, null);
                    mDrm.setOnSessionLostStateListener(new MediaDrm.OnSessionLostStateListener() {
                            @Override
                            public void onSessionLostState(MediaDrm md, byte[] sid) {
                                if (md != mDrm) {
                                    Log.e(TAG, ""onSessionLostState callback: drm object mismatch"");
                                } else if (!Arrays.equals(mSessionId, sid)) {
                                    Log.e(TAG, ""onSessionLostState callback: sessionId mismatch: |"" +
                                            Arrays.toString(mSessionId) + ""| vs |"" + Arrays.toString(sid) + ""|"");
                                } else {
                                    mLostStateReceived = true;
                                }
                            }
                        }, null);
                    mDrm.setOnKeyStatusChangeListener(new MediaDrm.OnKeyStatusChangeListener() {
                            @Override
                            public void onKeyStatusChange(MediaDrm md, byte[] sessionId,
                                    List<KeyStatus> keyInformation, boolean hasNewUsableKey) {
                                Log.d(TAG, ""onKeyStatusChange"");
                                assertTrue(md == mDrm);
                                assertTrue(Arrays.equals(sessionId, mSessionId));
                                mSessionMonitor.signal();
                                assertTrue(hasNewUsableKey);

                                assertEquals(3, keyInformation.size());
                                KeyStatus keyStatus = keyInformation.get(0);
                                assertTrue(Arrays.equals(keyStatus.getKeyId(), new byte[] {0xa, 0xb, 0xc}));
                                assertTrue(keyStatus.getStatusCode() == MediaDrm.KeyStatus.STATUS_USABLE);
                                keyStatus = keyInformation.get(1);
                                assertTrue(Arrays.equals(keyStatus.getKeyId(), new byte[] {0xd, 0xe, 0xf}));
                                assertTrue(keyStatus.getStatusCode() == MediaDrm.KeyStatus.STATUS_EXPIRED);
                                keyStatus = keyInformation.get(2);
                                assertTrue(Arrays.equals(keyStatus.getKeyId(), new byte[] {0x0, 0x1, 0x2}));
                                assertTrue(keyStatus.getStatusCode() == MediaDrm.KeyStatus.STATUS_USABLE_IN_FUTURE);
                            }
                        }, null);

                    mLock.notify();
                }
                Looper.loop();  // Blocks forever until Looper.quit() is called.
            }
        }.start();

        // wait for mDrm to be created
        synchronized(mLock) {
            try {
                mLock.wait(1000);
            } catch (Exception e) {
            }
        }
        return mDrm;
    }

    private void stopDrm(MediaDrm drm) {
        if (drm != mDrm) {
            Log.e(TAG, ""invalid drm specified in stopDrm"");
        }
        mLooper.quit();
        mDrm.close();
        mDrm = null;
    }

    private @NonNull byte[] openSession(MediaDrm drm) {
        byte[] mSessionId = null;
        boolean mRetryOpen;
        do {
            try {
                mRetryOpen = false;
                mSessionId = drm.openSession();
            } catch (Exception e) {
                mRetryOpen = true;
            }
        } while (mRetryOpen);
        return mSessionId;
    }

    private void closeSession(MediaDrm drm, byte[] sessionId) {
        drm.closeSession(sessionId);
    }

    /**
     * Tests clear key system playback.
     */
    private void testClearKeyPlayback(
            UUID drmSchemeUuid,
            String videoMime, String[] videoFeatures,
            String initDataType, byte[][] clearKeyIds,
            Uri audioUrl, boolean audioEncrypted,
            Uri videoUrl, boolean videoEncrypted,
            int videoWidth, int videoHeight, boolean scrambled, int keyType) throws Exception {

        if (isWatchDevice()) {
            return;
        }

        MediaDrm drm = null;
        mSessionId = null;
        final boolean hasDrm = !scrambled && drmSchemeUuid != null;
        if (hasDrm) {
            drm = startDrm(clearKeyIds, initDataType, drmSchemeUuid, keyType);
            mSessionId = openSession(drm);
        }

        if (!preparePlayback(videoMime, videoFeatures, audioUrl, audioEncrypted, videoUrl,
                videoEncrypted, videoWidth, videoHeight, scrambled, mSessionId, getSurfaces())) {
            // Allow device to skip test to keep existing behavior.
            // We should throw an exception for new tests.
            return;
        }

        if (hasDrm) {
            mDrmInitData = mMediaCodecPlayer.getDrmInitData();
            getKeys(mDrm, initDataType, mSessionId, mDrmInitData, keyType, clearKeyIds);
        }

        if (hasDrm && keyType == MediaDrm.KEY_TYPE_OFFLINE) {
            closeSession(drm, mSessionId);
            mSessionMonitor.waitForSignal();
            mSessionId = openSession(drm);
            if (mKeySetId.length > 0) {
                drm.restoreKeys(mSessionId, mKeySetId);
            } else {
                closeSession(drm, mSessionId);
                stopDrm(drm);
                throw new Error(""Invalid keySetId size for offline license"");
            }
        }

        // starts video playback
        playUntilEnd();
        if (hasDrm) {
            closeSession(drm, mSessionId);
            stopDrm(drm);
        }
    }

    /**
     * Tests KEY_TYPE_RELEASE for offline license.
     */
    @Presubmit"	"/home/gpoor/cts-12-source/cts/tests/tests/mediadrm/src/android/mediadrm/cts/MediaDrmClearkeyTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.mediadrm.cts.MediaDrmClearkeyTest"	"testReleaseOfflineLicense"	"CtsMediaDrmTestCases"	"1: ui"	"public void testReleaseOfflineLicense() throws Exception {
        if (isWatchDevice()) {
            return;
        }

        byte[][] clearKeyIds = new byte[][] { CLEAR_KEY_CENC };
        mSessionId = null;
        String initDataType = ""cenc"";

        MediaDrm drm = startDrm(clearKeyIds, initDataType,
                CLEARKEY_SCHEME_UUID, MediaDrm.KEY_TYPE_OFFLINE);
        mSessionId = openSession(drm);

        Uri videoUrl = Uri.parse(Utils.getMediaPath() + CENC_VIDEO_PATH);
        if (false == playbackPreCheck(MIME_VIDEO_AVC,
                new String[] { CodecCapabilities.FEATURE_SecurePlayback }, videoUrl,
                VIDEO_WIDTH_CENC, VIDEO_HEIGHT_CENC)) {
            // retry with unsecure codec
            if (false == playbackPreCheck(MIME_VIDEO_AVC,
                    new String[0], videoUrl,
                    VIDEO_WIDTH_CENC, VIDEO_HEIGHT_CENC)) {
                Log.e(TAG, ""Failed playback precheck"");
                return;
            }
        }

        mMediaCodecPlayer = new MediaCodecClearKeyPlayer(
                getSurfaces(),
                mSessionId, false /*scrambled */,
                mContext);

        Uri audioUrl = Uri.parse(Utils.getMediaPath() + CENC_AUDIO_PATH);
        mMediaCodecPlayer.setAudioDataSource(audioUrl, null, false);
        mMediaCodecPlayer.setVideoDataSource(videoUrl, null, true);
        mMediaCodecPlayer.start();
        mMediaCodecPlayer.prepare();
        mDrmInitData = mMediaCodecPlayer.getDrmInitData();

        // Create and store the offline license
        getKeys(mDrm, initDataType, mSessionId, mDrmInitData, MediaDrm.KEY_TYPE_OFFLINE,
                clearKeyIds);

        // Verify the offline license is valid
        closeSession(drm, mSessionId);
        mSessionMonitor.waitForSignal();
        mDrm.clearOnKeyStatusChangeListener();
        mSessionId = openSession(drm);
        drm.restoreKeys(mSessionId, mKeySetId);
        closeSession(drm, mSessionId);

        // Release the offline license
        getKeys(mDrm, initDataType, mKeySetId, mDrmInitData, MediaDrm.KEY_TYPE_RELEASE,
                clearKeyIds);

        // Verify restoreKeys will throw an exception if the offline license
        // has already been released
        mSessionId = openSession(drm);
        try {
            drm.restoreKeys(mSessionId, mKeySetId);
        } catch (MediaDrmStateException e) {
            // Expected exception caught, all is good
            return;
        } finally {
            closeSession(drm, mSessionId);
            stopDrm(drm);
        }

        // Did not receive expected exception, throw an Error
        throw new Error(""Did not receive expected exception from restoreKeys"");
    }

    private boolean queryKeyStatus(@NonNull final MediaDrm drm, @NonNull final byte[] sessionId) {
        final HashMap<String, String> keyStatus = drm.queryKeyStatus(sessionId);
        if (keyStatus.isEmpty()) {
            Log.e(TAG, ""queryKeyStatus: empty key status"");
            return false;
        }

        final Set<String> keySet = keyStatus.keySet();
        final int numKeys = keySet.size();
        final String[] keys = keySet.toArray(new String[numKeys]);
        for (int i = 0; i < numKeys; ++i) {
            final String key = keys[i];
            Log.i(TAG, ""queryKeyStatus: key="" + key + "", value="" + keyStatus.get(key));
        }

        return true;
    }

    @Presubmit"	"/home/gpoor/cts-12-source/cts/tests/tests/mediadrm/src/android/mediadrm/cts/MediaDrmClearkeyTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.mediadrm.cts.MediaDrmClearkeyTest"	"testQueryKeyStatus"	"CtsMediaDrmTestCases"	"1: ui"	"public void testQueryKeyStatus() throws Exception {
        if (isWatchDevice()) {
            // skip this test on watch because it calls
            // addTrack that requires codec
            return;
        }

        MediaDrm drm = startDrm(new byte[][] { CLEAR_KEY_CENC }, ""cenc"",
                CLEARKEY_SCHEME_UUID, MediaDrm.KEY_TYPE_STREAMING);

        mSessionId = openSession(drm);

        // Test default key status, should not be defined
        final HashMap<String, String> keyStatus = drm.queryKeyStatus(mSessionId);
        if (!keyStatus.isEmpty()) {
            closeSession(drm, mSessionId);
            stopDrm(drm);
            throw new Error(""query default key status failed"");
        }

        // Test valid key status
        mMediaCodecPlayer = new MediaCodecClearKeyPlayer(
                getSurfaces(),
                mSessionId, false,
                mContext);
        mMediaCodecPlayer.setAudioDataSource(
                Uri.parse(Utils.getMediaPath() + CENC_AUDIO_PATH), null, false);
        mMediaCodecPlayer.setVideoDataSource(
                Uri.parse(Utils.getMediaPath() + CENC_VIDEO_PATH), null, true);
        mMediaCodecPlayer.start();
        mMediaCodecPlayer.prepare();

        mDrmInitData = mMediaCodecPlayer.getDrmInitData();
        getKeys(drm, ""cenc"", mSessionId, mDrmInitData, MediaDrm.KEY_TYPE_STREAMING,
                new byte[][] { CLEAR_KEY_CENC });
        boolean success = true;
        if (!queryKeyStatus(drm, mSessionId)) {
            success = false;
        }

        mMediaCodecPlayer.reset();
        closeSession(drm, mSessionId);
        stopDrm(drm);
        if (!success) {
            throw new Error(""query key status failed"");
        }
    }

    @Presubmit"	"/home/gpoor/cts-12-source/cts/tests/tests/mediadrm/src/android/mediadrm/cts/MediaDrmClearkeyTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.mediadrm.cts.MediaDrmClearkeyTest"	"testOfflineKeyManagement"	"CtsMediaDrmTestCases"	"1: ui"	"public void testOfflineKeyManagement() throws Exception {
        if (isWatchDevice()) {
            // skip this test on watch because it calls
            // addTrack that requires codec
            return;
        }

        MediaDrm drm = startDrm(new byte[][] { CLEAR_KEY_CENC }, ""cenc"",
                CLEARKEY_SCHEME_UUID, MediaDrm.KEY_TYPE_OFFLINE);

        if (getClearkeyVersion(drm).matches(""1.[01]"")) {
            Log.i(TAG, ""Skipping testsOfflineKeyManagement: clearkey 1.2 required"");
            return;
        }

        mSessionId = openSession(drm);

        // Test get offline keys
        mMediaCodecPlayer = new MediaCodecClearKeyPlayer(
                getSurfaces(),
                mSessionId, false,
                mContext);
        mMediaCodecPlayer.setAudioDataSource(
                Uri.parse(Utils.getMediaPath() + CENC_AUDIO_PATH), null, false);
        mMediaCodecPlayer.setVideoDataSource(
                Uri.parse(Utils.getMediaPath() + CENC_VIDEO_PATH), null, true);
        mMediaCodecPlayer.start();
        mMediaCodecPlayer.prepare();

        try {
            mDrmInitData = mMediaCodecPlayer.getDrmInitData();

            List<byte[]> keySetIds = drm.getOfflineLicenseKeySetIds();
            int preCount = keySetIds.size();

            getKeys(drm, ""cenc"", mSessionId, mDrmInitData, MediaDrm.KEY_TYPE_OFFLINE,
                    new byte[][] { CLEAR_KEY_CENC });

            if (drm.getOfflineLicenseState(mKeySetId) != MediaDrm.OFFLINE_LICENSE_STATE_USABLE) {
                throw new Error(""Offline license state is not usable"");
            }

            keySetIds = drm.getOfflineLicenseKeySetIds();

            if (keySetIds.size() != preCount + 1) {
                throw new Error(""KeySetIds size did not increment"");
            }

            boolean found = false;
            for (int i = 0; i < keySetIds.size(); i++) {
                if (Arrays.equals(keySetIds.get(i), mKeySetId)) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                throw new Error(""New KeySetId is missing from KeySetIds"");
            }

            drm.removeOfflineLicense(mKeySetId);

            keySetIds = drm.getOfflineLicenseKeySetIds();
            if (keySetIds.size() != preCount) {
                throw new Error(""KeySetIds size is incorrect"");
            }

            found = false;
            for (int i = 0; i < keySetIds.size(); i++) {
                if (Arrays.equals(keySetIds.get(i), mKeySetId)) {
                    found = true;
                    break;
                }
            }

            if (found) {
                throw new Error(""New KeySetId is still in from KeySetIds after removal"");
            }

            // TODO: after RELEASE is implemented: add offline key, release it
            // get offline key status, check state is inactive
        } finally {
            mMediaCodecPlayer.reset();
            closeSession(drm, mSessionId);
            stopDrm(drm);
        }
    }

    // returns FEATURE_SecurePlayback if device supports secure codec,
    // else returns an empty string for the codec feature
    private String[] determineCodecFeatures(String mime,
            int videoWidth, int videoHeight) {
        String[] codecFeatures = { CodecCapabilities.FEATURE_SecurePlayback };
        if (!isResolutionSupported(MIME_VIDEO_AVC, codecFeatures,
            VIDEO_WIDTH_CENC, VIDEO_HEIGHT_CENC)) {
            // for device that does not support secure codec
            codecFeatures = new String[0];
        }
        return codecFeatures;
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/mediadrm/src/android/mediadrm/cts/MediaDrmClearkeyTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.mediadrm.cts.MediaDrmClearkeyTest"	"testClearKeyPlaybackCenc"	"CtsMediaDrmTestCases"	"1: ui"	"public void testClearKeyPlaybackCenc() throws Exception {
        String[] codecFeatures = determineCodecFeatures(MIME_VIDEO_AVC,
            VIDEO_WIDTH_CENC, VIDEO_HEIGHT_CENC);
        testClearKeyPlayback(
            COMMON_PSSH_SCHEME_UUID,
            // using secure codec even though it is clear key DRM
            MIME_VIDEO_AVC, codecFeatures,
            ""cenc"", new byte[][] { CLEAR_KEY_CENC },
            Uri.parse(Utils.getMediaPath() + CENC_AUDIO_PATH), false  /* audioEncrypted */,
            Uri.parse(Utils.getMediaPath() + CENC_VIDEO_PATH), true /* videoEncrypted */,
            VIDEO_WIDTH_CENC, VIDEO_HEIGHT_CENC, false /* scrambled */,
            MediaDrm.KEY_TYPE_STREAMING);
    }

    @Presubmit"	"/home/gpoor/cts-12-source/cts/tests/tests/mediadrm/src/android/mediadrm/cts/MediaDrmClearkeyTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.mediadrm.cts.MediaDrmClearkeyTest"	"testClearKeyPlaybackCenc2"	"CtsMediaDrmTestCases"	"1: ui"	"public void testClearKeyPlaybackCenc2() throws Exception {
        String[] codecFeatures = determineCodecFeatures(MIME_VIDEO_AVC,
            VIDEO_WIDTH_CENC, VIDEO_HEIGHT_CENC);
        testClearKeyPlayback(
            CLEARKEY_SCHEME_UUID,
            // using secure codec even though it is clear key DRM
            MIME_VIDEO_AVC, codecFeatures,
            ""cenc"", new byte[][] { CLEAR_KEY_CENC },
            Uri.parse(Utils.getMediaPath() + CENC_AUDIO_PATH), false /* audioEncrypted */ ,
            Uri.parse(Utils.getMediaPath() + CENC_VIDEO_PATH), true /* videoEncrypted */,
            VIDEO_WIDTH_CENC, VIDEO_HEIGHT_CENC, false /* scrambled */,
            MediaDrm.KEY_TYPE_STREAMING);
    }

    @Presubmit"	"/home/gpoor/cts-12-source/cts/tests/tests/mediadrm/src/android/mediadrm/cts/MediaDrmClearkeyTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.mediadrm.cts.MediaDrmClearkeyTest"	"testClearKeyPlaybackOfflineCenc"	"CtsMediaDrmTestCases"	"1: ui"	"public void testClearKeyPlaybackOfflineCenc() throws Exception {
        String[] codecFeatures = determineCodecFeatures(MIME_VIDEO_AVC,
            VIDEO_WIDTH_CENC, VIDEO_HEIGHT_CENC);
        testClearKeyPlayback(
                CLEARKEY_SCHEME_UUID,
                // using secure codec even though it is clear key DRM
                MIME_VIDEO_AVC, codecFeatures,
                ""cenc"", new byte[][] { CLEAR_KEY_CENC },
                Uri.parse(Utils.getMediaPath() + CENC_AUDIO_PATH), false /* audioEncrypted */ ,
                Uri.parse(Utils.getMediaPath() + CENC_VIDEO_PATH), true /* videoEncrypted */,
                VIDEO_WIDTH_CENC, VIDEO_HEIGHT_CENC, false /* scrambled */,
                MediaDrm.KEY_TYPE_OFFLINE);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/mediadrm/src/android/mediadrm/cts/MediaDrmClearkeyTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.mediadrm.cts.MediaDrmClearkeyTest"	"testClearKeyPlaybackWebm"	"CtsMediaDrmTestCases"	"1: ui"	"public void testClearKeyPlaybackWebm() throws Exception {
        testClearKeyPlayback(
            CLEARKEY_SCHEME_UUID,
            MIME_VIDEO_VP8, new String[0],
            ""webm"", new byte[][] { CLEAR_KEY_WEBM },
            WEBM_URL, true /* audioEncrypted */,
            WEBM_URL, true /* videoEncrypted */,
            VIDEO_WIDTH_WEBM, VIDEO_HEIGHT_WEBM, false /* scrambled */,
            MediaDrm.KEY_TYPE_STREAMING);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/mediadrm/src/android/mediadrm/cts/MediaDrmClearkeyTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.mediadrm.cts.MediaDrmClearkeyTest"	"testClearKeyPlaybackMpeg2ts"	"CtsMediaDrmTestCases"	"1: ui"	"public void testClearKeyPlaybackMpeg2ts() throws Exception {
        testClearKeyPlayback(
            CLEARKEY_SCHEME_UUID,
            MIME_VIDEO_AVC, new String[0],
            ""mpeg2ts"", null,
            MPEG2TS_SCRAMBLED_URL, false /* audioEncrypted */,
            MPEG2TS_SCRAMBLED_URL, false /* videoEncrypted */,
            VIDEO_WIDTH_MPEG2TS, VIDEO_HEIGHT_MPEG2TS, true /* scrambled */,
            MediaDrm.KEY_TYPE_STREAMING);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/mediadrm/src/android/mediadrm/cts/MediaDrmClearkeyTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.mediadrm.cts.MediaDrmClearkeyTest"	"testPlaybackMpeg2ts"	"CtsMediaDrmTestCases"	"1: ui"	"public void testPlaybackMpeg2ts() throws Exception {
        testClearKeyPlayback(
            CLEARKEY_SCHEME_UUID,
            MIME_VIDEO_AVC, new String[0],
            ""mpeg2ts"", null,
            MPEG2TS_CLEAR_URL, false /* audioEncrypted */,
            MPEG2TS_CLEAR_URL, false /* videoEncrypted */,
            VIDEO_WIDTH_MPEG2TS, VIDEO_HEIGHT_MPEG2TS, false /* scrambled */,
            MediaDrm.KEY_TYPE_STREAMING);
    }

    private String getStringProperty(final MediaDrm drm,  final String key) {
        String value = """";
        try {
            value = drm.getPropertyString(key);
        } catch (IllegalArgumentException e) {
            // Expected exception for invalid key
            Log.d(TAG, ""Expected result: "" + e.getMessage());
        } catch (Exception e) {
            throw new Error(e.getMessage() + ""-"" + key);
        }
        return value;
    }

    private byte[] getByteArrayProperty(final MediaDrm drm,  final String key) {
        byte[] bytes = new byte[0];
        try {
            bytes = drm.getPropertyByteArray(key);
        } catch (IllegalArgumentException e) {
            // Expected exception for invalid key
            Log.d(TAG, ""Expected: "" + e.getMessage() + "" - "" + key);
        } catch (Exception e) {
            throw new Error(e.getMessage() + ""-"" + key);
        }
        return bytes;
    }

    private void setStringProperty(final MediaDrm drm, final String key, final String value) {
        try {
            drm.setPropertyString(key, value);
        } catch (IllegalArgumentException e) {
            // Expected exception for invalid key
            Log.d(TAG, ""Expected: "" + e.getMessage() + "" - "" + key);
        } catch (Exception e) {
            throw new Error(e.getMessage() + ""-"" + key);
        }
    }

    private void setByteArrayProperty(final MediaDrm drm, final String key, final byte[] bytes) {
        try {
            drm.setPropertyByteArray(key, bytes);
        } catch (IllegalArgumentException e) {
            // Expected exception for invalid key
            Log.d(TAG, ""Expected: "" + e.getMessage() + "" - "" + key);
        } catch (Exception e) {
            throw new Error(e.getMessage() + ""-"" + key);
        }
    }

    @Presubmit"	"/home/gpoor/cts-12-source/cts/tests/tests/mediadrm/src/android/mediadrm/cts/MediaDrmClearkeyTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.mediadrm.cts.MediaDrmClearkeyTest"	"testGetProperties"	"CtsMediaDrmTestCases"	"1: ui"	"public void testGetProperties() throws Exception {
        if (watchHasNoClearkeySupport()) {
            return;
        }

        MediaDrm drm = startDrm(new byte[][] { CLEAR_KEY_CENC },
                ""cenc"", CLEARKEY_SCHEME_UUID, MediaDrm.KEY_TYPE_STREAMING);

        try {
            // The following tests will not verify the value we are getting
            // back since it could change in the future.
            final String[] sKeys = {
                    DESCRIPTION_PROPERTY_KEY, LISTENER_TEST_SUPPORT_PROPERTY_KEY,
                    VENDOR_PROPERTY_KEY, VERSION_PROPERTY_KEY};
            String value;
            for (String key : sKeys) {
                value = getStringProperty(drm, key);
                Log.d(TAG, ""getPropertyString returns: "" + key + "", "" + value);
                if (value.isEmpty()) {
                    throw new Error(""Failed to get property for: "" + key);
                }
            }

            if (cannotHandleGetPropertyByteArray(drm)) {
                Log.i(TAG, ""Skipping testGetProperties: byte array properties not implemented ""
                        + ""on devices launched before P"");
                return;
            }

            byte[] bytes = getByteArrayProperty(drm, DEVICEID_PROPERTY_KEY);
            if (0 == bytes.length) {
                throw new Error(""Failed to get property for: "" + DEVICEID_PROPERTY_KEY);
            }

            // Test with an invalid property key.
            value = getStringProperty(drm, INVALID_PROPERTY_KEY);
            bytes = getByteArrayProperty(drm, INVALID_PROPERTY_KEY);
            if (!value.isEmpty() || 0 != bytes.length) {
                throw new Error(""get property failed using an invalid property key"");
            }
        } finally {
            stopDrm(drm);
        }
    }

    @Presubmit"	"/home/gpoor/cts-12-source/cts/tests/tests/mediadrm/src/android/mediadrm/cts/MediaDrmClearkeyTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.mediadrm.cts.MediaDrmClearkeyTest"	"testSetProperties"	"CtsMediaDrmTestCases"	"1: ui"	"public void testSetProperties() throws Exception {
        if (watchHasNoClearkeySupport()) {
            return;
        }

        MediaDrm drm = startDrm(new byte[][]{CLEAR_KEY_CENC},
                ""cenc"", CLEARKEY_SCHEME_UUID, MediaDrm.KEY_TYPE_STREAMING);

        try {
            if (cannotHandleSetPropertyString(drm)) {
                Log.i(TAG, ""Skipping testSetProperties: set property string not implemented ""
                        + ""on devices launched before P"");
                return;
            }

            // Test setting predefined string property
            // - Save the value to be restored later
            // - Set the property value
            // - Check the value that was set
            // - Restore previous value
            String listenerTestSupport = getStringProperty(drm, LISTENER_TEST_SUPPORT_PROPERTY_KEY);

            setStringProperty(drm, LISTENER_TEST_SUPPORT_PROPERTY_KEY, ""testing"");

            String value = getStringProperty(drm, LISTENER_TEST_SUPPORT_PROPERTY_KEY);
            if (!value.equals(""testing"")) {
                throw new Error(""Failed to set property: "" + LISTENER_TEST_SUPPORT_PROPERTY_KEY);
            }

            setStringProperty(drm, LISTENER_TEST_SUPPORT_PROPERTY_KEY, listenerTestSupport);

            // Test setting immutable properties
            HashMap<String, String> defaultImmutableProperties = new HashMap<String, String>();
            defaultImmutableProperties.put(ALGORITHMS_PROPERTY_KEY,
                    getStringProperty(drm, ALGORITHMS_PROPERTY_KEY));
            defaultImmutableProperties.put(DESCRIPTION_PROPERTY_KEY,
                    getStringProperty(drm, DESCRIPTION_PROPERTY_KEY));
            defaultImmutableProperties.put(VENDOR_PROPERTY_KEY,
                    getStringProperty(drm, VENDOR_PROPERTY_KEY));
            defaultImmutableProperties.put(VERSION_PROPERTY_KEY,
                    getStringProperty(drm, VERSION_PROPERTY_KEY));

            HashMap<String, String> immutableProperties = new HashMap<String, String>();
            immutableProperties.put(ALGORITHMS_PROPERTY_KEY, ""brute force"");
            immutableProperties.put(DESCRIPTION_PROPERTY_KEY, ""testing only"");
            immutableProperties.put(VENDOR_PROPERTY_KEY, ""my Google"");
            immutableProperties.put(VERSION_PROPERTY_KEY, ""undefined"");

            for (String key : immutableProperties.keySet()) {
                setStringProperty(drm, key, immutableProperties.get(key));
            }

            // Verify the immutable properties have not been set
            for (String key : immutableProperties.keySet()) {
                value = getStringProperty(drm, key);
                if (!defaultImmutableProperties.get(key).equals(getStringProperty(drm, key))) {
                    throw new Error(""Immutable property has changed, key="" + key);
                }
            }

            // Test setPropertyByteArray for immutable property
            final byte[] bytes = new byte[] {
                    0xf, 0xe, 0xd, 0xc, 0xb, 0xa, 0x9, 0x8,
                    0x7, 0x6, 0x5, 0x4, 0x3, 0x2, 0x1, 0x0};

            final byte[] deviceId = getByteArrayProperty(drm, DEVICEID_PROPERTY_KEY);

            setByteArrayProperty(drm, DEVICEID_PROPERTY_KEY, bytes);

            // Verify deviceId has not changed
            if (!Arrays.equals(deviceId, getByteArrayProperty(drm, DEVICEID_PROPERTY_KEY))) {
                throw new Error(""Failed to set byte array for key="" + DEVICEID_PROPERTY_KEY);
            }
        } finally {
            stopDrm(drm);
        }
    }

    private final static int CLEARKEY_MAX_SESSIONS = 10;

    @Presubmit"	"/home/gpoor/cts-12-source/cts/tests/tests/mediadrm/src/android/mediadrm/cts/MediaDrmClearkeyTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.mediadrm.cts.MediaDrmClearkeyTest"	"testGetNumberOfSessions"	"CtsMediaDrmTestCases"	"1: ui"	"public void testGetNumberOfSessions() {
        if (watchHasNoClearkeySupport()) {
            return;
        }

        MediaDrm drm = startDrm(new byte[][] { CLEAR_KEY_CENC },
                ""cenc"", CLEARKEY_SCHEME_UUID, MediaDrm.KEY_TYPE_STREAMING);

        try {
            if (getClearkeyVersion(drm).equals(""1.0"")) {
                Log.i(TAG, ""Skipping testGetNumberOfSessions: not supported by clearkey 1.0"");
                return;
            }

            int maxSessionCount = drm.getMaxSessionCount();
            if (maxSessionCount != CLEARKEY_MAX_SESSIONS) {
                throw new Error(""expected max session count to be "" +
                        CLEARKEY_MAX_SESSIONS);
            }
            int initialOpenSessionCount = drm.getOpenSessionCount();
            if (initialOpenSessionCount == maxSessionCount) {
                throw new Error(""all sessions open, can't do increment test"");
            }
            mSessionId = openSession(drm);
            try {
                if (drm.getOpenSessionCount() != initialOpenSessionCount + 1) {
                    throw new Error(""openSessionCount didn't increment"");
                }
            } finally {
                closeSession(drm, mSessionId);
            }
        } finally {
            stopDrm(drm);
        }
    }

    @Presubmit"	"/home/gpoor/cts-12-source/cts/tests/tests/mediadrm/src/android/mediadrm/cts/MediaDrmClearkeyTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.mediadrm.cts.MediaDrmClearkeyTest"	"testHdcpLevels"	"CtsMediaDrmTestCases"	"1: ui"	"public void testHdcpLevels() {
        if (watchHasNoClearkeySupport()) {
            return;
        }

        MediaDrm drm = null;
        try {
            drm = new MediaDrm(CLEARKEY_SCHEME_UUID);

            if (getClearkeyVersion(drm).equals(""1.0"")) {
                Log.i(TAG, ""Skipping testHdcpLevels: not supported by clearkey 1.0"");
                return;
            }

            if (drm.getConnectedHdcpLevel() != MediaDrm.HDCP_NONE) {
                throw new Error(""expected connected hdcp level to be HDCP_NONE"");
            }

            if (drm.getMaxHdcpLevel() != MediaDrm.HDCP_NO_DIGITAL_OUTPUT) {
                throw new Error(""expected max hdcp level to be HDCP_NO_DIGITAL_OUTPUT"");
            }
        } catch(Exception e) {
            throw new Error(""Unexpected exception "", e);
        } finally {
            if (drm != null) {
                drm.close();
            }
        }
    }

    @Presubmit"	"/home/gpoor/cts-12-source/cts/tests/tests/mediadrm/src/android/mediadrm/cts/MediaDrmClearkeyTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.mediadrm.cts.MediaDrmClearkeyTest"	"testSecurityLevels"	"CtsMediaDrmTestCases"	"1: ui"	"public void testSecurityLevels() {
        if (watchHasNoClearkeySupport()) {
            return;
        }

        MediaDrm drm = null;
        byte[] sessionId = null;
        try {
            drm = new MediaDrm(CLEARKEY_SCHEME_UUID);

            if (getClearkeyVersion(drm).equals(""1.0"")) {
                Log.i(TAG, ""Skipping testSecurityLevels: not supported by clearkey 1.0"");
                return;
            }

            sessionId = drm.openSession(MediaDrm.SECURITY_LEVEL_SW_SECURE_CRYPTO);
            if (drm.getSecurityLevel(sessionId) != MediaDrm.SECURITY_LEVEL_SW_SECURE_CRYPTO) {
                throw new Error(""expected security level to be SECURITY_LEVEL_SW_SECURE_CRYPTO"");
            }
            drm.closeSession(sessionId);
            sessionId = null;

            sessionId = drm.openSession();
            if (drm.getSecurityLevel(sessionId) != MediaDrm.SECURITY_LEVEL_SW_SECURE_CRYPTO) {
                throw new Error(""expected security level to be SECURITY_LEVEL_SW_SECURE_CRYPTO"");
            }
            drm.closeSession(sessionId);
            sessionId = null;

            try {
                sessionId = drm.openSession(MediaDrm.SECURITY_LEVEL_SW_SECURE_DECODE);
            } catch (IllegalArgumentException e) {
                /* caught expected exception */
            } catch (Exception e) {
                throw new Exception (""did't get expected IllegalArgumentException"" +
                        "" while opening a session with disallowed security level"");
            } finally  {
                if (sessionId != null) {
                    drm.closeSession(sessionId);
                    sessionId = null;
                }
            }
        } catch(Exception e) {
            throw new Error(""Unexpected exception "", e);
        } finally  {
            if (sessionId != null) {
                drm.closeSession(sessionId);
            }
            if (drm != null) {
                drm.close();
            }
        }
     }

    @Presubmit"	"/home/gpoor/cts-12-source/cts/tests/tests/mediadrm/src/android/mediadrm/cts/MediaDrmClearkeyTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.mediadrm.cts.MediaDrmClearkeyTest"	"testSecureStop"	"CtsMediaDrmTestCases"	"2: ui system"	"public void testSecureStop() {
        if (watchHasNoClearkeySupport()) {
            return;
        }

        MediaDrm drm = startDrm(new byte[][] {CLEAR_KEY_CENC}, ""cenc"",
                CLEARKEY_SCHEME_UUID, MediaDrm.KEY_TYPE_STREAMING);

        byte[] sessionId = null;
        try {
            if (getClearkeyVersion(drm).equals(""1.0"")) {
                Log.i(TAG, ""Skipping testSecureStop: not supported in ClearKey v1.0"");
                return;
            }

            drm.removeAllSecureStops();
            Log.d(TAG, ""Test getSecureStops from an empty list."");
            List<byte[]> secureStops = drm.getSecureStops();
            assertTrue(secureStops.isEmpty());

            Log.d(TAG, ""Test getSecureStopIds from an empty list."");
            List<byte[]> secureStopIds = drm.getSecureStopIds();
            assertTrue(secureStopIds.isEmpty());

            mSessionId = openSession(drm);

            mMediaCodecPlayer = new MediaCodecClearKeyPlayer(
                    getSurfaces(), mSessionId, false, mContext);
            mMediaCodecPlayer.setAudioDataSource(
                    Uri.parse(Utils.getMediaPath() + CENC_AUDIO_PATH), null, false);
            mMediaCodecPlayer.setVideoDataSource(
                    Uri.parse(Utils.getMediaPath() + CENC_VIDEO_PATH), null, true);
            mMediaCodecPlayer.start();
            mMediaCodecPlayer.prepare();
            mDrmInitData = mMediaCodecPlayer.getDrmInitData();

            for (int i = 0; i < NUMBER_OF_SECURE_STOPS; ++i) {
                getKeys(drm, ""cenc"", mSessionId, mDrmInitData,
                        MediaDrm.KEY_TYPE_STREAMING, new byte[][] {CLEAR_KEY_CENC});
            }
            Log.d(TAG, ""Test getSecureStops."");
            secureStops = drm.getSecureStops();
            assertEquals(NUMBER_OF_SECURE_STOPS, secureStops.size());

            Log.d(TAG, ""Test getSecureStopIds."");
            secureStopIds = drm.getSecureStopIds();
            assertEquals(NUMBER_OF_SECURE_STOPS, secureStopIds.size());

            Log.d(TAG, ""Test getSecureStop using secure stop Ids."");
            for (int i = 0; i < secureStops.size(); ++i) {
                byte[] secureStop = drm.getSecureStop(secureStopIds.get(i));
                assertTrue(Arrays.equals(secureStops.get(i), secureStop));
            }

            Log.d(TAG, ""Test removeSecureStop given a secure stop Id."");
            drm.removeSecureStop(secureStopIds.get(NUMBER_OF_SECURE_STOPS - 1));
            secureStops = drm.getSecureStops();
            secureStopIds = drm.getSecureStopIds();
            assertEquals(NUMBER_OF_SECURE_STOPS - 1, secureStops.size());
            assertEquals(NUMBER_OF_SECURE_STOPS - 1, secureStopIds.size());

            Log.d(TAG, ""Test releaseSecureStops given a release message."");
            // Simulate server response message by removing
            // every other secure stops to make it interesting.
            List<byte[]> releaseList = new ArrayList<byte[]>();
            int releaseListSize = 0;
            for (int i = 0; i < secureStops.size(); i += 2) {
                byte[] secureStop = secureStops.get(i);
                releaseList.add(secureStop);
                releaseListSize += secureStop.length;
            }

            // ClearKey's release message format (this is a format shared between
            // the server and the drm service).
            // The clearkey implementation expects the message to contain
            // a 4 byte count of the number of fixed length secure stops
            // to follow.
            String count = String.format(""%04d"", releaseList.size());
            byte[] releaseMessage = new byte[count.length() + releaseListSize];

            byte[] buffer = count.getBytes();
            System.arraycopy(buffer, 0, releaseMessage, 0, count.length());

            int destPosition = count.length();
            for (int i = 0; i < releaseList.size(); ++i) {
                byte[] secureStop = releaseList.get(i);
                int secureStopSize = secureStop.length;
                System.arraycopy(secureStop, 0, releaseMessage, destPosition, secureStopSize);
                destPosition += secureStopSize;
            }

            drm.releaseSecureStops(releaseMessage);
            secureStops = drm.getSecureStops();
            secureStopIds = drm.getSecureStopIds();
            // All odd numbered secure stops are removed in the test,
            // leaving 2nd, 4th, 6th and the 8th element.
            assertEquals((NUMBER_OF_SECURE_STOPS - 1) / 2, secureStops.size());
            assertEquals((NUMBER_OF_SECURE_STOPS - 1 ) / 2, secureStopIds.size());

            Log.d(TAG, ""Test removeAllSecureStops."");
            drm.removeAllSecureStops();
            secureStops = drm.getSecureStops();
            assertTrue(secureStops.isEmpty());
            secureStopIds = drm.getSecureStopIds();
            assertTrue(secureStopIds.isEmpty());

            mMediaCodecPlayer.reset();
            closeSession(drm, mSessionId);
        } catch (Exception e) {
            throw new Error(""Unexpected exception"", e);
        } finally {
            if (sessionId != null) {
                drm.closeSession(sessionId);
            }
            stopDrm(drm);
        }
    }

    /**
     * Test that the framework handles a device returning
     * ::android::hardware::drm@1.2::Status::ERROR_DRM_RESOURCE_CONTENTION.
     * Expected behavior: throws MediaDrm.SessionException with
     * errorCode ERROR_RESOURCE_CONTENTION
     */
    @Presubmit"	"/home/gpoor/cts-12-source/cts/tests/tests/mediadrm/src/android/mediadrm/cts/MediaDrmClearkeyTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.mediadrm.cts.MediaDrmClearkeyTest"	"testResourceContentionError"	"CtsMediaDrmTestCases"	"1: ui"	"public void testResourceContentionError() {

        if (watchHasNoClearkeySupport()) {
            return;
        }

        MediaDrm drm = null;
        boolean gotException = false;

        try {
            drm = new MediaDrm(CLEARKEY_SCHEME_UUID);
            drm.setPropertyString(""drmErrorTest"", ""resourceContention"");
            byte[] sessionId = drm.openSession();

            try {
                byte[] ignoredInitData = new byte[] { 1 };
                drm.getKeyRequest(sessionId, ignoredInitData, ""cenc"", MediaDrm.KEY_TYPE_STREAMING, null);
            } catch (MediaDrm.SessionException e) {
                if (e.getErrorCode() != MediaDrm.SessionException.ERROR_RESOURCE_CONTENTION) {
                    throw new Error(""Expected transient ERROR_RESOURCE_CONTENTION"");
                }
                if(sIsAtLeastS && !e.isTransient()) {
                        throw new Error(""Expected transient ERROR_RESOURCE_CONTENTION"");
                }
                gotException = true;
            }
        } catch(Exception e) {
            throw new Error(""Unexpected exception "", e);
        } finally {
            if (drm != null) {
                drm.close();
            }
        }
        if (!gotException) {
            throw new Error(""Didn't receive expected MediaDrm.SessionException"");
        }
    }

    /**
     * Test sendExpirationUpdate and onExpirationUpdateListener
     *
     * Expected behavior: the EXPIRATION_UPDATE event arrives
     * at the onExpirationUpdateListener with the expiry time
     */
    @Presubmit"	"/home/gpoor/cts-12-source/cts/tests/tests/mediadrm/src/android/mediadrm/cts/MediaDrmClearkeyTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.mediadrm.cts.MediaDrmClearkeyTest"	"testOnExpirationUpdateListener"	"CtsMediaDrmTestCases"	"1: ui"	"public void testOnExpirationUpdateListener() {

        if (watchHasNoClearkeySupport()) {
            return;
        }

        MediaDrm drm = null;
        mSessionId = null;
        mExpirationUpdateReceived = false;

        // provideKeyResponse calls sendExpirationUpdate method
        // for testing purpose, we therefore start a license request
        // which calls provideKeyResonpse
        byte[][] clearKeyIds = new byte[][] { CLEAR_KEY_CENC };
        int keyType = MediaDrm.KEY_TYPE_STREAMING;
        String initDataType = new String(""cenc"");

        drm = startDrm(clearKeyIds,  initDataType, CLEARKEY_SCHEME_UUID, keyType);
        mSessionId = openSession(drm);
        try {
            if (!preparePlayback(
                    MIME_VIDEO_AVC,
                    new String[0],
                    Uri.parse(Utils.getMediaPath() + CENC_AUDIO_PATH), false /* audioEncrypted */ ,
                    Uri.parse(Utils.getMediaPath() + CENC_VIDEO_PATH), true /* videoEncrypted */,
                    VIDEO_WIDTH_CENC, VIDEO_HEIGHT_CENC, false /* scrambled */,
                    mSessionId, getSurfaces())) {
                closeSession(drm, mSessionId);
                stopDrm(drm);
                return;
            }
        } catch (Exception e) {
            throw new Error(""Unexpected exception "", e);
        }

        mDrmInitData = mMediaCodecPlayer.getDrmInitData();
        getKeys(drm, initDataType, mSessionId, mDrmInitData,
                    keyType, clearKeyIds);

        // wait for the event to arrive
        try {
            closeSession(drm, mSessionId);
            // wait up to 2 seconds for event
            for (int i = 0; i < 20 && !mExpirationUpdateReceived; i++) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                }
            }
            if (!mExpirationUpdateReceived) {
                throw new Error(""EXPIRATION_UPDATE event was not received by the listener"");
            }
          } catch (MediaDrmStateException e) {
                throw new Error(""Unexpected exception from closing session: "", e);
        } finally {
            stopDrm(drm);
        }
    }

    /**
     * Test that the onExpirationUpdateListener
     * listener is not called after
     * clearOnExpirationUpdateListener is called.
     */
    @Presubmit"	"/home/gpoor/cts-12-source/cts/tests/tests/mediadrm/src/android/mediadrm/cts/MediaDrmClearkeyTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.mediadrm.cts.MediaDrmClearkeyTest"	"testClearOnExpirationUpdateListener"	"CtsMediaDrmTestCases"	"1: ui"	"public void testClearOnExpirationUpdateListener() {

        if (watchHasNoClearkeySupport()) {
            return;
        }

        MediaDrm drm = null;
        mSessionId = null;
        mExpirationUpdateReceived = false;

        // provideKeyResponse calls sendExpirationUpdate method
        // for testing purpose, we therefore start a license request
        // which calls provideKeyResonpse
        byte[][] clearKeyIds = new byte[][] { CLEAR_KEY_CENC };
        int keyType = MediaDrm.KEY_TYPE_STREAMING;
        String initDataType = new String(""cenc"");

        drm = startDrm(clearKeyIds,  initDataType, CLEARKEY_SCHEME_UUID, keyType);
        mSessionId = openSession(drm);
        try {
            if (!preparePlayback(
                    MIME_VIDEO_AVC,
                    new String[0],
                    Uri.parse(Utils.getMediaPath() + CENC_AUDIO_PATH), false /* audioEncrypted */ ,
                    Uri.parse(Utils.getMediaPath() + CENC_VIDEO_PATH), true /* videoEncrypted */,
                    VIDEO_WIDTH_CENC, VIDEO_HEIGHT_CENC, false /* scrambled */,
                    mSessionId, getSurfaces())) {
                closeSession(drm, mSessionId);
                stopDrm(drm);
                return;
            }
        } catch (Exception e) {
            throw new Error(""Unexpected exception "", e);
        }

        // clear the expiration update listener
        drm.clearOnExpirationUpdateListener();
        mDrmInitData = mMediaCodecPlayer.getDrmInitData();
        getKeys(drm, initDataType, mSessionId, mDrmInitData,
                    keyType, clearKeyIds);

        // wait for the event, it should not arrive
        // because the expiration update listener has been cleared
        try {
            closeSession(drm, mSessionId);
            // wait up to 2 seconds for event
            for (int i = 0; i < 20 && !mExpirationUpdateReceived; i++) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                }
            }
            if (mExpirationUpdateReceived) {
                throw new Error(""onExpirationUpdateListener should not be called"");
            }
        } catch (MediaDrmStateException e) {
              throw new Error(""Unexpected exception from closing session: "", e);
        } finally {
            stopDrm(drm);
        }
    }

    /**
     * Test that after onClearEventListener is called,
     * MediaDrm's event listener is not called.
     *
     * Clearkey plugin's provideKeyResponse method sends a
     * vendor defined event to the media drm event listener
     * for testing purpose. Check that after onClearEventListener
     * is called, the event listener is not called.
     */
    @Presubmit"	"/home/gpoor/cts-12-source/cts/tests/tests/mediadrm/src/android/mediadrm/cts/MediaDrmClearkeyTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.mediadrm.cts.MediaDrmClearkeyTest"	"testClearOnEventListener"	"CtsMediaDrmTestCases"	"1: ui"	"public void testClearOnEventListener() {

        if (watchHasNoClearkeySupport()) {
            return;
        }

        MediaDrm drm = null;
        mSessionId = null;
        mEventListenerCalled = false;

        // provideKeyResponse in clearkey plugin sends a
        // vendor defined event to test the event listener;
        // we therefore start a license request which will
        // call provideKeyResonpse
        byte[][] clearKeyIds = new byte[][] { CLEAR_KEY_CENC };
        int keyType = MediaDrm.KEY_TYPE_STREAMING;
        String initDataType = new String(""cenc"");

        drm = startDrm(clearKeyIds,  initDataType, CLEARKEY_SCHEME_UUID, keyType);
        mSessionId = openSession(drm);
        try {
            if (!preparePlayback(
                    MIME_VIDEO_AVC,
                    new String[0],
                    Uri.parse(Utils.getMediaPath() + CENC_AUDIO_PATH), false /* audioEncrypted */ ,
                    Uri.parse(Utils.getMediaPath() + CENC_VIDEO_PATH), true /* videoEncrypted */,
                    VIDEO_WIDTH_CENC, VIDEO_HEIGHT_CENC, false /* scrambled */,
                    mSessionId, getSurfaces())) {
                closeSession(drm, mSessionId);
                stopDrm(drm);
                return;
            }
        } catch (Exception e) {
            throw new Error(""Unexpected exception "", e);
        }

        // test that the onEvent listener is called
        mDrmInitData = mMediaCodecPlayer.getDrmInitData();
        getKeys(drm, initDataType, mSessionId, mDrmInitData,
                    keyType, clearKeyIds);

        // wait for the vendor defined event, it should not arrive
        // because the event listener is cleared
        try {
            // wait up to 2 seconds for event
            for (int i = 0; i < 20 && !mEventListenerCalled; i++) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                }
            }
            if (!mEventListenerCalled) {
                closeSession(drm, mSessionId);
                stopDrm(drm);
                throw new Error(""onEventListener should be called"");
            }
        } catch (MediaDrmStateException e) {
              closeSession(drm, mSessionId);
              stopDrm(drm);
              throw new Error(""Unexpected exception from closing session: "", e);
        }

        // clear the drm event listener
        // and test that the onEvent listener is not called
        mEventListenerCalled = false;
        drm.clearOnEventListener();
        getKeys(drm, initDataType, mSessionId, mDrmInitData,
                    keyType, clearKeyIds);

        // wait for the vendor defined event, it should not arrive
        // because the event listener is cleared
        try {
            closeSession(drm, mSessionId);
            // wait up to 2 seconds for event
            for (int i = 0; i < 20 && !mEventListenerCalled; i++) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                }
            }
            if (mEventListenerCalled) {
                throw new Error(""onEventListener should not be called"");
            }
        } catch (MediaDrmStateException e) {
              throw new Error(""Unexpected exception from closing session: "", e);
        } finally {
            stopDrm(drm);
        }
    }

    /**
     * Test that the framework handles a device returning invoking
     * the ::android::hardware::drm@1.2::sendSessionLostState callback
     * Expected behavior: OnSessionLostState is called with
     * the sessionId
     */
    @Presubmit"	"/home/gpoor/cts-12-source/cts/tests/tests/mediadrm/src/android/mediadrm/cts/MediaDrmClearkeyTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.mediadrm.cts.MediaDrmClearkeyTest"	"testSessionLostStateError"	"CtsMediaDrmTestCases"	"1: ui"	"public void testSessionLostStateError() {

        if (watchHasNoClearkeySupport()) {
            return;
        }

        boolean gotException = false;
        mLostStateReceived = false;

        MediaDrm drm = startDrm(new byte[][] { CLEAR_KEY_CENC }, ""cenc"",
                CLEARKEY_SCHEME_UUID, MediaDrm.KEY_TYPE_STREAMING);

        mDrm.setPropertyString(""drmErrorTest"", ""lostState"");
        mSessionId = openSession(drm);

        // simulates session lost state here, detected by closeSession

        try {
            try {
                closeSession(drm, mSessionId);
            } catch (MediaDrmStateException e) {
                gotException = true; // expected for lost state
            }
            // wait up to 2 seconds for event
            for (int i = 0; i < 20 && !mLostStateReceived; i++) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                }
            }
            if (!mLostStateReceived) {
                throw new Error(""Callback for OnSessionLostStateListener not received"");
            }
        } catch(Exception e) {
            throw new Error(""Unexpected exception "", e);
        } finally {
            stopDrm(drm);
        }
        if (!gotException) {
            throw new Error(""Didn't receive expected MediaDrmStateException"");
        }
    }

    /**
     * Test that the framework handles a device ignoring
     * events for the onSessionLostStateListener after
     * clearOnSessionLostStateListener is called.
     *
     * Expected behavior: OnSessionLostState is not called with
     * the sessionId
     */
    @Presubmit"	"/home/gpoor/cts-12-source/cts/tests/tests/mediadrm/src/android/mediadrm/cts/MediaDrmClearkeyTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.mediadrm.cts.MediaDrmClearkeyTest"	"testClearOnSessionLostStateListener"	"CtsMediaDrmTestCases"	"1: ui"	"public void testClearOnSessionLostStateListener() {

        if (watchHasNoClearkeySupport()) {
            return;
        }

        boolean gotException = false;
        mLostStateReceived = false;

        MediaDrm drm = startDrm(new byte[][] { CLEAR_KEY_CENC }, ""cenc"",
                CLEARKEY_SCHEME_UUID, MediaDrm.KEY_TYPE_STREAMING);

        mDrm.setPropertyString(""drmErrorTest"", ""lostState"");
        mSessionId = openSession(drm);

        // Simulates session lost state here, event is sent from closeSession.
        // The session lost state should not arrive in the listener
        // after clearOnSessionLostStateListener() is called.
        try {
            try {
                mDrm.clearOnSessionLostStateListener();
                Thread.sleep(2000);
                closeSession(drm, mSessionId);
            } catch (MediaDrmStateException e) {
                gotException = true; // expected for lost state
            }
            // wait up to 2 seconds for event
            for (int i = 0; i < 20 && !mLostStateReceived; i++) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                }
            }
            if (mLostStateReceived) {
                throw new Error(""Should not receive callback for OnSessionLostStateListener"");
            }
        } catch(Exception e) {
            throw new Error(""Unexpected exception "", e);
        } finally {
            stopDrm(drm);
        }
        if (!gotException) {
            throw new Error(""Didn't receive expected MediaDrmStateException"");
        }
    }

    @Presubmit"	"/home/gpoor/cts-12-source/cts/tests/tests/mediadrm/src/android/mediadrm/cts/MediaDrmClearkeyTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.mediadrm.cts.MediaDrmClearkeyTest"	"testIsCryptoSchemeSupportedWithSecurityLevel"	"CtsMediaDrmTestCases"	"1: ui"	"public void testIsCryptoSchemeSupportedWithSecurityLevel() {
        if (watchHasNoClearkeySupport()) {
            return;
        }

        if (MediaDrm.isCryptoSchemeSupported(CLEARKEY_SCHEME_UUID, ""cenc"",
                                             MediaDrm.SECURITY_LEVEL_HW_SECURE_ALL)) {
            throw new Error(""Clearkey claims to support SECURITY_LEVEL_HW_SECURE_ALL"");
        }
        if (!MediaDrm.isCryptoSchemeSupported(CLEARKEY_SCHEME_UUID, ""cenc"",
                                              MediaDrm.SECURITY_LEVEL_SW_SECURE_CRYPTO)) {
            throw new Error(""Clearkey claims not to support SECURITY_LEVEL_SW_SECURE_CRYPTO"");
        }
    }

    @Presubmit
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	"/home/gpoor/cts-12-source/cts/tests/tests/mediadrm/src/android/mediadrm/cts/MediaDrmClearkeyTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.mediadrm.cts.MediaDrmClearkeyTest"	"testMediaDrmStateExceptionErrorCode"	"CtsMediaDrmTestCases"	"1: ui"	"public void testMediaDrmStateExceptionErrorCode()
            throws ResourceBusyException, UnsupportedSchemeException, NotProvisionedException {
        if (watchHasNoClearkeySupport()) {
            return;
        }

        MediaDrm drm = null;
        try {
            drm = new MediaDrm(CLEARKEY_SCHEME_UUID);
            byte[] sessionId = drm.openSession();
            drm.closeSession(sessionId);

            byte[] ignoredInitData = new byte[]{1};
            drm.getKeyRequest(sessionId, ignoredInitData, ""cenc"",
                    MediaDrm.KEY_TYPE_STREAMING,
                    null);
        } catch(MediaDrmStateException e) {
            Log.i(TAG, ""Verifying exception error code"", e);
            assertFalse(""ERROR_SESSION_NOT_OPENED requires new session"", e.isTransient());
            assertEquals(""Expected ERROR_SESSION_NOT_OPENED"",
                    MediaDrm.ErrorCodes.ERROR_SESSION_NOT_OPENED, e.getErrorCode());
        }  finally {
            if (drm != null) {
                drm.close();
            }
        }
    }

    private String getClearkeyVersion(MediaDrm drm) {
        try {
            return drm.getPropertyString(""version"");
        } catch (Exception e) {
            return ""unavailable"";
        }
    }

    private boolean cannotHandleGetPropertyByteArray(MediaDrm drm) {
        boolean apiNotSupported = false;
        byte[] bytes = new byte[0];
        try {
            bytes = drm.getPropertyByteArray(DEVICEID_PROPERTY_KEY);
        } catch (IllegalArgumentException e) {
            // Expected exception for invalid key or api not implemented
            apiNotSupported = true;
        }
        return apiNotSupported;
    }

    private boolean cannotHandleSetPropertyString(MediaDrm drm) {
        boolean apiNotSupported = false;
        final byte[] bytes = new byte[0];
        try {
            drm.setPropertyString(LISTENER_TEST_SUPPORT_PROPERTY_KEY, ""testing"");
        } catch (IllegalArgumentException e) {
            // Expected exception for invalid key or api not implemented
            apiNotSupported = true;
        }
        return apiNotSupported;
    }

    private boolean watchHasNoClearkeySupport() {
        if (!MediaDrm.isCryptoSchemeSupported(CLEARKEY_SCHEME_UUID)) {
            if (isWatchDevice()) {
                return true;
            } else {
                throw new Error(ERR_MSG_CRYPTO_SCHEME_NOT_SUPPORTED);
            }
        }
        return false;
    }

    private List<Surface> getSurfaces() {
        return Arrays.asList(getActivity().getSurfaceHolder().getSurface());
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/mediadrm/src/android/mediadrm/cts/MediaDrmClearkeyTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.managedprofile.ActivePasswordSufficientForDeviceTest"	"testActivePsswordSufficientForDevice_notCallableOnProfileInstance"	""	"1: ui"	"public void testActivePsswordSufficientForDevice_notCallableOnProfileInstance() {
        assertThrows(SecurityException.class,
                () -> mDevicePolicyManager.isActivePasswordSufficientForDeviceRequirement());
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/ActivePasswordSufficientForDeviceTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.managedprofile.ActivePasswordSufficientForDeviceTest"	"testActivePsswordSufficientForDevice_NoPolicy"	""	"1: ui"	"public void testActivePsswordSufficientForDevice_NoPolicy() {
        assertTrue(mParentDevicePolicyManager.isActivePasswordSufficientForDeviceRequirement());
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/ActivePasswordSufficientForDeviceTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.managedprofile.ActivePasswordSufficientForDeviceTest"	"testActivePsswordSufficientForDevice_UnmetParentPolicy"	""	"1: ui"	"public void testActivePsswordSufficientForDevice_UnmetParentPolicy() {
        mParentDevicePolicyManager.setRequiredPasswordComplexity(PASSWORD_COMPLEXITY_MEDIUM);
        assertFalse(mParentDevicePolicyManager.isActivePasswordSufficientForDeviceRequirement());
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/ActivePasswordSufficientForDeviceTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.managedprofile.ActivePasswordSufficientForDeviceTest"	"testActivePsswordSufficientForDevice_IrrelevantProfilePolicy"	""	"1: ui"	"public void testActivePsswordSufficientForDevice_IrrelevantProfilePolicy() {
        mDevicePolicyManager.setPasswordQuality(ADMIN_RECEIVER_COMPONENT, PASSWORD_QUALITY_NUMERIC);
        mDevicePolicyManager.setPasswordMinimumLength(ADMIN_RECEIVER_COMPONENT, 4);
        mDevicePolicyManager.setRequiredPasswordComplexity(PASSWORD_COMPLEXITY_MEDIUM);
        assertTrue(mParentDevicePolicyManager.isActivePasswordSufficientForDeviceRequirement());
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/ActivePasswordSufficientForDeviceTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.managedprofile.ActivePasswordSufficientForDeviceTest"	"testActivePsswordSufficientForDevice_UnifiedPassword_BothPolicies"	""	"3: ui system user"	"public void testActivePsswordSufficientForDevice_UnifiedPassword_BothPolicies() {
        changeUserCredential(""1234"", null, USER_SYSTEM);
        try {
            mDevicePolicyManager.setPasswordQuality(ADMIN_RECEIVER_COMPONENT,
                    PASSWORD_QUALITY_ALPHANUMERIC);
            mDevicePolicyManager.setPasswordMinimumLength(ADMIN_RECEIVER_COMPONENT, 4);
            mParentDevicePolicyManager.setRequiredPasswordComplexity(PASSWORD_COMPLEXITY_LOW);

            assertFalse(mDevicePolicyManager.isActivePasswordSufficient());
            assertTrue(mParentDevicePolicyManager.isActivePasswordSufficientForDeviceRequirement());
        } finally {
            mDevicePolicyManager.setPasswordQuality(ADMIN_RECEIVER_COMPONENT,
                    PASSWORD_QUALITY_UNSPECIFIED);
            mParentDevicePolicyManager.setRequiredPasswordComplexity(PASSWORD_COMPLEXITY_NONE);
            changeUserCredential(null, ""1234"", USER_SYSTEM);
        }
    }

    //TODO: reinstate test once LockSettingsShellCommand allows setting password for profiles
    // that have unified challenge b/176230819
    private void toTestActivePsswordSufficientForDevice_SeparatePassword_BothPolicies() {
        final int myUserId = UserHandle.getUserId(Process.myUid());
        changeUserCredential(""1234"", null, USER_SYSTEM);
        changeUserCredential(""asdf12"", ""1234"", myUserId); // This currently fails
        try {
            mDevicePolicyManager.setRequiredPasswordComplexity(PASSWORD_COMPLEXITY_LOW);
            mParentDevicePolicyManager.setRequiredPasswordComplexity(PASSWORD_COMPLEXITY_HIGH);

            assertTrue(mDevicePolicyManager.isActivePasswordSufficient());
            assertFalse(
                    mParentDevicePolicyManager.isActivePasswordSufficientForDeviceRequirement());
        } finally {
            mDevicePolicyManager.setRequiredPasswordComplexity(PASSWORD_COMPLEXITY_NONE);
            mParentDevicePolicyManager.setRequiredPasswordComplexity(PASSWORD_COMPLEXITY_NONE);
            changeUserCredential(null, ""1234"", USER_SYSTEM);
        }
    }

    private void changeUserCredential(String newCredential, String oldCredential, int userId) {
        final String oldCredentialArgument = (oldCredential == null || oldCredential.isEmpty()) ? """"
                : (""--old "" + oldCredential);
        if (newCredential != null && !newCredential.isEmpty()) {
            String commandOutput = SystemUtil.runShellCommand(String.format(
                    ""cmd lock_settings set-password --user %d %s %s"", userId, oldCredentialArgument,
                    newCredential));
            if (!commandOutput.startsWith(""Password set to"")) {
                fail(""Failed to set user credential: "" + commandOutput);
            }
        } else {
            String commandOutput = SystemUtil.runShellCommand(String.format(
                    ""cmd lock_settings clear --user %d %s"", userId, oldCredentialArgument));
            if (!commandOutput.startsWith(""Lock credential cleared"")) {
                fail(""Failed to clear user credential: "" + commandOutput);
            }
        }
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/ActivePasswordSufficientForDeviceTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.jdwpsecurity.cts.JdwpSecurityHostTest"	"testNonZygoteProgramIsNotDebuggable"	"CtsJdwpSecurityHostTestCases"	"2: ui system"	"public void testNonZygoteProgramIsNotDebuggable() throws Exception {
        String scriptFilepath = getDeviceScriptFilepath();
        Process scriptProcess = null;
        String scriptPid = null;
        List<String> activeJdwpPids = null;
        try {
            // Run the script on the background so it's running when we collect the list of
            // pids with a JDWP connection using 'adb jdwp'.
            // command.
            scriptProcess = runScriptInBackground(scriptFilepath);

            // On startup, the script will print its pid on its output.
            scriptPid = readScriptPid(scriptProcess);

            // Collect the list of pids with a JDWP connection.
            activeJdwpPids = getJdwpPids();
        } finally {
            // Stop the script.
            if (scriptProcess != null) {
                scriptProcess.destroy();
            }
        }

        assertNotNull(""Failed to get script pid"", scriptPid);
        assertNotNull(""Failed to get active JDWP pids"", activeJdwpPids);
        assertFalse(""Test app should not have an active JDWP connection"" +
                "" (pid "" + scriptPid + "" is returned by 'adb jdwp')"",
                activeJdwpPids.contains(scriptPid));
    }

    private Process runScriptInBackground(String scriptFilepath) throws IOException {
        String[] shellScriptCommand = buildAdbCommand(""shell"", scriptFilepath);
        return RunUtil.getDefault().runCmdInBackground(shellScriptCommand);
    }

    private String readScriptPid(Process scriptProcess) throws IOException {
        BufferedReader br = null;
        try {
            br = new BufferedReader(new InputStreamReader(scriptProcess.getInputStream()));
            // We only expect to read one line containing the pid.
            return br.readLine();
        } finally {
            if (br != null) {
                br.close();
            }
        }
    }

    private List<String> getJdwpPids() throws Exception {
        return new AdbJdwpOutputReader().listPidsWithAdbJdwp();
    }

    /**
     * Creates the script file on the host so it can be pushed onto the device.
     *
     * @return the script file
     * @throws IOException
     */
    private static File createScriptTempFile() throws IOException {
        File tempFile = File.createTempFile(""jdwptest"", "".tmp"");

        PrintWriter pw = null;
        try {
            pw = new PrintWriter(tempFile);

            // We need a dalvik-cache in /data/local/tmp so we have read-write access.
            // Note: this will cause the runtime to optimize the DEX file (contained in
            // the jar file) before executing it.
            pw.println(String.format(""export ANDROID_DATA=%s"", DEVICE_LOCATION));
            pw.println(String.format(""export CLASSPATH=%s"", getDeviceJarFilepath()));
            pw.println(String.format(""exec app_process /system/bin %s \""$@\"""",
                    JAR_MAIN_CLASS_NAME));
        } finally {
            if (pw != null) {
                pw.close();
            }
        }

        return tempFile;
    }

    /**
     * Helper class collecting all pids returned by 'adb jdwp' command.
     */
    private class AdbJdwpOutputReader implements Runnable {
        /**
         * A list of all pids with a JDWP connection returned by 'adb jdwp'.
         */
        private final List<String> lines = new ArrayList<String>();

        /**
         * The input stream of the process running 'adb jdwp'.
         */
        private InputStream in;

        public List<String> listPidsWithAdbJdwp() throws Exception {
            // The 'adb jdwp' command does not return normally, it only terminates with Ctrl^C.
            // Therefore we cannot use ITestDevice.executeAdbCommand but need to run that command
            // in the background. Since we know the tested app is already running, we only need to
            // capture the output for a short amount of time before stopping the 'adb jdwp'
            // command.
            String[] adbJdwpCommand = buildAdbCommand(""jdwp"");
            Process adbProcess = RunUtil.getDefault().runCmdInBackground(adbJdwpCommand);
            in = adbProcess.getInputStream();

            // Read the output for 5s in a separate thread before stopping the command.
            Thread t = new Thread(this);
            t.start();
            Thread.sleep(5000);

            // Kill the 'adb jdwp' process and wait for the thread to stop.
            adbProcess.destroy();
            t.join();

            return lines;
        }

        @Override
        public void run() {
            BufferedReader br = null;
            try {
                br = new BufferedReader(new InputStreamReader(in));
                String line;
                while ((line = readLineIgnoreException(br)) != null) {
                    lines.add(line);
                }
            } catch (IOException e) {
                CLog.e(e);
            } finally {
                if (br != null) {
                    try {
                        br.close();
                    } catch (IOException e) {
                        // Ignore it.
                    }
                }
            }
        }

        private String readLineIgnoreException(BufferedReader reader) throws IOException {
            try {
                return reader.readLine();
            } catch (IOException e) {
                if (e instanceof EOFException) {
                    // This is expected when the process's input stream is closed.
                    return null;
                } else {
                    throw e;
                }
            }
        }
    }

    private String[] buildAdbCommand(String... args) {
        return ArrayUtil.buildArray(new String[] {""adb"", ""-s"", getDevice().getSerialNumber()},
                args);
    }

    private boolean createRemoteDir(String remoteFilePath) throws DeviceNotAvailableException {
        if (getDevice().doesFileExist(remoteFilePath)) {
            return true;
        }
        File remoteFile = new File(remoteFilePath);
        String parentPath = remoteFile.getParent();
        if (parentPath != null) {
            if (!createRemoteDir(parentPath)) {
                return false;
            }
        }
        getDevice().executeShellCommand(String.format(""mkdir %s"", remoteFilePath));
        return getDevice().doesFileExist(remoteFilePath);
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/jdwpsecurity/src/android/jdwpsecurity/cts/JdwpSecurityHostTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.verifier.nfc.hce.ScreenOnOnlyOffHostEmulatorActivity"	"setPassFailButtonClickListeners"	""	"1: ui"	"public void testpackage com.android.cts.verifier.nfc.hce;

import android.annotation.TargetApi;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;

import com.android.cts.verifier.R;
import com.android.cts.verifier.nfc.NfcDialogs;

public class ScreenOnOnlyOffHostEmulatorActivity extends BaseEmulatorActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();
        setupServices(this, ScreenOnOnlyOffHostService.COMPONENT);
    }

    @Override
    protected void onResume() {
        super.onResume();
    }

    @Override
    void onServicesSetup(boolean result) {
        NfcDialogs.createHceTapReaderDialog(this, getString(R.string.nfc_screen_on_only_offhost_help)).show();
    }

    public static Intent buildReaderIntent(Context context) {
        Intent readerIntent = new Intent(context, SimpleReaderActivity.class);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_APDUS,
                ScreenOnOnlyOffHostService.APDU_COMMAND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_RESPONSES,
                ScreenOnOnlyOffHostService.APDU_RESPOND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_LABEL,
                context.getString(R.string.nfc_screen_on_only_offhost_reader));
        return readerIntent;
    }

    @Override
    void onApduSequenceComplete(ComponentName component, long duration) {
    }
}"	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/ScreenOnOnlyOffHostEmulatorActivity.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.os.cts.deviceidle.DeviceIdleTest"	"testDeviceIdleManager"	"CtsBatterySavingTestCases"	"1: system"	"public void testDeviceIdleManager() {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        assertNotNull(context.getSystemService(Context.DEVICE_IDLE_CONTROLLER));
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/batterysaving/src/android/os/cts/deviceidle/DeviceIdleTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.os.cts.deviceidle.DeviceIdleTest"	"testPowerManagerIgnoringBatteryOptimizations"	"CtsBatterySavingTestCases"	"1: system"	"public void testPowerManagerIgnoringBatteryOptimizations() {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();

        assertTrue(context.getSystemService(PowerManager.class)
                .isIgnoringBatteryOptimizations(""com.android.shell""));
        assertFalse(context.getSystemService(PowerManager.class)
                .isIgnoringBatteryOptimizations(""no.such.package.!!!""));
    }

}"	"/home/gpoor/cts-12-source/cts/tests/tests/batterysaving/src/android/os/cts/deviceidle/DeviceIdleTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.net.wifi.cts.WifiLockTest"	"testHiPerfWifiLock"	"CtsWifiTestCases"	"1: ui"	"public void testHiPerfWifiLock() {
        testWifiLock(WifiManager.WIFI_MODE_FULL_HIGH_PERF);
    }

    /**
     * Verify acquire and release of Low latency wifi locks
     */"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLockTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.net.wifi.cts.WifiLockTest"	"testLowLatencyWifiLock"	"CtsWifiTestCases"	"2: ui system"	"public void testLowLatencyWifiLock() {
        testWifiLock(WifiManager.WIFI_MODE_FULL_LOW_LATENCY);
    }

    private void testWifiLock(int lockType) {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        WifiManager wm = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        WifiLock wl = wm.createWifiLock(lockType, WIFI_TAG);

        wl.setReferenceCounted(true);
        wl.setWorkSource(new WorkSource());
        assertFalse(wl.isHeld());
        wl.acquire();
        assertTrue(wl.isHeld());
        wl.release();
        assertFalse(wl.isHeld());
        wl.acquire();
        wl.acquire();
        assertTrue(wl.isHeld());
        wl.release();
        assertTrue(wl.isHeld());
        wl.release();
        assertFalse(wl.isHeld());
        assertNotNull(wl.toString());
        try {
            wl.release();
            fail(""should throw out exception because release is called""
                    +"" a greater number of times than acquire"");
        } catch (RuntimeException e) {
            // expected
        }

        wl = wm.createWifiLock(lockType, WIFI_TAG);
        wl.setReferenceCounted(false);
        assertFalse(wl.isHeld());
        wl.acquire();
        assertTrue(wl.isHeld());
        wl.release();
        assertFalse(wl.isHeld());
        wl.acquire();
        wl.acquire();
        assertTrue(wl.isHeld());
        wl.release();
        assertFalse(wl.isHeld());
        assertNotNull(wl.toString());
        // releasing again after release: but ignored for non-referenced locks
        wl.release();
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLockTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.media.cts.MediaSessionTestService"	"testSeriesOfSetQueue_check"	"CtsMediaTestCases"	"1: mic"	"public void test/*
 *.
 */

package android.media.cts;

import static org.junit.Assert.assertTrue;

import static java.util.concurrent.TimeUnit.MILLISECONDS;

import android.annotation.Nullable;
import android.media.session.MediaController;
import android.media.session.MediaSession;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;

import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicInteger;

public class MediaSessionTestService extends RemoteService {
    public static final int TEST_SERIES_OF_SET_QUEUE = 0;
    public static final int TEST_SET_QUEUE = 1;

    public static final int STEP_SET_UP = 0;
    public static final int STEP_CHECK = 1;
    public static final int STEP_CLEAN_UP = 2;

    public static final String KEY_SESSION_TOKEN = ""sessionToken"";
    public static final String KEY_EXPECTED_TOTAL_NUMBER_OF_ITEMS = ""expectedTotalNumberOfItems"";
    public static final String KEY_EXPECTED_QUEUE_SIZE = ""expectedQueueSize"";

    private MediaController mMediaController;
    private MediaController.Callback mMediaControllerCallback;
    private CountDownLatch mAllItemsNotified;
    private CountDownLatch mQueueNotified;

    private void testSeriesOfSetQueue_setUp(Bundle args) {
        MediaSession.Token token = args.getParcelable(KEY_SESSION_TOKEN);
        int expectedTotalNumberOfItems = args.getInt(KEY_EXPECTED_TOTAL_NUMBER_OF_ITEMS);

        mAllItemsNotified = new CountDownLatch(1);
        AtomicInteger numberOfItems = new AtomicInteger();
        mMediaControllerCallback = new MediaController.Callback() {
            @Override
            public void onQueueChanged(List<MediaSession.QueueItem> queue) {
                if (queue != null) {
                    if (numberOfItems.addAndGet(queue.size()) >= expectedTotalNumberOfItems) {
                        mAllItemsNotified.countDown();
                    }
                }
            }
        };
        mMediaController = new MediaController(this, token);
        mMediaController.registerCallback(mMediaControllerCallback,
                new Handler(Looper.getMainLooper()));
    }

    private void testSeriesOfSetQueue_check() throws Exception {
        assertTrue(mAllItemsNotified.await(TIMEOUT_MS, MILLISECONDS));
    }

    private void testSeriesOfSetQueue_cleanUp() {
        mMediaController.unregisterCallback(mMediaControllerCallback);
        mMediaController = null;
        mMediaControllerCallback = null;
        mAllItemsNotified = null;
    }

    private void testSetQueue_setUp(Bundle args) {
        MediaSession.Token token = args.getParcelable(KEY_SESSION_TOKEN);
        int expectedQueueSize = args.getInt(KEY_EXPECTED_QUEUE_SIZE);

        mQueueNotified = new CountDownLatch(1);
        mMediaControllerCallback = new MediaController.Callback() {
            @Override
            public void onQueueChanged(List<MediaSession.QueueItem> queue) {
                if (queue != null && queue.size() == expectedQueueSize) {
                    mQueueNotified.countDown();
                }
            }
        };
        mMediaController = new MediaController(this, token);
        mMediaController.registerCallback(mMediaControllerCallback,
                new Handler(Looper.getMainLooper()));
    }

    private void testSetQueue_check() throws Exception {
        assertTrue(mQueueNotified.await(TIMEOUT_MS, MILLISECONDS));
    }

    private void testSetQueue_cleanUp() {
        mMediaController.unregisterCallback(mMediaControllerCallback);
        mMediaController = null;
        mMediaControllerCallback = null;
        mQueueNotified = null;
    }

    @Override
    public void onRun(int testId, int step, @Nullable Bundle args) throws Exception {
        if (testId == TEST_SERIES_OF_SET_QUEUE) {
            if (step == STEP_SET_UP) {
                testSeriesOfSetQueue_setUp(args);
            } else if (step == STEP_CHECK) {
                testSeriesOfSetQueue_check();
            } else if (step == STEP_CLEAN_UP) {
                testSeriesOfSetQueue_cleanUp();
            } else {
                throw new IllegalArgumentException(""Unknown step="" + step);
            }
        } else if (testId == TEST_SET_QUEUE) {
            if (step == STEP_SET_UP) {
                testSetQueue_setUp(args);
            } else if (step == STEP_CHECK) {
                testSetQueue_check();
            } else if (step == STEP_CLEAN_UP) {
                testSetQueue_cleanUp();
            } else {
                throw new IllegalArgumentException(""Unknown step="" + step);
            }

        } else {
            throw new IllegalArgumentException(""Unknown testId="" + testId);
        }
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaSessionTestService.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.devicepolicy.LauncherAppsSingleUserTest"	"uninstallTestApps"	"CtsDevicePolicyManagerTestCases"	"2: apps user"	"/*
 *.
 */

package com.android.cts.devicepolicy;

import static org.junit.Assume.assumeTrue;

import android.platform.test.annotations.FlakyTest;

import org.junit.Test;

import java.util.Collections;

/**
 * Set of tests for LauncherApps with managed profiles.
 */
public class LauncherAppsSingleUserTest extends BaseLauncherAppsTest {

    private final static String FEATURE_INCREMENTAL_DELIVERY =
            ""android.software.incremental_delivery"";
    private boolean mHasLauncherApps;
    private String mSerialNumber;
    private int mCurrentUserId;

    @Override
    public void setUp() throws Exception {
        super.setUp();
        mHasLauncherApps = getDevice().getApiLevel() >= 21;

        if (mHasLauncherApps) {
            mCurrentUserId = getDevice().getCurrentUser();
            mSerialNumber = Integer.toString(getUserSerialNumber(mCurrentUserId));
            uninstallTestApps();
            installTestApps(mCurrentUserId);
        }
    }

    @Override
    public void tearDown() throws Exception {
        if (mHasLauncherApps) {
            uninstallTestApps();
        }
        super.tearDown();
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/LauncherAppsSingleUserTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.devicepolicy.LauncherAppsSingleUserTest"	"testInstallAppMainUser"	"CtsDevicePolicyManagerTestCases"	"2: apps user"	"public void testInstallAppMainUser() throws Exception {
        if (!mHasLauncherApps) {
            return;
        }
        installAppAsUser(SIMPLE_APP_APK, mCurrentUserId);
        runDeviceTestsAsUser(LAUNCHER_TESTS_PKG,
                LAUNCHER_TESTS_CLASS, ""testSimpleAppInstalledForUser"",
                mCurrentUserId, Collections.singletonMap(PARAM_TEST_USER, mSerialNumber));
    }

    //TODO(b/171574935): make sure to migrate this to the new test infra"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/LauncherAppsSingleUserTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.devicepolicy.LauncherAppsSingleUserTest"	"testInstallAppMainUserIncremental"	"CtsDevicePolicyManagerTestCases"	"2: apps user"	"public void testInstallAppMainUserIncremental() throws Exception {
        assumeTrue(""true\n"".equals(getDevice().executeShellCommand(
                ""pm has-feature android.software.incremental_delivery"")));
        if (!mHasLauncherApps) {
            return;
        }
        installAppIncremental(SIMPLE_APP_APK);
        runDeviceTestsAsUser(LAUNCHER_TESTS_PKG,
                LAUNCHER_TESTS_CLASS, ""testSimpleAppInstalledForUser"",
                mCurrentUserId, Collections.singletonMap(PARAM_TEST_USER, mSerialNumber));
    }

    @FlakyTest"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/LauncherAppsSingleUserTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.devicepolicy.LauncherAppsSingleUserTest"	"testLauncherCallbackPackageAddedMainUser"	"CtsDevicePolicyManagerTestCases"	"2: apps user"	"public void testLauncherCallbackPackageAddedMainUser() throws Exception {
        if (!mHasLauncherApps) {
            return;
        }
        startCallbackService(mCurrentUserId);
        installAppAsUser(SIMPLE_APP_APK, mCurrentUserId);

        runDeviceTestsAsUser(LAUNCHER_TESTS_PKG,
                LAUNCHER_TESTS_CLASS,
                ""testPackageAddedCallbackForUser"",
                mCurrentUserId, Collections.singletonMap(PARAM_TEST_USER, mSerialNumber));
    }

    @FlakyTest"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/LauncherAppsSingleUserTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.devicepolicy.LauncherAppsSingleUserTest"	"testLauncherCallbackPackageRemovedMainUser"	"CtsDevicePolicyManagerTestCases"	"2: apps user"	"public void testLauncherCallbackPackageRemovedMainUser() throws Exception {
        if (!mHasLauncherApps) {
            return;
        }
        installAppAsUser(SIMPLE_APP_APK, mCurrentUserId);
        startCallbackService(mCurrentUserId);
        getDevice().uninstallPackage(SIMPLE_APP_PKG);
        runDeviceTestsAsUser(LAUNCHER_TESTS_PKG,
                LAUNCHER_TESTS_CLASS,
                ""testPackageRemovedCallbackForUser"",
                mCurrentUserId, Collections.singletonMap(PARAM_TEST_USER, mSerialNumber));
    }

    @FlakyTest"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/LauncherAppsSingleUserTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.devicepolicy.LauncherAppsSingleUserTest"	"testLauncherCallbackPackageChangedMainUser"	"CtsDevicePolicyManagerTestCases"	"2: apps user"	"public void testLauncherCallbackPackageChangedMainUser() throws Exception {
        if (!mHasLauncherApps) {
            return;
        }
        installAppAsUser(SIMPLE_APP_APK, mCurrentUserId);
        startCallbackService(mCurrentUserId);
        installAppAsUser(SIMPLE_APP_APK, mCurrentUserId);
        runDeviceTestsAsUser(LAUNCHER_TESTS_PKG,
                LAUNCHER_TESTS_CLASS,
                ""testPackageChangedCallbackForUser"",
                mCurrentUserId, Collections.singletonMap(PARAM_TEST_USER, mSerialNumber));
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/LauncherAppsSingleUserTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.devicepolicy.LauncherAppsSingleUserTest"	"testLauncherNonExportedAppFails"	"CtsDevicePolicyManagerTestCases"	"2: apps user"	"public void testLauncherNonExportedAppFails() throws Exception {
        if (!mHasLauncherApps) {
            return;
        }
        installAppAsUser(SIMPLE_APP_APK, mCurrentUserId);
        runDeviceTestsAsUser(LAUNCHER_TESTS_PKG,
                LAUNCHER_TESTS_CLASS, ""testLaunchNonExportActivityFails"",
                mCurrentUserId, Collections.singletonMap(PARAM_TEST_USER, mSerialNumber));
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/LauncherAppsSingleUserTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.devicepolicy.LauncherAppsSingleUserTest"	"testLaunchNonExportActivityFails"	"CtsDevicePolicyManagerTestCases"	"2: apps user"	"public void testLaunchNonExportActivityFails() throws Exception {
        if (!mHasLauncherApps) {
            return;
        }
        installAppAsUser(SIMPLE_APP_APK, mCurrentUserId);
        runDeviceTestsAsUser(LAUNCHER_TESTS_PKG,
                LAUNCHER_TESTS_CLASS, ""testLaunchNonExportLauncherFails"",
                mCurrentUserId, Collections.singletonMap(PARAM_TEST_USER, mSerialNumber));
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/LauncherAppsSingleUserTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.devicepolicy.LauncherAppsSingleUserTest"	"testLaunchMainActivity"	"CtsDevicePolicyManagerTestCases"	"2: apps user"	"public void testLaunchMainActivity() throws Exception {
        if (!mHasLauncherApps) {
            return;
        }
        installAppAsUser(SIMPLE_APP_APK, mCurrentUserId);
        runDeviceTestsAsUser(LAUNCHER_TESTS_PKG,
                LAUNCHER_TESTS_CLASS, ""testLaunchMainActivity"",
                mCurrentUserId, Collections.singletonMap(PARAM_TEST_USER, mSerialNumber));
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/LauncherAppsSingleUserTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.keystore.cts.performance.RsaCipherPerformanceTest"	"testRSA_ECB_OAEPPadding"	"CtsKeystoreTestCases"	"1: ui"	"public void testRSA_ECB_OAEPPadding() throws Exception {
        testRsaCipher(""RSA/ECB/OAEPPadding"", SUPPORTED_RSA_KEY_SIZES, TEST_MESSAGE_SIZES);
    }

    private void testRsaCipher(String algorithm, int[] keySizes, int[] messageSizes)
            throws Exception {
        for (int keySize : keySizes) {
            int maxMessageSize =
                    TestUtils.getMaxSupportedPlaintextInputSizeBytes(algorithm, keySize);
            for (int messageSize : messageSizes) {
                if (messageSize > maxMessageSize) {
                    continue;
                }
                measure(
                        new KeystoreRsaEncryptMeasurable(
                                new AndroidKeystoreRsaKeyGenerator(algorithm, keySize),
                                keySize,
                                messageSize),
                        new KeystoreRsaDecryptMeasurable(
                                new AndroidKeystoreRsaKeyGenerator(algorithm, keySize),
                                keySize,
                                messageSize),
                        new KeystoreRsaEncryptMeasurable(
                                new DefaultKeystoreKeyPairGenerator(algorithm, keySize),
                                keySize,
                                messageSize),
                        new KeystoreRsaDecryptMeasurable(
                                new DefaultKeystoreKeyPairGenerator(algorithm, keySize),
                                keySize,
                                messageSize));
            }
        }
    }

    private class AndroidKeystoreRsaKeyGenerator extends AndroidKeystoreKeyGenerator {

        AndroidKeystoreRsaKeyGenerator(String algorithm, int keySize) throws Exception {
            super(algorithm);
            String digest = TestUtils.getCipherDigest(algorithm);
            getKeyPairGenerator()
                    .initialize(
                            getKeyGenParameterSpecBuilder(
                                            KeyProperties.PURPOSE_ENCRYPT
                                                    | KeyProperties.PURPOSE_DECRYPT)
                                    .setBlockModes(TestUtils.getCipherBlockMode(algorithm))
                                    .setEncryptionPaddings(
                                            TestUtils.getCipherEncryptionPadding(algorithm))
                                    .setRandomizedEncryptionRequired(false)
                                    .setKeySize(keySize)
                                    .setDigests(
                                            (digest != null)
                                                    ? new String[] {digest}
                                                    : EmptyArray.STRING)
                                    .build());
        }
    }

    private class KeystoreRsaEncryptMeasurable extends KeystoreMeasurable {
        private final Cipher mCipher;
        private KeyPair mKey;

        KeystoreRsaEncryptMeasurable(
                KeystoreKeyGenerator keyGenerator, int keySize, int messageSize) throws Exception {
            super(keyGenerator, ""encrypt"", keySize, messageSize);
            mCipher = Cipher.getInstance(getAlgorithm());
        }

        @Override
        public void initialSetUp() throws Exception {
            mKey = generateKeyPair();
        }

        @Override
        public void setUp() throws Exception {
            mCipher.init(Cipher.ENCRYPT_MODE, mKey.getPublic());
        }

        @Override
        public void measure() throws Exception {
            mCipher.doFinal(getMessage());
        }
    }

    private class KeystoreRsaDecryptMeasurable extends KeystoreMeasurable {
        private final Cipher mCipher;
        private byte[] mEncryptedMessage;
        private AlgorithmParameters mAlgorithmParams;
        private KeyPair mKey;

        KeystoreRsaDecryptMeasurable(
                KeystoreKeyGenerator keyGenerator, int keySize, int messageSize) throws Exception {
            super(keyGenerator, ""decrypt"", keySize, messageSize);
            mCipher = Cipher.getInstance(getAlgorithm());
        }

        @Override
        public void initialSetUp() throws Exception {
            mKey = generateKeyPair();
            mCipher.init(Cipher.ENCRYPT_MODE, mKey.getPublic());
            mEncryptedMessage = mCipher.doFinal(getMessage());
            mAlgorithmParams = mCipher.getParameters();
        }

        @Override
        public void setUp() throws Exception {
            mCipher.init(Cipher.DECRYPT_MODE, mKey.getPrivate(), mAlgorithmParams);
        }

        @Override
        public void measure() throws Exception {
            mCipher.doFinal(mEncryptedMessage);
        }
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/performance/RsaCipherPerformanceTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telephony.euicc.cts.EuiccResolutionActivity"	"finish"	"CtsTelephonyTestCases"	"1: ui"	"public void test/*
 *.
 */

package android.telephony.euicc.cts;

import android.app.Activity;
import android.app.PendingIntent;
import android.telephony.euicc.EuiccManager;

/**
 * A mock activity which simulates a resolution activity. Returns {@link Activity#RESULT_OK} to
 * caller if 1) {@link Activity#onResume()} is called (as proof that the activity has been
 * successfully started), and 2) the callback intent is verified.
 */
public class EuiccResolutionActivity extends Activity {

    @Override
    protected void onResume() {
        super.onResume();

        // verify callback intent
        // TODO: verify callback intent's action matches
        // EuiccTestResolutionActivity.ACTION_START_RESOLUTION_ACTIVITY
        PendingIntent callbackIntent =
                getIntent()
                        .getParcelableExtra(
                                EuiccManager
                                        .EXTRA_EMBEDDED_SUBSCRIPTION_RESOLUTION_CALLBACK_INTENT);
        if (callbackIntent != null) {
            setResult(RESULT_OK);
        } else {
            setResult(RESULT_CANCELED);
        }

        // Resolution activity has successfully started, return result & finish
        finish();
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/euicc/cts/EuiccResolutionActivity.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.provider.cts.settings.SettingsTest"	"testNoStaleValueModifiedFromSameProcess"	"CtsProviderTestCases"	"2: mic system"	"public void testNoStaleValueModifiedFromSameProcess() throws Exception {
        final int initialValue = Settings.System.getInt(getContext().getContentResolver(),
                Settings.System.VIBRATE_WHEN_RINGING);
        try {
            for (int i = 0; i < 100; i++) {
                final int expectedValue = i % 2;
                Settings.System.putInt(getInstrumentation().getContext().getContentResolver(),
                        Settings.System.VIBRATE_WHEN_RINGING, expectedValue);
                final int actualValue = Settings.System.getInt(getContext().getContentResolver(),
                        Settings.System.VIBRATE_WHEN_RINGING);
                assertSame(""Settings write must be atomic"", expectedValue, actualValue);
            }
        } finally {
            Settings.System.putInt(getContext().getContentResolver(),
                    Settings.System.VIBRATE_WHEN_RINGING, initialValue);
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/settings/SettingsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.provider.cts.settings.SettingsTest"	"testNoStaleValueModifiedFromOtherProcess"	"CtsProviderTestCases"	"2: mic system"	"public void testNoStaleValueModifiedFromOtherProcess() throws Exception {
        final int initialValue = Settings.System.getInt(getContext().getContentResolver(),
                Settings.System.VIBRATE_WHEN_RINGING);
        try {
            for (int i = 0; i < 20; i++) {
                final int expectedValue = i % 2;
                SystemUtil.runShellCommand(getInstrumentation(), ""settings put system ""
                        +  Settings.System.VIBRATE_WHEN_RINGING + "" "" + expectedValue);
                final int actualValue = Settings.System.getInt(getContext().getContentResolver(),
                        Settings.System.VIBRATE_WHEN_RINGING);
                assertSame(""Settings write must be atomic"", expectedValue, actualValue);
            }
        } finally {
            Settings.System.putInt(getContext().getContentResolver(),
                    Settings.System.VIBRATE_WHEN_RINGING, initialValue);
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/settings/SettingsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.provider.cts.settings.SettingsTest"	"testNoStaleValueModifiedFromMultipleProcesses"	"CtsProviderTestCases"	"2: mic system"	"public void testNoStaleValueModifiedFromMultipleProcesses() throws Exception {
        final int initialValue = Settings.System.getInt(getContext().getContentResolver(),
                Settings.System.VIBRATE_WHEN_RINGING);
        try {
            for (int i = 0; i < 20; i++) {
                final int expectedValue = i % 2;
                final int unexpectedValue = (i + 1) % 2;
                Settings.System.putInt(getInstrumentation().getContext().getContentResolver(),
                        Settings.System.VIBRATE_WHEN_RINGING, expectedValue);
                SystemUtil.runShellCommand(getInstrumentation(), ""settings put system ""
                        +  Settings.System.VIBRATE_WHEN_RINGING + "" "" + unexpectedValue);
                Settings.System.putInt(getInstrumentation().getContext().getContentResolver(),
                        Settings.System.VIBRATE_WHEN_RINGING, expectedValue);
                final int actualValue = Settings.System.getInt(getContext().getContentResolver(),
                        Settings.System.VIBRATE_WHEN_RINGING);
                assertSame(""Settings write must be atomic"", expectedValue, actualValue);
            }
        } finally {
            Settings.System.putInt(getContext().getContentResolver(),
                    Settings.System.VIBRATE_WHEN_RINGING, initialValue);
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/settings/SettingsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.provider.cts.settings.SettingsTest"	"testAccessNonTable"	"CtsProviderTestCases"	"2: apps system"	"public void testAccessNonTable() {
        tryBadTableAccess(""SYSTEM"", ""system"", ""install_non_market_apps"");
        tryBadTableAccess(""SECURE"", ""secure"", ""install_non_market_apps"");
        tryBadTableAccess("" secure"", ""secure"", ""install_non_market_apps"");
        tryBadTableAccess(""secure "", ""secure"", ""install_non_market_apps"");
        tryBadTableAccess("" secure "", ""secure"", ""install_non_market_apps"");
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/settings/SettingsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.provider.cts.settings.SettingsTest"	"testSystemTable"	"CtsProviderTestCases"	"2: ui system"	"public void testSystemTable() throws RemoteException {
        final String[] SYSTEM_PROJECTION = new String[] {
                Settings.System._ID, Settings.System.NAME, Settings.System.VALUE
        };
        final int NAME_INDEX = 1;
        final int VALUE_INDEX = 2;

        String name = Settings.System.NEXT_ALARM_FORMATTED;
        String insertValue = ""value_insert"";
        String updateValue = ""value_update"";

        // get provider
        ContentResolver cr = getContext().getContentResolver();
        ContentProviderClient provider =
                cr.acquireContentProviderClient(Settings.System.CONTENT_URI);
        Cursor cursor = null;

        try {
            // Test: insert
            ContentValues value = new ContentValues();
            value.put(Settings.System.NAME, name);
            value.put(Settings.System.VALUE, insertValue);

            provider.insert(Settings.System.CONTENT_URI, value);
            cursor = provider.query(Settings.System.CONTENT_URI, SYSTEM_PROJECTION,
                    Settings.System.NAME + ""=\"""" + name + ""\"""", null, null, null);
            assertNotNull(cursor);
            assertEquals(1, cursor.getCount());
            assertTrue(cursor.moveToFirst());
            assertEquals(name, cursor.getString(NAME_INDEX));
            assertEquals(insertValue, cursor.getString(VALUE_INDEX));
            cursor.close();
            cursor = null;

            // Test: update
            value.clear();
            value.put(Settings.System.NAME, name);
            value.put(Settings.System.VALUE, updateValue);

            provider.update(Settings.System.CONTENT_URI, value,
                    Settings.System.NAME + ""=\"""" + name + ""\"""", null);
            cursor = provider.query(Settings.System.CONTENT_URI, SYSTEM_PROJECTION,
                    Settings.System.NAME + ""=\"""" + name + ""\"""", null, null, null);
            assertNotNull(cursor);
            assertEquals(1, cursor.getCount());
            assertTrue(cursor.moveToFirst());
            assertEquals(name, cursor.getString(NAME_INDEX));
            assertEquals(updateValue, cursor.getString(VALUE_INDEX));
            cursor.close();
            cursor = null;
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/settings/SettingsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.provider.cts.settings.SettingsTest"	"testSecureTable"	"CtsProviderTestCases"	"1: ui"	"public void testSecureTable() throws Exception {
        final String[] SECURE_PROJECTION = new String[] {
                Settings.Secure._ID, Settings.Secure.NAME, Settings.Secure.VALUE
        };

        ContentResolver cr = getContext().getContentResolver();
        ContentProviderClient provider =
                cr.acquireContentProviderClient(Settings.Secure.CONTENT_URI);
        assertNotNull(provider);

        // Test that the secure table can be read from.
        Cursor cursor = null;
        try {
            cursor = provider.query(Settings.Global.CONTENT_URI, SECURE_PROJECTION,
                    Settings.Global.NAME + ""=\"""" + Settings.Global.ADB_ENABLED + ""\"""",
                    null, null, null);
            assertNotNull(cursor);
        } finally {
            if (cursor != null) {
                cursor.close();
            }
        }
    }

    private static final String[] SELECT_VALUE =
        new String[] { Settings.NameValueTable.VALUE };
    private static final String NAME_EQ_PLACEHOLDER = ""name=?"";

    private void tryBadTableAccess(String table, String goodtable, String name) {
        ContentResolver cr = getContext().getContentResolver();

        Uri uri = Uri.parse(""content://settings/"" + table);
        ContentValues cv = new ContentValues();
        cv.put(""name"", ""name"");
        cv.put(""value"", ""xxxTESTxxx"");

        try {
            cr.insert(uri, cv);
            fail(""SettingsProvider didn't throw IllegalArgumentException for insert name ""
                    + name + "" at URI "" + uri);
        } catch (IllegalArgumentException e) {
            /* ignore */
        }

        try {
            cr.update(uri, cv, NAME_EQ_PLACEHOLDER, new String[]{name});
            fail(""SettingsProvider didn't throw SecurityException for update name ""
                    + name + "" at URI "" + uri);
        } catch (IllegalArgumentException e) {
            /* ignore */
        }

        try {
            cr.query(uri, SELECT_VALUE, NAME_EQ_PLACEHOLDER,
                    new String[]{name}, null);
            fail(""SettingsProvider didn't throw IllegalArgumentException for query name ""
                    + name + "" at URI "" + uri);
        } catch (IllegalArgumentException e) {
            /* ignore */
        }


        try {
            cr.delete(uri, NAME_EQ_PLACEHOLDER, new String[]{name});
            fail(""SettingsProvider didn't throw IllegalArgumentException for delete name ""
                    + name + "" at URI "" + uri);
        } catch (IllegalArgumentException e) {
            /* ignore */
        }


        String mimeType = cr.getType(uri);
        assertNull(""SettingsProvider didn't return null MIME type for getType at URI ""
                + uri, mimeType);

        uri = Uri.parse(""content://settings/"" + goodtable);
        try {
            Cursor c = cr.query(uri, SELECT_VALUE, NAME_EQ_PLACEHOLDER,
                    new String[]{name}, null);
            assertNotNull(c);
            String value = c.moveToNext() ? c.getString(0) : null;
            if (""xxxTESTxxx"".equals(value)) {
                fail(""Successfully modified "" + name + "" at URI "" + uri);
            }
            c.close();
        } catch (SQLiteException e) {
            // This is fine.
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/settings/SettingsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.provider.cts.settings.SettingsTest"	"testUriChangesUpdatingFromDifferentProcesses"	"CtsProviderTestCases"	"2: ui system"	"public void testUriChangesUpdatingFromDifferentProcesses() throws Exception {
        final int initialValue = Settings.System.getInt(getContext().getContentResolver(),
                Settings.System.VIBRATE_WHEN_RINGING);

        HandlerThread handlerThread = new HandlerThread(""MyThread"");
        handlerThread.start();

        CountDownLatch uriChangeCount = new CountDownLatch(4);
        Uri uri = Settings.System.getUriFor(Settings.System.VIBRATE_WHEN_RINGING);
        getContext().getContentResolver().registerContentObserver(uri,
                false, new ContentObserver(new Handler(handlerThread.getLooper())) {
                    @Override
                    public void onChange(boolean selfChange) {
                        uriChangeCount.countDown();
                    }
                });

        try {
            final int anotherValue = initialValue == 1 ? 0 : 1;
            Settings.System.putInt(getInstrumentation().getContext().getContentResolver(),
                    Settings.System.VIBRATE_WHEN_RINGING, anotherValue);
            SystemUtil.runShellCommand(getInstrumentation(), ""settings put system ""
                    +  Settings.System.VIBRATE_WHEN_RINGING + "" "" + initialValue);
            Settings.System.putInt(getInstrumentation().getContext().getContentResolver(),
                    Settings.System.VIBRATE_WHEN_RINGING, anotherValue);
            Settings.System.getInt(getContext().getContentResolver(),
                    Settings.System.VIBRATE_WHEN_RINGING);
            SystemUtil.runShellCommand(getInstrumentation(), ""settings put system ""
                    +  Settings.System.VIBRATE_WHEN_RINGING + "" "" + initialValue);

            uriChangeCount.await(30000, TimeUnit.MILLISECONDS);

            if (uriChangeCount.getCount() > 0) {
                fail(""Expected change not received for Uri: "" + uri);
            }
        } finally {
            Settings.System.putInt(getContext().getContentResolver(),
                    Settings.System.VIBRATE_WHEN_RINGING, initialValue);
            handlerThread.quit();
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/settings/SettingsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.provider.cts.settings.SettingsTest"	"testCheckWriteSettingsOperation"	"CtsProviderTestCases"	"1: ui"	"public void testCheckWriteSettingsOperation() throws Exception {
        final int myUid = Binder.getCallingUid();
        final String callingPackage = InstrumentationRegistry.getTargetContext().getPackageName();
        // Verify write settings permission.
        Settings.checkAndNoteWriteSettingsOperation(getContext(), myUid, callingPackage,
                true /* throwException */);

        // Verify SecurityException throw if uid do not match callingPackage.
        final int otherUid = myUid + 1;
        try {
            Settings.checkAndNoteWriteSettingsOperation(getContext(), otherUid, callingPackage,
                    true /* throwException */);
            fail(""Expect SecurityException because uid "" + otherUid + "" do not belong to ""
                    + callingPackage);
        } catch (SecurityException se) { }

        // Verify SecurityException throw if calling package do not have WRITE_SETTINGS permission.
        try {
            final String fakeCallingPackage = ""android.provider.cts.fakepackagename"";
            Settings.checkAndNoteWriteSettingsOperation(getContext(), myUid, fakeCallingPackage,
                    true /* throwException */);
            fail(""Expect throwing SecurityException due to no WRITE_SETTINGS permission"");
        } catch (SecurityException se) { }

    }

    private Instrumentation getInstrumentation() {
        return InstrumentationRegistry.getInstrumentation();
    }

    private Context getContext() {
        return InstrumentationRegistry.getTargetContext();
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/settings/SettingsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.provider.cts.settings.SettingsTest"	"testUserDictionarySettingsExists"	"CtsProviderTestCases"	"1: user"	"public void testUserDictionarySettingsExists() throws RemoteException {
        final Intent intent = new Intent(Settings.ACTION_USER_DICTIONARY_SETTINGS);
        final ResolveInfo ri = getContext().getPackageManager().resolveActivity(
                intent, PackageManager.MATCH_DEFAULT_ONLY);
        assertTrue(ri != null);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/settings/SettingsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.transition.cts.ChangeScrollTest"	"testChangeScroll"	"CtsTransitionTestCases"	"1: ui"	"public void testChangeScroll() throws Throwable {
        enterScene(R.layout.scene5);
        final CountDownLatch scrollChanged = new CountDownLatch(1);
        final View.OnScrollChangeListener listener = (v, newX, newY, oldX, oldY) -> {
            if (newX != 0 && newY != 0) {
                scrollChanged.countDown();
            }
        };
        mActivityRule.runOnUiThread(() -> {
            final View view = mActivity.findViewById(R.id.text);
            assertEquals(0, view.getScrollX());
            assertEquals(0, view.getScrollY());
            TransitionManager.beginDelayedTransition(mSceneRoot, mChangeScroll);
            view.scrollTo(150, 300);
            view.setOnScrollChangeListener(listener);
        });
        waitForStart();
        assertTrue(scrollChanged.await(1, TimeUnit.SECONDS));
        mActivityRule.runOnUiThread(() -> {
            final View view = mActivity.findViewById(R.id.text);
            final int scrollX = view.getScrollX();
            final int scrollY = view.getScrollY();
            assertTrue(scrollX > 0);
            assertTrue(scrollX < 150);
            assertTrue(scrollY > 0);
            assertTrue(scrollY < 300);
        });
        waitForEnd(800);
        mActivityRule.runOnUiThread(() -> {
            final View view = mActivity.findViewById(R.id.text);
            assertEquals(150, view.getScrollX());
            assertEquals(300, view.getScrollY());
        });
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/transition/src/android/transition/cts/ChangeScrollTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.opengl2.cts.primitive.GLPrimitiveActivity"	"finish"	"CtsOpenGlPerf2TestCases"	"2: ui system"	"public void test/*
 * Copyright (C) 2013 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package android.opengl2.cts.primitive;

import com.android.compatibility.common.util.WatchDog;

import android.app.Activity;
import android.content.Intent;
import android.opengl2.cts.GLActivityIntentKeys;
import android.os.Bundle;
import android.util.Log;
import android.view.Surface;
import android.view.SurfaceHolder;
import android.view.SurfaceView;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Semaphore;

public class GLPrimitiveActivity extends Activity {

    public final static String TAG = ""GLPrimitiveActivity"";

    private volatile Exception mException;
    private volatile Surface mSurface = null;
    private CountDownLatch mStartSignal = new CountDownLatch(1);
    private Semaphore mSemaphore = new Semaphore(0);

    private BenchmarkName mBenchmark;
    private boolean mOffscreen;
    private int mNumFrames;
    private int mNumIterations;
    private int mTimeout;
    public double[] mFpsValues;

    @Override
    public void onCreate(Bundle data) {
        super.onCreate(data);
        System.loadLibrary(""ctsopengl_jni"");
        Intent intent = getIntent();
        mBenchmark = BenchmarkName.valueOf(
                intent.getStringExtra(GLActivityIntentKeys.INTENT_EXTRA_BENCHMARK_NAME));
        mOffscreen = intent.getBooleanExtra(GLActivityIntentKeys.INTENT_EXTRA_OFFSCREEN, false);
        mNumFrames = intent.getIntExtra(GLActivityIntentKeys.INTENT_EXTRA_NUM_FRAMES, 0);
        mNumIterations = intent.getIntExtra(GLActivityIntentKeys.INTENT_EXTRA_NUM_ITERATIONS, 0);
        mTimeout = intent.getIntExtra(GLActivityIntentKeys.INTENT_EXTRA_TIMEOUT, 0);
        mFpsValues = new double[mNumIterations];

        Log.i(TAG, ""Benchmark: "" + mBenchmark);
        Log.i(TAG, ""Offscreen: "" + mOffscreen);
        Log.i(TAG, ""Num Frames: "" + mNumFrames);
        Log.i(TAG, ""Num Iterations: "" + mNumIterations);
        Log.i(TAG, ""Time Out: "" + mTimeout);

        SurfaceView surfaceView = new SurfaceView(this);
        surfaceView.getHolder().addCallback(new SurfaceHolder.Callback() {
            @Override
            public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
                mSurface = holder.getSurface();
                mStartSignal.countDown();
            }

            @Override
            public void surfaceCreated(SurfaceHolder holder) {}

            @Override
            public void surfaceDestroyed(SurfaceHolder holder) {}
        });
        setContentView(surfaceView);
        // Spawns a worker to run the benchmark.
        Worker worker = new Worker();
        worker.start();
    }

    public void waitForCompletion() throws Exception {
        // Wait for semiphore.
        mSemaphore.acquire();
        if (mException != null) {
            throw mException;
        }
    }

    private void complete() {
        // Release semiphore.
        mSemaphore.release();
        finish();
    }

    private synchronized void setException(Exception e) {
        if (mException == null) {
            mException = e;
        }
    }

    private static native boolean setupBenchmark(
            Surface surface, int benchmark, boolean offscreen);

    private static native boolean startBenchmark(int workload, int numFrames, double[] frameTimes);

    private static native void tearDownBenchmark();

    /**
     * This thread runs the benchmarks, freeing the UI thread.
     */
    private class Worker extends Thread implements WatchDog.TimeoutCallback {

        private WatchDog watchDog;
        private volatile boolean success = true;

        @Override
        public void run() {
            try {
                mStartSignal.await();
            } catch (InterruptedException e) {
                setException(e);
                complete();
                return;
            }
            Log.i(TAG, mBenchmark + "" Benchmark Started"");
            // Creates a watchdog to ensure a iteration doesn't exceed the timeout.
            watchDog = new WatchDog(mTimeout, this);
            // Used to record the start and end time of the iteration.
            double[] times = new double[2];
            try {
                // Setup the benchmark.
                setupBenchmark(mSurface, mBenchmark.ordinal(), mOffscreen);
                for (int i = 0; i < mNumIterations && success; i++) {
                    // The workload to use for this iteration.
                    int workload = i + 1;
                    watchDog.start();
                    // Start benchmark.
                    success = startBenchmark(workload, mNumFrames, times);
                    watchDog.stop();
                    if (!success) {
                        setException(new Exception(""Benchmark failed to run""));
                    } else {
                        // Calculate FPS.
                        mFpsValues[i] = mNumFrames * 1000.0f / (times[1] - times[0]);
                    }
                }
            }
            finally
            {
                tearDownBenchmark();
            }

            complete();
            Log.i(TAG, mBenchmark + "" Benchmark Completed"");
        }

        public void onTimeout() {
            setException(new Exception(""Benchmark timed out""));
            complete();
        }

    }
}"	"/home/gpoor/cts-12-source/cts/tests/openglperf2/src/android/opengl2/cts/primitive/GLPrimitiveActivity.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.verifier.tv.display.HotplugTestActivity"	"createTestItems"	""	"2: ui system"	"public void test/*
 *.
 */

package com.android.cts.verifier.tv.display;

import android.annotation.StringRes;
import android.content.Context;
import android.hardware.display.DisplayManager;
import android.view.Display;
import android.view.View;

import com.android.cts.verifier.R;
import com.android.cts.verifier.tv.TestSequence;
import com.android.cts.verifier.tv.TestStepBase;
import com.android.cts.verifier.tv.TvAppVerifierActivity;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

/**
 * Test when the HDMI cable on HDMI source devices (e.g. set-top boxes and TV sticks) is plugged out
 * and in {@link android.hardware.display.DisplayManager.DisplayListener#onDisplayChanged}. The
 * test also verifies that the display capabilities when the HDMI cable is unplugged contain only
 * one display mode and no HDR capabilities.
 */
public class HotplugTestActivity extends TvAppVerifierActivity {
    private static final float REFRESH_RATE_TOLERANCE = 0.01f;
    private TestSequence mTestSequence;

    @Override
    protected void setInfoResources() {
        setInfoResources(R.string.tv_hotplug_test, R.string.tv_hotplug_test_info, -1);
    }

    @Override
    protected void createTestItems() {
        List<TestStepBase> testSteps = new ArrayList<>();
        testSteps.add(new NoDisplayTestStep(this));
        mTestSequence = new TestSequence(this, testSteps);
        mTestSequence.init();
    }

    @Override
    public String getTestDetails() {
        return mTestSequence.getFailureDetails();
    }

    private static class DisplayCapabilities {
        public Display.Mode[] modes;
        public Display.HdrCapabilities hdrCapabilities;

        DisplayCapabilities(Display display) {
            this.modes = display.getSupportedModes();
            this.hdrCapabilities = display.getHdrCapabilities();
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof DisplayCapabilities)) return false;
            DisplayCapabilities that = (DisplayCapabilities) o;
            return modesAreEqual(modes, that.modes)
                    && Objects.equals(hdrCapabilities, that.hdrCapabilities);
        }

        private boolean modesAreEqual(Display.Mode[] left, Display.Mode[] right) {
            if (left.length != right.length) {
                return false;
            }

            for (int i = 0; i < left.length; i++) {
                if (!modesAreEqual(left[i], right[i])) {
                    return false;
                }
            }

            return  true;
        }

        private boolean modesAreEqual(Display.Mode left, Display.Mode right) {
            // Compare all properties except the ID.
            return left.getPhysicalHeight() == right.getPhysicalHeight()
                    && left.getPhysicalWidth() == right.getPhysicalWidth()
                    && Math.abs(left.getRefreshRate() - right.getRefreshRate())
                            < REFRESH_RATE_TOLERANCE
                    && Arrays.equals(
                            left.getAlternativeRefreshRates(), right.getAlternativeRefreshRates());
        }

        @Override
        public String toString() {
            String modesStr = Arrays.stream(modes)
                    .map(Display.Mode::toString)
                    .collect(Collectors.joining(""\n\t""));
            return ""DisplayCapabilities{""
                    + ""modes="" + modesStr
                    + "", hdrCapabilities="" + hdrCapabilities + '}';
        }
    }

    private static class NoDisplayTestStep extends AsyncTestStep implements
            DisplayManager.DisplayListener {
        // All recorded states of the display capabilities. The first element are the initial
        // display capabilities; each subsequent element is the state after a received
        // onDisplayChanged().
        private List<DisplayCapabilities> mRecordedCapabilities = new ArrayList<>();

        private int mNumOnDisplayChanged = 0;
        private boolean mDisconnectDetected = false;
        private boolean mConnectDetected = false;

        private View mDoneButtonView;
        private DisplayManager mDisplayManager;

        NoDisplayTestStep(TvAppVerifierActivity context) {
            super(
                    context,
                    R.string.tv_hotplug_test,
                    getInstructionText(context),
                    getButtonStringId());
        }

        private static String getInstructionText(Context context) {
            return context.getString(
                    R.string.tv_hotplug_disconnect_display,
                    context.getString(getButtonStringId()));
        }

        @StringRes
        private static int getButtonStringId() {
            return R.string.tv_start_test;
        }

        @Override
        public List<View> createUiElements() {
            List<View> list = super.createUiElements();
            mDoneButtonView = TvAppVerifierActivity.createButtonItem(
                    mContext.getLayoutInflater(),
                    null,
                    R.string.tv_done,
                    (View view) -> recordTestStateAndFinish());
            list.add(mDoneButtonView);
            return list;
        }

        @Override
        public void runTestAsync() {
            setButtonEnabled(mDoneButtonView, true);

            mDisplayManager = mContext.getSystemService(DisplayManager.class);
            Display display = mDisplayManager.getDisplay(Display.DEFAULT_DISPLAY);
            mRecordedCapabilities.add(new DisplayCapabilities(display));
            mDisplayManager.registerDisplayListener(this, null);
        }

        @Override
        public void onDisplayAdded(int displayId) {
            getAsserter().withMessage(""onDisplayAdded() is not expected"").fail();
        }

        @Override
        public void onDisplayRemoved(int displayId) {
            getAsserter().withMessage(""onDisplayRemoved() is not expected"").fail();
        }

        @Override
        public void onDisplayChanged(int displayId) {
            getAsserter().that(displayId).isEqualTo(Display.DEFAULT_DISPLAY);

            mNumOnDisplayChanged++;
            DisplayManager displayManager = mContext.getSystemService(DisplayManager.class);
            Display display = displayManager.getDisplay(Display.DEFAULT_DISPLAY);
            DisplayCapabilities currCapabilities = new DisplayCapabilities(display);
            mRecordedCapabilities.add(currCapabilities);

            // Some TVs may send multiple onDisplayChanged() events, for that reason we
            // test that in the sequence of states after each onDisplayChanged() there's
            // a state which looks like a disconnected display, followed by a state which looks
            // like the initial state.
            if (!mDisconnectDetected) {
                boolean isDisconnectedDisplay =
                        display.getHdrCapabilities().getSupportedHdrTypes().length == 0
                                && display.getSupportedModes().length == 1;

                if (isDisconnectedDisplay) {
                    mDisconnectDetected = true;
                }
            } else if (!mConnectDetected) {
                DisplayCapabilities initialCapabilities = mRecordedCapabilities.get(0);
                if (currCapabilities.equals(initialCapabilities)) {
                    mConnectDetected = true;
                    recordTestStateAndFinish();
                }
            }
        }

        private void recordTestStateAndFinish() {
            setButtonEnabled(mDoneButtonView, false);
            mDisplayManager.unregisterDisplayListener(this);
            if (!mConnectDetected || !mDisconnectDetected) {
                String recordedCapabilitiesStr = mRecordedCapabilities.stream()
                        .map(DisplayCapabilities::toString)
                        .collect(Collectors.joining(""\n""));
                String message = ""Number of onDisplayChanged() events = "" + mNumOnDisplayChanged
                        + ""\n"" + ""Disconnect detected = "" + mDisconnectDetected + ""\n""
                        + ""Recorded states = "" + recordedCapabilitiesStr;
                getAsserter().withMessage(message).fail();
            }
            done();
        }
    }
}"	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/tv/display/HotplugTestActivity.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.print.cts.PrinterDiscoverySessionLifecycleTest"	"onPrinterDiscoverySessionCreateCalled"	"CtsPrintTestCases"	"1: ui"	"public void addRemovePrinters() throws Throwable {
        StubbablePrinterDiscoverySession[] session = new StubbablePrinterDiscoverySession[1];

        // Create the session callbacks that we will be checking.
        final PrinterDiscoverySessionCallbacks firstSessionCallbacks =
                createMockPrinterDiscoverySessionCallbacks(invocation -> {
                    session[0] = ((PrinterDiscoverySessionCallbacks)
                            invocation.getMock()).getSession();

                    onPrinterDiscoverySessionCreateCalled();
                    return null;
                }, null, null, null, null, null, invocation -> {
                    onPrinterDiscoverySessionDestroyCalled();
                    return null;
                });

        // Create the service callbacks for the first print service.
        PrintServiceCallbacks firstServiceCallbacks = createMockPrintServiceCallbacks(
                invocation -> firstSessionCallbacks, null, null);

        // Configure the print services.
        FirstPrintService.setCallbacks(firstServiceCallbacks);
        SecondPrintService.setCallbacks(createSecondMockPrintServiceCallbacks());

        print(createDefaultPrintDocumentAdapter(1));

        waitForPrinterDiscoverySessionCreateCallbackCalled();

        runOnMainThread(() -> assertEquals(0, session[0].getPrinters().size()));

        PrinterId[] printerIds = new PrinterId[3];
        runOnMainThread(() -> {
            printerIds[0] = session[0].getService().generatePrinterId(""0"");
            printerIds[1] = session[0].getService().generatePrinterId(""1"");
            printerIds[2] = session[0].getService().generatePrinterId(""2"");
        });

        PrinterInfo printer1 = (new PrinterInfo.Builder(printerIds[0], ""0"",
                PrinterInfo.STATUS_IDLE)).build();

        PrinterInfo printer2 = (new PrinterInfo.Builder(printerIds[1], ""1"",
                PrinterInfo.STATUS_IDLE)).build();

        PrinterInfo printer3 = (new PrinterInfo.Builder(printerIds[2], ""2"",
                PrinterInfo.STATUS_IDLE)).build();

        ArrayList<PrinterInfo> printers = new ArrayList<>();
        printers.add(printer1);
        runOnMainThread(() -> session[0].addPrinters(printers));
        eventually(() -> runOnMainThread(() -> assertEquals(1, session[0].getPrinters().size())));

        printers.add(printer2);
        printers.add(printer3);
        runOnMainThread(() -> session[0].addPrinters(printers));
        eventually(() -> runOnMainThread(() -> assertEquals(3, session[0].getPrinters().size())));

        ArrayList<PrinterId> printerIdsToRemove = new ArrayList<>();
        printerIdsToRemove.add(printer1.getId());
        runOnMainThread(() -> session[0].removePrinters(printerIdsToRemove));
        eventually(() -> runOnMainThread(() -> assertEquals(2, session[0].getPrinters().size())));

        printerIdsToRemove.add(printer2.getId());
        printerIdsToRemove.add(printer3.getId());
        runOnMainThread(() -> session[0].removePrinters(printerIdsToRemove));
        eventually(() -> runOnMainThread(() -> assertEquals(0, session[0].getPrinters().size())));

        mPrintHelper.cancelPrinting();

        waitForPrinterDiscoverySessionDestroyCallbackCalled(1);
    }

    private PrinterId getAddedPrinterIdForLocalId(String printerLocalId) throws Throwable {
        final List<PrinterInfo> reportedPrinters = new ArrayList<>();
        runOnMainThread(() -> {
            // Grab the printer ids as only the service can create such.
            reportedPrinters.addAll(sSession.getPrinters());
        });

        final int reportedPrinterCount = reportedPrinters.size();
        for (int i = 0; i < reportedPrinterCount; i++) {
            PrinterInfo reportedPrinter = reportedPrinters.get(i);
            String localId = reportedPrinter.getId().getLocalId();
            if (printerLocalId.equals(localId)) {
                return reportedPrinter.getId();
            }
        }

        return null;
    }

    private PrintServiceCallbacks createSecondMockPrintServiceCallbacks() {
        return createMockPrintServiceCallbacks(null, null, null);
    }

    private PrinterDiscoverySessionCallbacks createFirstMockPrinterDiscoverySessionCallbacks(
            boolean shouldAddPrinters) {
        return createMockPrinterDiscoverySessionCallbacks(invocation -> {
            // Get the session.
            sSession = ((PrinterDiscoverySessionCallbacks)
                    invocation.getMock()).getSession();

            assertTrue(sSession.isPrinterDiscoveryStarted());

            if (shouldAddPrinters) {
                addPrinter(FIRST_PRINTER_LOCAL_ID, false);
                addPrinter(SECOND_PRINTER_LOCAL_ID, false);
            }

            return null;
        }, invocation -> {
            assertFalse(sSession.isPrinterDiscoveryStarted());
            return null;
        }, null, invocation -> {
            // Get the session.
            StubbablePrinterDiscoverySession session = ((PrinterDiscoverySessionCallbacks)
                    invocation.getMock()).getSession();

            PrinterId trackedPrinterId = (PrinterId) invocation.getArguments()[0];
            List<PrinterInfo> reportedPrinters = session.getPrinters();

            // We should be tracking a printer that we added.
            PrinterInfo trackedPrinter = null;
            final int reportedPrinterCount = reportedPrinters.size();
            for (int i = 0; i < reportedPrinterCount; i++) {
                PrinterInfo reportedPrinter = reportedPrinters.get(i);
                if (reportedPrinter.getId().equals(trackedPrinterId)) {
                    trackedPrinter = reportedPrinter;
                    break;
                }
            }
            assertNotNull(""Can track only added printers"", trackedPrinter);

            assertTrue(sSession.getTrackedPrinters().contains(trackedPrinter.getId()));
            assertEquals(1, sSession.getTrackedPrinters().size());

            // If the printer does not have capabilities reported add them.
            if (trackedPrinter.getCapabilities() == null) {

                // Add the capabilities to emulate lazy discovery.
                // Same for each printer is fine for what we test.
                PrinterCapabilitiesInfo capabilities =
                        new PrinterCapabilitiesInfo.Builder(trackedPrinterId)
                                .setMinMargins(new Margins(200, 200, 200, 200))
                                .addMediaSize(MediaSize.ISO_A4, true)
                                .addMediaSize(MediaSize.ISO_A5, false)
                                .addResolution(new Resolution(""300x300"", ""300x300"", 300, 300), true)
                                .setColorModes(PrintAttributes.COLOR_MODE_COLOR,
                                        PrintAttributes.COLOR_MODE_COLOR)
                                .build();
                PrinterInfo updatedPrinter = new PrinterInfo.Builder(trackedPrinter)
                        .setCapabilities(capabilities)
                        .build();

                // Update the printer.
                List<PrinterInfo> printers = new ArrayList<>();
                printers.add(updatedPrinter);
                session.addPrinters(printers);
            }

            return null;
        }, null, null, invocation -> {
            assertTrue(sSession.isDestroyed());

            // Take a note onDestroy was called.
            onPrinterDiscoverySessionDestroyCalled();
            return null;
        });
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/print/src/android/print/cts/PrinterDiscoverySessionLifecycleTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.print.cts.PrinterDiscoverySessionLifecycleTest"	"startPrinterDiscoveryWithHistoricalPrinters"	"CtsPrintTestCases"	"1: system"	"public void startPrinterDiscoveryWithHistoricalPrinters() throws Throwable {
        // Create the session callbacks that we will be checking.
        final PrinterDiscoverySessionCallbacks firstSessionCallbacks =
                createFirstMockPrinterDiscoverySessionCallbacks(false);

        // Create the service callbacks for the first print service.
        PrintServiceCallbacks firstServiceCallbacks = createMockPrintServiceCallbacks(
                invocation -> firstSessionCallbacks,
                invocation -> {
                    PrintJob printJob = (PrintJob) invocation.getArguments()[0];
                    // We pretend the job is handled immediately.
                    printJob.complete();
                    return null;
                }, null);

        // Configure the print services.
        FirstPrintService.setCallbacks(firstServiceCallbacks);
        SecondPrintService.setCallbacks(createSecondMockPrintServiceCallbacks());

        // Create a print adapter that respects the print contract.
        PrintDocumentAdapter adapter = createDefaultPrintDocumentAdapter(1);

        // Start printing.
        print(adapter);

        // Wait for write of the first page.
        waitForWriteAdapterCallback(1);

        runOnMainThread(() -> {
            addPrinter(FIRST_PRINTER_LOCAL_ID, false);
            addPrinter(SECOND_PRINTER_LOCAL_ID, false);
        });

        runOnMainThread(() -> assertFalse(sSession.isDestroyed()));
        runOnMainThread(() -> assertEquals(0, sSession.getTrackedPrinters().size()));

        // Select the first printer.
        selectPrinter(FIRST_PRINTER_LOCAL_ID);

        eventually(() -> runOnMainThread(() -> assertEquals(FIRST_PRINTER_LOCAL_ID,
                sSession.getTrackedPrinters().get(0).getLocalId())));
        runOnMainThread(() -> assertTrue(sSession.isPrinterDiscoveryStarted()));
        runOnMainThread(() -> assertEquals(1, sSession.getTrackedPrinters().size()));

        // Wait for a layout to finish - first layout was for the
        // PDF printer, second for the first printer in preview mode.
        waitForLayoutAdapterCallbackCount(2);

        // While the printer discovery session is still alive store the
        // ids of printer as we want to make some assertions about it
        // but only the print service can create printer ids which means
        // that we need to get the created one.
        PrinterId firstPrinterId = getAddedPrinterIdForLocalId(
                FIRST_PRINTER_LOCAL_ID);

        // Click the print button.
        mPrintHelper.submitPrintJob();

        eventually(() -> {
            // Answer the dialog for the print service cloud warning
            answerPrintServicesWarning(true);

            // Wait for the print to complete.
            waitForAdapterFinishCallbackCalled();
        }, OPERATION_TIMEOUT_MILLIS * 2);

        waitForPrinterDiscoverySessionDestroyCallbackCalled(1);

        // Set up print service to immediately report the printers
        final PrinterDiscoverySessionCallbacks firstSessionCallbacksWithPrinters =
                createFirstMockPrinterDiscoverySessionCallbacks(true);
        PrintServiceCallbacks firstServiceCallbacksWithPrinters = createMockPrintServiceCallbacks(
                invocation -> firstSessionCallbacksWithPrinters,
                invocation -> null, null);
        FirstPrintService.setCallbacks(firstServiceCallbacksWithPrinters);

        // Now print again as we want to confirm that the start
        // printer discovery passes in the priority list.
        print(adapter);

        // Wait for a layout to finish - first layout was for the
        // PDF printer, second for the first printer in preview mode,
        // the third for the first printer in non-preview mode, and
        // now a fourth for the PDF printer as we are printing again.
        waitForLayoutAdapterCallbackCount(4);

        // Cancel the printing.
        mPrintHelper.cancelPrinting();

        // Wait for all print jobs to be handled after which the is session destroyed.
        waitForPrinterDiscoverySessionDestroyCallbackCalled(2);

        runOnMainThread(() -> assertTrue(sSession.isDestroyed()));
        runOnMainThread(() -> assertFalse(sSession.isPrinterDiscoveryStarted()));
        runOnMainThread(() -> assertEquals(0, sSession.getTrackedPrinters().size()));

        // Verify the expected calls.
        InOrder inOrder = inOrder(firstSessionCallbacks, firstSessionCallbacksWithPrinters);

        // We start discovery with no printer history.
        List<PrinterId> priorityList = new ArrayList<>();
        inOrder.verify(firstSessionCallbacks).onStartPrinterDiscovery(
                priorityList);

        // We selected the first printer and now it should be tracked.
        inOrder.verify(firstSessionCallbacks).onStartPrinterStateTracking(
                firstPrinterId);

        // We confirmed print so the first should not be tracked.
        inOrder.verify(firstSessionCallbacks).onStopPrinterStateTracking(
                firstPrinterId);

        inOrder.verify(firstSessionCallbacks).onStopPrinterDiscovery();
        inOrder.verify(firstSessionCallbacks).onDestroy();

        priorityList.add(firstPrinterId);
        inOrder.verify(firstSessionCallbacksWithPrinters).onStartPrinterDiscovery(priorityList);

        // The system selects the highest ranked historical printer.
        inOrder.verify(firstSessionCallbacksWithPrinters).onStartPrinterStateTracking(
                firstPrinterId);

        // We canceled print so the first should not be tracked.
        inOrder.verify(firstSessionCallbacksWithPrinters).onStopPrinterStateTracking(
                firstPrinterId);


        // Discovery is always stopped before the session is always destroyed.
        inOrder.verify(firstSessionCallbacksWithPrinters).onStopPrinterDiscovery();

        // ...last the session is destroyed.
        inOrder.verify(firstSessionCallbacksWithPrinters).onDestroy();
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/print/src/android/print/cts/PrinterDiscoverySessionLifecycleTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.appwidget.cts.DarkTextThemeTest"	"grantBindAppWidgetPermission"	"CtsAppWidgetTestCases"	"1: ui"	"/*
 *.
 */
package android.appwidget.cts;

import static android.view.View.FIND_VIEWS_WITH_TEXT;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.doAnswer;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import android.appwidget.AppWidgetHost;
import android.appwidget.AppWidgetHostView;
import android.appwidget.AppWidgetManager;
import android.appwidget.AppWidgetProviderInfo;
import android.appwidget.cts.activity.EmptyActivity;
import android.appwidget.cts.service.MyAppWidgetService;
import android.content.Context;
import android.content.Intent;
import android.graphics.Color;
import android.graphics.drawable.ColorDrawable;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.platform.test.annotations.AppModeFull;
import android.util.ArrayMap;
import android.view.View;
import android.view.ViewTreeObserver.OnGlobalLayoutListener;
import android.widget.ListView;
import android.widget.RemoteViews;
import android.widget.RemoteViewsService;

import androidx.test.filters.LargeTest;
import androidx.test.rule.ActivityTestRule;
import androidx.test.runner.AndroidJUnit4;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.ArrayList;
import java.util.concurrent.CountDownLatch;
import java.util.function.Predicate;

/**
 * Test AppWidgets dark text theme
 */
@LargeTest
@AppModeFull
@RunWith(AndroidJUnit4.class)
public class DarkTextThemeTest extends AppWidgetTestCase {

    @Rule
    public ActivityTestRule<EmptyActivity> mActivityRule =
            new ActivityTestRule<>(EmptyActivity.class);

    private boolean mHasAppWidgets;

    private EmptyActivity mActivity;

    private AppWidgetHost mAppWidgetHost;

    private MyHostView mAppWidgetHostView;
    private int mAppWidgetId;

    @Before
    public void setup() throws Throwable {
        mHasAppWidgets = hasAppWidgets();
        if (!mHasAppWidgets) {
            return;
        }
        // We want to bind widgets - run a shell command to grant bind permission to our
        // package.
        grantBindAppWidgetPermission();

        mActivity = mActivityRule.getActivity();
        mActivityRule.runOnUiThread(this::bindNewWidget);
    }

    @After
    public void teardown() throws Exception {
        if (!mHasAppWidgets) {
            return;
        }
        mAppWidgetHost.deleteHost();
        revokeBindAppWidgetPermission();
    }

    private void bindNewWidget() {
        mAppWidgetHost = new AppWidgetHost(mActivity, 0) {
            @Override
            protected AppWidgetHostView onCreateView(Context context, int appWidgetId,
                    AppWidgetProviderInfo appWidget) {
                return new MyHostView(context);
            }
        };
        mAppWidgetHost.deleteHost();
        mAppWidgetHost.startListening();

        // Allocate a widget id to bind
        mAppWidgetId = mAppWidgetHost.allocateAppWidgetId();

        // Bind the app widget
        final AppWidgetProviderInfo providerInfo = getProviderInfo(getFirstWidgetComponent());
        boolean isBinding = getAppWidgetManager().bindAppWidgetIdIfAllowed(mAppWidgetId,
                providerInfo.getProfile(), providerInfo.provider, null);
        assertTrue(isBinding);

        // Create host view
        mAppWidgetHostView = (MyHostView) mAppWidgetHost
                .createView(mActivity, mAppWidgetId, providerInfo);
        mActivity.setContentView(mAppWidgetHostView);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/appwidget/src/android/appwidget/cts/DarkTextThemeTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.appwidget.cts.DarkTextThemeTest"	"testWidget_dark"	"CtsAppWidgetTestCases"	"1: ui"	"public void testWidget_dark() throws Throwable {
        if (!mHasAppWidgets) {
            return;
        }
        mActivity.runOnUiThread(() -> mAppWidgetHostView.setOnLightBackground(true));

        // Push update
        RemoteViews views = getViewsForResponse();
        getAppWidgetManager().updateAppWidget(new int[] {mAppWidgetId}, views);

        // Await until update
        CountDownLatch updateLatch = new CountDownLatch(1);
        mAppWidgetHostView.mCommands.put(
                (v) -> v.findViewById(R.id.hello) != null, updateLatch::countDown);
        updateLatch.await();

        // Perform click
        verifyColor(mAppWidgetHostView, Color.BLACK);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/appwidget/src/android/appwidget/cts/DarkTextThemeTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.appwidget.cts.DarkTextThemeTest"	"testCollection_dark"	"CtsAppWidgetTestCases"	"1: ui"	"public void testCollection_dark() throws Throwable {
        if (!mHasAppWidgets) {
            return;
        }
        mActivity.runOnUiThread(() -> mAppWidgetHostView.setOnLightBackground(true));

        setupAndAwaitCollectionWidget();

        // Perform click on various elements
        ListView listView = mAppWidgetHostView.findViewById(R.id.remoteViews_list);
        verifyColor(listView.getChildAt(0), Color.BLACK);
        verifyColor(listView.getChildAt(1), Color.BLACK);
        verifyColor(listView.getChildAt(2), Color.BLACK);
    }

    private void setupAndAwaitCollectionWidget() throws Throwable {
        // Configure the app widget service behavior
        RemoteViewsService.RemoteViewsFactory factory =
                mock(RemoteViewsService.RemoteViewsFactory.class);
        when(factory.getCount()).thenReturn(3);
        doAnswer(invocation -> {
            final int position = (Integer) invocation.getArguments()[0];
            RemoteViews remoteViews = getViewsForResponse();
            remoteViews.setTextViewText(R.id.hello, ""Text "" + position);
            return remoteViews;
        }).when(factory).getViewAt(any(int.class));
        when(factory.getViewTypeCount()).thenReturn(1);
        MyAppWidgetService.setFactory(factory);

        // Push update
        RemoteViews views = new RemoteViews(mActivity.getPackageName(),
                R.layout.remoteviews_adapter);
        Intent listIntent = new Intent(mActivity, MyAppWidgetService.class)
                .putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, mAppWidgetId);
        listIntent.setData(Uri.parse(listIntent.toUri(Intent.URI_INTENT_SCHEME)));
        views.setRemoteAdapter(R.id.remoteViews_list, listIntent);
        views.setViewVisibility(R.id.remoteViews_stack, View.GONE);
        views.setViewVisibility(R.id.remoteViews_list, View.VISIBLE);

        // Await until update
        getAppWidgetManager().updateAppWidget(new int[] {mAppWidgetId}, views);
        CountDownLatch updateLatch = new CountDownLatch(1);
        mActivityRule.runOnUiThread(() -> mAppWidgetHostView.getViewTreeObserver()
                .addOnGlobalLayoutListener(new OnGlobalLayoutListener() {
                    @Override
                    public void onGlobalLayout() {
                        mAppWidgetHostView.post(this::verifyChildrenAdded);
                    }

                    private void verifyChildrenAdded() {
                        ListView listView = mAppWidgetHostView.findViewById(R.id.remoteViews_list);
                        if (listView == null || listView.getChildCount() != 3) {
                            return;
                        }
                        if (hasText(""Text 0"", listView.getChildAt(0))
                                && hasText(""Text 1"", listView.getChildAt(1))
                                && hasText(""Text 2"", listView.getChildAt(2))) {
                            updateLatch.countDown();
                        }
                    }

                    private boolean hasText(String text, View parent) {
                        ArrayList<View> out = new ArrayList<>();
                        parent.findViewsWithText(out, text, FIND_VIEWS_WITH_TEXT);
                        return !out.isEmpty();
                    }
                }));
        updateLatch.await();
    }

    private RemoteViews getViewsForResponse() {
        RemoteViews views = new RemoteViews(mActivity.getPackageName(),
                R.layout.simple_white_layout);
        views.setLightBackgroundLayoutId(R.layout.simple_black_layout);
        return views;
    }

    private void verifyColor(View parent, int color) {
        Drawable bg = parent.findViewById(R.id.hello).getBackground();
        assertTrue(bg instanceof ColorDrawable);
        assertEquals(color, ((ColorDrawable) bg).getColor());
    }

    /**
     * Host view which supports waiting for a update to happen.
     */
    private static class MyHostView extends AppWidgetHostView {

        final ArrayMap<Predicate<MyHostView>, Runnable> mCommands = new ArrayMap<>();

        MyHostView(Context context) {
            super(context);
        }

        @Override
        public void updateAppWidget(RemoteViews remoteViews) {
            super.updateAppWidget(remoteViews);

            for (int i = mCommands.size() - 1; i >= 0; i--) {
                if (mCommands.keyAt(i).test(this)) {
                    Runnable action = mCommands.valueAt(i);
                    mCommands.removeAt(i);
                    action.run();
                }
            }
        }
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/appwidget/src/android/appwidget/cts/DarkTextThemeTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.net.wifi.cts.WifiFrameworkInitializerTest"	"registerServiceWrappers"	"CtsWifiTestCases"	"1: system"	"public void test/*
 *.
 */

package android.net.wifi.cts;

import android.net.wifi.WifiFrameworkInitializer;
import android.test.AndroidTestCase;

public class WifiFrameworkInitializerTest extends WifiJUnit3TestBase {
    /**
     * WifiFrameworkInitializer.registerServiceWrappers() should only be called by
     * SystemServiceRegistry during boot up when Wifi is first initialized. Calling this API at
     * any other time should throw an exception.
     */"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiFrameworkInitializerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.net.wifi.cts.WifiFrameworkInitializerTest"	"testRegisterServiceWrappers_failsWhenCalledOutsideOfSystemServiceRegistry"	"CtsWifiTestCases"	"1: system"	"public void testRegisterServiceWrappers_failsWhenCalledOutsideOfSystemServiceRegistry() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        try {
            WifiFrameworkInitializer.registerServiceWrappers();
            fail(""Expected exception when calling ""
                    + ""WifiFrameworkInitializer.registerServiceWrappers() outside of ""
                    + ""SystemServiceRegistry!"");
        } catch (IllegalStateException expected) {}
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiFrameworkInitializerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.deviceowner.proxy.PacProxyTest"	"testFileLoaded"	""	"1: direct"	"public void testFileLoaded() throws Exception {
    mPacServer.setPacFile(DIRECT_PAC);
    setPacURLAndWaitForDownload();
  }

  /**
   * Make sure when we set the PAC file URL we get a broadcast
   * containing the proxy info.
   */"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/proxy/PacProxyTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.deviceowner.proxy.PacProxyTest"	"testBroadcast"	""	"1: direct"	"public void testBroadcast() throws Exception {
    mPacServer.setPacFile(DIRECT_PAC);
    setPacURLAndWaitForDownload();

    assertNotNull(""Broadcast must contain proxy"", mProxy);
    assertEquals(""Proxy must contain PAC URL"", mPacServer.getPacURL(),
        mProxy.getPacFileUrl().toString());
  }

  /**
   * Make sure that we also get a broadcast after we clear the
   * PAC proxy settings.
   */"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/proxy/PacProxyTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.deviceowner.proxy.PacProxyTest"	"testProxyPassthrough"	""	"1: direct"	"public void testProxyPassthrough() throws Exception {
    mPacServer.setPacFile(DIRECT_PAC);
    setPacURLAndWaitForDownload();

    waitForSetProxySysProp();

    PassthroughTestHelper ptt = new PassthroughTestHelper(mProxy);
    ptt.runTest();
  }

  /**
   * Verify that for a simple PAC that returns direct the
   * result is direct.
   */"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/proxy/PacProxyTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.deviceowner.proxy.PacProxyTest"	"testDirect"	""	"1: direct"	"public void testDirect() throws Exception {
    testBroadcast();

    waitForSetProxySysProp();
    URI uri = new URI(""http://localhost/test/my/url"");

    ProxySelector selector = ProxySelector.getDefault();
    List<Proxy> list = selector.select(uri);
    assertEquals(""Proxy must be direct"", newArrayList(Proxy.NO_PROXY), list);
  }

  /**
   * Test a PAC file that returns a list of proxies, including one direct.
   */"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/proxy/PacProxyTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.deviceowner.proxy.PacProxyTest"	"testLocalPlusDirect"	""	"1: direct"	"public void testLocalPlusDirect() throws Exception {
    mPacServer.setPacFile(LOCAL_PLUS_DIRECT_PAC);
    setPacURLAndWaitForDownload();

    waitForSetProxySysProp();

    URI uri = new URI(""http://localhost/test/my/url"");

    ProxySelector selector = ProxySelector.getDefault();
    List<Proxy> list = selector.select(uri);
    assertEquals(""Must return multiple proxies"", newArrayList(
        new Proxy(Type.HTTP, InetSocketAddress.createUnresolved(""localhost"", 8080)),
        new Proxy(Type.HTTP, InetSocketAddress.createUnresolved(""localhost"", 8081)),
        Proxy.NO_PROXY), list);
  }

  /**
   * Tests a PAC file that returns different proxies depending on
   * the host that is being accessed.
   */"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/proxy/PacProxyTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.deviceowner.proxy.PacProxyTest"	"testUrlPassthrough"	""	"1: direct"	"public void testUrlPassthrough() throws Exception {
    mPacServer.setPacFile(URL_PAC);
    setPacURLAndWaitForDownload();

    waitForSetProxySysProp();

    URI uri = new URI(""http://localhost/my/url/"");

    ProxySelector selector = ProxySelector.getDefault();
    List<Proxy> list = selector.select(uri);
    assertEquals(""Correct URL returns proxy"", newArrayList(
        new Proxy(Type.HTTP, InetSocketAddress.createUnresolved(""localhost"", 8080))),
        list);

    uri = new URI(""http://localhost/not/my/url/"");
    list = selector.select(uri);
    assertEquals(""Incorrect URL should return DIRECT"",
        newArrayList(Proxy.NO_PROXY), list);
  }

  /**
   * Test a PAC file with toUpperCase/toLowerCase manipulations.
   */"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/proxy/PacProxyTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.deviceowner.proxy.PacProxyTest"	"testClearBroadcast"	""	"1: apps"	"public void testClearBroadcast() throws Exception {
    testBroadcast();
    assertTrue(""No broadcast after clearing proxy."", clearProxyAndWaitForBroadcast());
    assertTrue(isProxyEmpty());
  }

  /**
   * Verify that the locally-hosted android backup proxy is up and
   * running.
   * Android hosts a proxy server that provides legacy support for apps that
   * don't use the apache HTTP stack, but still read the static proxy
   * settings.  The static settings point to a server that will handle
   * the PAC parsing for them.
   */"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/proxy/PacProxyTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.ResourceCursorTreeAdapterTest"	"testConstructor"	"CtsWidgetTestCases"	"1: ui"	"public void testConstructor() {
        mResourceCursorTreeAdapter = new MockResourceCursorTreeAdapter(mContext, null,
                mGroupLayout, mChildLayout);
        assertNull(mResourceCursorTreeAdapter.getCursor());

        Cursor cursor = createTestCursor(3, 3);
        mResourceCursorTreeAdapter = new MockResourceCursorTreeAdapter(mContext, cursor,
                mGroupLayout, mChildLayout);
        assertEquals(cursor, mResourceCursorTreeAdapter.getCursor());

        new MockResourceCursorTreeAdapter(mContext, null, mCollapsedGroupLayout,
                mExpandedGroupLayout, mChildLayout);

        new MockResourceCursorTreeAdapter(mContext, null, mCollapsedGroupLayout,
                mExpandedGroupLayout, mNormalChildLayout, mLastChildLayout);

        new MockResourceCursorTreeAdapter(mContext, null, -1, -1);

        new MockResourceCursorTreeAdapter(mContext, null, -1, -1, -1);

        new MockResourceCursorTreeAdapter(mContext, null, -1, -1, -1, -1);
    }

    // The parameters Context and Cursor are never read in the method
    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/ResourceCursorTreeAdapterTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.ResourceCursorTreeAdapterTest"	"testNewChildView"	"CtsWidgetTestCases"	"1: ui"	"public void testNewChildView() {
        mResourceCursorTreeAdapter = new MockResourceCursorTreeAdapter(mContext, null,
                mGroupLayout, mChildLayout);

        View result = mResourceCursorTreeAdapter.newChildView(null, null, true, mParent);
        assertEquals(mChildId, result.getId());

        result = mResourceCursorTreeAdapter.newChildView(null, null, false, mParent);
        assertEquals(mChildId, result.getId());

        mResourceCursorTreeAdapter = new MockResourceCursorTreeAdapter(mContext, null,
                mGroupLayout, mGroupLayout, mNormalChildLayout, mLastChildLayout);

        result = mResourceCursorTreeAdapter.newChildView(null, null, true, mParent);
        assertEquals(mLastChildId, result.getId());

        result = mResourceCursorTreeAdapter.newChildView(null, null, false, mParent);
        assertEquals(mNormalChildId, result.getId());
    }

    // The parameters Context and Cursor are never read in the method
    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/ResourceCursorTreeAdapterTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.compatibility.common.util.BusinessLogicTestCase"	"TestName"	""	"1: direct"	"public void test/*
 *.
 */
package com.android.compatibility.common.util;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import android.app.Instrumentation;
import android.content.ContentResolver;
import android.content.Context;
import android.net.Uri;
import android.os.ParcelFileDescriptor;
import android.util.Log;

import androidx.test.InstrumentationRegistry;

import org.junit.Before;
import org.junit.Rule;
import org.junit.rules.TestName;

import java.io.File;
import java.io.FileNotFoundException;
import java.lang.reflect.Field;
import java.util.Map;

/**
 * Device-side base class for tests leveraging the Business Logic service.
 */
public class BusinessLogicTestCase {
    private static final String TAG = ""BusinessLogicTestCase"";

    /* String marking the beginning of the parameter in a test name */
    private static final String PARAM_START = ""["";

    public static final String CONTENT_PROVIDER =
            String.format(""%s://android.tradefed.contentprovider"", ContentResolver.SCHEME_CONTENT);

    /* Test name rule that tracks the current test method under execution */
    @Rule public TestName mTestCase = new TestName();

    protected BusinessLogic mBusinessLogic;
    protected boolean mCanReadBusinessLogic = true;

    @Before
    public void handleBusinessLogic() {
        loadBusinessLogic();
        executeBusinessLogic();
    }

    protected void executeBusinessLogic() {
        executeBusinessLogicForTest(mTestCase.getMethodName());
    }

    protected void executeBusinessLogicForTest(String methodName) {
        assertTrue(String.format(""Test \""%s\"" is unable to execute as it depends on the missing ""
                + ""remote configuration."", methodName), mCanReadBusinessLogic);
        if (methodName.contains(PARAM_START)) {
            // Strip parameter suffix (e.g. ""[0]"") from method name
            methodName = methodName.substring(0, methodName.lastIndexOf(PARAM_START));
        }
        String testName = String.format(""%s#%s"", this.getClass().getName(), methodName);
        if (mBusinessLogic.hasLogicFor(testName)) {
            Log.i(TAG, ""Finding business logic for test case: "" + testName);
            BusinessLogicExecutor executor = new BusinessLogicDeviceExecutor(getContext(), this, mBusinessLogic.getRedactionRegexes());
            mBusinessLogic.applyLogicFor(testName, executor);
        } else {
            /* There are cases in which this is an acceptable outcome, and we do not want to fail.
             * For instance, some business logic rule lists are only sent from the server
             * for certain devices (see go/aes-gts).  Devices exempt from those rules will
             * receive no BL config for some tests, and this should result in a pass.
             */
            Log.d(TAG, ""No business logic found for test: "" + testName);
        }
    }

    protected void loadBusinessLogic() {
        String uriPath = String.format(""%s/%s"", CONTENT_PROVIDER, BusinessLogic.DEVICE_FILE);
        Uri sdcardUri = Uri.parse(uriPath);
        Context appContext = InstrumentationRegistry.getTargetContext();
        try {
            ContentResolver resolver = appContext.getContentResolver();
            ParcelFileDescriptor descriptor = resolver.openFileDescriptor(sdcardUri, ""r"");
            mBusinessLogic = BusinessLogicFactory.createFromFile(
                    new ParcelFileDescriptor.AutoCloseInputStream(descriptor));
            return;
        } catch (FileNotFoundException e) {
            // Log the error and use the fallback too
            Log.e(TAG, ""Error while using content provider for config"", e);
        }
        // Fallback to reading the business logic directly.
        File businessLogicFile = new File(BusinessLogic.DEVICE_FILE);
        if (businessLogicFile.canRead()) {
            mBusinessLogic = BusinessLogicFactory.createFromFile(businessLogicFile);
        } else {
            mCanReadBusinessLogic = false;
        }
    }

    protected static Instrumentation getInstrumentation() {
        return InstrumentationRegistry.getInstrumentation();
    }

    protected static Context getContext() {
        return getInstrumentation().getTargetContext();
    }

    public static void skipTest(String message) {
        assumeTrue(message, false);
    }

    public static void failTest(String message) {
        fail(message);
    }

    public void mapPut(String mapName, String key, String value) {
        boolean put = false;
        for (Field f : getClass().getDeclaredFields()) {
            if (f.getName().equalsIgnoreCase(mapName) && Map.class.isAssignableFrom(f.getType())) {
                try {
                    ((Map) f.get(this)).put(key, value);
                    put = true;
                } catch (IllegalAccessException e) {
                    Log.w(String.format(""failed to invoke mapPut on field \""%s\"". Resuming..."",
                            f.getName()), e);
                    // continue iterating through fields, throw exception if no other fields match
                }
            }
        }
        if (!put) {
            throw new RuntimeException(String.format(""Failed to find map %s in class %s"", mapName,
                    getClass().getName()));
        }
    }
}"	"/home/gpoor/cts-12-source/cts/common/device-side/util-axt/src/com/android/compatibility/common/util/BusinessLogicTestCase.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.server.wm.StartActivityAsUserTests"	"computeState"	"CtsWindowManagerDeviceTestCases"	"1: user"	"public void startActivityInvalidUser() {
        UserHandle secondUserHandle = UserHandle.of(mSecondUserId * 100);
        int[] stackId = {-1};

        final Intent intent = new Intent(mContext, StartActivityAsUserActivity.class);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        runWithShellPermissionIdentity(() -> {
            mContext.startActivityAsUser(intent, secondUserHandle);
            WindowManagerState amState = mAmWmState;
            amState.computeState();
            ComponentName componentName = ComponentName.createRelative(PACKAGE, CLASS);
            stackId[0] = amState.getRootTaskIdByActivity(componentName);
        });

        assertThat(stackId[0]).isEqualTo(INVALID_STACK);
    }
}"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/StartActivityAsUserTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.managedprofile.ResetPasswordWithTokenTest"	"testClearPasswordBeforeUnlock"	""	"3: ui system user"	"public void testClearPasswordBeforeUnlock() {
        UserManager um = mContext.getSystemService(UserManager.class);
        assertFalse(um.isUserUnlocked());
        assertTrue(mDevicePolicyManager.isResetPasswordTokenActive(ADMIN_RECEIVER_COMPONENT));
        assertTrue(mDevicePolicyManager.resetPasswordWithToken(ADMIN_RECEIVER_COMPONENT, null,
                token, 0));

        // When password is cleared, the system should automatically unlock the user.
        final BlockingBroadcastReceiver receiver = new BlockingBroadcastReceiver(mContext,
                Intent.ACTION_USER_UNLOCKED);
        receiver.register();
        try {
            // Give the broadcast long enough time, as unlocking user could be slow.
            assertNotNull(receiver.awaitForBroadcast(90_000));
        } finally {
            receiver.unregisterQuietly();
        }
        assertTrue(um.isUserUnlocked());
        assertTrue(mDevicePolicyManager.isActivePasswordSufficient());
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/ResetPasswordWithTokenTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.managedprofile.ResetPasswordWithTokenTest"	"testResetPasswordBeforeUnlock"	""	"2: system user"	"public void testResetPasswordBeforeUnlock() {
        UserManager um = mContext.getSystemService(UserManager.class);
        assertFalse(um.isUserUnlocked());
        assertTrue(mDevicePolicyManager.isResetPasswordTokenActive(ADMIN_RECEIVER_COMPONENT));
        assertTrue(mDevicePolicyManager.resetPasswordWithToken(ADMIN_RECEIVER_COMPONENT, PASSWORD1,
                token, 0));

        mDevicePolicyManager.setPasswordQuality(ADMIN_RECEIVER_COMPONENT,
                DevicePolicyManager.PASSWORD_QUALITY_NUMERIC);
        mDevicePolicyManager.setPasswordMinimumLength(ADMIN_RECEIVER_COMPONENT, 6);
        try {
            mDevicePolicyManager.isActivePasswordSufficient();
            fail(""Did not throw expected exception."");
        } catch (IllegalStateException expected) {}
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/ResetPasswordWithTokenTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.storageapp.StorageTest"	"testVerifySpaceApi"	""	"4: direct ui system user"	"public void testVerifySpaceApi() throws Exception {
        final StorageManager sm = getContext().getSystemService(StorageManager.class);
        final StorageStatsManager stats = getContext().getSystemService(StorageStatsManager.class);

        final long cacheSize = sm.getCacheSizeBytes(
                sm.getUuidForPath(getContext().getCacheDir()));
        final long extCacheSize = sm.getCacheSizeBytes(
                sm.getUuidForPath(getContext().getExternalCacheDir()));
        if (cacheSize == extCacheSize) {
            assertMostlyEquals(CACHE_ALL, cacheSize);
        } else {
            assertMostlyEquals(CACHE_INT, cacheSize);
            assertMostlyEquals(CACHE_EXT, extCacheSize);
        }

        // Verify APIs that don't require any special permissions
        assertTrue(stats.getTotalBytes(StorageManager.UUID_DEFAULT) >= Environment
                .getDataDirectory().getTotalSpace());
        assertTrue(stats.getFreeBytes(StorageManager.UUID_DEFAULT) >= Environment
                .getDataDirectory().getUsableSpace());

        // Verify that we can see our own stats, and that they look sane
        ApplicationInfo ai = getContext().getApplicationInfo();
        final StorageStats pstats = stats.queryStatsForPackage(ai.storageUuid, ai.packageName,
                UserHandle.getUserHandleForUid(ai.uid));
        final StorageStats ustats = stats.queryStatsForUid(ai.storageUuid, ai.uid);
        assertEquals(cacheSize, pstats.getCacheBytes());
        assertEquals(cacheSize, ustats.getCacheBytes());

        // Verify that other packages are off-limits
        ai = getContext().getPackageManager().getApplicationInfo(PKG_B, 0);
        try {
            stats.queryStatsForPackage(ai.storageUuid, ai.packageName,
                    UserHandle.getUserHandleForUid(ai.uid));
            fail(""Unexpected access"");
        } catch (SecurityException expected) {
        }
        try {
            stats.queryStatsForUid(ai.storageUuid, ai.uid);
            fail(""Unexpected access"");
        } catch (SecurityException expected) {
        }
        try {
            stats.queryExternalStatsForUser(StorageManager.UUID_DEFAULT,
                    android.os.Process.myUserHandle());
            fail(""Unexpected access"");
        } catch (SecurityException expected) {
        }
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/StorageApp/src/com/android/cts/storageapp/StorageTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.storageapp.StorageTest"	"testVerifyAllocateApi"	""	"4: direct apps ui system"	"public void testVerifyAllocateApi() throws Exception {
        final StorageManager sm = getContext().getSystemService(StorageManager.class);

        final File filesDir = getContext().getFilesDir();
        final File extDir = Environment.getExternalStorageDirectory();

        final UUID filesUuid = sm.getUuidForPath(filesDir);
        final UUID extUuid = sm.getUuidForPath(extDir);

        assertTrue(""Apps must be able to allocate internal space"",
                sm.getAllocatableBytes(filesUuid) > 10 * MB_IN_BYTES);
        assertTrue(""Apps must be able to allocate external space"",
                sm.getAllocatableBytes(extUuid) > 10 * MB_IN_BYTES);

        // Should always be able to allocate 1MB indirectly
        sm.allocateBytes(filesUuid, 1 * MB_IN_BYTES);

        // Should always be able to allocate 1MB directly
        final File filesFile = makeUniqueFile(filesDir);
        assertEquals(0L, filesFile.length());
        try (ParcelFileDescriptor pfd = ParcelFileDescriptor.open(filesFile,
                ParcelFileDescriptor.parseMode(""rwt""))) {
            sm.allocateBytes(pfd.getFileDescriptor(), 1 * MB_IN_BYTES);
        }
        assertEquals(1 * MB_IN_BYTES, filesFile.length());
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/StorageApp/src/com/android/cts/storageapp/StorageTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.storageapp.StorageTest"	"testExternalStorageIsolatedWrite"	""	"2: direct system"	"public void testExternalStorageIsolatedWrite() throws Exception {
        final Context context = getContext();
        final List<File> paths = new ArrayList<File>();
        Collections.addAll(paths, Environment.getExternalStorageDirectory());
        Collections.addAll(paths,
                Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES));
        Collections.addAll(paths, context.getExternalCacheDirs());
        Collections.addAll(paths, context.getExternalFilesDirs(null));
        Collections.addAll(paths, context.getExternalFilesDirs(Environment.DIRECTORY_PICTURES));
        Collections.addAll(paths, context.getExternalMediaDirs());
        Collections.addAll(paths, context.getObbDirs());

        final String name = ""cts_"" + System.nanoTime();
        for (File path : paths) {
            final File otherPath = new File(path.getAbsolutePath()
                    .replace(""com.android.cts.storageapp_a"", ""com.android.cts.storageapp_b""));

            path.mkdirs();
            otherPath.mkdirs();

            final File file = new File(path, name);
            final File otherFile = new File(otherPath, name);

            file.createNewFile();
            otherFile.createNewFile();

            assertTrue(file.exists());
            assertTrue(otherFile.exists());
        }
    }

    /**
     * Verify that we can't see any of the ""cts"" probe files created above,
     * since our storage should be fully isolated.
     */"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/StorageApp/src/com/android/cts/storageapp/StorageTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.storageapp.StorageTest"	"testExternalStorageIsolatedRead"	""	"1: direct"	"public void testExternalStorageIsolatedRead() throws Exception {
        final LinkedList<File> traverse = new LinkedList<>();
        traverse.push(Environment.getStorageDirectory());
        traverse.push(Environment.getExternalStorageDirectory());

        while (!traverse.isEmpty()) {
            final File dir = traverse.poll();
            for (File f : dir.listFiles()) {
                if (f.getName().startsWith(""cts_"")) {
                    fail(""Found leaked file "" + f.getAbsolutePath());
                }
                if (f.isDirectory()) {
                    traverse.push(f);
                }
            }
        }
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/StorageApp/src/com/android/cts/storageapp/StorageTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.storageapp.StorageTest"	"testVerifyQuotaApi"	""	"3: apps ui system"	"public void testVerifyQuotaApi() throws Exception {
        final StorageManager sm = getContext().getSystemService(StorageManager.class);

        final long cacheSize = sm.getCacheQuotaBytes(
                sm.getUuidForPath(getContext().getCacheDir()));
        assertTrue(""Apps must have at least 10MB quota"", cacheSize > 10 * MB_IN_BYTES);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/StorageApp/src/com/android/cts/storageapp/StorageTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.storageapp.StorageTest"	"testFullDisk"	""	"2: ui system"	"public void testFullDisk() throws Exception {
        final StorageStatsManager stats = getContext()
                .getSystemService(StorageStatsManager.class);
        if (stats.isReservedSupported(UUID_DEFAULT)) {
            final File dataDir = getContext().getDataDir();
            Hoarder.doBlocks(dataDir, true);
        } else {
            fail(""Skipping full disk test due to missing quota support"");
        }
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/StorageApp/src/com/android/cts/storageapp/StorageTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.storageapp.StorageTest"	"testClearSpace"	""	"1: ui"	"public void testClearSpace() throws Exception {
        // First, disk better be full!
        assertTrue(getContext().getDataDir().getUsableSpace() < 256_000_000);

        final Activity activity = launchActivity(""com.android.cts.storageapp_a"",
                UtilsActivity.class, null);

        final Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
        intent.setData(Uri.fromParts(""package"", ""com.android.cts.storageapp_b"", null));
        activity.startActivity(intent);

        final UiDevice device = UiDevice.getInstance(getInstrumentation());
        device.waitForIdle();

        if (isWatch()) {
            clearSpaceWatch(device);
        } else if (isTV()) {
            clearSpaceTv(device);
        } else if (isCar()) {
            clearSpaceCar(device);
        } else {
            clearSpaceGeneric(device);
        }
        device.waitForIdle();

        // Now, disk better be less-full!
        assertTrue(getContext().getDataDir().getUsableSpace() > 256_000_000);
    }

    private void clearSpaceGeneric(UiDevice device) throws UiObjectNotFoundException {
        int i = device.findObjects(android.support.test.uiautomator.By.scrollable(true)).size();
        for (int j = 0; j < i; j++) {
            UiScrollable localObject = new UiScrollable(new UiSelector().scrollable(true).instance(j));
            ((UiScrollable) localObject).setMaxSearchSwipes(10);
            try {
                 ((UiScrollable) localObject).scrollTextIntoView(""internal storage"");
            } catch (UiObjectNotFoundException localUiObjectNotFoundException) {
                // Scrolling can fail if the UI is not scrollable
            }
        }
        device.findObject(new UiSelector().textContains(""internal storage"")).click();
        device.waitForIdle();

        device.findObject(new UiSelector().textContains(""Clear"")).click();
        device.waitForIdle();

        device.findObject(new UiSelector().text(""OK"")).click();
    }

    private void clearSpaceWatch(UiDevice device) throws UiObjectNotFoundException {
        UiScrollable uiScrollable = new UiScrollable(new UiSelector().scrollable(true));
        uiScrollable.scrollTextIntoView(""App info"");

        device.findObject(new UiSelector().textContains(""App info"")).click();
        device.waitForIdle();

        uiScrollable.scrollTextIntoView(""Clear data"");
        device.waitForIdle();

        device.findObject(new UiSelector().textContains(""Clear data"")).click();
        device.waitForIdle();

        UiSelector yesButton = new UiSelector().description(""Yes"");
        uiScrollable.scrollIntoView(yesButton);
        device.waitForIdle();

        device.findObject(yesButton).click();
    }

    private void clearSpaceTv(UiDevice device) throws UiObjectNotFoundException {
        device.findObject(new UiSelector().textContains(""Clear"")).click();
        device.waitForIdle();
        device.findObject(new UiSelector().text(""OK"")).click();
    }

    private void clearSpaceCar(UiDevice device) throws UiObjectNotFoundException {
        UiScrollable uiScrollable = new UiScrollable(new UiSelector().scrollable(true));
        String storageString = ""internal storage"";
        try {
            uiScrollable.scrollTextIntoView(storageString);
        } catch (UiObjectNotFoundException e) {
            // Scrolling can fail if the UI is not scrollable
        }
        device.findObject(new UiSelector().textContains(storageString)).click();
        device.waitForIdle();

        device.findObject(new UiSelector().textContains(""Clear storage"")).click();
        device.waitForIdle();

        device.findObject(new UiSelector().text(""OK"")).click();
    }

    /**
     * Measure ourselves manually.
     */"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/StorageApp/src/com/android/cts/storageapp/StorageTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.storageapp.StorageTest"	"testBehaviorNormal"	""	"1: system"	"public void testBehaviorNormal() throws Exception {
        final StorageManager sm = getContext().getSystemService(StorageManager.class);

        final File dir = makeUniqueFile(getContext().getCacheDir());
        dir.mkdir();
        assertFalse(sm.isCacheBehaviorGroup(dir));
        assertFalse(sm.isCacheBehaviorTombstone(dir));

        final File ext = makeUniqueFile(getContext().getExternalCacheDir());
        ext.mkdir();
        try { sm.isCacheBehaviorGroup(ext); fail(); } catch (IOException expected) { }
        try { sm.isCacheBehaviorTombstone(ext); fail(); } catch (IOException expected) { }
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/StorageApp/src/com/android/cts/storageapp/StorageTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.storageapp.StorageTest"	"testBehaviorGroup"	""	"1: system"	"public void testBehaviorGroup() throws Exception {
        final StorageManager sm = getContext().getSystemService(StorageManager.class);

        final File dir = makeUniqueFile(getContext().getCacheDir());
        dir.mkdir();
        sm.setCacheBehaviorGroup(dir, true);
        assertTrue(sm.isCacheBehaviorGroup(dir));

        final File ext = makeUniqueFile(getContext().getExternalCacheDir());
        ext.mkdir();
        try { sm.setCacheBehaviorGroup(ext, true); fail(); } catch (IOException expected) { }
        try { sm.setCacheBehaviorGroup(ext, false); fail(); } catch (IOException expected) { }
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/StorageApp/src/com/android/cts/storageapp/StorageTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.storageapp.StorageTest"	"testBehaviorTombstone"	""	"1: system"	"public void testBehaviorTombstone() throws Exception {
        final StorageManager sm = getContext().getSystemService(StorageManager.class);

        final File dir = makeUniqueFile(getContext().getCacheDir());
        dir.mkdir();
        sm.setCacheBehaviorTombstone(dir, true);
        assertTrue(sm.isCacheBehaviorTombstone(dir));

        final File ext = makeUniqueFile(getContext().getExternalCacheDir());
        ext.mkdir();
        try { sm.setCacheBehaviorTombstone(ext, true); fail(); } catch (IOException expected) { }
        try { sm.setCacheBehaviorTombstone(ext, false); fail(); } catch (IOException expected) { }
    }

    /**
     * Create ""cts"" probe files in every possible common storage location that
     * we can think of.
     */"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/StorageApp/src/com/android/cts/storageapp/StorageTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.storageapp.StorageTest"	"testExternalStorageIsolatedNonLegacy"	""	"1: system"	"public void testExternalStorageIsolatedNonLegacy() throws Exception {
        assertFalse(new File(""/sdcard/cts_top"").exists());
    }

    private boolean isTV() {
        return hasFeature(PackageManager.FEATURE_LEANBACK);
    }

    private boolean isCar() {
        return hasFeature(PackageManager.FEATURE_AUTOMOTIVE);
    }

    private boolean isWatch() {
        return hasFeature(PackageManager.FEATURE_WATCH);
    }

    private boolean hasFeature(String feature) {
        return getContext().getPackageManager().hasSystemFeature(feature);
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/StorageApp/src/com/android/cts/storageapp/StorageTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.hardware.cts.LowRamDeviceTest"	"DisplayMetrics"	"CtsHardwareTestCases"	"2: ui system"	"/*
 *
 */

package android.hardware.cts;

import static android.content.res.Configuration.SCREENLAYOUT_SIZE_LARGE;
import static android.content.res.Configuration.SCREENLAYOUT_SIZE_NORMAL;
import static android.content.res.Configuration.SCREENLAYOUT_SIZE_SMALL;
import static android.content.res.Configuration.SCREENLAYOUT_SIZE_XLARGE;
import static android.util.DisplayMetrics.DENSITY_400;
import static android.util.DisplayMetrics.DENSITY_560;
import static android.util.DisplayMetrics.DENSITY_HIGH;
import static android.util.DisplayMetrics.DENSITY_LOW;
import static android.util.DisplayMetrics.DENSITY_MEDIUM;
import static android.util.DisplayMetrics.DENSITY_TV;
import static android.util.DisplayMetrics.DENSITY_XHIGH;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import android.app.ActivityManager;
import android.content.Context;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.os.Build;
import android.os.StatFs;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.WindowManager;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.CddTest;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.File;

/**
 * Tests that devices with low RAM specify themselves as Low RAM devices
 */
@RunWith(AndroidJUnit4.class)
public class LowRamDeviceTest {

    private static final long ONE_MEGABYTE = 1048576L;
    private static final String TAG = ""LowRamDeviceTest"";
    private static final long LOW_RAM_MAX = 1024;
    private static final float MIN_APP_DATA_PARTITION_SIZE_GB = 4f;
    private static final float MIN_APP_DATA_PARTITION_SIZE_LOW_RAM_GB = 1.1f;
    private static final float MIN_SHARED_DATA_PARTITION_SIZE_GB = 1f;
    private static final long GB_TO_BYTES_MULTIPLIER = 1024 * 1024 * 1024;

    private Context mContext;
    private PackageManager mPackageManager;
    private ActivityManager mActivityManager;
    private DisplayMetrics mDisplayMetrics;

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getTargetContext();
        mPackageManager = mContext.getPackageManager();
        mActivityManager =
                (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);

        mDisplayMetrics = new DisplayMetrics();
        WindowManager windowManager =
                (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
        windowManager.getDefaultDisplay().getMetrics(mDisplayMetrics);
    }

    /**
     * Test the devices reported memory to ensure it meets the minimum values described
     * in CDD 7.6.1.
     */"	"/home/gpoor/cts-12-source/cts/tests/tests/hardware/src/android/hardware/cts/LowRamDeviceTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.hardware.cts.LowRamDeviceTest"	"testMinimumMemory"	"CtsHardwareTestCases"	"2: ui system"	"@CddTest(requirement=""7.6.1"")
    public void testMinimumMemory() {
        int density = mDisplayMetrics.densityDpi;
        Boolean supports64Bit = supportsSixtyFourBit();
        int screenSize = getScreenSize();
        Boolean lowRamDevice = mActivityManager.isLowRamDevice();
        Boolean watch = mPackageManager.hasSystemFeature(PackageManager.FEATURE_WATCH);

        Log.i(TAG, String.format(""density=%d, supports64Bit=%s, screenSize=%d, watch=%s"",
                density, supports64Bit, screenSize, watch));

        if (watch) {
            assertFalse(""Device is not expected to be 64-bit"", supports64Bit);
            assertMinMemoryMb(416);
        } else if (lessThanDpi(density, DENSITY_HIGH, screenSize,
                SCREENLAYOUT_SIZE_NORMAL, SCREENLAYOUT_SIZE_SMALL) ||
                lessThanDpi(density, DENSITY_MEDIUM, screenSize, SCREENLAYOUT_SIZE_LARGE) ||
                lessThanDpi(density, DENSITY_LOW, screenSize, SCREENLAYOUT_SIZE_XLARGE)) {

            if (supports64Bit) {
                assertMinMemoryMb(816);
            } else {
                assertMinMemoryMb(416);
            }
        } else if (greaterThanDpi(density, DENSITY_560, screenSize,
                SCREENLAYOUT_SIZE_NORMAL, SCREENLAYOUT_SIZE_SMALL) ||
                greaterThanDpi(density, DENSITY_400, screenSize, SCREENLAYOUT_SIZE_LARGE) ||
                greaterThanDpi(density, DENSITY_XHIGH, screenSize, SCREENLAYOUT_SIZE_XLARGE)) {

            if (supports64Bit) {
                assertMinMemoryMb(1824);
            } else {
                assertMinMemoryMb(1344);
            }
        } else if (greaterThanDpi(density, DENSITY_400, screenSize,
                SCREENLAYOUT_SIZE_NORMAL, SCREENLAYOUT_SIZE_SMALL) ||
                greaterThanDpi(density, DENSITY_XHIGH, screenSize, SCREENLAYOUT_SIZE_LARGE) ||
                greaterThanDpi(density, DENSITY_TV, screenSize, SCREENLAYOUT_SIZE_XLARGE)) {

            if (supports64Bit) {
                assertMinMemoryMb(1280);
            } else {
                assertMinMemoryMb(896);
            }
        } else if (greaterThanDpi(density, DENSITY_XHIGH, screenSize,
                SCREENLAYOUT_SIZE_NORMAL, SCREENLAYOUT_SIZE_SMALL) ||
                greaterThanDpi(density, DENSITY_TV, screenSize, SCREENLAYOUT_SIZE_LARGE) ||
                greaterThanDpi(density, DENSITY_MEDIUM, screenSize, SCREENLAYOUT_SIZE_XLARGE)) {

            if (supports64Bit) {
                assertMinMemoryMb(944);
            } else {
                assertMinMemoryMb(592);
            }
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/hardware/src/android/hardware/cts/LowRamDeviceTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.hardware.cts.LowRamDeviceTest"	"testMinSharedDataPartitionSize"	"CtsHardwareTestCases"	"1: ui"	"@CddTest(requirement=""7.6.2"")
    public void testMinSharedDataPartitionSize() {
        assertDataPartitionMinimumSize(
                ""Shared data"",
                mContext.getExternalFilesDir(null),
                MIN_SHARED_DATA_PARTITION_SIZE_GB);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/hardware/src/android/hardware/cts/LowRamDeviceTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.hardware.cts.LowRamDeviceTest"	"testMinDataPartitionSize"	"CtsHardwareTestCases"	"1: ui"	"@CddTest(requirement=""7.6.1/H-9-2,7.6.1/H-10-1"")
    public void testMinDataPartitionSize() {
        long totalMemoryMb = getTotalMemory() / ONE_MEGABYTE;
        boolean lowRam = totalMemoryMb <= LOW_RAM_MAX;

        if (lowRam) {
            assertDataPartitionMinimumSize(
                    ""Application data"",
                    mContext.getFilesDir(),
                    MIN_APP_DATA_PARTITION_SIZE_LOW_RAM_GB);
        } else {
            assertDataPartitionMinimumSize(
                    ""Application data"", mContext.getFilesDir(), MIN_APP_DATA_PARTITION_SIZE_GB);
        }
    }

    /**
     * @return the total memory accessible by the kernel as defined by
     * {@code ActivityManager.MemoryInfo}.
     */
    private long getTotalMemory() {
        ActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo();
        mActivityManager.getMemoryInfo(memoryInfo);
        return memoryInfo.totalMem;
    }

    /** @return the screen size as defined in {@Configuration}. */
    private int getScreenSize() {
        Configuration config = mContext.getResources().getConfiguration();
        return config.screenLayout & Configuration.SCREENLAYOUT_SIZE_MASK;
    }

    /** @return true iff this device supports 64 bit ABIs */
    private static boolean supportsSixtyFourBit() {
        return Build.SUPPORTED_64_BIT_ABIS.length > 0;
    }

    /** Asserts that the given values conform to the specs in CDD 7.6.1 */
    private void assertMinMemoryMb(long minMb) {

        long totalMemoryMb = getTotalMemory() / ONE_MEGABYTE;
        boolean lowRam = totalMemoryMb <= LOW_RAM_MAX;
        boolean lowRamDevice = mActivityManager.isLowRamDevice();

        Log.i(TAG, String.format(""minMb=%,d"", minMb));
        Log.i(TAG, String.format(""totalMemoryMb=%,d"", totalMemoryMb));
        Log.i(TAG, ""lowRam="" + lowRam);
        Log.i(TAG, ""lowRamDevice="" + lowRamDevice);

        assertTrue(String.format(""Does not meet minimum memory requirements (CDD 7.6.1).""
                + ""Found = %d, Minimum = %d"", totalMemoryMb, minMb), totalMemoryMb >= minMb);

        assertTrue(""Device must specify low RAM property: ro.config.low_ram=true"",
                !lowRam || (lowRam && lowRamDevice));
    }

    private static boolean lessThanDpi(int actualDensityDpi, int expectedDensityDpi,
            int actualScreenSize, int... expectedScreenSizes) {
        return actualDensityDpi <= expectedDensityDpi &&
                contains(expectedScreenSizes, actualScreenSize);
    }

    private static boolean greaterThanDpi(int actualDensityDpi, int expectedDensityDpi,
            int actualScreenSize, int... expectedScreenSizes) {
        return actualDensityDpi >= expectedDensityDpi &&
                contains(expectedScreenSizes, actualScreenSize);
    }

    /** @return true iff the {@code array} contains the {@code target} */
    private static boolean contains(int [] array, int target) {
        for(int a : array) {
            if (a == target) {
                return true;
            }
        }
        return false;
    }

    private void assertDataPartitionMinimumSize(
            String partitionName, File fileInPartition, float minPartitionSizeGb) {
        StatFs statFs = new StatFs(fileInPartition.getAbsolutePath());
        long size = statFs.getTotalBytes();
        long minSizeBytes = (long) minPartitionSizeGb * GB_TO_BYTES_MULTIPLIER;

        assertTrue(
                String.format(""%s partition size does not meet requirement. ""
                        + ""Found = %d, Minimum = %d"", partitionName, size, minSizeBytes),
                size > minSizeBytes);
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/hardware/src/android/hardware/cts/LowRamDeviceTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.server.cts.device.statsdatom.DirectoryTests"	"testStatsActiveMetricDirectoryExists"	""	"1: direct"	"public void testStatsActiveMetricDirectoryExists() {
        final File f = new File(""/data/misc/stats-active-metric/"");
        assertTrue(f.exists());
        assertFalse(f.isFile());
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/apps/statsdapp/src/com/android/server/cts/device/statsdatom/DirectoryTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.server.cts.device.statsdatom.DirectoryTests"	"testStatsDataDirectoryExists"	""	"1: direct"	"public void testStatsDataDirectoryExists() {
        final File f = new File(""/data/misc/stats-data/"");
        assertTrue(f.exists());
        assertFalse(f.isFile());
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/apps/statsdapp/src/com/android/server/cts/device/statsdatom/DirectoryTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.server.cts.device.statsdatom.DirectoryTests"	"testStatsMetadataDirectoryExists"	""	"1: direct"	"public void testStatsMetadataDirectoryExists() {
        final File f = new File(""/data/misc/stats-metadata/"");
        assertTrue(f.exists());
        assertFalse(f.isFile());
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/apps/statsdapp/src/com/android/server/cts/device/statsdatom/DirectoryTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.server.cts.device.statsdatom.DirectoryTests"	"testStatsServiceDirectoryExists"	""	"1: direct"	"public void testStatsServiceDirectoryExists() {
        final File f = new File(""/data/misc/stats-service/"");
        assertTrue(f.exists());
        assertFalse(f.isFile());
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/apps/statsdapp/src/com/android/server/cts/device/statsdatom/DirectoryTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.server.cts.device.statsdatom.DirectoryTests"	"testTrainInfoDirectoryExists"	""	"1: direct"	"public void testTrainInfoDirectoryExists() {
        final File f = new File(""/data/misc/train-info/"");
        assertTrue(f.exists());
        assertFalse(f.isFile());
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/apps/statsdapp/src/com/android/server/cts/device/statsdatom/DirectoryTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.os.cts.MessageQueueTest"	"testAddIdleHandler"	""	"1: ui"	"public void testAddIdleHandler() throws InterruptedException {
        TestLooperThread looperThread = new TestLooperThread(Test.ADD_IDLE_HANDLER);
        looperThread.start();

        try {
            if (!looperThread.hasIdleHandlerBeenCalled()) {
                fail(""IdleHandler#queueIdle was NOT called: "" + looperThread.getTestProgress());
            }
        } finally {
            assertTrue(""The looper should have been running."", looperThread.quit());
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/MessageQueueTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.os.cts.MessageQueueTest"	"testRemoveIdleHandler"	""	"1: ui"	"public void testRemoveIdleHandler() throws InterruptedException {
        TestLooperThread looperThread = new TestLooperThread(Test.REMOVE_IDLE_HANDLER);
        looperThread.start();

        try {
            if (looperThread.hasIdleHandlerBeenCalled()) {
                fail(""IdleHandler#queueIdle was called: "" + looperThread.getTestProgress());
            }
        } finally {
            assertTrue(""The looper should have been running."", looperThread.quit());
        }
    }

    private enum Test {ADD_IDLE_HANDLER, REMOVE_IDLE_HANDLER}

    /**
     * {@link HandlerThread} that adds or removes an idle handler depending on the {@link Test}
     * given. It uses a {@link CountDownLatch} with an initial count of 2. The first count down
     * occurs right before the looper's run thread had started running. The final count down
     * occurs when the idle handler was executed. Tests can call {@link #hasIdleHandlerBeenCalled()}
     * to see if the countdown reached to 0 or not.
     */
    private static class TestLooperThread extends HandlerThread {

        private final Test mTestMode;

        private final CountDownLatch mIdleLatch = new CountDownLatch(2);

        TestLooperThread(Test testMode) {
            super(""TestLooperThread"");
            mTestMode = testMode;
        }

        @Override
        protected void onLooperPrepared() {
            super.onLooperPrepared();

            IdleHandler idleHandler = new IdleHandler() {
                @Override
                public boolean queueIdle() {
                    mIdleLatch.countDown();
                    return false;
                }
            };

            if (mTestMode == Test.ADD_IDLE_HANDLER) {
                Looper.myQueue().addIdleHandler(idleHandler);
            } else {
                Looper.myQueue().addIdleHandler(idleHandler);
                Looper.myQueue().removeIdleHandler(idleHandler);
            }
        }

        @Override
        public void run() {
            mIdleLatch.countDown();
            super.run();
        }

        public boolean hasIdleHandlerBeenCalled() throws InterruptedException {
            return mIdleLatch.await(TIMEOUT, TimeUnit.MILLISECONDS);
        }

        public long getTestProgress() {
            return mIdleLatch.getCount();
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/MessageQueueTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.os.cts.MessageQueueTest"	"testIsIdle"	""	"1: ui"	"public void testIsIdle() throws Exception {
        HandlerThread thread = new HandlerThread(""testIsIdle"");
        thread.start();
        try {
            // Queue should initially be idle.
            assertTrue(thread.getLooper().getQueue().isIdle());

            // Post two messages.  Block in the first one leaving the second one pending.
            final CountDownLatch latch1 = new CountDownLatch(1);
            final CountDownLatch latch2 = new CountDownLatch(1);
            Handler handler = new Handler(thread.getLooper());
            handler.post(new Runnable() {
                @Override
                public void run() {
                    // Wait for latch1 released before returning.
                    try {
                        latch1.await(TIMEOUT, TimeUnit.MILLISECONDS);
                    } catch (InterruptedException ex) { }
                }
            });
            handler.post(new Runnable() {
                @Override
                public void run() {
                    // Release latch2 when finished.
                    latch2.countDown();
                }
            });

            // The first message is blocked so the second should still be in the queue.
            // At this point the queue will not be idle because there is a pending message.
            assertFalse(thread.getLooper().getQueue().isIdle());

            // Let the first message complete and wait for the second to leave the queue.
            // At this point the queue will be idle because it is empty.
            latch1.countDown();
            latch2.await(TIMEOUT, TimeUnit.MILLISECONDS);
            assertTrue(thread.getLooper().getQueue().isIdle());
        } finally {
            thread.quitSafely();
        }
    }

    /**
     * Use MessageQueue, send message by order
     */"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/MessageQueueTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.os.cts.MessageQueueTest"	"testFileDescriptorCallbacks"	""	"1: ui"	"public void testFileDescriptorCallbacks() throws Throwable {
        // Prepare a special looper that we can catch exceptions from.
        AssertableHandlerThread thread = new AssertableHandlerThread();
        thread.start();
        try {
            final CountDownLatch writerSawError = new CountDownLatch(1);
            final CountDownLatch readerDone = new CountDownLatch(1);
            final MessageQueue queue = thread.getLooper().getQueue();
            final ParcelFileDescriptor[] pipe = ParcelFileDescriptor.createPipe();
            try (final FileInputStream reader = new AutoCloseInputStream(pipe[0]);
                    final FileOutputStream writer = new AutoCloseOutputStream(pipe[1])) {
                final int size = 256 * 1024;

                // Prepare to write a lot of data to the pipe asynchronously.
                // We don't actually care about the content (assume pipes work correctly)
                // so we just write lots of zeros.
                OnFileDescriptorEventListener writerCallback = new OnFileDescriptorEventListener() {
                    private byte[] mBuffer = new byte[4096];
                    private int mRemaining = size;
                    private boolean mDone;

                    @Override
                    public int onFileDescriptorEvents(FileDescriptor fd, int events) {
                        assertEquals(pipe[1].getFileDescriptor(), fd);
                        if (!mDone) {
                            // When an error happens because the reader closed its end,
                            // signal the test, and remove the callback.
                            if ((events & OnFileDescriptorEventListener.EVENT_ERROR) != 0) {
                                writerSawError.countDown();
                                mDone = true;
                                return 0;
                            }

                            // Write all output until an error is observed.
                            if ((events & OnFileDescriptorEventListener.EVENT_OUTPUT) != 0) {
                                int count = Math.min(mBuffer.length, mRemaining);
                                try {
                                    writer.write(mBuffer, 0, count);
                                } catch (IOException ex) {
                                    throw new RuntimeException(ex);
                                }
                                mRemaining -= count;
                                return mRemaining != 0 ? EVENT_OUTPUT : EVENT_ERROR;
                            }
                        }

                        // Should never see anything else.
                        fail(""Saw unexpected events: "" + events + "", mDone="" + mDone);
                        return 0;
                    }
                };

                // Prepare to read all of that data.
                OnFileDescriptorEventListener readerCallback = new OnFileDescriptorEventListener() {
                    private byte[] mBuffer = new byte[4096];
                    private int mRemaining = size;
                    private boolean mDone;

                    @Override
                    public int onFileDescriptorEvents(FileDescriptor fd, int events) {
                        assertEquals(pipe[0].getFileDescriptor(), fd);
                        if (!mDone) {
                            // Errors should not happen.
                            if ((events & OnFileDescriptorEventListener.EVENT_ERROR) != 0) {
                                fail(""Saw unexpected error."");
                                return 0;
                            }

                            // Read until everything is read, signal the test,
                            // and remove the callback.
                            if ((events & OnFileDescriptorEventListener.EVENT_INPUT) != 0) {
                                try {
                                    int count = reader.read(mBuffer, 0, mBuffer.length);
                                    mRemaining -= count;
                                } catch (IOException ex) {
                                    throw new RuntimeException(ex);
                                }
                                if (mRemaining != 0) {
                                    return EVENT_INPUT;
                                }
                                readerDone.countDown();
                                mDone = true;
                                return 0;
                            }
                        }

                        // Should never see anything else.
                        fail(""Saw unexpected events: "" + events + "", mDone="" + mDone);
                        return 0;
                    }
                };

                // Register the callbacks.
                queue.addOnFileDescriptorEventListener(reader.getFD(),
                        OnFileDescriptorEventListener.EVENT_INPUT, readerCallback);
                queue.addOnFileDescriptorEventListener(writer.getFD(),
                        OnFileDescriptorEventListener.EVENT_OUTPUT, writerCallback);

                // Wait for the reader to see all of the data that the writer
                // is prepared to send.
                readerDone.await(TIMEOUT, TimeUnit.MILLISECONDS);

                // At this point the reader's callback should be unregistered.
                // Close the reader's file descriptor (pretend it crashed or something).
                reader.close();

                // Because the reader is gone, the writer should observe an error (EPIPE).
                // Wait for this to happen.
                writerSawError.await(TIMEOUT, TimeUnit.MILLISECONDS);

                // The reader and writer should already be unregistered.
                // Try to unregistered them again to ensure nothing bad happens.
                queue.removeOnFileDescriptorEventListener(reader.getFD());
                queue.removeOnFileDescriptorEventListener(writer.getFD());
            }
        } finally {
            thread.quitAndRethrow();
        }
    }

    /**
     * Since file descriptor numbers may be reused, there are some interesting
     * edge cases around closing file descriptors within the callback and adding
     * new ones with the same number.
     *
     * Register a file descriptor, close it from within the callback, then return.
     * Later, create a new file descriptor register it.  Ensure that we start getting
     * events for the new file descriptor.
     *
     * This test exercises special logic in Looper.cpp for EPOLL_CTL_DEL handling EBADF.
     */"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/MessageQueueTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.os.cts.MessageQueueTest"	"testPathologicalFileDescriptorReuseCallbacks1"	""	"1: ui"	"public void testPathologicalFileDescriptorReuseCallbacks1() throws Throwable {
        // Prepare a special looper that we can catch exceptions from.
        AssertableHandlerThread thread = new AssertableHandlerThread();
        thread.start();
        try {
            final MessageQueue queue = thread.getLooper().getQueue();
            final Handler handler = new Handler(thread.getLooper());

            final ParcelFileDescriptor[] pipe = ParcelFileDescriptor.createPipe();
            try (final FileInputStream reader = new AutoCloseInputStream(pipe[0]);
                    final FileOutputStream writer = new AutoCloseOutputStream(pipe[1])) {
                // Register the callback.
                final CountDownLatch awoke = new CountDownLatch(1);
                queue.addOnFileDescriptorEventListener(reader.getFD(),
                        OnFileDescriptorEventListener.EVENT_ERROR,
                        new OnFileDescriptorEventListener() {
                    @Override
                    public int onFileDescriptorEvents(FileDescriptor fd, int events) {
                        awoke.countDown();

                        // Close the reader before we return.
                        closeQuietly(reader);

                        // Return 0 to unregister the callback.
                        return 0;
                    }
                });

                // Close the writer to wake up the callback (due to hangup).
                writer.close();

                // Wait for the looper to catch up and run the callback.
                assertTrue(""awoke"", awoke.await(TIMEOUT, TimeUnit.MILLISECONDS));
                syncWait(handler);
            }

            // At this point, the reader and writer are both closed.
            // Make a new pipe and ensure that things still work as expected.
            final ParcelFileDescriptor[] pipe2 = ParcelFileDescriptor.createPipe();
            try (final FileInputStream reader2 = new AutoCloseInputStream(pipe2[0]);
                    final FileOutputStream writer2 = new AutoCloseOutputStream(pipe2[1])) {
                // Register the callback.
                final CountDownLatch awoke = new CountDownLatch(1);
                queue.addOnFileDescriptorEventListener(reader2.getFD(),
                        OnFileDescriptorEventListener.EVENT_INPUT,
                        new OnFileDescriptorEventListener() {
                    @Override
                    public int onFileDescriptorEvents(FileDescriptor fd, int events) {
                        awoke.countDown();

                        // Return 0 to unregister the callback.
                        return 0;
                    }
                });

                // Close the writer to wake up the callback (due to hangup).
                writer2.close();

                // Wait for the looper to catch up and run the callback.
                assertTrue(""awoke"", awoke.await(TIMEOUT, TimeUnit.MILLISECONDS));
                syncWait(handler);
            }
        } finally {
            thread.quitAndRethrow();
        }
    }

    /**
     * Since file descriptor numbers may be reused, there are some interesting
     * edge cases around closing file descriptors within the callback and adding
     * new ones with the same number.
     *
     * Register a file descriptor, close it from within the callback, reassign its
     * number to a different pipe, then return.  Later, register the same file descriptor
     * again (now referring to a new pipe).  Ensure that we start getting
     * events for the new file descriptor.
     *
     * This test exercises special logic in Looper.cpp for EPOLL_CTL_DEL handling ENOENT.
     */"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/MessageQueueTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.os.cts.MessageQueueTest"	"testPathologicalFileDescriptorReuseCallbacks2"	""	"1: ui"	"public void testPathologicalFileDescriptorReuseCallbacks2() throws Throwable {
        // Prepare a special looper that we can catch exceptions from.
        AssertableHandlerThread thread = new AssertableHandlerThread();
        thread.start();
        try {
            final MessageQueue queue = thread.getLooper().getQueue();
            final Handler handler = new Handler(thread.getLooper());

            final ParcelFileDescriptor[] pipe = ParcelFileDescriptor.createPipe();
            final ParcelFileDescriptor[] pipe2 = ParcelFileDescriptor.createPipe();
            try {
                final int oldReaderFd = pipe[0].getFd();
                try (final FileInputStream reader = new AutoCloseInputStream(pipe[0]);
                        final FileOutputStream writer = new AutoCloseOutputStream(pipe[1])) {
                    // Register the callback.
                    final CountDownLatch awoke = new CountDownLatch(1);
                    queue.addOnFileDescriptorEventListener(reader.getFD(),
                            OnFileDescriptorEventListener.EVENT_ERROR,
                            new OnFileDescriptorEventListener() {
                        @Override
                        public int onFileDescriptorEvents(FileDescriptor fd, int events) {
                            awoke.countDown();

                            // Close the reader before we return and hijack its fd.
                            hijackFd(pipe2, pipe);

                            // Return 0 to unregister the callback.
                            return 0;
                        }
                    });

                    // Close the writer to wake up the callback (due to hangup).
                    writer.close();

                    // Wait for the looper to catch up and run the callback.
                    assertTrue(""awoke"", awoke.await(TIMEOUT, TimeUnit.MILLISECONDS));
                    syncWait(handler);
                }

                // Now we have a new pipe with the same file descriptor, make sure we can
                // register it successfully.
                assertEquals(oldReaderFd, pipe2[0].getFd());
                try (final FileInputStream reader2 = new AutoCloseInputStream(pipe2[0]);
                        final FileOutputStream writer2 = new AutoCloseOutputStream(pipe2[1])) {
                    // Register the callback.
                    final CountDownLatch awoke = new CountDownLatch(1);
                    queue.addOnFileDescriptorEventListener(reader2.getFD(),
                            OnFileDescriptorEventListener.EVENT_INPUT,
                            new OnFileDescriptorEventListener() {
                        @Override
                        public int onFileDescriptorEvents(FileDescriptor fd, int events) {
                            awoke.countDown();

                            // Return 0 to unregister the callback.
                            return 0;
                        }
                    });

                    // Close the writer to wake up the callback (due to hangup).
                    writer2.close();

                    // Wait for the looper to catch up and run the callback.
                    assertTrue(""awoke"", awoke.await(TIMEOUT, TimeUnit.MILLISECONDS));
                    syncWait(handler);
                }
            } finally {
                closeQuietly(pipe[0]);
                closeQuietly(pipe[1]);
                closeQuietly(pipe2[0]);
                closeQuietly(pipe2[1]);
            }
        } finally {
            thread.quitAndRethrow();
        }
    }

    /**
     * Since file descriptor numbers may be reused, there are some interesting
     * edge cases around closing file descriptors within the callback and adding
     * new ones with the same number.
     *
     * Register a file descriptor, close it from within the callback, reassign its
     * number to a different pipe, register it, then return.
     * Ensure that we start getting events for the new file descriptor.
     *
     * This test exercises special logic in Looper.cpp for EPOLL_CTL_MOD handling
     * ENOENT and fallback to EPOLL_CTL_ADD as well as sequence number checks when removing
     * the fd after the callback returns.
     */"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/MessageQueueTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.os.cts.MessageQueueTest"	"testPathologicalFileDescriptorReuseCallbacks3"	""	"1: ui"	"public void testPathologicalFileDescriptorReuseCallbacks3() throws Throwable {
        // Prepare a special looper that we can catch exceptions from.
        AssertableHandlerThread thread = new AssertableHandlerThread();
        thread.start();
        try {
            final MessageQueue queue = thread.getLooper().getQueue();
            final Handler handler = new Handler(thread.getLooper());

            final ParcelFileDescriptor[] pipe = ParcelFileDescriptor.createPipe();
            final ParcelFileDescriptor[] pipe2 = ParcelFileDescriptor.createPipe();
            try {
                final CountDownLatch awoke2 = new CountDownLatch(1);
                final int oldReaderFd = pipe[0].getFd();
                try (final FileInputStream reader = new AutoCloseInputStream(pipe[0]);
                        final FileOutputStream writer = new AutoCloseOutputStream(pipe[1])) {
                    // Register the callback.
                    final CountDownLatch awoke = new CountDownLatch(1);
                    queue.addOnFileDescriptorEventListener(reader.getFD(),
                            OnFileDescriptorEventListener.EVENT_ERROR,
                            new OnFileDescriptorEventListener() {
                        @Override
                        public int onFileDescriptorEvents(FileDescriptor fd, int events) {
                            awoke.countDown();

                            // Close the reader before we return and hijack its fd.
                            hijackFd(pipe2, pipe);

                            // Now we have a new pipe, make sure we can register it successfully.
                            queue.addOnFileDescriptorEventListener(pipe2[0].getFileDescriptor(),
                                    OnFileDescriptorEventListener.EVENT_INPUT,
                                    new OnFileDescriptorEventListener() {
                                @Override
                                public int onFileDescriptorEvents(FileDescriptor fd, int events) {
                                    awoke2.countDown();

                                    // Return 0 to unregister the callback.
                                    return 0;
                                }
                            });

                            // Return 0 to unregister the callback.
                            return 0;
                        }
                    });

                    // Close the writer to wake up the callback (due to hangup).
                    writer.close();

                    // Wait for the looper to catch up and run the callback.
                    assertTrue(""awoke"", awoke.await(TIMEOUT, TimeUnit.MILLISECONDS));
                    syncWait(handler);
                }

                // Close the second writer to wake up the second callback (due to hangup).
                pipe2[1].close();

                // Wait for the looper to catch up and run the callback.
                assertTrue(""awoke2"", awoke2.await(TIMEOUT, TimeUnit.MILLISECONDS));
                syncWait(handler);

                // Close the second reader now that we're done with the test.
                assertEquals(oldReaderFd, pipe2[0].getFd());
                pipe2[0].close();
            } finally {
                closeQuietly(pipe[0]);
                closeQuietly(pipe[1]);
                closeQuietly(pipe2[0]);
                closeQuietly(pipe2[1]);
            }
        } finally {
            thread.quitAndRethrow();
        }
    }

    /**
     * Since file descriptor numbers may be reused, there are some interesting
     * edge cases around closing file descriptors within the callback and adding
     * new ones with the same number.
     *
     * Register a file descriptor, make a duplicate of it, close it from within the
     * callback, then return.  Look for signs that the Looper is spinning
     * and never getting a chance to block.
     *
     * This test exercises special logic in Looper.cpp for rebuilding the epoll set
     * in case it contains a file descriptor which has been closed and cannot be removed.
     */"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/MessageQueueTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.os.cts.MessageQueueTest"	"testPathologicalFileDescriptorReuseCallbacks4"	""	"1: ui"	"public void testPathologicalFileDescriptorReuseCallbacks4() throws Throwable {
        // Prepare a special looper that we can catch exceptions from.
        ParcelFileDescriptor dup = null;
        AssertableHandlerThread thread = new AssertableHandlerThread();
        thread.start();
        try {
            try {
                final MessageQueue queue = thread.getLooper().getQueue();
                final Handler handler = new Handler(thread.getLooper());

                final ParcelFileDescriptor[] pipe = ParcelFileDescriptor.createPipe();
                dup = pipe[0].dup();
                try (final FileInputStream reader = new AutoCloseInputStream(pipe[0]);
                        final FileOutputStream writer = new AutoCloseOutputStream(pipe[1])) {
                    // Register the callback.
                    final CountDownLatch awoke = new CountDownLatch(1);
                    queue.addOnFileDescriptorEventListener(reader.getFD(),
                            OnFileDescriptorEventListener.EVENT_ERROR, new OnFileDescriptorEventListener() {
                        @Override
                        public int onFileDescriptorEvents(FileDescriptor fd, int events) {
                            awoke.countDown();

                            // Close the file descriptor before we return.
                            try {
                                reader.close();
                            } catch (IOException ex) {
                                throw new RuntimeException(ex);
                            }

                            // Return 0 to unregister the callback.
                            return 0;
                        }
                    });

                    // Close the writer to wake up the callback (due to hangup).
                    writer.close();

                    // Wait for the looper to catch up and run the callback.
                    assertTrue(""awoke"", awoke.await(TIMEOUT, TimeUnit.MILLISECONDS));
                    syncWait(handler);
                }

                // Wait a little bit before we stop the thread.
                Thread.sleep(2000);
            } finally {
                // Check for how long the thread was running.
                // If the Looper behaved correctly, then it should have blocked for most of
                // the duration of the test (including that sleep above) since not much else
                // was happening.  If we failed to actually rebuild the epoll set then the
                // Looper may have been spinning continuously due to an FD that was never
                // properly removed from the epoll set so the thread runtime will be very high.
                long runtime = thread.quitAndRethrow();
                assertFalse(""Looper thread spent most of its time spinning instead of blocked."",
                        runtime > 1000);
            }
        } finally {
            // Close the duplicate now that we are done with it.
            if (dup != null) {
                dup.close();
            }
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/MessageQueueTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.os.cts.MessageQueueTest"	"testReleaseSyncBarrierThrowsIfTokenNotValid"	""	"2: ui system"	"public void testReleaseSyncBarrierThrowsIfTokenNotValid() throws Exception {
        MessageQueue queue = Looper.getMainLooper().getQueue();

        // Invalid token
        try {
            queue.removeSyncBarrier(-1);
            fail(""Should have thrown IllegalStateException"");
        } catch (IllegalStateException ex) {
            // expected
        }

        // Token already removed.
        int barrierToken = queue.postSyncBarrier();
        queue.removeSyncBarrier(barrierToken);
        try {
            queue.removeSyncBarrier(barrierToken);
            fail(""Should have thrown IllegalStateException"");
        } catch (IllegalStateException ex) {
            // expected
        }
    }

    private void syncWait(Handler handler) throws InterruptedException {
        final CountDownLatch latch = new CountDownLatch(1);
        handler.post(new Runnable() {
            @Override
            public void run() {
                latch.countDown();
            }
        });
        assertTrue(""Handler got stuck."", latch.await(TIMEOUT, TimeUnit.MILLISECONDS));
    }

    private static void closeQuietly(AutoCloseable c) {
        if (c != null) {
            try {
                c.close();
            } catch (RuntimeException rethrown) {
                throw rethrown;
            } catch (Exception ex) {
            }
        }
    }

    private static void hijackFd(ParcelFileDescriptor[] newPipe, ParcelFileDescriptor[] oldPipe) {
        // Detach the old pipe's first fd and get its number.
        int fd = oldPipe[0].detachFd();

        // Assign the new pipe's first fd to the same number as the old pipe's first fd.
        // This causes the old pipe's first fd to be closed and reassigned.
        try {
            Os.dup2(newPipe[0].getFileDescriptor(), fd);
        } catch (ErrnoException ex) {
            throw new RuntimeException(ex);
        }

        // Fix up the new pipe's first fd object.
        closeQuietly(newPipe[0]);
        newPipe[0] = ParcelFileDescriptor.adoptFd(fd);
    }

    /**
     * Helper class used to test sending message to message queue.
     */
    private class OrderTestHelper {
        Handler mHandler;
        int mLastMessage;
        int mCount;
        private boolean mSuccess;
        private RuntimeException mFailure;
        private boolean mDone;
        private Looper mLooper;

        public void init() {
            mHandler = new Handler() {
                @Override
                public void handleMessage(Message msg) {
                    OrderTestHelper.this.handleMessage(msg);
                }
            };
        }

        public void handleMessage(Message msg) {
            if (mCount <= mLastMessage) {
                if (msg.what != mCount) {
                    failure(new RuntimeException(""Expected message #"" + mCount + "", received #""
                            + msg.what));
                } else if (mCount == mLastMessage) {
                    success();
                }

                mCount++;
            } else {
                failure(new RuntimeException(""Message received after done, #"" + msg.what));
            }
        }

        public void doTest(long timeout, long interval) throws InterruptedException {
            (new LooperThread()).start();

            synchronized (this) {
                long now = System.currentTimeMillis();
                long endTime = now + timeout;
                while (!mDone && now < endTime) {
                    wait(interval);
                    now = System.currentTimeMillis();
                }
            }

            mLooper.quit();

            if (!mDone) {
                throw new RuntimeException(""test timed out"");
            }
            if (!mSuccess) {
                throw mFailure;
            }
        }

        class LooperThread extends HandlerThread {

            public LooperThread() {
                super(""MessengerLooperThread"");
            }

            @Override
            public void onLooperPrepared() {
                init();
                mLooper = getLooper();
            }

            @Override
            public void run() {
                super.run();
                synchronized (OrderTestHelper.this) {
                    mDone = true;
                    if (!mSuccess && mFailure == null) {
                        mFailure = new RuntimeException(""no failure exception set"");
                    }
                    OrderTestHelper.this.notifyAll();
                }
            }
        }

        public void success() {
            synchronized (this) {
                mSuccess = true;
                quit();
            }
        }

        public void failure(RuntimeException failure) {
            synchronized (this) {
                mSuccess = false;
                mFailure = failure;
                quit();
            }
        }

        private void quit() {
            synchronized (this) {
                mDone = true;
                notifyAll();
            }
        }
    }

    /**
     * A HandlerThread that propagates exceptions out of the event loop
     * instead of crashing the process.
     */
    private static class AssertableHandlerThread extends HandlerThread {
        private Throwable mThrowable;
        private long mRuntime;

        public AssertableHandlerThread() {
            super(""AssertableHandlerThread"");
        }

        @Override
        public void run() {
            final long startTime = SystemClock.currentThreadTimeMillis();
            try {
                super.run();
            } catch (Throwable t) {
                mThrowable = t;
            } finally {
                mRuntime = SystemClock.currentThreadTimeMillis() - startTime;
            }
        }

        public long quitAndRethrow() throws Throwable {
            quitSafely();
            join(TIMEOUT);
            if (mThrowable != null) {
                throw mThrowable;
            }
            return mRuntime;
        }
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/MessageQueueTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.os.cts.MessageQueueTest"	"testMessageOrder"	""	"1: system"	"public void testMessageOrder() throws Exception {

        OrderTestHelper tester = new OrderTestHelper() {
            @Override
            public void init() {
                super.init();
                long now = SystemClock.uptimeMillis() + 200;
                mLastMessage = 4;

                mHandler.sendMessageAtTime(mHandler.obtainMessage(2), now + 1);
                mHandler.sendMessageAtTime(mHandler.obtainMessage(3), now + 2);
                mHandler.sendMessageAtTime(mHandler.obtainMessage(4), now + 2);
                mHandler.sendMessageAtTime(mHandler.obtainMessage(0), now + 0);
                mHandler.sendMessageAtTime(mHandler.obtainMessage(1), now + 0);
            }

        };
        tester.doTest(1000, 50);
    }

    /**
     * Use MessageQueue, send message at front of queue.
     */"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/MessageQueueTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.os.cts.MessageQueueTest"	"testAtFrontOfQueue"	""	"1: system"	"public void testAtFrontOfQueue() throws Exception {

        OrderTestHelper tester = new OrderTestHelper() {

            @Override
            public void init() {
                super.init();
                long now = SystemClock.uptimeMillis() + 200;
                mLastMessage = 3;
                mHandler.sendMessageAtTime(mHandler.obtainMessage(3), now);
                mHandler.sendMessageAtFrontOfQueue(mHandler.obtainMessage(2));
                mHandler.sendMessageAtFrontOfQueue(mHandler.obtainMessage(0));
            }

            @Override
            public void handleMessage(Message msg) {
                super.handleMessage(msg);
                if (msg.what == 0) {
                    mHandler.sendMessageAtFrontOfQueue(mHandler.obtainMessage(1));
                }
            }
        };

        tester.doTest(1000, 50);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/MessageQueueTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.hardware.camera2.cts.testcases.Camera2SurfaceViewTestCase"	"isInstantApp"	"CtsCameraTestCases"	"3: hide ui system"	"public void test/*
 *.
 */

package android.hardware.camera2.cts.testcases;

import static android.hardware.camera2.cts.CameraTestUtils.*;

import static com.android.ex.camera2.blocking.BlockingStateCallback.STATE_CLOSED;
import androidx.test.InstrumentationRegistry;
import android.app.UiAutomation;

import android.content.Context;
import android.graphics.ImageFormat;
import android.hardware.camera2.CameraAccessException;
import android.hardware.camera2.CameraCaptureSession;
import android.hardware.camera2.CameraCaptureSession.CaptureCallback;
import android.hardware.camera2.CameraCharacteristics;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CameraManager;
import android.hardware.camera2.CameraMetadata;
import android.hardware.camera2.CaptureRequest;
import android.hardware.camera2.CaptureResult;
import android.hardware.camera2.cts.Camera2SurfaceViewCtsActivity;
import android.hardware.camera2.cts.Camera2ParameterizedTestCase;
import android.hardware.camera2.cts.CameraTestUtils;
import android.hardware.camera2.cts.CameraTestUtils.SimpleCaptureCallback;
import android.hardware.camera2.cts.helpers.CameraErrorCollector;
import android.hardware.camera2.cts.helpers.StaticMetadata;
import android.hardware.camera2.cts.helpers.StaticMetadata.CheckLevel;
import android.media.ImageReader;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.Looper;
import android.util.Log;
import android.util.Range;
import android.util.Size;
import android.view.Surface;
import android.view.SurfaceHolder;
import android.view.View;
import android.view.WindowManager;

import androidx.test.rule.ActivityTestRule;

import com.android.ex.camera2.blocking.BlockingSessionCallback;
import com.android.ex.camera2.blocking.BlockingStateCallback;
import com.android.ex.camera2.exceptions.TimeoutRuntimeException;

import org.junit.After;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Rule;

import java.io.File;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameter;
import org.junit.runners.Parameterized.Parameters;


/**
 * Camera2 Preview test case base class by using SurfaceView as rendering target.
 *
 * <p>This class encapsulates the SurfaceView based preview common functionalities.
 * The setup and teardown of CameraManager, test HandlerThread, Activity, Camera IDs
 * and CameraStateCallback are handled in this class. Some basic preview related utility
 * functions are provided to facilitate the derived preview-based test classes.
 * </p>
 */

public class Camera2SurfaceViewTestCase extends Camera2ParameterizedTestCase {
    private static final String TAG = ""SurfaceViewTestCase"";
    private static final boolean VERBOSE = Log.isLoggable(TAG, Log.VERBOSE);
    private static final int WAIT_FOR_SURFACE_CHANGE_TIMEOUT_MS = 1000;

    protected static final int WAIT_FOR_RESULT_TIMEOUT_MS = 3000;
    protected static final float FRAME_DURATION_ERROR_MARGIN = 0.01f; // 1 percent error margin.
    protected static final int NUM_RESULTS_WAIT_TIMEOUT = 100;
    protected static final int NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY = 8;
    protected static final int MIN_FRAME_DURATION_ERROR_MARGIN = 100; // ns

    protected HandlerThread mHandlerThread;
    protected Handler mHandler;
    protected BlockingStateCallback mCameraListener;
    protected BlockingSessionCallback mSessionListener;
    protected CameraErrorCollector mCollector;
    protected HashMap<String, StaticMetadata> mAllStaticInfo;
    // Per device fields:
    protected StaticMetadata mStaticInfo;
    protected CameraDevice mCamera;
    protected CameraCaptureSession mSession;
    protected ImageReader mReader;
    protected Surface mReaderSurface;
    protected Surface mPreviewSurface;
    protected SurfaceHolder mPreviewHolder;
    protected Size mPreviewSize;
    protected List<Size> mOrderedPreviewSizes; // In descending order.
    protected List<Size> m1080pBoundedOrderedPreviewSizes; // In descending order.
    protected List<Size> mOrderedVideoSizes; // In descending order.
    protected List<Size> mOrderedStillSizes; // In descending order.
    protected HashMap<Size, Long> mMinPreviewFrameDurationMap;
    protected String mDebugFileNameBase;

    protected WindowManager mWindowManager;

    @Rule
    public ActivityTestRule<Camera2SurfaceViewCtsActivity> mActivityRule =
            new ActivityTestRule<>(Camera2SurfaceViewCtsActivity.class);

    @Before
    public void setUp() throws Exception {
        super.setUp();
        mHandlerThread = new HandlerThread(TAG);
        mHandlerThread.start();
        mHandler = new Handler(mHandlerThread.getLooper());
        mCameraListener = new BlockingStateCallback();
        mCollector = new CameraErrorCollector();

        File filesDir = mContext.getPackageManager().isInstantApp()
                ? mContext.getFilesDir()
                : mContext.getExternalFilesDir(null);

        mDebugFileNameBase = filesDir.getPath();

        mAllStaticInfo = new HashMap<String, StaticMetadata>();
        List<String> hiddenPhysicalIds = new ArrayList<>();
        for (String cameraId : mCameraIdsUnderTest) {
            CameraCharacteristics props = mCameraManager.getCameraCharacteristics(cameraId);
            StaticMetadata staticMetadata = new StaticMetadata(props,
                    CheckLevel.ASSERT, /*collector*/null);
            mAllStaticInfo.put(cameraId, staticMetadata);

            for (String physicalId : props.getPhysicalCameraIds()) {
                if (!Arrays.asList(mCameraIdsUnderTest).contains(physicalId) &&
                        !hiddenPhysicalIds.contains(physicalId)) {
                    hiddenPhysicalIds.add(physicalId);
                    props = mCameraManager.getCameraCharacteristics(physicalId);
                    staticMetadata = new StaticMetadata(
                            mCameraManager.getCameraCharacteristics(physicalId),
                            CheckLevel.ASSERT, /*collector*/null);
                    mAllStaticInfo.put(physicalId, staticMetadata);
                }
            }
        }

        mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
    }

    @After
    public void tearDown() throws Exception {
        mHandlerThread.quitSafely();
        mHandler = null;
        mCameraListener = null;

        try {
            mCollector.verify();
        } catch (Throwable e) {
            // When new Exception(e) is used, exception info will be printed twice.
            throw new Exception(e.getMessage());
        }
        super.tearDown();
    }

    /**
     * Start camera preview by using the given request, preview size and capture
     * listener.
     * <p>
     * If preview is already started, calling this function will stop the
     * current preview stream and start a new preview stream with given
     * parameters. No need to call stopPreview between two startPreview calls.
     * </p>
     *
     * @param request The request builder used to start the preview.
     * @param previewSz The size of the camera device output preview stream.
     * @param listener The callbacks the camera device will notify when preview
     *            capture is available.
     */
    protected void startPreview(CaptureRequest.Builder request, Size previewSz,
            CaptureCallback listener) throws Exception {
        // Update preview size.
        updatePreviewSurface(previewSz);
        if (VERBOSE) {
            Log.v(TAG, ""start preview with size "" + mPreviewSize.toString());
        }

        configurePreviewOutput(request);

        mSession.setRepeatingRequest(request.build(), listener, mHandler);
    }

    /**
     * Configure the preview output stream.
     *
     * @param request The request to be configured with preview surface
     */
    protected void configurePreviewOutput(CaptureRequest.Builder request)
            throws CameraAccessException {
        List<Surface> outputSurfaces = new ArrayList<Surface>(/*capacity*/1);
        outputSurfaces.add(mPreviewSurface);
        mSessionListener = new BlockingSessionCallback();
        mSession = configureCameraSession(mCamera, outputSurfaces, mSessionListener, mHandler);

        request.addTarget(mPreviewSurface);
    }

    /**
     * Create a {@link CaptureRequest#Builder} and add the default preview surface.
     *
     * @return The {@link CaptureRequest#Builder} to be created
     * @throws CameraAccessException When create capture request from camera fails
     */
    protected CaptureRequest.Builder createRequestForPreview() throws CameraAccessException {
        if (mPreviewSurface == null) {
            throw new IllegalStateException(
                    ""Preview surface is not set yet, call updatePreviewSurface or startPreview""
                    + ""first to set the preview surface properly."");
        }
        CaptureRequest.Builder requestBuilder =
                mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
        requestBuilder.addTarget(mPreviewSurface);
        return requestBuilder;
    }

    /**
     * Stop preview for current camera device by closing the session.
     * Does _not_ wait for the device to go idle
     */
    protected void stopPreview() throws Exception {
        // Stop repeat, wait for captures to complete, and disconnect from surfaces
        if (mSession != null) {
            if (VERBOSE) Log.v(TAG, ""Stopping preview"");
            mSession.close();
        }
    }

    /**
     * Stop preview for current camera device by closing the session and waiting for it to close,
     * resulting in an idle device.
     */
    protected void stopPreviewAndDrain() throws Exception {
        // Stop repeat, wait for captures to complete, and disconnect from surfaces
        if (mSession != null) {
            if (VERBOSE) Log.v(TAG, ""Stopping preview and waiting for idle"");
            mSession.close();
            mSessionListener.getStateWaiter().waitForState(BlockingSessionCallback.SESSION_CLOSED,
                    /*timeoutMs*/WAIT_FOR_RESULT_TIMEOUT_MS);
        }
    }

    /**
     * Setup still (JPEG) capture configuration and start preview.
     * <p>
     * The default max number of image is set to image reader.
     * </p>
     *
     * @param previewRequest The capture request to be used for preview
     * @param stillRequest The capture request to be used for still capture
     * @param previewSz Preview size
     * @param stillSz The still capture size
     * @param resultListener Capture result listener
     * @param imageListener The still capture image listener
     */
    protected void prepareStillCaptureAndStartPreview(CaptureRequest.Builder previewRequest,
            CaptureRequest.Builder stillRequest, Size previewSz, Size stillSz,
            CaptureCallback resultListener,
            ImageReader.OnImageAvailableListener imageListener, boolean isHeic) throws Exception {
        prepareCaptureAndStartPreview(previewRequest, stillRequest, previewSz, stillSz,
                isHeic ? ImageFormat.HEIC : ImageFormat.JPEG, resultListener, MAX_READER_IMAGES,
                imageListener);
    }

    /**
     * Setup still (JPEG) capture configuration and start preview.
     *
     * @param previewRequest The capture request to be used for preview
     * @param stillRequest The capture request to be used for still capture
     * @param previewSz Preview size
     * @param stillSz The still capture size
     * @param resultListener Capture result listener
     * @param maxNumImages The max number of images set to the image reader
     * @param imageListener The still capture image listener
     */
    protected void prepareStillCaptureAndStartPreview(CaptureRequest.Builder previewRequest,
            CaptureRequest.Builder stillRequest, Size previewSz, Size stillSz,
            CaptureCallback resultListener, int maxNumImages,
            ImageReader.OnImageAvailableListener imageListener, boolean isHeic) throws Exception {
        prepareCaptureAndStartPreview(previewRequest, stillRequest, previewSz, stillSz,
                isHeic ? ImageFormat.HEIC : ImageFormat.JPEG, resultListener, maxNumImages, imageListener);
    }

    /**
     * Setup raw capture configuration and start preview.
     *
     * <p>
     * The default max number of image is set to image reader.
     * </p>
     *
     * @param previewRequest The capture request to be used for preview
     * @param rawRequest The capture request to be used for raw capture
     * @param previewSz Preview size
     * @param rawSz The raw capture size
     * @param resultListener Capture result listener
     * @param imageListener The raw capture image listener
     */
    protected void prepareRawCaptureAndStartPreview(CaptureRequest.Builder previewRequest,
            CaptureRequest.Builder rawRequest, Size previewSz, Size rawSz,
            CaptureCallback resultListener,
            ImageReader.OnImageAvailableListener imageListener) throws Exception {
        prepareCaptureAndStartPreview(previewRequest, rawRequest, previewSz, rawSz,
                ImageFormat.RAW_SENSOR, resultListener, MAX_READER_IMAGES, imageListener);
    }

    /**
     * Wait for expected result key value available in a certain number of results.
     *
     * <p>
     * Check the result immediately if numFramesWait is 0.
     * </p>
     *
     * @param listener The capture listener to get capture result
     * @param resultKey The capture result key associated with the result value
     * @param expectedValue The result value need to be waited for
     * @param numResultsWait Number of frame to wait before times out
     * @throws TimeoutRuntimeException If more than numResultsWait results are
     * seen before the result matching myRequest arrives, or each individual wait
     * for result times out after {@value #WAIT_FOR_RESULT_TIMEOUT_MS}ms.
     */
    protected static <T> void waitForResultValue(SimpleCaptureCallback listener,
            CaptureResult.Key<T> resultKey,
            T expectedValue, int numResultsWait) {
        CameraTestUtils.waitForResultValue(listener, resultKey, expectedValue,
                numResultsWait, WAIT_FOR_RESULT_TIMEOUT_MS);
    }

    /**
     * Wait for any expected result key values available in a certain number of results.
     *
     * <p>
     * Check the result immediately if numFramesWait is 0.
     * </p>
     *
     * @param listener The capture listener to get capture result.
     * @param resultKey The capture result key associated with the result value.
     * @param expectedValues The list of result value need to be waited for,
     * return immediately if the list is empty.
     * @param numResultsWait Number of frame to wait before times out.
     * @throws TimeoutRuntimeException If more than numResultsWait results are.
     * seen before the result matching myRequest arrives, or each individual wait
     * for result times out after {@value #WAIT_FOR_RESULT_TIMEOUT_MS}ms.
     */
    protected static <T> void waitForAnyResultValue(SimpleCaptureCallback listener,
            CaptureResult.Key<T> resultKey,
            List<T> expectedValues, int numResultsWait) {
        CameraTestUtils.waitForAnyResultValue(listener, resultKey, expectedValues, numResultsWait,
                WAIT_FOR_RESULT_TIMEOUT_MS);
    }

    /**
     * Submit a burst of the same capture request, then submit additional captures in order to
     * ensure that the camera will be synchronized.
     *
     * <p>
     * The additional capture count is determined by android.sync.maxLatency (or
     * a fixed {@value #NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY}) captures if maxLatency is unknown).
     * </p>
     *
     * <p>Returns the number of captures that were submitted (at least 1), which is useful
     * with {@link #waitForNumResults}.</p>
     *
     * @param request capture request to forward to {@link CameraDevice#capture}
     * @param listener request listener to forward to {@link CameraDevice#capture}
     * @param handler handler to forward to {@link CameraDevice#capture}
     *
     * @return the number of captures that were submitted
     *
     * @throws CameraAccessException if capturing failed
     */
    protected int captureRequestsSynchronizedBurst(
            CaptureRequest request, int count, CaptureCallback listener, Handler handler)
                    throws CameraAccessException {
        return captureRequestsSynchronizedImpl(request, count, listener, handler, true);
    }
    /**
     * Submit a capture once, then submit additional captures in order to ensure that
     * the camera will be synchronized.
     *
     * <p>
     * The additional capture count is determined by android.sync.maxLatency (or
     * a fixed {@value #NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY}) captures if maxLatency is unknown).
     * </p>
     *
     * <p>Returns the number of captures that were submitted (at least 1), which is useful
     * with {@link #waitForNumResults}.</p>
     *
     * @param request capture request to forward to {@link CameraDevice#capture}
     * @param listener request listener to forward to {@link CameraDevice#capture}
     * @param handler handler to forward to {@link CameraDevice#capture}
     *
     * @return the number of captures that were submitted
     *
     * @throws CameraAccessException if capturing failed
     */
    protected int captureRequestsSynchronized(
            CaptureRequest request, CaptureCallback listener, Handler handler)
                    throws CameraAccessException {
        return captureRequestsSynchronizedImpl(request, /*count*/1, listener, handler, false);
    }

    /**
     * Submit a capture {@code count} times, then submit additional captures in order to ensure that
     * the camera will be synchronized.
     *
     * <p>
     * The additional capture count is determined by android.sync.maxLatency (or
     * a fixed {@value #NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY}) captures if maxLatency is unknown).
     * </p>
     *
     * <p>Returns the number of captures that were submitted (at least 1), which is useful
     * with {@link #waitForNumResults}.</p>
     *
     * @param request capture request to forward to {@link CameraDevice#capture}
     * @param count the number of times to submit the request (minimally), must be at least 1
     * @param listener request listener to forward to {@link CameraDevice#capture}
     * @param handler handler to forward to {@link CameraDevice#capture}
     *
     * @return the number of captures that were submitted
     *
     * @throws IllegalArgumentException if {@code count} was not at least 1
     * @throws CameraAccessException if capturing failed
     */
    protected int captureRequestsSynchronized(
            CaptureRequest request, int count, CaptureCallback listener, Handler handler)
                    throws CameraAccessException {
        return captureRequestsSynchronizedImpl(request, count, listener, handler, false);
    }

    /**
     * Wait for numResultWait frames
     *
     * @param resultListener The capture listener to get capture result back.
     * @param numResultsWait Number of frame to wait
     *
     * @return the last result, or {@code null} if there was none
     */
    protected static CaptureResult waitForNumResults(SimpleCaptureCallback resultListener,
            int numResultsWait) {
        return CameraTestUtils.waitForNumResults(resultListener, numResultsWait,
                WAIT_FOR_RESULT_TIMEOUT_MS);
    }

    /**
     * Wait for enough results for settings to be applied
     *
     * @param resultListener The capture listener to get capture result back.
     * @param numResultWaitForUnknownLatency Number of frame to wait if camera device latency is
     *                                       unknown.
     */
    protected void waitForSettingsApplied(SimpleCaptureCallback resultListener,
            int numResultWaitForUnknownLatency) {
        int maxLatency = mStaticInfo.getSyncMaxLatency();
        if (maxLatency == CameraMetadata.SYNC_MAX_LATENCY_UNKNOWN) {
            maxLatency = numResultWaitForUnknownLatency;
        }
        // Wait for settings to take effect
        waitForNumResults(resultListener, maxLatency);
    }

    /**
     * Wait for AE to be stabilized before capture: CONVERGED or FLASH_REQUIRED.
     *
     * <p>Waits for {@code android.sync.maxLatency} number of results first, to make sure
     * that the result is synchronized (or {@code numResultWaitForUnknownLatency} if the latency
     * is unknown.</p>
     *
     * <p>This is a no-op for {@code LEGACY} devices since they don't report
     * the {@code aeState} result.</p>
     *
     * @param resultListener The capture listener to get capture result back.
     * @param numResultWaitForUnknownLatency Number of frame to wait if camera device latency is
     *                                       unknown.
     */
    protected void waitForAeStable(SimpleCaptureCallback resultListener,
            int numResultWaitForUnknownLatency) {
        CameraTestUtils.waitForAeStable(resultListener, NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY,
                mStaticInfo, WAIT_FOR_RESULT_TIMEOUT_MS, NUM_RESULTS_WAIT_TIMEOUT);
    }

    /**
     * Wait for AE to be: LOCKED
     *
     * <p>Waits for {@code android.sync.maxLatency} number of results first, to make sure
     * that the result is synchronized (or {@code numResultWaitForUnknownLatency} if the latency
     * is unknown.</p>
     *
     * <p>This is a no-op for {@code LEGACY} devices since they don't report
     * the {@code aeState} result.</p>
     *
     * @param resultListener The capture listener to get capture result back.
     * @param numResultWaitForUnknownLatency Number of frame to wait if camera device latency is
     *                                       unknown.
     */
    protected void waitForAeLocked(SimpleCaptureCallback resultListener,
            int numResultWaitForUnknownLatency) {

        waitForSettingsApplied(resultListener, numResultWaitForUnknownLatency);

        if (!mStaticInfo.isHardwareLevelAtLeastLimited()) {
            // No-op for legacy devices
            return;
        }

        List<Integer> expectedAeStates = new ArrayList<Integer>();
        expectedAeStates.add(new Integer(CaptureResult.CONTROL_AE_STATE_LOCKED));
        CameraTestUtils.waitForAnyResultValue(resultListener, CaptureResult.CONTROL_AE_STATE,
                expectedAeStates, NUM_RESULTS_WAIT_TIMEOUT, WAIT_FOR_RESULT_TIMEOUT_MS);
    }

    /**
     * Create an {@link ImageReader} object and get the surface.
     *
     * @param size The size of this ImageReader to be created.
     * @param format The format of this ImageReader to be created
     * @param maxNumImages The max number of images that can be acquired simultaneously.
     * @param listener The listener used by this ImageReader to notify callbacks.
     */
    protected void createImageReader(Size size, int format, int maxNumImages,
            ImageReader.OnImageAvailableListener listener) throws Exception {
        closeImageReader();

        ImageReader r = makeImageReader(size, format, maxNumImages, listener,
                mHandler);
        mReader = r;
        mReaderSurface = r.getSurface();
    }

    /**
     * Close the pending images then close current active {@link ImageReader} object.
     */
    protected void closeImageReader() {
        CameraTestUtils.closeImageReader(mReader);
        mReader = null;
        mReaderSurface = null;
    }

    /**
     * Close the pending images then close current active {@link ImageReader} objects.
     */
    protected void closeImageReaders(ImageReader[] readers) {
        CameraTestUtils.closeImageReaders(readers);
    }

    /**
     * Setup still capture configuration and start preview.
     *
     * @param previewRequest The capture request to be used for preview
     * @param stillRequest The capture request to be used for still capture
     * @param previewSz Preview size
     * @param captureSizes Still capture sizes
     * @param formats The single capture image formats
     * @param resultListener Capture result listener
     * @param maxNumImages The max number of images set to the image reader
     * @param imageListeners The single capture capture image listeners
     * @param isHeic HEIC still capture if true, JPEG still capture if false
     */
    protected ImageReader[] prepareStillCaptureAndStartPreview(
            CaptureRequest.Builder previewRequest, CaptureRequest.Builder stillRequest,
            Size previewSz, Size[] captureSizes, int[] formats, CaptureCallback resultListener,
            int maxNumImages, ImageReader.OnImageAvailableListener[] imageListeners,
            boolean isHeic)
            throws Exception {

        if ((captureSizes == null) || (formats == null) || (imageListeners == null) &&
                (captureSizes.length != formats.length) ||
                (formats.length != imageListeners.length)) {
            throw new IllegalArgumentException(""Invalid capture sizes/formats or image listeners!"");
        }

        if (VERBOSE) {
            Log.v(TAG, String.format(""Prepare still capture and preview (%s)"",
                    previewSz.toString()));
        }

        // Update preview size.
        updatePreviewSurface(previewSz);

        ImageReader[] readers = new ImageReader[captureSizes.length];
        List<Surface> outputSurfaces = new ArrayList<Surface>();
        outputSurfaces.add(mPreviewSurface);
        for (int i = 0; i < captureSizes.length; i++) {
            readers[i] = makeImageReader(captureSizes[i], formats[i], maxNumImages,
                    imageListeners[i], mHandler);
            outputSurfaces.add(readers[i].getSurface());
        }

        mSessionListener = new BlockingSessionCallback();
        mSession = configureCameraSession(mCamera, outputSurfaces, mSessionListener, mHandler);

        // Configure the requests.
        previewRequest.addTarget(mPreviewSurface);
        stillRequest.addTarget(mPreviewSurface);
        for (int i = 0; i < readers.length; i++) {
            stillRequest.addTarget(readers[i].getSurface());
        }

        // Start preview.
        mSession.setRepeatingRequest(previewRequest.build(), resultListener, mHandler);

        return readers;
    }

    /**
     * Open a camera device and get the StaticMetadata for a given camera id.
     *
     * @param cameraId The id of the camera device to be opened.
     */
    protected void openDevice(String cameraId) throws Exception {
        mCamera = CameraTestUtils.openCamera(
                mCameraManager, cameraId, mCameraListener, mHandler);
        mCollector.setCameraId(cameraId);
        mStaticInfo = new StaticMetadata(mCameraManager.getCameraCharacteristics(cameraId),
                CheckLevel.ASSERT, /*collector*/null);
        if (mStaticInfo.isColorOutputSupported()) {
            mOrderedPreviewSizes = getSupportedPreviewSizes(cameraId, mCameraManager,
                    getPreviewSizeBound(mWindowManager, PREVIEW_SIZE_BOUND));
            m1080pBoundedOrderedPreviewSizes = getSupportedPreviewSizes(cameraId, mCameraManager,
                    PREVIEW_SIZE_BOUND);
            mOrderedVideoSizes = getSupportedVideoSizes(cameraId, mCameraManager, PREVIEW_SIZE_BOUND);
            mOrderedStillSizes = getSupportedStillSizes(cameraId, mCameraManager, null);
            // Use ImageFormat.YUV_420_888 for now. TODO: need figure out what's format for preview
            // in public API side.
            mMinPreviewFrameDurationMap =
                mStaticInfo.getAvailableMinFrameDurationsForFormatChecked(ImageFormat.YUV_420_888);
        }
    }

    /**
     * Close the current actively used camera device.
     */
    protected void closeDevice() {
        if (mCamera != null) {
            mCamera.close();
            mCameraListener.waitForState(STATE_CLOSED, CAMERA_CLOSE_TIMEOUT_MS);
            mCamera = null;
            mSession = null;
            mSessionListener = null;
            mStaticInfo = null;
            mOrderedPreviewSizes = null;
            mOrderedVideoSizes = null;
            mOrderedStillSizes = null;
        }
    }

    /**
     * Update the preview surface size.
     *
     * @param size The preview size to be updated.
     */
    protected void updatePreviewSurface(Size size) {
        if (size.equals(mPreviewSize) && mPreviewSurface != null) {
            Log.w(TAG, ""Skipping update preview surface size..."");
            return;
        }

        mPreviewSize = size;
        Camera2SurfaceViewCtsActivity ctsActivity = mActivityRule.getActivity();
        final SurfaceHolder holder = ctsActivity.getSurfaceView().getHolder();
        Handler handler = new Handler(Looper.getMainLooper());
        handler.post(new Runnable() {
            @Override
            public void run() {
                holder.setFixedSize(mPreviewSize.getWidth(), mPreviewSize.getHeight());
            }
        });

        boolean res = ctsActivity.waitForSurfaceSizeChanged(
                WAIT_FOR_SURFACE_CHANGE_TIMEOUT_MS, mPreviewSize.getWidth(),
                mPreviewSize.getHeight());
        assertTrue(""wait for surface change to "" + mPreviewSize.toString() + "" timed out"", res);
        mPreviewHolder = holder;
        mPreviewSurface = holder.getSurface();
        assertNotNull(""Preview surface is null"", mPreviewSurface);
        assertTrue(""Preview surface is invalid"", mPreviewSurface.isValid());
    }

    /**
     * Recreate the SurfaceView's Surface
     *
     * Hide and unhide the activity's preview SurfaceView, so that its backing Surface is
     * recreated
     */
    protected void recreatePreviewSurface() {
        Camera2SurfaceViewCtsActivity ctsActivity = mActivityRule.getActivity();
        setPreviewVisibility(View.GONE);
        boolean res = ctsActivity.waitForSurfaceState(
            WAIT_FOR_SURFACE_CHANGE_TIMEOUT_MS, /*valid*/ false);
        assertTrue(""wait for surface destroyed timed out"", res);
        setPreviewVisibility(View.VISIBLE);
        res = ctsActivity.waitForSurfaceState(
            WAIT_FOR_SURFACE_CHANGE_TIMEOUT_MS, /*valid*/ true);
        assertTrue(""wait for surface created timed out"", res);
    }

    /**
     * Show/hide the preview SurfaceView.
     *
     * If set to View.GONE, the surfaceDestroyed callback will fire
     * @param visibility the new new visibility to set, one of View.VISIBLE / INVISIBLE / GONE
     */
    protected void setPreviewVisibility(int visibility) {
        final Camera2SurfaceViewCtsActivity ctsActivity = mActivityRule.getActivity();
        Handler handler = new Handler(Looper.getMainLooper());
        handler.post(new Runnable() {
            @Override
            public void run() {
                ctsActivity.getSurfaceView().setVisibility(visibility);
            }
        });
    }

    /**
     * Setup single capture configuration and start preview.
     *
     * @param previewRequest The capture request to be used for preview
     * @param stillRequest The capture request to be used for still capture
     * @param previewSz Preview size
     * @param captureSz Still capture size
     * @param format The single capture image format
     * @param resultListener Capture result listener
     * @param maxNumImages The max number of images set to the image reader
     * @param imageListener The single capture capture image listener
     */
    protected void prepareCaptureAndStartPreview(CaptureRequest.Builder previewRequest,
            CaptureRequest.Builder stillRequest, Size previewSz, Size captureSz, int format,
            CaptureCallback resultListener, int maxNumImages,
            ImageReader.OnImageAvailableListener imageListener) throws Exception {
        prepareCaptureAndStartPreview(previewRequest, stillRequest, previewSz, captureSz,
            format, resultListener, null, maxNumImages, imageListener);
    }

    /**
     * Setup single capture configuration and start preview.
     *
     * @param previewRequest The capture request to be used for preview
     * @param stillRequest The capture request to be used for still capture
     * @param previewSz Preview size
     * @param captureSz Still capture size
     * @param format The single capture image format
     * @param resultListener Capture result listener
     * @param sessionListener Session listener
     * @param maxNumImages The max number of images set to the image reader
     * @param imageListener The single capture capture image listener
     */
    protected void prepareCaptureAndStartPreview(CaptureRequest.Builder previewRequest,
            CaptureRequest.Builder stillRequest, Size previewSz, Size captureSz, int format,
            CaptureCallback resultListener, CameraCaptureSession.StateCallback sessionListener,
            int maxNumImages, ImageReader.OnImageAvailableListener imageListener) throws Exception {
        if (VERBOSE) {
            Log.v(TAG, String.format(""Prepare single capture (%s) and preview (%s)"",
                    captureSz.toString(), previewSz.toString()));
        }

        // Update preview size.
        updatePreviewSurface(previewSz);

        // Create ImageReader.
        createImageReader(captureSz, format, maxNumImages, imageListener);

        // Configure output streams with preview and jpeg streams.
        List<Surface> outputSurfaces = new ArrayList<Surface>();
        outputSurfaces.add(mPreviewSurface);
        outputSurfaces.add(mReaderSurface);
        if (sessionListener == null) {
            mSessionListener = new BlockingSessionCallback();
        } else {
            mSessionListener = new BlockingSessionCallback(sessionListener);
        }
        mSession = configureCameraSession(mCamera, outputSurfaces, mSessionListener, mHandler);

        // Configure the requests.
        previewRequest.addTarget(mPreviewSurface);
        stillRequest.addTarget(mPreviewSurface);
        stillRequest.addTarget(mReaderSurface);

        // Start preview.
        mSession.setRepeatingRequest(previewRequest.build(), resultListener, mHandler);
    }

    /**
     * Get the max preview size that supports the given fpsRange.
     *
     * @param fpsRange The fps range the returned size must support.
     * @return max size that support the given fps range.
     */
    protected Size getMaxPreviewSizeForFpsRange(Range<Integer> fpsRange) {
        if (fpsRange == null || fpsRange.getLower() <= 0 || fpsRange.getUpper() <= 0) {
            throw new IllegalArgumentException(""Invalid fps range argument"");
        }
        if (mOrderedPreviewSizes == null || mMinPreviewFrameDurationMap == null) {
            throw new IllegalStateException(""mOrderedPreviewSizes and mMinPreviewFrameDurationMap""
                    + "" must be initialized"");
        }

        long[] frameDurationRange =
                new long[]{(long) (1e9 / fpsRange.getUpper()), (long) (1e9 / fpsRange.getLower())};
        for (Size size : mOrderedPreviewSizes) {
            Long minDuration = mMinPreviewFrameDurationMap.get(size);
            if (minDuration == null ||
                    minDuration == 0) {
                if (mStaticInfo.isCapabilitySupported(
                        CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR)) {
                    throw new IllegalArgumentException(
                            ""No min frame duration available for the size "" + size);
                }
                continue;
            }
            if (minDuration <= (frameDurationRange[0] + MIN_FRAME_DURATION_ERROR_MARGIN)) {
                return size;
            }
        }

        // Search again for sizes not bounded by display size
        for (Size size : m1080pBoundedOrderedPreviewSizes) {
            Long minDuration = mMinPreviewFrameDurationMap.get(size);
            if (minDuration == null ||
                    minDuration == 0) {
                if (mStaticInfo.isCapabilitySupported(
                        CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR)) {
                    throw new IllegalArgumentException(
                            ""No min frame duration available for the size "" + size);
                }
                continue;
            }
            if (minDuration <= (frameDurationRange[0] + MIN_FRAME_DURATION_ERROR_MARGIN)) {
                return size;
            }
        }
        return null;
    }

    protected boolean isReprocessSupported(String cameraId, int format)
            throws CameraAccessException {
        if (format != ImageFormat.YUV_420_888 && format != ImageFormat.PRIVATE) {
            throw new IllegalArgumentException(
                    ""format "" + format + "" is not supported for reprocessing"");
        }

        StaticMetadata info =
                new StaticMetadata(mCameraManager.getCameraCharacteristics(cameraId),
                                   CheckLevel.ASSERT, /*collector*/ null);
        int cap = CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_YUV_REPROCESSING;
        if (format == ImageFormat.PRIVATE) {
            cap = CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING;
        }
        return info.isCapabilitySupported(cap);
    }

    protected Range<Integer> getSuitableFpsRangeForDuration(String cameraId, long frameDuration) {
        return CameraTestUtils.getSuitableFpsRangeForDuration(cameraId, frameDuration, mStaticInfo);
    }

    private int captureRequestsSynchronizedImpl(
            CaptureRequest request, int count, CaptureCallback listener, Handler handler,
            boolean isBurst) throws CameraAccessException {
        if (count < 1) {
            throw new IllegalArgumentException(""count must be positive"");
        }

        int maxLatency = mStaticInfo.getSyncMaxLatency();
        if (maxLatency == CameraMetadata.SYNC_MAX_LATENCY_UNKNOWN) {
            maxLatency = NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY;
        }

        assertTrue(""maxLatency is non-negative"", maxLatency >= 0);

        int numCaptures = maxLatency + count;
        ArrayList<CaptureRequest> burstCaptureRequests = new ArrayList<>();
        for (int i = 0; i < numCaptures; ++i) {
            if (isBurst) {
                burstCaptureRequests.add(request);
            } else {
                mSession.capture(request, listener, handler);
            }
        }
        if (isBurst) {
            mSession.captureBurst(burstCaptureRequests, listener, handler);
        }

        return numCaptures;
    }
}"	"/home/gpoor/cts-12-source/cts/tests/camera/src/android/hardware/camera2/cts/testcases/Camera2SurfaceViewTestCase.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.location.cts.gnss.asn1.supl2.ver2_ulp_components.SupportedWLANApsChannel11"	"isTagImplicit"	"CtsLocationGnssTestCases"	"1: ui"	"public void test/*
 *.
 */

package android.location.cts.asn1.supl2.ver2_ulp_components;

/*
 */


//
//
import android.location.cts.asn1.base.Asn1Boolean;
import android.location.cts.asn1.base.Asn1Null;
import android.location.cts.asn1.base.Asn1Object;
import android.location.cts.asn1.base.Asn1Sequence;
import android.location.cts.asn1.base.Asn1Tag;
import android.location.cts.asn1.base.BitStream;
import android.location.cts.asn1.base.BitStreamReader;
import android.location.cts.asn1.base.SequenceComponent;
import com.google.common.collect.ImmutableList;
import java.util.Collection;
import javax.annotation.Nullable;


/**
*/
public  class SupportedWLANApsChannel11a extends Asn1Sequence {
  //

  private static final Asn1Tag TAG_SupportedWLANApsChannel11a
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public SupportedWLANApsChannel11a() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_SupportedWLANApsChannel11a;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_SupportedWLANApsChannel11a != null) {
      return ImmutableList.of(TAG_SupportedWLANApsChannel11a);
    } else {
      return Asn1Sequence.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new SupportedWLANApsChannel11a from encoded stream.
   */
  public static SupportedWLANApsChannel11a fromPerUnaligned(byte[] encodedBytes) {
    SupportedWLANApsChannel11a result = new SupportedWLANApsChannel11a();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new SupportedWLANApsChannel11a from encoded stream.
   */
  public static SupportedWLANApsChannel11a fromPerAligned(byte[] encodedBytes) {
    SupportedWLANApsChannel11a result = new SupportedWLANApsChannel11a();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }



  @Override protected boolean isExtensible() {
    return false;
  }

  @Override public boolean containsExtensionValues() {
    for (SequenceComponent extensionComponent : getExtensionComponents()) {
      if (extensionComponent.isExplicitlySet()) return true;
    }
    return false;
  }

  
  private SupportedWLANApsChannel11a.ch34Type ch34_;
  public SupportedWLANApsChannel11a.ch34Type getCh34() {
    return ch34_;
  }
  /**
   * @throws ClassCastException if value is not a SupportedWLANApsChannel11a.ch34Type
   */
  public void setCh34(Asn1Object value) {
    this.ch34_ = (SupportedWLANApsChannel11a.ch34Type) value;
  }
  public SupportedWLANApsChannel11a.ch34Type setCh34ToNewInstance() {
    ch34_ = new SupportedWLANApsChannel11a.ch34Type();
    return ch34_;
  }
  
  private SupportedWLANApsChannel11a.ch36Type ch36_;
  public SupportedWLANApsChannel11a.ch36Type getCh36() {
    return ch36_;
  }
  /**
   * @throws ClassCastException if value is not a SupportedWLANApsChannel11a.ch36Type
   */
  public void setCh36(Asn1Object value) {
    this.ch36_ = (SupportedWLANApsChannel11a.ch36Type) value;
  }
  public SupportedWLANApsChannel11a.ch36Type setCh36ToNewInstance() {
    ch36_ = new SupportedWLANApsChannel11a.ch36Type();
    return ch36_;
  }
  
  private SupportedWLANApsChannel11a.ch38Type ch38_;
  public SupportedWLANApsChannel11a.ch38Type getCh38() {
    return ch38_;
  }
  /**
   * @throws ClassCastException if value is not a SupportedWLANApsChannel11a.ch38Type
   */
  public void setCh38(Asn1Object value) {
    this.ch38_ = (SupportedWLANApsChannel11a.ch38Type) value;
  }
  public SupportedWLANApsChannel11a.ch38Type setCh38ToNewInstance() {
    ch38_ = new SupportedWLANApsChannel11a.ch38Type();
    return ch38_;
  }
  
  private SupportedWLANApsChannel11a.ch40Type ch40_;
  public SupportedWLANApsChannel11a.ch40Type getCh40() {
    return ch40_;
  }
  /**
   * @throws ClassCastException if value is not a SupportedWLANApsChannel11a.ch40Type
   */
  public void setCh40(Asn1Object value) {
    this.ch40_ = (SupportedWLANApsChannel11a.ch40Type) value;
  }
  public SupportedWLANApsChannel11a.ch40Type setCh40ToNewInstance() {
    ch40_ = new SupportedWLANApsChannel11a.ch40Type();
    return ch40_;
  }
  
  private SupportedWLANApsChannel11a.ch42Type ch42_;
  public SupportedWLANApsChannel11a.ch42Type getCh42() {
    return ch42_;
  }
  /**
   * @throws ClassCastException if value is not a SupportedWLANApsChannel11a.ch42Type
   */
  public void setCh42(Asn1Object value) {
    this.ch42_ = (SupportedWLANApsChannel11a.ch42Type) value;
  }
  public SupportedWLANApsChannel11a.ch42Type setCh42ToNewInstance() {
    ch42_ = new SupportedWLANApsChannel11a.ch42Type();
    return ch42_;
  }
  
  private SupportedWLANApsChannel11a.ch44Type ch44_;
  public SupportedWLANApsChannel11a.ch44Type getCh44() {
    return ch44_;
  }
  /**
   * @throws ClassCastException if value is not a SupportedWLANApsChannel11a.ch44Type
   */
  public void setCh44(Asn1Object value) {
    this.ch44_ = (SupportedWLANApsChannel11a.ch44Type) value;
  }
  public SupportedWLANApsChannel11a.ch44Type setCh44ToNewInstance() {
    ch44_ = new SupportedWLANApsChannel11a.ch44Type();
    return ch44_;
  }
  
  private SupportedWLANApsChannel11a.ch46Type ch46_;
  public SupportedWLANApsChannel11a.ch46Type getCh46() {
    return ch46_;
  }
  /**
   * @throws ClassCastException if value is not a SupportedWLANApsChannel11a.ch46Type
   */
  public void setCh46(Asn1Object value) {
    this.ch46_ = (SupportedWLANApsChannel11a.ch46Type) value;
  }
  public SupportedWLANApsChannel11a.ch46Type setCh46ToNewInstance() {
    ch46_ = new SupportedWLANApsChannel11a.ch46Type();
    return ch46_;
  }
  
  private SupportedWLANApsChannel11a.ch48Type ch48_;
  public SupportedWLANApsChannel11a.ch48Type getCh48() {
    return ch48_;
  }
  /**
   * @throws ClassCastException if value is not a SupportedWLANApsChannel11a.ch48Type
   */
  public void setCh48(Asn1Object value) {
    this.ch48_ = (SupportedWLANApsChannel11a.ch48Type) value;
  }
  public SupportedWLANApsChannel11a.ch48Type setCh48ToNewInstance() {
    ch48_ = new SupportedWLANApsChannel11a.ch48Type();
    return ch48_;
  }
  
  private SupportedWLANApsChannel11a.ch52Type ch52_;
  public SupportedWLANApsChannel11a.ch52Type getCh52() {
    return ch52_;
  }
  /**
   * @throws ClassCastException if value is not a SupportedWLANApsChannel11a.ch52Type
   */
  public void setCh52(Asn1Object value) {
    this.ch52_ = (SupportedWLANApsChannel11a.ch52Type) value;
  }
  public SupportedWLANApsChannel11a.ch52Type setCh52ToNewInstance() {
    ch52_ = new SupportedWLANApsChannel11a.ch52Type();
    return ch52_;
  }
  
  private SupportedWLANApsChannel11a.ch56Type ch56_;
  public SupportedWLANApsChannel11a.ch56Type getCh56() {
    return ch56_;
  }
  /**
   * @throws ClassCastException if value is not a SupportedWLANApsChannel11a.ch56Type
   */
  public void setCh56(Asn1Object value) {
    this.ch56_ = (SupportedWLANApsChannel11a.ch56Type) value;
  }
  public SupportedWLANApsChannel11a.ch56Type setCh56ToNewInstance() {
    ch56_ = new SupportedWLANApsChannel11a.ch56Type();
    return ch56_;
  }
  
  private SupportedWLANApsChannel11a.ch60Type ch60_;
  public SupportedWLANApsChannel11a.ch60Type getCh60() {
    return ch60_;
  }
  /**
   * @throws ClassCastException if value is not a SupportedWLANApsChannel11a.ch60Type
   */
  public void setCh60(Asn1Object value) {
    this.ch60_ = (SupportedWLANApsChannel11a.ch60Type) value;
  }
  public SupportedWLANApsChannel11a.ch60Type setCh60ToNewInstance() {
    ch60_ = new SupportedWLANApsChannel11a.ch60Type();
    return ch60_;
  }
  
  private SupportedWLANApsChannel11a.ch64Type ch64_;
  public SupportedWLANApsChannel11a.ch64Type getCh64() {
    return ch64_;
  }
  /**
   * @throws ClassCastException if value is not a SupportedWLANApsChannel11a.ch64Type
   */
  public void setCh64(Asn1Object value) {
    this.ch64_ = (SupportedWLANApsChannel11a.ch64Type) value;
  }
  public SupportedWLANApsChannel11a.ch64Type setCh64ToNewInstance() {
    ch64_ = new SupportedWLANApsChannel11a.ch64Type();
    return ch64_;
  }
  
  private SupportedWLANApsChannel11a.ch149Type ch149_;
  public SupportedWLANApsChannel11a.ch149Type getCh149() {
    return ch149_;
  }
  /**
   * @throws ClassCastException if value is not a SupportedWLANApsChannel11a.ch149Type
   */
  public void setCh149(Asn1Object value) {
    this.ch149_ = (SupportedWLANApsChannel11a.ch149Type) value;
  }
  public SupportedWLANApsChannel11a.ch149Type setCh149ToNewInstance() {
    ch149_ = new SupportedWLANApsChannel11a.ch149Type();
    return ch149_;
  }
  
  private SupportedWLANApsChannel11a.ch153Type ch153_;
  public SupportedWLANApsChannel11a.ch153Type getCh153() {
    return ch153_;
  }
  /**
   * @throws ClassCastException if value is not a SupportedWLANApsChannel11a.ch153Type
   */
  public void setCh153(Asn1Object value) {
    this.ch153_ = (SupportedWLANApsChannel11a.ch153Type) value;
  }
  public SupportedWLANApsChannel11a.ch153Type setCh153ToNewInstance() {
    ch153_ = new SupportedWLANApsChannel11a.ch153Type();
    return ch153_;
  }
  
  private SupportedWLANApsChannel11a.ch157Type ch157_;
  public SupportedWLANApsChannel11a.ch157Type getCh157() {
    return ch157_;
  }
  /**
   * @throws ClassCastException if value is not a SupportedWLANApsChannel11a.ch157Type
   */
  public void setCh157(Asn1Object value) {
    this.ch157_ = (SupportedWLANApsChannel11a.ch157Type) value;
  }
  public SupportedWLANApsChannel11a.ch157Type setCh157ToNewInstance() {
    ch157_ = new SupportedWLANApsChannel11a.ch157Type();
    return ch157_;
  }
  
  private SupportedWLANApsChannel11a.ch161Type ch161_;
  public SupportedWLANApsChannel11a.ch161Type getCh161() {
    return ch161_;
  }
  /**
   * @throws ClassCastException if value is not a SupportedWLANApsChannel11a.ch161Type
   */
  public void setCh161(Asn1Object value) {
    this.ch161_ = (SupportedWLANApsChannel11a.ch161Type) value;
  }
  public SupportedWLANApsChannel11a.ch161Type setCh161ToNewInstance() {
    ch161_ = new SupportedWLANApsChannel11a.ch161Type();
    return ch161_;
  }
  

  

  

  @Override public Iterable<? extends SequenceComponent> getComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 0);

          @Override public boolean isExplicitlySet() {
            return getCh34() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getCh34();
          }

          @Override public void setToNewInstance() {
            setCh34ToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SupportedWLANApsChannel11a.ch34Type.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""ch34 : ""
                    + getCh34().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 1);

          @Override public boolean isExplicitlySet() {
            return getCh36() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getCh36();
          }

          @Override public void setToNewInstance() {
            setCh36ToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SupportedWLANApsChannel11a.ch36Type.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""ch36 : ""
                    + getCh36().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 2);

          @Override public boolean isExplicitlySet() {
            return getCh38() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getCh38();
          }

          @Override public void setToNewInstance() {
            setCh38ToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SupportedWLANApsChannel11a.ch38Type.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""ch38 : ""
                    + getCh38().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 3);

          @Override public boolean isExplicitlySet() {
            return getCh40() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getCh40();
          }

          @Override public void setToNewInstance() {
            setCh40ToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SupportedWLANApsChannel11a.ch40Type.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""ch40 : ""
                    + getCh40().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 4);

          @Override public boolean isExplicitlySet() {
            return getCh42() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getCh42();
          }

          @Override public void setToNewInstance() {
            setCh42ToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SupportedWLANApsChannel11a.ch42Type.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""ch42 : ""
                    + getCh42().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 5);

          @Override public boolean isExplicitlySet() {
            return getCh44() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getCh44();
          }

          @Override public void setToNewInstance() {
            setCh44ToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SupportedWLANApsChannel11a.ch44Type.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""ch44 : ""
                    + getCh44().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 6);

          @Override public boolean isExplicitlySet() {
            return getCh46() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getCh46();
          }

          @Override public void setToNewInstance() {
            setCh46ToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SupportedWLANApsChannel11a.ch46Type.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""ch46 : ""
                    + getCh46().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 7);

          @Override public boolean isExplicitlySet() {
            return getCh48() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getCh48();
          }

          @Override public void setToNewInstance() {
            setCh48ToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SupportedWLANApsChannel11a.ch48Type.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""ch48 : ""
                    + getCh48().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 8);

          @Override public boolean isExplicitlySet() {
            return getCh52() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getCh52();
          }

          @Override public void setToNewInstance() {
            setCh52ToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SupportedWLANApsChannel11a.ch52Type.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""ch52 : ""
                    + getCh52().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 9);

          @Override public boolean isExplicitlySet() {
            return getCh56() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getCh56();
          }

          @Override public void setToNewInstance() {
            setCh56ToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SupportedWLANApsChannel11a.ch56Type.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""ch56 : ""
                    + getCh56().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 10);

          @Override public boolean isExplicitlySet() {
            return getCh60() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getCh60();
          }

          @Override public void setToNewInstance() {
            setCh60ToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SupportedWLANApsChannel11a.ch60Type.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""ch60 : ""
                    + getCh60().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 11);

          @Override public boolean isExplicitlySet() {
            return getCh64() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getCh64();
          }

          @Override public void setToNewInstance() {
            setCh64ToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SupportedWLANApsChannel11a.ch64Type.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""ch64 : ""
                    + getCh64().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 12);

          @Override public boolean isExplicitlySet() {
            return getCh149() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getCh149();
          }

          @Override public void setToNewInstance() {
            setCh149ToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SupportedWLANApsChannel11a.ch149Type.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""ch149 : ""
                    + getCh149().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 13);

          @Override public boolean isExplicitlySet() {
            return getCh153() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getCh153();
          }

          @Override public void setToNewInstance() {
            setCh153ToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SupportedWLANApsChannel11a.ch153Type.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""ch153 : ""
                    + getCh153().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 14);

          @Override public boolean isExplicitlySet() {
            return getCh157() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getCh157();
          }

          @Override public void setToNewInstance() {
            setCh157ToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SupportedWLANApsChannel11a.ch157Type.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""ch157 : ""
                    + getCh157().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 15);

          @Override public boolean isExplicitlySet() {
            return getCh161() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getCh161();
          }

          @Override public void setToNewInstance() {
            setCh161ToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SupportedWLANApsChannel11a.ch161Type.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""ch161 : ""
                    + getCh161().toIndentedString(indent);
              }
        });
    
    return builder.build();
  }

  @Override public Iterable<? extends SequenceComponent>
                                                    getExtensionComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
      
      return builder.build();
    }

  
/*
 */


//

/**
 */
public static class ch34Type extends Asn1Boolean {
  //

  private static final Asn1Tag TAG_ch34Type
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public ch34Type() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_ch34Type;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_ch34Type != null) {
      return ImmutableList.of(TAG_ch34Type);
    } else {
      return Asn1Boolean.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new ch34Type from encoded stream.
   */
  public static ch34Type fromPerUnaligned(byte[] encodedBytes) {
    ch34Type result = new ch34Type();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new ch34Type from encoded stream.
   */
  public static ch34Type fromPerAligned(byte[] encodedBytes) {
    ch34Type result = new ch34Type();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""ch34Type = "" + getValue() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class ch36Type extends Asn1Boolean {
  //

  private static final Asn1Tag TAG_ch36Type
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public ch36Type() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_ch36Type;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_ch36Type != null) {
      return ImmutableList.of(TAG_ch36Type);
    } else {
      return Asn1Boolean.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new ch36Type from encoded stream.
   */
  public static ch36Type fromPerUnaligned(byte[] encodedBytes) {
    ch36Type result = new ch36Type();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new ch36Type from encoded stream.
   */
  public static ch36Type fromPerAligned(byte[] encodedBytes) {
    ch36Type result = new ch36Type();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""ch36Type = "" + getValue() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class ch38Type extends Asn1Boolean {
  //

  private static final Asn1Tag TAG_ch38Type
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public ch38Type() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_ch38Type;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_ch38Type != null) {
      return ImmutableList.of(TAG_ch38Type);
    } else {
      return Asn1Boolean.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new ch38Type from encoded stream.
   */
  public static ch38Type fromPerUnaligned(byte[] encodedBytes) {
    ch38Type result = new ch38Type();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new ch38Type from encoded stream.
   */
  public static ch38Type fromPerAligned(byte[] encodedBytes) {
    ch38Type result = new ch38Type();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""ch38Type = "" + getValue() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class ch40Type extends Asn1Boolean {
  //

  private static final Asn1Tag TAG_ch40Type
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public ch40Type() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_ch40Type;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_ch40Type != null) {
      return ImmutableList.of(TAG_ch40Type);
    } else {
      return Asn1Boolean.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new ch40Type from encoded stream.
   */
  public static ch40Type fromPerUnaligned(byte[] encodedBytes) {
    ch40Type result = new ch40Type();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new ch40Type from encoded stream.
   */
  public static ch40Type fromPerAligned(byte[] encodedBytes) {
    ch40Type result = new ch40Type();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""ch40Type = "" + getValue() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class ch42Type extends Asn1Boolean {
  //

  private static final Asn1Tag TAG_ch42Type
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public ch42Type() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_ch42Type;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_ch42Type != null) {
      return ImmutableList.of(TAG_ch42Type);
    } else {
      return Asn1Boolean.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new ch42Type from encoded stream.
   */
  public static ch42Type fromPerUnaligned(byte[] encodedBytes) {
    ch42Type result = new ch42Type();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new ch42Type from encoded stream.
   */
  public static ch42Type fromPerAligned(byte[] encodedBytes) {
    ch42Type result = new ch42Type();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""ch42Type = "" + getValue() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class ch44Type extends Asn1Boolean {
  //

  private static final Asn1Tag TAG_ch44Type
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public ch44Type() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_ch44Type;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_ch44Type != null) {
      return ImmutableList.of(TAG_ch44Type);
    } else {
      return Asn1Boolean.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new ch44Type from encoded stream.
   */
  public static ch44Type fromPerUnaligned(byte[] encodedBytes) {
    ch44Type result = new ch44Type();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new ch44Type from encoded stream.
   */
  public static ch44Type fromPerAligned(byte[] encodedBytes) {
    ch44Type result = new ch44Type();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""ch44Type = "" + getValue() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class ch46Type extends Asn1Boolean {
  //

  private static final Asn1Tag TAG_ch46Type
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public ch46Type() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_ch46Type;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_ch46Type != null) {
      return ImmutableList.of(TAG_ch46Type);
    } else {
      return Asn1Boolean.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new ch46Type from encoded stream.
   */
  public static ch46Type fromPerUnaligned(byte[] encodedBytes) {
    ch46Type result = new ch46Type();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new ch46Type from encoded stream.
   */
  public static ch46Type fromPerAligned(byte[] encodedBytes) {
    ch46Type result = new ch46Type();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""ch46Type = "" + getValue() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class ch48Type extends Asn1Boolean {
  //

  private static final Asn1Tag TAG_ch48Type
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public ch48Type() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_ch48Type;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_ch48Type != null) {
      return ImmutableList.of(TAG_ch48Type);
    } else {
      return Asn1Boolean.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new ch48Type from encoded stream.
   */
  public static ch48Type fromPerUnaligned(byte[] encodedBytes) {
    ch48Type result = new ch48Type();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new ch48Type from encoded stream.
   */
  public static ch48Type fromPerAligned(byte[] encodedBytes) {
    ch48Type result = new ch48Type();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""ch48Type = "" + getValue() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class ch52Type extends Asn1Boolean {
  //

  private static final Asn1Tag TAG_ch52Type
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public ch52Type() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_ch52Type;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_ch52Type != null) {
      return ImmutableList.of(TAG_ch52Type);
    } else {
      return Asn1Boolean.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new ch52Type from encoded stream.
   */
  public static ch52Type fromPerUnaligned(byte[] encodedBytes) {
    ch52Type result = new ch52Type();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new ch52Type from encoded stream.
   */
  public static ch52Type fromPerAligned(byte[] encodedBytes) {
    ch52Type result = new ch52Type();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""ch52Type = "" + getValue() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class ch56Type extends Asn1Boolean {
  //

  private static final Asn1Tag TAG_ch56Type
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public ch56Type() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_ch56Type;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_ch56Type != null) {
      return ImmutableList.of(TAG_ch56Type);
    } else {
      return Asn1Boolean.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new ch56Type from encoded stream.
   */
  public static ch56Type fromPerUnaligned(byte[] encodedBytes) {
    ch56Type result = new ch56Type();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new ch56Type from encoded stream.
   */
  public static ch56Type fromPerAligned(byte[] encodedBytes) {
    ch56Type result = new ch56Type();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""ch56Type = "" + getValue() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class ch60Type extends Asn1Boolean {
  //

  private static final Asn1Tag TAG_ch60Type
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public ch60Type() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_ch60Type;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_ch60Type != null) {
      return ImmutableList.of(TAG_ch60Type);
    } else {
      return Asn1Boolean.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new ch60Type from encoded stream.
   */
  public static ch60Type fromPerUnaligned(byte[] encodedBytes) {
    ch60Type result = new ch60Type();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new ch60Type from encoded stream.
   */
  public static ch60Type fromPerAligned(byte[] encodedBytes) {
    ch60Type result = new ch60Type();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""ch60Type = "" + getValue() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class ch64Type extends Asn1Boolean {
  //

  private static final Asn1Tag TAG_ch64Type
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public ch64Type() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_ch64Type;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_ch64Type != null) {
      return ImmutableList.of(TAG_ch64Type);
    } else {
      return Asn1Boolean.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new ch64Type from encoded stream.
   */
  public static ch64Type fromPerUnaligned(byte[] encodedBytes) {
    ch64Type result = new ch64Type();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new ch64Type from encoded stream.
   */
  public static ch64Type fromPerAligned(byte[] encodedBytes) {
    ch64Type result = new ch64Type();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""ch64Type = "" + getValue() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class ch149Type extends Asn1Boolean {
  //

  private static final Asn1Tag TAG_ch149Type
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public ch149Type() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_ch149Type;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_ch149Type != null) {
      return ImmutableList.of(TAG_ch149Type);
    } else {
      return Asn1Boolean.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new ch149Type from encoded stream.
   */
  public static ch149Type fromPerUnaligned(byte[] encodedBytes) {
    ch149Type result = new ch149Type();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new ch149Type from encoded stream.
   */
  public static ch149Type fromPerAligned(byte[] encodedBytes) {
    ch149Type result = new ch149Type();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""ch149Type = "" + getValue() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class ch153Type extends Asn1Boolean {
  //

  private static final Asn1Tag TAG_ch153Type
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public ch153Type() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_ch153Type;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_ch153Type != null) {
      return ImmutableList.of(TAG_ch153Type);
    } else {
      return Asn1Boolean.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new ch153Type from encoded stream.
   */
  public static ch153Type fromPerUnaligned(byte[] encodedBytes) {
    ch153Type result = new ch153Type();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new ch153Type from encoded stream.
   */
  public static ch153Type fromPerAligned(byte[] encodedBytes) {
    ch153Type result = new ch153Type();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""ch153Type = "" + getValue() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class ch157Type extends Asn1Boolean {
  //

  private static final Asn1Tag TAG_ch157Type
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public ch157Type() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_ch157Type;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_ch157Type != null) {
      return ImmutableList.of(TAG_ch157Type);
    } else {
      return Asn1Boolean.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new ch157Type from encoded stream.
   */
  public static ch157Type fromPerUnaligned(byte[] encodedBytes) {
    ch157Type result = new ch157Type();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new ch157Type from encoded stream.
   */
  public static ch157Type fromPerAligned(byte[] encodedBytes) {
    ch157Type result = new ch157Type();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""ch157Type = "" + getValue() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class ch161Type extends Asn1Boolean {
  //

  private static final Asn1Tag TAG_ch161Type
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public ch161Type() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_ch161Type;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_ch161Type != null) {
      return ImmutableList.of(TAG_ch161Type);
    } else {
      return Asn1Boolean.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new ch161Type from encoded stream.
   */
  public static ch161Type fromPerUnaligned(byte[] encodedBytes) {
    ch161Type result = new ch161Type();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new ch161Type from encoded stream.
   */
  public static ch161Type fromPerAligned(byte[] encodedBytes) {
    ch161Type result = new ch161Type();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""ch161Type = "" + getValue() + "";\n"";
  }
}

  

    

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    StringBuilder builder = new StringBuilder();
    builder.append(""SupportedWLANApsChannel11a = {\n"");
    final String internalIndent = indent + ""  "";
    for (SequenceComponent component : getComponents()) {
      if (component.isExplicitlySet()) {
        builder.append(internalIndent)
            .append(component.toIndentedString(internalIndent));
      }
    }
    if (isExtensible()) {
      builder.append(internalIndent).append(""...\n"");
      for (SequenceComponent component : getExtensionComponents()) {
        if (component.isExplicitlySet()) {
          builder.append(internalIndent)
              .append(component.toIndentedString(internalIndent));
        }
      }
    }
    builder.append(indent).append(""};\n"");
    return builder.toString();
  }
}"	"/home/gpoor/cts-12-source/cts/tests/location/location_gnss/src/android/location/cts/gnss/asn1/supl2/ver2_ulp_components/SupportedWLANApsChannel11a.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.security.SELinuxTargetSdkTest"	"testAppDomainContext"	"CtsSelinuxTargetSdk28TestCases"	"1: apps"	"public void testAppDomainContext() throws IOException {
        String context = ""u:r:untrusted_app_27:s0:c[0-9]+,c[0-9]+,c[0-9]+,c[0-9]+"";
        String msg = ""Untrusted apps with targetSdkVersion 28 "" +
            ""must run in the untrusted_app selinux domain and use the levelFrom=all "" +
            ""selector in SELinux seapp_contexts which adds four category types "" +
            ""to the app's selinux context.\n"" +
            ""Example expected value: u:r:untrusted_app:s0:c89,c256,c512,c768\n"" +
            ""Actual value: "";
        appDomainContext(context, msg);
    }

    /**
     * Verify that selinux context is the expected type based on
     * targetSdkVersion = 28
     */"	"/home/gpoor/cts-12-source/cts/tests/tests/selinux/selinuxTargetSdk28/src/android/security/SELinuxTargetSdkTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.security.SELinuxTargetSdkTest"	"testAppDataContext"	"CtsSelinuxTargetSdk28TestCases"	"1: apps"	"public void testAppDataContext() throws Exception {
        String context = ""u:object_r:app_data_file:s0:c[0-9]+,c[0-9]+,c[0-9]+,c[0-9]+"";
        String msg = ""Untrusted apps with targetSdkVersion 28 "" +
            ""must use the app_data_file selinux context and use the levelFrom=all "" +
            ""selector in SELinux seapp_contexts which adds four category types "" +
            ""to the app_data_file context.\n"" +
            ""Example expected value: u:object_r:app_data_file:s0:c89,c256,c512,c768\n"" +
            ""Actual value: "";
        appDataContext(context, msg);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/selinux/selinuxTargetSdk28/src/android/security/SELinuxTargetSdkTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.mediav2.cts.TextureRender"	"glFinish"	"CtsMediaV2TestCases"	"2: direct ui"	"public void test/*
 *.
 */

package android.mediav2.cts;

import android.graphics.Bitmap;
import android.graphics.SurfaceTexture;
import android.opengl.GLES11Ext;
import android.opengl.GLES20;
import android.opengl.Matrix;
import android.util.Log;

import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;

/**
 * Code for rendering a texture onto a surface using OpenGL ES 2.0.
 */
class TextureRender {
    private static final String TAG = ""TextureRender"";

    private static final int FLOAT_SIZE_BYTES = 4;
    private static final int TRIANGLE_VERTICES_DATA_STRIDE_BYTES = 5 * FLOAT_SIZE_BYTES;
    private static final int TRIANGLE_VERTICES_DATA_POS_OFFSET = 0;
    private static final int TRIANGLE_VERTICES_DATA_UV_OFFSET = 3;
    private final float[] mTriangleVerticesData = {
            // X, Y, Z, U, V
            -1.0f, -1.0f, 0.0f, 0.0f, 0.0f,
             1.0f, -1.0f, 0.0f, 1.0f, 0.0f,
            -1.0f,  1.0f, 0.0f, 0.0f, 1.0f,
             1.0f,  1.0f, 0.0f, 1.0f, 1.0f,
    };

    private FloatBuffer mTriangleVertices;

    private static final String VERTEX_SHADER =
            ""uniform mat4 uMVPMatrix;\n"" +
            ""uniform mat4 uSTMatrix;\n"" +
            ""attribute vec4 aPosition;\n"" +
            ""attribute vec4 aTextureCoord;\n"" +
            ""varying vec2 vTextureCoord;\n"" +
            ""void main() {\n"" +
            ""  gl_Position = uMVPMatrix * aPosition;\n"" +
            ""  vTextureCoord = (uSTMatrix * aTextureCoord).xy;\n"" +
            ""}\n"";

    private static final String FRAGMENT_SHADER =
            ""#extension GL_OES_EGL_image_external : require\n"" +
            ""precision mediump float;\n"" +      // highp here doesn't seem to matter
            ""varying vec2 vTextureCoord;\n"" +
            ""uniform samplerExternalOES sTexture;\n"" +
            ""void main() {\n"" +
            ""  gl_FragColor = texture2D(sTexture, vTextureCoord);\n"" +
            ""}\n"";

    private float[] mMVPMatrix = new float[16];
    private float[] mSTMatrix = new float[16];

    private int mProgram;
    private int mTextureID;
    private int muMVPMatrixHandle;
    private int muSTMatrixHandle;
    private int maPositionHandle;
    private int maTextureHandle;

    public TextureRender() {
        mTriangleVertices = ByteBuffer.allocateDirect(
            mTriangleVerticesData.length * FLOAT_SIZE_BYTES)
                .order(ByteOrder.nativeOrder()).asFloatBuffer();
        mTriangleVertices.put(mTriangleVerticesData).position(0);

        Matrix.setIdentityM(mSTMatrix, 0);
    }

    public int getTextureId() {
        return mTextureID;
    }

    public void drawFrame(SurfaceTexture st) {
        checkGlError(""onDrawFrame start"");
        st.getTransformMatrix(mSTMatrix);

        GLES20.glClearColor(0.0f, 1.0f, 0.0f, 1.0f);
        GLES20.glClear(GLES20.GL_DEPTH_BUFFER_BIT | GLES20.GL_COLOR_BUFFER_BIT);

        GLES20.glUseProgram(mProgram);
        checkGlError(""glUseProgram"");

        GLES20.glActiveTexture(GLES20.GL_TEXTURE0);
        GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, mTextureID);

        mTriangleVertices.position(TRIANGLE_VERTICES_DATA_POS_OFFSET);
        GLES20.glVertexAttribPointer(maPositionHandle, 3, GLES20.GL_FLOAT, false,
            TRIANGLE_VERTICES_DATA_STRIDE_BYTES, mTriangleVertices);
        checkGlError(""glVertexAttribPointer maPosition"");
        GLES20.glEnableVertexAttribArray(maPositionHandle);
        checkGlError(""glEnableVertexAttribArray maPositionHandle"");

        mTriangleVertices.position(TRIANGLE_VERTICES_DATA_UV_OFFSET);
        GLES20.glVertexAttribPointer(maTextureHandle, 2, GLES20.GL_FLOAT, false,
            TRIANGLE_VERTICES_DATA_STRIDE_BYTES, mTriangleVertices);
        checkGlError(""glVertexAttribPointer maTextureHandle"");
        GLES20.glEnableVertexAttribArray(maTextureHandle);
        checkGlError(""glEnableVertexAttribArray maTextureHandle"");

        Matrix.setIdentityM(mMVPMatrix, 0);
        GLES20.glUniformMatrix4fv(muMVPMatrixHandle, 1, false, mMVPMatrix, 0);
        GLES20.glUniformMatrix4fv(muSTMatrixHandle, 1, false, mSTMatrix, 0);

        GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4);
        checkGlError(""glDrawArrays"");
        GLES20.glFinish();
    }

    /**
     * Initializes GL state.  Call this after the EGL surface has been created and made current.
     */
    public void surfaceCreated() {
        mProgram = createProgram(VERTEX_SHADER, FRAGMENT_SHADER);
        if (mProgram == 0) {
            throw new RuntimeException(""failed creating program"");
        }
        maPositionHandle = GLES20.glGetAttribLocation(mProgram, ""aPosition"");
        checkGlError(""glGetAttribLocation aPosition"");
        if (maPositionHandle == -1) {
            throw new RuntimeException(""Could not get attrib location for aPosition"");
        }
        maTextureHandle = GLES20.glGetAttribLocation(mProgram, ""aTextureCoord"");
        checkGlError(""glGetAttribLocation aTextureCoord"");
        if (maTextureHandle == -1) {
            throw new RuntimeException(""Could not get attrib location for aTextureCoord"");
        }

        muMVPMatrixHandle = GLES20.glGetUniformLocation(mProgram, ""uMVPMatrix"");
        checkGlError(""glGetUniformLocation uMVPMatrix"");
        if (muMVPMatrixHandle == -1) {
            throw new RuntimeException(""Could not get attrib location for uMVPMatrix"");
        }

        muSTMatrixHandle = GLES20.glGetUniformLocation(mProgram, ""uSTMatrix"");
        checkGlError(""glGetUniformLocation uSTMatrix"");
        if (muSTMatrixHandle == -1) {
            throw new RuntimeException(""Could not get attrib location for uSTMatrix"");
        }


        int[] textures = new int[1];
        GLES20.glGenTextures(1, textures, 0);

        mTextureID = textures[0];
        GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, mTextureID);
        checkGlError(""glBindTexture mTextureID"");

        GLES20.glTexParameterf(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MIN_FILTER,
                GLES20.GL_NEAREST);
        GLES20.glTexParameterf(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MAG_FILTER,
                GLES20.GL_LINEAR);
        GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_S,
                GLES20.GL_CLAMP_TO_EDGE);
        GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_T,
                GLES20.GL_CLAMP_TO_EDGE);
        checkGlError(""glTexParameter"");
    }

    /**
     * Replaces the fragment shader.
     */
    public void changeFragmentShader(String fragmentShader) {
        GLES20.glDeleteProgram(mProgram);
        mProgram = createProgram(VERTEX_SHADER, fragmentShader);
        if (mProgram == 0) {
            throw new RuntimeException(""failed creating program"");
        }
    }

    private int loadShader(int shaderType, String source) {
        int shader = GLES20.glCreateShader(shaderType);
        checkGlError(""glCreateShader type="" + shaderType);
        GLES20.glShaderSource(shader, source);
        GLES20.glCompileShader(shader);
        int[] compiled = new int[1];
        GLES20.glGetShaderiv(shader, GLES20.GL_COMPILE_STATUS, compiled, 0);
        if (compiled[0] == 0) {
            Log.e(TAG, ""Could not compile shader "" + shaderType + "":"");
            Log.e(TAG, "" "" + GLES20.glGetShaderInfoLog(shader));
            GLES20.glDeleteShader(shader);
            shader = 0;
        }
        return shader;
    }

    private int createProgram(String vertexSource, String fragmentSource) {
        int vertexShader = loadShader(GLES20.GL_VERTEX_SHADER, vertexSource);
        if (vertexShader == 0) {
            return 0;
        }
        int pixelShader = loadShader(GLES20.GL_FRAGMENT_SHADER, fragmentSource);
        if (pixelShader == 0) {
            return 0;
        }

        int program = GLES20.glCreateProgram();
        checkGlError(""glCreateProgram"");
        if (program != 0) {
            GLES20.glAttachShader(program, vertexShader);
            checkGlError(""glAttachShader"");
            GLES20.glAttachShader(program, pixelShader);
            checkGlError(""glAttachShader"");
            GLES20.glLinkProgram(program);
            int[] linkStatus = new int[1];
            GLES20.glGetProgramiv(program, GLES20.GL_LINK_STATUS, linkStatus, 0);
            if (linkStatus[0] != GLES20.GL_TRUE) {
                Log.e(TAG, ""Could not link program: "");
                Log.e(TAG, GLES20.glGetProgramInfoLog(program));
                GLES20.glDeleteProgram(program);
                program = 0;
            }
        } else {
            Log.e(TAG, ""Could not create program"");
        }

        return program;
    }

    public void checkGlError(String op) {
        int error;
        while ((error = GLES20.glGetError()) != GLES20.GL_NO_ERROR) {
            Log.e(TAG, op + "": glError "" + error);
            throw new RuntimeException(op + "": glError "" + error);
        }
    }

    /**
     * Saves the current frame to disk as a PNG image.  Frame starts from (0,0).
     * <p>
     * Useful for debugging.
     */
    public static void saveFrame(String filename, int width, int height) {
        // glReadPixels gives us a ByteBuffer filled with what is essentially big-endian RGBA
        // data (i.e. a byte of red, followed by a byte of green...).  We need an int[] filled
        // with native-order ARGB data to feed to Bitmap.
        //
        // If we implement this as a series of buf.get() calls, we can spend 2.5 seconds just
        // copying data around for a 720p frame.  It's better to do a bulk get() and then
        // rearrange the data in memory.  (For comparison, the PNG compress takes about 500ms
        // for a trivial frame.)
        //
        // So... we set the ByteBuffer to little-endian, which should turn the bulk IntBuffer
        // get() into a straight memcpy on most Android devices.  Our ints will hold ABGR data.
        // Swapping B and R gives us ARGB.  We need about 30ms for the bulk get(), and another
        // 270ms for the color swap.
        //
        // Making this even more interesting is the upside-down nature of GL, which means we
        // flip the image vertically here.

        ByteBuffer buf = ByteBuffer.allocateDirect(width * height * 4);
        buf.order(ByteOrder.LITTLE_ENDIAN);
        GLES20.glReadPixels(0, 0, width, height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, buf);
        buf.rewind();

        int pixelCount = width * height;
        int[] colors = new int[pixelCount];
        buf.asIntBuffer().get(colors);
        for (int i = 0; i < pixelCount; i++) {
            int c = colors[i];
            colors[i] = (c & 0xff00ff00) | ((c & 0x00ff0000) >> 16) | ((c & 0x000000ff) << 16);
        }

        FileOutputStream fos = null;
        try {
            fos = new FileOutputStream(filename);
            Bitmap bmp = Bitmap.createBitmap(colors, width, height, Bitmap.Config.ARGB_8888);
            bmp.compress(Bitmap.CompressFormat.PNG, 90, fos);
            bmp.recycle();
        } catch (IOException ioe) {
            throw new RuntimeException(""Failed to write file "" + filename, ioe);
        } finally {
            try {
                if (fos != null) fos.close();
            } catch (IOException ioe2) {
                throw new RuntimeException(""Failed to close file "" + filename, ioe2);
            }
        }
        Log.d(TAG, ""Saved "" + width + ""x"" + height + "" frame as '"" + filename + ""'"");
    }
}"	"/home/gpoor/cts-12-source/cts/tests/media/src/android/mediav2/cts/TextureRender.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.location.cts.gnss.asn1.supl2.rrlp_components.SeqOfGPSRefOrbit"	"isTagImplicit"	"CtsLocationGnssTestCases"	"1: ui"	"public void test/*
 *.
 */

package android.location.cts.asn1.supl2.rrlp_components;

/*
 */


//
//
import android.location.cts.asn1.base.Asn1Null;
import android.location.cts.asn1.base.Asn1SequenceOf;
import android.location.cts.asn1.base.Asn1Tag;
import android.location.cts.asn1.base.BitStream;
import android.location.cts.asn1.base.BitStreamReader;
import com.google.common.collect.ImmutableList;
import java.util.Collection;
import javax.annotation.Nullable;


/**
 */
public  class SeqOfGPSRefOrbit
    extends Asn1SequenceOf<GPSReferenceOrbit> {
  //

  private static final Asn1Tag TAG_SeqOfGPSRefOrbit
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public SeqOfGPSRefOrbit() {
    super();
    setMinSize(1);
setMaxSize(32);

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_SeqOfGPSRefOrbit;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_SeqOfGPSRefOrbit != null) {
      return ImmutableList.of(TAG_SeqOfGPSRefOrbit);
    } else {
      return Asn1SequenceOf.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new SeqOfGPSRefOrbit from encoded stream.
   */
  public static SeqOfGPSRefOrbit fromPerUnaligned(byte[] encodedBytes) {
    SeqOfGPSRefOrbit result = new SeqOfGPSRefOrbit();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new SeqOfGPSRefOrbit from encoded stream.
   */
  public static SeqOfGPSRefOrbit fromPerAligned(byte[] encodedBytes) {
    SeqOfGPSRefOrbit result = new SeqOfGPSRefOrbit();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  
  @Override public GPSReferenceOrbit createAndAddValue() {
    GPSReferenceOrbit value = new GPSReferenceOrbit();
    add(value);
    return value;
  }

  

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    StringBuilder builder = new StringBuilder();
    builder.append(""SeqOfGPSRefOrbit = [\n"");
    final String internalIndent = indent + ""  "";
    for (GPSReferenceOrbit value : getValues()) {
      builder.append(internalIndent)
          .append(value.toIndentedString(internalIndent));
    }
    builder.append(indent).append(""];\n"");
    return builder.toString();
  }
}"	"/home/gpoor/cts-12-source/cts/tests/location/location_gnss/src/android/location/cts/gnss/asn1/supl2/rrlp_components/SeqOfGPSRefOrbit.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.view.cts.input.InputDeviceVibratorTest"	"isVibrating"	"CtsViewTestCases"	"2: ui system"	"/*
 *.
 */

package android.view.cts;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.mockito.ArgumentMatchers.anyBoolean;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.reset;
import static org.mockito.Mockito.timeout;
import static org.mockito.Mockito.verify;

import android.app.Instrumentation;
import android.hardware.input.InputManager;
import android.os.SystemClock;
import android.os.VibrationEffect;
import android.os.Vibrator;
import android.os.Vibrator.OnVibratorStateChangedListener;
import android.util.Log;
import android.view.InputDevice;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SmallTest;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.cts.input.InputJsonParser;
import com.android.cts.input.UinputDevice;
import com.android.cts.input.UinputResultData;
import com.android.cts.input.UinputVibratorTestData;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnit;
import org.mockito.junit.MockitoRule;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Test {@link android.view.InputDevice} vibrator functionality.
 */
@SmallTest
@RunWith(AndroidJUnit4.class)
public class InputDeviceVibratorTest {
    private static final String TAG = ""InputDeviceVibratorTest"";
    private static final long CALLBACK_TIMEOUT_MILLIS = 5000;

    private InputManager mInputManager;
    private UinputDevice mUinputDevice;
    private InputJsonParser mParser;
    private Instrumentation mInstrumentation;
    private Vibrator mVibrator;
    private int mDeviceId;

    @Rule
    public MockitoRule rule = MockitoJUnit.rule();
    @Mock
    private OnVibratorStateChangedListener mListener;

    /**
     * Get a vibrator from input device with specified Vendor Id and Product Id.
     * @param vid Vendor Id
     * @param pid Product Id
     * @return Vibrator object in specified InputDevice
     */
    private Vibrator getVibrator(int vid, int pid) {
        final int[] inputDeviceIds = mInputManager.getInputDeviceIds();
        for (int inputDeviceId : inputDeviceIds) {
            final InputDevice inputDevice = mInputManager.getInputDevice(inputDeviceId);
            Vibrator vibrator = inputDevice.getVibrator();
            if (vibrator.hasVibrator() && inputDevice.getVendorId() == vid
                    && inputDevice.getProductId() == pid) {
                Log.i(TAG, ""Input device: "" + inputDeviceId + "" VendorId: ""
                        + inputDevice.getVendorId() + "" ProductId: "" + inputDevice.getProductId());
                return vibrator;
            }
        }
        return null;
    }

    @Before
    public void setup() {
        final int resourceId = R.raw.google_gamepad_register;

        mInstrumentation = InstrumentationRegistry.getInstrumentation();
        mInputManager = mInstrumentation.getTargetContext().getSystemService(InputManager.class);
        assertNotNull(mInputManager);
        mParser = new InputJsonParser(mInstrumentation.getTargetContext());
        mDeviceId = mParser.readDeviceId(resourceId);
        String registerCommand = mParser.readRegisterCommand(resourceId);
        mUinputDevice = new UinputDevice(mInstrumentation, mDeviceId,
                mParser.readVendorId(resourceId), mParser.readProductId(resourceId),
                InputDevice.SOURCE_KEYBOARD, registerCommand);
        mVibrator = getVibrator(mParser.readVendorId(resourceId),
                mParser.readProductId(resourceId));
        assertTrue(mVibrator != null);
        mVibrator.addVibratorStateListener(mListener);
        verify(mListener, timeout(CALLBACK_TIMEOUT_MILLIS)
                .times(1)).onVibratorStateChanged(false);
        reset(mListener);
    }

    @After
    public void tearDown() {
        mUinputDevice.close();
    }

    public void testInputVibratorEvents(int resourceId) {
        final List<UinputVibratorTestData> tests = mParser.getUinputVibratorTestData(resourceId);

        for (UinputVibratorTestData test : tests) {
            assertTrue(test.durations.size() == test.amplitudes.size());
            assertTrue(test.durations.size() > 0);

            final long timeoutMills;
            final long totalVibrations = test.durations.size();
            final VibrationEffect effect;
            if (test.durations.size() == 1) {
                long duration = test.durations.get(0);
                int amplitude = test.amplitudes.get(0);
                effect = VibrationEffect.createOneShot(duration, amplitude);
                // Set timeout to be 2 times of the effect duration.
                timeoutMills = duration * 2;
            } else {
                long[] durations = test.durations.stream().mapToLong(Long::longValue).toArray();
                int[] amplitudes = test.amplitudes.stream().mapToInt(Integer::intValue).toArray();
                effect = VibrationEffect.createWaveform(
                    durations, amplitudes, -1);
                // Set timeout to be 2 times of the effect total duration.
                timeoutMills = Arrays.stream(durations).sum() * 2;
            }

            // Start vibration
            mVibrator.vibrate(effect);
            // Verify vibrator state listener
            verify(mListener, timeout(CALLBACK_TIMEOUT_MILLIS)
                    .times(1)).onVibratorStateChanged(true);
            assertTrue(mVibrator.isVibrating());

            final long startTime = SystemClock.elapsedRealtime();
            List<UinputResultData> results = new ArrayList<>();
            int vibrationCount = 0;

            while (vibrationCount < totalVibrations
                    && SystemClock.elapsedRealtime() - startTime < timeoutMills) {
                SystemClock.sleep(1000);
                try {
                    results = mUinputDevice.getResults(mDeviceId, ""vibrating"");
                    if (results.size() < totalVibrations) {
                        continue;
                    }
                    vibrationCount = 0;
                    for (int i = 0; i < results.size(); i++) {
                        UinputResultData result = results.get(i);
                        if (result.reason.equals(""vibrating"") && result.deviceId == mDeviceId
                                && (result.status > 0)) {
                            vibrationCount++;
                        }
                    }
                }  catch (IOException ex) {
                    throw new RuntimeException(""Could not get JSON results from HidDevice"");
                }
            }
            assertEquals(vibrationCount, totalVibrations);
            // Verify vibrator state listener
            verify(mListener, timeout(CALLBACK_TIMEOUT_MILLIS)
                    .times(1)).onVibratorStateChanged(false);
            assertFalse(mVibrator.isVibrating());
            reset(mListener);
        }
        // Shouldn't get any listener state callback after removal
        mVibrator.removeVibratorStateListener(mListener);
        // Start vibration
        mVibrator.vibrate(VibrationEffect.createOneShot(100 /* duration */, 255 /* amplitude */));
        assertTrue(mVibrator.isVibrating());
        // Verify vibrator state listener
        verify(mListener, never()).onVibratorStateChanged(anyBoolean());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/input/InputDeviceVibratorTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testOnResolvePointerIcon"	"CtsWidgetTestCases"	"3: mic ui system"	"public void testOnResolvePointerIcon() throws InterruptedException {
        final TextView selectableTextView = findTextView(R.id.textview_pointer);
        final MotionEvent event = createMouseHoverEvent(selectableTextView);

        // A selectable view shows the I beam
        selectableTextView.setTextIsSelectable(true);

        assertEquals(PointerIcon.getSystemIcon(mActivity, PointerIcon.TYPE_TEXT),
                selectableTextView.onResolvePointerIcon(event, 0));
        selectableTextView.setTextIsSelectable(false);

        // A clickable view shows the hand
        selectableTextView.setLinksClickable(true);
        SpannableString builder = new SpannableString(""hello world"");
        selectableTextView.setText(builder, BufferType.SPANNABLE);
        Spannable text = (Spannable) selectableTextView.getText();
        text.setSpan(
                new ClickableSpan() {
                    @Override
                    public void onClick(View widget) {

                    }
                }, 0, text.length(), Spanned.SPAN_INCLUSIVE_INCLUSIVE);

        assertEquals(PointerIcon.getSystemIcon(mActivity, PointerIcon.TYPE_HAND),
                selectableTextView.onResolvePointerIcon(event, 0));

        // A selectable & clickable view shows hand
        selectableTextView.setTextIsSelectable(true);

        assertEquals(PointerIcon.getSystemIcon(mActivity, PointerIcon.TYPE_HAND),
                selectableTextView.onResolvePointerIcon(event, 0));

        // An editable view shows the I-beam
        final TextView editableTextView = new EditText(mActivity);

        assertEquals(PointerIcon.getSystemIcon(mActivity, PointerIcon.TYPE_TEXT),
                editableTextView.onResolvePointerIcon(event, 0));
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testDynamicLayoutReflowCrash_b75652829"	"CtsWidgetTestCases"	"2: mic ui"	"public void testDynamicLayoutReflowCrash_b75652829() throws Throwable {
        final SpannableStringBuilder text = new SpannableStringBuilder(""abcde"");
        text.setSpan(new UnderlineSpan(), 0, 5, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);

        mActivityRule.runOnUiThread(() -> {
            mTextView = new EditText(mActivity);
            mActivity.setContentView(mTextView);
            mTextView.setText(text, BufferType.EDITABLE);
            mTextView.requestFocus();
            mTextView.setSelected(true);
            mTextView.setTextClassifier(TextClassifier.NO_OP);
        });
        mInstrumentation.waitForIdleSync();

        mActivityRule.runOnUiThread(() -> {
            // Set selection and try to start action mode.
            final Bundle args = new Bundle();
            args.putInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_START_INT, 0);
            args.putInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_END_INT, text.length());
            mTextView.performAccessibilityAction(
                    AccessibilityNodeInfo.ACTION_SET_SELECTION, args);
        });
        mInstrumentation.waitForIdleSync();

        mActivityRule.runOnUiThread(() -> {
            Editable editable = (Editable) mTextView.getText();
            SpannableStringBuilder ssb = new SpannableStringBuilder(""a"");
            ssb.setSpan(new UnderlineSpan(), 0, 1, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
            editable.replace(5, 5, ssb);
        });
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testUndo_directAppend"	"CtsWidgetTestCases"	"2: direct ui"	"public void testUndo_directAppend() throws Throwable {
        initTextViewForTypingOnUiThread();

        // Type some text.
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""abc"");
        mActivityRule.runOnUiThread(() -> {
            // Programmatically append some text.
            mTextView.append(""def"");
            assertEquals(""abcdef"", mTextView.getText().toString());

            // Undo removes the append as a separate step.
            mTextView.onTextContextMenuItem(android.R.id.undo);
            assertEquals(""abc"", mTextView.getText().toString());

            // Another undo removes the original typing.
            mTextView.onTextContextMenuItem(android.R.id.undo);
            assertEquals("""", mTextView.getText().toString());
        });
        mInstrumentation.waitForIdleSync();
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testUndo_directInsert"	"CtsWidgetTestCases"	"3: direct apps ui"	"public void testUndo_directInsert() throws Throwable {
        initTextViewForTypingOnUiThread();

        // Type some text.
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""abc"");
        mActivityRule.runOnUiThread(() -> {
            // Directly modify the underlying Editable to insert some text.
            // NOTE: This is a violation of the API of getText() which specifies that the
            // returned object should not be modified. However, some apps do this anyway and
            // the framework needs to handle it.
            Editable text = (Editable) mTextView.getText();
            text.insert(0, ""def"");
            assertEquals(""defabc"", mTextView.getText().toString());

            // Undo removes the insert as a separate step.
            mTextView.onTextContextMenuItem(android.R.id.undo);
            assertEquals(""abc"", mTextView.getText().toString());

            // Another undo removes the original typing.
            mTextView.onTextContextMenuItem(android.R.id.undo);
            assertEquals("""", mTextView.getText().toString());
        });
        mInstrumentation.waitForIdleSync();
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testUndo_textWatcherDirectAppend"	"CtsWidgetTestCases"	"2: direct ui"	"public void testUndo_textWatcherDirectAppend() {
        initTextViewForTyping();

        // Add a TextWatcher that converts the text to spaces on each change.
        mTextView.addTextChangedListener(new ConvertToSpacesTextWatcher());

        // Programmatically append some text. The TextWatcher changes it to spaces.
        mTextView.append(""abc"");
        assertEquals(""   "", mTextView.getText().toString());

        // Undo reverses both changes in one step.
        mTextView.onTextContextMenuItem(android.R.id.undo);
        assertEquals("""", mTextView.getText().toString());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testCompound"	"CtsWidgetTestCases"	"2: direct ui"	"public void testCompound() {
        mTextView = new TextView(mActivity);
        int padding = 3;
        Drawable[] drawables = mTextView.getCompoundDrawables();
        assertNull(drawables[0]);
        assertNull(drawables[1]);
        assertNull(drawables[2]);
        assertNull(drawables[3]);

        // test setCompoundDrawablePadding and getCompoundDrawablePadding
        mTextView.setCompoundDrawablePadding(padding);
        assertEquals(padding, mTextView.getCompoundDrawablePadding());

        // using resid, 0 represents null
        mTextView.setCompoundDrawablesWithIntrinsicBounds(R.drawable.start, R.drawable.pass,
                R.drawable.failed, 0);
        drawables = mTextView.getCompoundDrawables();

        // drawableLeft
        WidgetTestUtils.assertEquals(TestUtils.getBitmap(mActivity, R.drawable.start),
                ((BitmapDrawable) drawables[0]).getBitmap());
        // drawableTop
        WidgetTestUtils.assertEquals(TestUtils.getBitmap(mActivity, R.drawable.pass),
                ((BitmapDrawable) drawables[1]).getBitmap());
        // drawableRight
        WidgetTestUtils.assertEquals(TestUtils.getBitmap(mActivity, R.drawable.failed),
                ((BitmapDrawable) drawables[2]).getBitmap());
        // drawableBottom
        assertNull(drawables[3]);

        Drawable left = TestUtils.getDrawable(mActivity, R.drawable.blue);
        Drawable right = TestUtils.getDrawable(mActivity, R.drawable.yellow);
        Drawable top = TestUtils.getDrawable(mActivity, R.drawable.red);

        // using drawables directly
        mTextView.setCompoundDrawablesWithIntrinsicBounds(left, top, right, null);
        drawables = mTextView.getCompoundDrawables();

        // drawableLeft
        assertSame(left, drawables[0]);
        // drawableTop
        assertSame(top, drawables[1]);
        // drawableRight
        assertSame(right, drawables[2]);
        // drawableBottom
        assertNull(drawables[3]);

        // check compound padding
        assertEquals(mTextView.getPaddingLeft() + padding + left.getIntrinsicWidth(),
                mTextView.getCompoundPaddingLeft());
        assertEquals(mTextView.getPaddingTop() + padding + top.getIntrinsicHeight(),
                mTextView.getCompoundPaddingTop());
        assertEquals(mTextView.getPaddingRight() + padding + right.getIntrinsicWidth(),
                mTextView.getCompoundPaddingRight());
        assertEquals(mTextView.getPaddingBottom(), mTextView.getCompoundPaddingBottom());

        // set bounds to drawables and set them again.
        left.setBounds(0, 0, 1, 2);
        right.setBounds(0, 0, 3, 4);
        top.setBounds(0, 0, 5, 6);
        // usinf drawables
        mTextView.setCompoundDrawables(left, top, right, null);
        drawables = mTextView.getCompoundDrawables();

        // drawableLeft
        assertSame(left, drawables[0]);
        // drawableTop
        assertSame(top, drawables[1]);
        // drawableRight
        assertSame(right, drawables[2]);
        // drawableBottom
        assertNull(drawables[3]);

        // check compound padding
        assertEquals(mTextView.getPaddingLeft() + padding + left.getBounds().width(),
                mTextView.getCompoundPaddingLeft());
        assertEquals(mTextView.getPaddingTop() + padding + top.getBounds().height(),
                mTextView.getCompoundPaddingTop());
        assertEquals(mTextView.getPaddingRight() + padding + right.getBounds().width(),
                mTextView.getCompoundPaddingRight());
        assertEquals(mTextView.getPaddingBottom(), mTextView.getCompoundPaddingBottom());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetCompoundDrawablesRelative"	"CtsWidgetTestCases"	"2: direct ui"	"public void testGetCompoundDrawablesRelative() {
        // prepare textview
        mTextView = new TextView(mActivity);

        // prepare drawables
        final Drawable start = TestUtils.getDrawable(mActivity, R.drawable.blue);
        final Drawable end = TestUtils.getDrawable(mActivity, R.drawable.yellow);
        final Drawable top = TestUtils.getDrawable(mActivity, R.drawable.red);
        final Drawable bottom = TestUtils.getDrawable(mActivity, R.drawable.black);
        assertNotNull(start);
        assertNotNull(end);
        assertNotNull(top);
        assertNotNull(bottom);

        Drawable[] drawables = mTextView.getCompoundDrawablesRelative();
        assertNotNull(drawables);
        assertEquals(4, drawables.length);
        assertNull(drawables[0]);
        assertNull(drawables[1]);
        assertNull(drawables[2]);
        assertNull(drawables[3]);

        mTextView.setLayoutDirection(View.LAYOUT_DIRECTION_LTR);
        mTextView.setCompoundDrawablesRelative(start, top, end, bottom);
        drawables = mTextView.getCompoundDrawablesRelative();

        assertNotNull(drawables);
        assertEquals(4, drawables.length);
        assertSame(start, drawables[0]);
        assertSame(top, drawables[1]);
        assertSame(end, drawables[2]);
        assertSame(bottom, drawables[3]);

        mTextView.setLayoutDirection(View.LAYOUT_DIRECTION_RTL);
        mTextView.setCompoundDrawablesRelative(start, top, end, bottom);
        drawables = mTextView.getCompoundDrawablesRelative();

        assertNotNull(drawables);
        assertEquals(4, drawables.length);
        assertSame(start, drawables[0]);
        assertSame(top, drawables[1]);
        assertSame(end, drawables[2]);
        assertSame(bottom, drawables[3]);

        mTextView.setCompoundDrawablesRelative(null, null, null, null);
        drawables = mTextView.getCompoundDrawablesRelative();

        assertNotNull(drawables);
        assertEquals(4, drawables.length);
        assertNull(drawables[0]);
        assertNull(drawables[1]);
        assertNull(drawables[2]);
        assertNull(drawables[3]);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testXmlTypefaceFontFamilyHierarchy"	"CtsWidgetTestCases"	"1: direct"	"public void testXmlTypefaceFontFamilyHierarchy() {
        // This view has typeface=serif set on the view directly and a fontFamily on the appearance.
        // In this case, the attr set directly on the view should take precedence.
        mTextView = findTextView(R.id.textview_textappearance_attrs_serif_fontfamily);

        assertEquals(Typeface.SERIF, mTextView.getTypeface());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testTextDirectionDefault"	"CtsWidgetTestCases"	"2: direct ui"	"public void testTextDirectionDefault() {
        TextView tv = new TextView(mActivity);
        assertEquals(View.TEXT_DIRECTION_INHERIT, tv.getRawTextDirection());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetGetTextDirection"	"CtsWidgetTestCases"	"2: direct ui"	"public void testSetGetTextDirection() {
        TextView tv = new TextView(mActivity);

        tv.setTextDirection(View.TEXT_DIRECTION_FIRST_STRONG);
        assertEquals(View.TEXT_DIRECTION_FIRST_STRONG, tv.getRawTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_ANY_RTL);
        assertEquals(View.TEXT_DIRECTION_ANY_RTL, tv.getRawTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_INHERIT);
        assertEquals(View.TEXT_DIRECTION_INHERIT, tv.getRawTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_LTR);
        assertEquals(View.TEXT_DIRECTION_LTR, tv.getRawTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_RTL);
        assertEquals(View.TEXT_DIRECTION_RTL, tv.getRawTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_LOCALE);
        assertEquals(View.TEXT_DIRECTION_LOCALE, tv.getRawTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_FIRST_STRONG_LTR);
        assertEquals(View.TEXT_DIRECTION_FIRST_STRONG_LTR, tv.getRawTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_FIRST_STRONG_RTL);
        assertEquals(View.TEXT_DIRECTION_FIRST_STRONG_RTL, tv.getRawTextDirection());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetResolvedTextDirectionLtr"	"CtsWidgetTestCases"	"2: direct ui"	"public void testGetResolvedTextDirectionLtr() {
        TextView tv = new TextView(mActivity);
        tv.setText(""this is a test"");

        assertEquals(View.TEXT_DIRECTION_FIRST_STRONG, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_FIRST_STRONG);
        assertEquals(View.TEXT_DIRECTION_FIRST_STRONG, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_ANY_RTL);
        assertEquals(View.TEXT_DIRECTION_ANY_RTL, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_INHERIT);
        assertEquals(View.TEXT_DIRECTION_FIRST_STRONG, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_LTR);
        assertEquals(View.TEXT_DIRECTION_LTR, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_RTL);
        assertEquals(View.TEXT_DIRECTION_RTL, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_LOCALE);
        assertEquals(View.TEXT_DIRECTION_LOCALE, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_FIRST_STRONG_LTR);
        assertEquals(View.TEXT_DIRECTION_FIRST_STRONG_LTR, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_FIRST_STRONG_RTL);
        assertEquals(View.TEXT_DIRECTION_FIRST_STRONG_RTL, tv.getTextDirection());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetResolvedTextDirectionLtrWithInheritance"	"CtsWidgetTestCases"	"2: direct ui"	"public void testGetResolvedTextDirectionLtrWithInheritance() {
        LinearLayout ll = new LinearLayout(mActivity);
        ll.setTextDirection(View.TEXT_DIRECTION_ANY_RTL);

        TextView tv = new TextView(mActivity);
        tv.setText(""this is a test"");
        ll.addView(tv);

        tv.setTextDirection(View.TEXT_DIRECTION_FIRST_STRONG);
        assertEquals(View.TEXT_DIRECTION_FIRST_STRONG, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_ANY_RTL);
        assertEquals(View.TEXT_DIRECTION_ANY_RTL, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_INHERIT);
        assertEquals(View.TEXT_DIRECTION_ANY_RTL, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_LTR);
        assertEquals(View.TEXT_DIRECTION_LTR, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_RTL);
        assertEquals(View.TEXT_DIRECTION_RTL, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_LOCALE);
        assertEquals(View.TEXT_DIRECTION_LOCALE, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_FIRST_STRONG_LTR);
        assertEquals(View.TEXT_DIRECTION_FIRST_STRONG_LTR, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_FIRST_STRONG_RTL);
        assertEquals(View.TEXT_DIRECTION_FIRST_STRONG_RTL, tv.getTextDirection());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetResolvedTextDirectionRtl"	"CtsWidgetTestCases"	"2: direct ui"	"public void testGetResolvedTextDirectionRtl() {
        TextView tv = new TextView(mActivity);
        tv.setText(""\u05DD\u05DE""); // hebrew

        assertEquals(View.TEXT_DIRECTION_FIRST_STRONG, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_FIRST_STRONG);
        assertEquals(View.TEXT_DIRECTION_FIRST_STRONG, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_ANY_RTL);
        assertEquals(View.TEXT_DIRECTION_ANY_RTL, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_INHERIT);
        assertEquals(View.TEXT_DIRECTION_FIRST_STRONG, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_LTR);
        assertEquals(View.TEXT_DIRECTION_LTR, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_RTL);
        assertEquals(View.TEXT_DIRECTION_RTL, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_LOCALE);
        assertEquals(View.TEXT_DIRECTION_LOCALE, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_FIRST_STRONG_LTR);
        assertEquals(View.TEXT_DIRECTION_FIRST_STRONG_LTR, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_FIRST_STRONG_RTL);
        assertEquals(View.TEXT_DIRECTION_FIRST_STRONG_RTL, tv.getTextDirection());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetResolvedTextDirectionRtlWithInheritance"	"CtsWidgetTestCases"	"2: direct ui"	"public void testGetResolvedTextDirectionRtlWithInheritance() {
        LinearLayout ll = new LinearLayout(mActivity);
        ll.setTextDirection(View.TEXT_DIRECTION_FIRST_STRONG);

        TextView tv = new TextView(mActivity);
        tv.setText(""\u05DD\u05DE""); // hebrew
        ll.addView(tv);

        tv.setTextDirection(View.TEXT_DIRECTION_FIRST_STRONG);
        assertEquals(View.TEXT_DIRECTION_FIRST_STRONG, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_ANY_RTL);
        assertEquals(View.TEXT_DIRECTION_ANY_RTL, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_INHERIT);
        assertEquals(View.TEXT_DIRECTION_FIRST_STRONG, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_LTR);
        assertEquals(View.TEXT_DIRECTION_LTR, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_RTL);
        assertEquals(View.TEXT_DIRECTION_RTL, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_LOCALE);
        assertEquals(View.TEXT_DIRECTION_LOCALE, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_FIRST_STRONG_LTR);
        assertEquals(View.TEXT_DIRECTION_FIRST_STRONG_LTR, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_FIRST_STRONG_RTL);
        assertEquals(View.TEXT_DIRECTION_FIRST_STRONG_RTL, tv.getTextDirection());

        // Force to RTL text direction on the layout
        ll.setTextDirection(View.TEXT_DIRECTION_RTL);

        tv.setTextDirection(View.TEXT_DIRECTION_FIRST_STRONG);
        assertEquals(View.TEXT_DIRECTION_FIRST_STRONG, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_ANY_RTL);
        assertEquals(View.TEXT_DIRECTION_ANY_RTL, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_INHERIT);
        assertEquals(View.TEXT_DIRECTION_RTL, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_LTR);
        assertEquals(View.TEXT_DIRECTION_LTR, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_RTL);
        assertEquals(View.TEXT_DIRECTION_RTL, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_LOCALE);
        assertEquals(View.TEXT_DIRECTION_LOCALE, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_FIRST_STRONG_LTR);
        assertEquals(View.TEXT_DIRECTION_FIRST_STRONG_LTR, tv.getTextDirection());

        tv.setTextDirection(View.TEXT_DIRECTION_FIRST_STRONG_RTL);
        assertEquals(View.TEXT_DIRECTION_FIRST_STRONG_RTL, tv.getTextDirection());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testResetTextDirection"	"CtsWidgetTestCases"	"2: direct ui"	"public void testResetTextDirection() {
        LinearLayout ll = (LinearLayout) mActivity.findViewById(R.id.layout_textviewtest);
        TextView tv = (TextView) mActivity.findViewById(R.id.textview_rtl);

        ll.setTextDirection(View.TEXT_DIRECTION_RTL);
        tv.setTextDirection(View.TEXT_DIRECTION_INHERIT);
        assertEquals(View.TEXT_DIRECTION_RTL, tv.getTextDirection());

        // No reset when we remove the view
        ll.removeView(tv);
        assertEquals(View.TEXT_DIRECTION_RTL, tv.getTextDirection());

        // Reset is done when we add the view
        ll.addView(tv);
        assertEquals(View.TEXT_DIRECTION_FIRST_STRONG, tv.getTextDirection());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testTextDirectionFirstStrongLtr"	"CtsWidgetTestCases"	"2: direct ui"	"public void testTextDirectionFirstStrongLtr() {
        {
            // The first directional character is LTR, the paragraph direction is LTR.
            LinearLayout ll = new LinearLayout(mActivity);

            TextView tv = new TextView(mActivity);
            tv.setText(""this is a test"");
            ll.addView(tv);

            tv.setTextDirection(View.TEXT_DIRECTION_FIRST_STRONG_LTR);
            assertEquals(View.TEXT_DIRECTION_FIRST_STRONG_LTR, tv.getTextDirection());

            tv.onPreDraw();  // For freezing layout.
            Layout layout = tv.getLayout();
            assertEquals(Layout.DIR_LEFT_TO_RIGHT, layout.getParagraphDirection(0));
        }
        {
            // The first directional character is RTL, the paragraph direction is RTL.
            LinearLayout ll = new LinearLayout(mActivity);

            TextView tv = new TextView(mActivity);
            tv.setText(""\u05DD\u05DE""); // Hebrew
            ll.addView(tv);

            tv.setTextDirection(View.TEXT_DIRECTION_FIRST_STRONG_LTR);
            assertEquals(View.TEXT_DIRECTION_FIRST_STRONG_LTR, tv.getTextDirection());

            tv.onPreDraw();  // For freezing layout.
            Layout layout = tv.getLayout();
            assertEquals(Layout.DIR_RIGHT_TO_LEFT, layout.getParagraphDirection(0));
        }
        {
            // The first directional character is not a strong directional character, the paragraph
            // direction is LTR.
            LinearLayout ll = new LinearLayout(mActivity);

            TextView tv = new TextView(mActivity);
            tv.setText(""\uFFFD"");  // REPLACEMENT CHARACTER. Neutral direction.
            ll.addView(tv);

            tv.setTextDirection(View.TEXT_DIRECTION_FIRST_STRONG_LTR);
            assertEquals(View.TEXT_DIRECTION_FIRST_STRONG_LTR, tv.getTextDirection());

            tv.onPreDraw();  // For freezing layout.
            Layout layout = tv.getLayout();
            assertEquals(Layout.DIR_LEFT_TO_RIGHT, layout.getParagraphDirection(0));
        }
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testTextDirectionFirstStrongRtl"	"CtsWidgetTestCases"	"2: direct ui"	"public void testTextDirectionFirstStrongRtl() {
        {
            // The first directional character is LTR, the paragraph direction is LTR.
            LinearLayout ll = new LinearLayout(mActivity);

            TextView tv = new TextView(mActivity);
            tv.setText(""this is a test"");
            ll.addView(tv);

            tv.setTextDirection(View.TEXT_DIRECTION_FIRST_STRONG_RTL);
            assertEquals(View.TEXT_DIRECTION_FIRST_STRONG_RTL, tv.getTextDirection());

            tv.onPreDraw();  // For freezing layout.
            Layout layout = tv.getLayout();
            assertEquals(Layout.DIR_LEFT_TO_RIGHT, layout.getParagraphDirection(0));
        }
        {
            // The first directional character is RTL, the paragraph direction is RTL.
            LinearLayout ll = new LinearLayout(mActivity);

            TextView tv = new TextView(mActivity);
            tv.setText(""\u05DD\u05DE""); // Hebrew
            ll.addView(tv);

            tv.setTextDirection(View.TEXT_DIRECTION_FIRST_STRONG_RTL);
            assertEquals(View.TEXT_DIRECTION_FIRST_STRONG_RTL, tv.getTextDirection());

            tv.onPreDraw();  // For freezing layout.
            Layout layout = tv.getLayout();
            assertEquals(Layout.DIR_RIGHT_TO_LEFT, layout.getParagraphDirection(0));
        }
        {
            // The first directional character is not a strong directional character, the paragraph
            // direction is RTL.
            LinearLayout ll = new LinearLayout(mActivity);

            TextView tv = new TextView(mActivity);
            tv.setText(""\uFFFD"");  // REPLACEMENT CHARACTER. Neutral direction.
            ll.addView(tv);

            tv.setTextDirection(View.TEXT_DIRECTION_FIRST_STRONG_RTL);
            assertEquals(View.TEXT_DIRECTION_FIRST_STRONG_RTL, tv.getTextDirection());

            tv.onPreDraw();  // For freezing layout.
            Layout layout = tv.getLayout();
            assertEquals(Layout.DIR_RIGHT_TO_LEFT, layout.getParagraphDirection(0));
        }
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testDrawableResolution"	"CtsWidgetTestCases"	"2: direct ui"	"public void testDrawableResolution() {
        // Case 1.1: left / right drawable defined in default LTR mode
        TextView tv = (TextView) mActivity.findViewById(R.id.textview_drawable_1_1);
        TestUtils.verifyCompoundDrawables(tv, R.drawable.icon_blue, R.drawable.icon_red,
                R.drawable.icon_green, R.drawable.icon_yellow);
        TestUtils.verifyCompoundDrawablesRelative(tv, -1, -1,
                R.drawable.icon_green, R.drawable.icon_yellow);

        // Case 1.2: left / right drawable defined in default RTL mode
        tv = (TextView) mActivity.findViewById(R.id.textview_drawable_1_2);
        TestUtils.verifyCompoundDrawables(tv, R.drawable.icon_blue, R.drawable.icon_red,
                R.drawable.icon_green, R.drawable.icon_yellow);
        TestUtils.verifyCompoundDrawablesRelative(tv, -1, -1,
                R.drawable.icon_green, R.drawable.icon_yellow);

        // Case 2.1: start / end drawable defined in LTR mode
        tv = (TextView) mActivity.findViewById(R.id.textview_drawable_2_1);
        TestUtils.verifyCompoundDrawables(tv, R.drawable.icon_blue, R.drawable.icon_red,
                R.drawable.icon_green, R.drawable.icon_yellow);
        TestUtils.verifyCompoundDrawablesRelative(tv, R.drawable.icon_blue, R.drawable.icon_red,
                R.drawable.icon_green, R.drawable.icon_yellow);

        // Case 2.2: start / end drawable defined in RTL mode
        tv = (TextView) mActivity.findViewById(R.id.textview_drawable_2_2);
        TestUtils.verifyCompoundDrawables(tv, R.drawable.icon_red, R.drawable.icon_blue,
                R.drawable.icon_green, R.drawable.icon_yellow);
        TestUtils.verifyCompoundDrawablesRelative(tv, R.drawable.icon_blue, R.drawable.icon_red,
                R.drawable.icon_green, R.drawable.icon_yellow);

        // Case 3.1: left / right / start / end drawable defined in LTR mode
        tv = (TextView) mActivity.findViewById(R.id.textview_drawable_3_1);
        TestUtils.verifyCompoundDrawables(tv, R.drawable.icon_blue, R.drawable.icon_red,
                R.drawable.icon_green, R.drawable.icon_yellow);
        TestUtils.verifyCompoundDrawablesRelative(tv, R.drawable.icon_blue, R.drawable.icon_red,
                R.drawable.icon_green, R.drawable.icon_yellow);

        // Case 3.2: left / right / start / end drawable defined in RTL mode
        tv = (TextView) mActivity.findViewById(R.id.textview_drawable_3_2);
        TestUtils.verifyCompoundDrawables(tv, R.drawable.icon_red, R.drawable.icon_blue,
                R.drawable.icon_green, R.drawable.icon_yellow);
        TestUtils.verifyCompoundDrawablesRelative(tv, R.drawable.icon_blue, R.drawable.icon_red,
                R.drawable.icon_green, R.drawable.icon_yellow);

        // Case 4.1: start / end drawable defined in LTR mode inside a layout
        // that defines the layout direction
        tv = (TextView) mActivity.findViewById(R.id.textview_drawable_4_1);
        TestUtils.verifyCompoundDrawables(tv, R.drawable.icon_blue, R.drawable.icon_red,
                R.drawable.icon_green, R.drawable.icon_yellow);
        TestUtils.verifyCompoundDrawablesRelative(tv, R.drawable.icon_blue, R.drawable.icon_red,
                R.drawable.icon_green, R.drawable.icon_yellow);

        // Case 4.2: start / end drawable defined in RTL mode inside a layout
        // that defines the layout direction
        tv = (TextView) mActivity.findViewById(R.id.textview_drawable_4_2);
        TestUtils.verifyCompoundDrawables(tv, R.drawable.icon_red, R.drawable.icon_blue,
                R.drawable.icon_green, R.drawable.icon_yellow);
        TestUtils.verifyCompoundDrawablesRelative(tv, R.drawable.icon_blue, R.drawable.icon_red,
                R.drawable.icon_green, R.drawable.icon_yellow);

        // Case 5.1: left / right / start / end drawable defined in LTR mode inside a layout
        // that defines the layout direction
        tv = (TextView) mActivity.findViewById(R.id.textview_drawable_5_1);
        TestUtils.verifyCompoundDrawables(tv, R.drawable.icon_blue, R.drawable.icon_red,
                R.drawable.icon_green, R.drawable.icon_yellow);
        TestUtils.verifyCompoundDrawablesRelative(tv, R.drawable.icon_blue, R.drawable.icon_red,
                R.drawable.icon_green, R.drawable.icon_yellow);

        // Case 5.2: left / right / start / end drawable defined in RTL mode inside a layout
        // that defines the layout direction
        tv = (TextView) mActivity.findViewById(R.id.textview_drawable_5_2);
        TestUtils.verifyCompoundDrawables(tv, R.drawable.icon_red, R.drawable.icon_blue,
                R.drawable.icon_green, R.drawable.icon_yellow);
        TestUtils.verifyCompoundDrawablesRelative(tv, R.drawable.icon_blue, R.drawable.icon_red,
                R.drawable.icon_green, R.drawable.icon_yellow);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetTextDirectionHeuristic_password_returnsLTR"	"CtsWidgetTestCases"	"2: direct ui"	"@UiThreadTest
    public void testGetTextDirectionHeuristic_password_returnsLTR() {
        mActivity.setContentView(R.layout.textview_textdirectionheuristic);
        final TextView textView = mActivity.findViewById(R.id.text_password);

        assertEquals(TextDirectionHeuristics.LTR, textView.getTextDirectionHeuristic());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetTextDirectionHeuristic_LtrLayout_TextDirectionFirstStrong"	"CtsWidgetTestCases"	"2: direct ui"	"@UiThreadTest
    public void testGetTextDirectionHeuristic_LtrLayout_TextDirectionFirstStrong() {
        mActivity.setContentView(R.layout.textview_textdirectionheuristic);
        final TextView textView = mActivity.findViewById(R.id.text);
        textView.setTextDirection(View.TEXT_DIRECTION_FIRST_STRONG);
        textView.setLayoutDirection(View.LAYOUT_DIRECTION_LTR);

        assertEquals(TextDirectionHeuristics.FIRSTSTRONG_LTR, textView.getTextDirectionHeuristic());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetTextDirectionHeuristic_RtlLayout_TextDirectionFirstStrong"	"CtsWidgetTestCases"	"2: direct ui"	"@UiThreadTest
    public void testGetTextDirectionHeuristic_RtlLayout_TextDirectionFirstStrong() {
        mActivity.setContentView(R.layout.textview_textdirectionheuristic);
        final TextView textView = mActivity.findViewById(R.id.text);
        textView.setTextDirection(View.TEXT_DIRECTION_FIRST_STRONG);
        textView.setLayoutDirection(View.LAYOUT_DIRECTION_RTL);

        assertEquals(TextDirectionHeuristics.FIRSTSTRONG_RTL, textView.getTextDirectionHeuristic());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetTextDirectionHeuristic_RtlLayout_TextDirectionAnyRtl"	"CtsWidgetTestCases"	"2: direct ui"	"@UiThreadTest
    public void testGetTextDirectionHeuristic_RtlLayout_TextDirectionAnyRtl() {
        mActivity.setContentView(R.layout.textview_textdirectionheuristic);
        final TextView textView = mActivity.findViewById(R.id.text);
        textView.setTextDirection(View.TEXT_DIRECTION_ANY_RTL);

        textView.setLayoutDirection(View.LAYOUT_DIRECTION_RTL);
        assertEquals(TextDirectionHeuristics.ANYRTL_LTR, textView.getTextDirectionHeuristic());

        textView.setLayoutDirection(View.LAYOUT_DIRECTION_LTR);
        assertEquals(TextDirectionHeuristics.ANYRTL_LTR, textView.getTextDirectionHeuristic());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetTextDirectionHeuristic_RtlLayout_TextDirectionLtr"	"CtsWidgetTestCases"	"2: direct ui"	"@UiThreadTest
    public void testGetTextDirectionHeuristic_RtlLayout_TextDirectionLtr() {
        mActivity.setContentView(R.layout.textview_textdirectionheuristic);
        final TextView textView = mActivity.findViewById(R.id.text);
        textView.setTextDirection(View.TEXT_DIRECTION_LTR);

        assertEquals(TextDirectionHeuristics.LTR, textView.getTextDirectionHeuristic());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetTextDirectionHeuristic_RtlLayout_TextDirectionRtl"	"CtsWidgetTestCases"	"2: direct ui"	"@UiThreadTest
    public void testGetTextDirectionHeuristic_RtlLayout_TextDirectionRtl() {
        mActivity.setContentView(R.layout.textview_textdirectionheuristic);
        final TextView textView = mActivity.findViewById(R.id.text);
        textView.setTextDirection(View.TEXT_DIRECTION_RTL);

        assertEquals(TextDirectionHeuristics.RTL, textView.getTextDirectionHeuristic());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetTextDirectionHeuristic_RtlLayout_TextDirectionFirstStrongLtr"	"CtsWidgetTestCases"	"2: direct ui"	"@UiThreadTest
    public void testGetTextDirectionHeuristic_RtlLayout_TextDirectionFirstStrongLtr() {
        mActivity.setContentView(R.layout.textview_textdirectionheuristic);
        final TextView textView = mActivity.findViewById(R.id.text);
        textView.setTextDirection(View.TEXT_DIRECTION_FIRST_STRONG_LTR);

        textView.setLayoutDirection(View.LAYOUT_DIRECTION_RTL);
        assertEquals(TextDirectionHeuristics.FIRSTSTRONG_LTR, textView.getTextDirectionHeuristic());

        textView.setLayoutDirection(View.LAYOUT_DIRECTION_LTR);
        assertEquals(TextDirectionHeuristics.FIRSTSTRONG_LTR, textView.getTextDirectionHeuristic());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetTextDirectionHeuristic_RtlLayout_TextDirectionFirstStrongRtl"	"CtsWidgetTestCases"	"2: direct ui"	"@UiThreadTest
    public void testGetTextDirectionHeuristic_RtlLayout_TextDirectionFirstStrongRtl() {
        mActivity.setContentView(R.layout.textview_textdirectionheuristic);
        final TextView textView = mActivity.findViewById(R.id.text);
        textView.setTextDirection(View.TEXT_DIRECTION_FIRST_STRONG_RTL);

        textView.setLayoutDirection(View.LAYOUT_DIRECTION_RTL);
        assertEquals(TextDirectionHeuristics.FIRSTSTRONG_RTL, textView.getTextDirectionHeuristic());

        textView.setLayoutDirection(View.LAYOUT_DIRECTION_LTR);
        assertEquals(TextDirectionHeuristics.FIRSTSTRONG_RTL, textView.getTextDirectionHeuristic());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetTextDirectionHeuristic_phoneInputType_returnsLTR"	"CtsWidgetTestCases"	"2: direct ui"	"@UiThreadTest
    public void testGetTextDirectionHeuristic_phoneInputType_returnsLTR() {
        mActivity.setContentView(R.layout.textview_textdirectionheuristic);
        final TextView textView = mActivity.findViewById(R.id.text_phone);

        textView.setTextLocale(Locale.forLanguageTag(""ar""));
        textView.setTextDirection(View.TEXT_DIRECTION_RTL);
        textView.setLayoutDirection(View.LAYOUT_DIRECTION_RTL);

        assertEquals(TextDirectionHeuristics.LTR, textView.getTextDirectionHeuristic());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetTextDirectionHeuristic_RtlLayout_TextDirectionLocale"	"CtsWidgetTestCases"	"2: direct ui"	"@UiThreadTest
    public void testGetTextDirectionHeuristic_RtlLayout_TextDirectionLocale() {
        mActivity.setContentView(R.layout.textview_textdirectionheuristic);
        final TextView textView = mActivity.findViewById(R.id.text);
        textView.setTextDirection(View.TEXT_DIRECTION_LOCALE);

        assertEquals(TextDirectionHeuristics.LOCALE, textView.getTextDirectionHeuristic());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testConstructorOnUiThread"	"CtsWidgetTestCases"	"1: ui"	"public void testConstructorOnUiThread() {
        verifyConstructor();
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testConstructorOffUiThread"	"CtsWidgetTestCases"	"1: ui"	"public void testConstructorOffUiThread() {
        verifyConstructor();
    }

    private void verifyConstructor() {
        new TextView(mActivity);
        new TextView(mActivity, null);
        new TextView(mActivity, null, android.R.attr.textViewStyle);
        new TextView(mActivity, null, 0, android.R.style.Widget_DeviceDefault_TextView);
        new TextView(mActivity, null, 0, android.R.style.Widget_DeviceDefault_Light_TextView);
        new TextView(mActivity, null, 0, android.R.style.Widget_Material_TextView);
        new TextView(mActivity, null, 0, android.R.style.Widget_Material_Light_TextView);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAccessText"	"CtsWidgetTestCases"	"1: ui"	"public void testAccessText() {
        TextView tv = findTextView(R.id.textview_text);

        String expected = mActivity.getResources().getString(R.string.text_view_hello);
        tv.setText(expected);
        assertEquals(expected, tv.getText().toString());

        tv.setText(null);
        assertEquals("""", tv.getText().toString());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetLayout"	"CtsWidgetTestCases"	"1: ui"	"public void testGetLayout() throws Throwable {
        mActivityRule.runOnUiThread(() -> {
            mTextView = findTextView(R.id.textview_text);
            mTextView.setGravity(Gravity.CENTER);
        });
        mInstrumentation.waitForIdleSync();
        assertNotNull(mTextView.getLayout());

        TestLayoutRunnable runnable = new TestLayoutRunnable(mTextView) {
            public void run() {
                // change the text of TextView.
                mTextView.setText(""Hello, Android!"");
                saveLayout();
            }
        };
        mActivityRule.runOnUiThread(runnable);
        mInstrumentation.waitForIdleSync();
        assertNull(runnable.getLayout());
        assertNotNull(mTextView.getLayout());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAccessKeyListener"	"CtsWidgetTestCases"	"1: ui"	"public void testAccessKeyListener() throws Throwable {
        mActivityRule.runOnUiThread(() -> mTextView = findTextView(R.id.textview_text));
        mInstrumentation.waitForIdleSync();

        assertNull(mTextView.getKeyListener());

        final KeyListener digitsKeyListener = DigitsKeyListener.getInstance();

        mActivityRule.runOnUiThread(() -> mTextView.setKeyListener(digitsKeyListener));
        mInstrumentation.waitForIdleSync();
        assertSame(digitsKeyListener, mTextView.getKeyListener());

        final QwertyKeyListener qwertyKeyListener
                = QwertyKeyListener.getInstance(false, Capitalize.NONE);
        mActivityRule.runOnUiThread(() -> mTextView.setKeyListener(qwertyKeyListener));
        mInstrumentation.waitForIdleSync();
        assertSame(qwertyKeyListener, mTextView.getKeyListener());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testFontWeightAdjustment_forceBoldTextEnabled_textIsBolded"	"CtsWidgetTestCases"	"1: ui"	"public void testFontWeightAdjustment_forceBoldTextEnabled_textIsBolded() throws Throwable {
        mActivityRule.runOnUiThread(() -> mTextView = findTextView(R.id.textview_text));
        mInstrumentation.waitForIdleSync();

        assertEquals(FontStyle.FONT_WEIGHT_NORMAL, mTextView.getTypeface().getWeight());

        Configuration cf = new Configuration();
        cf.fontWeightAdjustment = BOLD_TEXT_ADJUSTMENT;
        mActivityRule.runOnUiThread(() -> mTextView.dispatchConfigurationChanged(cf));
        mInstrumentation.waitForIdleSync();

        Typeface forceBoldedPaintTf = mTextView.getPaint().getTypeface();
        assertEquals(FontStyle.FONT_WEIGHT_BOLD, forceBoldedPaintTf.getWeight());
        assertEquals(FontStyle.FONT_WEIGHT_NORMAL, mTextView.getTypeface().getWeight());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testFontWeightAdjustment_forceBoldTextDisabled_textIsUnbolded"	"CtsWidgetTestCases"	"1: ui"	"public void testFontWeightAdjustment_forceBoldTextDisabled_textIsUnbolded() throws Throwable {
        Configuration cf = new Configuration();
        cf.fontWeightAdjustment = BOLD_TEXT_ADJUSTMENT;
        mActivityRule.runOnUiThread(() -> {
            mTextView = findTextView(R.id.textview_text);
            mTextView.dispatchConfigurationChanged(cf);
            cf.fontWeightAdjustment = 0;
            mTextView.dispatchConfigurationChanged(cf);
        });
        mInstrumentation.waitForIdleSync();

        Typeface forceUnboldedPaintTf = mTextView.getPaint().getTypeface();
        assertEquals(FontStyle.FONT_WEIGHT_NORMAL, forceUnboldedPaintTf.getWeight());
        assertEquals(FontStyle.FONT_WEIGHT_NORMAL, mTextView.getTypeface().getWeight());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testFontWeightAdjustment_forceBoldTextEnabled_originalTypefaceKeptWhenEnabled"	"CtsWidgetTestCases"	"1: ui"	"public void testFontWeightAdjustment_forceBoldTextEnabled_originalTypefaceKeptWhenEnabled()
            throws Throwable {
        mActivityRule.runOnUiThread(() -> {
            mTextView = findTextView(R.id.textview_text);
            Configuration cf = new Configuration();
            cf.fontWeightAdjustment = BOLD_TEXT_ADJUSTMENT;
            mTextView.dispatchConfigurationChanged(cf);
            mTextView.setTypeface(Typeface.MONOSPACE);
        });
        mInstrumentation.waitForIdleSync();

        assertEquals(Typeface.MONOSPACE, mTextView.getTypeface());

        Typeface forceBoldedPaintTf = mTextView.getPaint().getTypeface();
        assertTrue(forceBoldedPaintTf.isBold());
        assertEquals(Typeface.create(Typeface.MONOSPACE,
                FontStyle.FONT_WEIGHT_BOLD, false), forceBoldedPaintTf);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testFontWeightAdjustment_forceBoldTextDisabled_originalTypefaceIsKept"	"CtsWidgetTestCases"	"1: ui"	"public void testFontWeightAdjustment_forceBoldTextDisabled_originalTypefaceIsKept()
            throws Throwable {
        mActivityRule.runOnUiThread(() -> {
            mTextView = findTextView(R.id.textview_text);
            Configuration cf = new Configuration();
            cf.fontWeightAdjustment = 0;
            mTextView.dispatchConfigurationChanged(cf);
            mTextView.setTypeface(Typeface.MONOSPACE);
        });
        mInstrumentation.waitForIdleSync();

        assertEquals(Typeface.MONOSPACE, mTextView.getTypeface());
        assertEquals(Typeface.MONOSPACE, mTextView.getPaint().getTypeface());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testFontWeightAdjustment_forceBoldTextEnabled_boldTypefaceIsBolded"	"CtsWidgetTestCases"	"1: ui"	"public void testFontWeightAdjustment_forceBoldTextEnabled_boldTypefaceIsBolded()
            throws Throwable {
        Typeface originalTypeface = Typeface.create(Typeface.MONOSPACE, Typeface.BOLD);
        mActivityRule.runOnUiThread(() -> {
            mTextView = findTextView(R.id.textview_text);
            Configuration cf = new Configuration();
            cf.fontWeightAdjustment = BOLD_TEXT_ADJUSTMENT;
            mTextView.dispatchConfigurationChanged(cf);
            mTextView.setTypeface(originalTypeface);
        });
        mInstrumentation.waitForIdleSync();

        assertEquals(originalTypeface, mTextView.getTypeface());
        assertEquals(FontStyle.FONT_WEIGHT_MAX,
                mTextView.getPaint().getTypeface().getWeight());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testFontWeightAdjustment_adjustmentIsNegative_fontWeightIsLower"	"CtsWidgetTestCases"	"1: ui"	"public void testFontWeightAdjustment_adjustmentIsNegative_fontWeightIsLower() throws Throwable {
        mActivityRule.runOnUiThread(() -> {
            mTextView = findTextView(R.id.textview_text);
            Configuration cf = new Configuration();
            cf.fontWeightAdjustment = -200;
            mTextView.dispatchConfigurationChanged(cf);
            mTextView.setTypeface(Typeface.MONOSPACE);
        });
        mInstrumentation.waitForIdleSync();

        assertEquals(Typeface.MONOSPACE, mTextView.getTypeface());
        assertEquals(200, mTextView.getPaint().getTypeface().getWeight());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testFontWeightAdjustment_adjustmentIsNegative_fontWeightIsMinimum"	"CtsWidgetTestCases"	"1: ui"	"public void testFontWeightAdjustment_adjustmentIsNegative_fontWeightIsMinimum()
            throws Throwable {
        mActivityRule.runOnUiThread(() -> {
            mTextView = findTextView(R.id.textview_text);
            Configuration cf = new Configuration();
            cf.fontWeightAdjustment = -500;
            mTextView.dispatchConfigurationChanged(cf);
            mTextView.setTypeface(Typeface.MONOSPACE);
        });
        mInstrumentation.waitForIdleSync();

        assertEquals(Typeface.MONOSPACE, mTextView.getTypeface());
        assertEquals(FontStyle.FONT_WEIGHT_MIN,
                mTextView.getPaint().getTypeface().getWeight());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAccessMovementMethod"	"CtsWidgetTestCases"	"1: ui"	"public void testAccessMovementMethod() throws Throwable {
        final CharSequence LONG_TEXT = ""Scrolls the specified widget to the specified ""
                + ""coordinates, except constrains the X scrolling position to the horizontal ""
                + ""regions of the text that will be visible after scrolling to ""
                + ""the specified Y position."";
        final int selectionStart = 10;
        final int selectionEnd = LONG_TEXT.length();
        final MovementMethod movementMethod = ArrowKeyMovementMethod.getInstance();
        mActivityRule.runOnUiThread(() -> {
            mTextView = findTextView(R.id.textview_text);
            mTextView.setMovementMethod(movementMethod);
            mTextView.setText(LONG_TEXT, BufferType.EDITABLE);
            Selection.setSelection((Editable) mTextView.getText(),
                    selectionStart, selectionEnd);
            mTextView.requestFocus();
        });
        mInstrumentation.waitForIdleSync();

        assertSame(movementMethod, mTextView.getMovementMethod());
        assertEquals(selectionStart, Selection.getSelectionStart(mTextView.getText()));
        assertEquals(selectionEnd, Selection.getSelectionEnd(mTextView.getText()));
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_SHIFT_LEFT,
                KeyEvent.KEYCODE_ALT_LEFT, KeyEvent.KEYCODE_DPAD_UP);
        // the selection has been removed.
        assertEquals(selectionStart, Selection.getSelectionStart(mTextView.getText()));
        assertEquals(selectionStart, Selection.getSelectionEnd(mTextView.getText()));

        mActivityRule.runOnUiThread(() -> {
            mTextView.setMovementMethod(null);
            Selection.setSelection((Editable) mTextView.getText(),
                    selectionStart, selectionEnd);
            mTextView.requestFocus();
        });
        mInstrumentation.waitForIdleSync();

        assertNull(mTextView.getMovementMethod());
        assertEquals(selectionStart, Selection.getSelectionStart(mTextView.getText()));
        assertEquals(selectionEnd, Selection.getSelectionEnd(mTextView.getText()));
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_SHIFT_LEFT,
                KeyEvent.KEYCODE_ALT_LEFT, KeyEvent.KEYCODE_DPAD_UP);
        // the selection will not be changed.
        assertEquals(selectionStart, Selection.getSelectionStart(mTextView.getText()));
        assertEquals(selectionEnd, Selection.getSelectionEnd(mTextView.getText()));
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testLength"	"CtsWidgetTestCases"	"1: ui"	"public void testLength() {
        mTextView = findTextView(R.id.textview_text);

        String content = ""This is content"";
        mTextView.setText(content);
        assertEquals(content.length(), mTextView.length());

        mTextView.setText("""");
        assertEquals(0, mTextView.length());

        mTextView.setText(null);
        assertEquals(0, mTextView.length());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAccessGravity"	"CtsWidgetTestCases"	"1: ui"	"public void testAccessGravity() {
        mActivity.setContentView(R.layout.textview_gravity);

        mTextView = findTextView(R.id.gravity_default);
        assertEquals(Gravity.TOP | Gravity.START, mTextView.getGravity());

        mTextView = findTextView(R.id.gravity_bottom);
        assertEquals(Gravity.BOTTOM | Gravity.START, mTextView.getGravity());

        mTextView = findTextView(R.id.gravity_right);
        assertEquals(Gravity.TOP | Gravity.RIGHT, mTextView.getGravity());

        mTextView = findTextView(R.id.gravity_center);
        assertEquals(Gravity.CENTER, mTextView.getGravity());

        mTextView = findTextView(R.id.gravity_fill);
        assertEquals(Gravity.FILL, mTextView.getGravity());

        mTextView = findTextView(R.id.gravity_center_vertical_right);
        assertEquals(Gravity.CENTER_VERTICAL | Gravity.RIGHT, mTextView.getGravity());

        mTextView.setGravity(Gravity.BOTTOM | Gravity.CENTER_HORIZONTAL);
        assertEquals(Gravity.BOTTOM | Gravity.CENTER_HORIZONTAL, mTextView.getGravity());
        mTextView.setGravity(Gravity.FILL);
        assertEquals(Gravity.FILL, mTextView.getGravity());
        mTextView.setGravity(Gravity.CENTER);
        assertEquals(Gravity.CENTER, mTextView.getGravity());

        mTextView.setGravity(Gravity.NO_GRAVITY);
        assertEquals(Gravity.TOP | Gravity.START, mTextView.getGravity());

        mTextView.setGravity(Gravity.RIGHT);
        assertEquals(Gravity.TOP | Gravity.RIGHT, mTextView.getGravity());

        mTextView.setGravity(Gravity.FILL_VERTICAL);
        assertEquals(Gravity.FILL_VERTICAL | Gravity.START, mTextView.getGravity());

        //test negative input value.
        mTextView.setGravity(-1);
        assertEquals(-1, mTextView.getGravity());
    }

    @Retention(SOURCE)
    @IntDef({EditorInfo.IME_ACTION_UNSPECIFIED, EditorInfo.IME_ACTION_NONE,
            EditorInfo.IME_ACTION_GO, EditorInfo.IME_ACTION_SEARCH, EditorInfo.IME_ACTION_SEND,
            EditorInfo.IME_ACTION_NEXT, EditorInfo.IME_ACTION_DONE, EditorInfo.IME_ACTION_PREVIOUS})
    private @interface ImeOptionAction {}

    @Retention(SOURCE)
    @IntDef(flag = true,
            value = {EditorInfo.IME_FLAG_NO_PERSONALIZED_LEARNING,
                    EditorInfo.IME_FLAG_NO_FULLSCREEN, EditorInfo.IME_FLAG_NAVIGATE_PREVIOUS,
                    EditorInfo.IME_FLAG_NAVIGATE_NEXT, EditorInfo.IME_FLAG_NO_EXTRACT_UI,
                    EditorInfo.IME_FLAG_NO_ACCESSORY_ACTION, EditorInfo.IME_FLAG_NO_ENTER_ACTION,
                    EditorInfo.IME_FLAG_FORCE_ASCII})
    private @interface ImeOptionFlags {}

    private static void assertImeOptions(TextView textView,
            @ImeOptionAction int expectedImeOptionAction,
            @ImeOptionFlags int expectedImeOptionFlags) {
        final int actualAction = textView.getImeOptions() & EditorInfo.IME_MASK_ACTION;
        final int actualFlags = textView.getImeOptions() & ~EditorInfo.IME_MASK_ACTION;
        assertEquals(expectedImeOptionAction, actualAction);
        assertEquals(expectedImeOptionFlags, actualFlags);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testImeOptions"	"CtsWidgetTestCases"	"1: ui"	"public void testImeOptions() {
        mActivity.setContentView(R.layout.textview_imeoptions);

        // Test ""normal"" to be a synonym EditorInfo.IME_NULL
        assertEquals(EditorInfo.IME_NULL,
                mActivity.<TextView>findViewById(R.id.textview_imeoption_normal).getImeOptions());

        // Test EditorInfo.IME_ACTION_*
        assertImeOptions(
                mActivity.findViewById(R.id.textview_imeoption_action_unspecified),
                EditorInfo.IME_ACTION_UNSPECIFIED, 0);
        assertImeOptions(
                mActivity.findViewById(R.id.textview_imeoption_action_none),
                EditorInfo.IME_ACTION_NONE, 0);
        assertImeOptions(
                mActivity.findViewById(R.id.textview_imeoption_action_go),
                EditorInfo.IME_ACTION_GO, 0);
        assertImeOptions(
                mActivity.findViewById(R.id.textview_imeoption_action_search),
                EditorInfo.IME_ACTION_SEARCH, 0);
        assertImeOptions(
                mActivity.findViewById(R.id.textview_imeoption_action_send),
                EditorInfo.IME_ACTION_SEND, 0);
        assertImeOptions(
                mActivity.findViewById(R.id.textview_imeoption_action_next),
                EditorInfo.IME_ACTION_NEXT, 0);
        assertImeOptions(
                mActivity.findViewById(R.id.textview_imeoption_action_done),
                EditorInfo.IME_ACTION_DONE, 0);
        assertImeOptions(
                mActivity.findViewById(R.id.textview_imeoption_action_previous),
                EditorInfo.IME_ACTION_PREVIOUS, 0);

        // Test EditorInfo.IME_FLAG_*
        assertImeOptions(
                mActivity.findViewById(R.id.textview_imeoption_no_personalized_learning),
                EditorInfo.IME_ACTION_UNSPECIFIED,
                EditorInfo.IME_FLAG_NO_PERSONALIZED_LEARNING);
        assertImeOptions(
                mActivity.findViewById(R.id.textview_imeoption_no_fullscreen),
                EditorInfo.IME_ACTION_UNSPECIFIED,
                EditorInfo.IME_FLAG_NO_FULLSCREEN);
        assertImeOptions(
                mActivity.findViewById(R.id.textview_imeoption_navigation_previous),
                EditorInfo.IME_ACTION_UNSPECIFIED,
                EditorInfo.IME_FLAG_NAVIGATE_PREVIOUS);
        assertImeOptions(
                mActivity.findViewById(R.id.textview_imeoption_navigation_next),
                EditorInfo.IME_ACTION_UNSPECIFIED,
                EditorInfo.IME_FLAG_NAVIGATE_NEXT);
        assertImeOptions(
                mActivity.findViewById(R.id.textview_imeoption_no_extract_ui),
                EditorInfo.IME_ACTION_UNSPECIFIED,
                EditorInfo.IME_FLAG_NO_EXTRACT_UI);
        assertImeOptions(
                mActivity.findViewById(R.id.textview_imeoption_no_accessory_action),
                EditorInfo.IME_ACTION_UNSPECIFIED,
                EditorInfo.IME_FLAG_NO_ACCESSORY_ACTION);
        assertImeOptions(
                mActivity.findViewById(R.id.textview_imeoption_no_enter_action),
                EditorInfo.IME_ACTION_UNSPECIFIED,
                EditorInfo.IME_FLAG_NO_ENTER_ACTION);
        assertImeOptions(
                mActivity.findViewById(R.id.textview_imeoption_force_ascii),
                EditorInfo.IME_ACTION_UNSPECIFIED,
                EditorInfo.IME_FLAG_FORCE_ASCII);

        // test action + multiple flags
        assertImeOptions(
                mActivity.findViewById(
                        R.id.textview_imeoption_action_go_nagivate_next_no_extract_ui_force_ascii),
                EditorInfo.IME_ACTION_GO,
                EditorInfo.IME_FLAG_NAVIGATE_NEXT | EditorInfo.IME_FLAG_NO_EXTRACT_UI
                        | EditorInfo.IME_FLAG_FORCE_ASCII);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAccessAutoLinkMask"	"CtsWidgetTestCases"	"1: ui"	"public void testAccessAutoLinkMask() throws Throwable {
        mTextView = findTextView(R.id.textview_text);
        final CharSequence text1 =
                new SpannableString(""URL: http://www.google.com. mailto: account@gmail.com"");
        mActivityRule.runOnUiThread(() -> {
            mTextView.setAutoLinkMask(Linkify.ALL);
            mTextView.setText(text1, BufferType.EDITABLE);
        });
        mInstrumentation.waitForIdleSync();
        assertEquals(Linkify.ALL, mTextView.getAutoLinkMask());

        Spannable spanString = (Spannable) mTextView.getText();
        URLSpan[] spans = spanString.getSpans(0, spanString.length(), URLSpan.class);
        assertNotNull(spans);
        assertEquals(2, spans.length);
        assertEquals(""http://www.google.com"", spans[0].getURL());
        assertEquals(""mailto:account@gmail.com"", spans[1].getURL());

        final CharSequence text2 =
            new SpannableString(""name: Jack. tel: +41 44 800 8999"");
        mActivityRule.runOnUiThread(() -> {
            mTextView.setAutoLinkMask(Linkify.PHONE_NUMBERS);
            mTextView.setText(text2, BufferType.EDITABLE);
        });
        mInstrumentation.waitForIdleSync();
        assertEquals(Linkify.PHONE_NUMBERS, mTextView.getAutoLinkMask());

        spanString = (Spannable) mTextView.getText();
        spans = spanString.getSpans(0, spanString.length(), URLSpan.class);
        assertNotNull(spans);
        assertEquals(1, spans.length);
        assertEquals(""tel:+41448008999"", spans[0].getURL());

        layout(R.layout.textview_autolink);
        // 1 for web, 2 for email, 4 for phone, 7 for all(web|email|phone)
        assertEquals(0, getAutoLinkMask(R.id.autolink_default));
        assertEquals(Linkify.WEB_URLS, getAutoLinkMask(R.id.autolink_web));
        assertEquals(Linkify.EMAIL_ADDRESSES, getAutoLinkMask(R.id.autolink_email));
        assertEquals(Linkify.PHONE_NUMBERS, getAutoLinkMask(R.id.autolink_phone));
        assertEquals(Linkify.ALL, getAutoLinkMask(R.id.autolink_all));
        assertEquals(Linkify.WEB_URLS | Linkify.EMAIL_ADDRESSES,
                getAutoLinkMask(R.id.autolink_compound1));
        assertEquals(Linkify.WEB_URLS | Linkify.PHONE_NUMBERS,
                getAutoLinkMask(R.id.autolink_compound2));
        assertEquals(Linkify.EMAIL_ADDRESSES | Linkify.PHONE_NUMBERS,
                getAutoLinkMask(R.id.autolink_compound3));
        assertEquals(Linkify.PHONE_NUMBERS | Linkify.ALL,
                getAutoLinkMask(R.id.autolink_compound4));
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAccessTextSize"	"CtsWidgetTestCases"	"1: ui"	"public void testAccessTextSize() {
        DisplayMetrics metrics = mActivity.getResources().getDisplayMetrics();

        mTextView = new TextView(mActivity);
        mTextView.setTextSize(TypedValue.COMPLEX_UNIT_PX, 20f);
        assertEquals(TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_PX, 20f, metrics),
                mTextView.getTextSize(), 0.01f);

        mTextView.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 20f);
        assertEquals(TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 20f, metrics),
                mTextView.getTextSize(), 0.01f);

        mTextView.setTextSize(TypedValue.COMPLEX_UNIT_SP, 20f);
        assertEquals(TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, 20f, metrics),
                mTextView.getTextSize(), 0.01f);

        // setTextSize by default unit ""sp""
        mTextView.setTextSize(20f);
        assertEquals(TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, 20f, metrics),
                mTextView.getTextSize(), 0.01f);

        mTextView.setTextSize(200f);
        assertEquals(TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, 200f, metrics),
                mTextView.getTextSize(), 0.01f);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetTextColor"	"CtsWidgetTestCases"	"1: ui"	"public void testGetTextColor() {
        // TODO: How to get a suitable TypedArray to test this method.

        try {
            TextView.getTextColor(mActivity, null, -1);
            fail(""There should be a NullPointerException thrown out."");
        } catch (NullPointerException e) {
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAccessHighlightColor"	"CtsWidgetTestCases"	"1: ui"	"public void testAccessHighlightColor() throws Throwable {
        final TextView textView = (TextView) mActivity.findViewById(R.id.textview_text);

        mActivityRule.runOnUiThread(() -> {
            textView.setTextIsSelectable(true);
            textView.setText(""abcd"", BufferType.EDITABLE);
            textView.setHighlightColor(Color.BLUE);
        });
        mInstrumentation.waitForIdleSync();

        assertTrue(textView.isTextSelectable());
        assertEquals(Color.BLUE, textView.getHighlightColor());

        // Long click on the text selects all text and shows selection handlers. The view has an
        // attribute layout_width=""wrap_content"", so clicked location (the center of the view)
        // should be on the text.
        CtsTouchUtils.emulateLongPressOnViewCenter(mInstrumentation, mActivityRule, textView);

        // At this point the entire content of our TextView should be selected and highlighted
        // with blue. Now change the highlight to red while the selection is still on.
        mActivityRule.runOnUiThread(() -> textView.setHighlightColor(Color.RED));
        mInstrumentation.waitForIdleSync();

        assertEquals(Color.RED, textView.getHighlightColor());
        assertTrue(TextUtils.equals(""abcd"", textView.getText()));

        // Remove the selection
        mActivityRule.runOnUiThread(() -> Selection.removeSelection((Spannable) textView.getText()));
        mInstrumentation.waitForIdleSync();

        // And switch highlight to green after the selection has been removed
        mActivityRule.runOnUiThread(() -> textView.setHighlightColor(Color.GREEN));
        mInstrumentation.waitForIdleSync();

        assertEquals(Color.GREEN, textView.getHighlightColor());
        assertTrue(TextUtils.equals(""abcd"", textView.getText()));
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetShadowLayer"	"CtsWidgetTestCases"	"1: ui"	"public void testSetShadowLayer() {
        // test values
        final MockTextView mockTextView = new MockTextView(mActivity);

        mockTextView.setShadowLayer(1.0f, 0.3f, 0.4f, Color.CYAN);
        assertEquals(Color.CYAN, mockTextView.getShadowColor());
        assertEquals(0.3f, mockTextView.getShadowDx(), 0.0f);
        assertEquals(0.4f, mockTextView.getShadowDy(), 0.0f);
        assertEquals(1.0f, mockTextView.getShadowRadius(), 0.0f);

        // shadow is placed to the left and below the text
        mockTextView.setShadowLayer(1.0f, 0.3f, 0.3f, Color.CYAN);
        assertTrue(mockTextView.isPaddingOffsetRequired());
        assertEquals(0, mockTextView.getLeftPaddingOffset());
        assertEquals(0, mockTextView.getTopPaddingOffset());
        assertEquals(1, mockTextView.getRightPaddingOffset());
        assertEquals(1, mockTextView.getBottomPaddingOffset());

        // shadow is placed to the right and above the text
        mockTextView.setShadowLayer(1.0f, -0.8f, -0.8f, Color.CYAN);
        assertTrue(mockTextView.isPaddingOffsetRequired());
        assertEquals(-1, mockTextView.getLeftPaddingOffset());
        assertEquals(-1, mockTextView.getTopPaddingOffset());
        assertEquals(0, mockTextView.getRightPaddingOffset());
        assertEquals(0, mockTextView.getBottomPaddingOffset());

        // no shadow
        mockTextView.setShadowLayer(0.0f, 0.0f, 0.0f, Color.CYAN);
        assertFalse(mockTextView.isPaddingOffsetRequired());
        assertEquals(0, mockTextView.getLeftPaddingOffset());
        assertEquals(0, mockTextView.getTopPaddingOffset());
        assertEquals(0, mockTextView.getRightPaddingOffset());
        assertEquals(0, mockTextView.getBottomPaddingOffset());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetSelectAllOnFocus"	"CtsWidgetTestCases"	"1: ui"	"public void testSetSelectAllOnFocus() {
        mActivity.setContentView(R.layout.textview_selectallonfocus);
        String content = ""This is the content"";
        String blank = """";
        mTextView = findTextView(R.id.selectAllOnFocus_default);
        mTextView.setText(blank, BufferType.SPANNABLE);
        // change the focus
        findTextView(R.id.selectAllOnFocus_placeholder).requestFocus();
        assertFalse(mTextView.isFocused());
        mTextView.requestFocus();
        assertTrue(mTextView.isFocused());

        assertEquals(-1, mTextView.getSelectionStart());
        assertEquals(-1, mTextView.getSelectionEnd());

        mTextView.setText(content, BufferType.SPANNABLE);
        mTextView.setSelectAllOnFocus(true);
        // change the focus
        findTextView(R.id.selectAllOnFocus_placeholder).requestFocus();
        assertFalse(mTextView.isFocused());
        mTextView.requestFocus();
        assertTrue(mTextView.isFocused());

        assertEquals(0, mTextView.getSelectionStart());
        assertEquals(content.length(), mTextView.getSelectionEnd());

        Selection.setSelection((Spannable) mTextView.getText(), 0);
        mTextView.setSelectAllOnFocus(false);
        // change the focus
        findTextView(R.id.selectAllOnFocus_placeholder).requestFocus();
        assertFalse(mTextView.isFocused());
        mTextView.requestFocus();
        assertTrue(mTextView.isFocused());

        assertEquals(0, mTextView.getSelectionStart());
        assertEquals(0, mTextView.getSelectionEnd());

        mTextView.setText(blank, BufferType.SPANNABLE);
        mTextView.setSelectAllOnFocus(true);
        // change the focus
        findTextView(R.id.selectAllOnFocus_placeholder).requestFocus();
        assertFalse(mTextView.isFocused());
        mTextView.requestFocus();
        assertTrue(mTextView.isFocused());

        assertEquals(0, mTextView.getSelectionStart());
        assertEquals(blank.length(), mTextView.getSelectionEnd());

        Selection.setSelection((Spannable) mTextView.getText(), 0);
        mTextView.setSelectAllOnFocus(false);
        // change the focus
        findTextView(R.id.selectAllOnFocus_placeholder).requestFocus();
        assertFalse(mTextView.isFocused());
        mTextView.requestFocus();
        assertTrue(mTextView.isFocused());

        assertEquals(0, mTextView.getSelectionStart());
        assertEquals(0, mTextView.getSelectionEnd());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetPaint"	"CtsWidgetTestCases"	"1: ui"	"public void testGetPaint() {
        mTextView = new TextView(mActivity);
        TextPaint tp = mTextView.getPaint();
        assertNotNull(tp);

        assertEquals(mTextView.getPaintFlags(), tp.getFlags());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAccessLinksClickable"	"CtsWidgetTestCases"	"1: ui"	"public void testAccessLinksClickable() {
        mActivity.setContentView(R.layout.textview_hint_linksclickable_freezestext);

        mTextView = findTextView(R.id.hint_linksClickable_freezesText_default);
        assertTrue(mTextView.getLinksClickable());

        mTextView = findTextView(R.id.linksClickable_true);
        assertTrue(mTextView.getLinksClickable());

        mTextView = findTextView(R.id.linksClickable_false);
        assertFalse(mTextView.getLinksClickable());

        mTextView.setLinksClickable(false);
        assertFalse(mTextView.getLinksClickable());

        mTextView.setLinksClickable(true);
        assertTrue(mTextView.getLinksClickable());

        assertNull(mTextView.getMovementMethod());

        final CharSequence text = new SpannableString(""name: Jack. tel: +41 44 800 8999"");

        mTextView.setAutoLinkMask(Linkify.PHONE_NUMBERS);
        mTextView.setText(text, BufferType.EDITABLE);

        // Movement method will be automatically set to LinkMovementMethod
        assertTrue(mTextView.getMovementMethod() instanceof LinkMovementMethod);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAccessHintTextColor"	"CtsWidgetTestCases"	"1: ui"	"public void testAccessHintTextColor() {
        mTextView = new TextView(mActivity);
        // using int values
        // normal
        mTextView.setHintTextColor(Color.GREEN);
        assertEquals(Color.GREEN, mTextView.getCurrentHintTextColor());
        assertSame(ColorStateList.valueOf(Color.GREEN), mTextView.getHintTextColors());

        mTextView.setHintTextColor(Color.BLUE);
        assertSame(ColorStateList.valueOf(Color.BLUE), mTextView.getHintTextColors());
        assertEquals(Color.BLUE, mTextView.getCurrentHintTextColor());

        mTextView.setHintTextColor(Color.RED);
        assertSame(ColorStateList.valueOf(Color.RED), mTextView.getHintTextColors());
        assertEquals(Color.RED, mTextView.getCurrentHintTextColor());

        // using ColorStateList
        // normal
        ColorStateList colors = new ColorStateList(new int[][] {
                new int[] { android.R.attr.state_focused}, new int[0] },
                new int[] { Color.rgb(0, 255, 0), Color.BLACK });
        mTextView.setHintTextColor(colors);
        assertSame(colors, mTextView.getHintTextColors());
        assertEquals(Color.BLACK, mTextView.getCurrentHintTextColor());

        // exceptional
        mTextView.setHintTextColor(null);
        assertNull(mTextView.getHintTextColors());
        assertEquals(mTextView.getCurrentTextColor(), mTextView.getCurrentHintTextColor());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAccessLinkTextColor"	"CtsWidgetTestCases"	"1: ui"	"public void testAccessLinkTextColor() {
        mTextView = new TextView(mActivity);
        // normal
        mTextView.setLinkTextColor(Color.GRAY);
        assertSame(ColorStateList.valueOf(Color.GRAY), mTextView.getLinkTextColors());
        assertEquals(Color.GRAY, mTextView.getPaint().linkColor);

        mTextView.setLinkTextColor(Color.YELLOW);
        assertSame(ColorStateList.valueOf(Color.YELLOW), mTextView.getLinkTextColors());
        assertEquals(Color.YELLOW, mTextView.getPaint().linkColor);

        mTextView.setLinkTextColor(Color.WHITE);
        assertSame(ColorStateList.valueOf(Color.WHITE), mTextView.getLinkTextColors());
        assertEquals(Color.WHITE, mTextView.getPaint().linkColor);

        ColorStateList colors = new ColorStateList(new int[][] {
                new int[] { android.R.attr.state_expanded}, new int[0] },
                new int[] { Color.rgb(0, 255, 0), Color.BLACK });
        mTextView.setLinkTextColor(colors);
        assertSame(colors, mTextView.getLinkTextColors());
        assertEquals(Color.BLACK, mTextView.getPaint().linkColor);

        mTextView.setLinkTextColor(null);
        assertNull(mTextView.getLinkTextColors());
        assertEquals(Color.BLACK, mTextView.getPaint().linkColor);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetMaxLines_toZero_shouldNotDisplayAnyLines"	"CtsWidgetTestCases"	"1: ui"	"public void testSetMaxLines_toZero_shouldNotDisplayAnyLines() throws Throwable {
        mTextView = findTextView(R.id.textview_text);
        mActivityRule.runOnUiThread(() -> {
            mTextView.setPadding(0, 0, 0, 0);
            mTextView.setText(""Single"");
            mTextView.setMaxLines(0);
        });
        mInstrumentation.waitForIdleSync();

        final int expectedHeight = mTextView.getTotalPaddingBottom()
                + mTextView.getTotalPaddingTop();

        assertEquals(expectedHeight, mTextView.getHeight());

        mActivityRule.runOnUiThread(() -> mTextView.setText(""Two\nLines""));
        mInstrumentation.waitForIdleSync();
        assertEquals(expectedHeight, mTextView.getHeight());

        mActivityRule.runOnUiThread(() -> mTextView.setTextIsSelectable(true));
        mInstrumentation.waitForIdleSync();
        assertEquals(expectedHeight, mTextView.getHeight());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetLineSpacing"	"CtsWidgetTestCases"	"1: ui"	"public void testSetLineSpacing() throws Throwable {
        mActivityRule.runOnUiThread(() -> mTextView = new TextView(mActivity));
        mInstrumentation.waitForIdleSync();
        int originalLineHeight = mTextView.getLineHeight();

        // normal
        float add = 1.2f;
        float mult = 1.4f;
        setLineSpacing(add, mult);
        assertEquals(Math.round(originalLineHeight * mult + add), mTextView.getLineHeight());
        add = 0.0f;
        mult = 1.4f;
        setLineSpacing(add, mult);
        assertEquals(Math.round(originalLineHeight * mult + add), mTextView.getLineHeight());

        // abnormal
        add = -1.2f;
        mult = 1.4f;
        setLineSpacing(add, mult);
        assertEquals(Math.round(originalLineHeight * mult + add), mTextView.getLineHeight());
        add = -1.2f;
        mult = -1.4f;
        setLineSpacing(add, mult);
        assertEquals(Math.round(originalLineHeight * mult + add), mTextView.getLineHeight());
        add = 1.2f;
        mult = 0.0f;
        setLineSpacing(add, mult);
        assertEquals(Math.round(originalLineHeight * mult + add), mTextView.getLineHeight());

        // edge
        add = Float.MIN_VALUE;
        mult = Float.MIN_VALUE;
        setLineSpacing(add, mult);
        assertEquals(Math.round(originalLineHeight * mult + add), mTextView.getLineHeight());

        // edge case where the behavior of Math.round() deviates from
        // FastMath.round(), requiring us to use an explicit 0 value
        add = Float.MAX_VALUE;
        mult = Float.MAX_VALUE;
        setLineSpacing(add, mult);
        assertEquals(0, mTextView.getLineHeight());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetElegantLineHeight"	"CtsWidgetTestCases"	"1: ui"	"public void testSetElegantLineHeight() throws Throwable {
        mTextView = findTextView(R.id.textview_text);
        assertFalse(mTextView.getPaint().isElegantTextHeight());
        mActivityRule.runOnUiThread(() -> {
            mTextView.setWidth(mTextView.getWidth() / 3);
            mTextView.setPadding(1, 2, 3, 4);
            mTextView.setGravity(Gravity.BOTTOM);
        });
        mInstrumentation.waitForIdleSync();

        int oldHeight = mTextView.getHeight();
        mActivityRule.runOnUiThread(() -> mTextView.setElegantTextHeight(true));
        mInstrumentation.waitForIdleSync();

        assertTrue(mTextView.getPaint().isElegantTextHeight());
        assertTrue(mTextView.getHeight() > oldHeight);

        mActivityRule.runOnUiThread(() -> mTextView.setElegantTextHeight(false));
        mInstrumentation.waitForIdleSync();
        assertFalse(mTextView.getPaint().isElegantTextHeight());
        assertTrue(mTextView.getHeight() == oldHeight);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAccessFreezesText"	"CtsWidgetTestCases"	"1: ui"	"public void testAccessFreezesText() throws Throwable {
        layout(R.layout.textview_hint_linksclickable_freezestext);

        mTextView = findTextView(R.id.hint_linksClickable_freezesText_default);
        assertFalse(mTextView.getFreezesText());

        mTextView = findTextView(R.id.freezesText_true);
        assertTrue(mTextView.getFreezesText());

        mTextView = findTextView(R.id.freezesText_false);
        assertFalse(mTextView.getFreezesText());

        mTextView.setFreezesText(false);
        assertFalse(mTextView.getFreezesText());

        final CharSequence text = ""Hello, TextView."";
        mActivityRule.runOnUiThread(() -> mTextView.setText(text));
        mInstrumentation.waitForIdleSync();

        final URLSpan urlSpan = new URLSpan(""ctstest://TextView/test"");
        // TODO: How to simulate the TextView in frozen icicles.
        ActivityMonitor am = mInstrumentation.addMonitor(MockURLSpanTestActivity.class.getName(),
                null, false);

        mActivityRule.runOnUiThread(() -> {
            Uri uri = Uri.parse(urlSpan.getURL());
            Intent intent = new Intent(Intent.ACTION_VIEW, uri);
            mActivity.startActivity(intent);
        });

        Activity newActivity = am.waitForActivityWithTimeout(TIMEOUT);
        assertNotNull(newActivity);
        newActivity.finish();
        mInstrumentation.removeMonitor(am);
        // the text of TextView is removed.
        mTextView = findTextView(R.id.freezesText_false);

        assertEquals(text.toString(), mTextView.getText().toString());

        mTextView.setFreezesText(true);
        assertTrue(mTextView.getFreezesText());

        mActivityRule.runOnUiThread(() -> mTextView.setText(text));
        mInstrumentation.waitForIdleSync();
        // TODO: How to simulate the TextView in frozen icicles.
        am = mInstrumentation.addMonitor(MockURLSpanTestActivity.class.getName(),
                null, false);

        mActivityRule.runOnUiThread(() -> {
            Uri uri = Uri.parse(urlSpan.getURL());
            Intent intent = new Intent(Intent.ACTION_VIEW, uri);
            mActivity.startActivity(intent);
        });

        Activity oldActivity = newActivity;
        while (true) {
            newActivity = am.waitForActivityWithTimeout(TIMEOUT);
            assertNotNull(newActivity);
            if (newActivity != oldActivity) {
                break;
            }
        }
        newActivity.finish();
        mInstrumentation.removeMonitor(am);
        // the text of TextView is still there.
        mTextView = findTextView(R.id.freezesText_false);
        assertEquals(text.toString(), mTextView.getText().toString());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetEditableFactory"	"CtsWidgetTestCases"	"1: ui"	"public void testSetEditableFactory() {
        mTextView = new TextView(mActivity);
        String text = ""sample"";

        final Editable.Factory mockEditableFactory = spy(new Editable.Factory());
        doCallRealMethod().when(mockEditableFactory).newEditable(any(CharSequence.class));
        mTextView.setEditableFactory(mockEditableFactory);

        mTextView.setText(text);
        verify(mockEditableFactory, never()).newEditable(any(CharSequence.class));

        reset(mockEditableFactory);
        mTextView.setText(text, BufferType.SPANNABLE);
        verify(mockEditableFactory, never()).newEditable(any(CharSequence.class));

        reset(mockEditableFactory);
        mTextView.setText(text, BufferType.NORMAL);
        verify(mockEditableFactory, never()).newEditable(any(CharSequence.class));

        reset(mockEditableFactory);
        mTextView.setText(text, BufferType.EDITABLE);
        verify(mockEditableFactory, times(1)).newEditable(text);

        mTextView.setKeyListener(DigitsKeyListener.getInstance());
        reset(mockEditableFactory);
        mTextView.setText(text, BufferType.EDITABLE);
        verify(mockEditableFactory, times(1)).newEditable(text);

        try {
            mTextView.setEditableFactory(null);
            fail(""The factory can not set to null!"");
        } catch (NullPointerException e) {
        }
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetSpannableFactory"	"CtsWidgetTestCases"	"1: ui"	"public void testSetSpannableFactory() {
        mTextView = new TextView(mActivity);
        String text = ""sample"";

        final Spannable.Factory mockSpannableFactory = spy(new Spannable.Factory());
        doCallRealMethod().when(mockSpannableFactory).newSpannable(any(CharSequence.class));
        mTextView.setSpannableFactory(mockSpannableFactory);

        mTextView.setText(text);
        verify(mockSpannableFactory, never()).newSpannable(any(CharSequence.class));

        reset(mockSpannableFactory);
        mTextView.setText(text, BufferType.EDITABLE);
        verify(mockSpannableFactory, never()).newSpannable(any(CharSequence.class));

        reset(mockSpannableFactory);
        mTextView.setText(text, BufferType.NORMAL);
        verify(mockSpannableFactory, never()).newSpannable(any(CharSequence.class));

        reset(mockSpannableFactory);
        mTextView.setText(text, BufferType.SPANNABLE);
        verify(mockSpannableFactory, times(1)).newSpannable(text);

        mTextView.setMovementMethod(LinkMovementMethod.getInstance());
        reset(mockSpannableFactory);
        mTextView.setText(text, BufferType.NORMAL);
        verify(mockSpannableFactory, times(1)).newSpannable(text);

        try {
            mTextView.setSpannableFactory(null);
            fail(""The factory can not set to null!"");
        } catch (NullPointerException e) {
        }
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testTextChangedListener"	"CtsWidgetTestCases"	"1: ui"	"public void testTextChangedListener() {
        mTextView = new TextView(mActivity);
        MockTextWatcher watcher0 = new MockTextWatcher();
        MockTextWatcher watcher1 = new MockTextWatcher();

        mTextView.addTextChangedListener(watcher0);
        mTextView.addTextChangedListener(watcher1);

        watcher0.reset();
        watcher1.reset();
        mTextView.setText(""Changed"");
        assertTrue(watcher0.hasCalledBeforeTextChanged());
        assertTrue(watcher0.hasCalledOnTextChanged());
        assertTrue(watcher0.hasCalledAfterTextChanged());
        assertTrue(watcher1.hasCalledBeforeTextChanged());
        assertTrue(watcher1.hasCalledOnTextChanged());
        assertTrue(watcher1.hasCalledAfterTextChanged());

        watcher0.reset();
        watcher1.reset();
        // BeforeTextChanged and OnTextChanged are called though the strings are same
        mTextView.setText(""Changed"");
        assertTrue(watcher0.hasCalledBeforeTextChanged());
        assertTrue(watcher0.hasCalledOnTextChanged());
        assertTrue(watcher0.hasCalledAfterTextChanged());
        assertTrue(watcher1.hasCalledBeforeTextChanged());
        assertTrue(watcher1.hasCalledOnTextChanged());
        assertTrue(watcher1.hasCalledAfterTextChanged());

        watcher0.reset();
        watcher1.reset();
        // BeforeTextChanged and OnTextChanged are called twice (The text is not
        // Editable, so in Append() it calls setText() first)
        mTextView.append(""and appended"");
        assertTrue(watcher0.hasCalledBeforeTextChanged());
        assertTrue(watcher0.hasCalledOnTextChanged());
        assertTrue(watcher0.hasCalledAfterTextChanged());
        assertTrue(watcher1.hasCalledBeforeTextChanged());
        assertTrue(watcher1.hasCalledOnTextChanged());
        assertTrue(watcher1.hasCalledAfterTextChanged());

        watcher0.reset();
        watcher1.reset();
        // Methods are not called if the string does not change
        mTextView.append("""");
        assertFalse(watcher0.hasCalledBeforeTextChanged());
        assertFalse(watcher0.hasCalledOnTextChanged());
        assertFalse(watcher0.hasCalledAfterTextChanged());
        assertFalse(watcher1.hasCalledBeforeTextChanged());
        assertFalse(watcher1.hasCalledOnTextChanged());
        assertFalse(watcher1.hasCalledAfterTextChanged());

        watcher0.reset();
        watcher1.reset();
        mTextView.removeTextChangedListener(watcher1);
        mTextView.setText(null);
        assertTrue(watcher0.hasCalledBeforeTextChanged());
        assertTrue(watcher0.hasCalledOnTextChanged());
        assertTrue(watcher0.hasCalledAfterTextChanged());
        assertFalse(watcher1.hasCalledBeforeTextChanged());
        assertFalse(watcher1.hasCalledOnTextChanged());
        assertFalse(watcher1.hasCalledAfterTextChanged());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetTextKeepState1"	"CtsWidgetTestCases"	"1: ui"	"public void testSetTextKeepState1() {
        mTextView = new TextView(mActivity);

        String longString = ""very long content"";
        String shortString = ""short"";

        // selection is at the exact place which is inside the short string
        mTextView.setText(longString, BufferType.SPANNABLE);
        Selection.setSelection((Spannable) mTextView.getText(), 3);
        mTextView.setTextKeepState(shortString);
        assertEquals(shortString, mTextView.getText().toString());
        assertEquals(3, mTextView.getSelectionStart());
        assertEquals(3, mTextView.getSelectionEnd());

        // selection is at the exact place which is outside the short string
        mTextView.setText(longString);
        Selection.setSelection((Spannable) mTextView.getText(), shortString.length() + 1);
        mTextView.setTextKeepState(shortString);
        assertEquals(shortString, mTextView.getText().toString());
        assertEquals(shortString.length(), mTextView.getSelectionStart());
        assertEquals(shortString.length(), mTextView.getSelectionEnd());

        // select the sub string which is inside the short string
        mTextView.setText(longString);
        Selection.setSelection((Spannable) mTextView.getText(), 1, 4);
        mTextView.setTextKeepState(shortString);
        assertEquals(shortString, mTextView.getText().toString());
        assertEquals(1, mTextView.getSelectionStart());
        assertEquals(4, mTextView.getSelectionEnd());

        // select the sub string which ends outside the short string
        mTextView.setText(longString);
        Selection.setSelection((Spannable) mTextView.getText(), 2, shortString.length() + 1);
        mTextView.setTextKeepState(shortString);
        assertEquals(shortString, mTextView.getText().toString());
        assertEquals(2, mTextView.getSelectionStart());
        assertEquals(shortString.length(), mTextView.getSelectionEnd());

        // select the sub string which is outside the short string
        mTextView.setText(longString);
        Selection.setSelection((Spannable) mTextView.getText(),
                shortString.length() + 1, shortString.length() + 3);
        mTextView.setTextKeepState(shortString);
        assertEquals(shortString, mTextView.getText().toString());
        assertEquals(shortString.length(), mTextView.getSelectionStart());
        assertEquals(shortString.length(), mTextView.getSelectionEnd());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetEditableText"	"CtsWidgetTestCases"	"1: ui"	"public void testGetEditableText() {
        TextView tv = findTextView(R.id.textview_text);

        String text = ""Hello"";
        tv.setText(text, BufferType.EDITABLE);
        assertEquals(text, tv.getText().toString());
        assertTrue(tv.getText() instanceof Editable);
        assertEquals(text, tv.getEditableText().toString());

        tv.setText(text, BufferType.SPANNABLE);
        assertEquals(text, tv.getText().toString());
        assertTrue(tv.getText() instanceof Spannable);
        assertNull(tv.getEditableText());

        tv.setText(null, BufferType.EDITABLE);
        assertEquals("""", tv.getText().toString());
        assertTrue(tv.getText() instanceof Editable);
        assertEquals("""", tv.getEditableText().toString());

        tv.setText(null, BufferType.SPANNABLE);
        assertEquals("""", tv.getText().toString());
        assertTrue(tv.getText() instanceof Spannable);
        assertNull(tv.getEditableText());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetText2"	"CtsWidgetTestCases"	"1: ui"	"public void testSetText2() {
        String string = ""This is a test for setting text content by char array"";
        char[] input = string.toCharArray();
        TextView tv = findTextView(R.id.textview_text);

        tv.setText(input, 0, input.length);
        assertEquals(string, tv.getText().toString());

        tv.setText(input, 0, 5);
        assertEquals(string.substring(0, 5), tv.getText().toString());

        try {
            tv.setText(input, -1, input.length);
            fail(""Should throw exception if the start position is negative!"");
        } catch (IndexOutOfBoundsException exception) {
        }

        try {
            tv.setText(input, 0, -1);
            fail(""Should throw exception if the length is negative!"");
        } catch (IndexOutOfBoundsException exception) {
        }

        try {
            tv.setText(input, 1, input.length);
            fail(""Should throw exception if the end position is out of index!"");
        } catch (IndexOutOfBoundsException exception) {
        }

        tv.setText(input, 1, 0);
        assertEquals("""", tv.getText().toString());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetText1"	"CtsWidgetTestCases"	"1: ui"	"public void testSetText1() {
        mTextView = findTextView(R.id.textview_text);

        String longString = ""very long content"";
        String shortString = ""short"";

        // selection is at the exact place which is inside the short string
        mTextView.setText(longString, BufferType.SPANNABLE);
        Selection.setSelection((Spannable) mTextView.getText(), 3);
        mTextView.setTextKeepState(shortString, BufferType.EDITABLE);
        assertTrue(mTextView.getText() instanceof Editable);
        assertEquals(shortString, mTextView.getText().toString());
        assertEquals(shortString, mTextView.getEditableText().toString());
        assertEquals(3, mTextView.getSelectionStart());
        assertEquals(3, mTextView.getSelectionEnd());

        mTextView.setText(shortString, BufferType.EDITABLE);
        assertTrue(mTextView.getText() instanceof Editable);
        assertEquals(shortString, mTextView.getText().toString());
        assertEquals(shortString, mTextView.getEditableText().toString());
        // there is no selection.
        assertEquals(-1, mTextView.getSelectionStart());
        assertEquals(-1, mTextView.getSelectionEnd());

        // selection is at the exact place which is outside the short string
        mTextView.setText(longString);
        Selection.setSelection((Spannable) mTextView.getText(), longString.length());
        mTextView.setTextKeepState(shortString, BufferType.EDITABLE);
        assertTrue(mTextView.getText() instanceof Editable);
        assertEquals(shortString, mTextView.getText().toString());
        assertEquals(shortString, mTextView.getEditableText().toString());
        assertEquals(shortString.length(), mTextView.getSelectionStart());
        assertEquals(shortString.length(), mTextView.getSelectionEnd());

        mTextView.setText(shortString, BufferType.EDITABLE);
        assertTrue(mTextView.getText() instanceof Editable);
        assertEquals(shortString, mTextView.getText().toString());
        assertEquals(shortString, mTextView.getEditableText().toString());
        // there is no selection.
        assertEquals(-1, mTextView.getSelectionStart());
        assertEquals(-1, mTextView.getSelectionEnd());

        // select the sub string which is inside the short string
        mTextView.setText(longString);
        Selection.setSelection((Spannable) mTextView.getText(), 1, shortString.length() - 1);
        mTextView.setTextKeepState(shortString, BufferType.EDITABLE);
        assertTrue(mTextView.getText() instanceof Editable);
        assertEquals(shortString, mTextView.getText().toString());
        assertEquals(shortString, mTextView.getEditableText().toString());
        assertEquals(1, mTextView.getSelectionStart());
        assertEquals(shortString.length() - 1, mTextView.getSelectionEnd());

        mTextView.setText(shortString, BufferType.EDITABLE);
        assertTrue(mTextView.getText() instanceof Editable);
        assertEquals(shortString, mTextView.getText().toString());
        assertEquals(shortString, mTextView.getEditableText().toString());
        // there is no selection.
        assertEquals(-1, mTextView.getSelectionStart());
        assertEquals(-1, mTextView.getSelectionEnd());

        // select the sub string which ends outside the short string
        mTextView.setText(longString);
        Selection.setSelection((Spannable) mTextView.getText(), 2, longString.length());
        mTextView.setTextKeepState(shortString, BufferType.EDITABLE);
        assertTrue(mTextView.getText() instanceof Editable);
        assertEquals(shortString, mTextView.getText().toString());
        assertEquals(shortString, mTextView.getEditableText().toString());
        assertEquals(2, mTextView.getSelectionStart());
        assertEquals(shortString.length(), mTextView.getSelectionEnd());

        mTextView.setText(shortString, BufferType.EDITABLE);
        assertTrue(mTextView.getText() instanceof Editable);
        assertEquals(shortString, mTextView.getText().toString());
        assertEquals(shortString, mTextView.getEditableText().toString());
        // there is no selection.
        assertEquals(-1, mTextView.getSelectionStart());
        assertEquals(-1, mTextView.getSelectionEnd());

        // select the sub string which is outside the short string
        mTextView.setText(longString);
        Selection.setSelection((Spannable) mTextView.getText(),
                shortString.length() + 1, shortString.length() + 3);
        mTextView.setTextKeepState(shortString, BufferType.EDITABLE);
        assertTrue(mTextView.getText() instanceof Editable);
        assertEquals(shortString, mTextView.getText().toString());
        assertEquals(shortString, mTextView.getEditableText().toString());
        assertEquals(shortString.length(), mTextView.getSelectionStart());
        assertEquals(shortString.length(), mTextView.getSelectionEnd());

        mTextView.setText(shortString, BufferType.EDITABLE);
        assertTrue(mTextView.getText() instanceof Editable);
        assertEquals(shortString, mTextView.getText().toString());
        assertEquals(shortString, mTextView.getEditableText().toString());
        // there is no selection.
        assertEquals(-1, mTextView.getSelectionStart());
        assertEquals(-1, mTextView.getSelectionEnd());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetText3"	"CtsWidgetTestCases"	"1: ui"	"public void testSetText3() {
        TextView tv = findTextView(R.id.textview_text);

        int resId = R.string.text_view_hint;
        String result = mActivity.getResources().getString(resId);

        tv.setText(resId);
        assertEquals(result, tv.getText().toString());

        try {
            tv.setText(-1);
            fail(""Should throw exception with illegal id"");
        } catch (NotFoundException e) {
        }
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetTextUpdatesHeightAfterRemovingImageSpan"	"CtsWidgetTestCases"	"1: ui"	"public void testSetTextUpdatesHeightAfterRemovingImageSpan() throws Throwable {
        // Height calculation had problems when TextView had width: match_parent
        final int textViewWidth = ViewGroup.LayoutParams.MATCH_PARENT;
        final Spannable text = new SpannableString(""some text"");
        final int spanHeight = 100;

        // prepare TextView, width: MATCH_PARENT
        mActivityRule.runOnUiThread(() -> mTextView = new TextView(mActivity));
        mInstrumentation.waitForIdleSync();
        mTextView.setSingleLine(true);
        mTextView.setTextSize(TypedValue.COMPLEX_UNIT_SP, 2);
        mTextView.setPadding(0, 0, 0, 0);
        mTextView.setIncludeFontPadding(false);
        mTextView.setText(text);
        final FrameLayout layout = new FrameLayout(mActivity);
        final ViewGroup.LayoutParams layoutParams = new ViewGroup.LayoutParams(textViewWidth,
                ViewGroup.LayoutParams.WRAP_CONTENT);
        layout.addView(mTextView, layoutParams);
        layout.setLayoutParams(layoutParams);
        mActivityRule.runOnUiThread(() -> mActivity.setContentView(layout));
        mInstrumentation.waitForIdleSync();

        // measure height of text with no span
        final int heightWithoutSpan = mTextView.getHeight();
        assertTrue(""Text height should be smaller than span height"",
                heightWithoutSpan < spanHeight);

        // add ImageSpan to text
        Drawable drawable = mInstrumentation.getContext().getDrawable(R.drawable.scenery);
        drawable.setBounds(0, 0, spanHeight, spanHeight);
        ImageSpan span = new ImageSpan(drawable);
        text.setSpan(span, 0, 1, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        mActivityRule.runOnUiThread(() -> mTextView.setText(text));
        mInstrumentation.waitForIdleSync();

        // measure height with span
        final int heightWithSpan = mTextView.getHeight();
        assertTrue(""Text height should be greater or equal than span height"",
                heightWithSpan >= spanHeight);

        // remove the span
        text.removeSpan(span);
        mActivityRule.runOnUiThread(() -> mTextView.setText(text));
        mInstrumentation.waitForIdleSync();

        final int heightAfterRemoveSpan = mTextView.getHeight();
        assertEquals(""Text height should be same after removing the span"",
                heightWithoutSpan, heightAfterRemoveSpan);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testRemoveSelectionWithSelectionHandles"	"CtsWidgetTestCases"	"1: ui"	"public void testRemoveSelectionWithSelectionHandles() throws Throwable {
        initTextViewForTypingOnUiThread();

        assertFalse(mTextView.isTextSelectable());
        mActivityRule.runOnUiThread(() -> {
            mTextView.setTextIsSelectable(true);
            mTextView.setText(""abcd"", BufferType.EDITABLE);
        });
        mInstrumentation.waitForIdleSync();
        assertTrue(mTextView.isTextSelectable());

        // Long click on the text selects all text and shows selection handlers. The view has an
        // attribute layout_width=""wrap_content"", so clicked location (the center of the view)
        // should be on the text.
        CtsTouchUtils.emulateLongPressOnViewCenter(mInstrumentation, mActivityRule, mTextView);

        mActivityRule.runOnUiThread(() -> Selection.removeSelection((Spannable) mTextView.getText()));
        mInstrumentation.waitForIdleSync();

        assertTrue(TextUtils.equals(""abcd"", mTextView.getText()));
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testUndo_insert"	"CtsWidgetTestCases"	"1: ui"	"public void testUndo_insert() throws Throwable {
        initTextViewForTypingOnUiThread();

        // Type some text.
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""abc"");
        mActivityRule.runOnUiThread(() -> {
            // Precondition: The cursor is at the end of the text.
            assertEquals(3, mTextView.getSelectionStart());

            // Undo removes the typed string in one step.
            mTextView.onTextContextMenuItem(android.R.id.undo);
            assertEquals("""", mTextView.getText().toString());
            assertEquals(0, mTextView.getSelectionStart());

            // Redo restores the text and cursor position.
            mTextView.onTextContextMenuItem(android.R.id.redo);
            assertEquals(""abc"", mTextView.getText().toString());
            assertEquals(3, mTextView.getSelectionStart());

            // Undoing the redo clears the text again.
            mTextView.onTextContextMenuItem(android.R.id.undo);
            assertEquals("""", mTextView.getText().toString());

            // Undo when the undo stack is empty does nothing.
            mTextView.onTextContextMenuItem(android.R.id.undo);
            assertEquals("""", mTextView.getText().toString());
        });
        mInstrumentation.waitForIdleSync();
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testUndo_delete"	"CtsWidgetTestCases"	"1: ui"	"public void testUndo_delete() throws Throwable {
        initTextViewForTypingOnUiThread();

        // Simulate deleting text and undoing it.
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""xyz"");
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_DEL,
                KeyEvent.KEYCODE_DEL, KeyEvent.KEYCODE_DEL);
        mActivityRule.runOnUiThread(() -> {
            // Precondition: The text was actually deleted.
            assertEquals("""", mTextView.getText().toString());
            assertEquals(0, mTextView.getSelectionStart());

            // Undo restores the typed string and cursor position in one step.
            mTextView.onTextContextMenuItem(android.R.id.undo);
            assertEquals(""xyz"", mTextView.getText().toString());
            assertEquals(3, mTextView.getSelectionStart());

            // Redo removes the text in one step.
            mTextView.onTextContextMenuItem(android.R.id.redo);
            assertEquals("""", mTextView.getText().toString());
            assertEquals(0, mTextView.getSelectionStart());

            // Undoing the redo restores the text again.
            mTextView.onTextContextMenuItem(android.R.id.undo);
            assertEquals(""xyz"", mTextView.getText().toString());
            assertEquals(3, mTextView.getSelectionStart());

            // Undoing again undoes the original typing.
            mTextView.onTextContextMenuItem(android.R.id.undo);
            assertEquals("""", mTextView.getText().toString());
            assertEquals(0, mTextView.getSelectionStart());
        });
        mInstrumentation.waitForIdleSync();
    }

    // Initialize the text view for simulated IME typing. Must be called on UI thread.
    private InputConnection initTextViewForSimulatedIme() {
        mTextView = findTextView(R.id.textview_text);
        return initTextViewForSimulatedIme(mTextView);
    }

    private InputConnection initTextViewForSimulatedIme(TextView textView) {
        textView.setKeyListener(QwertyKeyListener.getInstance(false, Capitalize.NONE));
        textView.setText("""", BufferType.EDITABLE);
        return textView.onCreateInputConnection(new EditorInfo());
    }

    // Simulates IME composing text behavior.
    private void setComposingTextInBatch(InputConnection input, CharSequence text) {
        input.beginBatchEdit();
        input.setComposingText(text, 1);  // Leave cursor at end.
        input.endBatchEdit();
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testUndo_imeInsertLatin"	"CtsWidgetTestCases"	"1: ui"	"public void testUndo_imeInsertLatin() {
        InputConnection input = initTextViewForSimulatedIme();

        // Simulate IME text entry behavior. The Latin IME enters text by replacing partial words,
        // such as ""c"" -> ""ca"" -> ""cat"" -> ""cat "".
        setComposingTextInBatch(input, ""c"");
        setComposingTextInBatch(input, ""ca"");

        // The completion and space are added in the same batch.
        input.beginBatchEdit();
        input.commitText(""cat"", 1);
        input.commitText("" "", 1);
        input.endBatchEdit();

        // The repeated replacements undo in a single step.
        mTextView.onTextContextMenuItem(android.R.id.undo);
        assertEquals("""", mTextView.getText().toString());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testUndo_imeInsertJapanese"	"CtsWidgetTestCases"	"1: ui"	"public void testUndo_imeInsertJapanese() {
        InputConnection input = initTextViewForSimulatedIme();

        // The Japanese IME does repeated replacements of Latin characters to hiragana to kanji.
        final String HA = ""\u306F"";  // HIRAGANA LETTER HA
        final String NA = ""\u306A"";  // HIRAGANA LETTER NA
        setComposingTextInBatch(input, ""h"");
        setComposingTextInBatch(input, HA);
        setComposingTextInBatch(input, HA + ""n"");
        setComposingTextInBatch(input, HA + NA);

        // The result may be a surrogate pair. The composition ends in the same batch.
        input.beginBatchEdit();
        input.commitText(""\uD83C\uDF37"", 1);  // U+1F337 TULIP
        input.setComposingText("""", 1);
        input.endBatchEdit();

        // The repeated replacements are a single undo step.
        mTextView.onTextContextMenuItem(android.R.id.undo);
        assertEquals("""", mTextView.getText().toString());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testUndo_imeInsertAndDeleteLatin"	"CtsWidgetTestCases"	"1: ui"	"public void testUndo_imeInsertAndDeleteLatin() {
        InputConnection input = initTextViewForSimulatedIme();

        setComposingTextInBatch(input, ""t"");
        setComposingTextInBatch(input, ""te"");
        setComposingTextInBatch(input, ""tes"");
        setComposingTextInBatch(input, ""test"");
        setComposingTextInBatch(input, ""tes"");
        setComposingTextInBatch(input, ""te"");
        setComposingTextInBatch(input, ""t"");

        input.beginBatchEdit();
        input.setComposingText("""", 1);
        input.finishComposingText();
        input.endBatchEdit();

        mTextView.onTextContextMenuItem(android.R.id.undo);
        assertEquals(""test"", mTextView.getText().toString());
        mTextView.onTextContextMenuItem(android.R.id.undo);
        assertEquals("""", mTextView.getText().toString());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testUndo_imeAutoCorrection"	"CtsWidgetTestCases"	"1: ui"	"public void testUndo_imeAutoCorrection() {
        mTextView = findTextView(R.id.textview_text);
        TextView spiedTextView = spy(mTextView);
        InputConnection input = initTextViewForSimulatedIme(spiedTextView);

        // Start typing a composition.
        setComposingTextInBatch(input, ""t"");
        setComposingTextInBatch(input, ""te"");
        setComposingTextInBatch(input, ""teh"");

        CorrectionInfo correctionInfo = new CorrectionInfo(0, ""teh"", ""the"");
        reset(spiedTextView);
        input.beginBatchEdit();
        // Auto correct ""teh"" to ""the"".
        assertTrue(input.commitCorrection(correctionInfo));
        input.commitText(""the"", 1);
        input.endBatchEdit();

        verify(spiedTextView, times(1)).onCommitCorrection(refEq(correctionInfo));

        assertEquals(""the"", spiedTextView.getText().toString());
        spiedTextView.onTextContextMenuItem(android.R.id.undo);
        assertEquals(""teh"", spiedTextView.getText().toString());
        spiedTextView.onTextContextMenuItem(android.R.id.undo);
        assertEquals("""", spiedTextView.getText().toString());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testUndo_imeAutoCompletion"	"CtsWidgetTestCases"	"1: ui"	"public void testUndo_imeAutoCompletion() {
        mTextView = findTextView(R.id.textview_text);
        TextView spiedTextView = spy(mTextView);
        InputConnection input = initTextViewForSimulatedIme(spiedTextView);

        // Start typing a composition.
        setComposingTextInBatch(input, ""a"");
        setComposingTextInBatch(input, ""an"");
        setComposingTextInBatch(input, ""and"");

        CompletionInfo completionInfo = new CompletionInfo(0, 0, ""android"");
        reset(spiedTextView);
        input.beginBatchEdit();
        // Auto complete ""and"" to ""android"".
        assertTrue(input.commitCompletion(completionInfo));
        input.commitText(""android"", 1);
        input.endBatchEdit();

        verify(spiedTextView, times(1)).onCommitCompletion(refEq(completionInfo));

        assertEquals(""android"", spiedTextView.getText().toString());
        spiedTextView.onTextContextMenuItem(android.R.id.undo);
        assertEquals("""", spiedTextView.getText().toString());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testUndo_imeCancel"	"CtsWidgetTestCases"	"1: ui"	"public void testUndo_imeCancel() {
        InputConnection input = initTextViewForSimulatedIme();
        mTextView.setText(""flower"");

        // Start typing a composition.
        final String HA = ""\u306F"";  // HIRAGANA LETTER HA
        setComposingTextInBatch(input, ""h"");
        setComposingTextInBatch(input, HA);
        setComposingTextInBatch(input, HA + ""n"");

        // Cancel the composition.
        setComposingTextInBatch(input, """");

        mTextView.onTextContextMenuItem(android.R.id.undo);
        assertEquals(HA + ""n"" + ""flower"", mTextView.getText().toString());
        mTextView.onTextContextMenuItem(android.R.id.redo);
        assertEquals(""flower"", mTextView.getText().toString());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testUndo_imeEmptyBatch"	"CtsWidgetTestCases"	"1: ui"	"public void testUndo_imeEmptyBatch() {
        InputConnection input = initTextViewForSimulatedIme();
        mTextView.setText(""flower"");

        // Send an empty batch edit. This happens if the IME is hidden and shown.
        input.beginBatchEdit();
        input.endBatchEdit();

        // Undo and redo do nothing.
        mTextView.onTextContextMenuItem(android.R.id.undo);
        assertEquals(""flower"", mTextView.getText().toString());
        mTextView.onTextContextMenuItem(android.R.id.redo);
        assertEquals(""flower"", mTextView.getText().toString());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testUndo_setText"	"CtsWidgetTestCases"	"1: ui"	"public void testUndo_setText() throws Throwable {
        initTextViewForTypingOnUiThread();

        // Create two undo operations, an insert and a delete.
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""xyz"");
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_DEL,
                KeyEvent.KEYCODE_DEL, KeyEvent.KEYCODE_DEL);
        mActivityRule.runOnUiThread(() -> {
            // Calling setText() clears both undo operations, so undo doesn't happen.
            mTextView.setText(""Hello"", BufferType.EDITABLE);
            mTextView.onTextContextMenuItem(android.R.id.undo);
            assertEquals(""Hello"", mTextView.getText().toString());

            // Clearing text programmatically does not undo either.
            mTextView.setText("""", BufferType.EDITABLE);
            mTextView.onTextContextMenuItem(android.R.id.undo);
            assertEquals("""", mTextView.getText().toString());
        });
        mInstrumentation.waitForIdleSync();
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testRedo_setText"	"CtsWidgetTestCases"	"1: ui"	"public void testRedo_setText() throws Throwable {
        initTextViewForTypingOnUiThread();

        // Type some text. This creates an undo entry.
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""abc"");
        mActivityRule.runOnUiThread(() -> {
            // Undo the typing to create a redo entry.
            mTextView.onTextContextMenuItem(android.R.id.undo);

            // Calling setText() clears the redo stack, so redo doesn't happen.
            mTextView.setText(""Hello"", BufferType.EDITABLE);
            mTextView.onTextContextMenuItem(android.R.id.redo);
            assertEquals(""Hello"", mTextView.getText().toString());
        });
        mInstrumentation.waitForIdleSync();
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testUndo_noCursor"	"CtsWidgetTestCases"	"1: ui"	"public void testUndo_noCursor() {
        initTextViewForTyping();

        // Append some text to create an undo operation. There is no cursor present.
        mTextView.append(""cat"");

        // Place the cursor at the end of the text so the undo will have to change it.
        Selection.setSelection((Spannable) mTextView.getText(), 3);

        // Undo the append. This should not crash, despite not having a valid cursor
        // position in the undo operation.
        mTextView.onTextContextMenuItem(android.R.id.undo);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testUndo_textWatcher"	"CtsWidgetTestCases"	"1: ui"	"public void testUndo_textWatcher() throws Throwable {
        initTextViewForTypingOnUiThread();

        // Add a TextWatcher that converts the text to spaces on each change.
        mTextView.addTextChangedListener(new ConvertToSpacesTextWatcher());

        // Type some text.
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""abc"");
        mActivityRule.runOnUiThread(() -> {
            // TextWatcher altered the text.
            assertEquals(""   "", mTextView.getText().toString());

            // Undo reverses both changes in one step.
            mTextView.onTextContextMenuItem(android.R.id.undo);
            assertEquals("""", mTextView.getText().toString());
        });
        mInstrumentation.waitForIdleSync();
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testUndo_shortcuts"	"CtsWidgetTestCases"	"1: ui"	"public void testUndo_shortcuts() throws Throwable {
        initTextViewForTypingOnUiThread();

        // Type some text.
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""abc"");
        mActivityRule.runOnUiThread(() -> {
            // Pressing Control-Z triggers undo.
            KeyEvent control = new KeyEvent(0, 0, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_Z, 0,
                    KeyEvent.META_CTRL_LEFT_ON);
            assertTrue(mTextView.onKeyShortcut(KeyEvent.KEYCODE_Z, control));
            assertEquals("""", mTextView.getText().toString());

            // Pressing Control-Shift-Z triggers redo.
            KeyEvent controlShift = new KeyEvent(0, 0, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_Z,
                    0, KeyEvent.META_CTRL_LEFT_ON | KeyEvent.META_SHIFT_LEFT_ON);
            assertTrue(mTextView.onKeyShortcut(KeyEvent.KEYCODE_Z, controlShift));
            assertEquals(""abc"", mTextView.getText().toString());
        });
        mInstrumentation.waitForIdleSync();
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testUndo_saveInstanceState"	"CtsWidgetTestCases"	"1: ui"	"public void testUndo_saveInstanceState() throws Throwable {
        initTextViewForTypingOnUiThread();

        // Type some text to create an undo operation.
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""abc"");
        mActivityRule.runOnUiThread(() -> {
            // Parcel and unparcel the TextView.
            Parcelable state = mTextView.onSaveInstanceState();
            mTextView.onRestoreInstanceState(state);
        });
        mInstrumentation.waitForIdleSync();

        // Delete a character to create a new undo operation.
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_DEL);
        mActivityRule.runOnUiThread(() -> {
            assertEquals(""ab"", mTextView.getText().toString());

            // Undo the delete.
            mTextView.onTextContextMenuItem(android.R.id.undo);
            assertEquals(""abc"", mTextView.getText().toString());

            // Undo the typing, which verifies that the original undo operation was parceled
            // correctly.
            mTextView.onTextContextMenuItem(android.R.id.undo);
            assertEquals("""", mTextView.getText().toString());

            // Parcel and unparcel the undo stack (which is empty but has been used and may
            // contain other state).
            Parcelable state = mTextView.onSaveInstanceState();
            mTextView.onRestoreInstanceState(state);
        });
        mInstrumentation.waitForIdleSync();
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testUndo_saveInstanceStateEmpty"	"CtsWidgetTestCases"	"1: ui"	"public void testUndo_saveInstanceStateEmpty() throws Throwable {
        initTextViewForTypingOnUiThread();

        // Type and delete to create two new undo operations.
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""a"");
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_DEL);
        mActivityRule.runOnUiThread(() -> {
            // Empty the undo stack then parcel and unparcel the TextView. While the undo
            // stack contains no operations it may contain other state.
            mTextView.onTextContextMenuItem(android.R.id.undo);
            mTextView.onTextContextMenuItem(android.R.id.undo);
            Parcelable state = mTextView.onSaveInstanceState();
            mTextView.onRestoreInstanceState(state);
        });
        mInstrumentation.waitForIdleSync();

        // Create two more undo operations.
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""b"");
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_DEL);
        mActivityRule.runOnUiThread(() -> {
            // Verify undo still works.
            mTextView.onTextContextMenuItem(android.R.id.undo);
            assertEquals(""b"", mTextView.getText().toString());
            mTextView.onTextContextMenuItem(android.R.id.undo);
            assertEquals("""", mTextView.getText().toString());
        });
        mInstrumentation.waitForIdleSync();
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testCopyAndPaste"	"CtsWidgetTestCases"	"1: ui"	"public void testCopyAndPaste() {
        initTextViewForTyping();

        mTextView.setText(""abcd"", BufferType.EDITABLE);
        mTextView.setSelected(true);

        // Copy ""bc"".
        Selection.setSelection((Spannable) mTextView.getText(), 1, 3);
        mTextView.onTextContextMenuItem(android.R.id.copy);

        // Paste ""bc"" between ""b"" and ""c"".
        Selection.setSelection((Spannable) mTextView.getText(), 2, 2);
        mTextView.onTextContextMenuItem(android.R.id.paste);
        assertEquals(""abbccd"", mTextView.getText().toString());

        // Select entire text and paste ""bc"".
        Selection.selectAll((Spannable) mTextView.getText());
        mTextView.onTextContextMenuItem(android.R.id.paste);
        assertEquals(""bc"", mTextView.getText().toString());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testCopyAndPaste_byKey"	"CtsWidgetTestCases"	"1: ui"	"public void testCopyAndPaste_byKey() throws Throwable {
        initTextViewForTypingOnUiThread();

        // Type ""abc"".
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""abc"");
        mActivityRule.runOnUiThread(() -> {
            // Select ""bc""
            Selection.setSelection((Spannable) mTextView.getText(), 1, 3);
        });
        mInstrumentation.waitForIdleSync();
        // Copy ""bc""
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_COPY);

        mActivityRule.runOnUiThread(() -> {
            // Set cursor between 'b' and 'c'.
            Selection.setSelection((Spannable) mTextView.getText(), 2, 2);
        });
        mInstrumentation.waitForIdleSync();
        // Paste ""bc""
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_PASTE);
        assertEquals(""abbcc"", mTextView.getText().toString());

        mActivityRule.runOnUiThread(() -> {
            Selection.selectAll((Spannable) mTextView.getText());
            KeyEvent copyWithMeta = new KeyEvent(0, 0, KeyEvent.ACTION_DOWN,
                    KeyEvent.KEYCODE_COPY, 0, KeyEvent.META_SHIFT_LEFT_ON);
            // Shift + copy doesn't perform copy.
            mTextView.onKeyDown(KeyEvent.KEYCODE_COPY, copyWithMeta);
            Selection.setSelection((Spannable) mTextView.getText(), 0, 0);
            mTextView.onTextContextMenuItem(android.R.id.paste);
            assertEquals(""bcabbcc"", mTextView.getText().toString());

            Selection.selectAll((Spannable) mTextView.getText());
            copyWithMeta = new KeyEvent(0, 0, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_COPY, 0,
                    KeyEvent.META_CTRL_LEFT_ON);
            // Control + copy doesn't perform copy.
            mTextView.onKeyDown(KeyEvent.KEYCODE_COPY, copyWithMeta);
            Selection.setSelection((Spannable) mTextView.getText(), 0, 0);
            mTextView.onTextContextMenuItem(android.R.id.paste);
            assertEquals(""bcbcabbcc"", mTextView.getText().toString());

            Selection.selectAll((Spannable) mTextView.getText());
            copyWithMeta = new KeyEvent(0, 0, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_COPY, 0,
                    KeyEvent.META_SHIFT_LEFT_ON | KeyEvent.META_CTRL_LEFT_ON);
            // Control + Shift + copy doesn't perform copy.
            mTextView.onKeyDown(KeyEvent.KEYCODE_COPY, copyWithMeta);
            Selection.setSelection((Spannable) mTextView.getText(), 0, 0);
            mTextView.onTextContextMenuItem(android.R.id.paste);
            assertEquals(""bcbcbcabbcc"", mTextView.getText().toString());
        });
        mInstrumentation.waitForIdleSync();
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testCopyAndPaste_byCtrlInsert"	"CtsWidgetTestCases"	"1: ui"	"public void testCopyAndPaste_byCtrlInsert() throws Throwable {
        // Test copy-and-paste by Ctrl-Insert and Shift-Insert.
        initTextViewForTypingOnUiThread();

        // Type ""abc""
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""abc"");
        mActivityRule.runOnUiThread(() -> {
            // Select ""bc""
            Selection.setSelection((Spannable) mTextView.getText(), 1, 3);
        });
        mInstrumentation.waitForIdleSync();

        // Copy ""bc""
        CtsKeyEventUtil.sendKeyWhileHoldingModifier(mInstrumentation, mTextView,
                KeyEvent.KEYCODE_INSERT, KeyEvent.KEYCODE_CTRL_LEFT);
        mActivityRule.runOnUiThread(() -> {
            // Set cursor between 'b' and 'c'
            Selection.setSelection((Spannable) mTextView.getText(), 2, 2);
        });
        mInstrumentation.waitForIdleSync();

        // Paste ""bc""
        CtsKeyEventUtil.sendKeyWhileHoldingModifier(mInstrumentation, mTextView,
                KeyEvent.KEYCODE_INSERT, KeyEvent.KEYCODE_SHIFT_LEFT);
        assertEquals(""abbcc"", mTextView.getText().toString());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testCutAndPaste"	"CtsWidgetTestCases"	"1: ui"	"public void testCutAndPaste() {
        initTextViewForTyping();

        mTextView.setText(""abcd"", BufferType.EDITABLE);
        mTextView.setSelected(true);

        // Cut ""bc"".
        Selection.setSelection((Spannable) mTextView.getText(), 1, 3);
        mTextView.onTextContextMenuItem(android.R.id.cut);
        assertEquals(""ad"", mTextView.getText().toString());

        // Cut ""ad"".
        Selection.setSelection((Spannable) mTextView.getText(), 0, 2);
        mTextView.onTextContextMenuItem(android.R.id.cut);
        assertEquals("""", mTextView.getText().toString());

        // Paste ""ad"".
        mTextView.onTextContextMenuItem(android.R.id.paste);
        assertEquals(""ad"", mTextView.getText().toString());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testCutAndPaste_byKey"	"CtsWidgetTestCases"	"1: ui"	"public void testCutAndPaste_byKey() throws Throwable {
        initTextViewForTypingOnUiThread();

        // Type ""abc"".
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""abc"");
        mActivityRule.runOnUiThread(() -> {
            // Select ""bc""
            Selection.setSelection((Spannable) mTextView.getText(), 1, 3);
        });
        mInstrumentation.waitForIdleSync();
        // Cut ""bc""
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_CUT);

        mActivityRule.runOnUiThread(() -> {
            assertEquals(""a"", mTextView.getText().toString());
            // Move cursor to the head
            Selection.setSelection((Spannable) mTextView.getText(), 0, 0);
        });
        mInstrumentation.waitForIdleSync();
        // Paste ""bc""
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_PASTE);
        assertEquals(""bca"", mTextView.getText().toString());

        mActivityRule.runOnUiThread(() -> {
            Selection.selectAll((Spannable) mTextView.getText());
            KeyEvent cutWithMeta = new KeyEvent(0, 0, KeyEvent.ACTION_DOWN,
                    KeyEvent.KEYCODE_CUT, 0, KeyEvent.META_SHIFT_LEFT_ON);
            // Shift + cut doesn't perform cut.
            mTextView.onKeyDown(KeyEvent.KEYCODE_CUT, cutWithMeta);
            assertEquals(""bca"", mTextView.getText().toString());

            cutWithMeta = new KeyEvent(0, 0, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_CUT, 0,
                    KeyEvent.META_CTRL_LEFT_ON);
            // Control + cut doesn't perform cut.
            mTextView.onKeyDown(KeyEvent.KEYCODE_CUT, cutWithMeta);
            assertEquals(""bca"", mTextView.getText().toString());

            cutWithMeta = new KeyEvent(0, 0, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_CUT, 0,
                    KeyEvent.META_SHIFT_LEFT_ON | KeyEvent.META_CTRL_LEFT_ON);
            // Control + Shift + cut doesn't perform cut.
            mTextView.onKeyDown(KeyEvent.KEYCODE_CUT, cutWithMeta);
            assertEquals(""bca"", mTextView.getText().toString());
        });
        mInstrumentation.waitForIdleSync();
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testCutAndPaste_byShiftDelete"	"CtsWidgetTestCases"	"1: ui"	"public void testCutAndPaste_byShiftDelete() throws Throwable {
        // Test cut and paste by Shift-Delete and Shift-Insert
        initTextViewForTypingOnUiThread();

        // Type ""abc"".
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""abc"");
        mActivityRule.runOnUiThread(() -> {
            // Select ""bc""
            Selection.setSelection((Spannable) mTextView.getText(), 1, 3);
        });
        mInstrumentation.waitForIdleSync();

        // Cut ""bc""
        CtsKeyEventUtil.sendKeyWhileHoldingModifier(mInstrumentation, mTextView,
                KeyEvent.KEYCODE_FORWARD_DEL, KeyEvent.KEYCODE_SHIFT_LEFT);
        mActivityRule.runOnUiThread(() -> {
            assertEquals(""a"", mTextView.getText().toString());
            // Move cursor to the head
            Selection.setSelection((Spannable) mTextView.getText(), 0, 0);
        });
        mInstrumentation.waitForIdleSync();

        // Paste ""bc""
        CtsKeyEventUtil.sendKeyWhileHoldingModifier(mInstrumentation, mTextView,
                KeyEvent.KEYCODE_INSERT, KeyEvent.KEYCODE_SHIFT_LEFT);
        assertEquals(""bca"", mTextView.getText().toString());
    }

    private static boolean hasSpansAtMiddleOfText(final TextView textView, final Class<?> type) {
        final Spannable spannable = (Spannable)textView.getText();
        final int at = spannable.length() / 2;
        return spannable.getSpans(at, at, type).length > 0;
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testCutAndPaste_withAndWithoutStyle"	"CtsWidgetTestCases"	"1: ui"	"public void testCutAndPaste_withAndWithoutStyle() {
        initTextViewForTyping();

        mTextView.setText(""example"", BufferType.EDITABLE);
        mTextView.setSelected(true);

        // Set URLSpan.
        final Spannable spannable = (Spannable) mTextView.getText();
        spannable.setSpan(new URLSpan(""http://example.com""), 0, spannable.length(), 0);
        assertTrue(hasSpansAtMiddleOfText(mTextView, URLSpan.class));

        // Cut entire text.
        Selection.selectAll((Spannable) mTextView.getText());
        mTextView.onTextContextMenuItem(android.R.id.cut);
        assertEquals("""", mTextView.getText().toString());

        // Paste without style.
        mTextView.onTextContextMenuItem(android.R.id.pasteAsPlainText);
        assertEquals(""example"", mTextView.getText().toString());
        // Check that the text doesn't have URLSpan.
        assertFalse(hasSpansAtMiddleOfText(mTextView, URLSpan.class));

        // Paste with style.
        Selection.selectAll((Spannable) mTextView.getText());
        mTextView.onTextContextMenuItem(android.R.id.paste);
        assertEquals(""example"", mTextView.getText().toString());
        // Check that the text has URLSpan.
        assertTrue(hasSpansAtMiddleOfText(mTextView, URLSpan.class));
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSaveInstanceState"	"CtsWidgetTestCases"	"1: ui"	"public void testSaveInstanceState() {
        // should save text when freezesText=true
        TextView originalTextView = new TextView(mActivity);
        final String text = ""This is a string"";
        originalTextView.setText(text);
        originalTextView.setFreezesText(true);  // needed to actually save state
        Parcelable state = originalTextView.onSaveInstanceState();

        TextView restoredTextView = new TextView(mActivity);
        restoredTextView.onRestoreInstanceState(state);
        assertEquals(text, restoredTextView.getText().toString());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testOnSaveInstanceState_whenFreezesTextIsFalse"	"CtsWidgetTestCases"	"1: ui"	"public void testOnSaveInstanceState_whenFreezesTextIsFalse() {
        final String text = ""This is a string"";
        { // should not save text when freezesText=false
            // prepare TextView for before saveInstanceState
            TextView textView1 = new TextView(mActivity);
            textView1.setFreezesText(false);
            textView1.setText(text);

            // prepare TextView for after saveInstanceState
            TextView textView2 = new TextView(mActivity);
            textView2.setFreezesText(false);

            textView2.onRestoreInstanceState(textView1.onSaveInstanceState());

            assertEquals("""", textView2.getText().toString());
        }

        { // should not save text even when textIsSelectable=true
            // prepare TextView for before saveInstanceState
            TextView textView1 = new TextView(mActivity);
            textView1.setFreezesText(false);
            textView1.setTextIsSelectable(true);
            textView1.setText(text);

            // prepare TextView for after saveInstanceState
            TextView textView2 = new TextView(mActivity);
            textView2.setFreezesText(false);
            textView2.setTextIsSelectable(true);

            textView2.onRestoreInstanceState(textView1.onSaveInstanceState());

            assertEquals("""", textView2.getText().toString());
        }
    }

    @UiThreadTest
    @SmallTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testOnSaveInstanceState_doesNotSaveSelectionWhenDoesNotExist"	"CtsWidgetTestCases"	"1: ui"	"public void testOnSaveInstanceState_doesNotSaveSelectionWhenDoesNotExist() {
        // prepare TextView for before saveInstanceState
        final String text = ""This is a string"";
        TextView textView1 = new TextView(mActivity);
        textView1.setFreezesText(true);
        textView1.setText(text);

        // prepare TextView for after saveInstanceState
        TextView textView2 = new TextView(mActivity);
        textView2.setFreezesText(true);

        textView2.onRestoreInstanceState(textView1.onSaveInstanceState());

        assertEquals(-1, textView2.getSelectionStart());
        assertEquals(-1, textView2.getSelectionEnd());
    }

    @UiThreadTest
    @SmallTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testOnSaveInstanceState_doesNotRestoreSelectionWhenTextIsAbsent"	"CtsWidgetTestCases"	"1: ui"	"public void testOnSaveInstanceState_doesNotRestoreSelectionWhenTextIsAbsent() {
        // prepare TextView for before saveInstanceState
        final String text = ""This is a string"";
        TextView textView1 = new TextView(mActivity);
        textView1.setFreezesText(false);
        textView1.setTextIsSelectable(true);
        textView1.setText(text);
        Selection.setSelection((Spannable) textView1.getText(), 2, text.length() - 2);

        // prepare TextView for after saveInstanceState
        TextView textView2 = new TextView(mActivity);
        textView2.setFreezesText(false);
        textView2.setTextIsSelectable(true);

        textView2.onRestoreInstanceState(textView1.onSaveInstanceState());

        assertEquals("""", textView2.getText().toString());
        //when textIsSelectable, selection start and end are initialized to 0
        assertEquals(0, textView2.getSelectionStart());
        assertEquals(0, textView2.getSelectionEnd());
    }

    @UiThreadTest
    @SmallTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testOnSaveInstanceState_savesSelectionWhenExists"	"CtsWidgetTestCases"	"1: ui"	"public void testOnSaveInstanceState_savesSelectionWhenExists() {
        final String text = ""This is a string"";
        // prepare TextView for before saveInstanceState
        TextView textView1 = new TextView(mActivity);
        textView1.setFreezesText(true);
        textView1.setTextIsSelectable(true);
        textView1.setText(text);
        Selection.setSelection((Spannable) textView1.getText(), 2, text.length() - 2);

        // prepare TextView for after saveInstanceState
        TextView textView2 = new TextView(mActivity);
        textView2.setFreezesText(true);
        textView2.setTextIsSelectable(true);

        textView2.onRestoreInstanceState(textView1.onSaveInstanceState());

        assertEquals(textView1.getSelectionStart(), textView2.getSelectionStart());
        assertEquals(textView1.getSelectionEnd(), textView2.getSelectionEnd());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetText"	"CtsWidgetTestCases"	"1: ui"	"public void testSetText() {
        TextView tv = findTextView(R.id.textview_text);

        int resId = R.string.text_view_hint;
        String result = mActivity.getResources().getString(resId);

        tv.setText(resId, BufferType.EDITABLE);
        assertEquals(result, tv.getText().toString());
        assertTrue(tv.getText() instanceof Editable);

        tv.setText(resId, BufferType.SPANNABLE);
        assertEquals(result, tv.getText().toString());
        assertTrue(tv.getText() instanceof Spannable);

        try {
            tv.setText(-1, BufferType.EDITABLE);
            fail(""Should throw exception with illegal id"");
        } catch (NotFoundException e) {
        }
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAccessError"	"CtsWidgetTestCases"	"1: ui"	"public void testAccessError() throws Throwable {
        mTextView = findTextView(R.id.textview_text);
        assertNull(mTextView.getError());

        final String errorText = ""Oops! There is an error"";

        mActivityRule.runOnUiThread(() -> mTextView.setError(null));
        mInstrumentation.waitForIdleSync();
        assertNull(mTextView.getError());

        final Drawable icon = TestUtils.getDrawable(mActivity, R.drawable.failed);
        mActivityRule.runOnUiThread(() -> mTextView.setError(errorText, icon));
        mInstrumentation.waitForIdleSync();
        assertEquals(errorText, mTextView.getError().toString());
        // can not check whether the drawable is set correctly

        mActivityRule.runOnUiThread(() -> mTextView.setError(null, null));
        mInstrumentation.waitForIdleSync();
        assertNull(mTextView.getError());

        mActivityRule.runOnUiThread(() -> {
            mTextView.setKeyListener(DigitsKeyListener.getInstance(""""));
            mTextView.setText("""", BufferType.EDITABLE);
            mTextView.setError(errorText);
            mTextView.requestFocus();
        });
        mInstrumentation.waitForIdleSync();

        assertEquals(errorText, mTextView.getError().toString());

        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""a"");
        // a key event that will not change the TextView's text
        assertEquals("""", mTextView.getText().toString());
        // The icon and error message will not be reset to null
        assertEquals(errorText, mTextView.getError().toString());

        mActivityRule.runOnUiThread(() -> {
            mTextView.setKeyListener(DigitsKeyListener.getInstance());
            mTextView.setText("""", BufferType.EDITABLE);
            mTextView.setError(errorText);
            mTextView.requestFocus();
        });
        mInstrumentation.waitForIdleSync();

        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""1"");
        // a key event cause changes to the TextView's text
        assertEquals(""1"", mTextView.getText().toString());
        // the error message and icon will be cleared.
        assertNull(mTextView.getError());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAccessFilters"	"CtsWidgetTestCases"	"1: ui"	"public void testAccessFilters() throws Throwable {
        final InputFilter[] expected = { new InputFilter.AllCaps(),
                new InputFilter.LengthFilter(2) };

        final QwertyKeyListener qwertyKeyListener
                = QwertyKeyListener.getInstance(false, Capitalize.NONE);
        mActivityRule.runOnUiThread(() -> {
            mTextView = findTextView(R.id.textview_text);
            mTextView.setKeyListener(qwertyKeyListener);
            mTextView.setText("""", BufferType.EDITABLE);
            mTextView.setFilters(expected);
            mTextView.requestFocus();
        });
        mInstrumentation.waitForIdleSync();

        assertSame(expected, mTextView.getFilters());

        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""a"");
        // the text is capitalized by InputFilter.AllCaps
        assertEquals(""A"", mTextView.getText().toString());
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""b"");
        // the text is capitalized by InputFilter.AllCaps
        assertEquals(""AB"", mTextView.getText().toString());
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""c"");
        // 'C' could not be accepted, because there is a length filter.
        assertEquals(""AB"", mTextView.getText().toString());

        try {
            mTextView.setFilters(null);
            fail(""Should throw IllegalArgumentException!"");
        } catch (IllegalArgumentException e) {
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetFocusedRect"	"CtsWidgetTestCases"	"1: ui"	"public void testGetFocusedRect() throws Throwable {
        Rect rc = new Rect();

        // Basic
        mActivityRule.runOnUiThread(() -> mTextView = new TextView(mActivity));
        mInstrumentation.waitForIdleSync();
        mTextView.getFocusedRect(rc);
        assertEquals(mTextView.getScrollX(), rc.left);
        assertEquals(mTextView.getScrollX() + mTextView.getWidth(), rc.right);
        assertEquals(mTextView.getScrollY(), rc.top);
        assertEquals(mTextView.getScrollY() + mTextView.getHeight(), rc.bottom);

        // Single line
        mTextView = findTextView(R.id.textview_text);
        mTextView.getFocusedRect(rc);
        assertEquals(mTextView.getScrollX(), rc.left);
        assertEquals(mTextView.getScrollX() + mTextView.getWidth(), rc.right);
        assertEquals(mTextView.getScrollY(), rc.top);
        assertEquals(mTextView.getScrollY() + mTextView.getHeight(), rc.bottom);

        mActivityRule.runOnUiThread(() -> {
            final SpannableString text = new SpannableString(mTextView.getText());
            mTextView.setTextIsSelectable(true);
            mTextView.setText(text);
            Selection.setSelection((Spannable) mTextView.getText(), 3, 13);
        });
        mInstrumentation.waitForIdleSync();
        mTextView.getFocusedRect(rc);
        assertNotNull(mTextView.getLayout());
        /* Cursor coordinates from getPrimaryHorizontal() may have a fractional
         * component, while the result of getFocusedRect is in int coordinates.
         * It's not practical for these to match exactly, so we compare that the
         * integer components match - there can be a fractional pixel
         * discrepancy, which should be okay for all practical applications. */
        assertEquals((int) mTextView.getLayout().getPrimaryHorizontal(3), rc.left);
        assertEquals((int) mTextView.getLayout().getPrimaryHorizontal(13), rc.right);
        assertEquals(mTextView.getLayout().getLineTop(0), rc.top);
        assertEquals(mTextView.getLayout().getLineBottom(0), rc.bottom);

        mActivityRule.runOnUiThread(() -> {
            final SpannableString text = new SpannableString(mTextView.getText());
            mTextView.setTextIsSelectable(true);
            mTextView.setText(text);
            Selection.setSelection((Spannable) mTextView.getText(), 13, 3);
        });
        mInstrumentation.waitForIdleSync();
        mTextView.getFocusedRect(rc);
        assertNotNull(mTextView.getLayout());
        assertEquals((int) mTextView.getLayout().getPrimaryHorizontal(3) - 2, rc.left);
        assertEquals((int) mTextView.getLayout().getPrimaryHorizontal(3) + 2, rc.right);
        assertEquals(mTextView.getLayout().getLineTop(0), rc.top);
        assertEquals(mTextView.getLayout().getLineBottom(0), rc.bottom);

        // Multi lines
        mTextView = findTextView(R.id.textview_text_two_lines);
        mTextView.getFocusedRect(rc);
        assertEquals(mTextView.getScrollX(), rc.left);
        assertEquals(mTextView.getScrollX() + mTextView.getWidth(), rc.right);
        assertEquals(mTextView.getScrollY(), rc.top);
        assertEquals(mTextView.getScrollY() + mTextView.getHeight(), rc.bottom);

        mActivityRule.runOnUiThread(() -> {
            final SpannableString text = new SpannableString(mTextView.getText());
            mTextView.setTextIsSelectable(true);
            mTextView.setText(text);
            Selection.setSelection((Spannable) mTextView.getText(), 2, 4);
        });
        mInstrumentation.waitForIdleSync();
        mTextView.getFocusedRect(rc);
        assertNotNull(mTextView.getLayout());
        assertEquals((int) mTextView.getLayout().getPrimaryHorizontal(2), rc.left);
        assertEquals((int) mTextView.getLayout().getPrimaryHorizontal(4), rc.right);
        assertEquals(mTextView.getLayout().getLineTop(0), rc.top);
        assertEquals(mTextView.getLayout().getLineBottom(0), rc.bottom);

        mActivityRule.runOnUiThread(() -> {
            final SpannableString text = new SpannableString(mTextView.getText());
            mTextView.setTextIsSelectable(true);
            mTextView.setText(text);
            // cross the ""\n"" and two lines
            Selection.setSelection((Spannable) mTextView.getText(), 2, 10);
        });
        mInstrumentation.waitForIdleSync();
        mTextView.getFocusedRect(rc);
        Path path = new Path();
        mTextView.getLayout().getSelectionPath(2, 10, path);
        RectF rcf = new RectF();
        path.computeBounds(rcf, true);
        assertNotNull(mTextView.getLayout());
        assertEquals(rcf.left - 1, (float) rc.left, 0.0f);
        assertEquals(rcf.right + 1, (float) rc.right, 0.0f);
        assertEquals(mTextView.getLayout().getLineTop(0), rc.top);
        assertEquals(mTextView.getLayout().getLineBottom(1), rc.bottom);

        // Exception
        try {
            mTextView.getFocusedRect(null);
            fail(""Should throw NullPointerException!"");
        } catch (NullPointerException e) {
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetLineCount"	"CtsWidgetTestCases"	"1: ui"	"public void testGetLineCount() throws Throwable {
        mActivityRule.runOnUiThread(() -> mTextView = findTextView(R.id.textview_text));
        mInstrumentation.waitForIdleSync();
        // this is an one line text with default setting.
        assertEquals(1, mTextView.getLineCount());

        // make it multi-lines
        setMaxWidth(mTextView.getWidth() / 3);
        assertTrue(1 < mTextView.getLineCount());

        // make it to an one line
        setMaxWidth(Integer.MAX_VALUE);
        assertEquals(1, mTextView.getLineCount());

        // set min lines don't effect the lines count for actual text.
        setMinLines(12);
        assertEquals(1, mTextView.getLineCount());

        mActivityRule.runOnUiThread(() -> mTextView = new TextView(mActivity));
        mInstrumentation.waitForIdleSync();
        // the internal Layout has not been built.
        assertNull(mTextView.getLayout());
        assertEquals(0, mTextView.getLineCount());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetLineBounds"	"CtsWidgetTestCases"	"1: ui"	"public void testGetLineBounds() throws Throwable {
        Rect rc = new Rect();
        mActivityRule.runOnUiThread(() -> mTextView = new TextView(mActivity));
        mInstrumentation.waitForIdleSync();
        assertEquals(0, mTextView.getLineBounds(0, null));

        assertEquals(0, mTextView.getLineBounds(0, rc));
        assertEquals(0, rc.left);
        assertEquals(0, rc.right);
        assertEquals(0, rc.top);
        assertEquals(0, rc.bottom);

        mTextView = findTextView(R.id.textview_text);
        assertEquals(mTextView.getBaseline(), mTextView.getLineBounds(0, null));

        assertEquals(mTextView.getBaseline(), mTextView.getLineBounds(0, rc));
        assertEquals(0, rc.left);
        assertEquals(mTextView.getWidth(), rc.right);
        assertEquals(0, rc.top);
        assertEquals(mTextView.getHeight(), rc.bottom);

        mActivityRule.runOnUiThread(() -> {
            mTextView.setPadding(1, 2, 3, 4);
            mTextView.setGravity(Gravity.BOTTOM);
        });
        mInstrumentation.waitForIdleSync();
        assertEquals(mTextView.getBaseline(), mTextView.getLineBounds(0, rc));
        assertEquals(mTextView.getTotalPaddingLeft(), rc.left);
        assertEquals(mTextView.getWidth() - mTextView.getTotalPaddingRight(), rc.right);
        assertEquals(mTextView.getTotalPaddingTop(), rc.top);
        assertEquals(mTextView.getHeight() - mTextView.getTotalPaddingBottom(), rc.bottom);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetBaseLine"	"CtsWidgetTestCases"	"1: ui"	"public void testGetBaseLine() throws Throwable {
        mActivityRule.runOnUiThread(() -> mTextView = new TextView(mActivity));
        mInstrumentation.waitForIdleSync();
        assertEquals(-1, mTextView.getBaseline());

        mTextView = findTextView(R.id.textview_text);
        assertEquals(mTextView.getLayout().getLineBaseline(0), mTextView.getBaseline());

        mActivityRule.runOnUiThread(() -> {
            mTextView.setPadding(1, 2, 3, 4);
            mTextView.setGravity(Gravity.BOTTOM);
        });
        mInstrumentation.waitForIdleSync();
        int expected = mTextView.getTotalPaddingTop() + mTextView.getLayout().getLineBaseline(0);
        assertEquals(expected, mTextView.getBaseline());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testPressKey"	"CtsWidgetTestCases"	"1: ui"	"public void testPressKey() throws Throwable {
        initTextViewForTypingOnUiThread();

        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""a"");
        assertEquals(""a"", mTextView.getText().toString());
        CtsKeyEventUtil.sendString(mInstrumentation, mTextView, ""b"");
        assertEquals(""ab"", mTextView.getText().toString());
        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, KeyEvent.KEYCODE_DEL);
        assertEquals(""a"", mTextView.getText().toString());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testKeyNavigation"	"CtsWidgetTestCases"	"1: ui"	"public void testKeyNavigation() throws Throwable {
        initTextViewForTypingOnUiThread();
        mActivityRule.runOnUiThread(() -> {
            mActivity.findViewById(R.id.textview_singleLine).setFocusableInTouchMode(true);
            mActivity.findViewById(R.id.textview_text_two_lines).setFocusableInTouchMode(true);
            mTextView.setMovementMethod(ArrowKeyMovementMethod.getInstance());
            mTextView.setText(""abc"");
            mTextView.setFocusableInTouchMode(true);
        });

        mTextView.requestFocus();
        mInstrumentation.waitForIdleSync();
        assertTrue(mTextView.isFocused());

        // Pure-keyboard arrows should not cause focus to leave the textfield
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTextView, KeyEvent.KEYCODE_DPAD_UP);
        mInstrumentation.waitForIdleSync();
        assertTrue(mTextView.isFocused());

        // Non-pure-keyboard arrows, however, should.
        int dpadRemote = InputDevice.SOURCE_DPAD | InputDevice.SOURCE_KEYBOARD;
        sendSourceKeyDownUp(mInstrumentation, mTextView, KeyEvent.KEYCODE_DPAD_UP, dpadRemote);
        mInstrumentation.waitForIdleSync();
        assertFalse(mTextView.isFocused());

        sendSourceKeyDownUp(mInstrumentation, mTextView, KeyEvent.KEYCODE_DPAD_DOWN, dpadRemote);
        mInstrumentation.waitForIdleSync();
        assertTrue(mTextView.isFocused());

        // Tab should
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mTextView, KeyEvent.KEYCODE_TAB);
        mInstrumentation.waitForIdleSync();
        assertFalse(mTextView.isFocused());
    }

    private void sendSourceKeyDownUp(Instrumentation instrumentation, View targetView, int key,
            int source) {
        KeyEvent event = new KeyEvent(KeyEvent.ACTION_DOWN, key);
        event.setSource(source);
        CtsKeyEventUtil.sendKey(instrumentation, targetView, event);
        event = new KeyEvent(KeyEvent.ACTION_UP, key);
        event.setSource(source);
        CtsKeyEventUtil.sendKey(instrumentation, targetView, event);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetIncludeFontPadding"	"CtsWidgetTestCases"	"1: ui"	"public void testSetIncludeFontPadding() throws Throwable {
        mTextView = findTextView(R.id.textview_text);
        assertTrue(mTextView.getIncludeFontPadding());
        mActivityRule.runOnUiThread(() -> {
            mTextView.setWidth(mTextView.getWidth() / 3);
            mTextView.setPadding(1, 2, 3, 4);
            mTextView.setGravity(Gravity.BOTTOM);
        });
        mInstrumentation.waitForIdleSync();

        int oldHeight = mTextView.getHeight();
        mActivityRule.runOnUiThread(() -> mTextView.setIncludeFontPadding(false));
        mInstrumentation.waitForIdleSync();

        assertTrue(mTextView.getHeight() < oldHeight);
        assertFalse(mTextView.getIncludeFontPadding());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testDebug"	"CtsWidgetTestCases"	"1: ui"	"public void testDebug() throws Throwable {
        mActivityRule.runOnUiThread(() -> {
            mTextView = new TextView(mActivity);
            mTextView.debug(0);
            mTextView.setText(""Hello!"");
        });
        mInstrumentation.waitForIdleSync();

        layout(mTextView);
        mTextView.debug(1);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testOnSelectionChangedIsTriggeredWhenSelectionChanges"	"CtsWidgetTestCases"	"1: ui"	"public void testOnSelectionChangedIsTriggeredWhenSelectionChanges() throws Throwable {
        final String text = ""any text"";
        mActivityRule.runOnUiThread(() -> mTextView = spy(new MockTextView(mActivity)));
        mInstrumentation.waitForIdleSync();
        mTextView.setText(text, BufferType.SPANNABLE);

        // assert that there is currently no selection
        assertFalse(mTextView.hasSelection());

        // select all
        Selection.selectAll((Spannable) mTextView.getText());
        // After selectAll OnSelectionChanged should have been called
        ((MockTextView) verify(mTextView, times(1))).onSelectionChanged(0, text.length());

        reset(mTextView);
        // change selection
        Selection.setSelection((Spannable) mTextView.getText(), 1, 5);
        ((MockTextView) verify(mTextView, times(1))).onSelectionChanged(1, 5);

        reset(mTextView);
        // clear selection
        Selection.removeSelection((Spannable) mTextView.getText());
        ((MockTextView) verify(mTextView, times(1))).onSelectionChanged(-1, -1);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testEllipsizeAndMaxLinesForSingleLine"	"CtsWidgetTestCases"	"1: ui"	"public void testEllipsizeAndMaxLinesForSingleLine() throws Throwable {
        // no maxline or ellipsize set, single line text
        final TextView tvNoMaxLine = new TextView(mActivity);
        tvNoMaxLine.setLineSpacing(0, 1.5f);
        tvNoMaxLine.setText(""a"");

        // maxline set, no ellipsize, text with two lines
        final TextView tvEllipsizeNone = new TextView(mActivity);
        tvEllipsizeNone.setMaxLines(1);
        tvEllipsizeNone.setLineSpacing(0, 1.5f);
        tvEllipsizeNone.setText(""a\na"");

        // maxline set, ellipsize end, text with two lines
        final TextView tvEllipsizeEnd = new TextView(mActivity);
        tvEllipsizeEnd.setEllipsize(TruncateAt.END);
        tvEllipsizeEnd.setMaxLines(1);
        tvEllipsizeEnd.setLineSpacing(0, 1.5f);
        tvEllipsizeEnd.setText(""a\na"");

        final FrameLayout layout = new FrameLayout(mActivity);
        ViewGroup.LayoutParams layoutParams = new ViewGroup.LayoutParams(
                ViewGroup.LayoutParams.WRAP_CONTENT,
                ViewGroup.LayoutParams.WRAP_CONTENT);
        layout.addView(tvEllipsizeEnd, layoutParams);
        layout.addView(tvEllipsizeNone, layoutParams);
        layout.addView(tvNoMaxLine, layoutParams);

        mActivityRule.runOnUiThread(() -> mActivity.setContentView(layout,
                new ViewGroup.LayoutParams(
                        ViewGroup.LayoutParams.MATCH_PARENT,
                        ViewGroup.LayoutParams.MATCH_PARENT)));
        mInstrumentation.waitForIdleSync();

        assertEquals(tvEllipsizeEnd.getHeight(), tvEllipsizeNone.getHeight());

        assertEquals(tvEllipsizeEnd.getHeight(), tvNoMaxLine.getHeight());

        assertEquals(tvEllipsizeEnd.getLayout().getLineBaseline(0),
                tvEllipsizeNone.getLayout().getLineBaseline(0));

        assertEquals(tvEllipsizeEnd.getLayout().getLineBaseline(0),
                tvNoMaxLine.getLayout().getLineBaseline(0));
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testEllipsizeAndMaxLinesForMultiLine"	"CtsWidgetTestCases"	"1: ui"	"public void testEllipsizeAndMaxLinesForMultiLine() throws Throwable {
        // no maxline, no ellipsize, text with two lines
        final TextView tvNoMaxLine = new TextView(mActivity);
        tvNoMaxLine.setLineSpacing(0, 1.5f);
        tvNoMaxLine.setText(""a\na"");

        // maxline set, no ellipsize, text with three lines
        final TextView tvEllipsizeNone = new TextView(mActivity);
        tvEllipsizeNone.setMaxLines(2);
        tvEllipsizeNone.setLineSpacing(0, 1.5f);
        tvEllipsizeNone.setText(""a\na\na"");

        // maxline set, ellipsize end, text with three lines
        final TextView tvEllipsizeEnd = new TextView(mActivity);
        tvEllipsizeEnd.setEllipsize(TruncateAt.END);
        tvEllipsizeEnd.setMaxLines(2);
        tvEllipsizeEnd.setLineSpacing(0, 1.5f);
        tvEllipsizeEnd.setText(""a\na\na"");

        final FrameLayout layout = new FrameLayout(mActivity);
        ViewGroup.LayoutParams layoutParams = new ViewGroup.LayoutParams(
                ViewGroup.LayoutParams.WRAP_CONTENT,
                ViewGroup.LayoutParams.WRAP_CONTENT);

        layout.addView(tvNoMaxLine, layoutParams);
        layout.addView(tvEllipsizeEnd, layoutParams);
        layout.addView(tvEllipsizeNone, layoutParams);

        mActivityRule.runOnUiThread(() ->  mActivity.setContentView(layout,
                new ViewGroup.LayoutParams(
                        ViewGroup.LayoutParams.MATCH_PARENT,
                        ViewGroup.LayoutParams.MATCH_PARENT)));
        mInstrumentation.waitForIdleSync();

        assertEquals(tvEllipsizeEnd.getHeight(), tvEllipsizeNone.getHeight());

        assertEquals(tvEllipsizeEnd.getHeight(), tvNoMaxLine.getHeight());

        for (int i = 0; i < tvEllipsizeEnd.getLineCount(); i++) {
            assertEquals(""Should have the same baseline for line "" + i,
                    tvEllipsizeEnd.getLayout().getLineBaseline(i),
                    tvEllipsizeNone.getLayout().getLineBaseline(i));

            assertEquals(""Should have the same baseline for line "" + i,
                    tvEllipsizeEnd.getLayout().getLineBaseline(i),
                    tvNoMaxLine.getLayout().getLineBaseline(i));
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testEllipsizeAndMaxLinesForHint"	"CtsWidgetTestCases"	"1: ui"	"public void testEllipsizeAndMaxLinesForHint() throws Throwable {
        // no maxline, no ellipsize, hint with two lines
        final TextView tvTwoLines = new TextView(mActivity);
        tvTwoLines.setLineSpacing(0, 1.5f);
        tvTwoLines.setHint(""a\na"");

        // no maxline, no ellipsize, hint with three lines
        final TextView tvThreeLines = new TextView(mActivity);
        tvThreeLines.setLineSpacing(0, 1.5f);
        tvThreeLines.setHint(""a\na\na"");

        // maxline set, ellipsize end, hint with three lines
        final TextView tvEllipsizeEnd = new TextView(mActivity);
        tvEllipsizeEnd.setEllipsize(TruncateAt.END);
        tvEllipsizeEnd.setMaxLines(2);
        tvEllipsizeEnd.setLineSpacing(0, 1.5f);
        tvEllipsizeEnd.setHint(""a\na\na"");

        // maxline set, no ellipsize, hint with three lines
        final TextView tvEllipsizeNone = new TextView(mActivity);
        tvEllipsizeNone.setMaxLines(2);
        tvEllipsizeNone.setLineSpacing(0, 1.5f);
        tvEllipsizeNone.setHint(""a\na\na"");

        final FrameLayout layout = new FrameLayout(mActivity);
        ViewGroup.LayoutParams layoutParams = new ViewGroup.LayoutParams(
                ViewGroup.LayoutParams.WRAP_CONTENT,
                ViewGroup.LayoutParams.WRAP_CONTENT);

        layout.addView(tvTwoLines, layoutParams);
        layout.addView(tvEllipsizeEnd, layoutParams);
        layout.addView(tvEllipsizeNone, layoutParams);
        layout.addView(tvThreeLines, layoutParams);

        mActivityRule.runOnUiThread(() ->  mActivity.setContentView(layout,
                new ViewGroup.LayoutParams(
                        ViewGroup.LayoutParams.MATCH_PARENT,
                        ViewGroup.LayoutParams.MATCH_PARENT)));
        mInstrumentation.waitForIdleSync();

        assertEquals(""Non-ellipsized hint should not crop text at maxLines"",
                tvThreeLines.getHeight(), tvEllipsizeNone.getHeight());

        assertEquals(""Ellipsized hint should crop text at maxLines"",
                tvTwoLines.getHeight(), tvEllipsizeEnd.getHeight());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAccessCursorVisible"	"CtsWidgetTestCases"	"1: ui"	"public void testAccessCursorVisible() {
        mTextView = new TextView(mActivity);

        mTextView.setCursorVisible(true);
        assertTrue(mTextView.isCursorVisible());
        mTextView.setCursorVisible(false);
        assertFalse(mTextView.isCursorVisible());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"isCursorVisible"	"CtsWidgetTestCases"	"1: ui"	"public void setSetImeConsumesInput() {
        InputConnection input = initTextViewForSimulatedIme();
        mTextView.setCursorVisible(true);
        assertTrue(mTextView.isCursorVisible());

        mTextView.setImeConsumesInput(true);
        assertFalse(mTextView.isCursorVisible());

        mTextView.setCursorVisible(true);
        assertFalse(mTextView.isCursorVisible());

        input.closeConnection();
        assertTrue(mTextView.isCursorVisible());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testPerformLongClick"	"CtsWidgetTestCases"	"2: ui interaction"	"public void testPerformLongClick() {
        mTextView = findTextView(R.id.textview_text);
        mTextView.setText(""This is content"");

        View.OnLongClickListener mockOnLongClickListener = mock(View.OnLongClickListener.class);
        when(mockOnLongClickListener.onLongClick(any(View.class))).thenReturn(Boolean.TRUE);

        View.OnCreateContextMenuListener mockOnCreateContextMenuListener =
                mock(View.OnCreateContextMenuListener.class);
        doAnswer((InvocationOnMock invocation) -> {
            ((ContextMenu) invocation.getArguments() [0]).add(""menu item"");
            return null;
        }).when(mockOnCreateContextMenuListener).onCreateContextMenu(
                any(ContextMenu.class), any(View.class), any());

        mTextView.setOnLongClickListener(mockOnLongClickListener);
        mTextView.setOnCreateContextMenuListener(mockOnCreateContextMenuListener);
        assertTrue(mTextView.performLongClick());
        verify(mockOnLongClickListener, times(1)).onLongClick(mTextView);
        verifyZeroInteractions(mockOnCreateContextMenuListener);

        reset(mockOnLongClickListener);
        when(mockOnLongClickListener.onLongClick(any(View.class))).thenReturn(Boolean.FALSE);
        assertTrue(mTextView.performLongClick());
        verify(mockOnLongClickListener, times(1)).onLongClick(mTextView);
        verify(mockOnCreateContextMenuListener, times(1)).onCreateContextMenu(
                any(ContextMenu.class), eq(mTextView), any());

        reset(mockOnCreateContextMenuListener);
        mTextView.setOnLongClickListener(null);
        doNothing().when(mockOnCreateContextMenuListener).onCreateContextMenu(
                any(ContextMenu.class), any(View.class), any());
        assertFalse(mTextView.performLongClick());
        verifyNoMoreInteractions(mockOnLongClickListener);
        verify(mockOnCreateContextMenuListener, times(1)).onCreateContextMenu(
                any(ContextMenu.class), eq(mTextView), any());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testTextAttr"	"CtsWidgetTestCases"	"1: ui"	"public void testTextAttr() {
        mTextView = findTextView(R.id.textview_textAttr);
        // getText
        assertEquals(mActivity.getString(R.string.text_view_hello), mTextView.getText().toString());

        // getCurrentTextColor
        assertEquals(mActivity.getResources().getColor(R.drawable.black),
                mTextView.getCurrentTextColor());
        assertEquals(mActivity.getResources().getColor(R.drawable.red),
                mTextView.getCurrentHintTextColor());
        assertEquals(mActivity.getResources().getColor(R.drawable.red),
                mTextView.getHintTextColors().getDefaultColor());
        assertEquals(mActivity.getResources().getColor(R.drawable.blue),
                mTextView.getLinkTextColors().getDefaultColor());

        // getTextScaleX
        assertEquals(1.2f, mTextView.getTextScaleX(), 0.01f);

        // setTextScaleX
        mTextView.setTextScaleX(2.4f);
        assertEquals(2.4f, mTextView.getTextScaleX(), 0.01f);

        mTextView.setTextScaleX(0f);
        assertEquals(0f, mTextView.getTextScaleX(), 0.01f);

        mTextView.setTextScaleX(- 2.4f);
        assertEquals(- 2.4f, mTextView.getTextScaleX(), 0.01f);

        // getTextSize
        assertEquals(20f, mTextView.getTextSize(), 0.01f);

        // getTypeface
        // getTypeface will be null if android:typeface is set to normal,
        // and android:style is not set or is set to normal, and
        // android:fontFamily is not set
        assertNull(mTextView.getTypeface());

        mTextView.setTypeface(Typeface.DEFAULT);
        assertSame(Typeface.DEFAULT, mTextView.getTypeface());
        // null type face
        mTextView.setTypeface(null);
        assertNull(mTextView.getTypeface());

        // default type face, bold style, note: the type face will be changed
        // after call set method
        mTextView.setTypeface(Typeface.DEFAULT, Typeface.BOLD);
        assertSame(Typeface.BOLD, mTextView.getTypeface().getStyle());

        // null type face, BOLD style
        mTextView.setTypeface(null, Typeface.BOLD);
        assertSame(Typeface.BOLD, mTextView.getTypeface().getStyle());

        // old type face, null style
        mTextView.setTypeface(Typeface.DEFAULT, 0);
        assertEquals(Typeface.NORMAL, mTextView.getTypeface().getStyle());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testTextAttr_zeroTextSize"	"CtsWidgetTestCases"	"1: ui"	"public void testTextAttr_zeroTextSize() {
        mTextView = findTextView(R.id.textview_textAttr_zeroTextSize);
        // text size should be 0 as set in xml, rather than the text view default (15.0)
        assertEquals(0f, mTextView.getTextSize(), 0.01f);
        // text size can be set programmatically to non-negative values
        mTextView.setTextSize(20f);
        assertTrue(mTextView.getTextSize() > 0.0f);
        mTextView.setTextSize(0f);
        assertEquals(0f, mTextView.getTextSize(), 0.01f);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAppend"	"CtsWidgetTestCases"	"1: ui"	"public void testAppend() {
        mTextView = new TextView(mActivity);

        // 1: check the original length, should be blank as initialised.
        assertEquals(0, mTextView.getText().length());

        // 2: append a string use append(CharSquence) into the original blank
        // buffer, check the content. And upgrading it to BufferType.EDITABLE if it was
        // not already editable.
        assertFalse(mTextView.getText() instanceof Editable);
        mTextView.append(""Append."");
        assertEquals(""Append."", mTextView.getText().toString());
        assertTrue(mTextView.getText() instanceof Editable);

        // 3: append a string from 0~3.
        mTextView.append(""Append"", 0, 3);
        assertEquals(""Append.App"", mTextView.getText().toString());
        assertTrue(mTextView.getText() instanceof Editable);

        // 4: append a string from 0~0, nothing will be append as expected.
        mTextView.append(""Append"", 0, 0);
        assertEquals(""Append.App"", mTextView.getText().toString());
        assertTrue(mTextView.getText() instanceof Editable);

        // 5: append a string from -3~3. check the wrong left edge.
        try {
            mTextView.append(""Append"", -3, 3);
            fail(""Should throw StringIndexOutOfBoundsException"");
        } catch (StringIndexOutOfBoundsException e) {
        }

        // 6: append a string from 3~10. check the wrong right edge.
        try {
            mTextView.append(""Append"", 3, 10);
            fail(""Should throw StringIndexOutOfBoundsException"");
        } catch (StringIndexOutOfBoundsException e) {
        }

        // 7: append a null string.
        try {
            mTextView.append(null);
            fail(""Should throw NullPointerException"");
        } catch (NullPointerException e) {
        }
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAppend_doesNotAddLinksWhenAppendedTextDoesNotContainLinks"	"CtsWidgetTestCases"	"1: ui"	"public void testAppend_doesNotAddLinksWhenAppendedTextDoesNotContainLinks() {
        mTextView = new TextView(mActivity);
        mTextView.setAutoLinkMask(Linkify.ALL);
        mTextView.setText(""text without URL"");

        mTextView.append("" another text without URL"");

        Spannable text = (Spannable) mTextView.getText();
        URLSpan[] urlSpans = text.getSpans(0, text.length(), URLSpan.class);
        assertEquals(""URLSpan count should be zero"", 0, urlSpans.length);
        assertEquals(""text without URL another text without URL"", text.toString());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAppend_doesNotAddLinksWhenAutoLinkIsNotEnabled"	"CtsWidgetTestCases"	"1: ui"	"public void testAppend_doesNotAddLinksWhenAutoLinkIsNotEnabled() {
        mTextView = new TextView(mActivity);
        mTextView.setText(""text without URL"");

        mTextView.append("" text with URL http://android.com"");

        Spannable text = (Spannable) mTextView.getText();
        URLSpan[] urlSpans = text.getSpans(0, text.length(), URLSpan.class);
        assertEquals(""URLSpan count should be zero"", 0, urlSpans.length);
        assertEquals(""text without URL text with URL http://android.com"", text.toString());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAppend_addsLinksWhenAutoLinkIsEnabled"	"CtsWidgetTestCases"	"1: ui"	"public void testAppend_addsLinksWhenAutoLinkIsEnabled() {
        mTextView = new TextView(mActivity);
        mTextView.setAutoLinkMask(Linkify.ALL);
        mTextView.setText(""text without URL"");

        mTextView.append("" text with URL http://android.com"");

        Spannable text = (Spannable) mTextView.getText();
        URLSpan[] urlSpans = text.getSpans(0, text.length(), URLSpan.class);
        assertEquals(""URLSpan count should be one after appending a URL"", 1, urlSpans.length);
        assertEquals(""URLSpan URL should be same as the appended URL"",
                urlSpans[0].getURL(), ""http://android.com"");
        assertEquals(""text without URL text with URL http://android.com"", text.toString());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAppend_addsLinksEvenWhenThereAreUrlsSetBefore"	"CtsWidgetTestCases"	"1: ui"	"public void testAppend_addsLinksEvenWhenThereAreUrlsSetBefore() {
        mTextView = new TextView(mActivity);
        mTextView.setAutoLinkMask(Linkify.ALL);
        mTextView.setText(""text with URL http://android.com/before"");

        mTextView.append("" text with URL http://android.com"");

        Spannable text = (Spannable) mTextView.getText();
        URLSpan[] urlSpans = text.getSpans(0, text.length(), URLSpan.class);
        assertEquals(""URLSpan count should be two after appending another URL"", 2, urlSpans.length);
        assertEquals(""First URLSpan URL should be same"",
                urlSpans[0].getURL(), ""http://android.com/before"");
        assertEquals(""URLSpan URL should be same as the appended URL"",
                urlSpans[1].getURL(), ""http://android.com"");
        assertEquals(""text with URL http://android.com/before text with URL http://android.com"",
                text.toString());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAppend_setsMovementMethodWhenTextContainsUrlAndAutoLinkIsEnabled"	"CtsWidgetTestCases"	"1: ui"	"public void testAppend_setsMovementMethodWhenTextContainsUrlAndAutoLinkIsEnabled() {
        mTextView = new TextView(mActivity);
        mTextView.setAutoLinkMask(Linkify.ALL);
        mTextView.setText(""text without a URL"");

        mTextView.append("" text with a url: http://android.com"");

        assertNotNull(""MovementMethod should not be null when text contains url"",
                mTextView.getMovementMethod());
        assertTrue(""MovementMethod should be instance of LinkMovementMethod when text contains url"",
                mTextView.getMovementMethod() instanceof LinkMovementMethod);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAppend_addsLinksWhenTextIsSpannableAndContainsUrlAndAutoLinkIsEnabled"	"CtsWidgetTestCases"	"1: ui"	"public void testAppend_addsLinksWhenTextIsSpannableAndContainsUrlAndAutoLinkIsEnabled() {
        mTextView = new TextView(mActivity);
        mTextView.setAutoLinkMask(Linkify.ALL);
        mTextView.setText(""text without a URL"");

        mTextView.append(new SpannableString("" text with a url: http://android.com""));

        Spannable text = (Spannable) mTextView.getText();
        URLSpan[] urlSpans = text.getSpans(0, text.length(), URLSpan.class);
        assertEquals(""URLSpan count should be one after appending a URL"", 1, urlSpans.length);
        assertEquals(""URLSpan URL should be same as the appended URL"",
                urlSpans[0].getURL(), ""http://android.com"");
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAppend_addsLinkIfAppendedTextCompletesPartialUrlAtTheEndOfExistingText"	"CtsWidgetTestCases"	"1: ui"	"public void testAppend_addsLinkIfAppendedTextCompletesPartialUrlAtTheEndOfExistingText() {
        mTextView = new TextView(mActivity);
        mTextView.setAutoLinkMask(Linkify.ALL);
        mTextView.setText(""text with a partial url android."");

        mTextView.append(""com"");

        Spannable text = (Spannable) mTextView.getText();
        URLSpan[] urlSpans = text.getSpans(0, text.length(), URLSpan.class);
        assertEquals(""URLSpan count should be one after appending to partial URL"",
                1, urlSpans.length);
        assertEquals(""URLSpan URL should be same as the appended URL"",
                urlSpans[0].getURL(), ""http://android.com"");
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAppend_addsLinkIfAppendedTextUpdatesUrlAtTheEndOfExistingText"	"CtsWidgetTestCases"	"1: ui"	"public void testAppend_addsLinkIfAppendedTextUpdatesUrlAtTheEndOfExistingText() {
        mTextView = new TextView(mActivity);
        mTextView.setAutoLinkMask(Linkify.ALL);
        mTextView.setText(""text with a url http://android.com"");

        mTextView.append(""/textview"");

        Spannable text = (Spannable) mTextView.getText();
        URLSpan[] urlSpans = text.getSpans(0, text.length(), URLSpan.class);
        assertEquals(""URLSpan count should still be one after extending a URL"", 1, urlSpans.length);
        assertEquals(""URLSpan URL should be same as the new URL"",
                urlSpans[0].getURL(), ""http://android.com/textview"");
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetLetterSpacingChangesTextWidth"	"CtsWidgetTestCases"	"1: ui"	"public void testSetLetterSpacingChangesTextWidth() throws Throwable {
        mActivityRule.runOnUiThread(() -> {
            mTextView = new TextView(mActivity);
            mTextView.setText(""aa"");
            mTextView.setLetterSpacing(0f);
            mTextView.setTextSize(8f);
        });
        mInstrumentation.waitForIdleSync();

        final FrameLayout layout = new FrameLayout(mActivity);
        final ViewGroup.LayoutParams layoutParams = new ViewGroup.LayoutParams(
                ViewGroup.LayoutParams.WRAP_CONTENT,
                ViewGroup.LayoutParams.MATCH_PARENT);
        layout.addView(mTextView, layoutParams);
        layout.setLayoutParams(layoutParams);

        mActivityRule.runOnUiThread(() -> mActivity.setContentView(layout));
        mInstrumentation.waitForIdleSync();

        // measure text with zero letter spacing
        final float zeroSpacing = mTextView.getLayout().getLineWidth(0);

        mActivityRule.runOnUiThread(() -> mTextView.setLetterSpacing(1f));
        mInstrumentation.waitForIdleSync();

        // measure text with single letter spacing
        final float singleSpacing = mTextView.getLayout().getLineWidth(0);

        mActivityRule.runOnUiThread(() -> mTextView.setLetterSpacing(2f));
        mInstrumentation.waitForIdleSync();

        // measure text with double letter spacing
        final float doubleSpacing = mTextView.getLayout().getLineWidth(0);

        assertEquals(""Double spacing should have two times the spacing of single spacing"",
                doubleSpacing - zeroSpacing, 2f * (singleSpacing - zeroSpacing), 2f);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetFontFeatureSettings_returnsValueThatWasSet"	"CtsWidgetTestCases"	"1: ui"	"public void testGetFontFeatureSettings_returnsValueThatWasSet() {
        mTextView = new TextView(mActivity);
        mTextView.setFontFeatureSettings(""\""smcp\"" on"");
        assertEquals(""getFontFeatureSettings should return the value that was set"",
                ""\""smcp\"" on"", mTextView.getFontFeatureSettings());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetOffsetForPositionSingleLineLtr"	"CtsWidgetTestCases"	"1: ui"	"public void testGetOffsetForPositionSingleLineLtr() throws Throwable {
        // asserts getOffsetPosition returns correct values for a single line LTR text
        final String text = ""aaaaa"";

        mActivityRule.runOnUiThread(() -> {
            mTextView = new TextView(mActivity);
            mTextView.setText(text);
            mTextView.setTextSize(8f);
            mTextView.setSingleLine(true);
        });
        mInstrumentation.waitForIdleSync();

        // add a compound drawable to TextView to make offset calculation more interesting
        final Drawable drawable = TestUtils.getDrawable(mActivity, R.drawable.red);
        drawable.setBounds(0, 0, 10, 10);
        mTextView.setCompoundDrawables(drawable, drawable, drawable, drawable);

        final FrameLayout layout = new FrameLayout(mActivity);
        final ViewGroup.LayoutParams layoutParams = new ViewGroup.LayoutParams(
                ViewGroup.LayoutParams.MATCH_PARENT,
                ViewGroup.LayoutParams.WRAP_CONTENT);
        layout.addView(mTextView, layoutParams);
        layout.setLayoutParams(layoutParams);

        mActivityRule.runOnUiThread(() -> mActivity.setContentView(layout));
        mInstrumentation.waitForIdleSync();

        final float horizontalPosFix = (float) Math.ceil(
                mTextView.getPaint().measureText(""a"") * 2f / 3f);
        final int paddingTop = mTextView.getTotalPaddingTop();
        final int paddingLeft = mTextView.getTotalPaddingLeft();

        final int firstOffset = 0;
        final int lastOffset = text.length() - 1;
        final int midOffset = text.length() / 2;

        // left edge of view
        float x = 0f;
        float y = mTextView.getHeight() / 2f + paddingTop;
        assertEquals(firstOffset, mTextView.getOffsetForPosition(x, y));

        // right edge of text
        x = mTextView.getLayout().getLineWidth(0) + paddingLeft - horizontalPosFix;
        assertEquals(lastOffset, mTextView.getOffsetForPosition(x, y));

        // right edge of view
        x = mTextView.getWidth();
        assertEquals(lastOffset + 1, mTextView.getOffsetForPosition(x, y));

        // left edge of view - out of bounds
        x = -1f;
        assertEquals(firstOffset, mTextView.getOffsetForPosition(x, y));

        // horizontal center of text
        x = mTextView.getLayout().getLineWidth(0) / 2f + paddingLeft - horizontalPosFix;
        assertEquals(midOffset, mTextView.getOffsetForPosition(x, y));
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetOffsetForPositionMultiLineLtr"	"CtsWidgetTestCases"	"1: ui"	"public void testGetOffsetForPositionMultiLineLtr() throws Throwable {
        final String line = ""aaa\n"";
        final String threeLines = line + line + line;
        mActivityRule.runOnUiThread(() -> {
            mTextView = new TextView(mActivity);
            mTextView.setText(threeLines);
            mTextView.setTextSize(8f);
            mTextView.setLines(2);
        });
        mInstrumentation.waitForIdleSync();

        // add a compound drawable to TextView to make offset calculation more interesting
        final Drawable drawable = TestUtils.getDrawable(mActivity, R.drawable.red);
        drawable.setBounds(0, 0, 10, 10);
        mTextView.setCompoundDrawables(drawable, drawable, drawable, drawable);

        final FrameLayout layout = new FrameLayout(mActivity);
        final ViewGroup.LayoutParams layoutParams = new ViewGroup.LayoutParams(
                ViewGroup.LayoutParams.MATCH_PARENT,
                ViewGroup.LayoutParams.WRAP_CONTENT);
        layout.addView(mTextView, layoutParams);
        layout.setLayoutParams(layoutParams);

        mActivityRule.runOnUiThread(() -> mActivity.setContentView(layout));
        mInstrumentation.waitForIdleSync();

        final Rect lineBounds = new Rect();
        mTextView.getLayout().getLineBounds(0, lineBounds);

        final float horizontalPosFix = (float) Math.ceil(
                mTextView.getPaint().measureText(""a"") * 2f / 3f);
        final int paddingTop = mTextView.getTotalPaddingTop();
        final int paddingLeft = mTextView.getTotalPaddingLeft();

        // left edge of view at first line
        float x = 0f;
        float y = lineBounds.height() / 2f + paddingTop;
        assertEquals(0, mTextView.getOffsetForPosition(x, y));

        // right edge of view at first line
        x = mTextView.getWidth() - 1f;
        assertEquals(line.length() - 1, mTextView.getOffsetForPosition(x, y));

        // update lineBounds to be the second line
        mTextView.getLayout().getLineBounds(1, lineBounds);
        y = lineBounds.top + lineBounds.height() / 2f + paddingTop;

        // left edge of view at second line
        x = 0f;
        assertEquals(line.length(), mTextView.getOffsetForPosition(x, y));

        // right edge of text at second line
        x = mTextView.getLayout().getLineWidth(1) + paddingLeft - horizontalPosFix;
        assertEquals(line.length() + line.length() - 1, mTextView.getOffsetForPosition(x, y));

        // right edge of view at second line
        x = mTextView.getWidth() - 1f;
        assertEquals(line.length() + line.length() - 1, mTextView.getOffsetForPosition(x, y));

        // horizontal center of text at second line
        x = mTextView.getLayout().getLineWidth(1) / 2f + paddingLeft - horizontalPosFix;
        // second line mid offset should not include next line, therefore subtract one
        assertEquals(line.length() + (line.length() - 1) / 2, mTextView.getOffsetForPosition(x, y));
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetOffsetForPositionMultiLineRtl"	"CtsWidgetTestCases"	"1: ui"	"public void testGetOffsetForPositionMultiLineRtl() throws Throwable {
        final String line = ""\u0635\u0635\u0635\n"";
        final String threeLines = line + line + line;
        mActivityRule.runOnUiThread(() -> {
            mTextView = new TextView(mActivity);
            mTextView.setText(threeLines);
            mTextView.setTextSize(8f);
            mTextView.setLines(2);
        });
        mInstrumentation.waitForIdleSync();

        // add a compound drawable to TextView to make offset calculation more interesting
        final Drawable drawable = TestUtils.getDrawable(mActivity, R.drawable.red);
        drawable.setBounds(0, 0, 10, 10);
        mTextView.setCompoundDrawables(drawable, drawable, drawable, drawable);

        final FrameLayout layout = new FrameLayout(mActivity);
        final LayoutParams layoutParams = new LayoutParams(
                LayoutParams.MATCH_PARENT,
                LayoutParams.WRAP_CONTENT);
        layout.addView(mTextView, layoutParams);
        layout.setLayoutParams(layoutParams);

        mActivityRule.runOnUiThread(() -> mActivity.setContentView(layout));
        mInstrumentation.waitForIdleSync();

        final Rect lineBounds = new Rect();
        mTextView.getLayout().getLineBounds(0, lineBounds);

        final float horizontalPosFix = (float) Math.ceil(
                mTextView.getPaint().measureText(""\u0635"") * 2f / 3f);
        final int paddingTop = mTextView.getTotalPaddingTop();
        final int paddingRight = mTextView.getTotalPaddingRight();

        // right edge of view at first line
        float x = mTextView.getWidth() - 1f;
        float y = lineBounds.height() / 2f + paddingTop;
        assertEquals(0, mTextView.getOffsetForPosition(x, y));

        // left edge of view at first line
        x = 0f;
        assertEquals(line.length() - 1, mTextView.getOffsetForPosition(x, y));

        // update lineBounds to be the second line
        mTextView.getLayout().getLineBounds(1, lineBounds);
        y = lineBounds.top + lineBounds.height() / 2f + paddingTop;

        // right edge of view at second line
        x = mTextView.getWidth() - 1f;
        assertEquals(line.length(), mTextView.getOffsetForPosition(x, y));

        // left edge of view at second line
        x = 0f;
        assertEquals(line.length() + line.length() - 1, mTextView.getOffsetForPosition(x, y));

        // left edge of text at second line
        x = mTextView.getWidth() - (mTextView.getLayout().getLineWidth(1) + paddingRight
                - horizontalPosFix);
        assertEquals(line.length() + line.length() - 1, mTextView.getOffsetForPosition(x, y));

        // horizontal center of text at second line
        x = mTextView.getWidth() - (mTextView.getLayout().getLineWidth(1) / 2f + paddingRight
                - horizontalPosFix);
        // second line mid offset should not include next line, therefore subtract one
        assertEquals(line.length() + (line.length() - 1) / 2, mTextView.getOffsetForPosition(x, y));
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testIsTextSelectable_returnsFalseByDefault"	"CtsWidgetTestCases"	"1: ui"	"public void testIsTextSelectable_returnsFalseByDefault() {
        final TextView textView = new TextView(mActivity);
        textView.setText(""any text"");
        assertFalse(textView.isTextSelectable());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testIsTextSelectable_returnsTrueIfSetTextIsSelectableCalledWithTrue"	"CtsWidgetTestCases"	"1: ui"	"public void testIsTextSelectable_returnsTrueIfSetTextIsSelectableCalledWithTrue() {
        final TextView textView = new TextView(mActivity);
        textView.setText(""any text"");
        textView.setTextIsSelectable(true);
        assertTrue(textView.isTextSelectable());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAccessTransformationMethod"	"CtsWidgetTestCases"	"1: ui"	"public void testAccessTransformationMethod() throws Throwable {
        // check the password attribute in xml
        mTextView = findTextView(R.id.textview_password);
        assertNotNull(mTextView);
        assertSame(PasswordTransformationMethod.getInstance(),
                mTextView.getTransformationMethod());

        // check the singleLine attribute in xml
        mTextView = findTextView(R.id.textview_singleLine);
        assertNotNull(mTextView);
        assertSame(SingleLineTransformationMethod.getInstance(),
                mTextView.getTransformationMethod());

        final QwertyKeyListener qwertyKeyListener = QwertyKeyListener.getInstance(false,
                Capitalize.NONE);
        final TransformationMethod method = PasswordTransformationMethod.getInstance();
        // change transformation method by function
        mActivityRule.runOnUiThread(() -> {
            mTextView.setKeyListener(qwertyKeyListener);
            mTextView.setTransformationMethod(method);
            mTransformedText = method.getTransformation(mTextView.getText(), mTextView);

            mTextView.requestFocus();
        });
        mInstrumentation.waitForIdleSync();
        assertSame(PasswordTransformationMethod.getInstance(),
                mTextView.getTransformationMethod());

        CtsKeyEventUtil.sendKeys(mInstrumentation, mTextView, ""H E 2*L O"");
        mActivityRule.runOnUiThread(() -> mTextView.append("" ""));
        mInstrumentation.waitForIdleSync();

        // It will get transformed after a while
        // We're waiting for transformation to ""******""
        PollingCheck.waitFor(TIMEOUT, () -> mTransformedText.toString()
                .equals(""\u2022\u2022\u2022\u2022\u2022\u2022""));

        // set null
        mActivityRule.runOnUiThread(() -> mTextView.setTransformationMethod(null));
        mInstrumentation.waitForIdleSync();
        assertNull(mTextView.getTransformationMethod());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testCursorDrawable_isNotNullByDefault"	"CtsWidgetTestCases"	"1: ui"	"public void testCursorDrawable_isNotNullByDefault() {
        assertNotNull(new TextView(mActivity).getTextCursorDrawable());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testCursorDrawable_canBeSet_toDrawable"	"CtsWidgetTestCases"	"1: ui"	"public void testCursorDrawable_canBeSet_toDrawable() {
        mTextView = new TextView(mActivity);
        final Drawable cursor = TestUtils.getDrawable(mActivity, R.drawable.blue);
        mTextView.setTextCursorDrawable(cursor);
        assertSame(cursor, mTextView.getTextCursorDrawable());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testCursorDrawable_canBeSet_toDrawableResource"	"CtsWidgetTestCases"	"1: ui"	"public void testCursorDrawable_canBeSet_toDrawableResource() {
        mTextView = new TextView(mActivity);
        mTextView.setTextCursorDrawable(R.drawable.start);
        WidgetTestUtils.assertEquals(TestUtils.getBitmap(mActivity, R.drawable.start),
                ((BitmapDrawable) mTextView.getTextCursorDrawable()).getBitmap());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testCursorDrawable_canBeSetToNull"	"CtsWidgetTestCases"	"1: ui"	"public void testCursorDrawable_canBeSetToNull() {
        new TextView(mActivity).setTextCursorDrawable(null);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testCursorDrawable_canBeSetToZeroResId"	"CtsWidgetTestCases"	"1: ui"	"public void testCursorDrawable_canBeSetToZeroResId() {
        new TextView(mActivity).setTextCursorDrawable(0);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testHandleDrawables_areNotNullByDefault"	"CtsWidgetTestCases"	"1: ui"	"public void testHandleDrawables_areNotNullByDefault() {
        mTextView = new TextView(mActivity);
        assertNotNull(mTextView.getTextSelectHandle());
        assertNotNull(mTextView.getTextSelectHandleLeft());
        assertNotNull(mTextView.getTextSelectHandleRight());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testHandleDrawables_canBeSet_toDrawables"	"CtsWidgetTestCases"	"1: ui"	"public void testHandleDrawables_canBeSet_toDrawables() {
        mTextView = new TextView(mActivity);

        final Drawable blue = TestUtils.getDrawable(mActivity, R.drawable.blue);
        final Drawable yellow = TestUtils.getDrawable(mActivity, R.drawable.yellow);
        final Drawable red = TestUtils.getDrawable(mActivity, R.drawable.red);

        mTextView.setTextSelectHandle(blue);
        mTextView.setTextSelectHandleLeft(yellow);
        mTextView.setTextSelectHandleRight(red);

        assertSame(blue, mTextView.getTextSelectHandle());
        assertSame(yellow, mTextView.getTextSelectHandleLeft());
        assertSame(red, mTextView.getTextSelectHandleRight());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testHandleDrawables_canBeSet_toDrawableResources"	"CtsWidgetTestCases"	"1: ui"	"public void testHandleDrawables_canBeSet_toDrawableResources() {
        mTextView = new TextView(mActivity);

        mTextView.setTextSelectHandle(R.drawable.start);
        mTextView.setTextSelectHandleLeft(R.drawable.pass);
        mTextView.setTextSelectHandleRight(R.drawable.failed);

        WidgetTestUtils.assertEquals(TestUtils.getBitmap(mActivity, R.drawable.start),
                ((BitmapDrawable) mTextView.getTextSelectHandle()).getBitmap());
        WidgetTestUtils.assertEquals(TestUtils.getBitmap(mActivity, R.drawable.pass),
                ((BitmapDrawable) mTextView.getTextSelectHandleLeft()).getBitmap());
        WidgetTestUtils.assertEquals(TestUtils.getBitmap(mActivity, R.drawable.failed),
                ((BitmapDrawable) mTextView.getTextSelectHandleRight()).getBitmap());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSelectHandleDrawable_cannotBeSetToNull"	"CtsWidgetTestCases"	"1: ui"	"(expected = NullPointerException.class)
    public void testSelectHandleDrawable_cannotBeSetToNull() {
        new TextView(mActivity).setTextSelectHandle(null);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSelectHandleDrawable_cannotBeSetToZeroResId"	"CtsWidgetTestCases"	"1: ui"	"(expected = IllegalArgumentException.class)
    public void testSelectHandleDrawable_cannotBeSetToZeroResId() {
        new TextView(mActivity).setTextSelectHandle(0);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSelectHandleDrawableLeft_cannotBeSetToNull"	"CtsWidgetTestCases"	"1: ui"	"(expected = NullPointerException.class)
    public void testSelectHandleDrawableLeft_cannotBeSetToNull() {
        new TextView(mActivity).setTextSelectHandleLeft(null);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSelectHandleDrawableLeft_cannotBeSetToZeroResId"	"CtsWidgetTestCases"	"1: ui"	"(expected = IllegalArgumentException.class)
    public void testSelectHandleDrawableLeft_cannotBeSetToZeroResId() {
        new TextView(mActivity).setTextSelectHandleLeft(0);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSelectHandleDrawableRight_cannotBeSetToNull"	"CtsWidgetTestCases"	"1: ui"	"(expected = NullPointerException.class)
    public void testSelectHandleDrawableRight_cannotBeSetToNull() {
        new TextView(mActivity).setTextSelectHandleRight(null);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testHandleDrawable_canBeSet_whenInsertionHandleIsShown"	"CtsWidgetTestCases"	"1: ui"	"public void testHandleDrawable_canBeSet_whenInsertionHandleIsShown() throws Throwable {
        if (isWatch()) {
            return; // watch does not support overlay keyboard.
        }
        initTextViewForTypingOnUiThread();
        mActivityRule.runOnUiThread(() -> {
            mTextView.setTextIsSelectable(true);
            mTextView.setText(""abcd"", BufferType.EDITABLE);
        });
        mInstrumentation.waitForIdleSync();

        // Trigger insertion.
        CtsTouchUtils.emulateTapOnViewCenter(mInstrumentation, mActivityRule, mTextView);

        final boolean[] mDrawn = new boolean[3];
        mActivityRule.runOnUiThread(() -> {
            mTextView.setTextSelectHandle(new TestHandleDrawable(mDrawn, 0));
            mTextView.setTextSelectHandleLeft(new TestHandleDrawable(mDrawn, 1));
            mTextView.setTextSelectHandleRight(new TestHandleDrawable(mDrawn, 2));
        });
        mInstrumentation.waitForIdleSync();

        assertTrue(mDrawn[0]);
        assertFalse(mDrawn[1]);
        assertFalse(mDrawn[2]);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testHandleDrawables_canBeSet_whenSelectionHandlesAreShown"	"CtsWidgetTestCases"	"1: ui"	"public void testHandleDrawables_canBeSet_whenSelectionHandlesAreShown()
            throws Throwable {
        initTextViewForTypingOnUiThread();
        mActivityRule.runOnUiThread(() -> {
            mTextView.setTextIsSelectable(true);
            mTextView.setText(""abcd"", BufferType.EDITABLE);
        });
        mInstrumentation.waitForIdleSync();

        // Trigger selection.
        CtsTouchUtils.emulateLongPressOnViewCenter(mInstrumentation, mActivityRule, mTextView);

        final boolean[] mDrawn = new boolean[3];
        mActivityRule.runOnUiThread(() -> {
            mTextView.setTextSelectHandle(new TestHandleDrawable(mDrawn, 0));
            mTextView.setTextSelectHandleLeft(new TestHandleDrawable(mDrawn, 1));
            mTextView.setTextSelectHandleRight(new TestHandleDrawable(mDrawn, 2));
        });
        mInstrumentation.waitForIdleSync();

        assertFalse(mDrawn[0]);
        assertTrue(mDrawn[1]);
        assertTrue(mDrawn[2]);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testTextActionModeCallback_loadsHandleDrawables"	"CtsWidgetTestCases"	"1: ui"	"public void testTextActionModeCallback_loadsHandleDrawables() throws Throwable {
        final String text = ""abcde"";
        mActivityRule.runOnUiThread(() -> {
            mTextView = new EditText(mActivity);
            mActivity.setContentView(mTextView);
            mTextView.setText(text, BufferType.SPANNABLE);
            mTextView.setTextIsSelectable(true);
            mTextView.requestFocus();
            mTextView.setSelected(true);
            mTextView.setTextClassifier(TextClassifier.NO_OP);
        });
        mInstrumentation.waitForIdleSync();

        mActivityRule.runOnUiThread(() -> {
            // Set selection and try to start action mode.
            final Bundle args = new Bundle();
            args.putInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_START_INT, 0);
            args.putInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_END_INT, text.length());
            mTextView.performAccessibilityAction(
                    AccessibilityNodeInfo.ACTION_SET_SELECTION, args);
        });
        mInstrumentation.waitForIdleSync();

        // There should be no null pointer exception caused by handle drawables not being loaded.
    }

    private class TestHandleDrawable extends ColorDrawable {
        private final boolean[] mArray;
        private final int mIndex;

        TestHandleDrawable(final boolean[] array, final int index) {
            mArray = array;
            mIndex = index;
        }

        @Override
        public void draw(Canvas canvas) {
            super.draw(canvas);
            mArray[mIndex] = true;
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSingleLine"	"CtsWidgetTestCases"	"1: ui"	"public void testSingleLine() throws Throwable {
        mActivityRule.runOnUiThread(() -> mTextView = new TextView(mActivity));
        mInstrumentation.waitForIdleSync();

        setSpannableText(mTextView, ""This is a really long sentence""
                + "" which can not be placed in one line on the screen."");

        // Narrow layout assures that the text will get wrapped.
        final FrameLayout innerLayout = new FrameLayout(mActivity);
        innerLayout.setLayoutParams(new ViewGroup.LayoutParams(100, 100));
        innerLayout.addView(mTextView);

        final FrameLayout layout = new FrameLayout(mActivity);
        layout.addView(innerLayout);

        mActivityRule.runOnUiThread(() -> {
            mActivity.setContentView(layout);
            mTextView.setSingleLine(true);
        });
        mInstrumentation.waitForIdleSync();

        assertEquals(SingleLineTransformationMethod.getInstance(),
                mTextView.getTransformationMethod());

        int singleLineWidth = 0;
        int singleLineHeight = 0;

        if (mTextView.getLayout() != null) {
            singleLineWidth = mTextView.getLayout().getWidth();
            singleLineHeight = mTextView.getLayout().getHeight();
        }

        mActivityRule.runOnUiThread(() -> mTextView.setSingleLine(false));
        mInstrumentation.waitForIdleSync();
        assertEquals(null, mTextView.getTransformationMethod());

        if (mTextView.getLayout() != null) {
            assertTrue(mTextView.getLayout().getHeight() > singleLineHeight);
            assertTrue(mTextView.getLayout().getWidth() < singleLineWidth);
        }

        // same behaviours as setSingLine(true)
        mActivityRule.runOnUiThread(mTextView::setSingleLine);
        mInstrumentation.waitForIdleSync();
        assertEquals(SingleLineTransformationMethod.getInstance(),
                mTextView.getTransformationMethod());

        if (mTextView.getLayout() != null) {
            assertEquals(singleLineHeight, mTextView.getLayout().getHeight());
            assertEquals(singleLineWidth, mTextView.getLayout().getWidth());
        }
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testIsSingleLineTrue"	"CtsWidgetTestCases"	"1: ui"	"public void testIsSingleLineTrue() {
        mTextView = new TextView(mActivity);

        mTextView.setSingleLine(true);

        assertTrue(mTextView.isSingleLine());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testXmlIsSingleLineFalse"	"CtsWidgetTestCases"	"1: ui"	"public void testXmlIsSingleLineFalse() {
        final Context context = InstrumentationRegistry.getTargetContext();
        final LayoutInflater layoutInflater = LayoutInflater.from(context);
        final View root = layoutInflater.inflate(R.layout.textview_singleline, null);

        mTextView = root.findViewById(R.id.textview_singleline_false);

        assertFalse(mTextView.isSingleLine());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAccessMaxLines"	"CtsWidgetTestCases"	"1: ui"	"public void testAccessMaxLines() {
        mTextView = findTextView(R.id.textview_text);
        mTextView.setWidth((int) (mTextView.getPaint().measureText(LONG_TEXT) / 4));
        mTextView.setText(LONG_TEXT);

        final int maxLines = 2;
        assertTrue(mTextView.getLineCount() > maxLines);

        mTextView.setMaxLines(maxLines);
        mTextView.requestLayout();

        assertEquals(2, mTextView.getMaxLines());
        assertEquals(-1, mTextView.getMaxHeight());
        assertTrue(mTextView.getHeight() <= maxLines * mTextView.getLineHeight());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testHyphenationNotHappen_frequencyNone"	"CtsWidgetTestCases"	"1: ui"	"public void testHyphenationNotHappen_frequencyNone() {
        final int[] BREAK_STRATEGIES = {
            Layout.BREAK_STRATEGY_SIMPLE, Layout.BREAK_STRATEGY_HIGH_QUALITY,
            Layout.BREAK_STRATEGY_BALANCED };

        mTextView = findTextView(R.id.textview_text);

        for (int breakStrategy : BREAK_STRATEGIES) {
            for (int charWidth = 10; charWidth < 120; charWidth += 5) {
                // Change the text view's width to charWidth width.
                final String substring = LONG_TEXT.substring(0, charWidth);
                mTextView.setWidth((int) Math.ceil(mTextView.getPaint().measureText(substring)));

                mTextView.setText(LONG_TEXT);
                mTextView.setBreakStrategy(breakStrategy);

                mTextView.setHyphenationFrequency(Layout.HYPHENATION_FREQUENCY_NONE);

                mTextView.requestLayout();
                mTextView.onPreDraw();  // For freezing the layout.
                Layout layout = mTextView.getLayout();

                final int lineCount = layout.getLineCount();
                for (int line = 0; line < lineCount; ++line) {
                    final int lineEnd = layout.getLineEnd(line);
                    // In any width, any break strategy, hyphenation should not happen if
                    // HYPHENATION_FREQUENCY_NONE is specified.
                    assertTrue(lineEnd == LONG_TEXT.length() ||
                            Character.isWhitespace(LONG_TEXT.charAt(lineEnd - 1)));
                }
            }
        }
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testHyphenationNotHappen_breakStrategySimple"	"CtsWidgetTestCases"	"1: ui"	"public void testHyphenationNotHappen_breakStrategySimple() {
        final int[] HYPHENATION_FREQUENCIES = {
            Layout.HYPHENATION_FREQUENCY_NORMAL, Layout.HYPHENATION_FREQUENCY_FULL,
            Layout.HYPHENATION_FREQUENCY_NONE };

        mTextView = findTextView(R.id.textview_text);

        for (int hyphenationFrequency: HYPHENATION_FREQUENCIES) {
            for (int charWidth = 10; charWidth < 120; charWidth += 5) {
                // Change the text view's width to charWidth width.
                final String substring = LONG_TEXT.substring(0, charWidth);
                mTextView.setWidth((int) Math.ceil(mTextView.getPaint().measureText(substring)));

                mTextView.setText(LONG_TEXT);
                mTextView.setBreakStrategy(Layout.BREAK_STRATEGY_SIMPLE);

                mTextView.setHyphenationFrequency(hyphenationFrequency);

                mTextView.requestLayout();
                mTextView.onPreDraw();  // For freezing the layout.
                Layout layout = mTextView.getLayout();

                final int lineCount = layout.getLineCount();
                for (int line = 0; line < lineCount; ++line) {
                    final int lineEnd = layout.getLineEnd(line);
                    // In any width, any hyphenation frequency, hyphenation should not happen if
                    // BREAK_STRATEGY_SIMPLE is specified.
                    assertTrue(lineEnd == LONG_TEXT.length() ||
                            Character.isWhitespace(LONG_TEXT.charAt(lineEnd - 1)));
                }
            }
        }
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetLines"	"CtsWidgetTestCases"	"1: ui"	"public void testSetLines() throws Throwable {
        mTextView = findTextView(R.id.textview_text);
        // make it multiple lines
        setWidth(mTextView.getWidth() >> 3);
        int originalLines = mTextView.getLineCount();

        setLines(originalLines - 1);
        assertTrue((originalLines - 1) * mTextView.getLineHeight() <= mTextView.getHeight());

        setLines(originalLines + 1);
        assertTrue((originalLines + 1) * mTextView.getLineHeight() <= mTextView.getHeight());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetLinesException"	"CtsWidgetTestCases"	"1: ui"	"public void testSetLinesException() {
        mTextView = new TextView(mActivity);
        mActivity.setContentView(mTextView);
        mTextView.setWidth(mTextView.getWidth() >> 3);
        mTextView.setLines(-1);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetExtendedPaddingTop"	"CtsWidgetTestCases"	"1: ui"	"public void testGetExtendedPaddingTop() {
        mTextView = findTextView(R.id.textview_text);
        // Initialized value
        assertEquals(0, mTextView.getExtendedPaddingTop());

        // After Set a Drawable
        final Drawable top = TestUtils.getDrawable(mActivity, R.drawable.red);
        top.setBounds(0, 0, 100, 10);
        mTextView.setCompoundDrawables(null, top, null, null);
        assertEquals(mTextView.getCompoundPaddingTop(), mTextView.getExtendedPaddingTop());

        // Change line count
        mTextView.setLines(mTextView.getLineCount() - 1);
        mTextView.setGravity(Gravity.BOTTOM);

        assertTrue(mTextView.getExtendedPaddingTop() > 0);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetTotalPaddingTop"	"CtsWidgetTestCases"	"1: ui"	"public void testGetTotalPaddingTop() throws Throwable {
        mTextView = findTextView(R.id.textview_text);
        // Initialized value
        assertEquals(0, mTextView.getTotalPaddingTop());

        // After Set a Drawable
        final Drawable top = TestUtils.getDrawable(mActivity, R.drawable.red);
        top.setBounds(0, 0, 100, 10);
        mActivityRule.runOnUiThread(() -> {
            mTextView.setCompoundDrawables(null, top, null, null);
            mTextView.setLines(mTextView.getLineCount() - 1);
            mTextView.setGravity(Gravity.BOTTOM);
        });
        mInstrumentation.waitForIdleSync();
        assertEquals(mTextView.getExtendedPaddingTop(), mTextView.getTotalPaddingTop());

        // Change line count
        setLines(mTextView.getLineCount() + 1);
        int expected = mTextView.getHeight()
                - mTextView.getExtendedPaddingBottom()
                - mTextView.getLayout().getLineTop(mTextView.getLineCount());
        assertEquals(expected, mTextView.getTotalPaddingTop());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetTotalPaddingBottom"	"CtsWidgetTestCases"	"1: ui"	"public void testGetTotalPaddingBottom() throws Throwable {
        mTextView = findTextView(R.id.textview_text);
        // Initialized value
        assertEquals(0, mTextView.getTotalPaddingBottom());

        // After Set a Drawable
        final Drawable bottom = TestUtils.getDrawable(mActivity, R.drawable.red);
        bottom.setBounds(0, 0, 100, 10);
        mActivityRule.runOnUiThread(() -> {
            mTextView.setCompoundDrawables(null, null, null, bottom);
            mTextView.setLines(mTextView.getLineCount() - 1);
            mTextView.setGravity(Gravity.CENTER_VERTICAL);
        });
        mInstrumentation.waitForIdleSync();
        assertEquals(mTextView.getExtendedPaddingBottom(), mTextView.getTotalPaddingBottom());

        // Change line count
        setLines(mTextView.getLineCount() + 1);
        int expected = ((mTextView.getHeight()
                - mTextView.getExtendedPaddingBottom()
                - mTextView.getExtendedPaddingTop()
                - mTextView.getLayout().getLineBottom(mTextView.getLineCount())) >> 1)
                + mTextView.getExtendedPaddingBottom();
        assertEquals(expected, mTextView.getTotalPaddingBottom());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetTotalPaddingLeft"	"CtsWidgetTestCases"	"1: ui"	"public void testGetTotalPaddingLeft() {
        mTextView = findTextView(R.id.textview_text);
        // Initialized value
        assertEquals(0, mTextView.getTotalPaddingLeft());

        // After Set a Drawable
        Drawable left = TestUtils.getDrawable(mActivity, R.drawable.red);
        left.setBounds(0, 0, 10, 100);
        mTextView.setCompoundDrawables(left, null, null, null);
        mTextView.setGravity(Gravity.RIGHT);
        assertEquals(mTextView.getCompoundPaddingLeft(), mTextView.getTotalPaddingLeft());

        // Change width
        mTextView.setWidth(Integer.MAX_VALUE);
        assertEquals(mTextView.getCompoundPaddingLeft(), mTextView.getTotalPaddingLeft());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetTotalPaddingRight"	"CtsWidgetTestCases"	"1: ui"	"public void testGetTotalPaddingRight() {
        mTextView = findTextView(R.id.textview_text);
        // Initialized value
        assertEquals(0, mTextView.getTotalPaddingRight());

        // After Set a Drawable
        Drawable right = TestUtils.getDrawable(mActivity, R.drawable.red);
        right.setBounds(0, 0, 10, 100);
        mTextView.setCompoundDrawables(null, null, right, null);
        mTextView.setGravity(Gravity.CENTER_HORIZONTAL);
        assertEquals(mTextView.getCompoundPaddingRight(), mTextView.getTotalPaddingRight());

        // Change width
        mTextView.setWidth(Integer.MAX_VALUE);
        assertEquals(mTextView.getCompoundPaddingRight(), mTextView.getTotalPaddingRight());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetUrls"	"CtsWidgetTestCases"	"1: ui"	"public void testGetUrls() {
        mTextView = new TextView(mActivity);

        URLSpan[] spans = mTextView.getUrls();
        assertEquals(0, spans.length);

        String url = ""http://www.google.com"";
        String email = ""name@gmail.com"";
        String string = url + "" mailto:"" + email;
        SpannableString spannable = new SpannableString(string);
        spannable.setSpan(new URLSpan(url), 0, url.length(), 0);
        mTextView.setText(spannable, BufferType.SPANNABLE);
        spans = mTextView.getUrls();
        assertEquals(1, spans.length);
        assertEquals(url, spans[0].getURL());

        spannable.setSpan(new URLSpan(email), 0, email.length(), 0);
        mTextView.setText(spannable, BufferType.SPANNABLE);

        spans = mTextView.getUrls();
        assertEquals(2, spans.length);
        assertEquals(url, spans[0].getURL());
        assertEquals(email, spans[1].getURL());

        // test the situation that param what is not a URLSpan
        spannable.setSpan(new Object(), 0, 9, 0);
        mTextView.setText(spannable, BufferType.SPANNABLE);
        spans = mTextView.getUrls();
        assertEquals(2, spans.length);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetPadding"	"CtsWidgetTestCases"	"1: ui"	"public void testSetPadding() {
        mTextView = new TextView(mActivity);

        mTextView.setPadding(0, 1, 2, 4);
        assertEquals(0, mTextView.getPaddingLeft());
        assertEquals(1, mTextView.getPaddingTop());
        assertEquals(2, mTextView.getPaddingRight());
        assertEquals(4, mTextView.getPaddingBottom());

        mTextView.setPadding(10, 20, 30, 40);
        assertEquals(10, mTextView.getPaddingLeft());
        assertEquals(20, mTextView.getPaddingTop());
        assertEquals(30, mTextView.getPaddingRight());
        assertEquals(40, mTextView.getPaddingBottom());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testBaselineAttributes"	"CtsWidgetTestCases"	"1: ui"	"public void testBaselineAttributes() {
        mTextView = findTextView(R.id.textview_baseline);

        final int firstBaselineToTopHeight = mTextView.getResources()
                .getDimensionPixelSize(R.dimen.textview_firstBaselineToTopHeight);
        final int lastBaselineToBottomHeight = mTextView.getResources()
                .getDimensionPixelSize(R.dimen.textview_lastBaselineToBottomHeight);
        final int lineHeight = mTextView.getResources()
                .getDimensionPixelSize(R.dimen.textview_lineHeight);

        assertEquals(firstBaselineToTopHeight, mTextView.getFirstBaselineToTopHeight());
        assertEquals(lastBaselineToBottomHeight, mTextView.getLastBaselineToBottomHeight());
        assertEquals(lineHeight, mTextView.getLineHeight());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetFirstBaselineToTopHeight"	"CtsWidgetTestCases"	"1: ui"	"public void testSetFirstBaselineToTopHeight() {
        mTextView = new TextView(mActivity);
        mTextView.setText(""This is some random text"");
        final int padding = 100;
        mTextView.setPadding(padding, padding, padding, padding);

        final FontMetricsInt fontMetrics = mTextView.getPaint().getFontMetricsInt();
        final int fontMetricsTop = Math.max(
                Math.abs(fontMetrics.top), Math.abs(fontMetrics.ascent));

        int firstBaselineToTopHeight = fontMetricsTop + 10;
        mTextView.setFirstBaselineToTopHeight(firstBaselineToTopHeight);
        assertEquals(firstBaselineToTopHeight, mTextView.getFirstBaselineToTopHeight());
        assertNotEquals(padding, mTextView.getPaddingTop());

        firstBaselineToTopHeight = fontMetricsTop + 40;
        mTextView.setFirstBaselineToTopHeight(firstBaselineToTopHeight);
        assertEquals(firstBaselineToTopHeight, mTextView.getFirstBaselineToTopHeight());

        mTextView.setPadding(padding, padding, padding, padding);
        assertEquals(padding, mTextView.getPaddingTop());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetFirstBaselineToTopHeight_tooSmall"	"CtsWidgetTestCases"	"1: ui"	"public void testSetFirstBaselineToTopHeight_tooSmall() {
        mTextView = new TextView(mActivity);
        mTextView.setText(""This is some random text"");
        final int padding = 100;
        mTextView.setPadding(padding, padding, padding, padding);

        final FontMetricsInt fontMetrics = mTextView.getPaint().getFontMetricsInt();
        final int fontMetricsTop = Math.min(
                Math.abs(fontMetrics.top), Math.abs(fontMetrics.ascent));

        int firstBaselineToTopHeight = fontMetricsTop - 1;
        mTextView.setFirstBaselineToTopHeight(firstBaselineToTopHeight);
        assertNotEquals(firstBaselineToTopHeight, mTextView.getFirstBaselineToTopHeight());
        assertEquals(padding, mTextView.getPaddingTop());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetFirstBaselineToTopHeight_negative"	"CtsWidgetTestCases"	"1: ui"	"(expected = IllegalArgumentException.class)
    public void testSetFirstBaselineToTopHeight_negative() {
        new TextView(mActivity).setFirstBaselineToTopHeight(-1);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetLastBaselineToBottomHeight"	"CtsWidgetTestCases"	"1: ui"	"public void testSetLastBaselineToBottomHeight() {
        mTextView = new TextView(mActivity);
        mTextView.setText(""This is some random text"");
        final int padding = 100;
        mTextView.setPadding(padding, padding, padding, padding);

        final FontMetricsInt fontMetrics = mTextView.getPaint().getFontMetricsInt();
        final int fontMetricsBottom = Math.max(
                Math.abs(fontMetrics.bottom), Math.abs(fontMetrics.descent));

        int lastBaselineToBottomHeight = fontMetricsBottom + 20;
        mTextView.setLastBaselineToBottomHeight(lastBaselineToBottomHeight);
        assertEquals(lastBaselineToBottomHeight, mTextView.getLastBaselineToBottomHeight());
        assertNotEquals(padding, mTextView.getPaddingBottom());

        lastBaselineToBottomHeight = fontMetricsBottom + 30;
        mTextView.setLastBaselineToBottomHeight(lastBaselineToBottomHeight);
        assertEquals(lastBaselineToBottomHeight, mTextView.getLastBaselineToBottomHeight());

        mTextView.setPadding(padding, padding, padding, padding);
        assertEquals(padding, mTextView.getPaddingBottom());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetLastBaselineToBottomHeight_tooSmall"	"CtsWidgetTestCases"	"1: ui"	"public void testSetLastBaselineToBottomHeight_tooSmall() {
        mTextView = new TextView(mActivity);
        mTextView.setText(""This is some random text"");
        final int padding = 100;
        mTextView.setPadding(padding, padding, padding, padding);

        final FontMetricsInt fontMetrics = mTextView.getPaint().getFontMetricsInt();
        final int fontMetricsBottom = Math.min(
                Math.abs(fontMetrics.bottom), Math.abs(fontMetrics.descent));

        int lastBaselineToBottomHeight = fontMetricsBottom - 1;
        mTextView.setLastBaselineToBottomHeight(lastBaselineToBottomHeight);
        assertNotEquals(lastBaselineToBottomHeight, mTextView.getLastBaselineToBottomHeight());
        assertEquals(padding, mTextView.getPaddingBottom());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetLastBaselineToBottomHeight_negative"	"CtsWidgetTestCases"	"1: ui"	"(expected = IllegalArgumentException.class)
    public void testSetLastBaselineToBottomHeight_negative() {
        new TextView(mActivity).setLastBaselineToBottomHeight(-1);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetLineHeight"	"CtsWidgetTestCases"	"1: ui"	"public void testSetLineHeight() {
        mTextView = new TextView(mActivity);
        mTextView.setText(""This is some random text"");

        // The line height of RobotoFont is (1900 + 500) / 2048 em.
        // Not to accidentally divide the line height into half, use the small text size.
        mTextView.setTextSize(10f);

        final float lineSpacingExtra = 50;
        final float lineSpacingMultiplier = 0.2f;
        mTextView.setLineSpacing(lineSpacingExtra, lineSpacingMultiplier);

        mTextView.setLineHeight(100);
        assertEquals(100, mTextView.getLineHeight());
        assertNotEquals(lineSpacingExtra, mTextView.getLineSpacingExtra(), 0);
        assertNotEquals(lineSpacingMultiplier, mTextView.getLineSpacingMultiplier(), 0);

        mTextView.setLineHeight(200);
        assertEquals(200, mTextView.getLineHeight());

        mTextView.setLineSpacing(lineSpacingExtra, lineSpacingMultiplier);
        assertEquals(lineSpacingExtra, mTextView.getLineSpacingExtra(), 0);
        assertEquals(lineSpacingMultiplier, mTextView.getLineSpacingMultiplier(), 0);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetLineHeight_negative"	"CtsWidgetTestCases"	"1: ui"	"(expected = IllegalArgumentException.class)
    public void testSetLineHeight_negative() {
        new TextView(mActivity).setLineHeight(-1);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testDeprecatedSetTextAppearance"	"CtsWidgetTestCases"	"1: ui"	"public void testDeprecatedSetTextAppearance() {
        mTextView = new TextView(mActivity);

        mTextView.setTextAppearance(mActivity, R.style.TextAppearance_All);
        assertEquals(mActivity.getResources().getColor(R.drawable.black),
                mTextView.getCurrentTextColor());
        assertEquals(20f, mTextView.getTextSize(), 0.01f);
        assertEquals(Typeface.BOLD, mTextView.getTypeface().getStyle());
        assertEquals(mActivity.getResources().getColor(R.drawable.red),
                mTextView.getCurrentHintTextColor());
        assertEquals(mActivity.getResources().getColor(R.drawable.blue),
                mTextView.getLinkTextColors().getDefaultColor());

        mTextView.setTextAppearance(mActivity, R.style.TextAppearance_Colors);
        assertEquals(mActivity.getResources().getColor(R.drawable.black),
                mTextView.getCurrentTextColor());
        assertEquals(mActivity.getResources().getColor(R.drawable.blue),
                mTextView.getCurrentHintTextColor());
        assertEquals(mActivity.getResources().getColor(R.drawable.yellow),
                mTextView.getLinkTextColors().getDefaultColor());

        mTextView.setTextAppearance(mActivity, R.style.TextAppearance_NotColors);
        assertEquals(17f, mTextView.getTextSize(), 0.01f);
        assertEquals(Typeface.NORMAL, mTextView.getTypeface().getStyle());

        mTextView.setTextAppearance(mActivity, R.style.TextAppearance_Style);
        assertEquals(null, mTextView.getTypeface());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAttributeReading_allCapsAndPassword"	"CtsWidgetTestCases"	"1: ui"	"public void testAttributeReading_allCapsAndPassword() {
        // This TextView has all caps & password, therefore all caps should be ignored.
        mTextView = findTextView(R.id.textview_textappearance_attrs_allcaps_password);
        assertFalse(mTextView.isAllCaps());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testComputeHorizontalScrollRange"	"CtsWidgetTestCases"	"1: ui"	"public void testComputeHorizontalScrollRange() throws Throwable {
        mActivityRule.runOnUiThread(() -> mTextView = new MockTextView(mActivity));
        mInstrumentation.waitForIdleSync();
        // test when layout is null
        assertNull(mTextView.getLayout());
        assertEquals(mTextView.getWidth(),
                ((MockTextView) mTextView).computeHorizontalScrollRange());

        mActivityRule.runOnUiThread(() -> ((MockTextView) mTextView).setFrame(0, 0, 40, 50));
        mInstrumentation.waitForIdleSync();
        assertEquals(mTextView.getWidth(),
                ((MockTextView) mTextView).computeHorizontalScrollRange());

        // set the layout
        layout(mTextView);
        assertEquals(mTextView.getLayout().getWidth(),
                ((MockTextView) mTextView).computeHorizontalScrollRange());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testComputeVerticalScrollRange"	"CtsWidgetTestCases"	"1: ui"	"public void testComputeVerticalScrollRange() throws Throwable {
        mActivityRule.runOnUiThread(() -> mTextView = new MockTextView(mActivity));
        mInstrumentation.waitForIdleSync();

        // test when layout is null
        assertNull(mTextView.getLayout());
        assertEquals(0, ((MockTextView) mTextView).computeVerticalScrollRange());

        mActivityRule.runOnUiThread(() -> ((MockTextView) mTextView).setFrame(0, 0, 40, 50));
        mInstrumentation.waitForIdleSync();
        assertEquals(mTextView.getHeight(), ((MockTextView) mTextView).computeVerticalScrollRange());

        //set the layout
        layout(mTextView);
        assertEquals(mTextView.getLayout().getHeight(),
                ((MockTextView) mTextView).computeVerticalScrollRange());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testDrawableStateChanged"	"CtsWidgetTestCases"	"1: ui"	"public void testDrawableStateChanged() throws Throwable {
        mActivityRule.runOnUiThread(() -> mTextView = spy(new MockTextView(mActivity)));
        mInstrumentation.waitForIdleSync();
        reset(mTextView);
        mTextView.refreshDrawableState();
        ((MockTextView) verify(mTextView, times(1))).drawableStateChanged();
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetDefaultEditable"	"CtsWidgetTestCases"	"1: ui"	"public void testGetDefaultEditable() {
        mTextView = new MockTextView(mActivity);

        //the TextView#getDefaultEditable() does nothing, and always return false.
        assertFalse(((MockTextView) mTextView).getDefaultEditable());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetDefaultMovementMethod"	"CtsWidgetTestCases"	"1: ui"	"public void testGetDefaultMovementMethod() {
        MockTextView textView = new MockTextView(mActivity);

        //the TextView#getDefaultMovementMethod() does nothing, and always return null.
        assertNull(textView.getDefaultMovementMethod());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testMarquee"	"CtsWidgetTestCases"	"1: ui"	"public void testMarquee() throws Throwable {
        // Both are pointing to the same object. This works around current limitation in CTS
        // coverage report tool for properly reporting coverage of base class method calls.
        mActivityRule.runOnUiThread(() -> {
            mSecondTextView = new MockTextView(mActivity);

            mTextView = mSecondTextView;
            mTextView.setText(LONG_TEXT);
            mTextView.setSingleLine();
            mTextView.setEllipsize(TruncateAt.MARQUEE);
            mTextView.setLayoutParams(new LayoutParams(100, 100));
        });
        mInstrumentation.waitForIdleSync();

        final FrameLayout layout = new FrameLayout(mActivity);
        layout.addView(mTextView);

        // make the fading to be shown
        mTextView.setHorizontalFadingEdgeEnabled(true);

        mActivityRule.runOnUiThread(() -> mActivity.setContentView(layout));
        mInstrumentation.waitForIdleSync();

        TestSelectedRunnable runnable = new TestSelectedRunnable(mTextView) {
            public void run() {
                mTextView.setMarqueeRepeatLimit(-1);
                // force the marquee to start
                saveIsSelected1();
                mTextView.setSelected(true);
                saveIsSelected2();
            }
        };
        mActivityRule.runOnUiThread(runnable);

        // wait for the marquee to run
        // fading is shown on both sides if the marquee runs for a while
        PollingCheck.waitFor(TIMEOUT, () ->
                ((MockTextView) mSecondTextView).getLeftFadingEdgeStrength() > 0.0f
                        && ((MockTextView) mSecondTextView).getRightFadingEdgeStrength() > 0.0f);

        // wait for left marquee to fully apply
        PollingCheck.waitFor(TIMEOUT, () ->
                ((MockTextView) mSecondTextView).getLeftFadingEdgeStrength() > 0.99f);

        assertFalse(runnable.getIsSelected1());
        assertTrue(runnable.getIsSelected2());
        assertEquals(-1, mTextView.getMarqueeRepeatLimit());

        runnable = new TestSelectedRunnable(mTextView) {
            public void run() {
                mTextView.setMarqueeRepeatLimit(0);
                // force the marquee to stop
                saveIsSelected1();
                mTextView.setSelected(false);
                saveIsSelected2();
                mTextView.setGravity(Gravity.LEFT);
            }
        };
        // force the marquee to stop
        mActivityRule.runOnUiThread(runnable);
        mInstrumentation.waitForIdleSync();
        assertTrue(runnable.getIsSelected1());
        assertFalse(runnable.getIsSelected2());
        assertEquals(0.0f, ((MockTextView) mSecondTextView).getLeftFadingEdgeStrength(), 0.01f);
        assertTrue(((MockTextView) mSecondTextView).getRightFadingEdgeStrength() > 0.0f);
        assertEquals(0, mTextView.getMarqueeRepeatLimit());

        mActivityRule.runOnUiThread(() -> mTextView.setGravity(Gravity.RIGHT));
        mInstrumentation.waitForIdleSync();
        assertTrue(((MockTextView) mSecondTextView).getLeftFadingEdgeStrength() > 0.0f);
        assertEquals(0.0f, ((MockTextView) mSecondTextView).getRightFadingEdgeStrength(), 0.01f);

        mActivityRule.runOnUiThread(() -> mTextView.setGravity(Gravity.CENTER_HORIZONTAL));
        mInstrumentation.waitForIdleSync();
        // there is no left fading (Is it correct?)
        assertEquals(0.0f, ((MockTextView) mSecondTextView).getLeftFadingEdgeStrength(), 0.01f);
        assertTrue(((MockTextView) mSecondTextView).getRightFadingEdgeStrength() > 0.0f);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetMarqueeRepeatLimit"	"CtsWidgetTestCases"	"1: ui"	"public void testGetMarqueeRepeatLimit() {
        final TextView textView = new TextView(mActivity);

        textView.setMarqueeRepeatLimit(10);
        assertEquals(10, textView.getMarqueeRepeatLimit());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAccessInputExtras"	"CtsWidgetTestCases"	"1: ui"	"public void testAccessInputExtras() throws XmlPullParserException, IOException {
        mTextView = new TextView(mActivity);
        mTextView.setText(null, BufferType.EDITABLE);
        mTextView.setInputType(InputType.TYPE_CLASS_TEXT);

        // do not create the extras
        assertNull(mTextView.getInputExtras(false));

        // create if it does not exist
        Bundle inputExtras = mTextView.getInputExtras(true);
        assertNotNull(inputExtras);
        assertTrue(inputExtras.isEmpty());

        // it is created already
        assertNotNull(mTextView.getInputExtras(false));

        try {
            mTextView.setInputExtras(R.xml.input_extras);
            fail(""Should throw NullPointerException!"");
        } catch (NullPointerException e) {
        }
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAccessContentType"	"CtsWidgetTestCases"	"1: ui"	"public void testAccessContentType() {
        mTextView = new TextView(mActivity);
        mTextView.setText(null, BufferType.EDITABLE);
        mTextView.setKeyListener(null);
        mTextView.setTransformationMethod(null);

        mTextView.setInputType(InputType.TYPE_CLASS_DATETIME
                | InputType.TYPE_DATETIME_VARIATION_NORMAL);
        assertEquals(InputType.TYPE_CLASS_DATETIME
                | InputType.TYPE_DATETIME_VARIATION_NORMAL, mTextView.getInputType());
        assertTrue(mTextView.getKeyListener() instanceof DateTimeKeyListener);

        mTextView.setInputType(InputType.TYPE_CLASS_DATETIME
                | InputType.TYPE_DATETIME_VARIATION_DATE);
        assertEquals(InputType.TYPE_CLASS_DATETIME
                | InputType.TYPE_DATETIME_VARIATION_DATE, mTextView.getInputType());
        assertTrue(mTextView.getKeyListener() instanceof DateKeyListener);

        mTextView.setInputType(InputType.TYPE_CLASS_DATETIME
                | InputType.TYPE_DATETIME_VARIATION_TIME);
        assertEquals(InputType.TYPE_CLASS_DATETIME
                | InputType.TYPE_DATETIME_VARIATION_TIME, mTextView.getInputType());
        assertTrue(mTextView.getKeyListener() instanceof TimeKeyListener);

        mTextView.setInputType(InputType.TYPE_CLASS_NUMBER
                | InputType.TYPE_NUMBER_FLAG_DECIMAL
                | InputType.TYPE_NUMBER_FLAG_SIGNED);
        assertEquals(InputType.TYPE_CLASS_NUMBER
                | InputType.TYPE_NUMBER_FLAG_DECIMAL
                | InputType.TYPE_NUMBER_FLAG_SIGNED, mTextView.getInputType());
        assertSame(mTextView.getKeyListener(),
                DigitsKeyListener.getInstance(null, true, true));

        mTextView.setInputType(InputType.TYPE_CLASS_PHONE);
        assertEquals(InputType.TYPE_CLASS_PHONE, mTextView.getInputType());
        assertTrue(mTextView.getKeyListener() instanceof DialerKeyListener);

        mTextView.setInputType(InputType.TYPE_CLASS_TEXT
                | InputType.TYPE_TEXT_FLAG_AUTO_CORRECT);
        assertEquals(InputType.TYPE_CLASS_TEXT
                | InputType.TYPE_TEXT_FLAG_AUTO_CORRECT, mTextView.getInputType());
        assertSame(mTextView.getKeyListener(), TextKeyListener.getInstance(true, Capitalize.NONE));

        mTextView.setSingleLine();
        assertTrue(mTextView.getTransformationMethod() instanceof SingleLineTransformationMethod);
        mTextView.setInputType(InputType.TYPE_CLASS_TEXT
                | InputType.TYPE_TEXT_FLAG_MULTI_LINE
                | InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS);
        assertEquals(InputType.TYPE_CLASS_TEXT
                | InputType.TYPE_TEXT_FLAG_MULTI_LINE
                | InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS, mTextView.getInputType());
        assertSame(mTextView.getKeyListener(),
                TextKeyListener.getInstance(false, Capitalize.CHARACTERS));
        assertNull(mTextView.getTransformationMethod());

        mTextView.setInputType(InputType.TYPE_CLASS_TEXT
                | InputType.TYPE_TEXT_FLAG_CAP_WORDS);
        assertEquals(InputType.TYPE_CLASS_TEXT
                | InputType.TYPE_TEXT_FLAG_CAP_WORDS, mTextView.getInputType());
        assertSame(mTextView.getKeyListener(),
                TextKeyListener.getInstance(false, Capitalize.WORDS));
        assertTrue(mTextView.getTransformationMethod() instanceof SingleLineTransformationMethod);

        mTextView.setInputType(InputType.TYPE_CLASS_TEXT
                | InputType.TYPE_TEXT_FLAG_CAP_SENTENCES);
        assertEquals(InputType.TYPE_CLASS_TEXT
                | InputType.TYPE_TEXT_FLAG_CAP_SENTENCES, mTextView.getInputType());
        assertSame(mTextView.getKeyListener(),
                TextKeyListener.getInstance(false, Capitalize.SENTENCES));

        mTextView.setInputType(InputType.TYPE_NULL);
        assertEquals(InputType.TYPE_NULL, mTextView.getInputType());
        assertTrue(mTextView.getKeyListener() instanceof TextKeyListener);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAccessRawContentType"	"CtsWidgetTestCases"	"1: ui"	"public void testAccessRawContentType() {
        mTextView = new TextView(mActivity);
        mTextView.setText(null, BufferType.EDITABLE);
        mTextView.setKeyListener(null);
        mTextView.setTransformationMethod(null);

        mTextView.setRawInputType(InputType.TYPE_CLASS_DATETIME
                | InputType.TYPE_DATETIME_VARIATION_NORMAL);
        assertEquals(InputType.TYPE_CLASS_DATETIME
                | InputType.TYPE_DATETIME_VARIATION_NORMAL, mTextView.getInputType());
        assertNull(mTextView.getTransformationMethod());
        assertNull(mTextView.getKeyListener());

        mTextView.setRawInputType(InputType.TYPE_CLASS_DATETIME
                | InputType.TYPE_DATETIME_VARIATION_DATE);
        assertEquals(InputType.TYPE_CLASS_DATETIME
                | InputType.TYPE_DATETIME_VARIATION_DATE, mTextView.getInputType());
        assertNull(mTextView.getTransformationMethod());
        assertNull(mTextView.getKeyListener());

        mTextView.setRawInputType(InputType.TYPE_CLASS_DATETIME
                | InputType.TYPE_DATETIME_VARIATION_TIME);
        assertEquals(InputType.TYPE_CLASS_DATETIME
                | InputType.TYPE_DATETIME_VARIATION_TIME, mTextView.getInputType());
        assertNull(mTextView.getTransformationMethod());
        assertNull(mTextView.getKeyListener());

        mTextView.setRawInputType(InputType.TYPE_CLASS_NUMBER
                | InputType.TYPE_NUMBER_FLAG_DECIMAL
                | InputType.TYPE_NUMBER_FLAG_SIGNED);
        assertEquals(InputType.TYPE_CLASS_NUMBER
                | InputType.TYPE_NUMBER_FLAG_DECIMAL
                | InputType.TYPE_NUMBER_FLAG_SIGNED, mTextView.getInputType());
        assertNull(mTextView.getTransformationMethod());
        assertNull(mTextView.getKeyListener());

        mTextView.setRawInputType(InputType.TYPE_CLASS_PHONE);
        assertEquals(InputType.TYPE_CLASS_PHONE, mTextView.getInputType());
        assertNull(mTextView.getTransformationMethod());
        assertNull(mTextView.getKeyListener());

        mTextView.setRawInputType(InputType.TYPE_CLASS_TEXT
                | InputType.TYPE_TEXT_FLAG_AUTO_CORRECT);
        assertEquals(InputType.TYPE_CLASS_TEXT
                | InputType.TYPE_TEXT_FLAG_AUTO_CORRECT, mTextView.getInputType());
        assertNull(mTextView.getTransformationMethod());
        assertNull(mTextView.getKeyListener());

        mTextView.setSingleLine();
        assertTrue(mTextView.getTransformationMethod() instanceof SingleLineTransformationMethod);
        mTextView.setRawInputType(InputType.TYPE_CLASS_TEXT
                | InputType.TYPE_TEXT_FLAG_MULTI_LINE
                | InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS);
        assertEquals(InputType.TYPE_CLASS_TEXT
                | InputType.TYPE_TEXT_FLAG_MULTI_LINE
                | InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS, mTextView.getInputType());
        assertTrue(mTextView.getTransformationMethod() instanceof SingleLineTransformationMethod);
        assertNull(mTextView.getKeyListener());

        mTextView.setRawInputType(InputType.TYPE_CLASS_TEXT
                | InputType.TYPE_TEXT_FLAG_CAP_WORDS);
        assertEquals(InputType.TYPE_CLASS_TEXT
                | InputType.TYPE_TEXT_FLAG_CAP_WORDS, mTextView.getInputType());
        assertTrue(mTextView.getTransformationMethod() instanceof SingleLineTransformationMethod);
        assertNull(mTextView.getKeyListener());

        mTextView.setRawInputType(InputType.TYPE_CLASS_TEXT
                | InputType.TYPE_TEXT_FLAG_CAP_SENTENCES);
        assertEquals(InputType.TYPE_CLASS_TEXT
                | InputType.TYPE_TEXT_FLAG_CAP_SENTENCES, mTextView.getInputType());
        assertTrue(mTextView.getTransformationMethod() instanceof SingleLineTransformationMethod);
        assertNull(mTextView.getKeyListener());

        mTextView.setRawInputType(InputType.TYPE_NULL);
        assertTrue(mTextView.getTransformationMethod() instanceof SingleLineTransformationMethod);
        assertNull(mTextView.getKeyListener());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAccessImeActionLabel"	"CtsWidgetTestCases"	"1: ui"	"public void testAccessImeActionLabel() {
        mTextView = findTextView(R.id.textview_text);
        assertNull(mTextView.getImeActionLabel());
        assertEquals(0, mTextView.getImeActionId());

        mTextView.setImeActionLabel(""pinyin"", 1);
        assertEquals(""pinyin"", mTextView.getImeActionLabel().toString());
        assertEquals(1, mTextView.getImeActionId());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAccessImeHintLocales"	"CtsWidgetTestCases"	"1: ui"	"public void testAccessImeHintLocales() {
        final TextView textView = new TextView(mActivity);
        textView.setText("""", BufferType.EDITABLE);
        textView.setKeyListener(null);
        textView.setRawInputType(InputType.TYPE_CLASS_TEXT);
        assertNull(textView.getImeHintLocales());
        {
            final EditorInfo editorInfo = new EditorInfo();
            textView.onCreateInputConnection(editorInfo);
            assertNull(editorInfo.hintLocales);
        }

        final LocaleList localeList = LocaleList.forLanguageTags(""en-PH,en-US"");
        textView.setImeHintLocales(localeList);
        assertEquals(localeList, textView.getImeHintLocales());
        {
            final EditorInfo editorInfo = new EditorInfo();
            textView.onCreateInputConnection(editorInfo);
            assertEquals(localeList, editorInfo.hintLocales);
        }
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetImeHintLocalesChangesInputType"	"CtsWidgetTestCases"	"1: ui"	"public void testSetImeHintLocalesChangesInputType() {
        final TextView textView = new TextView(mActivity);
        textView.setText("""", BufferType.EDITABLE);

        textView.setInputType(InputType.TYPE_CLASS_NUMBER);
        assertEquals(InputType.TYPE_CLASS_NUMBER, textView.getInputType());

        final LocaleList localeList = LocaleList.forLanguageTags(""fa-IR"");
        textView.setImeHintLocales(localeList);
        final int textType = InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_NORMAL;
        // Setting IME hint locales to Persian must change the input type to a full text IME,
        // since the typical number input IME may not have localized digits.
        assertEquals(textType, textView.getInputType());

        // Changing the input type to datetime should keep the full text IME, since the IME hint
        // is still set to Persian, which needs advanced input.
        final int dateType = InputType.TYPE_CLASS_DATETIME | InputType.TYPE_DATETIME_VARIATION_DATE;
        textView.setInputType(dateType);
        assertEquals(textType, textView.getInputType());

        // Changing the input type to number password should keep the full text IME, since the IME
        // hint is still set to Persian, which needs advanced input. But it also needs to set the
        // text password flag.
        final int numberPasswordType = InputType.TYPE_CLASS_NUMBER
                | InputType.TYPE_NUMBER_VARIATION_PASSWORD;
        final int textPasswordType = InputType.TYPE_CLASS_TEXT
                | InputType.TYPE_TEXT_VARIATION_PASSWORD;
        textView.setInputType(numberPasswordType);
        assertEquals(textPasswordType, textView.getInputType());

        // Setting the IME hint locales to null should reset the type to number password, since we
        // no longer need internationalized input.
        textView.setImeHintLocales(null);
        assertEquals(numberPasswordType, textView.getInputType());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetImeHintLocalesDoesntLoseInputType"	"CtsWidgetTestCases"	"1: ui"	"public void testSetImeHintLocalesDoesntLoseInputType() {
        final TextView textView = new TextView(mActivity);
        textView.setText("""", BufferType.EDITABLE);
        final int inputType = InputType.TYPE_CLASS_TEXT
                | InputType.TYPE_TEXT_VARIATION_WEB_EDIT_TEXT
                | InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS
                | InputType.TYPE_TEXT_FLAG_MULTI_LINE
                | InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS;
        textView.setInputType(inputType);
        textView.setImeHintLocales(new LocaleList(Locale.US));
        assertEquals(inputType, textView.getInputType());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testMoveCursorToVisibleOffset"	"CtsWidgetTestCases"	"1: ui"	"public void testMoveCursorToVisibleOffset() throws Throwable {
        mTextView = findTextView(R.id.textview_text);

        // not a spannable text
        mActivityRule.runOnUiThread(() -> assertFalse(mTextView.moveCursorToVisibleOffset()));
        mInstrumentation.waitForIdleSync();

        // a selection range
        final String spannableText = ""text"";
        mActivityRule.runOnUiThread(() ->  mTextView = new TextView(mActivity));
        mInstrumentation.waitForIdleSync();

        mActivityRule.runOnUiThread(
                () -> mTextView.setText(spannableText, BufferType.SPANNABLE));
        mInstrumentation.waitForIdleSync();
        Selection.setSelection((Spannable) mTextView.getText(), 0, spannableText.length());

        assertEquals(0, mTextView.getSelectionStart());
        assertEquals(spannableText.length(), mTextView.getSelectionEnd());
        mActivityRule.runOnUiThread(() -> assertFalse(mTextView.moveCursorToVisibleOffset()));
        mInstrumentation.waitForIdleSync();

        // a spannable without range
        mActivityRule.runOnUiThread(() -> {
            mTextView = findTextView(R.id.textview_text);
            mTextView.setText(spannableText, BufferType.SPANNABLE);
        });
        mInstrumentation.waitForIdleSync();

        mActivityRule.runOnUiThread(() -> assertTrue(mTextView.moveCursorToVisibleOffset()));
        mInstrumentation.waitForIdleSync();
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testIsInputMethodTarget"	"CtsWidgetTestCases"	"1: ui"	"public void testIsInputMethodTarget() throws Throwable {
        mTextView = findTextView(R.id.textview_text);
        assertFalse(mTextView.isInputMethodTarget());

        assertFalse(mTextView.isFocused());
        mActivityRule.runOnUiThread(() -> {
            mTextView.setFocusable(true);
            mTextView.requestFocus();
         });
        mInstrumentation.waitForIdleSync();
        assertTrue(mTextView.isFocused());

        PollingCheck.waitFor(mTextView::isInputMethodTarget);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testBeginEndBatchEditCallbacksAreCalledForEditableText"	"CtsWidgetTestCases"	"1: ui"	"public void testBeginEndBatchEditCallbacksAreCalledForEditableText() throws Throwable {
        mActivityRule.runOnUiThread(() -> mTextView = spy(new TextView(mActivity)));
        mInstrumentation.waitForIdleSync();

        final FrameLayout layout = new FrameLayout(mActivity);
        ViewGroup.LayoutParams layoutParams = new ViewGroup.LayoutParams(
                ViewGroup.LayoutParams.MATCH_PARENT,
                ViewGroup.LayoutParams.MATCH_PARENT);
        layout.addView(mTextView, layoutParams);
        layout.setLayoutParams(layoutParams);

        mActivityRule.runOnUiThread(() -> mActivity.setContentView(layout));
        mInstrumentation.waitForIdleSync();

        mActivityRule.runOnUiThread(() -> {
            mTextView.setKeyListener(QwertyKeyListener.getInstance(false, Capitalize.NONE));
            mTextView.setText("""", BufferType.EDITABLE);
            mTextView.requestFocus();
        });
        mInstrumentation.waitForIdleSync();

        reset(mTextView);
        assertTrue(mTextView.hasFocus());
        verify(mTextView, never()).onBeginBatchEdit();
        verify(mTextView, never()).onEndBatchEdit();

        mTextView.beginBatchEdit();

        verify(mTextView, times(1)).onBeginBatchEdit();
        verify(mTextView, never()).onEndBatchEdit();

        reset(mTextView);
        mTextView.endBatchEdit();
        verify(mTextView, never()).onBeginBatchEdit();
        verify(mTextView, times(1)).onEndBatchEdit();
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testCancelLongPress"	"CtsWidgetTestCases"	"1: ui"	"public void testCancelLongPress() {
        mTextView = findTextView(R.id.textview_text);
        CtsTouchUtils.emulateLongPressOnViewCenter(mInstrumentation, mActivityRule, mTextView);
        mTextView.cancelLongPress();
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testClearComposingText"	"CtsWidgetTestCases"	"1: ui"	"public void testClearComposingText() {
        mTextView = findTextView(R.id.textview_text);
        mTextView.setText(""Hello world!"", BufferType.SPANNABLE);
        Spannable text = (Spannable) mTextView.getText();

        assertEquals(-1, BaseInputConnection.getComposingSpanStart(text));
        assertEquals(-1, BaseInputConnection.getComposingSpanStart(text));

        BaseInputConnection.setComposingSpans((Spannable) mTextView.getText());
        assertEquals(0, BaseInputConnection.getComposingSpanStart(text));
        assertEquals(0, BaseInputConnection.getComposingSpanStart(text));

        mTextView.clearComposingText();
        assertEquals(-1, BaseInputConnection.getComposingSpanStart(text));
        assertEquals(-1, BaseInputConnection.getComposingSpanStart(text));
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testComputeVerticalScrollExtent"	"CtsWidgetTestCases"	"1: ui"	"public void testComputeVerticalScrollExtent() {
        mTextView = new MockTextView(mActivity);
        assertEquals(0, ((MockTextView) mTextView).computeVerticalScrollExtent());

        Drawable d = TestUtils.getDrawable(mActivity, R.drawable.pass);
        mTextView.setCompoundDrawables(null, d, null, d);

        assertEquals(0, ((MockTextView) mTextView).computeVerticalScrollExtent());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSelectAllJustAfterTap"	"CtsWidgetTestCases"	"1: ui"	"public void testSelectAllJustAfterTap() throws Throwable {
        // Prepare an EditText with focus.
        mActivityRule.runOnUiThread(() -> {
            // Make a placeholder focusable so that initial focus doesn't go to our test textview
            LinearLayout top = new LinearLayout(mActivity);
            TextView placeholder = new TextView(mActivity);
            placeholder.setFocusableInTouchMode(true);
            top.addView(placeholder, LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
            mTextView = new EditText(mActivity);
            top.addView(mTextView, LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
            mActivity.setContentView(top);

            assertFalse(mTextView.didTouchFocusSelect());
            mTextView.setFocusable(true);
            mTextView.requestFocus();
            assertTrue(mTextView.didTouchFocusSelect());

            mTextView.setText(""Hello, World."", BufferType.SPANNABLE);
        });
        mInstrumentation.waitForIdleSync();

        // Tap the view to show InsertPointController.
        CtsTouchUtils.emulateTapOnViewCenter(mInstrumentation, mActivityRule, mTextView);
        // bad workaround for waiting onStartInputView of LeanbackIme.apk done
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // Execute SelectAll context menu.
        mActivityRule.runOnUiThread(() -> mTextView.onTextContextMenuItem(android.R.id.selectAll));
        mInstrumentation.waitForIdleSync();

        // The selection must be whole of the text contents.
        assertEquals(0, mTextView.getSelectionStart());
        assertEquals(""Hello, World."", mTextView.getText().toString());
        assertEquals(mTextView.length(), mTextView.getSelectionEnd());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testExtractText"	"CtsWidgetTestCases"	"1: ui"	"public void testExtractText() {
        mTextView = new TextView(mActivity);

        ExtractedTextRequest request = new ExtractedTextRequest();
        ExtractedText outText = new ExtractedText();

        request.token = 0;
        request.flags = 10;
        request.hintMaxLines = 2;
        request.hintMaxChars = 20;
        assertTrue(mTextView.extractText(request, outText));

        mTextView = findTextView(R.id.textview_text);
        assertTrue(mTextView.extractText(request, outText));

        assertEquals(mActivity.getResources().getString(R.string.text_view_hello),
                outText.text.toString());

        // Tests for invalid arguments.
        assertFalse(mTextView.extractText(request, null));
        assertFalse(mTextView.extractText(null, outText));
        assertFalse(mTextView.extractText(null, null));
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testTextLocales"	"CtsWidgetTestCases"	"1: ui"	"public void testTextLocales() {
        TextView tv = new TextView(mActivity);
        assertEquals(Locale.getDefault(), tv.getTextLocale());
        assertEquals(LocaleList.getDefault(), tv.getTextLocales());

        tv.setTextLocale(Locale.CHINESE);
        assertEquals(Locale.CHINESE, tv.getTextLocale());
        assertEquals(new LocaleList(Locale.CHINESE), tv.getTextLocales());

        tv.setTextLocales(LocaleList.forLanguageTags(""en,ja""));
        assertEquals(Locale.forLanguageTag(""en""), tv.getTextLocale());
        assertEquals(LocaleList.forLanguageTags(""en,ja""), tv.getTextLocales());

        try {
            tv.setTextLocale(null);
            fail(""Setting the text locale to null should throw"");
        } catch (Throwable e) {
            assertEquals(IllegalArgumentException.class, e.getClass());
        }

        try {
            tv.setTextLocales(null);
            fail(""Setting the text locales to null should throw"");
        } catch (Throwable e) {
            assertEquals(IllegalArgumentException.class, e.getClass());
        }

        try {
            tv.setTextLocales(new LocaleList());
            fail(""Setting the text locale to an empty list should throw"");
        } catch (Throwable e) {
            assertEquals(IllegalArgumentException.class, e.getClass());
        }
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAllCaps_Localization"	"CtsWidgetTestCases"	"1: ui"	"public void testAllCaps_Localization() {
        final String testString = ""abcdefghijklmnopqrstuvwxyz i\u0307\u0301 άέήίΐόύΰώάυ ή"";

        // Capital ""i"" in Turkish and Azerbaijani is different from English, Lithuanian has special
        // rules for uppercasing dotted i with accents, and Greek has complex capitalization rules.
        final Locale[] testLocales = {
            new Locale(""az"", ""AZ""),  // Azerbaijani
            new Locale(""tr"", ""TR""),  // Turkish
            new Locale(""lt"", ""LT""),  // Lithuanian
            new Locale(""el"", ""GR""),  // Greek
            Locale.US,
        };

        final TextView tv = new TextView(mActivity);
        tv.setAllCaps(true);
        for (Locale locale: testLocales) {
            tv.setTextLocale(locale);
            assertEquals(""Locale: "" + locale.getDisplayName(),
                         UCharacter.toUpperCase(locale, testString),
                         tv.getTransformationMethod().getTransformation(testString, tv).toString());
        }
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAllCaps_SpansArePreserved"	"CtsWidgetTestCases"	"1: ui"	"public void testAllCaps_SpansArePreserved() {
        final Locale greek = new Locale(""el"", ""GR"");
        final String lowerString = ""ι\u0301ριδα"";  // ίριδα with first letter decomposed
        final String upperString = ""ΙΡΙΔΑ"";  // uppercased
        // expected lowercase to uppercase index map
        final int[] indexMap = {0, 1, 1, 2, 3, 4, 5};
        final int flags = Spanned.SPAN_INCLUSIVE_INCLUSIVE;

        final TextView tv = new TextView(mActivity);
        tv.setTextLocale(greek);
        tv.setAllCaps(true);

        final Spannable source = new SpannableString(lowerString);
        source.setSpan(new Object(), 0, 1, flags);
        source.setSpan(new Object(), 1, 2, flags);
        source.setSpan(new Object(), 2, 3, flags);
        source.setSpan(new Object(), 3, 4, flags);
        source.setSpan(new Object(), 4, 5, flags);
        source.setSpan(new Object(), 5, 6, flags);
        source.setSpan(new Object(), 0, 2, flags);
        source.setSpan(new Object(), 1, 3, flags);
        source.setSpan(new Object(), 2, 4, flags);
        source.setSpan(new Object(), 0, 6, flags);
        final Object[] sourceSpans = source.getSpans(0, source.length(), Object.class);

        final CharSequence transformed =
                tv.getTransformationMethod().getTransformation(source, tv);
        assertTrue(transformed instanceof Spanned);
        final Spanned result = (Spanned) transformed;

        assertEquals(upperString, transformed.toString());
        final Object[] resultSpans = result.getSpans(0, result.length(), Object.class);
        assertEquals(sourceSpans.length, resultSpans.length);
        for (int i = 0; i < sourceSpans.length; i++) {
            assertSame(sourceSpans[i], resultSpans[i]);
            final Object span = sourceSpans[i];
            assertEquals(indexMap[source.getSpanStart(span)], result.getSpanStart(span));
            assertEquals(indexMap[source.getSpanEnd(span)], result.getSpanEnd(span));
            assertEquals(source.getSpanFlags(span), result.getSpanFlags(span));
        }
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testTextAlignmentDefault"	"CtsWidgetTestCases"	"1: ui"	"public void testTextAlignmentDefault() {
        TextView tv = new TextView(mActivity);
        assertEquals(View.TEXT_ALIGNMENT_GRAVITY, tv.getRawTextAlignment());
        // resolved default text alignment is GRAVITY
        assertEquals(View.TEXT_ALIGNMENT_GRAVITY, tv.getTextAlignment());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetGetTextAlignment"	"CtsWidgetTestCases"	"1: ui"	"public void testSetGetTextAlignment() {
        TextView tv = new TextView(mActivity);

        tv.setTextAlignment(View.TEXT_ALIGNMENT_GRAVITY);
        assertEquals(View.TEXT_ALIGNMENT_GRAVITY, tv.getRawTextAlignment());

        tv.setTextAlignment(View.TEXT_ALIGNMENT_CENTER);
        assertEquals(View.TEXT_ALIGNMENT_CENTER, tv.getRawTextAlignment());

        tv.setTextAlignment(View.TEXT_ALIGNMENT_TEXT_START);
        assertEquals(View.TEXT_ALIGNMENT_TEXT_START, tv.getRawTextAlignment());

        tv.setTextAlignment(View.TEXT_ALIGNMENT_TEXT_END);
        assertEquals(View.TEXT_ALIGNMENT_TEXT_END, tv.getRawTextAlignment());

        tv.setTextAlignment(View.TEXT_ALIGNMENT_VIEW_START);
        assertEquals(View.TEXT_ALIGNMENT_VIEW_START, tv.getRawTextAlignment());

        tv.setTextAlignment(View.TEXT_ALIGNMENT_VIEW_END);
        assertEquals(View.TEXT_ALIGNMENT_VIEW_END, tv.getRawTextAlignment());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetResolvedTextAlignment"	"CtsWidgetTestCases"	"1: ui"	"public void testGetResolvedTextAlignment() {
        TextView tv = new TextView(mActivity);

        assertEquals(View.TEXT_ALIGNMENT_GRAVITY, tv.getTextAlignment());

        // Test center alignment first so that we dont hit the default case
        tv.setTextAlignment(View.TEXT_ALIGNMENT_CENTER);
        assertEquals(View.TEXT_ALIGNMENT_CENTER, tv.getTextAlignment());

        // Test the default case too
        tv.setTextAlignment(View.TEXT_ALIGNMENT_GRAVITY);
        assertEquals(View.TEXT_ALIGNMENT_GRAVITY, tv.getTextAlignment());

        tv.setTextAlignment(View.TEXT_ALIGNMENT_TEXT_START);
        assertEquals(View.TEXT_ALIGNMENT_TEXT_START, tv.getTextAlignment());

        tv.setTextAlignment(View.TEXT_ALIGNMENT_TEXT_END);
        assertEquals(View.TEXT_ALIGNMENT_TEXT_END, tv.getTextAlignment());

        tv.setTextAlignment(View.TEXT_ALIGNMENT_VIEW_START);
        assertEquals(View.TEXT_ALIGNMENT_VIEW_START, tv.getTextAlignment());

        tv.setTextAlignment(View.TEXT_ALIGNMENT_VIEW_END);
        assertEquals(View.TEXT_ALIGNMENT_VIEW_END, tv.getTextAlignment());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetResolvedTextAlignmentWithInheritance"	"CtsWidgetTestCases"	"1: ui"	"public void testGetResolvedTextAlignmentWithInheritance() {
        LinearLayout ll = new LinearLayout(mActivity);
        ll.setTextAlignment(View.TEXT_ALIGNMENT_GRAVITY);

        TextView tv = new TextView(mActivity);
        ll.addView(tv);

        // check defaults
        assertEquals(View.TEXT_ALIGNMENT_GRAVITY, tv.getRawTextAlignment());
        assertEquals(View.TEXT_ALIGNMENT_GRAVITY, tv.getTextAlignment());

        // set inherit and check that child is following parent
        tv.setTextAlignment(View.TEXT_ALIGNMENT_INHERIT);
        assertEquals(View.TEXT_ALIGNMENT_INHERIT, tv.getRawTextAlignment());

        ll.setTextAlignment(View.TEXT_ALIGNMENT_CENTER);
        assertEquals(View.TEXT_ALIGNMENT_CENTER, tv.getTextAlignment());

        ll.setTextAlignment(View.TEXT_ALIGNMENT_TEXT_START);
        assertEquals(View.TEXT_ALIGNMENT_TEXT_START, tv.getTextAlignment());

        ll.setTextAlignment(View.TEXT_ALIGNMENT_TEXT_END);
        assertEquals(View.TEXT_ALIGNMENT_TEXT_END, tv.getTextAlignment());

        ll.setTextAlignment(View.TEXT_ALIGNMENT_VIEW_START);
        assertEquals(View.TEXT_ALIGNMENT_VIEW_START, tv.getTextAlignment());

        ll.setTextAlignment(View.TEXT_ALIGNMENT_VIEW_END);
        assertEquals(View.TEXT_ALIGNMENT_VIEW_END, tv.getTextAlignment());

        // now get rid of the inheritance but still change the parent
        tv.setTextAlignment(View.TEXT_ALIGNMENT_CENTER);

        ll.setTextAlignment(View.TEXT_ALIGNMENT_CENTER);
        assertEquals(View.TEXT_ALIGNMENT_CENTER, tv.getTextAlignment());

        ll.setTextAlignment(View.TEXT_ALIGNMENT_TEXT_START);
        assertEquals(View.TEXT_ALIGNMENT_CENTER, tv.getTextAlignment());

        ll.setTextAlignment(View.TEXT_ALIGNMENT_TEXT_END);
        assertEquals(View.TEXT_ALIGNMENT_CENTER, tv.getTextAlignment());

        ll.setTextAlignment(View.TEXT_ALIGNMENT_VIEW_START);
        assertEquals(View.TEXT_ALIGNMENT_CENTER, tv.getTextAlignment());

        ll.setTextAlignment(View.TEXT_ALIGNMENT_VIEW_END);
        assertEquals(View.TEXT_ALIGNMENT_CENTER, tv.getTextAlignment());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testResetTextAlignment"	"CtsWidgetTestCases"	"1: ui"	"public void testResetTextAlignment() {
        LinearLayout ll = (LinearLayout) mActivity.findViewById(R.id.layout_textviewtest);
        TextView tv = (TextView) mActivity.findViewById(R.id.textview_rtl);

        ll.setTextAlignment(View.TEXT_ALIGNMENT_CENTER);
        tv.setTextAlignment(View.TEXT_ALIGNMENT_INHERIT);
        assertEquals(View.TEXT_ALIGNMENT_CENTER, tv.getTextAlignment());

        // No reset when we remove the view
        ll.removeView(tv);
        assertEquals(View.TEXT_ALIGNMENT_CENTER, tv.getTextAlignment());

        // Reset is done when we add the view
        // Default text alignment is GRAVITY
        ll.addView(tv);
        assertEquals(View.TEXT_ALIGNMENT_GRAVITY, tv.getTextAlignment());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testCompoundAndTotalPadding"	"CtsWidgetTestCases"	"1: ui"	"public void testCompoundAndTotalPadding() {
        final Resources res = mActivity.getResources();
        final int drawablePadding = res.getDimensionPixelSize(R.dimen.textview_drawable_padding);
        final int paddingLeft = res.getDimensionPixelSize(R.dimen.textview_padding_left);
        final int paddingRight = res.getDimensionPixelSize(R.dimen.textview_padding_right);
        final int paddingTop = res.getDimensionPixelSize(R.dimen.textview_padding_top);
        final int paddingBottom = res.getDimensionPixelSize(R.dimen.textview_padding_bottom);
        final int iconSize = TestUtils.dpToPx(mActivity, 32);

        final TextView textViewLtr = (TextView) mActivity.findViewById(
                R.id.textview_compound_drawable_ltr);
        final int combinedPaddingLeftLtr = paddingLeft + drawablePadding + iconSize;
        final int combinedPaddingRightLtr = paddingRight + drawablePadding + iconSize;
        assertEquals(combinedPaddingLeftLtr, textViewLtr.getCompoundPaddingLeft());
        assertEquals(combinedPaddingLeftLtr, textViewLtr.getCompoundPaddingStart());
        assertEquals(combinedPaddingLeftLtr, textViewLtr.getTotalPaddingLeft());
        assertEquals(combinedPaddingLeftLtr, textViewLtr.getTotalPaddingStart());
        assertEquals(combinedPaddingRightLtr, textViewLtr.getCompoundPaddingRight());
        assertEquals(combinedPaddingRightLtr, textViewLtr.getCompoundPaddingEnd());
        assertEquals(combinedPaddingRightLtr, textViewLtr.getTotalPaddingRight());
        assertEquals(combinedPaddingRightLtr, textViewLtr.getTotalPaddingEnd());
        assertEquals(paddingTop + drawablePadding + iconSize,
                textViewLtr.getCompoundPaddingTop());
        assertEquals(paddingBottom + drawablePadding + iconSize,
                textViewLtr.getCompoundPaddingBottom());

        final TextView textViewRtl = (TextView) mActivity.findViewById(
                R.id.textview_compound_drawable_rtl);
        final int combinedPaddingLeftRtl = paddingLeft + drawablePadding + iconSize;
        final int combinedPaddingRightRtl = paddingRight + drawablePadding + iconSize;
        assertEquals(combinedPaddingLeftRtl, textViewRtl.getCompoundPaddingLeft());
        assertEquals(combinedPaddingLeftRtl, textViewRtl.getCompoundPaddingEnd());
        assertEquals(combinedPaddingLeftRtl, textViewRtl.getTotalPaddingLeft());
        assertEquals(combinedPaddingLeftRtl, textViewRtl.getTotalPaddingEnd());
        assertEquals(combinedPaddingRightRtl, textViewRtl.getCompoundPaddingRight());
        assertEquals(combinedPaddingRightRtl, textViewRtl.getCompoundPaddingStart());
        assertEquals(combinedPaddingRightRtl, textViewRtl.getTotalPaddingRight());
        assertEquals(combinedPaddingRightRtl, textViewRtl.getTotalPaddingStart());
        assertEquals(paddingTop + drawablePadding + iconSize,
                textViewRtl.getCompoundPaddingTop());
        assertEquals(paddingBottom + drawablePadding + iconSize,
                textViewRtl.getCompoundPaddingBottom());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetGetBreakStrategy"	"CtsWidgetTestCases"	"1: ui"	"public void testSetGetBreakStrategy() {
        TextView tv = new TextView(mActivity);

        assertEquals(Layout.BREAK_STRATEGY_HIGH_QUALITY, tv.getBreakStrategy());

        tv.setBreakStrategy(Layout.BREAK_STRATEGY_SIMPLE);
        assertEquals(Layout.BREAK_STRATEGY_SIMPLE, tv.getBreakStrategy());

        tv.setBreakStrategy(Layout.BREAK_STRATEGY_HIGH_QUALITY);
        assertEquals(Layout.BREAK_STRATEGY_HIGH_QUALITY, tv.getBreakStrategy());

        tv.setBreakStrategy(Layout.BREAK_STRATEGY_BALANCED);
        assertEquals(Layout.BREAK_STRATEGY_BALANCED, tv.getBreakStrategy());

        EditText et = new EditText(mActivity);

        // The default value is from the theme, here the default is BREAK_STRATEGY_SIMPLE for
        // EditText.
        assertEquals(Layout.BREAK_STRATEGY_SIMPLE, et.getBreakStrategy());

        et.setBreakStrategy(Layout.BREAK_STRATEGY_SIMPLE);
        assertEquals(Layout.BREAK_STRATEGY_SIMPLE, et.getBreakStrategy());

        et.setBreakStrategy(Layout.BREAK_STRATEGY_HIGH_QUALITY);
        assertEquals(Layout.BREAK_STRATEGY_HIGH_QUALITY, et.getBreakStrategy());

        et.setBreakStrategy(Layout.BREAK_STRATEGY_BALANCED);
        assertEquals(Layout.BREAK_STRATEGY_BALANCED, et.getBreakStrategy());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetGetHyphenationFrequency"	"CtsWidgetTestCases"	"1: ui"	"public void testSetGetHyphenationFrequency() {
        TextView tv = new TextView(mActivity);

        // Hypenation is enabled by default on watches to fit more text on their tiny screens.
        if (isWatch()) {
            assertEquals(Layout.HYPHENATION_FREQUENCY_NORMAL, tv.getHyphenationFrequency());
        } else {
            assertEquals(Layout.HYPHENATION_FREQUENCY_NONE, tv.getHyphenationFrequency());
        }

        tv.setHyphenationFrequency(Layout.HYPHENATION_FREQUENCY_NORMAL);
        assertEquals(Layout.HYPHENATION_FREQUENCY_NORMAL, tv.getHyphenationFrequency());

        tv.setHyphenationFrequency(Layout.HYPHENATION_FREQUENCY_FULL);
        assertEquals(Layout.HYPHENATION_FREQUENCY_FULL, tv.getHyphenationFrequency());

        tv.setHyphenationFrequency(Layout.HYPHENATION_FREQUENCY_NONE);
        assertEquals(Layout.HYPHENATION_FREQUENCY_NONE, tv.getHyphenationFrequency());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetAndGetCustomSelectionActionModeCallback"	"CtsWidgetTestCases"	"1: ui"	"public void testSetAndGetCustomSelectionActionModeCallback() throws Throwable {
        final String text = ""abcde"";
        mActivityRule.runOnUiThread(() -> {
            mTextView = new EditText(mActivity);
            mActivity.setContentView(mTextView);
            mTextView.setText(text, BufferType.SPANNABLE);
            mTextView.setTextIsSelectable(true);
            mTextView.requestFocus();
            mTextView.setSelected(true);
            mTextView.setTextClassifier(TextClassifier.NO_OP);
        });
        mInstrumentation.waitForIdleSync();

        // Check default value.
        assertNull(mTextView.getCustomSelectionActionModeCallback());

        final ActionMode.Callback mockActionModeCallback = mock(ActionMode.Callback.class);
        when(mockActionModeCallback.onCreateActionMode(any(ActionMode.class), any(Menu.class))).
                thenReturn(Boolean.FALSE);
        mTextView.setCustomSelectionActionModeCallback(mockActionModeCallback);
        assertEquals(mockActionModeCallback,
                mTextView.getCustomSelectionActionModeCallback());

        mActivityRule.runOnUiThread(() -> {
            // Set selection and try to start action mode.
            final Bundle args = new Bundle();
            args.putInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_START_INT, 0);
            args.putInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_END_INT, text.length());
            mTextView.performAccessibilityAction(
                    AccessibilityNodeInfo.ACTION_SET_SELECTION, args);
        });
        mInstrumentation.waitForIdleSync();

        verify(mockActionModeCallback, times(1)).onCreateActionMode(
                any(ActionMode.class), any(Menu.class));

        mActivityRule.runOnUiThread(() -> {
            // Remove selection and stop action mode.
            mTextView.onTextContextMenuItem(android.R.id.copy);
        });
        mInstrumentation.waitForIdleSync();

        // Action mode was blocked.
        verify(mockActionModeCallback, never()).onDestroyActionMode(any(ActionMode.class));

        // Reset and reconfigure callback.
        reset(mockActionModeCallback);
        when(mockActionModeCallback.onCreateActionMode(any(ActionMode.class), any(Menu.class))).
                thenReturn(Boolean.TRUE);
        assertEquals(mockActionModeCallback, mTextView.getCustomSelectionActionModeCallback());

        mActivityRule.runOnUiThread(() -> {
            // Set selection and try to start action mode.
            final Bundle args = new Bundle();
            args.putInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_START_INT, 0);
            args.putInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_END_INT, text.length());
            mTextView.performAccessibilityAction(
                    AccessibilityNodeInfo.ACTION_SET_SELECTION, args);

        });
        mInstrumentation.waitForIdleSync();

        verify(mockActionModeCallback, times(1)).onCreateActionMode(
                any(ActionMode.class), any(Menu.class));

        mActivityRule.runOnUiThread(() -> {
            // Remove selection and stop action mode.
            mTextView.onTextContextMenuItem(android.R.id.copy);
        });
        mInstrumentation.waitForIdleSync();

        // Action mode was started
        verify(mockActionModeCallback, times(1)).onDestroyActionMode(any(ActionMode.class));
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetAndGetCustomInsertionActionMode"	"CtsWidgetTestCases"	"1: ui"	"public void testSetAndGetCustomInsertionActionMode() {
        initTextViewForTyping();
        // Check default value.
        assertNull(mTextView.getCustomInsertionActionModeCallback());

        final ActionMode.Callback mockActionModeCallback = mock(ActionMode.Callback.class);
        when(mockActionModeCallback.onCreateActionMode(any(ActionMode.class), any(Menu.class))).
                thenReturn(Boolean.FALSE);
        mTextView.setCustomInsertionActionModeCallback(mockActionModeCallback);
        assertEquals(mockActionModeCallback, mTextView.getCustomInsertionActionModeCallback());
        // TODO(Bug: 22033189): Tests the set callback is actually used.
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testTextShadows"	"CtsWidgetTestCases"	"1: ui"	"public void testTextShadows() throws Throwable {
        final TextView textViewWithConfiguredShadow =
                (TextView) mActivity.findViewById(R.id.textview_with_shadow);
        assertEquals(1.0f, textViewWithConfiguredShadow.getShadowDx(), 0.0f);
        assertEquals(2.0f, textViewWithConfiguredShadow.getShadowDy(), 0.0f);
        assertEquals(3.0f, textViewWithConfiguredShadow.getShadowRadius(), 0.0f);
        assertEquals(Color.GREEN, textViewWithConfiguredShadow.getShadowColor());

        final TextView textView = (TextView) mActivity.findViewById(R.id.textview_text);
        assertEquals(0.0f, textView.getShadowDx(), 0.0f);
        assertEquals(0.0f, textView.getShadowDy(), 0.0f);
        assertEquals(0.0f, textView.getShadowRadius(), 0.0f);

        mActivityRule.runOnUiThread(() -> textView.setShadowLayer(5.0f, 3.0f, 4.0f, Color.RED));
        mInstrumentation.waitForIdleSync();
        assertEquals(3.0f, textView.getShadowDx(), 0.0f);
        assertEquals(4.0f, textView.getShadowDy(), 0.0f);
        assertEquals(5.0f, textView.getShadowRadius(), 0.0f);
        assertEquals(Color.RED, textView.getShadowColor());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testFontFeatureSettings"	"CtsWidgetTestCases"	"1: ui"	"public void testFontFeatureSettings() throws Throwable {
        final TextView textView = (TextView) mActivity.findViewById(R.id.textview_text);
        assertTrue(TextUtils.isEmpty(textView.getFontFeatureSettings()));

        mActivityRule.runOnUiThread(() -> textView.setFontFeatureSettings(""smcp""));
        mInstrumentation.waitForIdleSync();
        assertEquals(""smcp"", textView.getFontFeatureSettings());

        mActivityRule.runOnUiThread(() -> textView.setFontFeatureSettings(""frac""));
        mInstrumentation.waitForIdleSync();
        assertEquals(""frac"", textView.getFontFeatureSettings());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testIsSuggestionsEnabled"	"CtsWidgetTestCases"	"1: ui"	"public void testIsSuggestionsEnabled() throws Throwable {
        mTextView = findTextView(R.id.textview_text);

        // Anything without InputType.TYPE_CLASS_TEXT doesn't have suggestions enabled
        mActivityRule.runOnUiThread(() -> mTextView.setInputType(InputType.TYPE_CLASS_DATETIME));
        assertFalse(mTextView.isSuggestionsEnabled());

        mActivityRule.runOnUiThread(() -> mTextView.setInputType(InputType.TYPE_CLASS_PHONE));
        assertFalse(mTextView.isSuggestionsEnabled());

        mActivityRule.runOnUiThread(() -> mTextView.setInputType(InputType.TYPE_CLASS_NUMBER));
        assertFalse(mTextView.isSuggestionsEnabled());

        // From this point our text view has InputType.TYPE_CLASS_TEXT

        // Anything with InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS doesn't have suggestions enabled
        mActivityRule.runOnUiThread(
                () -> mTextView.setInputType(
                        InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS));
        assertFalse(mTextView.isSuggestionsEnabled());

        mActivityRule.runOnUiThread(
                () -> mTextView.setInputType(
                        InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_NORMAL |
                                InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS));
        assertFalse(mTextView.isSuggestionsEnabled());

        mActivityRule.runOnUiThread(
                () -> mTextView.setInputType(
                        InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS |
                                InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS));
        assertFalse(mTextView.isSuggestionsEnabled());

        // Otherwise suggestions are enabled for specific type variations enumerated in the
        // documentation of TextView.isSuggestionsEnabled
        mActivityRule.runOnUiThread(
                () -> mTextView.setInputType(
                        InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_NORMAL));
        assertTrue(mTextView.isSuggestionsEnabled());

        mActivityRule.runOnUiThread(
                () -> mTextView.setInputType(
                        InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_EMAIL_SUBJECT));
        assertTrue(mTextView.isSuggestionsEnabled());

        mActivityRule.runOnUiThread(
                () -> mTextView.setInputType(
                        InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_LONG_MESSAGE));
        assertTrue(mTextView.isSuggestionsEnabled());

        mActivityRule.runOnUiThread(
                () -> mTextView.setInputType(
                        InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_SHORT_MESSAGE));
        assertTrue(mTextView.isSuggestionsEnabled());

        mActivityRule.runOnUiThread(
                () -> mTextView.setInputType(
                        InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_WEB_EDIT_TEXT));
        assertTrue(mTextView.isSuggestionsEnabled());

        // and not on any other type variation
        mActivityRule.runOnUiThread(
                () -> mTextView.setInputType(
                        InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS));
        assertFalse(mTextView.isSuggestionsEnabled());

        mActivityRule.runOnUiThread(
                () -> mTextView.setInputType(
                        InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_FILTER));
        assertFalse(mTextView.isSuggestionsEnabled());

        mActivityRule.runOnUiThread(
                () -> mTextView.setInputType(
                        InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD));
        assertFalse(mTextView.isSuggestionsEnabled());

        mActivityRule.runOnUiThread(
                () -> mTextView.setInputType(
                        InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PERSON_NAME));
        assertFalse(mTextView.isSuggestionsEnabled());

        mActivityRule.runOnUiThread(
                () -> mTextView.setInputType(
                        InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PHONETIC));
        assertFalse(mTextView.isSuggestionsEnabled());

        mActivityRule.runOnUiThread(
                () -> mTextView.setInputType(
                        InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_POSTAL_ADDRESS));
        assertFalse(mTextView.isSuggestionsEnabled());

        mActivityRule.runOnUiThread(
                () -> mTextView.setInputType(
                        InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_URI));
        assertFalse(mTextView.isSuggestionsEnabled());

        mActivityRule.runOnUiThread(
                () -> mTextView.setInputType(
                        InputType.TYPE_CLASS_TEXT |
                                InputType.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD));
        assertFalse(mTextView.isSuggestionsEnabled());

        mActivityRule.runOnUiThread(
                () -> mTextView.setInputType(
                        InputType.TYPE_CLASS_TEXT |
                                InputType.TYPE_TEXT_VARIATION_WEB_EMAIL_ADDRESS));
        assertFalse(mTextView.isSuggestionsEnabled());

        mActivityRule.runOnUiThread(
                () -> mTextView.setInputType(
                        InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_WEB_PASSWORD));
        assertFalse(mTextView.isSuggestionsEnabled());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testTextIsSelectableFocusAndOnClick"	"CtsWidgetTestCases"	"2: ui system"	"public void testTextIsSelectableFocusAndOnClick() throws Throwable {
        // Prepare a focusable TextView with an onClickListener attached.
        final View.OnClickListener mockOnClickListener = mock(View.OnClickListener.class);
        final int safeDoubleTapTimeout = ViewConfiguration.getDoubleTapTimeout() + 1;
        mActivityRule.runOnUiThread(() -> {
            // set up a placeholder focusable so that initial focus doesn't go to our test textview
            LinearLayout top = new LinearLayout(mActivity);
            TextView placeholder = new TextView(mActivity);
            placeholder.setFocusableInTouchMode(true);
            top.addView(placeholder, LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
            mTextView = new TextView(mActivity);
            mTextView.setText(""...text 11:11. some more text is in here..."");
            mTextView.setFocusable(true);
            mTextView.setOnClickListener(mockOnClickListener);
            top.addView(mTextView, LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
            mActivity.setContentView(top);
        });
        mInstrumentation.waitForIdleSync();
        assertTrue(mTextView.isFocusable());
        assertFalse(mTextView.isTextSelectable());
        assertFalse(mTextView.isFocusableInTouchMode());
        assertFalse(mTextView.isFocused());
        assertFalse(mTextView.isInTouchMode());

        // First tap on the view triggers onClick() but does not focus the TextView.
        CtsTouchUtils.emulateTapOnViewCenter(mInstrumentation, mActivityRule, mTextView);
        SystemClock.sleep(safeDoubleTapTimeout);
        assertTrue(mTextView.isInTouchMode());
        assertFalse(mTextView.isFocused());
        verify(mockOnClickListener, times(1)).onClick(mTextView);
        reset(mockOnClickListener);
        // So does the second tap.
        CtsTouchUtils.emulateTapOnViewCenter(mInstrumentation, mActivityRule, mTextView);
        SystemClock.sleep(safeDoubleTapTimeout);
        assertTrue(mTextView.isInTouchMode());
        assertFalse(mTextView.isFocused());
        verify(mockOnClickListener, times(1)).onClick(mTextView);

        mActivityRule.runOnUiThread(() -> mTextView.setTextIsSelectable(true));
        mInstrumentation.waitForIdleSync();
        assertTrue(mTextView.isFocusable());
        assertTrue(mTextView.isTextSelectable());
        assertTrue(mTextView.isFocusableInTouchMode());
        assertFalse(mTextView.isFocused());

        // First tap on the view focuses the TextView but does not trigger onClick().
        reset(mockOnClickListener);
        CtsTouchUtils.emulateTapOnViewCenter(mInstrumentation, mActivityRule, mTextView);
        SystemClock.sleep(safeDoubleTapTimeout);
        assertTrue(mTextView.isInTouchMode());
        assertTrue(mTextView.isFocused());
        verify(mockOnClickListener, never()).onClick(mTextView);
        reset(mockOnClickListener);
        // The second tap triggers onClick() and keeps the focus.
        CtsTouchUtils.emulateTapOnViewCenter(mInstrumentation, mActivityRule, mTextView);
        SystemClock.sleep(safeDoubleTapTimeout);
        assertTrue(mTextView.isInTouchMode());
        assertTrue(mTextView.isFocused());
        verify(mockOnClickListener, times(1)).onClick(mTextView);
    }

    private void verifyGetOffsetForPosition(final int x, final int y) {
        final int actual = mTextView.getOffsetForPosition(x, y);

        final Layout layout = mTextView.getLayout();
        if (layout == null) {
            assertEquals(""For ["" + x + "", "" + y + ""]"", -1, actual);
            return;
        }

        // Get the line which corresponds to the Y position
        final int line = layout.getLineForVertical(y + mTextView.getScrollY());
        // Get the offset in that line that corresponds to the X position
        final int expected = layout.getOffsetForHorizontal(line, x + mTextView.getScrollX());
        assertEquals(""For ["" + x + "", "" + y + ""]"", expected, actual);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testGetOffsetForPosition"	"CtsWidgetTestCases"	"1: ui"	"public void testGetOffsetForPosition() throws Throwable {
        mTextView = findTextView(R.id.textview_text);
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mTextView, () -> {
            mTextView.setText(LONG_TEXT);
            mTextView.setPadding(0, 0, 0, 0);
        });

        assertNotNull(mTextView.getLayout());
        final int viewWidth = mTextView.getWidth();
        final int viewHeight = mTextView.getHeight();
        final int lineHeight = mTextView.getLineHeight();

        verifyGetOffsetForPosition(0, 0);
        verifyGetOffsetForPosition(0, viewHeight / 2);
        verifyGetOffsetForPosition(viewWidth / 3, lineHeight / 2);
        verifyGetOffsetForPosition(viewWidth / 2, viewHeight / 2);
        verifyGetOffsetForPosition(viewWidth, viewHeight);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testClickableSpanOnClickDragOutside"	"CtsWidgetTestCases"	"1: ui"	"public void testClickableSpanOnClickDragOutside() throws Throwable {
        ClickableSpanTestDetails spanDetails = prepareAndRetrieveClickableSpanDetails();
        final int[] viewOnScreenXY = new int[2];
        mTextView.getLocationOnScreen(viewOnScreenXY);

        SparseArray<Point> swipeCoordinates = new SparseArray<>();
        swipeCoordinates.put(0, new Point(viewOnScreenXY[0] + spanDetails.mXPosOutside,
                viewOnScreenXY[1] + spanDetails.mYPosOutside));
        swipeCoordinates.put(1, new Point(viewOnScreenXY[0] + spanDetails.mXPosOutside + 50,
                viewOnScreenXY[1] + spanDetails.mYPosOutside + 50));
        CtsTouchUtils.emulateDragGesture(mInstrumentation, mActivityRule, swipeCoordinates);
        verify(spanDetails.mClickableSpan, never()).onClick(mTextView);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testOnInitializeA11yNodeInfo_populatesHintTextProperly"	"CtsWidgetTestCases"	"1: ui"	"public void testOnInitializeA11yNodeInfo_populatesHintTextProperly() {
        final TextView textView = new TextView(mActivity);
        textView.setText("""", BufferType.EDITABLE);
        final String hintText = ""Hint text"";
        textView.setHint(hintText);
        AccessibilityNodeInfo info = AccessibilityNodeInfo.obtain();
        textView.onInitializeAccessibilityNodeInfo(info);
        assertTrue(""Hint text flag set incorrectly for accessibility"", info.isShowingHintText());
        assertTrue(""Hint text not showing as accessibility text"",
                TextUtils.equals(hintText, info.getText()));
        assertTrue(""Hint text not provided to accessibility"",
                TextUtils.equals(hintText, info.getHintText()));

        final String nonHintText = ""Something else"";
        textView.setText(nonHintText, BufferType.EDITABLE);
        textView.onInitializeAccessibilityNodeInfo(info);
        assertFalse(""Hint text flag set incorrectly for accessibility"", info.isShowingHintText());
        assertTrue(""Text not provided to accessibility"",
                TextUtils.equals(nonHintText, info.getText()));
        assertTrue(""Hint text not provided to accessibility"",
                TextUtils.equals(hintText, info.getHintText()));
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testOnInitializeA11yNodeInfo_removesClickabilityWithLinkMovementMethod"	"CtsWidgetTestCases"	"1: ui"	"public void testOnInitializeA11yNodeInfo_removesClickabilityWithLinkMovementMethod() {
        mTextView = findTextView(R.id.textview_text);
        mTextView.setMovementMethod(new LinkMovementMethod());

        assertTrue(""clickable should be true"", mTextView.isClickable());
        assertFalse(""View should not have onClickListeners"", mTextView.hasOnClickListeners());
        assertTrue(""longClickable should be true"", mTextView.isLongClickable());
        assertFalse(""View should not have onLongClickListeners"",
                mTextView.hasOnLongClickListeners());

        final AccessibilityNodeInfo info = AccessibilityNodeInfo.obtain();
        mTextView.onInitializeAccessibilityNodeInfo(info);
        List<AccessibilityNodeInfo.AccessibilityAction> actionList = info.getActionList();
        assertFalse(""info's isClickable should be false"", info.isClickable());
        assertFalse(""info should not have ACTION_CLICK"",
                actionList.contains(AccessibilityNodeInfo.AccessibilityAction.ACTION_CLICK));
        assertFalse(""info's isLongClickable should be false"",
                info.isLongClickable());
        assertFalse(""info should not have ACTION_LONG_CLICK"",
                actionList.contains(AccessibilityNodeInfo.AccessibilityAction.ACTION_LONG_CLICK));
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testOnInitializeA11yNodeInfo_keepsClickabilityWithMovementMethod"	"CtsWidgetTestCases"	"1: ui"	"public void testOnInitializeA11yNodeInfo_keepsClickabilityWithMovementMethod() {
        mTextView = findTextView(R.id.textview_text);
        mTextView.setMovementMethod(new ArrowKeyMovementMethod());

        assertTrue(""clickable should be true"", mTextView.isClickable());
        assertFalse(""View should not have onClickListeners"", mTextView.hasOnClickListeners());
        assertTrue(""longClickable should be false"", mTextView.isLongClickable());
        assertFalse(""View should not have onLongClickListeners"",
                mTextView.hasOnLongClickListeners());

        final AccessibilityNodeInfo info = AccessibilityNodeInfo.obtain();
        mTextView.onInitializeAccessibilityNodeInfo(info);
        List<AccessibilityNodeInfo.AccessibilityAction> actionList = info.getActionList();
        assertTrue(""info's isClickable should be true"", info.isClickable());
        assertTrue(""info should have ACTION_CLICK"",
                actionList.contains(AccessibilityNodeInfo.AccessibilityAction.ACTION_CLICK));
        assertTrue(""info's isLongClickable should be true"",
                info.isLongClickable());
        assertTrue(""info should have ACTION_LONG_CLICK"",
                actionList.contains(AccessibilityNodeInfo.AccessibilityAction.ACTION_LONG_CLICK));
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testOnInitializeA11yNodeInfo_keepsClickabilityWithOnClickListener"	"CtsWidgetTestCases"	"1: ui"	"public void testOnInitializeA11yNodeInfo_keepsClickabilityWithOnClickListener() {
        mTextView = findTextView(R.id.textview_text);
        mTextView.setMovementMethod(new LinkMovementMethod());

        assertTrue(""clickable should be true"", mTextView.isClickable());
        assertFalse(""View should not have onClickListeners"", mTextView.hasOnClickListeners());
        assertTrue(""longClickable should be true"", mTextView.isLongClickable());
        assertFalse(""View should not have onLongClickListeners"",
                mTextView.hasOnLongClickListeners());

        mTextView.setOnClickListener(mock(View.OnClickListener.class));

        final AccessibilityNodeInfo info = AccessibilityNodeInfo.obtain();
        mTextView.onInitializeAccessibilityNodeInfo(info);
        List<AccessibilityNodeInfo.AccessibilityAction> actionList = info.getActionList();
        assertTrue(""info's isClickable should be true"", info.isClickable());
        assertTrue(""info should have ACTION_CLICK"",
                actionList.contains(AccessibilityNodeInfo.AccessibilityAction.ACTION_CLICK));
        assertFalse(""info's isLongClickable should not be true"",
                info.isLongClickable());
        assertFalse(""info should have ACTION_LONG_CLICK"",
                actionList.contains(AccessibilityNodeInfo.AccessibilityAction.ACTION_LONG_CLICK));
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAutoSizeCallers_setText"	"CtsWidgetTestCases"	"1: ui"	"public void testAutoSizeCallers_setText() throws Throwable {
        final TextView autoSizeTextView = prepareAndRetrieveAutoSizeTestData(
                R.id.textview_autosize_uniform, false);

        // Configure layout params and auto-size both in pixels to dodge flakiness on different
        // devices.
        final LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(
                200, 200);
        mActivityRule.runOnUiThread(() -> {
            autoSizeTextView.setLayoutParams(layoutParams);
            autoSizeTextView.setAutoSizeTextTypeUniformWithConfiguration(
                    1, 5000, 1, TypedValue.COMPLEX_UNIT_PX);
        });
        mInstrumentation.waitForIdleSync();

        final String initialText = ""13characters "";
        final StringBuilder textToSet = new StringBuilder().append(initialText);
        float initialSize = 0;

        // As we add characters the text size shrinks.
        for (int i = 0; i < 10; i++) {
            mActivityRule.runOnUiThread(() ->
                    autoSizeTextView.setText(textToSet.toString()));
            mInstrumentation.waitForIdleSync();
            float expectedLargerSize = autoSizeTextView.getTextSize();
            if (i == 0) {
                initialSize = expectedLargerSize;
            }

            textToSet.append(initialText);
            mActivityRule.runOnUiThread(() ->
                    autoSizeTextView.setText(textToSet.toString()));
            mInstrumentation.waitForIdleSync();

            assertTrue(expectedLargerSize >= autoSizeTextView.getTextSize());
        }
        assertTrue(initialSize > autoSizeTextView.getTextSize());

        initialSize = Integer.MAX_VALUE;
        // As we remove characters the text size expands.
        for (int i = 9; i >= 0; i--) {
            mActivityRule.runOnUiThread(() ->
                    autoSizeTextView.setText(textToSet.toString()));
            mInstrumentation.waitForIdleSync();
            float expectedSmallerSize = autoSizeTextView.getTextSize();
            if (i == 9) {
                initialSize = expectedSmallerSize;
            }

            textToSet.replace((textToSet.length() - initialText.length()), textToSet.length(), """");
            mActivityRule.runOnUiThread(() ->
                    autoSizeTextView.setText(textToSet.toString()));
            mInstrumentation.waitForIdleSync();

            assertTrue(autoSizeTextView.getTextSize() >= expectedSmallerSize);
        }
        assertTrue(autoSizeTextView.getTextSize() > initialSize);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAutoSize_setEllipsize"	"CtsWidgetTestCases"	"1: ui"	"public void testAutoSize_setEllipsize() throws Throwable {
        final TextView textView = (TextView) mActivity.findViewById(
                R.id.textview_autosize_uniform_predef_sizes);
        final int initialAutoSizeType = textView.getAutoSizeTextType();
        final int initialMinTextSize = textView.getAutoSizeMinTextSize();
        final int initialMaxTextSize = textView.getAutoSizeMaxTextSize();
        final int initialAutoSizeGranularity = textView.getAutoSizeStepGranularity();
        final int initialSizes = textView.getAutoSizeTextAvailableSizes().length;

        assertEquals(null, textView.getEllipsize());
        // Verify styled attributes.
        assertEquals(TextView.AUTO_SIZE_TEXT_TYPE_UNIFORM, initialAutoSizeType);
        assertNotEquals(-1, initialMinTextSize);
        assertNotEquals(-1, initialMaxTextSize);
        // Because this TextView has been configured to use predefined sizes.
        assertEquals(-1, initialAutoSizeGranularity);
        assertNotEquals(0, initialSizes);

        final TextUtils.TruncateAt newEllipsizeValue = TextUtils.TruncateAt.END;
        mActivityRule.runOnUiThread(() ->
                textView.setEllipsize(newEllipsizeValue));
        mInstrumentation.waitForIdleSync();
        assertEquals(newEllipsizeValue, textView.getEllipsize());
        // Beside the ellipsis no auto-size attribute has changed.
        assertEquals(initialAutoSizeType, textView.getAutoSizeTextType());
        assertEquals(initialMinTextSize, textView.getAutoSizeMinTextSize());
        assertEquals(initialMaxTextSize, textView.getAutoSizeMaxTextSize());
        assertEquals(initialAutoSizeGranularity, textView.getAutoSizeStepGranularity());
        assertEquals(initialSizes, textView.getAutoSizeTextAvailableSizes().length);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testEllipsize_setAutoSize"	"CtsWidgetTestCases"	"1: ui"	"public void testEllipsize_setAutoSize() throws Throwable {
        TextView textView = findTextView(R.id.textview_text);
        final TextUtils.TruncateAt newEllipsizeValue = TextUtils.TruncateAt.END;
        mActivityRule.runOnUiThread(() ->
                textView.setEllipsize(newEllipsizeValue));
        mInstrumentation.waitForIdleSync();
        assertEquals(newEllipsizeValue, textView.getEllipsize());
        assertEquals(TextView.AUTO_SIZE_TEXT_TYPE_NONE, textView.getAutoSizeTextType());
        assertEquals(-1, textView.getAutoSizeMinTextSize());
        assertEquals(-1, textView.getAutoSizeMaxTextSize());
        assertEquals(-1, textView.getAutoSizeStepGranularity());
        assertEquals(0, textView.getAutoSizeTextAvailableSizes().length);

        mActivityRule.runOnUiThread(() ->
                textView.setAutoSizeTextTypeWithDefaults(TextView.AUTO_SIZE_TEXT_TYPE_UNIFORM));
        mInstrumentation.waitForIdleSync();
        assertEquals(newEllipsizeValue, textView.getEllipsize());
        assertEquals(TextView.AUTO_SIZE_TEXT_TYPE_UNIFORM, textView.getAutoSizeTextType());
        // The auto-size defaults have been used.
        assertNotEquals(-1, textView.getAutoSizeMinTextSize());
        assertNotEquals(-1, textView.getAutoSizeMaxTextSize());
        assertNotEquals(-1, textView.getAutoSizeStepGranularity());
        assertNotEquals(0, textView.getAutoSizeTextAvailableSizes().length);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAutoSizeCallers_setTransformationMethod"	"CtsWidgetTestCases"	"1: ui"	"public void testAutoSizeCallers_setTransformationMethod() throws Throwable {
        final TextView autoSizeTextView = prepareAndRetrieveAutoSizeTestData(
                R.id.textview_autosize_uniform, false);
        // Mock transformation method to return the duplicated input text in order to measure
        // auto-sizing.
        TransformationMethod duplicateTextTransformationMethod = mock(TransformationMethod.class);
        when(duplicateTextTransformationMethod
                .getTransformation(any(CharSequence.class), any(View.class)))
                .thenAnswer(invocation -> {
                    CharSequence source = (CharSequence) invocation.getArguments()[0];
                    return new StringBuilder().append(source).append(source).toString();
                });

        mActivityRule.runOnUiThread(() ->
                autoSizeTextView.setTransformationMethod(null));
        mInstrumentation.waitForIdleSync();
        final float initialTextSize = autoSizeTextView.getTextSize();
        mActivityRule.runOnUiThread(() ->
                autoSizeTextView.setTransformationMethod(duplicateTextTransformationMethod));
        mInstrumentation.waitForIdleSync();

        assertTrue(autoSizeTextView.getTextSize() < initialTextSize);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAutoSizeCallers_setCompoundDrawables"	"CtsWidgetTestCases"	"1: ui"	"public void testAutoSizeCallers_setCompoundDrawables() throws Throwable {
        final TextView autoSizeTextView = prepareAndRetrieveAutoSizeTestData(
                R.id.textview_autosize_uniform, false);
        final float initialTextSize = autoSizeTextView.getTextSize();
        Drawable drawable = TestUtils.getDrawable(mActivity, R.drawable.red);
        drawable.setBounds(0, 0, autoSizeTextView.getWidth() / 3, autoSizeTextView.getHeight() / 3);
        mActivityRule.runOnUiThread(() ->
                autoSizeTextView.setCompoundDrawables(drawable, drawable, drawable, drawable));
        mInstrumentation.waitForIdleSync();

        assertTrue(autoSizeTextView.getTextSize() < initialTextSize);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAutoSizeCallers_setCompoundDrawablesRelative"	"CtsWidgetTestCases"	"1: ui"	"public void testAutoSizeCallers_setCompoundDrawablesRelative() throws Throwable {
        final TextView autoSizeTextView = prepareAndRetrieveAutoSizeTestData(
                R.id.textview_autosize_uniform, false);
        final float initialTextSize = autoSizeTextView.getTextSize();
        Drawable drawable = TestUtils.getDrawable(mActivity, R.drawable.red);
        drawable.setBounds(0, 0, autoSizeTextView.getWidth() / 3, autoSizeTextView.getHeight() / 3);
        mActivityRule.runOnUiThread(() -> autoSizeTextView.setCompoundDrawablesRelative(
                drawable, drawable, drawable, drawable));
        mInstrumentation.waitForIdleSync();

        assertTrue(autoSizeTextView.getTextSize() < initialTextSize);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAutoSizeCallers_setCompoundDrawablePadding"	"CtsWidgetTestCases"	"1: ui"	"public void testAutoSizeCallers_setCompoundDrawablePadding() throws Throwable {
        final TextView autoSizeTextView = prepareAndRetrieveAutoSizeTestData(
                R.id.textview_autosize_uniform, false);
        // Prepare a larger layout in order not to hit the min value easily.
        mActivityRule.runOnUiThread(() -> {
            autoSizeTextView.setWidth(autoSizeTextView.getWidth() * 2);
            autoSizeTextView.setHeight(autoSizeTextView.getHeight() * 2);
        });
        mInstrumentation.waitForIdleSync();
        // Setup the drawables before setting their padding in order to modify the available
        // space and trigger a resize.
        Drawable drawable = TestUtils.getDrawable(mActivity, R.drawable.red);
        drawable.setBounds(0, 0, autoSizeTextView.getWidth() / 4, autoSizeTextView.getHeight() / 4);
        mActivityRule.runOnUiThread(() -> autoSizeTextView.setCompoundDrawables(
                drawable, drawable, drawable, drawable));
        mInstrumentation.waitForIdleSync();
        final float initialTextSize = autoSizeTextView.getTextSize();
        mActivityRule.runOnUiThread(() -> autoSizeTextView.setCompoundDrawablePadding(
                autoSizeTextView.getCompoundDrawablePadding() + 10));
        mInstrumentation.waitForIdleSync();

        assertTrue(autoSizeTextView.getTextSize() < initialTextSize);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAutoSizeCallers_setPadding"	"CtsWidgetTestCases"	"1: ui"	"public void testAutoSizeCallers_setPadding() throws Throwable {
        final TextView autoSizeTextView = prepareAndRetrieveAutoSizeTestData(
                R.id.textview_autosize_uniform, false);
        final float initialTextSize = autoSizeTextView.getTextSize();
        mActivityRule.runOnUiThread(() -> autoSizeTextView.setPadding(
                autoSizeTextView.getWidth() / 3, autoSizeTextView.getHeight() / 3,
                autoSizeTextView.getWidth() / 3, autoSizeTextView.getHeight() / 3));
        mInstrumentation.waitForIdleSync();

        assertTrue(autoSizeTextView.getTextSize() < initialTextSize);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAutoSizeCallers_setPaddingRelative"	"CtsWidgetTestCases"	"1: ui"	"public void testAutoSizeCallers_setPaddingRelative() throws Throwable {
        final TextView autoSizeTextView = prepareAndRetrieveAutoSizeTestData(
                R.id.textview_autosize_uniform, false);
        final float initialTextSize = autoSizeTextView.getTextSize();

        mActivityRule.runOnUiThread(() -> autoSizeTextView.setPaddingRelative(
                autoSizeTextView.getWidth() / 3, autoSizeTextView.getHeight() / 3,
                autoSizeTextView.getWidth() / 3, autoSizeTextView.getHeight() / 3));
        mInstrumentation.waitForIdleSync();

        assertTrue(autoSizeTextView.getTextSize() < initialTextSize);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAutoSizeCallers_setTextScaleX"	"CtsWidgetTestCases"	"1: ui"	"public void testAutoSizeCallers_setTextScaleX() throws Throwable {
        final TextView autoSizeTextView = prepareAndRetrieveAutoSizeTestData(
                R.id.textview_autosize_uniform, false);
        final float initialTextSize = autoSizeTextView.getTextSize();

        mActivityRule.runOnUiThread(() ->
                autoSizeTextView.setTextScaleX(autoSizeTextView.getTextScaleX() * 4.5f));
        mInstrumentation.waitForIdleSync();
        final float changedTextSize = autoSizeTextView.getTextSize();

        assertTrue(changedTextSize < initialTextSize);

        mActivityRule.runOnUiThread(() ->
                autoSizeTextView.setTextScaleX(autoSizeTextView.getTextScaleX()));
        mInstrumentation.waitForIdleSync();

        assertEquals(changedTextSize, autoSizeTextView.getTextSize(), 0f);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAutoSizeCallers_setTypeface"	"CtsWidgetTestCases"	"1: ui"	"public void testAutoSizeCallers_setTypeface() throws Throwable {
        final TextView autoSizeTextView = prepareAndRetrieveAutoSizeTestData(
                R.id.textview_autosize_uniform, false);
        mActivityRule.runOnUiThread(() ->
                autoSizeTextView.setText(""The typeface change needs a bit more text then ""
                        + ""the default used for this batch of tests in order to get to resize text.""
                        + "" The resize function is always called but even with different typefaces ""
                        + ""there may not be a need to resize text because it just fits. The longer ""
                        + ""the text, the higher the chance for a resize. And here is yet another ""
                        + ""sentence to make sure this test is not flaky. Not flaky at all.""));
        mInstrumentation.waitForIdleSync();
        final float initialTextSize = autoSizeTextView.getTextSize();

        mActivityRule.runOnUiThread(() -> {
            Typeface differentTypeface = Typeface.MONOSPACE;
            if (autoSizeTextView.getTypeface() == Typeface.MONOSPACE) {
                differentTypeface = Typeface.SANS_SERIF;
            }
            autoSizeTextView.setTypeface(differentTypeface);
        });
        mInstrumentation.waitForIdleSync();
        final float changedTextSize = autoSizeTextView.getTextSize();

        // Don't really know if it is larger or smaller (depends on the typeface chosen above),
        // but it should definitely have changed.
        assertNotEquals(initialTextSize, changedTextSize, 0f);

        mActivityRule.runOnUiThread(() ->
                autoSizeTextView.setTypeface(autoSizeTextView.getTypeface()));
        mInstrumentation.waitForIdleSync();

        assertEquals(changedTextSize, autoSizeTextView.getTextSize(), 0f);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAutoSizeCallers_setLetterSpacing"	"CtsWidgetTestCases"	"1: ui"	"public void testAutoSizeCallers_setLetterSpacing() throws Throwable {
        final TextView autoSizeTextView = prepareAndRetrieveAutoSizeTestData(
                R.id.textview_autosize_uniform, false);
        final float initialTextSize = autoSizeTextView.getTextSize();

        mActivityRule.runOnUiThread(() ->
                // getLetterSpacing() could return 0, make sure there is enough of a difference to
                // trigger auto-size.
                autoSizeTextView.setLetterSpacing(
                        autoSizeTextView.getLetterSpacing() * 1.5f + 4.5f));
        mInstrumentation.waitForIdleSync();
        final float changedTextSize = autoSizeTextView.getTextSize();

        assertTrue(changedTextSize < initialTextSize);

        mActivityRule.runOnUiThread(() ->
                autoSizeTextView.setLetterSpacing(autoSizeTextView.getLetterSpacing()));
        mInstrumentation.waitForIdleSync();

        assertEquals(changedTextSize, autoSizeTextView.getTextSize(), 0f);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAutoSizeCallers_setHorizontallyScrolling"	"CtsWidgetTestCases"	"1: ui"	"public void testAutoSizeCallers_setHorizontallyScrolling() throws Throwable {
        final TextView autoSizeTextView = prepareAndRetrieveAutoSizeTestData(
                R.id.textview_autosize_uniform, false);
        // Verify that we do not have horizontal scrolling turned on.
        assertTrue(!autoSizeTextView.getHorizontallyScrolling());

        final float initialTextSize = autoSizeTextView.getTextSize();
        mActivityRule.runOnUiThread(() -> autoSizeTextView.setHorizontallyScrolling(true));
        mInstrumentation.waitForIdleSync();
        assertTrue(autoSizeTextView.getTextSize() > initialTextSize);

        mActivityRule.runOnUiThread(() -> autoSizeTextView.setHorizontallyScrolling(false));
        mInstrumentation.waitForIdleSync();
        assertEquals(initialTextSize, autoSizeTextView.getTextSize(), 0f);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAutoSizeCallers_setMaxLines"	"CtsWidgetTestCases"	"1: ui"	"public void testAutoSizeCallers_setMaxLines() throws Throwable {
        final TextView autoSizeTextView = prepareAndRetrieveAutoSizeTestData(
                R.id.textview_autosize_uniform, false);
        // Configure layout params and auto-size both in pixels to dodge flakiness on different
        // devices.
        final LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(
                200, 200);
        final String text = ""one\ntwo\nthree\nfour\nfive\nsix\nseven\neight\nnine\nten"";
        mActivityRule.runOnUiThread(() -> {
            autoSizeTextView.setLayoutParams(layoutParams);
            autoSizeTextView.setAutoSizeTextTypeUniformWithConfiguration(
                    1 /* autoSizeMinTextSize */,
                    5000 /* autoSizeMaxTextSize */,
                    1 /* autoSizeStepGranularity */,
                    TypedValue.COMPLEX_UNIT_PX);
            autoSizeTextView.setText(text);
        });
        mInstrumentation.waitForIdleSync();

        float initialSize = 0;
        for (int i = 1; i < 10; i++) {
            final int maxLines = i;
            mActivityRule.runOnUiThread(() -> autoSizeTextView.setMaxLines(maxLines));
            mInstrumentation.waitForIdleSync();
            float expectedSmallerSize = autoSizeTextView.getTextSize();
            if (i == 1) {
                initialSize = expectedSmallerSize;
            }

            mActivityRule.runOnUiThread(() -> autoSizeTextView.setMaxLines(maxLines + 1));
            mInstrumentation.waitForIdleSync();
            assertTrue(expectedSmallerSize <= autoSizeTextView.getTextSize());
        }
        assertTrue(initialSize < autoSizeTextView.getTextSize());

        initialSize = Integer.MAX_VALUE;
        for (int i = 10; i > 1; i--) {
            final int maxLines = i;
            mActivityRule.runOnUiThread(() -> autoSizeTextView.setMaxLines(maxLines));
            mInstrumentation.waitForIdleSync();
            float expectedLargerSize = autoSizeTextView.getTextSize();
            if (i == 10) {
                initialSize = expectedLargerSize;
            }

            mActivityRule.runOnUiThread(() -> autoSizeTextView.setMaxLines(maxLines - 1));
            mInstrumentation.waitForIdleSync();
            assertTrue(expectedLargerSize >= autoSizeTextView.getTextSize());
        }
        assertTrue(initialSize > autoSizeTextView.getTextSize());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAutoSizeCallers_setMaxHeight"	"CtsWidgetTestCases"	"1: ui"	"public void testAutoSizeCallers_setMaxHeight() throws Throwable {
        final TextView autoSizeTextView = prepareAndRetrieveAutoSizeTestData(
                R.id.textview_autosize_uniform, true);
        // Do not force exact height only.
        final LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(
                200,
                LinearLayout.LayoutParams.WRAP_CONTENT);
        mActivityRule.runOnUiThread(() -> autoSizeTextView.setLayoutParams(layoutParams));
        mInstrumentation.waitForIdleSync();
        final float initialTextSize = autoSizeTextView.getTextSize();
        mActivityRule.runOnUiThread(() -> autoSizeTextView.setMaxHeight(
                autoSizeTextView.getHeight() / 4));
        mInstrumentation.waitForIdleSync();

        assertTrue(autoSizeTextView.getTextSize() < initialTextSize);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAutoSizeCallers_setHeight"	"CtsWidgetTestCases"	"1: ui"	"public void testAutoSizeCallers_setHeight() throws Throwable {
        final TextView autoSizeTextView = prepareAndRetrieveAutoSizeTestData(
                R.id.textview_autosize_uniform, true);
        // Do not force exact height only.
        final LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(
                200,
                LinearLayout.LayoutParams.WRAP_CONTENT);
        mActivityRule.runOnUiThread(() -> autoSizeTextView.setLayoutParams(layoutParams));
        mInstrumentation.waitForIdleSync();
        final float initialTextSize = autoSizeTextView.getTextSize();
        mActivityRule.runOnUiThread(() -> autoSizeTextView.setHeight(
                autoSizeTextView.getHeight() / 4));
        mInstrumentation.waitForIdleSync();

        assertTrue(autoSizeTextView.getTextSize() < initialTextSize);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAutoSizeCallers_setLines"	"CtsWidgetTestCases"	"1: ui"	"public void testAutoSizeCallers_setLines() throws Throwable {
        final TextView autoSizeTextView = prepareAndRetrieveAutoSizeTestData(
                R.id.textview_autosize_uniform, false);
        final float initialTextSize = autoSizeTextView.getTextSize();
        mActivityRule.runOnUiThread(() -> autoSizeTextView.setLines(1));
        mInstrumentation.waitForIdleSync();

        assertTrue(autoSizeTextView.getTextSize() < initialTextSize);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAutoSizeCallers_setMaxWidth"	"CtsWidgetTestCases"	"1: ui"	"public void testAutoSizeCallers_setMaxWidth() throws Throwable {
        final TextView autoSizeTextView = prepareAndRetrieveAutoSizeTestData(
                R.id.textview_autosize_uniform, true);
        // Do not force exact width only.
        final LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.WRAP_CONTENT,
                200);
        mActivityRule.runOnUiThread(() -> autoSizeTextView.setLayoutParams(layoutParams));
        mInstrumentation.waitForIdleSync();
        final float initialTextSize = autoSizeTextView.getTextSize();
        mActivityRule.runOnUiThread(() -> autoSizeTextView.setMaxWidth(
                autoSizeTextView.getWidth() / 4));
        mInstrumentation.waitForIdleSync();

        assertTrue(autoSizeTextView.getTextSize() != initialTextSize);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAutoSizeCallers_setWidth"	"CtsWidgetTestCases"	"1: ui"	"public void testAutoSizeCallers_setWidth() throws Throwable {
        final TextView autoSizeTextView = prepareAndRetrieveAutoSizeTestData(
                R.id.textview_autosize_uniform, true);
        // Do not force exact width only.
        final LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.WRAP_CONTENT,
                200);
        mActivityRule.runOnUiThread(() -> autoSizeTextView.setLayoutParams(layoutParams));
        mInstrumentation.waitForIdleSync();

        final float initialTextSize = autoSizeTextView.getTextSize();
        mActivityRule.runOnUiThread(() -> autoSizeTextView.setWidth(
                autoSizeTextView.getWidth() / 4));
        mInstrumentation.waitForIdleSync();

        assertTrue(autoSizeTextView.getTextSize() != initialTextSize);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAutoSizeCallers_setLineSpacing"	"CtsWidgetTestCases"	"1: ui"	"public void testAutoSizeCallers_setLineSpacing() throws Throwable {
        final TextView autoSizeTextView = prepareAndRetrieveAutoSizeTestData(
                R.id.textview_autosize_uniform, false);
        final float initialTextSize = autoSizeTextView.getTextSize();

        mActivityRule.runOnUiThread(() -> autoSizeTextView.setLineSpacing(
                autoSizeTextView.getLineSpacingExtra() * 4,
                autoSizeTextView.getLineSpacingMultiplier() * 4));
        mInstrumentation.waitForIdleSync();
        final float changedTextSize = autoSizeTextView.getTextSize();

        assertTrue(changedTextSize < initialTextSize);

        mActivityRule.runOnUiThread(() -> autoSizeTextView.setLineSpacing(
                autoSizeTextView.getLineSpacingExtra(),
                autoSizeTextView.getLineSpacingMultiplier()));
        mInstrumentation.waitForIdleSync();

        assertEquals(changedTextSize, autoSizeTextView.getTextSize(), 0f);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAutoSizeCallers_setTextSizeIsNoOp"	"CtsWidgetTestCases"	"1: ui"	"public void testAutoSizeCallers_setTextSizeIsNoOp() throws Throwable {
        final TextView autoSizeTextView = prepareAndRetrieveAutoSizeTestData(
                R.id.textview_autosize_uniform, false);
        final float initialTextSize = autoSizeTextView.getTextSize();

        mActivityRule.runOnUiThread(() -> autoSizeTextView.setTextSize(
                initialTextSize + 123f));
        mInstrumentation.waitForIdleSync();

        assertEquals(initialTextSize, autoSizeTextView.getTextSize(), 0f);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAutoSizeCallers_setHeightForOneLineText"	"CtsWidgetTestCases"	"1: ui"	"public void testAutoSizeCallers_setHeightForOneLineText() throws Throwable {
        final TextView autoSizeTextView = (TextView) mActivity.findViewById(
                R.id.textview_autosize_basic);
        assertEquals(TextView.AUTO_SIZE_TEXT_TYPE_UNIFORM, autoSizeTextView.getAutoSizeTextType());
        final float initialTextSize = autoSizeTextView.getTextSize();
        mActivityRule.runOnUiThread(() -> autoSizeTextView.setHeight(
                autoSizeTextView.getHeight() * 3));
        mInstrumentation.waitForIdleSync();

        assertTrue(autoSizeTextView.getTextSize() > initialTextSize);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAutoSizeUniform_predefinedSizesFilteringAndSorting"	"CtsWidgetTestCases"	"1: ui"	"public void testAutoSizeUniform_predefinedSizesFilteringAndSorting() throws Throwable {
        mTextView = findTextView(R.id.textview_text);
        assertEquals(TextView.AUTO_SIZE_TEXT_TYPE_NONE, mTextView.getAutoSizeTextType());

        final int[] predefinedSizes = new int[] {400, 0, 10, 40, 10, 10, 0, 0};
        mActivityRule.runOnUiThread(() -> mTextView.setAutoSizeTextTypeUniformWithPresetSizes(
                predefinedSizes, TypedValue.COMPLEX_UNIT_PX));
        mInstrumentation.waitForIdleSync();
        assertArrayEquals(new int[] {10, 40, 400}, mTextView.getAutoSizeTextAvailableSizes());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAutoSizeUniform_predefinedSizesNullArray"	"CtsWidgetTestCases"	"1: ui"	"(expected = NullPointerException.class)
    public void testAutoSizeUniform_predefinedSizesNullArray() throws Throwable {
        mTextView = findTextView(R.id.textview_text);
        assertEquals(TextView.AUTO_SIZE_TEXT_TYPE_NONE, mTextView.getAutoSizeTextType());

        final int[] predefinedSizes = null;
        mActivityRule.runOnUiThread(() -> mTextView.setAutoSizeTextTypeUniformWithPresetSizes(
                predefinedSizes, TypedValue.COMPLEX_UNIT_PX));
        mInstrumentation.waitForIdleSync();
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAutoSizeUniform_predefinedSizesEmptyArray"	"CtsWidgetTestCases"	"1: ui"	"public void testAutoSizeUniform_predefinedSizesEmptyArray() throws Throwable {
        mTextView = findTextView(R.id.textview_text);
        assertEquals(TextView.AUTO_SIZE_TEXT_TYPE_NONE, mTextView.getAutoSizeTextType());

        mActivityRule.runOnUiThread(() ->
                mTextView.setAutoSizeTextTypeWithDefaults(TextView.AUTO_SIZE_TEXT_TYPE_UNIFORM));
        mInstrumentation.waitForIdleSync();

        final int[] defaultSizes = mTextView.getAutoSizeTextAvailableSizes();
        assertNotNull(defaultSizes);
        assertTrue(defaultSizes.length > 0);

        final int[] predefinedSizes = new int[0];
        mActivityRule.runOnUiThread(() -> mTextView.setAutoSizeTextTypeUniformWithPresetSizes(
                predefinedSizes, TypedValue.COMPLEX_UNIT_PX));
        mInstrumentation.waitForIdleSync();

        final int[] newSizes = mTextView.getAutoSizeTextAvailableSizes();
        assertNotNull(defaultSizes);
        assertArrayEquals(defaultSizes, newSizes);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAutoSizeUniform_buildsSizes"	"CtsWidgetTestCases"	"1: ui"	"public void testAutoSizeUniform_buildsSizes() throws Throwable {
        TextView autoSizeTextViewUniform = (TextView) mActivity.findViewById(
                R.id.textview_autosize_uniform);

        // Verify that the interval limits are both included.
        mActivityRule.runOnUiThread(() -> autoSizeTextViewUniform
                .setAutoSizeTextTypeUniformWithConfiguration(10, 20, 2,
                        TypedValue.COMPLEX_UNIT_PX));
        mInstrumentation.waitForIdleSync();
        assertArrayEquals(
                new int[] {10, 12, 14, 16, 18, 20},
                autoSizeTextViewUniform.getAutoSizeTextAvailableSizes());

        mActivityRule.runOnUiThread(() -> autoSizeTextViewUniform
                .setAutoSizeTextTypeUniformWithConfiguration(
                        autoSizeTextViewUniform.getAutoSizeMinTextSize(),
                        19,
                        autoSizeTextViewUniform.getAutoSizeStepGranularity(),
                        TypedValue.COMPLEX_UNIT_PX));
        mInstrumentation.waitForIdleSync();
        assertArrayEquals(
                new int[] {10, 12, 14, 16, 18},
                autoSizeTextViewUniform.getAutoSizeTextAvailableSizes());

        mActivityRule.runOnUiThread(() -> autoSizeTextViewUniform
                .setAutoSizeTextTypeUniformWithConfiguration(
                        autoSizeTextViewUniform.getAutoSizeMinTextSize(),
                        21,
                        autoSizeTextViewUniform.getAutoSizeStepGranularity(),
                        TypedValue.COMPLEX_UNIT_PX));
        mInstrumentation.waitForIdleSync();
        assertArrayEquals(
                new int[] {10, 12, 14, 16, 18, 20},
                autoSizeTextViewUniform.getAutoSizeTextAvailableSizes());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAutoSizeUniform_equivalentConfigurations"	"CtsWidgetTestCases"	"1: ui"	"public void testAutoSizeUniform_equivalentConfigurations() throws Throwable {
        final DisplayMetrics dm = mActivity.getResources().getDisplayMetrics();
        final int minTextSize = 10;
        final int maxTextSize = 20;
        final int granularity = 2;
        final int unit = TypedValue.COMPLEX_UNIT_SP;

        final TextView granularityTextView = new TextView(mActivity);
        granularityTextView.setAutoSizeTextTypeUniformWithConfiguration(
                minTextSize, maxTextSize, granularity, unit);

        final TextView presetTextView = new TextView(mActivity);
        presetTextView.setAutoSizeTextTypeUniformWithPresetSizes(
                new int[] {minTextSize, 12, 14, 16, 18, maxTextSize}, unit);

        // The TextViews have been configured differently but the end result should be nearly
        // identical.
        final int expectedAutoSizeType = TextView.AUTO_SIZE_TEXT_TYPE_UNIFORM;
        assertEquals(expectedAutoSizeType, granularityTextView.getAutoSizeTextType());
        assertEquals(expectedAutoSizeType, presetTextView.getAutoSizeTextType());

        final int expectedMinTextSizeInPx = Math.round(
                TypedValue.applyDimension(unit, minTextSize, dm));
        assertEquals(expectedMinTextSizeInPx, granularityTextView.getAutoSizeMinTextSize());
        assertEquals(expectedMinTextSizeInPx, presetTextView.getAutoSizeMinTextSize());

        final int expectedMaxTextSizeInPx = Math.round(
                TypedValue.applyDimension(unit, maxTextSize, dm));
        assertEquals(expectedMaxTextSizeInPx, granularityTextView.getAutoSizeMaxTextSize());
        assertEquals(expectedMaxTextSizeInPx, presetTextView.getAutoSizeMaxTextSize());

        // Configured with granularity.
        assertEquals(Math.round(TypedValue.applyDimension(unit, granularity, dm)),
                granularityTextView.getAutoSizeStepGranularity());
        // Configured with preset values, there is no granularity.
        assertEquals(-1, presetTextView.getAutoSizeStepGranularity());

        // Both TextViews generate exactly the same sizes in pixels to choose from when auto-sizing.
        assertArrayEquals(""Expected the granularity and preset configured auto-sized ""
                + ""TextViews to have identical available sizes for auto-sizing.""
                + ""\ngranularity sizes: ""
                + Arrays.toString(granularityTextView.getAutoSizeTextAvailableSizes())
                + ""\npreset sizes: ""
                + Arrays.toString(presetTextView.getAutoSizeTextAvailableSizes()),
                granularityTextView.getAutoSizeTextAvailableSizes(),
                presetTextView.getAutoSizeTextAvailableSizes());

        final String someText = ""This is a string"";
        final LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(
                200, 200);
        // Configure identically and attach to layout.
        mActivityRule.runOnUiThread(() -> {
            granularityTextView.setLayoutParams(layoutParams);
            presetTextView.setLayoutParams(layoutParams);

            LinearLayout ll = mActivity.findViewById(R.id.layout_textviewtest);
            ll.removeAllViews();
            ll.addView(granularityTextView);
            ll.addView(presetTextView);

            granularityTextView.setText(someText);
            presetTextView.setText(someText);
        });
        mInstrumentation.waitForIdleSync();

        assertEquals(granularityTextView.getTextSize(), presetTextView.getTextSize(), 0f);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testAutoSizeUniform_autoSizeCalledWhenTypeChanged"	"CtsWidgetTestCases"	"1: ui"	"public void testAutoSizeUniform_autoSizeCalledWhenTypeChanged() throws Throwable {
        mTextView = findTextView(R.id.textview_text);
        // Make sure we pick an already inflated non auto-sized text view.
        assertEquals(TextView.AUTO_SIZE_TEXT_TYPE_NONE, mTextView.getAutoSizeTextType());
        // Set the text size to a very low value in order to prepare for auto-size.
        final int customTextSize = 3;
        mActivityRule.runOnUiThread(() ->
                mTextView.setTextSize(TypedValue.COMPLEX_UNIT_PX, customTextSize));
        mInstrumentation.waitForIdleSync();
        assertEquals(customTextSize, mTextView.getTextSize(), 0f);
        mActivityRule.runOnUiThread(() ->
                mTextView.setAutoSizeTextTypeWithDefaults(TextView.AUTO_SIZE_TEXT_TYPE_UNIFORM));
        mInstrumentation.waitForIdleSync();
        // The size of the text should have changed.
        assertNotEquals(customTextSize, mTextView.getTextSize(), 0f);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSmartSelection"	"CtsWidgetTestCases"	"1: ui"	"public void testSmartSelection() throws Throwable {
        mTextView = findTextView(R.id.textview_text);
        String text = ""The president-elect, Filip, is coming to town tomorrow."";
        int startIndex = text.indexOf(""president"");
        int endIndex = startIndex + ""president"".length();
        initializeTextForSmartSelection(text);

        // Long-press for smart selection. Expect smart selection.
        Point offset = getCenterPositionOfTextAt(mTextView, startIndex, endIndex);
        emulateLongPressOnView(mTextView, offset.x, offset.y);
        PollingCheck.waitFor(() -> mTextView.getSelectionStart() == SMARTSELECT_START
                && mTextView.getSelectionEnd() == SMARTSELECT_END);
        // TODO: Test the floating toolbar content.
    }

    private boolean isWatch() {
        return (mActivity.getResources().getConfiguration().uiMode
                & Configuration.UI_MODE_TYPE_MASK) == Configuration.UI_MODE_TYPE_WATCH;
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testFontResourcesXml_restrictedContext"	"CtsWidgetTestCases"	"2: ui system"	"@MediumTest
    public void testFontResourcesXml_restrictedContext()
            throws PackageManager.NameNotFoundException {
        Context restrictedContext = mActivity.createPackageContext(mActivity.getPackageName(),
                Context.CONTEXT_RESTRICTED);
        LayoutInflater layoutInflater = (LayoutInflater) restrictedContext.getSystemService(
                Context.LAYOUT_INFLATER_SERVICE);
        View root = layoutInflater.inflate(R.layout.textview_restricted_layout, null);

        mTextView = root.findViewById(R.id.textview_fontresource_fontfamily);
        assertEquals(Typeface.DEFAULT, mTextView.getTypeface());
        mTextView = root.findViewById(R.id.textview_fontxmlresource_fontfamily);
        assertEquals(Typeface.DEFAULT, mTextView.getTypeface());
        mTextView = root.findViewById(R.id.textview_fontxmlresource_nonFontReference);
        assertEquals(Typeface.DEFAULT, mTextView.getTypeface());
        mTextView = root.findViewById(R.id.textview_fontresource_style);
        assertEquals(Typeface.DEFAULT, mTextView.getTypeface());
        mTextView = root.findViewById(R.id.textview_fontxmlresource_style);
        assertEquals(Typeface.DEFAULT, mTextView.getTypeface());
        mTextView = root.findViewById(R.id.textview_fontresource_textAppearance);
        assertEquals(Typeface.DEFAULT, mTextView.getTypeface());
        mTextView = root.findViewById(R.id.textview_fontxmlresource_textAppearance);
        assertEquals(Typeface.DEFAULT, mTextView.getTypeface());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testFallbackLineSpacing_readsFromLayoutXml"	"CtsWidgetTestCases"	"1: ui"	"public void testFallbackLineSpacing_readsFromLayoutXml() {
        mActivity.setContentView(R.layout.textview_fallbacklinespacing_layout);
        mTextView = findTextView(R.id.textview_true);
        assertTrue(mTextView.isFallbackLineSpacing());

        mTextView = findTextView(R.id.textview_default);
        assertTrue(mTextView.isFallbackLineSpacing());

        mTextView = findTextView(R.id.textview_false);
        assertFalse(mTextView.isFallbackLineSpacing());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testFallbackLineSpacing_set_get"	"CtsWidgetTestCases"	"1: ui"	"public void testFallbackLineSpacing_set_get() {
        mActivity.setContentView(R.layout.textview_fallbacklinespacing_layout);
        mTextView = findTextView(R.id.textview_true);
        assertTrue(mTextView.isFallbackLineSpacing());

        mTextView.setFallbackLineSpacing(false);
        assertFalse(mTextView.isFallbackLineSpacing());

        mTextView.setFallbackLineSpacing(true);
        assertTrue(mTextView.isFallbackLineSpacing());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testFallbackLineSpacing_readsFromStyleXml"	"CtsWidgetTestCases"	"1: ui"	"public void testFallbackLineSpacing_readsFromStyleXml() {
        mActivity.setContentView(R.layout.textview_fallbacklinespacing_layout);
        mTextView = findTextView(R.id.textview_style_true);
        assertTrue(mTextView.isFallbackLineSpacing());

        mTextView = findTextView(R.id.textview_style_default);
        assertTrue(mTextView.isFallbackLineSpacing());

        mTextView = findTextView(R.id.textview_style_false);
        assertFalse(mTextView.isFallbackLineSpacing());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testFallbackLineSpacing_textAppearance_set_get"	"CtsWidgetTestCases"	"1: ui"	"public void testFallbackLineSpacing_textAppearance_set_get() {
        mActivity.setContentView(R.layout.textview_fallbacklinespacing_layout);
        mTextView = findTextView(R.id.textview_default);
        assertTrue(mTextView.isFallbackLineSpacing());

        mTextView.setTextAppearance(R.style.TextAppearance_FallbackLineSpacingFalse);
        assertFalse(mTextView.isFallbackLineSpacing());

        mTextView.setTextAppearance(R.style.TextAppearance_FallbackLineSpacingTrue);
        assertTrue(mTextView.isFallbackLineSpacing());

        mTextView.setFallbackLineSpacing(false);
        mTextView.setTextAppearance(R.style.TextAppearance);
        assertFalse(mTextView.isFallbackLineSpacing());

        mTextView.setFallbackLineSpacing(true);
        mTextView.setTextAppearance(R.style.TextAppearance);
        assertTrue(mTextView.isFallbackLineSpacing());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"measureConsistency"	"CtsWidgetTestCases"	"2: ui system"	"public void measureConsistency() {
        String text = ""12\n34"";
        TextView textView = new TextView(mActivity);
        textView.setTextSize(TypedValue.COMPLEX_UNIT_PX, 100);
        textView.setText(text);

        int width = (int) Math.ceil(Layout.getDesiredWidth(text, textView.getPaint()));
        int height = StaticLayout.Builder.obtain(text, 0, text.length(),
                textView.getPaint(), width).build().getHeight();
        // Reserve enough width for the text.
        int wMeasureSpec = View.MeasureSpec.makeMeasureSpec(width * 2, View.MeasureSpec.AT_MOST);
        int hMeasureSpec = View.MeasureSpec.makeMeasureSpec(height * 2, View.MeasureSpec.AT_MOST);

        textView.measure(wMeasureSpec, hMeasureSpec);
        int measuredWidth = textView.getMeasuredWidth();

        textView.measure(wMeasureSpec, hMeasureSpec);
        assertEquals(measuredWidth, textView.getMeasuredWidth());
    }

    private void initializeTextForSmartSelection(CharSequence text) throws Throwable {
        assertTrue(text.length() >= SMARTSELECT_END);
        mActivityRule.runOnUiThread(() -> {
            // Support small devices. b/155842369
            mTextView.setTextSize(TypedValue.COMPLEX_UNIT_PX, 20);
            mTextView.setTextIsSelectable(true);
            mTextView.setText(text);
            mTextView.setTextClassifier(FAKE_TEXT_CLASSIFIER);
            mTextView.requestFocus();
        });
        mInstrumentation.waitForIdleSync();
    }

    private void emulateClickOnView(View view, int offsetX, int offsetY) {
        CtsTouchUtils.emulateTapOnView(mInstrumentation, mActivityRule, view, offsetX, offsetY);
        SystemClock.sleep(CLICK_TIMEOUT);
    }

    private void emulateLongPressOnView(View view, int offsetX, int offsetY) {
        CtsTouchUtils.emulateLongPressOnView(mInstrumentation, mActivityRule, view,
                offsetX, offsetY);
        // TODO: Ideally, we shouldn't have to wait for a click timeout after a long-press but it
        // seems like we have a minor bug (call it inconvenience) in TextView that requires this.
        SystemClock.sleep(CLICK_TIMEOUT);
    }

    /**
     * Some TextView attributes require non-fixed width and/or layout height. This function removes
     * all other existing views from the layout leaving only one auto-size TextView (for exercising
     * the auto-size behavior) which has been set up to suit the test needs.
     *
     * @param viewId The id of the view to prepare.
     * @param shouldWrapLayoutContent Specifies if the layout params should wrap content
     *
     * @return a TextView configured for auto size tests.
     */
    private TextView prepareAndRetrieveAutoSizeTestData(final int viewId,
            final boolean shouldWrapLayoutContent) throws Throwable {
        mActivityRule.runOnUiThread(() -> {
            LinearLayout ll = (LinearLayout) mActivity.findViewById(R.id.layout_textviewtest);
            TextView targetedTextView = (TextView) mActivity.findViewById(viewId);
            ll.removeAllViews();
            ll.addView(targetedTextView);
        });
        mInstrumentation.waitForIdleSync();

        final TextView textView = (TextView) mActivity.findViewById(viewId);
        if (shouldWrapLayoutContent) {
            // Do not force exact width or height.
            final LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.WRAP_CONTENT,
                    LinearLayout.LayoutParams.WRAP_CONTENT);
            mActivityRule.runOnUiThread(() -> {
                textView.setLayoutParams(layoutParams);
            });
            mInstrumentation.waitForIdleSync();
        }

        return textView;
    }

    /**
     * Removes all existing views from the layout and adds a basic TextView (for exercising the
     * ClickableSpan onClick() behavior) in order to prevent scrolling. Adds a ClickableSpan to the
     * TextView and returns the ClickableSpan and position details about it to be used in individual
     * tests.
     */
    private ClickableSpanTestDetails prepareAndRetrieveClickableSpanDetails() throws Throwable {
        mActivityRule.runOnUiThread(() -> {
            LinearLayout ll = (LinearLayout) mActivity.findViewById(R.id.layout_textviewtest);
            ll.removeAllViews();
            mTextView = new TextView(mActivity);
            ll.addView(mTextView);
        });
        mInstrumentation.waitForIdleSync();

        ClickableSpan mockTextLink = mock(ClickableSpan.class);
        StringBuilder textViewContent = new StringBuilder();
        String clickableString = ""clickMe!"";
        textViewContent.append(clickableString);
        final int startPos = 0;

        // Insert more characters to make some room for swiping.
        for (int i = 0; i < 200; i++) {
            textViewContent.append("" text"");
        }
        SpannableString spannableString = new SpannableString(textViewContent);
        final int endPos = clickableString.length();
        spannableString.setSpan(mockTextLink, startPos, endPos, 0);
        mActivityRule.runOnUiThread(() -> {
            mTextView.setText(spannableString);
            mTextView.setMovementMethod(LinkMovementMethod.getInstance());
        });
        mInstrumentation.waitForIdleSync();

        return new ClickableSpanTestDetails(mockTextLink, mTextView, startPos, endPos);
    }

    private static final class ClickableSpanTestDetails {
        ClickableSpan mClickableSpan;
        int mXPosInside;
        int mYPosInside;
        int mXPosOutside;
        int mYPosOutside;

        private int mStartCharPos;
        private int mEndCharPos;
        private TextView mParent;

        ClickableSpanTestDetails(ClickableSpan clickableSpan, TextView parent,
                int startCharPos, int endCharPos) {
            mClickableSpan = clickableSpan;
            mParent = parent;
            mStartCharPos = startCharPos;
            mEndCharPos = endCharPos;

            calculatePositions();
        }

        private void calculatePositions() {
            int xStart = (int) mParent.getLayout().getPrimaryHorizontal(mStartCharPos, true);
            int xEnd = (int) mParent.getLayout().getPrimaryHorizontal(mEndCharPos, true);
            int line = mParent.getLayout().getLineForOffset(mEndCharPos);
            int yTop = mParent.getLayout().getLineTop(line);
            int yBottom = mParent.getLayout().getLineBottom(line);

            mXPosInside = (xStart + xEnd) / 2;
            mYPosInside = (yTop + yBottom) / 2;
            mXPosOutside = xEnd + 1;
            mYPosOutside = yBottom + 1;
        }
    }

    private MotionEvent createMouseHoverEvent(View view) {
        final int[] xy = new int[2];
        view.getLocationOnScreen(xy);
        final int viewWidth = view.getWidth();
        final int viewHeight = view.getHeight();
        float x = xy[0] + viewWidth / 2.0f;
        float y = xy[1] + viewHeight / 2.0f;
        long eventTime = SystemClock.uptimeMillis();
        MotionEvent.PointerCoords[] pointerCoords = new MotionEvent.PointerCoords[1];
        pointerCoords[0] = new MotionEvent.PointerCoords();
        pointerCoords[0].x = x;
        pointerCoords[0].y = y;
        final int[] pointerIds = new int[1];
        pointerIds[0] = 0;
        return MotionEvent.obtain(0, eventTime, MotionEvent.ACTION_HOVER_MOVE, 1, pointerIds,
                pointerCoords, 0, 0, 0, 0, 0, InputDevice.SOURCE_MOUSE, 0);
    }

    private void layout(final TextView textView) throws Throwable {
        mActivityRule.runOnUiThread(() -> mActivity.setContentView(textView));
        mInstrumentation.waitForIdleSync();
    }

    private void layout(final int layoutId) throws Throwable {
        mActivityRule.runOnUiThread(() -> mActivity.setContentView(layoutId));
        mInstrumentation.waitForIdleSync();
    }

    private TextView findTextView(int id) {
        return (TextView) mActivity.findViewById(id);
    }

    private int getAutoLinkMask(int id) {
        return findTextView(id).getAutoLinkMask();
    }

    private void setMaxLines(final int lines) throws Throwable {
        mActivityRule.runOnUiThread(() -> mTextView.setMaxLines(lines));
        mInstrumentation.waitForIdleSync();
    }

    private void setMaxWidth(final int pixels) throws Throwable {
        mActivityRule.runOnUiThread(() -> mTextView.setMaxWidth(pixels));
        mInstrumentation.waitForIdleSync();
    }

    private void setMinWidth(final int pixels) throws Throwable {
        mActivityRule.runOnUiThread(() -> mTextView.setMinWidth(pixels));
        mInstrumentation.waitForIdleSync();
    }

    private void setMaxHeight(final int pixels) throws Throwable {
        mActivityRule.runOnUiThread(() -> mTextView.setMaxHeight(pixels));
        mInstrumentation.waitForIdleSync();
    }

    private void setMinHeight(final int pixels) throws Throwable {
        mActivityRule.runOnUiThread(() -> mTextView.setMinHeight(pixels));
        mInstrumentation.waitForIdleSync();
    }

    private void setMinLines(final int minLines) throws Throwable {
        mActivityRule.runOnUiThread(() -> mTextView.setMinLines(minLines));
        mInstrumentation.waitForIdleSync();
    }

    /**
     * Convenience for {@link TextView#setText(CharSequence, BufferType)}. And
     * the buffer type is fixed to SPANNABLE.
     *
     * @param tv the text view
     * @param content the content
     */
    private void setSpannableText(final TextView tv, final String content) throws Throwable {
        mActivityRule.runOnUiThread(() -> tv.setText(content, BufferType.SPANNABLE));
        mInstrumentation.waitForIdleSync();
    }

    private void setLines(final int lines) throws Throwable {
        mActivityRule.runOnUiThread(() -> mTextView.setLines(lines));
        mInstrumentation.waitForIdleSync();
    }

    private void setHorizontallyScrolling(final boolean whether) throws Throwable {
        mActivityRule.runOnUiThread(() -> mTextView.setHorizontallyScrolling(whether));
        mInstrumentation.waitForIdleSync();
    }

    private void setWidth(final int pixels) throws Throwable {
        mActivityRule.runOnUiThread(() -> mTextView.setWidth(pixels));
        mInstrumentation.waitForIdleSync();
    }

    private void setHeight(final int pixels) throws Throwable {
        mActivityRule.runOnUiThread(() -> mTextView.setHeight(pixels));
        mInstrumentation.waitForIdleSync();
    }

    private void setMinEms(final int ems) throws Throwable {
        mActivityRule.runOnUiThread(() -> mTextView.setMinEms(ems));
        mInstrumentation.waitForIdleSync();
    }

    private void setMaxEms(final int ems) throws Throwable {
        mActivityRule.runOnUiThread(() -> mTextView.setMaxEms(ems));
        mInstrumentation.waitForIdleSync();
    }

    private void setEms(final int ems) throws Throwable {
        mActivityRule.runOnUiThread(() -> mTextView.setEms(ems));
        mInstrumentation.waitForIdleSync();
    }

    private void setLineSpacing(final float add, final float mult) throws Throwable {
        mActivityRule.runOnUiThread(() -> mTextView.setLineSpacing(add, mult));
        mInstrumentation.waitForIdleSync();
    }

    /**
     * Returns the x, y coordinates of text at a specified indices relative to the position of the
     * TextView.
     *
     * @param textView
     * @param startIndex start index of the text in the textView
     * @param endIndex end index of the text in the textView
     */
    private static Point getCenterPositionOfTextAt(
            TextView textView, int startIndex, int endIndex) {
        int xStart = (int) textView.getLayout().getPrimaryHorizontal(startIndex, true);
        int xEnd = (int) textView.getLayout().getPrimaryHorizontal(endIndex, true);
        int line = textView.getLayout().getLineForOffset(endIndex);
        int yTop = textView.getLayout().getLineTop(line);
        int yBottom = textView.getLayout().getLineBottom(line);

        return new Point((xStart + xEnd) / 2 /* x */, (yTop + yBottom) / 2 /* y */);
    }

    private static abstract class TestSelectedRunnable implements Runnable {
        private TextView mTextView;
        private boolean mIsSelected1;
        private boolean mIsSelected2;

        public TestSelectedRunnable(TextView textview) {
            mTextView = textview;
        }

        public boolean getIsSelected1() {
            return mIsSelected1;
        }

        public boolean getIsSelected2() {
            return mIsSelected2;
        }

        public void saveIsSelected1() {
            mIsSelected1 = mTextView.isSelected();
        }

        public void saveIsSelected2() {
            mIsSelected2 = mTextView.isSelected();
        }
    }

    private static abstract class TestLayoutRunnable implements Runnable {
        private TextView mTextView;
        private Layout mLayout;

        public TestLayoutRunnable(TextView textview) {
            mTextView = textview;
        }

        public Layout getLayout() {
            return mLayout;
        }

        public void saveLayout() {
            mLayout = mTextView.getLayout();
        }
    }

    private static class MockTextWatcher implements TextWatcher {
        private boolean mHasCalledAfterTextChanged;
        private boolean mHasCalledBeforeTextChanged;
        private boolean mHasOnTextChanged;

        public void reset(){
            mHasCalledAfterTextChanged = false;
            mHasCalledBeforeTextChanged = false;
            mHasOnTextChanged = false;
        }

        public boolean hasCalledAfterTextChanged() {
            return mHasCalledAfterTextChanged;
        }

        public boolean hasCalledBeforeTextChanged() {
            return mHasCalledBeforeTextChanged;
        }

        public boolean hasCalledOnTextChanged() {
            return mHasOnTextChanged;
        }

        public void afterTextChanged(Editable s) {
            mHasCalledAfterTextChanged = true;
        }

        public void beforeTextChanged(CharSequence s, int start, int count, int after) {
            mHasCalledBeforeTextChanged = true;
        }

        public void onTextChanged(CharSequence s, int start, int before, int count) {
            mHasOnTextChanged = true;
        }
    }

    /**
     * A TextWatcher that converts the text to spaces whenever the text changes.
     */
    private static class ConvertToSpacesTextWatcher implements TextWatcher {
        boolean mChangingText;

        @Override
        public void beforeTextChanged(CharSequence s, int start, int count, int after) {
        }

        @Override
        public void onTextChanged(CharSequence s, int start, int before, int count) {
        }

        @Override
        public void afterTextChanged(Editable s) {
            // Avoid infinite recursion.
            if (mChangingText) {
                return;
            }
            mChangingText = true;
            // Create a string of s.length() spaces.
            StringBuilder builder = new StringBuilder(s.length());
            for (int i = 0; i < s.length(); i++) {
                builder.append(' ');
            }
            s.replace(0, s.length(), builder.toString());
            mChangingText = false;
        }
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextViewTest"	"testSetOnEditorActionListener"	"CtsWidgetTestCases"	"1: interaction"	"public void testSetOnEditorActionListener() {
        mTextView = findTextView(R.id.textview_text);

        final TextView.OnEditorActionListener mockOnEditorActionListener =
                mock(TextView.OnEditorActionListener.class);
        verifyZeroInteractions(mockOnEditorActionListener);

        mTextView.setOnEditorActionListener(mockOnEditorActionListener);
        verifyZeroInteractions(mockOnEditorActionListener);

        mTextView.onEditorAction(EditorInfo.IME_ACTION_DONE);
        verify(mockOnEditorActionListener, times(1)).onEditorAction(mTextView,
                EditorInfo.IME_ACTION_DONE, null);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.inline.InlineContentViewTest"	"testSetZOrderedOnTop"	"CtsWidgetTestCases"	"1: ui"	"public void testSetZOrderedOnTop() {
        mInlineContentView.setZOrderedOnTop(false);

        assertThat(mInlineContentView.isZOrderedOnTop()).isFalse();

        mInlineContentView.setZOrderedOnTop(true);

        assertThat(mInlineContentView.isZOrderedOnTop()).isTrue();
    }

    private void attachInlineContentView() {
        final ViewGroup viewGroup = (ViewGroup) mActivity.findViewById(R.id.inlinecontentview);
        try {
            mActivityRule.runOnUiThread(
                    () -> viewGroup.addView(mInlineContentView, new ViewGroup.LayoutParams(
                            ViewGroup.LayoutParams.MATCH_PARENT,
                            ViewGroup.LayoutParams.WRAP_CONTENT)));
            mInstrumentation.waitForIdleSync();
        } catch (Throwable e) {
            Log.e(LOG_TAG, ""attachInlineContentView fail"");
        }
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/inline/InlineContentViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.graphics.fonts.DataDirPermissionTest"	"testDataFontDirPermission"	"CtsGraphicsTestCases"	"1: direct"	"public void testDataFontDirPermission() {
        File file = new File(FONT_DATA_DIR);
        assertThat(file.isDirectory()).isTrue();
        assertThat(file.canRead()).isFalse();
        assertThat(file.canWrite()).isFalse();
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/fonts/DataDirPermissionTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.graphics.fonts.DataDirPermissionTest"	"testDataFontFilesDirPermission"	"CtsGraphicsTestCases"	"1: direct"	"public void testDataFontFilesDirPermission() {
        File file = new File(FONT_DATA_FILES_DIR);
        assertThat(file.isDirectory()).isTrue();
        assertThat(file.canRead()).isFalse();
        assertThat(file.canWrite()).isFalse();
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/fonts/DataDirPermissionTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.security.cts.CertBlacklistTest"	"testBlacklistedRootOfTrust"	"CtsSecurityTestCases"	"1: ui"	"public void testBlacklistedRootOfTrust() throws Exception {
        // Chain is leaf -> blacklisted
        X509Certificate[] chain = loadCertificates(BLACKLISTED_CHAIN);
        X509Certificate blacklistedCa = loadCertificate(BLACKLIST_CA);
        assertUntrusted(chain, getTrustManager(blacklistedCa));
    }

    /**
     * Tests that the path building correctly routes around a blacklisted cert where there are
     * other valid paths available. This prevents breakage where a cert was cross signed by a
     * blacklisted CA but is still valid due to also being cross signed by CAs that remain trusted.
     * Path:
     *
     * leaf -> intermediate -> blacklisted_ca
     *               \
     *                -------> trusted_ca
     */"	"/home/gpoor/cts-12-source/cts/tests/tests/security/src/android/security/cts/CertBlacklistTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.jobscheduler.cts.TriggerContentTest"	"exists"	"CtsJobSchedulerTestCases"	"2: direct ui"	"public void test/*
 *.
 */

package android.jobscheduler.cts;

import android.annotation.TargetApi;
import android.app.job.JobInfo;
import android.app.job.JobParameters;
import android.content.ContentResolver;
import android.content.Context;
import android.jobscheduler.DummyJobContentProvider;
import android.jobscheduler.TriggerContentJobService;
import android.media.MediaScannerConnection;
import android.net.Uri;
import android.os.Environment;
import android.os.Process;
import android.provider.MediaStore;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * Schedules jobs that look for content URI changes and ensures they are triggered correctly.
 */
@TargetApi(23)
public class TriggerContentTest extends BaseJobSchedulerTest {
    public static final int TRIGGER_CONTENT_JOB_ID = TriggerContentTest.class.hashCode();

    // The root URI of the media provider, to monitor for generic changes to its content.
    static final Uri MEDIA_URI = Uri.parse(""content://"" + MediaStore.AUTHORITY + ""/"");

    // Media URI for all external media content.
    static final Uri MEDIA_EXTERNAL_URI = Uri.parse(""content://"" + MediaStore.AUTHORITY
            + ""/external"");

    // Path segments for image-specific URIs in the provider.
    static final List<String> EXTERNAL_PATH_SEGMENTS
            = MediaStore.Images.Media.EXTERNAL_CONTENT_URI.getPathSegments();

    // This is the external storage directory where cameras place pictures.
    static final String DCIM_DIR = Environment.getExternalStoragePublicDirectory(
            Environment.DIRECTORY_DCIM).getPath();

    static final String PIC_1_NAME = ""TriggerContentTest1_"" + Process.myPid();
    static final String PIC_2_NAME = ""TriggerContentTest2_"" + Process.myPid();

    File[] mActiveFiles = new File[5];
    Uri[] mActiveUris = new Uri[5];

    static class MediaScanner implements MediaScannerConnection.OnScanCompletedListener {
        private static final long DEFAULT_TIMEOUT_MILLIS = 1000L; // 1 second.

        private CountDownLatch mLatch;
        private String mScannedPath;
        private Uri mScannedUri;

        public boolean scan(Context context, String file, String mimeType)
                throws InterruptedException {
            mLatch = new CountDownLatch(1);
            MediaScannerConnection.scanFile(context,
                    new String[] { file.toString() }, new String[] { mimeType }, this);
            return mLatch.await(DEFAULT_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
        }

        public String getScannedPath() {
            synchronized (this) {
                return mScannedPath;
            }
        }

        public Uri getScannedUri() {
            synchronized (this) {
                return mScannedUri;
            }
        }

        @Override public void onScanCompleted(String path, Uri uri) {
            synchronized (this) {
                mScannedPath = path;
                mScannedUri = uri;
                mLatch.countDown();
            }
        }
    }

    private void cleanupActive(int which) {
        if (mActiveUris[which] != null) {
            getContext().getContentResolver().delete(mActiveUris[which], null, null);
            mActiveUris[which] = null;
        }
        if (mActiveFiles[which] != null) {
            mActiveFiles[which].delete();
            mActiveFiles[which] = null;
        }
    }

    @Override
    public void tearDown() throws Exception {
        for (int i=0; i<mActiveFiles.length; i++) {
            cleanupActive(i);
        }
        super.tearDown();
    }

    private JobInfo makeJobInfo(Uri uri, int flags) {
        JobInfo.Builder builder = new JobInfo.Builder(TRIGGER_CONTENT_JOB_ID,
                kTriggerContentServiceComponent);
        builder.addTriggerContentUri(new JobInfo.TriggerContentUri(uri, flags));
        // For testing purposes, react quickly.
        builder.setTriggerContentUpdateDelay(500);
        builder.setTriggerContentMaxDelay(500);
        return builder.build();
    }

    private JobInfo makePhotosJobInfo() {
        JobInfo.Builder builder = new JobInfo.Builder(TRIGGER_CONTENT_JOB_ID,
                kTriggerContentServiceComponent);
        // Look for general reports of changes in the overall provider.
        builder.addTriggerContentUri(new JobInfo.TriggerContentUri(
                MEDIA_URI,
                JobInfo.TriggerContentUri.FLAG_NOTIFY_FOR_DESCENDANTS));
        // For testing purposes, react quickly.
        builder.setTriggerContentUpdateDelay(500);
        builder.setTriggerContentMaxDelay(500);
        return builder.build();
    }

    public static void copyToFileOrThrow(InputStream inputStream, File destFile)
            throws IOException {
        if (destFile.exists()) {
            destFile.delete();
        }
        destFile.getParentFile().mkdirs();
        FileOutputStream out = new FileOutputStream(destFile);
        try {
            byte[] buffer = new byte[4096];
            int bytesRead;
            while ((bytesRead = inputStream.read(buffer)) >= 0) {
                out.write(buffer, 0, bytesRead);
            }
        } finally {
            out.flush();
            try {
                out.getFD().sync();
            } catch (IOException e) {
            }
            out.close();
            inputStream.close();
        }
    }

    public Uri createAndAddImage(File destFile, InputStream image) throws IOException,
            InterruptedException {
        copyToFileOrThrow(image, destFile);
        MediaScanner scanner = new MediaScanner();
        boolean success = scanner.scan(getContext(), destFile.toString(), ""image/jpeg"");
        if (success) {
            return scanner.getScannedUri();
        }
        return null;
    }

    public Uri makeActiveFile(int which, File file, InputStream source) throws IOException,
                InterruptedException {
        mActiveFiles[which] = file;
        mActiveUris[which] = createAndAddImage(file, source);
        return mActiveUris[which];
    }

    private static void assertUriArrayLength(int length, Uri[] uris) {
        if (uris.length != length) {
            StringBuilder sb = new StringBuilder();
            sb.append(""Expected "");
            sb.append(length);
            sb.append("" URI, got "");
            sb.append(uris.length);
            if (uris.length > 0) {
                sb.append("": "");
                for (int i=0; i<uris.length; i++) {
                    if (i > 0) {
                        sb.append("", "");
                    }
                    sb.append(uris[i]);
                }
            }
            fail(sb.toString());
        }
    }

    private static void assertHasUri(Uri wanted, Uri[] uris) {
        for (int i=0; i<uris.length; i++) {
            if (wanted.equals(uris[i])) {
                return;
            }
        }

        StringBuilder sb = new StringBuilder();
        sb.append(""Don't have uri "");
        sb.append(wanted);
        sb.append("" in: "");
        for (int i=0; i<uris.length; i++) {
            if (i > 0) {
                sb.append("", "");
            }
            sb.append(uris[i]);
        }
        fail(sb.toString());
    }

    private static void assertUriDecendant(Uri expected, Uri actual) {
        assertEquals(expected.getScheme(), expected.getScheme());
        assertEquals(expected.getAuthority(), expected.getAuthority());

        final List<String> expectedPath = expected.getPathSegments();
        final List<String> actualPath = actual.getPathSegments();
        for (int i = 0; i < expectedPath.size(); i++) {
            assertEquals(expectedPath.get(i), actualPath.get(i));
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/JobScheduler/src/android/jobscheduler/cts/TriggerContentTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.net.vcn.cts.VcnGatewayConnectionConfigTest"	"testBuildVcnGatewayConnectionConfig"	"CtsVcnTestCases"	"1: ui"	"public void testBuildVcnGatewayConnectionConfig() throws Exception {
        final VcnGatewayConnectionConfig gatewayConnConfig = buildVcnGatewayConnectionConfig();

        assertEquals(VCN_GATEWAY_CONNECTION_NAME, gatewayConnConfig.getGatewayConnectionName());
        assertEquals(buildTunnelConnectionParams(), gatewayConnConfig.getTunnelConnectionParams());
        assertArrayEquals(
                new int[] {NET_CAPABILITY_INTERNET}, gatewayConnConfig.getExposedCapabilities());
        assertArrayEquals(RETRY_INTERNAL_MILLIS, gatewayConnConfig.getRetryIntervalsMillis());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/vcn/src/android/net/vcn/cts/VcnGatewayConnectionConfigTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.net.vcn.cts.VcnGatewayConnectionConfigTest"	"testBuilderAddRemove"	"CtsVcnTestCases"	"1: ui"	"public void testBuilderAddRemove() throws Exception {
        final VcnGatewayConnectionConfig gatewayConnConfig =
                buildVcnGatewayConnectionConfigBase()
                        .addExposedCapability(NET_CAPABILITY_DUN)
                        .removeExposedCapability(NET_CAPABILITY_DUN)
                        .build();

        assertArrayEquals(
                new int[] {NET_CAPABILITY_INTERNET}, gatewayConnConfig.getExposedCapabilities());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/vcn/src/android/net/vcn/cts/VcnGatewayConnectionConfigTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.net.vcn.cts.VcnGatewayConnectionConfigTest"	"testBuildWithoutMobikeEnabled"	"CtsVcnTestCases"	"1: ui"	"public void testBuildWithoutMobikeEnabled() {
        final IkeSessionParams ikeParams =
                getIkeSessionParamsBase().removeIkeOption(IKE_OPTION_MOBIKE).build();
        final IkeTunnelConnectionParams tunnelParams = buildTunnelConnectionParams(ikeParams);

        try {
            new VcnGatewayConnectionConfig.Builder(VCN_GATEWAY_CONNECTION_NAME, tunnelParams);
            fail(""Expected exception if MOBIKE not configured"");
        } catch (IllegalArgumentException e) {
        }
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/vcn/src/android/net/vcn/cts/VcnGatewayConnectionConfigTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.verifier.audio.USBAudioPeripheralAttributesActivity"	"setPassFailButtonClickListeners"	""	"1: ui"	"public void test/*
 *.
 */

package com.android.cts.verifier.audio;

import android.content.Context;
import android.media.AudioDeviceInfo;
import android.os.Bundle;
import android.util.Log;
import android.widget.TextView;

import com.android.cts.verifier.audio.peripheralprofile.ListsHelper;
import com.android.cts.verifier.audio.peripheralprofile.PeripheralProfile;

import com.android.cts.verifier.R;  // needed to access resource in CTSVerifier project namespace.

public class USBAudioPeripheralAttributesActivity extends USBAudioPeripheralActivity {
    private static final String TAG = ""USBAudioPeripheralAttributesActivity"";

    private TextView mTestStatusTx;

    public USBAudioPeripheralAttributesActivity() {
        super(true); // Mandated peripheral is required
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.uap_attribs_panel);

        connectPeripheralStatusWidgets();

        mTestStatusTx = (TextView)findViewById(R.id.uap_attribsStatusTx);

        setPassFailButtonClickListeners();
        setInfoResources(R.string.usbaudio_attribs_test, R.string.usbaudio_attribs_info, -1);

        connectUSBPeripheralUI();
    }

    //
    // USBAudioPeripheralActivity
    //
    public void updateConnectStatus() {
        boolean outPass = false;
        boolean inPass = false;
        if (mIsPeripheralAttached && mSelectedProfile != null) {
            boolean match = true;
            StringBuilder metaSb = new StringBuilder();

            // Outputs
            if (mOutputDevInfo != null) {
                AudioDeviceInfo deviceInfo = mOutputDevInfo;
                PeripheralProfile.ProfileAttributes attribs =
                    mSelectedProfile.getOutputAttributes();
                StringBuilder sb = new StringBuilder();

                // Channel Counts
                if (deviceInfo.getChannelCounts().length == 0) {
                    sb.append(""Output - No Peripheral Channel Counts\n"");
                } else if (!ListsHelper.isSubset(deviceInfo.getChannelCounts(), attribs.mChannelCounts)) {
                    sb.append(""Output - Channel Counts Mismatch"" +
                            "" d"" + ListsHelper.textFormatDecimal(deviceInfo.getChannelCounts()) +
                            "" p"" + ListsHelper.textFormatDecimal(attribs.mChannelCounts) +""\n"");
                }

                // Encodings
                if (deviceInfo.getEncodings().length == 0) {
                    sb.append(""Output - No Peripheral Encodings\n"");
                } else if (!ListsHelper.isSubset(deviceInfo.getEncodings(), attribs.mEncodings)) {
                    sb.append(""Output - Encodings Mismatch"" +
                            "" d"" + ListsHelper.textFormatHex(deviceInfo.getEncodings()) +
                            "" p"" + ListsHelper.textFormatHex(attribs.mEncodings) + ""\n"");
                }

                // Sample Rates
                if (deviceInfo.getSampleRates().length == 0) {
                    sb.append(""Output - No Peripheral Sample Rates\n"");
                } else if (!ListsHelper.isSubset(deviceInfo.getSampleRates(), attribs.mSampleRates)) {
                    sb.append(""Output - Sample Rates Mismatch"" +
                            "" d"" + ListsHelper.textFormatHex(deviceInfo.getSampleRates()) +
                            "" p"" + ListsHelper.textFormatHex(attribs.mSampleRates) + ""\n"");
                }

                // Channel Masks
                if (deviceInfo.getChannelIndexMasks().length == 0 &&
                    deviceInfo.getChannelMasks().length == 0) {
                    sb.append(""Output - No Peripheral Channel Masks\n"");
                } else {
                    // Channel Index Masks
                    if (!ListsHelper.isSubset(deviceInfo.getChannelIndexMasks(),
                            attribs.mChannelIndexMasks)) {
                        sb.append(""Output - Channel Index Masks Mismatch"" +
                                "" d"" + ListsHelper.textFormatHex(deviceInfo.getChannelIndexMasks()) +
                                "" p"" + ListsHelper.textFormatHex(attribs.mChannelIndexMasks) + ""\n"");
                    }

                    // Channel Position Masks
                    if (!ListsHelper.isSubset(deviceInfo.getChannelMasks(),
                            attribs.mChannelPositionMasks)) {
                        sb.append(""Output - Channel Position Masks Mismatch"" +
                                "" d"" + ListsHelper.textFormatHex(deviceInfo.getChannelMasks()) +
                                "" p"" + ListsHelper.textFormatHex(attribs.mChannelPositionMasks) + ""\n"");
                    }
                }

                // Report
                if (sb.toString().length() == 0){
                    metaSb.append(""Output - Match\n"");
                    outPass = true;
                } else {
                    metaSb.append(sb.toString());
                }
            } else {
                // No output device to test, so pass it.
                outPass = true;
            }

            // Inputs
            if (mInputDevInfo != null) {
                AudioDeviceInfo deviceInfo = mInputDevInfo;
                PeripheralProfile.ProfileAttributes attribs =
                    mSelectedProfile.getInputAttributes();
                StringBuilder sb = new StringBuilder();

                // Channel Counts
                if (deviceInfo.getChannelCounts().length == 0) {
                    sb.append(""Input - No Peripheral Channel Counts\n"");
                } else if (!ListsHelper.isSubset(deviceInfo.getChannelCounts(), attribs.mChannelCounts)) {
                    sb.append(""Input - Channel Counts Mismatch"" +
                            "" d"" + ListsHelper.textFormatDecimal(deviceInfo.getChannelCounts()) +
                            "" p"" + ListsHelper.textFormatDecimal(attribs.mChannelCounts) + ""\n"");
                }

                // Encodings
                if (deviceInfo.getEncodings().length == 0) {
                    sb.append(""Input - No Peripheral Encodings\n"");
                } else if (!ListsHelper.isSubset(deviceInfo.getEncodings(), attribs.mEncodings)) {
                    sb.append(""Input - Encodings Mismatch"" +
                            "" d"" + ListsHelper.textFormatHex(deviceInfo.getEncodings()) +
                            "" p"" + ListsHelper.textFormatHex(attribs.mEncodings) + ""\n"");
                }

                // Sample Rates
                if (deviceInfo.getSampleRates().length == 0) {
                    sb.append(""Input - No Peripheral Sample Rates\n"");
                } else if (!ListsHelper.isSubset(deviceInfo.getSampleRates(), attribs.mSampleRates)) {
                    sb.append(""Input - Sample Rates Mismatch"" +
                            "" d"" + ListsHelper.textFormatDecimal(deviceInfo.getSampleRates()) +
                            "" p"" + ListsHelper.textFormatDecimal(attribs.mSampleRates) + ""\n"");
                }

                // Channel Masks
                if (deviceInfo.getChannelIndexMasks().length == 0 &&
                        deviceInfo.getChannelMasks().length == 0) {
                    sb.append(""Input - No Peripheral Channel Masks\n"");
                } else {
                    if (!ListsHelper.isSubset(deviceInfo.getChannelIndexMasks(),
                            attribs.mChannelIndexMasks)) {
                        sb.append(""Input - Channel Index Masks Mismatch"" +
                                "" d"" + ListsHelper.textFormatHex(deviceInfo.getChannelIndexMasks()) +
                                "" p"" + ListsHelper.textFormatHex(attribs.mChannelIndexMasks) + ""\n"");
                    }
                    if (!ListsHelper.isSubset(deviceInfo.getChannelMasks(),
                            attribs.mChannelPositionMasks)) {
                        sb.append(""Input - Channel Position Masks Mismatch"" +
                                "" d"" + ListsHelper.textFormatHex(deviceInfo.getChannelMasks()) +
                                "" p"" + ListsHelper.textFormatHex(attribs.mChannelPositionMasks) + ""\n"");
                    }
                }
                if (sb.toString().length() == 0){
                    metaSb.append(""Input - Match\n"");
                    inPass = true;
                } else {
                    metaSb.append(sb.toString());
                }
            } else {
                // No input device, so pass it.
                inPass = true;
            }

            mTestStatusTx.setText(metaSb.toString());
        } else {
            mTestStatusTx.setText(""No Peripheral or No Matching Profile."");
        }

        // Headset not publicly available, violates CTS Verifier additional equipment guidelines.
        getPassButton().setEnabled(outPass && inPass);
    }
}"	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/audio/USBAudioPeripheralAttributesActivity.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.permission.cts.ProviderPermissionTest"	"testWriteCallLog"	"CtsPermissionTestCases"	"2: apps ui"	"public void testWriteCallLog() {
        assertWritingContentUriRequiresPermission(CallLog.CONTENT_URI,
                android.Manifest.permission.WRITE_CALL_LOG);
    }

    /**
     * Verify that reading from call-log (a content provider that is not accessible to instant apps)
     * returns null
     */
    @AppModeInstant"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ProviderPermissionTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.permission.cts.ProviderPermissionTest"	"testReadCallLogInstant"	"CtsPermissionTestCases"	"1: apps"	"public void testReadCallLogInstant() {
        assertNull(getContext().getContentResolver().query(CallLog.CONTENT_URI, null, null, null,
                null));
    }

    /**
     * Verify that writing to call-log (a content provider that is not accessible to instant apps)
     * yields an IAE.
     */
    @AppModeInstant"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ProviderPermissionTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.permission.cts.ProviderPermissionTest"	"testReadSms"	"CtsPermissionTestCases"	"3: apps ui system"	"public void testReadSms() {
        if (!mContext.getPackageManager().hasSystemFeature(
                PackageManager.FEATURE_TELEPHONY)) {
            return;
        }

        assertReadingContentUriRequiresPermission(Telephony.Sms.CONTENT_URI,
                android.Manifest.permission.READ_SMS);
    }

    /**
     * Verify that reading from 'sms' (a content provider that is not accessible to instant apps)
     * returns null
     */
    @AppModeInstant"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ProviderPermissionTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.permission.cts.ProviderPermissionTest"	"testWriteSettings"	"CtsPermissionTestCases"	"4: apps ui system user"	"public void testWriteSettings() {
        final String permission = android.Manifest.permission.WRITE_SETTINGS;
        ContentValues value = new ContentValues();
        value.put(Settings.System.NAME, ""name"");
        value.put(Settings.System.VALUE, ""value_insert"");

        try {
            getContext().getContentResolver().insert(Settings.System.CONTENT_URI, value);
            fail(""expected SecurityException requiring "" + permission);
        } catch (SecurityException expected) {
            assertNotNull(""security exception's error message."", expected.getMessage());
            assertTrue(""error message should contain \"""" + permission + ""\"". Got: \""""
                    + expected.getMessage() + ""\""."",
                    expected.getMessage().contains(permission));
        }
    }

    /**
     * Verify that the {@link android.Manifest.permission#MANAGE_DOCUMENTS}
     * permission is only held by up to one package: whoever handles the
     * {@link android.content.Intent#ACTION_OPEN_DOCUMENT} intent, if any.
     * <p>
     * No other apps should <em>ever</em> attempt to acquire this permission,
     * since it would give those apps extremely broad access to all storage
     * providers on the device without user involvement in the arbitration
     * process. Apps should instead always rely on Uri permission grants for
     * access, using
     * {@link android.content.Intent#FLAG_GRANT_READ_URI_PERMISSION} and related
     * APIs.
     */"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ProviderPermissionTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.permission.cts.ProviderPermissionTest"	"testManageDocuments"	"CtsPermissionTestCases"	"3: apps ui user"	"public void testManageDocuments() {
        final PackageManager pm = getContext().getPackageManager();

        final Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);
        intent.addCategory(Intent.CATEGORY_OPENABLE);
        intent.setType(""*/*"");
        final ResolveInfo ri = pm.resolveActivity(intent, 0);

        if (ri != null) {
            final String validPkg = ri.activityInfo.packageName;

            final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[] {
                    android.Manifest.permission.MANAGE_DOCUMENTS
                    }, PackageManager.MATCH_UNINSTALLED_PACKAGES);
            for (PackageInfo pi : holding) {
                if (!Objects.equals(pi.packageName, validPkg)) {
                    fail(""Exactly one package (must be "" + validPkg
                            + "") can request the MANAGE_DOCUMENTS permission; found package ""
                            + pi.packageName + "" which must be revoked for security reasons"");
                }
            }
        }
    }

    /**
     * The {@link android.Manifest.permission#WRITE_MEDIA_STORAGE} permission is
     * a very powerful permission that grants raw storage access to all devices,
     * and as such it's only appropriate to be granted to the media stack.
     * <p>
     * CDD now requires that all apps requesting this permission also hold the
     * ""Storage"" runtime permission, to give users visibility into the
     * capabilities of each app, and control over those capabilities.
     * <p>
     * If the end user revokes the ""Storage"" permission from an app, but that
     * app still has raw access to storage via {@code WRITE_MEDIA_STORAGE}, that
     * would be a CDD violation and a privacy incident.
     */"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ProviderPermissionTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.permission.cts.ProviderPermissionTest"	"testReadContacts"	"CtsPermissionTestCases"	"1: ui"	"public void testReadContacts() {
        for (Uri uri : CONTACT_URIS) {
            Log.d(TAG, ""Checking contacts URI "" + uri);
            assertReadingContentUriRequiresPermission(uri,
                    android.Manifest.permission.READ_CONTACTS);
        }
    }

    /**
     * Verify that writing contacts requires permissions.
     * <p>Tests Permission:
     *   {@link android.Manifest.permission#WRITE_CONTACTS}
     */"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ProviderPermissionTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.permission.cts.ProviderPermissionTest"	"testWriteContacts"	"CtsPermissionTestCases"	"1: ui"	"public void testWriteContacts() {
        assertWritingContentUriRequiresPermission(Contacts.People.CONTENT_URI,
                android.Manifest.permission.WRITE_CONTACTS);
    }

    /**
     * Verify that reading call logs requires permissions.
     * <p>Tests Permission:
     *   {@link android.Manifest.permission#READ_CALL_LOG}
     */
    @AppModeFull"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ProviderPermissionTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.permission.cts.ProviderPermissionTest"	"testReadCallLog"	"CtsPermissionTestCases"	"1: ui"	"public void testReadCallLog() {
        assertReadingContentUriRequiresPermission(CallLog.CONTENT_URI,
                android.Manifest.permission.READ_CALL_LOG);
    }

    /**
     * Verify that writing call logs requires permissions.
     * <p>Tests Permission:
     *   {@link android.Manifest.permission#WRITE_CALL_LOG}
     */
    @AppModeFull"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ProviderPermissionTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.permission.cts.ProviderPermissionTest"	"testWriteCallLogInstant"	"CtsPermissionTestCases"	"1: ui"	"public void testWriteCallLogInstant() {
        try {
            getContext().getContentResolver().insert(CallLog.CONTENT_URI, new ContentValues());
            fail(""Expected IllegalArgumentException"");
        } catch (IllegalArgumentException expected) {
        }
    }

    /**
     * Verify that reading already received SMS messages requires permissions.
     * <p>Tests Permission:
     *   {@link android.Manifest.permission#READ_SMS}
     *
     * <p>Note: The WRITE_SMS permission has been removed.
     */
    @AppModeFull"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ProviderPermissionTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.permission.cts.ProviderPermissionTest"	"testReadSmsInstant"	"CtsPermissionTestCases"	"2: ui system"	"public void testReadSmsInstant() {
        if (!mContext.getPackageManager().hasSystemFeature(
                PackageManager.FEATURE_TELEPHONY)) {
            return;
        }

        assertNull(getContext().getContentResolver().query(Telephony.Sms.CONTENT_URI, null, null,
                null, null));
    }

    /**
     * Verify that write to settings requires permissions.
     * <p>Tests Permission:
     *   {@link android.Manifest.permission#WRITE_SETTINGS}
     */"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ProviderPermissionTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.permission.cts.ProviderPermissionTest"	"testWriteMediaStorage"	"CtsPermissionTestCases"	"3: ui system user"	"public void testWriteMediaStorage() throws Exception {
        final UiAutomation ui = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        final PackageManager pm = getContext().getPackageManager();
        final UserHandle userHandle = getContext().getUser();
        final List<PackageInfo> pkgs = pm.getInstalledPackages(
                PackageManager.MATCH_UNINSTALLED_PACKAGES | PackageManager.GET_PERMISSIONS);
        for (PackageInfo pkg : pkgs) {
            final int appUid = userHandle.getAppId(pkg.applicationInfo.uid);
            final boolean isSystem = appUid == android.os.Process.SYSTEM_UID;
            final boolean hasFrontDoor = pm.getLaunchIntentForPackage(pkg.packageName) != null;
            final boolean grantedMedia = pm.checkPermission(WRITE_MEDIA_STORAGE,
                    pkg.packageName) == PackageManager.PERMISSION_GRANTED;

            if (!isSystem && hasFrontDoor && grantedMedia) {
                final boolean requestsStorage = contains(pkg.requestedPermissions,
                        WRITE_EXTERNAL_STORAGE);
                if (!requestsStorage) {
                    fail(""Found "" + pkg.packageName + "" holding WRITE_MEDIA_STORAGE permission ""
                            + ""without also requesting WRITE_EXTERNAL_STORAGE; these permissions ""
                            + ""must be requested together"");
                }

                final boolean grantedStorage = pm.checkPermission(WRITE_EXTERNAL_STORAGE,
                        pkg.packageName) == PackageManager.PERMISSION_GRANTED;
                if (grantedStorage) {
                    final int flags;
                    ui.adoptShellPermissionIdentity(""android.permission.GET_RUNTIME_PERMISSIONS"");
                    try {
                        flags = pm.getPermissionFlags(WRITE_EXTERNAL_STORAGE, pkg.packageName,
                                android.os.Process.myUserHandle());
                    } finally {
                        ui.dropShellPermissionIdentity();
                    }

                    final boolean isFixed = (flags & (PackageManager.FLAG_PERMISSION_USER_FIXED
                            | PackageManager.FLAG_PERMISSION_POLICY_FIXED
                            | PackageManager.FLAG_PERMISSION_SYSTEM_FIXED)) != 0;
                    if (isFixed) {
                        fail(""Found "" + pkg.packageName + "" holding WRITE_EXTERNAL_STORAGE in a ""
                                + ""fixed state; this permission must be revokable by the user"");
                    }
                }
            }
        }
    }

    private static boolean contains(String[] haystack, String needle) {
        if (haystack != null) {
            for (String test : haystack) {
                if (Objects.equals(test, needle)) {
                    return true;
                }
            }
        }
        return false;
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ProviderPermissionTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.location.cts.gnss.asn1.supl2.rrlp_components.ReferenceIdentityType"	"isTagImplicit"	"CtsLocationGnssTestCases"	"1: system"	"public void test/*
 *.
 */

package android.location.cts.asn1.supl2.rrlp_components;

/*
 */


//
//
import android.location.cts.asn1.base.Asn1Choice;
import android.location.cts.asn1.base.Asn1Null;
import android.location.cts.asn1.base.Asn1Object;
import android.location.cts.asn1.base.Asn1Tag;
import android.location.cts.asn1.base.BitStream;
import android.location.cts.asn1.base.BitStreamReader;
import android.location.cts.asn1.base.ChoiceComponent;
import com.google.common.collect.ImmutableList;
import java.nio.ByteBuffer;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import javax.annotation.Nullable;


/**
 */
public  class ReferenceIdentityType extends Asn1Choice {
  //

  private static final Asn1Tag TAG_ReferenceIdentityType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  private static final Map<Asn1Tag, Select> tagToSelection = new HashMap<>();

  private boolean extension;
  private ChoiceComponent selection;
  private Asn1Object element;

  static {
    for (Select select : Select.values()) {
      for (Asn1Tag tag : select.getPossibleFirstTags()) {
        Select select0;
        if ((select0 = tagToSelection.put(tag, select)) != null) {
          throw new IllegalStateException(
            ""ReferenceIdentityType: "" + tag + "" maps to both "" + select0 + "" and "" + select);
        }
      }
    }
  }

  public ReferenceIdentityType() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_ReferenceIdentityType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_ReferenceIdentityType != null) {
      return ImmutableList.of(TAG_ReferenceIdentityType);
    } else {
      return tagToSelection.keySet();
    }
  }

  /**
   * Creates a new ReferenceIdentityType from encoded stream.
   */
  public static ReferenceIdentityType fromPerUnaligned(byte[] encodedBytes) {
    ReferenceIdentityType result = new ReferenceIdentityType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new ReferenceIdentityType from encoded stream.
   */
  public static ReferenceIdentityType fromPerAligned(byte[] encodedBytes) {
    ReferenceIdentityType result = new ReferenceIdentityType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  

  @Override protected boolean hasExtensionValue() {
    return extension;
  }

  @Override protected Integer getSelectionOrdinal() {
    return selection.ordinal();
  }

  @Nullable
  @Override
  protected ChoiceComponent getSelectedComponent() {
    return selection;
  }

  @Override protected int getOptionCount() {
    if (hasExtensionValue()) {
      return Extend.values().length;
    }
    return Select.values().length;
  }

  protected Asn1Object createAndSetValue(boolean isExtensionValue,
                                         int ordinal) {
    extension = isExtensionValue;
    if (isExtensionValue) {
      selection = Extend.values()[ordinal];
    } else {
      selection = Select.values()[ordinal];
    }
    element = selection.createElement();
    return element;
  }

  @Override protected ChoiceComponent createAndSetValue(Asn1Tag tag) {
    Select select = tagToSelection.get(tag);
    if (select == null) {
      throw new IllegalArgumentException(""Unknown selection tag: "" + tag);
    }
    element = select.createElement();
    selection = select;
    extension = false;
    return select;
  }

  @Override protected boolean isExtensible() {
    return false;
  }

  @Override protected Asn1Object getValue() {
    return element;
  }

  
  private static enum Select implements ChoiceComponent {
    
    $BsicAndCarrier(Asn1Tag.fromClassAndNumber(2, 0),
        true) {
      @Override
      public Asn1Object createElement() {
        return new BSICAndCarrier();
      }

      @Override
      Collection<Asn1Tag> getPossibleFirstTags() {
        return tag == null ? BSICAndCarrier.getPossibleFirstTags() : ImmutableList.of(tag);
      }

      @Override
      String elementIndentedString(Asn1Object element, String indent) {
        return toString() + "" : "" + element.toIndentedString(indent);
      }
    },
    
    $Ci(Asn1Tag.fromClassAndNumber(2, 1),
        true) {
      @Override
      public Asn1Object createElement() {
        return new CellID();
      }

      @Override
      Collection<Asn1Tag> getPossibleFirstTags() {
        return tag == null ? CellID.getPossibleFirstTags() : ImmutableList.of(tag);
      }

      @Override
      String elementIndentedString(Asn1Object element, String indent) {
        return toString() + "" : "" + element.toIndentedString(indent);
      }
    },
    
    $RequestIndex(Asn1Tag.fromClassAndNumber(2, 2),
        true) {
      @Override
      public Asn1Object createElement() {
        return new RequestIndex();
      }

      @Override
      Collection<Asn1Tag> getPossibleFirstTags() {
        return tag == null ? RequestIndex.getPossibleFirstTags() : ImmutableList.of(tag);
      }

      @Override
      String elementIndentedString(Asn1Object element, String indent) {
        return toString() + "" : "" + element.toIndentedString(indent);
      }
    },
    
    $SystemInfoIndex(Asn1Tag.fromClassAndNumber(2, 3),
        true) {
      @Override
      public Asn1Object createElement() {
        return new SystemInfoIndex();
      }

      @Override
      Collection<Asn1Tag> getPossibleFirstTags() {
        return tag == null ? SystemInfoIndex.getPossibleFirstTags() : ImmutableList.of(tag);
      }

      @Override
      String elementIndentedString(Asn1Object element, String indent) {
        return toString() + "" : "" + element.toIndentedString(indent);
      }
    },
    
    $CiAndLAC(Asn1Tag.fromClassAndNumber(2, 4),
        true) {
      @Override
      public Asn1Object createElement() {
        return new CellIDAndLAC();
      }

      @Override
      Collection<Asn1Tag> getPossibleFirstTags() {
        return tag == null ? CellIDAndLAC.getPossibleFirstTags() : ImmutableList.of(tag);
      }

      @Override
      String elementIndentedString(Asn1Object element, String indent) {
        return toString() + "" : "" + element.toIndentedString(indent);
      }
    },
    
    ;

    @Nullable final Asn1Tag tag;
    final boolean isImplicitTagging;

    Select(@Nullable Asn1Tag tag, boolean isImplicitTagging) {
      this.tag = tag;
      this.isImplicitTagging = isImplicitTagging;
    }

    @Override
    public Asn1Object createElement() {
      throw new IllegalStateException(""Select template error"");
    }

    @Override
    @Nullable
    public Asn1Tag getTag() {
      return tag;
    }

    @Override
    public boolean isImplicitTagging() {
      return isImplicitTagging;
    }

    abstract Collection<Asn1Tag> getPossibleFirstTags();

    abstract String elementIndentedString(Asn1Object element, String indent);
  }
  
  

  public boolean isBsicAndCarrier() {
    return !hasExtensionValue() && Select.$BsicAndCarrier == selection;
  }

  /**
   * @throws {@code IllegalStateException} if {@code !isBsicAndCarrier}.
   */
  @SuppressWarnings(""unchecked"")
  public BSICAndCarrier getBsicAndCarrier() {
    if (!isBsicAndCarrier()) {
      throw new IllegalStateException(""ReferenceIdentityType value not a BsicAndCarrier"");
    }
    return (BSICAndCarrier) element;
  }

  public void setBsicAndCarrier(BSICAndCarrier selected) {
    selection = Select.$BsicAndCarrier;
    extension = false;
    element = selected;
  }

  public BSICAndCarrier setBsicAndCarrierToNewInstance() {
      BSICAndCarrier element = new BSICAndCarrier();
      setBsicAndCarrier(element);
      return element;
  }
  
  

  public boolean isCi() {
    return !hasExtensionValue() && Select.$Ci == selection;
  }

  /**
   * @throws {@code IllegalStateException} if {@code !isCi}.
   */
  @SuppressWarnings(""unchecked"")
  public CellID getCi() {
    if (!isCi()) {
      throw new IllegalStateException(""ReferenceIdentityType value not a Ci"");
    }
    return (CellID) element;
  }

  public void setCi(CellID selected) {
    selection = Select.$Ci;
    extension = false;
    element = selected;
  }

  public CellID setCiToNewInstance() {
      CellID element = new CellID();
      setCi(element);
      return element;
  }
  
  

  public boolean isRequestIndex() {
    return !hasExtensionValue() && Select.$RequestIndex == selection;
  }

  /**
   * @throws {@code IllegalStateException} if {@code !isRequestIndex}.
   */
  @SuppressWarnings(""unchecked"")
  public RequestIndex getRequestIndex() {
    if (!isRequestIndex()) {
      throw new IllegalStateException(""ReferenceIdentityType value not a RequestIndex"");
    }
    return (RequestIndex) element;
  }

  public void setRequestIndex(RequestIndex selected) {
    selection = Select.$RequestIndex;
    extension = false;
    element = selected;
  }

  public RequestIndex setRequestIndexToNewInstance() {
      RequestIndex element = new RequestIndex();
      setRequestIndex(element);
      return element;
  }
  
  

  public boolean isSystemInfoIndex() {
    return !hasExtensionValue() && Select.$SystemInfoIndex == selection;
  }

  /**
   * @throws {@code IllegalStateException} if {@code !isSystemInfoIndex}.
   */
  @SuppressWarnings(""unchecked"")
  public SystemInfoIndex getSystemInfoIndex() {
    if (!isSystemInfoIndex()) {
      throw new IllegalStateException(""ReferenceIdentityType value not a SystemInfoIndex"");
    }
    return (SystemInfoIndex) element;
  }

  public void setSystemInfoIndex(SystemInfoIndex selected) {
    selection = Select.$SystemInfoIndex;
    extension = false;
    element = selected;
  }

  public SystemInfoIndex setSystemInfoIndexToNewInstance() {
      SystemInfoIndex element = new SystemInfoIndex();
      setSystemInfoIndex(element);
      return element;
  }
  
  

  public boolean isCiAndLAC() {
    return !hasExtensionValue() && Select.$CiAndLAC == selection;
  }

  /**
   * @throws {@code IllegalStateException} if {@code !isCiAndLAC}.
   */
  @SuppressWarnings(""unchecked"")
  public CellIDAndLAC getCiAndLAC() {
    if (!isCiAndLAC()) {
      throw new IllegalStateException(""ReferenceIdentityType value not a CiAndLAC"");
    }
    return (CellIDAndLAC) element;
  }

  public void setCiAndLAC(CellIDAndLAC selected) {
    selection = Select.$CiAndLAC;
    extension = false;
    element = selected;
  }

  public CellIDAndLAC setCiAndLACToNewInstance() {
      CellIDAndLAC element = new CellIDAndLAC();
      setCiAndLAC(element);
      return element;
  }
  

  private static enum Extend implements ChoiceComponent {
    
    ;
    @Nullable private final Asn1Tag tag;
    private final boolean isImplicitTagging;

    Extend(@Nullable Asn1Tag tag, boolean isImplicitTagging) {
      this.tag = tag;
      this.isImplicitTagging = isImplicitTagging;
    }

    public Asn1Object createElement() {
      throw new IllegalStateException(""Extend template error"");
    }

    @Override
    @Nullable
    public Asn1Tag getTag() {
      return tag;
    }

    @Override
    public boolean isImplicitTagging() {
      return isImplicitTagging;
    }

    String elementIndentedString(Asn1Object element, String indent) {
      throw new IllegalStateException(""Extend template error"");
    }
  }
  

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  private String elementIndentedString(String indent) {
    if (element == null) {
      return ""null;\n"";
    }
    if (extension) {
      return Extend.values()[selection.ordinal()]
          .elementIndentedString(element, indent + ""  "");
    } else {
      return Select.values()[selection.ordinal()]
          .elementIndentedString(element, indent + ""  "");
    }
  }

  public String toIndentedString(String indent) {
    return ""ReferenceIdentityType = "" + elementIndentedString(indent) + indent + "";\n"";
  }
}"	"/home/gpoor/cts-12-source/cts/tests/location/location_gnss/src/android/location/cts/gnss/asn1/supl2/rrlp_components/ReferenceIdentityType.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.location.cts.gnss.asn1.supl2.ver2_ulp_components.RTDUnits"	"isExtensionValue"	"CtsLocationGnssTestCases"	"1: mic"	"public void test/*
 *.
 */

package android.location.cts.asn1.supl2.ver2_ulp_components;

/*
 */


//
//
import android.location.cts.asn1.base.Asn1Enumerated;
import android.location.cts.asn1.base.Asn1Tag;
import android.location.cts.asn1.base.BitStream;
import android.location.cts.asn1.base.BitStreamReader;
import com.google.common.collect.ImmutableList;
import java.util.Collection;
import javax.annotation.Nullable;


/**
 */
public  class RTDUnits extends Asn1Enumerated {
  public enum Value implements Asn1Enumerated.Value {
    microseconds(0),
    hundredsofnanoseconds(1),
    tensofnanoseconds(2),
    nanoseconds(3),
    tenthsofnanoseconds(4),
    ;

    Value(int i) {
      value = i;
    }

    private int value;
    public int getAssignedValue() {
      return value;
    }

    @Override public boolean isExtensionValue() {
      return false;
    }
  }

  public enum ExtensionValue implements Asn1Enumerated.Value {
    ;

    ExtensionValue(int i) {
      value = i;
    }

    private int value;
    @Override public int getAssignedValue() {
      return value;
    }

    @Override public boolean isExtensionValue() {
      return true;
    }
  }

  

  private static final Asn1Tag TAG_RTDUnits
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public RTDUnits() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_RTDUnits;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_RTDUnits != null) {
      return ImmutableList.of(TAG_RTDUnits);
    } else {
      return Asn1Enumerated.getPossibleFirstTags();
    }
  }

  @Override protected boolean isExtensible() {
    return true;
  }

  @Override protected Asn1Enumerated.Value lookupValue(int ordinal) {
    return Value.values()[ordinal];
  }

  @Override protected Asn1Enumerated.Value lookupExtensionValue(int ordinal) {
    return ExtensionValue.values()[ordinal];
  }

  @Override protected int getValueCount() {
    return Value.values().length;
  }

  /**
   * Creates a new RTDUnits from encoded stream.
   */
  public static RTDUnits fromPerUnaligned(byte[] encodedBytes) {
    RTDUnits result = new RTDUnits();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new RTDUnits from encoded stream.
   */
  public static RTDUnits fromPerAligned(byte[] encodedBytes) {
    RTDUnits result = new RTDUnits();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""RTDUnits = "" + getValue() + "";\n"";
  }
}"	"/home/gpoor/cts-12-source/cts/tests/location/location_gnss/src/android/location/cts/gnss/asn1/supl2/ver2_ulp_components/RTDUnits.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.edi.cts.LibraryDeviceInfo"	"isDirectory"	"CtsEdiHostTestCases"	"2: direct system"	"public void test/*
 *.
 */
package android.edi.cts;

import com.android.compatibility.common.util.DeviceInfo;
import com.android.compatibility.common.util.HostInfoStore;
import com.android.ddmlib.FileListingService.FileEntry;
import com.android.tradefed.device.IFileEntry;
import com.android.tradefed.device.ITestDevice;

import java.util.Arrays;

public class LibraryDeviceInfo extends DeviceInfo {

    private ITestDevice mDevice;

    @Override
    protected void collectDeviceInfo(HostInfoStore store) throws Exception {

        mDevice = getDevice();

        collectSystemLibs(store);
        collectVendorLibs(store);
        collectFrameworkJars(store);
    }

    private void collectSystemLibs(HostInfoStore store) throws Exception {
        store.startArray(""lib"");
        collectFileDetails(store, ""/system/lib"", "".so"");
        store.endArray();
    }

    private void collectVendorLibs(HostInfoStore store) throws Exception {
        store.startArray(""vendor_lib"");
        collectFileDetails(store, ""/system/vendor/lib"", "".so"");
        store.endArray();
    }

    private void collectFrameworkJars(HostInfoStore store) throws Exception {
        store.startArray(""framework_jar"");
        collectFileDetails(store, ""/system/framework"", "".jar"");
        store.endArray();
    }

    private void collectFileDetails(HostInfoStore store, String path, String suffix)
            throws Exception {
        IFileEntry dir = mDevice.getFileEntry(path);

        if(dir == null || !dir.isDirectory()) {
            return;
        }

        for (IFileEntry file : dir.getChildren(false)) {
            String name = file.getName();
            if (!file.isDirectory() && name.endsWith(suffix)) {
                String sha1 = getSha1(file.getFullPath());
                store.startGroup();
                store.addResult(""name"", name);
                store.addResult(""sha1"", sha1);
                store.endGroup();
            }
        }
    }

    private String getSha1(String filePath) {
        String sha1 = ""unknown"";
        try {
            String out = mDevice.executeShellCommand(""sha1sum "" + filePath);
            sha1 = out.split("" "", 2)[0].toUpperCase();
        } catch (Exception e) {
            // Do nothing.
        }
        return sha1;
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/edi/src/android/edi/cts/LibraryDeviceInfo.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.hardware.devicestate.cts.DeviceStateManagerTests"	"testRequestAllSupportedStates"	"CtsDeviceStateManagerTestCases"	"1: ui"	"public void testRequestAllSupportedStates() throws Throwable {
        final ArgumentCaptor<Integer> intAgumentCaptor = ArgumentCaptor.forClass(Integer.class);
        final DeviceStateManager.DeviceStateCallback callback
                = mock(DeviceStateManager.DeviceStateCallback.class);
        final DeviceStateManager manager = getDeviceStateManager();
        manager.registerCallback(Runnable::run, callback);

        final int[] supportedStates = manager.getSupportedStates();
        for (int i = 0; i < supportedStates.length; i++) {
            final DeviceStateRequest request
                    = DeviceStateRequest.newBuilder(supportedStates[i]).build();

            runWithRequestActive(request, () -> {
                verify(callback, atLeastOnce()).onStateChanged(intAgumentCaptor.capture());
                assertEquals(intAgumentCaptor.getValue().intValue(), request.getState());
            });
        }
    }

    /**
     * Tests that calling {@link DeviceStateManager#requestState(DeviceStateRequest, Executor,
     * DeviceStateRequest.Callback)} throws an {@link java.lang.IllegalArgumentException} if
     * supplied with a state above {@link MAXIMUM_DEVICE_STATE}.
     */"	"/home/gpoor/cts-12-source/cts/tests/devicestate/src/android/hardware/devicestate/cts/DeviceStateManagerTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.hardware.devicestate.cts.DeviceStateManagerTests"	"testRequestStateTooLarge"	"CtsDeviceStateManagerTestCases"	"1: ui"	"(expected = IllegalArgumentException.class)
    public void testRequestStateTooLarge() throws Throwable {
        final DeviceStateManager manager = getDeviceStateManager();
        final DeviceStateRequest request
                = DeviceStateRequest.newBuilder(MAXIMUM_DEVICE_STATE + 1).build();
        runWithControlDeviceStatePermission(() -> manager.requestState(request, null, null));
    }

    /**
     * Tests that calling {@link DeviceStateManager#requestState(DeviceStateRequest, Executor,
     * DeviceStateRequest.Callback)} throws an {@link java.lang.IllegalArgumentException} if
     * supplied with a state below {@link MINIMUM_DEVICE_STATE}.
     */"	"/home/gpoor/cts-12-source/cts/tests/devicestate/src/android/hardware/devicestate/cts/DeviceStateManagerTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.hardware.devicestate.cts.DeviceStateManagerTests"	"testRequestStateTooSmall"	"CtsDeviceStateManagerTestCases"	"1: ui"	"(expected = IllegalArgumentException.class)
    public void testRequestStateTooSmall() throws Throwable {
        final DeviceStateManager manager = getDeviceStateManager();
        final DeviceStateRequest request
                = DeviceStateRequest.newBuilder(MINIMUM_DEVICE_STATE - 1).build();
        runWithControlDeviceStatePermission(() -> manager.requestState(request, null, null));
    }

    /**
     * Tests that calling {@link DeviceStateManager#requestState()} throws a
     * {@link java.lang.SecurityException} without the
     * {@link android.Manifest.permission.CONTROL_DEVICE_STATE} permission held.
     */"	"/home/gpoor/cts-12-source/cts/tests/devicestate/src/android/hardware/devicestate/cts/DeviceStateManagerTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.hardware.devicestate.cts.DeviceStateManagerTests"	"testRequestStateWithoutPermission"	"CtsDeviceStateManagerTestCases"	"1: ui"	"(expected = SecurityException.class)
    public void testRequestStateWithoutPermission() {
        final DeviceStateManager manager = getDeviceStateManager();
        final int[] states = manager.getSupportedStates();
        final DeviceStateRequest request = DeviceStateRequest.newBuilder(states[0]).build();
        manager.requestState(request, null, null);
    }

    /**
     * Tests that calling {@link DeviceStateManager#cancelRequest()} throws a
     * {@link java.lang.SecurityException} without the
     * {@link android.Manifest.permission.CONTROL_DEVICE_STATE} permission held.
     */"	"/home/gpoor/cts-12-source/cts/tests/devicestate/src/android/hardware/devicestate/cts/DeviceStateManagerTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.hardware.devicestate.cts.DeviceStateManagerTests"	"testCancelRequestWithoutPermission"	"CtsDeviceStateManagerTestCases"	"1: ui"	"(expected = SecurityException.class)
    public void testCancelRequestWithoutPermission() throws Throwable {
        final DeviceStateManager manager = getDeviceStateManager();
        final int[] states = manager.getSupportedStates();
        final DeviceStateRequest request = DeviceStateRequest.newBuilder(states[0]).build();
        runWithRequestActive(request, () -> {
            manager.cancelRequest(request);
        });
    }

    /**
     * Tests that callbacks added with {@link DeviceStateManager#registerDeviceStateCallback()} are
     * supplied with an initial callback that contains the state at the time of registration.
     */"	"/home/gpoor/cts-12-source/cts/tests/devicestate/src/android/hardware/devicestate/cts/DeviceStateManagerTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.testharness.app.TestHarnessModeDeviceTest"	"testDeviceInTestHarnessMode"	""	"1: user"	"public void testDeviceInTestHarnessMode() {
        Assert.assertTrue(ActivityManager.isRunningInUserTestHarness());
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/testharness/app/src/android/testharness/app/TestHarnessModeDeviceTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.verifier.nfc.hce.DualNonPaymentEmulatorActivity"	"setPassFailButtonClickListeners"	""	"2: ui system"	"public void testpackage com.android.cts.verifier.nfc.hce;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;

import com.android.cts.verifier.R;
import com.android.cts.verifier.nfc.NfcDialogs;

public class DualNonPaymentEmulatorActivity extends BaseEmulatorActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);
        setupServices(this, TransportService2.COMPONENT, AccessService.COMPONENT);
    }

    @Override
    protected void onResume() {
        super.onResume();
    }

    @Override
    void onServicesSetup(boolean result) {
        NfcDialogs.createHceTapReaderDialog(this, null).show();
    }

    public static Intent buildReaderIntent(Context context) {
        Intent readerIntent = new Intent(context, SimpleReaderActivity.class);
        // Combine command/response APDU arrays
        CommandApdu[] commandSequences = new CommandApdu[TransportService2.APDU_COMMAND_SEQUENCE.length +
                                               AccessService.APDU_COMMAND_SEQUENCE.length];
        System.arraycopy(TransportService2.APDU_COMMAND_SEQUENCE, 0, commandSequences, 0,
                TransportService2.APDU_COMMAND_SEQUENCE.length);
        System.arraycopy(AccessService.APDU_COMMAND_SEQUENCE, 0, commandSequences,
                TransportService2.APDU_COMMAND_SEQUENCE.length,
                AccessService.APDU_COMMAND_SEQUENCE.length);

        String[] responseSequences = new String[TransportService2.APDU_RESPOND_SEQUENCE.length +
                                               AccessService.APDU_RESPOND_SEQUENCE.length];
        System.arraycopy(TransportService2.APDU_RESPOND_SEQUENCE, 0, responseSequences, 0,
                TransportService2.APDU_RESPOND_SEQUENCE.length);
        System.arraycopy(AccessService.APDU_RESPOND_SEQUENCE, 0, responseSequences,
                TransportService2.APDU_RESPOND_SEQUENCE.length,
                AccessService.APDU_RESPOND_SEQUENCE.length);

        readerIntent.putExtra(SimpleReaderActivity.EXTRA_APDUS, commandSequences);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_RESPONSES, responseSequences);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_LABEL,
                context.getString(R.string.nfc_hce_dual_non_payment_reader));
        return readerIntent;
    }

    @Override
    void onApduSequenceComplete(ComponentName component, long duration) {
        if (component.equals(TransportService2.COMPONENT)) {
            getPassButton().setEnabled(true);
        }
    }
}"	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/DualNonPaymentEmulatorActivity.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.atracetestapp.AtraceDeviceTests"	"finish"	""	"1: system"	"public void launchActivity() {
        AtraceTestAppActivity activity = mActivity.launchActivity(null);
        activity.waitForDraw();
        activity.finish();
    }

    static {
        System.loadLibrary(""ctstrace_jni"");
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/atrace/AtraceTestApp/src/com/android/cts/atracetestapp/AtraceDeviceTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.webkit.WebViewDeviceSideStartupTest"	"WebViewDeviceSideStartupTest"	""	"1: ui"	"public void test/*
 *.
 */

package com.android.cts.webkit;

import android.net.http.SslError;
import android.os.StrictMode;
import android.test.ActivityInstrumentationTestCase2;
import android.test.UiThreadTest;
import android.util.Log;
import android.webkit.CookieManager;
import android.webkit.CookieSyncManager;
import android.webkit.SslErrorHandler;
import android.webkit.WebView;
import android.webkit.cts.CtsTestServer;
import android.webkit.cts.WebViewSyncLoader;
import android.webkit.cts.WebViewSyncLoader.WaitForLoadedClient;

import com.android.compatibility.common.util.NullWebViewUtils;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Test class testing different aspects of WebView loading.
 * The test methods in this class should be run one-and-one from the host-side to ensure we
 * don't run the tests in the same process (since we can only load WebView into a process
 * once - after that we will reuse the same webview provider).
 * This works because the instrumentation used to run device-tests from the host-side terminates the
 * testing process after each run.
 * OBS! When adding a test here - remember to add a corresponding host-side test that will start the
 * device-test added here! See com.android.cts.webkit.WebViewHostSideStartupTest.
 */
public class WebViewDeviceSideStartupTest
        extends ActivityInstrumentationTestCase2<WebViewStartupCtsActivity> {

    private static final String TAG = WebViewDeviceSideStartupTest.class.getSimpleName();
    private static final long TEST_TIMEOUT_MS = 3000;

    private WebViewStartupCtsActivity mActivity;

    public WebViewDeviceSideStartupTest() {
        super(""com.android.cts.webkit"", WebViewStartupCtsActivity.class);
    }

    @Override
    public void setUp() throws Exception {
        super.setUp();
        mActivity = getActivity();
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/hostsidetests/webkit/app/src/com/android/cts/webkit/WebViewDeviceSideStartupTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.webkit.WebViewDeviceSideStartupTest"	"testCookieManagerBlockingUiThread"	""	"1: ui"	"public void testCookieManagerBlockingUiThread() throws Throwable {
        if (!NullWebViewUtils.isWebViewAvailable()) {
            return;
        }

        // Instant app can only have https connection.
        CtsTestServer server = new CtsTestServer(mActivity, true);
        final String url = server.getCookieUrl(""death.html"");

        Thread background = new Thread(new Runnable() {
            @Override
            public void run() {
                CookieSyncManager csm = CookieSyncManager.createInstance(mActivity);
                CookieManager cookieManager = CookieManager.getInstance();

                cookieManager.removeAllCookie();
                cookieManager.setAcceptCookie(true);
                cookieManager.setCookie(url, ""count=41"");
                Log.i(TAG, ""done setting cookie before creating webview"");
            }
        });

        background.start();
        background.join();

        // Now create WebView and test that setting the cookie beforehand really worked.
        mActivity.createAndAttachWebView();
        WebView webView = mActivity.getWebView();
        WebViewSyncLoader syncLoader = new WebViewSyncLoader(webView);
        webView.setWebViewClient(new WaitForLoadedClient(syncLoader) {
            @Override
            public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) {
                // Not intended to verify server certificate, ignore the error.
                if (error.getPrimaryError() == SslError.SSL_IDMISMATCH) handler.proceed();
            }
        });
        syncLoader.loadUrlAndWaitForCompletion(url);
        assertEquals(""1|count=41"", webView.getTitle()); // outgoing cookie
        CookieManager cookieManager = CookieManager.getInstance();
        String cookie = cookieManager.getCookie(url);
        assertNotNull(cookie);
        final Pattern pat = Pattern.compile(""count=(\\d+)"");
        Matcher m = pat.matcher(cookie);
        assertTrue(m.matches());
        assertEquals(""42"", m.group(1)); // value got incremented
        syncLoader.detach();
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/hostsidetests/webkit/app/src/com/android/cts/webkit/WebViewDeviceSideStartupTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.webkit.WebViewDeviceSideStartupTest"	"testStrictModeNotViolatedOnStartup"	""	"1: ui"	"public void testStrictModeNotViolatedOnStartup() throws Throwable {
        if (!NullWebViewUtils.isWebViewAvailable()) {
            return;
        }

        StrictMode.ThreadPolicy oldThreadPolicy = StrictMode.getThreadPolicy();
        StrictMode.VmPolicy oldVmPolicy = StrictMode.getVmPolicy();
        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()
                .detectAll()
                .penaltyLog()
                .penaltyDeath()
                .build());
        StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()
                .detectAll()
                // TODO(b/151974299): Remove this after fixing existing context usage violation.
                .permitIncorrectContextUse()
                .penaltyLog()
                .penaltyDeath()
                .build());

        try {
            createWebViewAndNavigate();
            // Try to force Garbage Collection to catch any StrictMode violations triggered in
            // finalizers.
            for(int n = 0; n < 5; n++) {
                Runtime.getRuntime().gc();
                Thread.sleep(200);
            }
        } finally {
            StrictMode.setThreadPolicy(oldThreadPolicy);
            StrictMode.setVmPolicy(oldVmPolicy);
        }
    }

    private void createWebViewAndNavigate() {
        // Try to call some WebView APIs to ensure they don't cause strictmode violations
        mActivity.createAndAttachWebView();
        WebViewSyncLoader syncLoader = new WebViewSyncLoader(mActivity.getWebView());
        syncLoader.loadUrlAndWaitForCompletion(""about:blank"");
        syncLoader.loadUrlAndWaitForCompletion("""");
        syncLoader.detach();
    }

}"	"/home/gpoor/cts-12-source/cts/hostsidetests/webkit/app/src/com/android/cts/webkit/WebViewDeviceSideStartupTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.keystore.cts.util.TestUtils"	"TestUtils"	"CtsKeystoreTestCases"	"4: interfaces ui system user"	"public void test/*
 *.
 */

package android.keystore.cts.util;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import android.content.Context;
import android.content.pm.PackageManager;
import android.content.pm.FeatureInfo;
import android.os.Build;
import android.os.SystemProperties;
import android.security.keystore.KeyGenParameterSpec;
import android.security.keystore.KeyInfo;
import android.security.keystore.KeyProperties;
import android.security.keystore.KeyProtection;
import android.test.MoreAsserts;

import androidx.test.platform.app.InstrumentationRegistry;

import com.android.internal.util.HexDump;

import junit.framework.Assert;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigInteger;
import java.security.Key;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.KeyPairGeneratorSpi;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.ProviderException;
import java.security.PublicKey;
import java.security.UnrecoverableEntryException;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.interfaces.ECKey;
import java.security.interfaces.ECPrivateKey;
import java.security.interfaces.ECPublicKey;
import java.security.interfaces.RSAKey;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.ECParameterSpec;
import java.security.spec.EllipticCurve;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.security.SecureRandom;

import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.SecretKeySpec;

public class TestUtils {

    public static final String EXPECTED_CRYPTO_OP_PROVIDER_NAME = ""AndroidKeyStoreBCWorkaround"";
    public static final String EXPECTED_PROVIDER_NAME = ""AndroidKeyStore"";

    public static final long DAY_IN_MILLIS = 1000 * 60 * 60 * 24;

    private TestUtils() {}

    static public void assumeStrongBox() {
        PackageManager packageManager =
                InstrumentationRegistry.getInstrumentation().getTargetContext().getPackageManager();
        assumeTrue(""Can only test if we have StrongBox"",
                packageManager.hasSystemFeature(PackageManager.FEATURE_STRONGBOX_KEYSTORE));
    }

    // Returns 0 if not implemented. Otherwise returns the feature version.
    //
    public static int getFeatureVersionKeystore(Context appContext) {
        PackageManager pm = appContext.getPackageManager();

        int featureVersionFromPm = 0;
        if (pm.hasSystemFeature(PackageManager.FEATURE_HARDWARE_KEYSTORE)) {
            FeatureInfo info = null;
            FeatureInfo[] infos = pm.getSystemAvailableFeatures();
            for (int n = 0; n < infos.length; n++) {
                FeatureInfo i = infos[n];
                if (i.name.equals(PackageManager.FEATURE_HARDWARE_KEYSTORE)) {
                    info = i;
                    break;
                }
            }
            if (info != null) {
                featureVersionFromPm = info.version;
            }
        }

        return featureVersionFromPm;
    }

    // Returns 0 if not implemented. Otherwise returns the feature version.
    //
    public static int getFeatureVersionKeystoreStrongBox(Context appContext) {
        PackageManager pm = appContext.getPackageManager();

        int featureVersionFromPm = 0;
        if (pm.hasSystemFeature(PackageManager.FEATURE_STRONGBOX_KEYSTORE)) {
            FeatureInfo info = null;
            FeatureInfo[] infos = pm.getSystemAvailableFeatures();
            for (int n = 0; n < infos.length; n++) {
                FeatureInfo i = infos[n];
                if (i.name.equals(PackageManager.FEATURE_STRONGBOX_KEYSTORE)) {
                    info = i;
                    break;
                }
            }
            if (info != null) {
                featureVersionFromPm = info.version;
            }
        }

        return featureVersionFromPm;
    }

    /**
     * Returns whether 3DES KeyStore tests should run on this device. 3DES support was added in
     * KeyMaster 4.0 and there should be no software fallback on earlier KeyMaster versions.
     */
    public static boolean supports3DES() {
        return ""true"".equals(SystemProperties.get(""ro.hardware.keystore_desede""));
    }

    /**
     * Returns whether the device has a StrongBox backed KeyStore.
     */
    public static boolean hasStrongBox(Context context) {
        return context.getPackageManager()
            .hasSystemFeature(PackageManager.FEATURE_STRONGBOX_KEYSTORE);
    }

    /**
     * Asserts the the key algorithm and algorithm-specific parameters of the two keys in the
     * provided pair match.
     */
    public static void assertKeyPairSelfConsistent(KeyPair keyPair) {
        assertKeyPairSelfConsistent(keyPair.getPublic(), keyPair.getPrivate());
    }

    /**
     * Asserts the the key algorithm and public algorithm-specific parameters of the two provided
     * keys match.
     */
    public static void assertKeyPairSelfConsistent(PublicKey publicKey, PrivateKey privateKey) {
        assertNotNull(publicKey);
        assertNotNull(privateKey);
        assertEquals(publicKey.getAlgorithm(), privateKey.getAlgorithm());
        String keyAlgorithm = publicKey.getAlgorithm();
        if (""EC"".equalsIgnoreCase(keyAlgorithm)) {
            assertTrue(""EC public key must be instanceof ECKey: ""
                    + publicKey.getClass().getName(),
                    publicKey instanceof ECKey);
            assertTrue(""EC private key must be instanceof ECKey: ""
                    + privateKey.getClass().getName(),
                    privateKey instanceof ECKey);
            assertECParameterSpecEqualsIgnoreSeedIfNotPresent(
                    ""Private key must have the same EC parameters as public key"",
                    ((ECKey) publicKey).getParams(), ((ECKey) privateKey).getParams());
        } else if (""RSA"".equalsIgnoreCase(keyAlgorithm)) {
            assertTrue(""RSA public key must be instance of RSAKey: ""
                    + publicKey.getClass().getName(),
                    publicKey instanceof RSAKey);
            assertTrue(""RSA private key must be instance of RSAKey: ""
                    + privateKey.getClass().getName(),
                    privateKey instanceof RSAKey);
            assertEquals(""Private and public key must have the same RSA modulus"",
                    ((RSAKey) publicKey).getModulus(), ((RSAKey) privateKey).getModulus());
        } else {
            fail(""Unsuported key algorithm: "" + keyAlgorithm);
        }
    }

    public static int getKeySizeBits(Key key) {
        if (key instanceof ECKey) {
            return ((ECKey) key).getParams().getCurve().getField().getFieldSize();
        } else if (key instanceof RSAKey) {
            return ((RSAKey) key).getModulus().bitLength();
        } else {
            throw new IllegalArgumentException(""Unsupported key type: "" + key.getClass());
        }
    }

    public static void assertKeySize(int expectedSizeBits, KeyPair keyPair) {
        assertEquals(expectedSizeBits, getKeySizeBits(keyPair.getPrivate()));
        assertEquals(expectedSizeBits, getKeySizeBits(keyPair.getPublic()));
    }

    /**
     * Asserts that the provided key pair is an Android Keystore key pair stored under the provided
     * alias.
     */
    public static void assertKeyStoreKeyPair(KeyStore keyStore, String alias, KeyPair keyPair) {
        assertKeyMaterialExportable(keyPair.getPublic());
        assertKeyMaterialNotExportable(keyPair.getPrivate());
        assertTransparentKey(keyPair.getPublic());
        assertOpaqueKey(keyPair.getPrivate());

        KeyStore.Entry entry;
        Certificate cert;
        try {
            entry = keyStore.getEntry(alias, null);
            cert = keyStore.getCertificate(alias);
        } catch (KeyStoreException | UnrecoverableEntryException | NoSuchAlgorithmException e) {
            throw new RuntimeException(""Failed to load entry: "" + alias, e);
        }
        assertNotNull(entry);

        assertTrue(entry instanceof KeyStore.PrivateKeyEntry);
        KeyStore.PrivateKeyEntry privEntry = (KeyStore.PrivateKeyEntry) entry;
        assertEquals(cert, privEntry.getCertificate());
        assertTrue(""Certificate must be an X.509 certificate: "" + cert.getClass(),
                cert instanceof X509Certificate);
        final X509Certificate x509Cert = (X509Certificate) cert;

        PrivateKey keystorePrivateKey = privEntry.getPrivateKey();
        PublicKey keystorePublicKey = cert.getPublicKey();
        assertEquals(keyPair.getPrivate(), keystorePrivateKey);
        assertTrue(""Key1:\n"" + HexDump.dumpHexString(keyPair.getPublic().getEncoded())
                + ""\nKey2:\n"" + HexDump.dumpHexString(keystorePublicKey.getEncoded()) + ""\n"",
                Arrays.equals(keyPair.getPublic().getEncoded(), keystorePublicKey.getEncoded()));


        assertEquals(
                ""Public key used to sign certificate should have the same algorithm as in KeyPair"",
                keystorePublicKey.getAlgorithm(), x509Cert.getPublicKey().getAlgorithm());

        Certificate[] chain = privEntry.getCertificateChain();
        if (chain.length == 0) {
            fail(""Empty certificate chain"");
            return;
        }
        assertEquals(cert, chain[0]);
    }


    private static void assertKeyMaterialExportable(Key key) {
        if (key instanceof PublicKey) {
            assertEquals(""X.509"", key.getFormat());
        } else if (key instanceof PrivateKey) {
            assertEquals(""PKCS#8"", key.getFormat());
        } else if (key instanceof SecretKey) {
            assertEquals(""RAW"", key.getFormat());
        } else {
            fail(""Unsupported key type: "" + key.getClass().getName());
        }
        byte[] encodedForm = key.getEncoded();
        assertNotNull(encodedForm);
        if (encodedForm.length == 0) {
            fail(""Empty encoded form"");
        }
    }

    private static void assertKeyMaterialNotExportable(Key key) {
        assertEquals(null, key.getFormat());
        assertEquals(null, key.getEncoded());
    }

    private static void assertOpaqueKey(Key key) {
        assertFalse(key.getClass().getName() + "" is a transparent key"", isTransparentKey(key));
    }

    private static void assertTransparentKey(Key key) {
        assertTrue(key.getClass().getName() + "" is not a transparent key"", isTransparentKey(key));
    }

    private static boolean isTransparentKey(Key key) {
        if (key instanceof PrivateKey) {
            return (key instanceof ECPrivateKey) || (key instanceof RSAPrivateKey);
        } else if (key instanceof PublicKey) {
            return (key instanceof ECPublicKey) || (key instanceof RSAPublicKey);
        } else if (key instanceof SecretKey) {
            return (key instanceof SecretKeySpec);
        } else {
            throw new IllegalArgumentException(""Unsupported key type: "" + key.getClass().getName());
        }
    }

    public static void assertECParameterSpecEqualsIgnoreSeedIfNotPresent(
            ECParameterSpec expected, ECParameterSpec actual) {
        assertECParameterSpecEqualsIgnoreSeedIfNotPresent(null, expected, actual);
    }

    public static void assertECParameterSpecEqualsIgnoreSeedIfNotPresent(String message,
            ECParameterSpec expected, ECParameterSpec actual) {
        EllipticCurve expectedCurve = expected.getCurve();
        EllipticCurve actualCurve = actual.getCurve();
        String msgPrefix = (message != null) ? message + "": "" : """";
        assertEquals(msgPrefix + ""curve field"", expectedCurve.getField(), actualCurve.getField());
        assertEquals(msgPrefix + ""curve A"", expectedCurve.getA(), actualCurve.getA());
        assertEquals(msgPrefix + ""curve B"", expectedCurve.getB(), actualCurve.getB());
        assertEquals(msgPrefix + ""order"", expected.getOrder(), actual.getOrder());
        assertEquals(msgPrefix + ""generator"",
                expected.getGenerator(), actual.getGenerator());
        assertEquals(msgPrefix + ""cofactor"", expected.getCofactor(), actual.getCofactor());

        // If present, the seed must be the same
        byte[] expectedSeed = expectedCurve.getSeed();
        byte[] actualSeed = expectedCurve.getSeed();
        if ((expectedSeed != null) && (actualSeed != null)) {
            MoreAsserts.assertEquals(expectedSeed, actualSeed);
        }
    }

    public static KeyInfo getKeyInfo(Key key) throws InvalidKeySpecException, NoSuchAlgorithmException,
            NoSuchProviderException {
        if ((key instanceof PrivateKey) || (key instanceof PublicKey)) {
            return KeyFactory.getInstance(key.getAlgorithm(), ""AndroidKeyStore"")
                    .getKeySpec(key, KeyInfo.class);
        } else if (key instanceof SecretKey) {
            return (KeyInfo) SecretKeyFactory.getInstance(key.getAlgorithm(), ""AndroidKeyStore"")
                    .getKeySpec((SecretKey) key, KeyInfo.class);
        } else {
            throw new IllegalArgumentException(""Unexpected key type: "" + key.getClass());
        }
    }

    public static <T> void assertContentsInAnyOrder(Iterable<T> actual, T... expected) {
        assertContentsInAnyOrder(null, actual, expected);
    }

    public static <T> void assertContentsInAnyOrder(String message, Iterable<T> actual, T... expected) {
        Map<T, Integer> actualFreq = getFrequencyTable(actual);
        Map<T, Integer> expectedFreq = getFrequencyTable(expected);
        if (actualFreq.equals(expectedFreq)) {
            return;
        }

        Map<T, Integer> extraneousFreq = new HashMap<T, Integer>();
        for (Map.Entry<T, Integer> actualEntry : actualFreq.entrySet()) {
            int actualCount = actualEntry.getValue();
            Integer expectedCount = expectedFreq.get(actualEntry.getKey());
            int diff = actualCount - ((expectedCount != null) ? expectedCount : 0);
            if (diff > 0) {
                extraneousFreq.put(actualEntry.getKey(), diff);
            }
        }

        Map<T, Integer> missingFreq = new HashMap<T, Integer>();
        for (Map.Entry<T, Integer> expectedEntry : expectedFreq.entrySet()) {
            int expectedCount = expectedEntry.getValue();
            Integer actualCount = actualFreq.get(expectedEntry.getKey());
            int diff = expectedCount - ((actualCount != null) ? actualCount : 0);
            if (diff > 0) {
                missingFreq.put(expectedEntry.getKey(), diff);
            }
        }

        List<T> extraneous = frequencyTableToValues(extraneousFreq);
        List<T> missing = frequencyTableToValues(missingFreq);
        StringBuilder result = new StringBuilder();
        String delimiter = """";
        if (message != null) {
            result.append(message).append(""."");
            delimiter = "" "";
        }
        if (!missing.isEmpty()) {
            result.append(delimiter).append(""missing: "" + missing);
            delimiter = "", "";
        }
        if (!extraneous.isEmpty()) {
            result.append(delimiter).append(""extraneous: "" + extraneous);
        }
        fail(result.toString());
    }

    private static <T> Map<T, Integer> getFrequencyTable(Iterable<T> values) {
        Map<T, Integer> result = new HashMap<T, Integer>();
        for (T value : values) {
            Integer count = result.get(value);
            if (count == null) {
                count = 1;
            } else {
                count++;
            }
            result.put(value, count);
        }
        return result;
    }

    private static <T> Map<T, Integer> getFrequencyTable(T... values) {
        Map<T, Integer> result = new HashMap<T, Integer>();
        for (T value : values) {
            Integer count = result.get(value);
            if (count == null) {
                count = 1;
            } else {
                count++;
            }
            result.put(value, count);
        }
        return result;
    }

    @SuppressWarnings(""rawtypes"")
    private static <T> List<T> frequencyTableToValues(Map<T, Integer> table) {
        if (table.isEmpty()) {
            return Collections.emptyList();
        }

        List<T> result = new ArrayList<T>();
        boolean comparableValues = true;
        for (Map.Entry<T, Integer> entry : table.entrySet()) {
            T value = entry.getKey();
            if (!(value instanceof Comparable)) {
                comparableValues = false;
            }
            int frequency = entry.getValue();
            for (int i = 0; i < frequency; i++) {
                result.add(value);
            }
        }

        if (comparableValues) {
            sortAssumingComparable(result);
        }
        return result;
    }

    @SuppressWarnings({""rawtypes"", ""unchecked""})
    private static void sortAssumingComparable(List<?> values) {
        Collections.sort((List<Comparable>)values);
    }

    public static String[] toLowerCase(String... values) {
        if (values == null) {
            return null;
        }
        String[] result = new String[values.length];
        for (int i = 0; i < values.length; i++) {
            String value = values[i];
            result[i] = (value != null) ? value.toLowerCase() : null;
        }
        return result;
    }

    public static PrivateKey getRawResPrivateKey(Context context, int resId) throws Exception {
        byte[] pkcs8EncodedForm;
        try (InputStream in = context.getResources().openRawResource(resId)) {
            pkcs8EncodedForm = drain(in);
        }
        PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(pkcs8EncodedForm);

        try {
            return KeyFactory.getInstance(""EC"").generatePrivate(privateKeySpec);
        } catch (InvalidKeySpecException e) {
            try {
                return KeyFactory.getInstance(""RSA"").generatePrivate(privateKeySpec);
            } catch (InvalidKeySpecException e2) {
                throw new InvalidKeySpecException(""The key is neither EC nor RSA"", e);
            }
        }
    }

    public static X509Certificate getRawResX509Certificate(Context context, int resId) throws Exception {
        try (InputStream in = context.getResources().openRawResource(resId)) {
            return (X509Certificate) CertificateFactory.getInstance(""X.509"")
                    .generateCertificate(in);
        }
    }

    public static KeyPair importIntoAndroidKeyStore(
            String alias,
            PrivateKey privateKey,
            Certificate certificate,
            KeyProtection keyProtection) throws Exception {
        KeyStore keyStore = KeyStore.getInstance(""AndroidKeyStore"");
        keyStore.load(null);
        keyStore.setEntry(alias,
                new KeyStore.PrivateKeyEntry(privateKey, new Certificate[] {certificate}),
                keyProtection);
        return new KeyPair(
                keyStore.getCertificate(alias).getPublicKey(),
                (PrivateKey) keyStore.getKey(alias, null));
    }

    public static ImportedKey importIntoAndroidKeyStore(
            String alias,
            SecretKey key,
            KeyProtection keyProtection) throws Exception {
        KeyStore keyStore = KeyStore.getInstance(""AndroidKeyStore"");
        keyStore.load(null);
        keyStore.setEntry(alias,
                new KeyStore.SecretKeyEntry(key),
                keyProtection);
        return new ImportedKey(alias, key, (SecretKey) keyStore.getKey(alias, null));
    }

    public static ImportedKey importIntoAndroidKeyStore(
            String alias, Context context, int privateResId, int certResId, KeyProtection params)
                    throws Exception {
        Certificate originalCert = TestUtils.getRawResX509Certificate(context, certResId);
        PublicKey originalPublicKey = originalCert.getPublicKey();
        PrivateKey originalPrivateKey = TestUtils.getRawResPrivateKey(context, privateResId);

        // Check that the domain parameters match between the private key and the public key. This
        // is to catch accidental errors where a test provides the wrong resource ID as one of the
        // parameters.
        if (!originalPublicKey.getAlgorithm().equalsIgnoreCase(originalPrivateKey.getAlgorithm())) {
            throw new IllegalArgumentException(""Key algorithm mismatch.""
                    + "" Public: "" + originalPublicKey.getAlgorithm()
                    + "", private: "" + originalPrivateKey.getAlgorithm());
        }
        assertKeyPairSelfConsistent(originalPublicKey, originalPrivateKey);

        KeyPair keystoreBacked = TestUtils.importIntoAndroidKeyStore(
                alias, originalPrivateKey, originalCert,
                params);
        assertKeyPairSelfConsistent(keystoreBacked);
        assertKeyPairSelfConsistent(keystoreBacked.getPublic(), originalPrivateKey);
        return new ImportedKey(
                alias,
                new KeyPair(originalCert.getPublicKey(), originalPrivateKey),
                keystoreBacked);
    }

    public static byte[] drain(InputStream in) throws IOException {
        ByteArrayOutputStream result = new ByteArrayOutputStream();
        byte[] buffer = new byte[16 * 1024];
        int chunkSize;
        while ((chunkSize = in.read(buffer)) != -1) {
            result.write(buffer, 0, chunkSize);
        }
        return result.toByteArray();
    }

    public static KeyProtection.Builder buildUpon(KeyProtection params) {
        return buildUponInternal(params, null);
    }

    public static KeyProtection.Builder buildUpon(KeyProtection params, int newPurposes) {
        return buildUponInternal(params, newPurposes);
    }

    public static KeyProtection.Builder buildUpon(
            KeyProtection.Builder builder) {
        return buildUponInternal(builder.build(), null);
    }

    public static KeyProtection.Builder buildUpon(
            KeyProtection.Builder builder, int newPurposes) {
        return buildUponInternal(builder.build(), newPurposes);
    }

    private static KeyProtection.Builder buildUponInternal(
            KeyProtection spec, Integer newPurposes) {
        int purposes = (newPurposes == null) ? spec.getPurposes() : newPurposes;
        KeyProtection.Builder result = new KeyProtection.Builder(purposes);
        result.setBlockModes(spec.getBlockModes());
        if (spec.isDigestsSpecified()) {
            result.setDigests(spec.getDigests());
        }
        result.setEncryptionPaddings(spec.getEncryptionPaddings());
        result.setSignaturePaddings(spec.getSignaturePaddings());
        result.setKeyValidityStart(spec.getKeyValidityStart());
        result.setKeyValidityForOriginationEnd(spec.getKeyValidityForOriginationEnd());
        result.setKeyValidityForConsumptionEnd(spec.getKeyValidityForConsumptionEnd());
        result.setRandomizedEncryptionRequired(spec.isRandomizedEncryptionRequired());
        result.setUserAuthenticationRequired(spec.isUserAuthenticationRequired());
        result.setUserAuthenticationValidityDurationSeconds(
                spec.getUserAuthenticationValidityDurationSeconds());
        result.setBoundToSpecificSecureUserId(spec.getBoundToSpecificSecureUserId());
        return result;
    }

    public static KeyGenParameterSpec.Builder buildUpon(KeyGenParameterSpec spec) {
        return buildUponInternal(spec, null);
    }

    public static KeyGenParameterSpec.Builder buildUpon(KeyGenParameterSpec spec, int newPurposes) {
        return buildUponInternal(spec, newPurposes);
    }

    public static KeyGenParameterSpec.Builder buildUpon(
            KeyGenParameterSpec.Builder builder) {
        return buildUponInternal(builder.build(), null);
    }

    public static KeyGenParameterSpec.Builder buildUpon(
            KeyGenParameterSpec.Builder builder, int newPurposes) {
        return buildUponInternal(builder.build(), newPurposes);
    }

    private static KeyGenParameterSpec.Builder buildUponInternal(
            KeyGenParameterSpec spec, Integer newPurposes) {
        int purposes = (newPurposes == null) ? spec.getPurposes() : newPurposes;
        KeyGenParameterSpec.Builder result =
                new KeyGenParameterSpec.Builder(spec.getKeystoreAlias(), purposes);
        if (spec.getKeySize() >= 0) {
            result.setKeySize(spec.getKeySize());
        }
        if (spec.getAlgorithmParameterSpec() != null) {
            result.setAlgorithmParameterSpec(spec.getAlgorithmParameterSpec());
        }
        result.setCertificateNotBefore(spec.getCertificateNotBefore());
        result.setCertificateNotAfter(spec.getCertificateNotAfter());
        result.setCertificateSerialNumber(spec.getCertificateSerialNumber());
        result.setCertificateSubject(spec.getCertificateSubject());
        result.setBlockModes(spec.getBlockModes());
        if (spec.isDigestsSpecified()) {
            result.setDigests(spec.getDigests());
        }
        result.setEncryptionPaddings(spec.getEncryptionPaddings());
        result.setSignaturePaddings(spec.getSignaturePaddings());
        result.setKeyValidityStart(spec.getKeyValidityStart());
        result.setKeyValidityForOriginationEnd(spec.getKeyValidityForOriginationEnd());
        result.setKeyValidityForConsumptionEnd(spec.getKeyValidityForConsumptionEnd());
        result.setRandomizedEncryptionRequired(spec.isRandomizedEncryptionRequired());
        result.setUserAuthenticationRequired(spec.isUserAuthenticationRequired());
        result.setUserAuthenticationValidityDurationSeconds(
                spec.getUserAuthenticationValidityDurationSeconds());
        return result;
    }

    public static KeyPair getKeyPairForKeyAlgorithm(String keyAlgorithm, Iterable<KeyPair> keyPairs) {
        for (KeyPair keyPair : keyPairs) {
            if (keyAlgorithm.equalsIgnoreCase(keyPair.getPublic().getAlgorithm())) {
                return keyPair;
            }
        }
        throw new IllegalArgumentException(""No KeyPair for key algorithm "" + keyAlgorithm);
    }

    public static Key getKeyForKeyAlgorithm(String keyAlgorithm, Iterable<? extends Key> keys) {
        for (Key key : keys) {
            if (keyAlgorithm.equalsIgnoreCase(key.getAlgorithm())) {
                return key;
            }
        }
        throw new IllegalArgumentException(""No Key for key algorithm "" + keyAlgorithm);
    }

    public static byte[] generateLargeKatMsg(byte[] seed, int msgSizeBytes) throws Exception {
        byte[] result = new byte[msgSizeBytes];
        MessageDigest digest = MessageDigest.getInstance(""SHA-512"");
        int resultOffset = 0;
        int resultRemaining = msgSizeBytes;
        while (resultRemaining > 0) {
            seed = digest.digest(seed);
            int chunkSize = Math.min(seed.length, resultRemaining);
            System.arraycopy(seed, 0, result, resultOffset, chunkSize);
            resultOffset += chunkSize;
            resultRemaining -= chunkSize;
        }
        return result;
    }

    public static byte[] leftPadWithZeroBytes(byte[] array, int length) {
        if (array.length >= length) {
            return array;
        }
        byte[] result = new byte[length];
        System.arraycopy(array, 0, result, result.length - array.length, array.length);
        return result;
    }

    public static boolean contains(int[] array, int value) {
        for (int element : array) {
            if (element == value) {
                return true;
            }
        }
        return false;
    }

    public static boolean isHmacAlgorithm(String algorithm) {
        return algorithm.toUpperCase(Locale.US).startsWith(""HMAC"");
    }

    public static String getHmacAlgorithmDigest(String algorithm) {
        String algorithmUpperCase = algorithm.toUpperCase(Locale.US);
        if (!algorithmUpperCase.startsWith(""HMAC"")) {
            return null;
        }
        String result = algorithmUpperCase.substring(""HMAC"".length());
        if (result.startsWith(""SHA"")) {
            result = ""SHA-"" + result.substring(""SHA"".length());
        }
        return result;
    }

    public static String getKeyAlgorithm(String transformation) {
        try {
            return getCipherKeyAlgorithm(transformation);
        } catch (IllegalArgumentException e) {

        }
        try {
            return getSignatureAlgorithmKeyAlgorithm(transformation);
        } catch (IllegalArgumentException e) {

        }
        String transformationUpperCase = transformation.toUpperCase(Locale.US);
        if (transformationUpperCase.equals(""EC"")) {
            return KeyProperties.KEY_ALGORITHM_EC;
        }
        if (transformationUpperCase.equals(""RSA"")) {
            return KeyProperties.KEY_ALGORITHM_RSA;
        }
        if (transformationUpperCase.equals(""DESEDE"")) {
            return KeyProperties.KEY_ALGORITHM_3DES;
        }
        if (transformationUpperCase.equals(""AES"")) {
            return KeyProperties.KEY_ALGORITHM_AES;
        }
        if (transformationUpperCase.startsWith(""HMAC"")) {
            if (transformation.endsWith(""SHA1"")) {
                return KeyProperties.KEY_ALGORITHM_HMAC_SHA1;
            } else if (transformation.endsWith(""SHA224"")) {
                return KeyProperties.KEY_ALGORITHM_HMAC_SHA224;
            } else if (transformation.endsWith(""SHA256"")) {
                return KeyProperties.KEY_ALGORITHM_HMAC_SHA256;
            } else if (transformation.endsWith(""SHA384"")) {
                return KeyProperties.KEY_ALGORITHM_HMAC_SHA384;
            } else if (transformation.endsWith(""SHA512"")) {
                return KeyProperties.KEY_ALGORITHM_HMAC_SHA512;
            }
        }
        throw new IllegalArgumentException(""Unsupported transformation: "" + transformation);
    }

    public static String getCipherKeyAlgorithm(String transformation) {
        String transformationUpperCase = transformation.toUpperCase(Locale.US);
        if (transformationUpperCase.startsWith(""AES/"")) {
            return KeyProperties.KEY_ALGORITHM_AES;
        } else if (transformationUpperCase.startsWith(""DESEDE/"")) {
            return KeyProperties.KEY_ALGORITHM_3DES;
        } else if (transformationUpperCase.startsWith(""RSA/"")) {
            return KeyProperties.KEY_ALGORITHM_RSA;
        } else {
            throw new IllegalArgumentException(""Unsupported transformation: "" + transformation);
        }
    }

    public static boolean isCipherSymmetric(String transformation) {
        String transformationUpperCase = transformation.toUpperCase(Locale.US);
        if (transformationUpperCase.startsWith(""AES/"") || transformationUpperCase.startsWith(
                ""DESEDE/"")) {
            return true;
        } else if (transformationUpperCase.startsWith(""RSA/"")) {
            return false;
        } else {
            throw new IllegalArgumentException(""YYZ: Unsupported transformation: "" + transformation);
        }
    }

    public static String getCipherDigest(String transformation) {
        String transformationUpperCase = transformation.toUpperCase(Locale.US);
        if (transformationUpperCase.contains(""/OAEP"")) {
            if (transformationUpperCase.endsWith(""/OAEPPADDING"")) {
                return KeyProperties.DIGEST_SHA1;
            } else if (transformationUpperCase.endsWith(
                    ""/OAEPWITHSHA-1ANDMGF1PADDING"")) {
                return KeyProperties.DIGEST_SHA1;
            } else if (transformationUpperCase.endsWith(
                    ""/OAEPWITHSHA-224ANDMGF1PADDING"")) {
                return KeyProperties.DIGEST_SHA224;
            } else if (transformationUpperCase.endsWith(
                    ""/OAEPWITHSHA-256ANDMGF1PADDING"")) {
                return KeyProperties.DIGEST_SHA256;
            } else if (transformationUpperCase.endsWith(
                    ""/OAEPWITHSHA-384ANDMGF1PADDING"")) {
                return KeyProperties.DIGEST_SHA384;
            } else if (transformationUpperCase.endsWith(
                    ""/OAEPWITHSHA-512ANDMGF1PADDING"")) {
                return KeyProperties.DIGEST_SHA512;
            } else {
                throw new RuntimeException(""Unsupported OAEP padding scheme: ""
                        + transformation);
            }
        } else {
            return null;
        }
    }

    public static String getCipherEncryptionPadding(String transformation) {
        String transformationUpperCase = transformation.toUpperCase(Locale.US);
        if (transformationUpperCase.endsWith(""/NOPADDING"")) {
            return KeyProperties.ENCRYPTION_PADDING_NONE;
        } else if (transformationUpperCase.endsWith(""/PKCS7PADDING"")) {
            return KeyProperties.ENCRYPTION_PADDING_PKCS7;
        } else if (transformationUpperCase.endsWith(""/PKCS1PADDING"")) {
            return KeyProperties.ENCRYPTION_PADDING_RSA_PKCS1;
        } else if (transformationUpperCase.split(""/"")[2].startsWith(""OAEP"")) {
            return KeyProperties.ENCRYPTION_PADDING_RSA_OAEP;
        } else {
            throw new IllegalArgumentException(""Unsupported transformation: "" + transformation);
        }
    }

    public static String getCipherBlockMode(String transformation) {
        return transformation.split(""/"")[1].toUpperCase(Locale.US);
    }

    public static String getSignatureAlgorithmDigest(String algorithm) {
        String algorithmUpperCase = algorithm.toUpperCase(Locale.US);
        int withIndex = algorithmUpperCase.indexOf(""WITH"");
        if (withIndex == -1) {
            throw new IllegalArgumentException(""Unsupported algorithm: "" + algorithm);
        }
        String digest = algorithmUpperCase.substring(0, withIndex);
        if (digest.startsWith(""SHA"")) {
            digest = ""SHA-"" + digest.substring(""SHA"".length());
        }
        return digest;
    }

    public static String getSignatureAlgorithmPadding(String algorithm) {
        String algorithmUpperCase = algorithm.toUpperCase(Locale.US);
        if (algorithmUpperCase.endsWith(""WITHECDSA"")) {
            return null;
        } else if (algorithmUpperCase.endsWith(""WITHRSA"")) {
            return KeyProperties.SIGNATURE_PADDING_RSA_PKCS1;
        } else if (algorithmUpperCase.endsWith(""WITHRSA/PSS"")) {
            return KeyProperties.SIGNATURE_PADDING_RSA_PSS;
        } else {
            throw new IllegalArgumentException(""Unsupported algorithm: "" + algorithm);
        }
    }

    public static String getSignatureAlgorithmKeyAlgorithm(String algorithm) {
        String algorithmUpperCase = algorithm.toUpperCase(Locale.US);
        if (algorithmUpperCase.endsWith(""WITHECDSA"")) {
            return KeyProperties.KEY_ALGORITHM_EC;
        } else if ((algorithmUpperCase.endsWith(""WITHRSA""))
                || (algorithmUpperCase.endsWith(""WITHRSA/PSS""))) {
            return KeyProperties.KEY_ALGORITHM_RSA;
        } else {
            throw new IllegalArgumentException(""Unsupported algorithm: "" + algorithm);
        }
    }

    public static boolean isKeyLongEnoughForSignatureAlgorithm(String algorithm, int keySizeBits) {
        String keyAlgorithm = getSignatureAlgorithmKeyAlgorithm(algorithm);
        if (KeyProperties.KEY_ALGORITHM_EC.equalsIgnoreCase(keyAlgorithm)) {
            // No length restrictions for ECDSA
            return true;
        } else if (KeyProperties.KEY_ALGORITHM_RSA.equalsIgnoreCase(keyAlgorithm)) {
            String digest = getSignatureAlgorithmDigest(algorithm);
            int digestOutputSizeBits = getDigestOutputSizeBits(digest);
            if (digestOutputSizeBits == -1) {
                // No digesting -- assume the key is long enough for the message
                return true;
            }
            String paddingScheme = getSignatureAlgorithmPadding(algorithm);
            int paddingOverheadBytes;
            if (KeyProperties.SIGNATURE_PADDING_RSA_PKCS1.equalsIgnoreCase(paddingScheme)) {
                paddingOverheadBytes = 30;
            } else if (KeyProperties.SIGNATURE_PADDING_RSA_PSS.equalsIgnoreCase(paddingScheme)) {
                int saltSizeBytes = (digestOutputSizeBits + 7) / 8;
                paddingOverheadBytes = saltSizeBytes + 1;
            } else {
                throw new IllegalArgumentException(
                        ""Unsupported signature padding scheme: "" + paddingScheme);
            }
            int minKeySizeBytes = paddingOverheadBytes + (digestOutputSizeBits + 7) / 8 + 1;
            int keySizeBytes = keySizeBits / 8;
            return keySizeBytes >= minKeySizeBytes;
        } else {
            throw new IllegalArgumentException(""Unsupported key algorithm: "" + keyAlgorithm);
        }
    }

    public static boolean isKeyLongEnoughForSignatureAlgorithm(String algorithm, Key key) {
        return isKeyLongEnoughForSignatureAlgorithm(algorithm, getKeySizeBits(key));
    }

    public static int getMaxSupportedPlaintextInputSizeBytes(String transformation, int keySizeBits) {
        String encryptionPadding = getCipherEncryptionPadding(transformation);
        int modulusSizeBytes = (keySizeBits + 7) / 8;
        if (KeyProperties.ENCRYPTION_PADDING_NONE.equalsIgnoreCase(encryptionPadding)) {
            return modulusSizeBytes - 1;
        } else if (KeyProperties.ENCRYPTION_PADDING_RSA_PKCS1.equalsIgnoreCase(
                encryptionPadding)) {
            return modulusSizeBytes - 11;
        } else if (KeyProperties.ENCRYPTION_PADDING_RSA_OAEP.equalsIgnoreCase(
                encryptionPadding)) {
            String digest = getCipherDigest(transformation);
            int digestOutputSizeBytes = (getDigestOutputSizeBits(digest) + 7) / 8;
            return modulusSizeBytes - 2 * digestOutputSizeBytes - 2;
        } else {
            throw new IllegalArgumentException(
                    ""Unsupported encryption padding scheme: "" + encryptionPadding);
        }

    }

    public static int getMaxSupportedPlaintextInputSizeBytes(String transformation, Key key) {
        String keyAlgorithm = getCipherKeyAlgorithm(transformation);
        if (KeyProperties.KEY_ALGORITHM_AES.equalsIgnoreCase(keyAlgorithm)
                || KeyProperties.KEY_ALGORITHM_3DES.equalsIgnoreCase(keyAlgorithm)) {
            return Integer.MAX_VALUE;
        } else if (KeyProperties.KEY_ALGORITHM_RSA.equalsIgnoreCase(keyAlgorithm)) {
            return getMaxSupportedPlaintextInputSizeBytes(transformation, getKeySizeBits(key));
        } else {
            throw new IllegalArgumentException(""Unsupported key algorithm: "" + keyAlgorithm);
        }
    }

    public static int getDigestOutputSizeBits(String digest) {
        if (KeyProperties.DIGEST_NONE.equals(digest)) {
            return -1;
        } else if (KeyProperties.DIGEST_MD5.equals(digest)) {
            return 128;
        } else if (KeyProperties.DIGEST_SHA1.equals(digest)) {
            return 160;
        } else if (KeyProperties.DIGEST_SHA224.equals(digest)) {
            return 224;
        } else if (KeyProperties.DIGEST_SHA256.equals(digest)) {
            return 256;
        } else if (KeyProperties.DIGEST_SHA384.equals(digest)) {
            return 384;
        } else if (KeyProperties.DIGEST_SHA512.equals(digest)) {
            return 512;
        } else {
            throw new IllegalArgumentException(""Unsupported digest: "" + digest);
        }
    }

    public static byte[] concat(byte[] arr1, byte[] arr2) {
        return concat(arr1, 0, (arr1 != null) ? arr1.length : 0,
                arr2, 0, (arr2 != null) ? arr2.length : 0);
    }

    public static byte[] concat(byte[] arr1, int offset1, int len1,
            byte[] arr2, int offset2, int len2) {
        if (len1 == 0) {
            return subarray(arr2, offset2, len2);
        } else if (len2 == 0) {
            return subarray(arr1, offset1, len1);
        }
        byte[] result = new byte[len1 + len2];
        if (len1 > 0) {
            System.arraycopy(arr1, offset1, result, 0, len1);
        }
        if (len2 > 0) {
            System.arraycopy(arr2, offset2, result, len1, len2);
        }
        return result;
    }

    public static byte[] subarray(byte[] arr, int offset, int len) {
        if (len == 0) {
            return EmptyArray.BYTE;
        }
        if ((offset == 0) && (arr.length == len)) {
            return arr;
        }
        byte[] result = new byte[len];
        System.arraycopy(arr, offset, result, 0, len);
        return result;
    }

    public static KeyProtection getMinimalWorkingImportParametersForSigningingWith(
            String signatureAlgorithm) {
        String keyAlgorithm = getSignatureAlgorithmKeyAlgorithm(signatureAlgorithm);
        String digest = getSignatureAlgorithmDigest(signatureAlgorithm);
        if (KeyProperties.KEY_ALGORITHM_EC.equalsIgnoreCase(keyAlgorithm)) {
            return new KeyProtection.Builder(KeyProperties.PURPOSE_SIGN)
                    .setDigests(digest)
                    .build();
        } else if (KeyProperties.KEY_ALGORITHM_RSA.equalsIgnoreCase(keyAlgorithm)) {
            String padding = getSignatureAlgorithmPadding(signatureAlgorithm);
            return new KeyProtection.Builder(KeyProperties.PURPOSE_SIGN)
                    .setDigests(digest)
                    .setSignaturePaddings(padding)
                    .build();
        } else {
            throw new IllegalArgumentException(
                    ""Unsupported signature algorithm: "" + signatureAlgorithm);
        }
    }

    public static KeyProtection getMinimalWorkingImportParametersWithLimitedUsageForSigningingWith(
            String signatureAlgorithm, int maxUsageCount) {
        String keyAlgorithm = getSignatureAlgorithmKeyAlgorithm(signatureAlgorithm);
        String digest = getSignatureAlgorithmDigest(signatureAlgorithm);
        if (KeyProperties.KEY_ALGORITHM_EC.equalsIgnoreCase(keyAlgorithm)) {
            return new KeyProtection.Builder(KeyProperties.PURPOSE_SIGN)
                    .setDigests(digest)
                    .setMaxUsageCount(maxUsageCount)
                    .build();
        } else if (KeyProperties.KEY_ALGORITHM_RSA.equalsIgnoreCase(keyAlgorithm)) {
            String padding = getSignatureAlgorithmPadding(signatureAlgorithm);
            return new KeyProtection.Builder(KeyProperties.PURPOSE_SIGN)
                    .setDigests(digest)
                    .setSignaturePaddings(padding)
                    .setMaxUsageCount(maxUsageCount)
                    .build();
        } else {
            throw new IllegalArgumentException(
                    ""Unsupported signature algorithm: "" + signatureAlgorithm);
        }
    }

    public static KeyProtection getMinimalWorkingImportParametersForCipheringWith(
            String transformation, int purposes) {
        return getMinimalWorkingImportParametersForCipheringWith(transformation, purposes, false);
    }

    public static KeyProtection getMinimalWorkingImportParametersForCipheringWith(
            String transformation, int purposes, boolean ivProvidedWhenEncrypting) {
        return getMinimalWorkingImportParametersForCipheringWith(transformation, purposes,
            ivProvidedWhenEncrypting, false, false);
    }

    public static KeyProtection getMinimalWorkingImportParametersForCipheringWith(
            String transformation, int purposes, boolean ivProvidedWhenEncrypting,
            boolean isUnlockedDeviceRequired, boolean isUserAuthRequired) {
        String keyAlgorithm = TestUtils.getCipherKeyAlgorithm(transformation);
        if (KeyProperties.KEY_ALGORITHM_AES.equalsIgnoreCase(keyAlgorithm)
            || KeyProperties.KEY_ALGORITHM_3DES.equalsIgnoreCase(keyAlgorithm)) {
            String encryptionPadding = TestUtils.getCipherEncryptionPadding(transformation);
            String blockMode = TestUtils.getCipherBlockMode(transformation);
            boolean randomizedEncryptionRequired = true;
            if (KeyProperties.BLOCK_MODE_ECB.equalsIgnoreCase(blockMode)) {
                randomizedEncryptionRequired = false;
            } else if ((ivProvidedWhenEncrypting)
                    && ((purposes & KeyProperties.PURPOSE_ENCRYPT) != 0)) {
                randomizedEncryptionRequired = false;
            }
            return new KeyProtection.Builder(
                    purposes)
                    .setBlockModes(blockMode)
                    .setEncryptionPaddings(encryptionPadding)
                    .setRandomizedEncryptionRequired(randomizedEncryptionRequired)
                    .setUnlockedDeviceRequired(isUnlockedDeviceRequired)
                    .setUserAuthenticationRequired(isUserAuthRequired)
                    .setUserAuthenticationValidityDurationSeconds(3600)
                    .build();
        } else if (KeyProperties.KEY_ALGORITHM_RSA.equalsIgnoreCase(keyAlgorithm)) {
            String digest = TestUtils.getCipherDigest(transformation);
            String encryptionPadding = TestUtils.getCipherEncryptionPadding(transformation);
            boolean randomizedEncryptionRequired =
                    !KeyProperties.ENCRYPTION_PADDING_NONE.equalsIgnoreCase(encryptionPadding);
            return new KeyProtection.Builder(
                    purposes)
                    .setDigests((digest != null) ? new String[] {digest} : EmptyArray.STRING)
                    .setEncryptionPaddings(encryptionPadding)
                    .setRandomizedEncryptionRequired(randomizedEncryptionRequired)
                    .setUserAuthenticationRequired(isUserAuthRequired)
                    .setUserAuthenticationValidityDurationSeconds(3600)
                    .setUnlockedDeviceRequired(isUnlockedDeviceRequired)
                    .build();
        } else {
            throw new IllegalArgumentException(""Unsupported key algorithm: "" + keyAlgorithm);
        }
    }

    public static byte[] getBigIntegerMagnitudeBytes(BigInteger value) {
        return removeLeadingZeroByteIfPresent(value.toByteArray());
    }

    private static byte[] removeLeadingZeroByteIfPresent(byte[] value) {
        if ((value.length < 1) || (value[0] != 0)) {
            return value;
        }
        return TestUtils.subarray(value, 1, value.length - 1);
    }

    public static byte[] generateRandomMessage(int messageSize) {
        byte[] message = new byte[messageSize];
        new SecureRandom().nextBytes(message);
        return message;
    }

    public static boolean isAttestationSupported() {
        return Build.VERSION.DEVICE_INITIAL_SDK_INT >= Build.VERSION_CODES.O;
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/util/TestUtils.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telecom.cts.CtsConnectionService"	"isServiceRegisteredToTelecom"	"CtsTelecomTestCases"	"1: ui"	"public void test/*
 *.
 */

package android.telecom.cts;

import static org.junit.Assert.assertTrue;

import android.content.Intent;
import android.os.IBinder;
import android.telecom.Conference;
import android.telecom.Connection;
import android.telecom.ConnectionRequest;
import android.telecom.ConnectionService;
import android.telecom.PhoneAccountHandle;
import android.telecom.RemoteConference;
import android.telecom.RemoteConnection;
import android.util.Log;

import java.util.Collection;
import java.util.Collections;
import java.util.concurrent.CountDownLatch;

/**
 * This is the official ConnectionService for Telecom's CTS App. Since telecom requires that a
 * CS be registered in the AndroidManifest.xml file, we have to have a single implementation
 * of a CS and this is it. To test specific CS behavior, tests will implement their own CS and
 * tell CtsConnectionService to forward any method invocations to that test's implementation.
 * This is set up using {@link #setUp} and should be cleaned up before the end of the test using
 * {@link #tearDown}.
 *
 * sConnectionService: Contains the connection service object provided by the current test in
 *                     progress. We use this object to forward any communication received from the
 *                     Telecom framework to the test connection service.
 * sTelecomConnectionService: Contains the connection service object registered to the Telecom
 *                            framework. We use this object to forward any communication from the
 *                            test connection service to the Telecom framework. After Telecom
 *                            binds to CtsConnectionService, this is set to be the instance of
 *                            CtsConnectionService created by the framework after Telecom binds.
 */
public class CtsConnectionService extends ConnectionService {
    private static String LOG_TAG = ""CtsConnectionService"";
    // This is the connection service implemented by the test
    private static ConnectionService sConnectionService;
    // This is the connection service registered with Telecom
    private static ConnectionService sTelecomConnectionService;
    private static boolean sIsBound = false;
    private static CountDownLatch sServiceUnBoundLatch = new CountDownLatch(1);

    @Override
    public void onBindClient(Intent intent) {
        sTelecomConnectionService = this;
        Log.i(""TelecomCTS"", ""CS bound"");
        sIsBound = true;
    }

    private static Object sLock = new Object();

    public static void setUp(ConnectionService connectionService) throws Exception {
        synchronized(sLock) {
            if (sConnectionService != null) {
                throw new Exception(""Mock ConnectionService exists.  Failed to call setUp()."");
            }
            sConnectionService = connectionService;
        }
    }

    public static void tearDown() {
        synchronized(sLock) {
            sConnectionService = null;
        }
    }

    @Override
    public Connection onCreateOutgoingConnection(PhoneAccountHandle connectionManagerPhoneAccount,
            ConnectionRequest request) {
        synchronized(sLock) {
            if (sConnectionService != null) {
                return sConnectionService.onCreateOutgoingConnection(
                        connectionManagerPhoneAccount, request);
            } else {
                Log.e(LOG_TAG,
                        ""Tried to create outgoing connection when sConnectionService null!"");
                return null;
            }
        }
    }

    @Override
    public Connection onCreateIncomingConnection(PhoneAccountHandle connectionManagerPhoneAccount,
            ConnectionRequest request) {
        synchronized(sLock) {
            if (sConnectionService != null) {
                return sConnectionService.onCreateIncomingConnection(
                        connectionManagerPhoneAccount, request);
            } else {
                Log.e(LOG_TAG,
                        ""Tried to create incoming connection when sConnectionService null!"");
                return null;
            }
        }
    }

    @Override
    public void onCreateIncomingConnectionFailed(PhoneAccountHandle connectionManagerPhoneAccount,
            ConnectionRequest request) {
        if (sConnectionService != null) {
            sConnectionService.onCreateIncomingConnectionFailed(connectionManagerPhoneAccount,
                    request);
        } else {
            Log.e(LOG_TAG,
                    ""onCreateIncomingConnectionFailed called when sConnectionService null!"");
        }
    }

    @Override
    public Conference onCreateOutgoingConference(PhoneAccountHandle connectionManagerPhoneAccount,
            ConnectionRequest request) {
        synchronized (sLock) {
            if (sConnectionService != null) {
                return sConnectionService.onCreateOutgoingConference(connectionManagerPhoneAccount,
                        request);
            } else {
                Log.e(LOG_TAG,
                        ""onCreateOutgoingConference called when sConnectionService null!"");
                return null;
            }
        }
    }

    @Override
    public void onCreateOutgoingConferenceFailed(PhoneAccountHandle connectionManagerPhoneAccount,
            ConnectionRequest request) {
        synchronized (sLock) {
            if (sConnectionService != null) {
                sConnectionService.onCreateOutgoingConferenceFailed(connectionManagerPhoneAccount,
                        request);
            } else {
                Log.e(LOG_TAG,
                        ""onCreateOutgoingConferenceFailed called when sConnectionService null!"");
            }
        }
    }

    @Override
    public Conference onCreateIncomingConference(PhoneAccountHandle connectionManagerPhoneAccount,
            ConnectionRequest request) {
        synchronized (sLock) {
            if (sConnectionService != null) {
                return sConnectionService.onCreateIncomingConference(connectionManagerPhoneAccount,
                        request);
            } else {
                Log.e(LOG_TAG,
                        ""onCreateIncomingConference called when sConnectionService null!"");
                return null;
            }
        }
    }

    @Override
    public void onCreateIncomingConferenceFailed(PhoneAccountHandle connectionManagerPhoneAccount,
            ConnectionRequest request) {
        synchronized (sLock) {
            if (sConnectionService != null) {
                sConnectionService.onCreateIncomingConferenceFailed(connectionManagerPhoneAccount,
                        request);
            } else {
                Log.e(LOG_TAG,
                        ""onCreateIncomingConferenceFailed called when sConnectionService null!"");
            }
        }
    }

    @Override
    public void onConference(Connection connection1, Connection connection2) {
        synchronized(sLock) {
            if (sConnectionService != null) {
                sConnectionService.onConference(connection1, connection2);
            } else {
                Log.e(LOG_TAG,
                        ""onConference called when sConnectionService null!"");
            }
        }
    }

    @Override
    public void onRemoteExistingConnectionAdded(RemoteConnection connection) {
        synchronized(sLock) {
            if (sConnectionService != null) {
                sConnectionService.onRemoteExistingConnectionAdded(connection);
            } else {
                Log.e(LOG_TAG,
                        ""onRemoteExistingConnectionAdded called when sConnectionService null!"");
            }
        }
    }

    public static void addConferenceToTelecom(Conference conference) {
        synchronized(sLock) {
            if (sTelecomConnectionService != null) {
                sTelecomConnectionService.addConference(conference);
            } else {
                Log.e(LOG_TAG, ""addConferenceToTelecom called when""
                        + "" sTelecomConnectionService null!"");
            }
        }
    }

    public static void addExistingConnectionToTelecom(
            PhoneAccountHandle phoneAccountHandle, Connection connection) {
        synchronized(sLock) {
            if (sTelecomConnectionService != null) {
                sTelecomConnectionService.addExistingConnection(phoneAccountHandle, connection);
            } else {
                Log.e(LOG_TAG, ""addExistingConnectionToTelecom called when""
                        + "" sTelecomConnectionService null!"");
            }
        }
    }

    public static Collection<Connection> getAllConnectionsFromTelecom() {
        synchronized(sLock) {
            if (sTelecomConnectionService == null) {
                return Collections.EMPTY_LIST;
            }
            return sTelecomConnectionService.getAllConnections();
        }
    }

    public static RemoteConnection createRemoteOutgoingConnectionToTelecom(
            PhoneAccountHandle connectionManagerPhoneAccount,
            ConnectionRequest request) {
        synchronized(sLock) {
            if (sTelecomConnectionService != null) {
                return sTelecomConnectionService.createRemoteOutgoingConnection(
                        connectionManagerPhoneAccount, request);
            } else {
                Log.e(LOG_TAG, ""createRemoteOutgoingConnectionToTelecom called when""
                        + "" sTelecomConnectionService null!"");
                return null;
            }
        }
    }

    public static RemoteConnection createRemoteIncomingConnectionToTelecom(
            PhoneAccountHandle connectionManagerPhoneAccount,
            ConnectionRequest request) {
        synchronized(sLock) {
            if (sTelecomConnectionService != null) {
                return sTelecomConnectionService.createRemoteIncomingConnection(
                        connectionManagerPhoneAccount, request);
            } else {
                Log.e(LOG_TAG, ""createRemoteIncomingConnectionToTelecom called when""
                        + "" sTelecomConnectionService null!"");
                return null;
            }
        }
    }

    public static RemoteConference createRemoteIncomingConferenceToTelecom(
            PhoneAccountHandle connectionManagerPhoneAccount,
            ConnectionRequest request) {
        synchronized (sLock) {
            if (sTelecomConnectionService != null) {
                return sTelecomConnectionService.createRemoteIncomingConference(
                        connectionManagerPhoneAccount, request);
            } else {
                Log.e(LOG_TAG, ""createRemoteIncomingConferenceToTelecom called when""
                        + "" sTelecomConnectionService null!"");
                return null;
            }
        }
    }


    public static RemoteConference createRemoteOutgoingConferenceToTelecom(
            PhoneAccountHandle connectionManagerPhoneAccount,
            ConnectionRequest request) {
        synchronized (sLock) {
            if (sTelecomConnectionService != null) {
                return sTelecomConnectionService.createRemoteOutgoingConference(
                        connectionManagerPhoneAccount, request);
            } else {
                Log.e(LOG_TAG, ""createRemoteOutgoingConferenceToTelecom called when""
                        + "" sTelecomConnectionService null!"");
                return null;
            }
        }
    }

    @Override
    public void onRemoteConferenceAdded(RemoteConference conference) {
        synchronized(sLock) {
            if (sConnectionService != null) {
                sConnectionService.onRemoteConferenceAdded(conference);
            } else {
                Log.e(LOG_TAG,
                        ""onRemoteConferenceAdded called when sConnectionService null!"");
            }
        }
    }

    @Override
    public void onConnectionServiceFocusGained() {
        synchronized (sLock) {
            if (sConnectionService != null) {
                sConnectionService.onConnectionServiceFocusGained();
            } else {
                Log.e(LOG_TAG,
                        ""onConnectionServiceFocusGained called when sConnectionService null!"");
            }
        }
    }

    @Override
    public void onConnectionServiceFocusLost() {
        synchronized (sLock) {
            if (sConnectionService != null) {
                sConnectionService.onConnectionServiceFocusLost();
            } else {
                Log.e(LOG_TAG,
                        ""onConnectionServiceFocusLost called when sConnectionService null!"");
            }
        }
    }

    @Override
    public boolean onUnbind(Intent intent) {
        synchronized (sLock) {
            Log.i(LOG_TAG, ""Service has been unbound"");
            sIsBound = false;
            sServiceUnBoundLatch.countDown();
            sConnectionService = null;
            sTelecomConnectionService = null;
            return super.onUnbind(intent);
        }
    }

    public static boolean isServiceRegisteredToTelecom() {
        return sTelecomConnectionService != null;
    }

    public static boolean isBound() {
        return sIsBound;
    }

    public static boolean waitForUnBinding() {
        return TestUtils.waitForLatchCountDown(sServiceUnBoundLatch);
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/CtsConnectionService.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.appsecurity.cts.ReadableSettingsFieldsTest"	"testSystemNonHiddenSettingsKeysAreReadable"	"CtsAppSecurityHostTestCases"	"1: system"	"public void testSystemNonHiddenSettingsKeysAreReadable() throws DeviceNotAvailableException {
        runDeviceTests(TEST_PACKAGE, TEST_CLASS, ""testSystemNonHiddenSettingsKeysAreReadable"");
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ReadableSettingsFieldsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.appsecurity.cts.ReadableSettingsFieldsTest"	"testSystemSomeHiddenSettingsKeysAreReadable"	"CtsAppSecurityHostTestCases"	"1: system"	"public void testSystemSomeHiddenSettingsKeysAreReadable() throws DeviceNotAvailableException {
        runDeviceTests(TEST_PACKAGE, TEST_CLASS, ""testSystemSomeHiddenSettingsKeysAreReadable"");
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ReadableSettingsFieldsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.appsecurity.cts.ReadableSettingsFieldsTest"	"testSystemHiddenSettingsKeysNotReadableWithoutAnnotation"	"CtsAppSecurityHostTestCases"	"1: system"	"public void testSystemHiddenSettingsKeysNotReadableWithoutAnnotation()
            throws DeviceNotAvailableException {
        runDeviceTests(TEST_PACKAGE, TEST_CLASS,
                ""testSystemHiddenSettingsKeysNotReadableWithoutAnnotation"");
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ReadableSettingsFieldsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.appsecurity.cts.ReadableSettingsFieldsTest"	"testSystemHiddenSettingsKeysReadableWhenTestOnly"	"CtsAppSecurityHostTestCases"	"1: system"	"public void testSystemHiddenSettingsKeysReadableWhenTestOnly()
            throws DeviceNotAvailableException, FileNotFoundException {
        new InstallMultiple().addFile(TEST_APK_TEST_ONLY).addArg(""-t"").run();
        runDeviceTests(TEST_PACKAGE, TEST_CLASS,
                ""testSystemHiddenSettingsKeysReadableWithoutAnnotation"");
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/ReadableSettingsFieldsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.runner.CtsTestRunListener"	"disableKeyguard"	""	"2: ui system"	"public void testRunStarted(Description description) throws Exception {
        mEnvironment = new TestEnvironment(getInstrumentation().getTargetContext());

        // We might want to move this to /sdcard, if is is mounted/writable.
        File cacheDir = getInstrumentation().getTargetContext().getCacheDir();
        System.setProperty(""java.io.tmpdir"", cacheDir.getAbsolutePath());

        // attempt to disable keyguard, if current test has permission to do so
        // TODO: move this to a better place, such as InstrumentationTestRunner
        // ?
        if (getInstrumentation().getContext().checkCallingOrSelfPermission(
                android.Manifest.permission.DISABLE_KEYGUARD)
                == PackageManager.PERMISSION_GRANTED) {
            Log.i(TAG, ""Disabling keyguard"");
            KeyguardManager keyguardManager =
                    (KeyguardManager) getInstrumentation().getContext().getSystemService(
                            Context.KEYGUARD_SERVICE);
            keyguardManager.newKeyguardLock(""cts"").disableKeyguard();
        } else {
            Log.i(TAG, ""Test lacks permission to disable keyguard. "" +
                    ""UI based tests may fail if keyguard is up"");
        }
    }

    @Override"	"/home/gpoor/cts-12-source/cts/tests/core/runner-axt/src/com/android/cts/runner/CtsTestRunListener.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.runner.CtsTestRunListener"	"isPrimitive"	""	"2: system user"	"public void testFinished(Description description) {
        // no way to implement this in JUnit4...
        // offending test cases that need this logic should probably be cleaned
        // up individually
        // if (test instanceof TestCase) {
        // cleanup((TestCase) test);
        // }
    }

    /**
     * Dumps some memory info.
     */
    private void printMemory(Class<?> testClass) {
        Runtime runtime = Runtime.getRuntime();

        long total = runtime.totalMemory();
        long free = runtime.freeMemory();
        long used = total - free;

        Log.d(TAG, ""Total memory  : "" + total);
        Log.d(TAG, ""Used memory   : "" + used);
        Log.d(TAG, ""Free memory   : "" + free);

        String tempdir = System.getProperty(""java.io.tmpdir"", """");
        // TODO: Remove these extra Logs added to debug a specific timeout problem.
        Log.d(TAG, ""java.io.tmpdir is:"" + tempdir);

        if (!TextUtils.isEmpty(tempdir)) {
            String[] commands = {""df"", tempdir};
            BufferedReader in = null;
            try {
                Log.d(TAG, ""About to .exec df"");
                Process proc = runtime.exec(commands);
                Log.d(TAG, "".exec returned"");
                in = new BufferedReader(new InputStreamReader(proc.getInputStream()));
                Log.d(TAG, ""Stream reader created"");
                String line;
                while ((line = in.readLine()) != null) {
                    Log.d(TAG, line);
                }
            } catch (IOException e) {
                Log.d(TAG, ""Exception: "" + e.toString());
                // Well, we tried
            } finally {
                Log.d(TAG, ""In finally"");
                if (in != null) {
                    try {
                        in.close();
                    } catch (IOException e) {
                        // Meh
                    }
                }
            }
        }

        Log.d(TAG, ""Now executing : "" + testClass.getName());
    }

    /**
     * Nulls all non-static reference fields in the given test class. This
     * method helps us with those test classes that don't have an explicit
     * tearDown() method. Normally the garbage collector should take care of
     * everything, but since JUnit keeps references to all test cases, a little
     * help might be a good idea.
     */
    private void cleanup(TestCase test) {
        Class<?> clazz = test.getClass();

        while (clazz != TestCase.class) {
            Field[] fields = clazz.getDeclaredFields();
            for (int i = 0; i < fields.length; i++) {
                Field f = fields[i];
                if (!f.getType().isPrimitive() &&
                        !Modifier.isStatic(f.getModifiers())) {
                    try {
                        f.setAccessible(true);
                        f.set(test, null);
                    } catch (Exception ignored) {
                        // Nothing we can do about it.
                    }
                }
            }

            clazz = clazz.getSuperclass();
        }
    }

    private interface TestEnvironmentResetter {
        Boolean getDateFormatIs24Hour();
        void setDateFormatIs24Hour(Boolean value);
        Properties createDefaultProperties();
    }

    private static class AndroidTestEnvironmentResetter implements TestEnvironmentResetter {
        private final Field mDateFormatIs24HourField;

        AndroidTestEnvironmentResetter() {
            try {
                Class<?> dateFormatClass = Class.forName(""java.text.DateFormat"");
                mDateFormatIs24HourField = dateFormatClass.getDeclaredField(""is24Hour"");
            } catch (ReflectiveOperationException e) {
                throw new AssertionError(""Missing DateFormat.is24Hour"", e);
            }
        }

        @Override
        public Boolean getDateFormatIs24Hour() {
            try {
                return (Boolean) mDateFormatIs24HourField.get(null);
            } catch (ReflectiveOperationException e) {
                throw new AssertionError(""Unable to get java.text.DateFormat.is24Hour"", e);
            }
        }

        @Override
        public void setDateFormatIs24Hour(Boolean value) {
            try {
                mDateFormatIs24HourField.set(null, value);
            } catch (ReflectiveOperationException e) {
                throw new AssertionError(""Unable to set java.text.DateFormat.is24Hour"", e);
            }
        }

        @Override
        public Properties createDefaultProperties() {
            return new Properties();
        }
    }

    private static class StubTestEnvironmentResetter implements TestEnvironmentResetter {
        @Override
        public Boolean getDateFormatIs24Hour() {
            return false;
        }

        @Override
        public void setDateFormatIs24Hour(Boolean value) {
        }

        @Override
        public Properties createDefaultProperties() {
            return System.getProperties();
        }
    }

    // http://code.google.com/p/vogar/source/browse/trunk/src/vogar/target/TestEnvironment.java
    static class TestEnvironment {
        private final static TestEnvironmentResetter sTestEnvironmentResetter;
        static {
            if (System.getProperty(""java.vendor"").toLowerCase().contains(""android"")) {
                sTestEnvironmentResetter = new AndroidTestEnvironmentResetter();
            } else {
                sTestEnvironmentResetter = new StubTestEnvironmentResetter();
            }
        }

        private final Locale mDefaultLocale;
        private final TimeZone mDefaultTimeZone;
        private final HostnameVerifier mHostnameVerifier;
        private final SSLSocketFactory mSslSocketFactory;
        private final Properties mProperties;
        private final Boolean mDefaultIs24Hour;

        TestEnvironment(Context context) {
            mDefaultLocale = Locale.getDefault();
            mDefaultTimeZone = TimeZone.getDefault();
            mHostnameVerifier = HttpsURLConnection.getDefaultHostnameVerifier();
            mSslSocketFactory = HttpsURLConnection.getDefaultSSLSocketFactory();

            mProperties = sTestEnvironmentResetter.createDefaultProperties();
            mProperties.setProperty(""user.home"", """");
            mProperties.setProperty(""java.io.tmpdir"", context.getCacheDir().getAbsolutePath());
            // The CDD mandates that devices that support WiFi are the only ones that will have
            // multicast.
            PackageManager pm = context.getPackageManager();
            mProperties.setProperty(""android.cts.device.multicast"",
                    Boolean.toString(pm.hasSystemFeature(PackageManager.FEATURE_WIFI)));
            mDefaultIs24Hour = sTestEnvironmentResetter.getDateFormatIs24Hour();

            // There are tests in libcore that should be disabled for low ram devices. They can't
            // access ActivityManager to call isLowRamDevice, but can read system properties.
            ActivityManager activityManager =
                    (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
            mProperties.setProperty(""android.cts.device.lowram"",
                    Boolean.toString(activityManager.isLowRamDevice()));
        }

        void reset() {
            System.setProperties(null);
            System.setProperties(mProperties);
            Locale.setDefault(mDefaultLocale);
            TimeZone.setDefault(mDefaultTimeZone);
            Authenticator.setDefault(null);
            CookieHandler.setDefault(null);
            ResponseCache.setDefault(null);
            HttpsURLConnection.setDefaultHostnameVerifier(mHostnameVerifier);
            HttpsURLConnection.setDefaultSSLSocketFactory(mSslSocketFactory);
            sTestEnvironmentResetter.setDateFormatIs24Hour(mDefaultIs24Hour);
        }
    }
}"	"/home/gpoor/cts-12-source/cts/tests/core/runner-axt/src/com/android/cts/runner/CtsTestRunListener.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.devicepolicy.QuietModeHostsideTest"	"wakeupAndDismissKeyguard"	"CtsDevicePolicyManagerTestCases"	"3: apps ui user"	"package com.android.cts.devicepolicy;

import static com.android.cts.devicepolicy.DeviceAdminFeaturesCheckerRule.FEATURE_MANAGED_USERS;

import static com.google.common.truth.Truth.assertThat;

import android.platform.test.annotations.LargeTest;

import com.android.cts.devicepolicy.DeviceAdminFeaturesCheckerRule.RequiresAdditionalFeatures;
import com.android.tradefed.device.DeviceNotAvailableException;

import org.junit.Test;

import java.io.FileNotFoundException;
import java.util.HashMap;
import java.util.Map;

/**
 * CTS to verify toggling quiet mode in work profile by using
 * {@link android.os.UserManager#requestQuietModeEnabled(boolean, android.os.UserHandle)}.
 */
@RequiresAdditionalFeatures({FEATURE_MANAGED_USERS})
public class QuietModeHostsideTest extends BaseDevicePolicyTest {
    private static final String TEST_PACKAGE = ""com.android.cts.launchertests"";
    private static final String TEST_CLASS = "".QuietModeTest"";
    private static final String PARAM_TARGET_USER = ""TARGET_USER"";
    private static final String PARAM_ORIGINAL_DEFAULT_LAUNCHER = ""ORIGINAL_DEFAULT_LAUNCHER"";
    private static final String TEST_APK = ""CtsLauncherAppsTests.apk"";

    private static final String TEST_LAUNCHER_PACKAGE = ""com.android.cts.launchertests.support"";
    private static final String TEST_LAUNCHER_APK = ""CtsLauncherAppsTestsSupport.apk"";
    private static final String ENABLED_TEST_APK = ""CtsCrossProfileEnabledApp.apk"";
    private static final String USER_ENABLED_TEST_APK = ""CtsCrossProfileUserEnabledApp.apk"";
    private static final String ENABLED_NO_PERMS_TEST_APK = ""CtsCrossProfileEnabledNoPermsApp.apk"";
    private static final String QUIET_MODE_ENABLED_TEST_APK = ""CtsModifyQuietModeEnabledApp.apk"";
    private static final String NOT_ENABLED_TEST_APK = ""CtsCrossProfileNotEnabledApp.apk"";
    private static final String ENABLED_TEST_PACKAGE = ""com.android.cts.crossprofileenabledapp"";
    private static final String USER_ENABLED_TEST_PACKAGE =
            ""com.android.cts.crossprofileuserenabledapp"";
    private static final String ENABLED_NO_PERMS_TEST_PACKAGE =
            ""com.android.cts.crossprofileenablednopermsapp"";
    private static final String NOT_ENABLED_TEST_PACKAGE =
            ""com.android.cts.crossprofilenotenabledapp"";
    private static final String QUIET_MODE_ENABLED_TEST_PACKAGE =
            ""com.android.cts.modifyquietmodeenabledapp"";

    private int mProfileId;
    private String mOriginalLauncher;

    @Override
    public void setUp() throws Exception {
        super.setUp();

        mOriginalLauncher = getDefaultLauncher();

        installAppAsUser(TEST_APK, mPrimaryUserId);
        installAppAsUser(TEST_LAUNCHER_APK, mPrimaryUserId);

        waitForBroadcastIdle();

        createAndStartManagedProfile();
        installAppAsUser(TEST_APK, mProfileId);

        waitForBroadcastIdle();
        wakeupAndDismissKeyguard();
    }

    @Override
    public void tearDown() throws Exception {
        uninstallRequiredApps();
        getDevice().uninstallPackage(TEST_LAUNCHER_PACKAGE);

        super.tearDown();
    }

    @LargeTest"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/QuietModeHostsideTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.devicepolicy.QuietModeHostsideTest"	"testBroadcastManagedProfileAvailable_withoutCrossProfileAppsOp"	"CtsDevicePolicyManagerTestCases"	"1: apps"	"public void testBroadcastManagedProfileAvailable_withoutCrossProfileAppsOp() throws Exception {
        checkBroadcastManagedProfileAvailable(/* withCrossProfileAppOps= */ false);
    }


    @LargeTest"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/QuietModeHostsideTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.devicepolicy.QuietModeHostsideTest"	"testBroadcastManagedProfileAvailable_withCrossProfileAppsOp"	"CtsDevicePolicyManagerTestCases"	"3: apps ui user"	"public void testBroadcastManagedProfileAvailable_withCrossProfileAppsOp() throws Exception {
        checkBroadcastManagedProfileAvailable(/* withCrossProfileAppOps= */ true);
    }

    private void checkBroadcastManagedProfileAvailable(boolean withCrossProfileAppOps)
            throws Exception {
        installCrossProfileApps();
        if (withCrossProfileAppOps) {
            enableCrossProfileAppsOp();
        }
        clearLogcat();
        runDeviceTestsAsUser(
                TEST_PACKAGE,
                TEST_CLASS,
                ""testTryEnableQuietMode"",
                mPrimaryUserId,
                createParams(mProfileId));
        // In case of a necessary log is not captured
        // cause of too many logs while waiting idle broadcast, capture log previously.
        // This log will be concatenated.
        String log = getDevice().executeAdbCommand(""logcat"", ""-d"");
        waitForBroadcastIdle();
        verifyBroadcastSent(""android.intent.action.MANAGED_PROFILE_UNAVAILABLE"",
                /* needPermissions= */ !withCrossProfileAppOps, log);

        clearLogcat();
        runDeviceTestsAsUser(
                TEST_PACKAGE,
                TEST_CLASS,
                ""testTryDisableQuietMode"",
                mPrimaryUserId,
                createParams(mProfileId));
        log = getDevice().executeAdbCommand(""logcat"", ""-d"");
        waitForBroadcastIdle();
        verifyBroadcastSent(""android.intent.action.MANAGED_PROFILE_AVAILABLE"",
                /* needPermissions= */ !withCrossProfileAppOps, log);

        clearLogcat();
        removeUser(mProfileId);
        log = getDevice().executeAdbCommand(""logcat"", ""-d"");
        waitForBroadcastIdle();
        verifyBroadcastSent(""android.intent.action.MANAGED_PROFILE_REMOVED"",
                /* needPermissions= */ false, log);
    }

    private void clearLogcat() throws DeviceNotAvailableException {
        getDevice().executeAdbCommand(""logcat"", ""-c"");
        getDevice().executeAdbCommand(""logcat"", ""-G"", ""16M"");
    }

    private void verifyBroadcastSent(String actionName, boolean needPermissions, String prevLog)
            throws DeviceNotAvailableException {
        String result = getDevice().executeAdbCommand(""logcat"", ""-d"");
        result = prevLog + result;
        assertThat(result).contains(
                buildReceivedBroadcastRegex(actionName, ""CrossProfileEnabledAppReceiver""));
        assertThat(result).contains(
                buildReceivedBroadcastRegex(actionName, ""CrossProfileUserEnabledAppReceiver""));
        String noPermsString = buildReceivedBroadcastRegex(actionName,
                ""CrossProfileEnabledNoPermsAppReceiver"");
        if (needPermissions) {
            assertThat(result).doesNotContain(noPermsString);
        } else {
            assertThat(result).contains(noPermsString);
        }
        assertThat(result).doesNotContain(
                buildReceivedBroadcastRegex(actionName,
                        ""CrossProfileNotEnabledAppReceiver""));
        assertThat(result).contains(
                buildReceivedBroadcastRegex(actionName, ""ModifyQuietModeEnabledAppReceiver""));
    }

    private String buildReceivedBroadcastRegex(String actionName, String className) {
        return String.format(""%s: onReceive(%s)"", className, actionName);
    }

    @LargeTest"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/QuietModeHostsideTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.devicepolicy.QuietModeHostsideTest"	"testQuietMode_noCredentialRequest"	"CtsDevicePolicyManagerTestCases"	"3: apps ui user"	"public void testQuietMode_noCredentialRequest() throws Exception {
        assumeHasSecureLockScreenFeature();

        // Set a separate work challenge so turning on the profile requires entering the
        // separate challenge.
        changeUserCredential(/* newCredential= */ TEST_PASSWORD, /* oldCredential= */ null,
                mProfileId);
        runDeviceTestsAsUser(
                TEST_PACKAGE,
                TEST_CLASS,
                ""testTryEnableQuietMode_noCredentialRequest"",
                mPrimaryUserId,
                createParams(mProfileId));
    }

    private void createAndStartManagedProfile() throws Exception {
        mProfileId = createManagedProfile(mPrimaryUserId);
        switchUser(mPrimaryUserId);
        startUser(mProfileId);
    }

    private void uninstallRequiredApps()
            throws DeviceNotAvailableException {
        getDevice().uninstallPackage(TEST_PACKAGE);
        getDevice().uninstallPackage(ENABLED_TEST_PACKAGE);
        getDevice().uninstallPackage(USER_ENABLED_TEST_PACKAGE);
        getDevice().uninstallPackage(ENABLED_NO_PERMS_TEST_PACKAGE);
        getDevice().uninstallPackage(NOT_ENABLED_TEST_PACKAGE);
        getDevice().uninstallPackage(QUIET_MODE_ENABLED_TEST_PACKAGE);
    }

    private void installCrossProfileApps()
            throws FileNotFoundException, DeviceNotAvailableException {
        installCrossProfileApp(ENABLED_TEST_APK, /* grantPermissions= */ true);
        installCrossProfileApp(USER_ENABLED_TEST_APK, /* grantPermissions= */ true);
        installCrossProfileApp(NOT_ENABLED_TEST_APK, /* grantPermissions= */ true);
        installCrossProfileApp(ENABLED_NO_PERMS_TEST_APK, /* grantPermissions= */  false);
        installCrossProfileApp(QUIET_MODE_ENABLED_TEST_APK, /* grantPermissions= */  true);
    }

    private void enableCrossProfileAppsOp() throws DeviceNotAvailableException {
        enableCrossProfileAppsOp(ENABLED_NO_PERMS_TEST_PACKAGE, mPrimaryUserId);
    }

    private void installCrossProfileApp(String apkName, boolean grantPermissions)
            throws FileNotFoundException, DeviceNotAvailableException {
        installAppAsUser(apkName, grantPermissions, mPrimaryUserId);
        installAppAsUser(apkName, grantPermissions, mProfileId);
    }

    private void enableCrossProfileAppsOp(String packageName, int userId)
            throws DeviceNotAvailableException {
        getDevice().executeShellCommand(
                String.format(""appops set --user %s %s android:interact_across_profiles 0"",
                        userId, packageName));
        assertThat(getDevice().executeShellCommand(
                String.format(""appops get --user %s %s android:interact_across_profiles"",
                        userId, packageName))).contains(""INTERACT_ACROSS_PROFILES: allow"");
    }

    private Map<String, String> createParams(int targetUserId) throws Exception {
        Map<String, String> params = new HashMap<>();
        params.put(PARAM_TARGET_USER, Integer.toString(getUserSerialNumber(targetUserId)));
        params.put(PARAM_ORIGINAL_DEFAULT_LAUNCHER, mOriginalLauncher);
        return params;
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/QuietModeHostsideTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.devicepolicy.QuietModeHostsideTest"	"testQuietMode_defaultForegroundLauncher"	"CtsDevicePolicyManagerTestCases"	"2: ui user"	"public void testQuietMode_defaultForegroundLauncher() throws Exception {
        assumeHasSecureLockScreenFeature();

        // Add a lockscreen to test the case that profile with unified challenge can still
        // be turned on without asking the user to enter the lockscreen password.
        changeUserCredential(/* newCredential= */ TEST_PASSWORD, /* oldCredential= */ null,
                mPrimaryUserId);
        try {
            runDeviceTestsAsUser(
                    TEST_PACKAGE,
                    TEST_CLASS,
                    ""testTryEnableQuietMode_defaultForegroundLauncher"",
                    mPrimaryUserId,
                    createParams(mProfileId));
        } finally {
            changeUserCredential(/* newCredential= */ null, /* oldCredential= */ TEST_PASSWORD,
                    mPrimaryUserId);
        }
    }

    @LargeTest"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/QuietModeHostsideTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.devicepolicy.QuietModeHostsideTest"	"testQuietMode_notForegroundLauncher"	"CtsDevicePolicyManagerTestCases"	"2: ui user"	"public void testQuietMode_notForegroundLauncher() throws Exception {
        runDeviceTestsAsUser(
                TEST_PACKAGE,
                TEST_CLASS,
                ""testTryEnableQuietMode_notForegroundLauncher"",
                mPrimaryUserId,
                createParams(mProfileId));
    }

    @LargeTest"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/QuietModeHostsideTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.devicepolicy.QuietModeHostsideTest"	"testQuietMode_notDefaultLauncher"	"CtsDevicePolicyManagerTestCases"	"2: ui user"	"public void testQuietMode_notDefaultLauncher() throws Exception {
        runDeviceTestsAsUser(
                TEST_PACKAGE,
                TEST_CLASS,
                ""testTryEnableQuietMode_notDefaultLauncher"",
                mPrimaryUserId,
                createParams(mProfileId));
    }

    @LargeTest"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/QuietModeHostsideTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telecom.cts.CtsRoleManagerAdapter"	"isDialerRoleAvailable"	"CtsTelecomTestCases"	"2: system user"	"public void test/*
 *.
 */

package android.telecom.cts;

import static android.telecom.cts.TestUtils.WAIT_FOR_STATE_CHANGE_TIMEOUT_MS;
import static android.telecom.cts.TestUtils.executeShellCommand;

import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;

import static junit.framework.Assert.fail;

import static org.junit.Assert.assertEquals;

import android.app.Instrumentation;
import android.app.role.RoleManager;
import android.content.Context;
import android.os.Process;
import android.os.UserHandle;
import android.telecom.TelecomManager;
import android.util.Log;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executor;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

public class CtsRoleManagerAdapter {

    private static final String TAG = CtsRoleManagerAdapter.class.getSimpleName();

    private Context mContext;
    private RoleManager mRoleManager;
    private Instrumentation mInstrumentation;
    private ConcurrentHashMap<String, List<String>> mRoleHolders;

    public CtsRoleManagerAdapter(Instrumentation instrumentation) {
        mInstrumentation = instrumentation;
        mContext = instrumentation.getContext();
        mRoleManager = (RoleManager) mContext.getSystemService(Context.ROLE_SERVICE);
        mRoleHolders = new ConcurrentHashMap<>();
    }

    public boolean isDialerRoleAvailable() {
        return mRoleManager.isRoleAvailable(RoleManager.ROLE_DIALER);
    }

    public void setDialerRoleHolder(String packageName)
            throws Exception {
        if (mRoleManager != null) {
            addRoleHolder(RoleManager.ROLE_DIALER, packageName);
        } else {
            fail(""Expected role manager"");
        }
    }

    public List<String> getRoleHolder(String roleName) {
        List<String> holders = new ArrayList<>();
        runWithShellPermissionIdentity(() -> {
            List<String> previousHolders = mRoleManager.getRoleHolders(roleName);
            if (previousHolders != null && !previousHolders.isEmpty()) {
                holders.addAll(previousHolders);
            }
        });
        return holders;
    }

    private void addRoleHolder(String roleName, String packageName) throws InterruptedException {
        UserHandle user = Process.myUserHandle();
        Executor executor = mContext.getMainExecutor();
        LinkedBlockingQueue<String> q = new LinkedBlockingQueue<>(1);
        runWithShellPermissionIdentity(() -> {
            mRoleManager.addRoleHolderAsUser(roleName, packageName,
                    RoleManager.MANAGE_HOLDERS_FLAG_DONT_KILL_APP, user, executor,
                    successful -> {
                        if (successful) {
                            q.add(roleName + packageName);
                        } else  {
                            Log.e(TAG, ""Add role holder failed."");
                        }
                    });
        });
        String res = q.poll(WAIT_FOR_STATE_CHANGE_TIMEOUT_MS, TimeUnit.MILLISECONDS);
        assertEquals(roleName + packageName, res);
    }

    private void removeRoleHolder(String roleName, String packageName)
            throws InterruptedException {
        UserHandle user = Process.myUserHandle();
        Executor executor = mContext.getMainExecutor();
        LinkedBlockingQueue<String> q = new LinkedBlockingQueue<>(1);
        runWithShellPermissionIdentity(() -> {
            mRoleManager.removeRoleHolderAsUser(roleName, packageName, 0, user, executor,
                    successful -> {
                        if (successful) {
                            q.add(roleName + packageName);
                        } else {
                            Log.e(TAG, ""Remove role holder failed."");
                        }
                    });
        });
        String res = q.poll(WAIT_FOR_STATE_CHANGE_TIMEOUT_MS, TimeUnit.MILLISECONDS);
        assertEquals(roleName + packageName, res);
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/CtsRoleManagerAdapter.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.appsecurity.cts.v3rotationtests.V3RotationTest"	"testHasSigningCertificateByUid"	""	"1: ui"	"public void testHasSigningCertificateByUid() throws Exception {
        // make sure that hasSigningCertificate() reports that both certificates in the signing
        // history are present
        PackageManager pm = getContext().getPackageManager();
        int uid = pm.getPackageUid(PKG, 0);
        byte[] firstCertBytes = fromHexToByteArray(FIRST_CERT_HEX);
        assertTrue(""Old signing certificate not found for "" + PKG,
                pm.hasSigningCertificate(uid, firstCertBytes, PackageManager.CERT_INPUT_RAW_X509));
        byte[] secondCertBytes = fromHexToByteArray(SECOND_CERT_HEX);
        assertTrue(""Current signing certificate not found for "" + PKG,
                pm.hasSigningCertificate(uid, secondCertBytes, PackageManager.CERT_INPUT_RAW_X509));
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/V3SigningSchemeRotation/src/android/appsecurity/cts/v3rotationtests/V3RotationTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.appsecurity.cts.v3rotationtests.V3RotationTest"	"testHasSigningCertificateByUidSha256"	""	"1: ui"	"public void testHasSigningCertificateByUidSha256() throws Exception {
        // make sure that hasSigningCertificate() reports that both certificates in the signing
        // history are present
        PackageManager pm = getContext().getPackageManager();
        int uid = pm.getPackageUid(PKG, 0);
        byte[] firstCertBytes = computeSha256DigestBytes(fromHexToByteArray(FIRST_CERT_HEX));

        assertTrue(""Old signing certificate not found for "" + PKG,
                pm.hasSigningCertificate(uid, firstCertBytes, PackageManager.CERT_INPUT_SHA256));
        byte[] secondCertBytes = computeSha256DigestBytes(fromHexToByteArray(SECOND_CERT_HEX));
        assertTrue(""Current signing certificate not found for "" + PKG,
                pm.hasSigningCertificate(uid, secondCertBytes, PackageManager.CERT_INPUT_SHA256));
    }

    private  static byte[] fromHexToByteArray(String str) {
        if (str == null || str.length() == 0 || str.length() % 2 != 0) {
            return null;
        }

        final char[] chars = str.toCharArray();
        final int charLength = chars.length;
        final byte[] bytes = new byte[charLength / 2];

        for (int i = 0; i < bytes.length; i++) {
            bytes[i] =
                    (byte)(((getIndex(chars[i * 2]) << 4) & 0xF0)
                            | (getIndex(chars[i * 2 + 1]) & 0x0F));
        }
        return bytes;
    }

    // copy of ByteStringUtils - lowercase version (to match inputs)
    private static int getIndex(char c) {
        final char[] HEX_ARRAY = ""0123456789abcdef"".toCharArray();
        for (int i = 0; i < HEX_ARRAY.length; i++) {
            if (HEX_ARRAY[i] == c) {
                return i;
            }
        }
        return -1;
    }

    private static byte[] computeSha256DigestBytes(byte[] data) throws NoSuchAlgorithmException {
        MessageDigest messageDigest = MessageDigest.getInstance(""SHA256"");
        messageDigest.update(data);
        return messageDigest.digest();
    }

    private static void assertExpectedSignatures(Signature[] signatures,
            String... expectedSignatures) throws Exception {
        int numSigners = signatures.length;
        assertEquals(""An unexpected number of signatures was returned, expected ""
                        + expectedSignatures.length + "", but received "" + signatures.length,
                expectedSignatures.length, numSigners);
        Set<String> expectedSignatureSet = new HashSet<>(Arrays.asList(expectedSignatures));
        for (int i = 0; i < numSigners; i++) {
            String reportedCert = signatures[i].toCharsString();
            // Remove the reported certificate from the set to ensure duplicates are not matched.
            if (!expectedSignatureSet.remove(reportedCert)) {
                fail(""Received an unexpected signature during the test: "" + reportedCert);
            }
        }
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/V3SigningSchemeRotation/src/android/appsecurity/cts/v3rotationtests/V3RotationTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telecom.cts.BackgroundCallAudioTest"	"testAudioProcessingFromCallScreeningAllow"	"CtsTelecomTestCases"	"3: ui system user"	"public void testAudioProcessingFromCallScreeningAllow() throws Exception {
        if (!mShouldTestTelecom) {
            return;
        }

        setupIncomingCallWithCallScreening();

        final MockConnection connection = verifyConnectionForIncomingCall();

        if (!mInCallCallbacks.lock.tryAcquire(TestUtils.WAIT_FOR_CALL_ADDED_TIMEOUT_S,
                TimeUnit.SECONDS)) {
            fail(""No call added to InCallService."");
        }

        Call call = mInCallCallbacks.getService().getLastCall();
        assertCallState(call, Call.STATE_AUDIO_PROCESSING);
        assertConnectionState(connection, Connection.STATE_ACTIVE);

        AudioManager audioManager = mContext.getSystemService(AudioManager.class);
        if (doesAudioManagerSupportCallScreening) {
            assertAudioMode(audioManager, MODE_CALL_SCREENING);
        }

        verifySimulateRingAndUserPickup(call, connection);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/BackgroundCallAudioTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telecom.cts.BackgroundCallAudioTest"	"testHoldAfterAudioProcessingFromCallScreening"	"CtsTelecomTestCases"	"3: ui system user"	"public void testHoldAfterAudioProcessingFromCallScreening() throws Exception {
        if (!mShouldTestTelecom) {
            return;
        }

        setupIncomingCallWithCallScreening();

        final MockConnection connection = verifyConnectionForIncomingCall();

        if (!mInCallCallbacks.lock.tryAcquire(TestUtils.WAIT_FOR_CALL_ADDED_TIMEOUT_S,
                TimeUnit.SECONDS)) {
            fail(""No call added to InCallService."");
        }

        Call call = mInCallCallbacks.getService().getLastCall();
        assertCallState(call, Call.STATE_AUDIO_PROCESSING);
        assertConnectionState(connection, Connection.STATE_ACTIVE);

        AudioManager audioManager = mContext.getSystemService(AudioManager.class);
        if (doesAudioManagerSupportCallScreening) {
            assertAudioMode(audioManager, MODE_CALL_SCREENING);
        }

        verifySimulateRingAndUserPickup(call, connection);

        call.hold();
        assertCallState(call, Call.STATE_HOLDING);
        call.unhold();
        assertCallState(call, Call.STATE_ACTIVE);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/BackgroundCallAudioTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telecom.cts.BackgroundCallAudioTest"	"testAudioProcessingFromCallScreeningDisallow"	"CtsTelecomTestCases"	"2: ui system"	"public void testAudioProcessingFromCallScreeningDisallow() throws Exception {
        if (!mShouldTestTelecom) {
            return;
        }

        setupIncomingCallWithCallScreening();

        final MockConnection connection = verifyConnectionForIncomingCall();

        if (!mInCallCallbacks.lock.tryAcquire(TestUtils.WAIT_FOR_CALL_ADDED_TIMEOUT_S,
                TimeUnit.SECONDS)) {
            fail(""No call added to InCallService."");
        }

        Call call = mInCallCallbacks.getService().getLastCall();
        assertCallState(call, Call.STATE_AUDIO_PROCESSING);
        assertConnectionState(connection, Connection.STATE_ACTIVE);

        AudioManager audioManager = mContext.getSystemService(AudioManager.class);
        if (doesAudioManagerSupportCallScreening) {
            assertAudioMode(audioManager, MODE_CALL_SCREENING);
        }

        call.disconnect();
        assertCallState(call, Call.STATE_DISCONNECTED);
        assertEquals(DisconnectCause.REJECTED, call.getDetails().getDisconnectCause().getCode());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/BackgroundCallAudioTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telecom.cts.BackgroundCallAudioTest"	"testAudioProcessingFromCallScreeningMissed"	"CtsTelecomTestCases"	"3: ui system user"	"public void testAudioProcessingFromCallScreeningMissed() throws Exception {
        if (!mShouldTestTelecom) {
            return;
        }

        setupIncomingCallWithCallScreening();

        final MockConnection connection = verifyConnectionForIncomingCall();

        if (!mInCallCallbacks.lock.tryAcquire(TestUtils.WAIT_FOR_CALL_ADDED_TIMEOUT_S,
                TimeUnit.SECONDS)) {
            fail(""No call added to InCallService."");
        }

        Call call = mInCallCallbacks.getService().getLastCall();
        assertCallState(call, Call.STATE_AUDIO_PROCESSING);
        assertConnectionState(connection, Connection.STATE_ACTIVE);

        AudioManager audioManager = mContext.getSystemService(AudioManager.class);
        if (doesAudioManagerSupportCallScreening) {
            assertAudioMode(audioManager, MODE_CALL_SCREENING);
        }

        verifySimulateRingAndUserMissed(call, connection);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/BackgroundCallAudioTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telecom.cts.BackgroundCallAudioTest"	"testAudioProcessingFromCallScreeningRemoteHangupDuringRing"	"CtsTelecomTestCases"	"2: ui system"	"public void testAudioProcessingFromCallScreeningRemoteHangupDuringRing() throws Exception {
        if (!mShouldTestTelecom) {
            return;
        }

        setupIncomingCallWithCallScreening();

        final MockConnection connection = verifyConnectionForIncomingCall();

        if (!mInCallCallbacks.lock.tryAcquire(TestUtils.WAIT_FOR_CALL_ADDED_TIMEOUT_S,
                TimeUnit.SECONDS)) {
            fail(""No call added to InCallService."");
        }

        Call call = mInCallCallbacks.getService().getLastCall();
        assertCallState(call, Call.STATE_AUDIO_PROCESSING);
        assertConnectionState(connection, Connection.STATE_ACTIVE);

        AudioManager audioManager = mContext.getSystemService(AudioManager.class);
        if (doesAudioManagerSupportCallScreening) {
            assertAudioMode(audioManager, MODE_CALL_SCREENING);
        }

        call.exitBackgroundAudioProcessing(true);
        assertCallState(call, Call.STATE_SIMULATED_RINGING);

        waitOnAllHandlers(getInstrumentation());
        // We expect the audio mode to stay in CALL_SCREENING when going into simulated ringing.
        if (doesAudioManagerSupportCallScreening) {
            assertAudioMode(audioManager, MODE_CALL_SCREENING);
        }
        assertConnectionState(connection, Connection.STATE_ACTIVE);

        connection.setDisconnected(new DisconnectCause(DisconnectCause.REMOTE));
        assertCallState(call, Call.STATE_DISCONNECTED);
        assertEquals(DisconnectCause.MISSED, call.getDetails().getDisconnectCause().getCode());
        connection.destroy();
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/BackgroundCallAudioTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telecom.cts.BackgroundCallAudioTest"	"testAudioProcessingFromCallScreeningAllowPlaceEmergencyCall"	"CtsTelecomTestCases"	"3: ui system user"	"public void testAudioProcessingFromCallScreeningAllowPlaceEmergencyCall() throws Exception {
        if (!mShouldTestTelecom) {
            return;
        }
        setupForEmergencyCalling(TEST_EMERGENCY_NUMBER);
        setupIncomingCallWithCallScreening();

        final MockConnection connection = verifyConnectionForIncomingCall();

        if (!mInCallCallbacks.lock.tryAcquire(TestUtils.WAIT_FOR_CALL_ADDED_TIMEOUT_S,
                TimeUnit.SECONDS)) {
            fail(""No call added to InCallService."");
        }

        Call call = mInCallCallbacks.getService().getLastCall();
        assertCallState(call, Call.STATE_AUDIO_PROCESSING);
        assertConnectionState(connection, Connection.STATE_ACTIVE);

        AudioManager audioManager = mContext.getSystemService(AudioManager.class);
        if (doesAudioManagerSupportCallScreening) {
            assertAudioMode(audioManager, MODE_CALL_SCREENING);
        }

        call.exitBackgroundAudioProcessing(true);
        assertCallState(call, Call.STATE_SIMULATED_RINGING);
        waitOnAllHandlers(getInstrumentation());
        // We expect the audio mode to stay in CALL_SCREENING when going into simulated ringing.
        if (doesAudioManagerSupportCallScreening) {
            assertAudioMode(audioManager, MODE_CALL_SCREENING);
        }
        assertConnectionState(connection, Connection.STATE_ACTIVE);

        placeAndVerifyEmergencyCall(false /*supportsHold*/);
        waitOnAllHandlers(getInstrumentation());
        Call eCall = getInCallService().getLastCall();
        assertCallState(eCall, Call.STATE_DIALING);
        // Even though the connection was technically active, it is ""simulated ringing"", so
        // disconnect as you would a normal ringing call in favor of an emergency call.
        assertCallState(call, Call.STATE_DISCONNECTED);
        assertConnectionState(connection, Connection.STATE_DISCONNECTED);
        // Notify as missed instead of rejected, since the user did not explicitly reject.
        verifyCallLogging(connection.getAddress(), CallLog.Calls.MISSED_TYPE);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/BackgroundCallAudioTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telecom.cts.BackgroundCallAudioTest"	"testAudioProcessingFromIncomingActivePlaceEmergencyCall"	"CtsTelecomTestCases"	"3: ui system user"	"public void testAudioProcessingFromIncomingActivePlaceEmergencyCall() throws Exception {
        if (!mShouldTestTelecom) {
            return;
        }
        setupForEmergencyCalling(TEST_EMERGENCY_NUMBER);
        setupIncomingCallWithCallScreening();

        final MockConnection connection = verifyConnectionForIncomingCall();

        if (!mInCallCallbacks.lock.tryAcquire(TestUtils.WAIT_FOR_CALL_ADDED_TIMEOUT_S,
                TimeUnit.SECONDS)) {
            fail(""No call added to InCallService."");
        }

        Call call = mInCallCallbacks.getService().getLastCall();
        assertCallState(call, Call.STATE_AUDIO_PROCESSING);
        assertConnectionState(connection, Connection.STATE_ACTIVE);

        AudioManager audioManager = mContext.getSystemService(AudioManager.class);
        if (doesAudioManagerSupportCallScreening) {
            assertAudioMode(audioManager, MODE_CALL_SCREENING);
        }

        verifySimulateRingAndUserPickup(call, connection);
        // Go back into audio processing for hold case
        call.enterBackgroundAudioProcessing();
        assertCallState(call, Call.STATE_AUDIO_PROCESSING);
        waitOnAllHandlers(getInstrumentation());

        placeAndVerifyEmergencyCall(false /*supportsHold*/);
        waitOnAllHandlers(getInstrumentation());
        Call eCall = getInCallService().getLastCall();
        assertCallState(eCall, Call.STATE_DIALING);
        // Even though the connection was technically active, it is ""simulated ringing"", so
        // disconnect as you would a normal ringing call in favor of an emergency call.
        assertCallState(call, Call.STATE_DISCONNECTED);
        assertConnectionState(connection, Connection.STATE_DISCONNECTED);
        // Notify as incoming, since the user has already answered the call.
        verifyCallLogging(connection.getAddress(), CallLog.Calls.INCOMING_TYPE);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/BackgroundCallAudioTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telecom.cts.BackgroundCallAudioTest"	"testLowerApiLevelCompatibility1"	"CtsTelecomTestCases"	"1: ui"	"public void testLowerApiLevelCompatibility1() throws Exception {
        if (!mShouldTestTelecom) {
            return;
        }

        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(""android.permission.CONTROL_INCALL_EXPERIENCE"");
        try {
            ICtsApi29InCallServiceControl controlInterface = setUpControl();

            setupIncomingCallWithCallScreening();

            final MockConnection connection = verifyConnectionForIncomingCall();

            if (!mInCallCallbacks.lock.tryAcquire(TestUtils.WAIT_FOR_CALL_ADDED_TIMEOUT_S,
                    TimeUnit.SECONDS)) {
                fail(""No call added to InCallService."");
            }

            Call call = mInCallCallbacks.getService().getLastCall();
            assertCallState(call, Call.STATE_AUDIO_PROCESSING);
            assertConnectionState(connection, Connection.STATE_ACTIVE);
            // Make sure that the test app never got any calls
            assertEquals(0, controlInterface.getHistoricalCallCount());

            call.exitBackgroundAudioProcessing(true);
            assertCallState(call, Call.STATE_SIMULATED_RINGING);
            waitOnAllHandlers(getInstrumentation());
            assertConnectionState(connection, Connection.STATE_ACTIVE);
            // Make sure that the test app sees a ringing call.
            assertEquals(Call.STATE_RINGING,
                    controlInterface.getCallState(call.getDetails().getTelecomCallId()));

            call.answer(VideoProfile.STATE_AUDIO_ONLY);
            assertCallState(call, Call.STATE_ACTIVE);
            waitOnAllHandlers(getInstrumentation());
            assertConnectionState(connection, Connection.STATE_ACTIVE);
            // Make sure that the test app sees an active call.
            assertEquals(Call.STATE_ACTIVE,
                    controlInterface.getCallState(call.getDetails().getTelecomCallId()));

            tearDownControl();
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                    .dropShellPermissionIdentity();
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/BackgroundCallAudioTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telecom.cts.BackgroundCallAudioTest"	"testLowerApiLevelCompatibility2"	"CtsTelecomTestCases"	"3: ui system user"	"public void testLowerApiLevelCompatibility2() throws Exception {
        if (!mShouldTestTelecom) {
            return;
        }
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(""android.permission.CONTROL_INCALL_EXPERIENCE"");
        try {
            ICtsApi29InCallServiceControl controlInterface = setUpControl();

            setupIncomingCallWithCallScreening();

            final MockConnection connection = verifyConnectionForIncomingCall();

            if (!mInCallCallbacks.lock.tryAcquire(TestUtils.WAIT_FOR_CALL_ADDED_TIMEOUT_S,
                    TimeUnit.SECONDS)) {
                fail(""No call added to InCallService."");
            }

            Call call = mInCallCallbacks.getService().getLastCall();
            assertCallState(call, Call.STATE_AUDIO_PROCESSING);
            assertConnectionState(connection, Connection.STATE_ACTIVE);
            // Make sure that the test app never got any calls
            assertEquals(0, controlInterface.getHistoricalCallCount());

            call.disconnect();
            assertCallState(call, Call.STATE_DISCONNECTED);
            waitOnAllHandlers(getInstrumentation());
            assertConnectionState(connection, Connection.STATE_DISCONNECTED);
            // Under some rare circumstances, the test app might get a flash of the disconnection
            // call, so we won't do the call count check again.

            tearDownControl();
        } finally {
            InstrumentationRegistry.getInstrumentation().getUiAutomation()
                    .dropShellPermissionIdentity();
        }
    }

    private Connection placeActiveOutgoingCall() {
        placeAndVerifyCall();

        Call call = mInCallCallbacks.getService().getLastCall();
        assertCallState(call, Call.STATE_DIALING);

        final MockConnection connection = verifyConnectionForOutgoingCall();
        connection.setActive();
        assertCallState(call, Call.STATE_ACTIVE);
        return connection;
    }

    private void verifySimulateRingAndUserPickup(Call call, Connection connection) {
        AudioManager audioManager = mContext.getSystemService(AudioManager.class);

        call.exitBackgroundAudioProcessing(true);
        assertCallState(call, Call.STATE_SIMULATED_RINGING);
        waitOnAllHandlers(getInstrumentation());
        // We expect the audio mode to stay in CALL_SCREENING when going into simulated ringing.
        if (doesAudioManagerSupportCallScreening) {
            assertAudioMode(audioManager, MODE_CALL_SCREENING);
        }
        assertConnectionState(connection, Connection.STATE_ACTIVE);

        call.answer(VideoProfile.STATE_AUDIO_ONLY);
        assertCallState(call, Call.STATE_ACTIVE);
        waitOnAllHandlers(getInstrumentation());
        assertAudioMode(audioManager, AudioManager.MODE_IN_CALL);
        assertConnectionState(connection, Connection.STATE_ACTIVE);
    }

    private void verifySimulateRingAndUserMissed(Call call, Connection connection) {
        AudioManager audioManager = mContext.getSystemService(AudioManager.class);

        call.exitBackgroundAudioProcessing(true);
        assertCallState(call, Call.STATE_SIMULATED_RINGING);
        waitOnAllHandlers(getInstrumentation());
        // We expect the audio mode to stay in CALL_SCREENING when going into simulated ringing.
        if (doesAudioManagerSupportCallScreening) {
            assertAudioMode(audioManager, MODE_CALL_SCREENING);
        }
        assertConnectionState(connection, Connection.STATE_ACTIVE);
        assertTrue(mTelecomManager.isRinging());

        call.disconnect();
        assertCallState(call, Call.STATE_DISCONNECTED);
        assertConnectionState(connection, Connection.STATE_DISCONNECTED);
        assertEquals(DisconnectCause.MISSED, call.getDetails().getDisconnectCause().getCode());
    }

    private void setupIncomingCallWithCallScreening() throws Exception {
        CallScreeningServiceCallbacks callback = new CallScreeningServiceCallbacks() {
            @Override
            public void onScreenCall(Details callDetails) {
                getService().respondToCall(callDetails, new CallResponse.Builder()
                        .setDisallowCall(false)
                        .setShouldScreenCallViaAudioProcessing(true)
                        .build());
                lock.release();
            }
        };
        MockCallScreeningService.enableService(mContext);
        MockCallScreeningService.setCallbacks(callback);
        Bundle extras = new Bundle();
        extras.putParcelable(TelecomManager.EXTRA_INCOMING_CALL_ADDRESS, createTestNumber());
        mTelecomManager.addNewIncomingCall(TEST_PHONE_ACCOUNT_HANDLE, extras);

        if (!callback.lock.tryAcquire(TestUtils.WAIT_FOR_CALL_ADDED_TIMEOUT_S,
                TimeUnit.SECONDS)) {
            fail(""Call screening service never got the call"");
        }

    }

    private ICtsApi29InCallServiceControl setUpControl() throws Exception {
        Pair<ServiceConnection, ICtsApi29InCallServiceControl> setupResult =
                Api29InCallUtils.setupControl(mContext);
        mApiCompatControlServiceConnection = setupResult.first;
        return setupResult.second;
    }

    private void tearDownControl() throws Exception {
        Api29InCallUtils.tearDownControl(mContext,
                mApiCompatControlServiceConnection);
    }

    private void clearRoleHoldersAsUser(String roleName)
            throws Exception {
        UserHandle user = Process.myUserHandle();
        Executor executor = mContext.getMainExecutor();
        LinkedBlockingQueue<Boolean> queue = new LinkedBlockingQueue(1);

        runWithShellPermissionIdentity(() -> mRoleManager.clearRoleHoldersAsUser(roleName,
                RoleManager.MANAGE_HOLDERS_FLAG_DONT_KILL_APP, user, executor,
                successful -> {
                    try {
                        queue.put(successful);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }));
        boolean result = queue.poll(ASYNC_TIMEOUT, TimeUnit.MILLISECONDS);
        assertTrue(result);
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/BackgroundCallAudioTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telecom.cts.BackgroundCallAudioTest"	"isCallScreeningModeSupported"	"CtsTelecomTestCases"	"2: system user"	"public void testpackage android.telecom.cts;

import static android.app.role.RoleManager.ROLE_CALL_SCREENING;
import static android.telecom.cts.TestUtils.TEST_PHONE_ACCOUNT_HANDLE;
import static android.telecom.cts.TestUtils.waitOnAllHandlers;
import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;

import android.app.role.RoleManager;
import android.content.Context;
import android.content.ServiceConnection;
import android.media.AudioManager;
import android.os.Bundle;
import android.os.Process;
import android.os.UserHandle;
import android.provider.CallLog;
import android.telecom.Call;
import android.telecom.Call.Details;
import android.telecom.CallScreeningService.CallResponse;
import android.telecom.Connection;
import android.telecom.DisconnectCause;
import android.telecom.TelecomManager;
import android.telecom.VideoProfile;
import android.telecom.cts.MockCallScreeningService.CallScreeningServiceCallbacks;
import android.telecom.cts.api29incallservice.ICtsApi29InCallServiceControl;
import android.text.TextUtils;
import android.util.Pair;

import androidx.test.InstrumentationRegistry;

import java.util.concurrent.Executor;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

public class BackgroundCallAudioTest extends BaseTelecomTestWithMockServices {
    private static final String LOG_TAG = BackgroundCallAudioTest.class.getSimpleName();

    private static final int ASYNC_TIMEOUT = 10000;
    private RoleManager mRoleManager;
    private ServiceConnection mApiCompatControlServiceConnection;

    // copied from AudioSystem.java -- defined here because that change isn't in AOSP yet.
    private static final int MODE_CALL_SCREENING = 4;

    // true if there's platform support for call screening in the audio stack.
    private boolean doesAudioManagerSupportCallScreening = false;

    private String mPreviousDefaultDialer = null;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        if (mShouldTestTelecom) {
            mRoleManager = (RoleManager) mContext.getSystemService(Context.ROLE_SERVICE);
            clearRoleHoldersAsUser(ROLE_CALL_SCREENING);
            mPreviousDefaultDialer = TestUtils.getDefaultDialer(getInstrumentation());
            TestUtils.setDefaultDialer(getInstrumentation(), TestUtils.PACKAGE);
            setupConnectionService(null, FLAG_REGISTER | FLAG_ENABLE);
            // Some of the tests expect changes in audio mode when the ringer starts, so we're
            // going to turn up the ring stream volume.
            AudioManager audioManager = mContext.getSystemService(AudioManager.class);
            audioManager.adjustStreamVolume(AudioManager.STREAM_RING,
                    AudioManager.ADJUST_UNMUTE, 0);
            doesAudioManagerSupportCallScreening =
                    audioManager.isCallScreeningModeSupported();
        }
    }

    @Override
    protected void tearDown() throws Exception {
        if (mShouldTestTelecom && !TextUtils.isEmpty(mPreviousDefaultDialer)) {
            TestUtils.setDefaultDialer(getInstrumentation(), mPreviousDefaultDialer);
            MockCallScreeningService.disableService(mContext);
        }
        super.tearDown();
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/BackgroundCallAudioTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telecom.cts.BackgroundCallAudioTest"	"testAudioProcessActiveCall"	"CtsTelecomTestCases"	"2: system user"	"public void testAudioProcessActiveCall() {
        if (!mShouldTestTelecom) {
            return;
        }

        Connection connection = placeActiveOutgoingCall();
        Call call = mInCallCallbacks.getService().getLastCall();

        call.enterBackgroundAudioProcessing();
        assertCallState(call, Call.STATE_AUDIO_PROCESSING);

        waitOnAllHandlers(getInstrumentation());
        AudioManager audioManager = mContext.getSystemService(AudioManager.class);
        if (doesAudioManagerSupportCallScreening) {
            assertAudioMode(audioManager, MODE_CALL_SCREENING);
        }
        assertConnectionState(connection, Connection.STATE_ACTIVE);

        verifySimulateRingAndUserPickup(call, connection);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/BackgroundCallAudioTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telecom.cts.BackgroundCallAudioTest"	"testAudioProcessActiveCallMissed"	"CtsTelecomTestCases"	"2: system user"	"public void testAudioProcessActiveCallMissed() throws Exception {
        if (!mShouldTestTelecom) {
            return;
        }

        Connection connection = placeActiveOutgoingCall();
        Call call = mInCallCallbacks.getService().getLastCall();

        call.enterBackgroundAudioProcessing();
        assertCallState(call, Call.STATE_AUDIO_PROCESSING);
        assertConnectionState(connection, Connection.STATE_ACTIVE);

        waitOnAllHandlers(getInstrumentation());
        AudioManager audioManager = mContext.getSystemService(AudioManager.class);
        if (doesAudioManagerSupportCallScreening) {
            assertAudioMode(audioManager, MODE_CALL_SCREENING);
        }

        verifySimulateRingAndUserMissed(call, connection);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/BackgroundCallAudioTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telecom.cts.BackgroundCallAudioTest"	"testAudioProcessActiveCallRemoteHangup"	"CtsTelecomTestCases"	"1: system"	"public void testAudioProcessActiveCallRemoteHangup() {
        if (!mShouldTestTelecom) {
            return;
        }

        Connection connection = placeActiveOutgoingCall();
        Call call = mInCallCallbacks.getService().getLastCall();

        call.enterBackgroundAudioProcessing();
        assertCallState(call, Call.STATE_AUDIO_PROCESSING);
        assertConnectionState(connection, Connection.STATE_ACTIVE);

        waitOnAllHandlers(getInstrumentation());
        AudioManager audioManager = mContext.getSystemService(AudioManager.class);
        if (doesAudioManagerSupportCallScreening) {
            assertAudioMode(audioManager, MODE_CALL_SCREENING);
        }

        connection.setDisconnected(new DisconnectCause(DisconnectCause.REMOTE));
        assertCallState(call, Call.STATE_DISCONNECTED);
        assertEquals(DisconnectCause.REMOTE, call.getDetails().getDisconnectCause().getCode());
        connection.destroy();
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/BackgroundCallAudioTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telecom.cts.BackgroundCallAudioTest"	"testAudioProcessOutgoingActiveEmergencyCallPlaced"	"CtsTelecomTestCases"	"1: system"	"public void testAudioProcessOutgoingActiveEmergencyCallPlaced() throws Exception {
        if (!mShouldTestTelecom) {
            return;
        }
        setupForEmergencyCalling(TEST_EMERGENCY_NUMBER);

        Connection connection = placeActiveOutgoingCall();
        Call call = mInCallCallbacks.getService().getLastCall();

        call.enterBackgroundAudioProcessing();
        assertCallState(call, Call.STATE_AUDIO_PROCESSING);
        assertConnectionState(connection, Connection.STATE_ACTIVE);

        waitOnAllHandlers(getInstrumentation());
        AudioManager audioManager = mContext.getSystemService(AudioManager.class);
        if (doesAudioManagerSupportCallScreening) {
            assertAudioMode(audioManager, MODE_CALL_SCREENING);
        }

        placeAndVerifyEmergencyCall(false /*supportsHold*/);
        waitOnAllHandlers(getInstrumentation());
        Call eCall = getInCallService().getLastCall();
        // emergency call should be dialing
        assertCallState(eCall, Call.STATE_DIALING);
        // audio processing call should be disconnected
        assertConnectionState(connection, Connection.STATE_DISCONNECTED);
        assertCallState(call, Call.STATE_DISCONNECTED);
        // If we went to AUDIO_PROCESSING from an active outgoing call, Make sure the call is
        // marked outgoing, not missed.
        verifyCallLogging(connection.getAddress(), CallLog.Calls.OUTGOING_TYPE);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/BackgroundCallAudioTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telecom.cts.BackgroundCallAudioTest"	"testManualAudioCallScreenAccept"	"CtsTelecomTestCases"	"1: system"	"public void testManualAudioCallScreenAccept() {
        if (!mShouldTestTelecom) {
            return;
        }

        addAndVerifyNewIncomingCall(createTestNumber(), null);
        final MockConnection connection = verifyConnectionForIncomingCall();

        Call call = mInCallCallbacks.getService().getLastCall();
        assertCallState(call, Call.STATE_RINGING);

        call.enterBackgroundAudioProcessing();
        assertCallState(call, Call.STATE_AUDIO_PROCESSING);
        assertConnectionState(connection, Connection.STATE_ACTIVE);

        waitOnAllHandlers(getInstrumentation());
        AudioManager audioManager = mContext.getSystemService(AudioManager.class);
        if (doesAudioManagerSupportCallScreening) {
            assertAudioMode(audioManager, MODE_CALL_SCREENING);
        }

        call.exitBackgroundAudioProcessing(false);
        assertCallState(call, Call.STATE_ACTIVE);
        waitOnAllHandlers(getInstrumentation());
        assertAudioMode(audioManager, AudioManager.MODE_IN_CALL);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/BackgroundCallAudioTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telecom.cts.BackgroundCallAudioTest"	"testManualAudioCallScreenReject"	"CtsTelecomTestCases"	"1: system"	"public void testManualAudioCallScreenReject() {
        if (!mShouldTestTelecom) {
            return;
        }

        addAndVerifyNewIncomingCall(createTestNumber(), null);
        final MockConnection connection = verifyConnectionForIncomingCall();

        Call call = mInCallCallbacks.getService().getLastCall();
        assertCallState(call, Call.STATE_RINGING);

        call.enterBackgroundAudioProcessing();
        assertCallState(call, Call.STATE_AUDIO_PROCESSING);
        assertConnectionState(connection, Connection.STATE_ACTIVE);

        waitOnAllHandlers(getInstrumentation());
        AudioManager audioManager = mContext.getSystemService(AudioManager.class);
        if (doesAudioManagerSupportCallScreening) {
            assertAudioMode(audioManager, MODE_CALL_SCREENING);
        }

        call.disconnect();
        assertCallState(call, Call.STATE_DISCONNECTED);
        assertEquals(DisconnectCause.REJECTED, call.getDetails().getDisconnectCause().getCode());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/BackgroundCallAudioTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.dynamicmime.testapp.assertions.MimeGroupAssertions"	"MimeGroupAssertions"	""	"1: mic"	"public void test/*
 *.
 */

package android.dynamicmime.testapp.assertions;

import android.content.Context;
import android.util.ArraySet;

import java.util.Collections;
import java.util.Set;

public abstract class MimeGroupAssertions {
    public abstract void assertMatchedByMimeGroup(String mimeGroup, String mimeType);

    public abstract void assertNotMatchedByMimeGroup(String mimeGroup, String mimeType);

    public abstract void assertMimeGroupInternal(String mimeGroup, Set<String> mimeTypes);

    public final void assertMimeGroup(String mimeGroup, String... mimeTypes) {
        assertMimeGroupInternal(mimeGroup, new ArraySet<>(mimeTypes));
    }

    public final void assertMimeGroupIsEmpty(String mimeGroup) {
        assertMimeGroupInternal(mimeGroup, Collections.emptySet());
    }

    public final void assertMimeGroupUndefined(String mimeGroup) {
        assertMimeGroupInternal(mimeGroup, null);
    }

    public final void assertMatchedByMimeGroup(String mimeGroup, String... mimeTypes) {
        for (String mimeType: mimeTypes) {
            assertMatchedByMimeGroup(mimeGroup, mimeType);
        }
    }

    public final void assertNotMatchedByMimeGroup(String mimeGroup, String... mimeTypes) {
        for (String mimeType: mimeTypes) {
            assertNotMatchedByMimeGroup(mimeGroup, mimeType);
        }
    }

    public static MimeGroupAssertions testApp(Context context) {
        return AssertionsByGroupData.testApp(context)
                .mergeWith(AssertionsByIntentResolution.testApp(context));
    }

    public static MimeGroupAssertions helperApp(Context context) {
        return AssertionsByGroupData.helperApp(context)
                .mergeWith(AssertionsByIntentResolution.helperApp(context));
    }

    public static MimeGroupAssertions appWithUpdates(Context context) {
        return AssertionsByGroupData.appWithUpdates(context)
                .mergeWith(AssertionsByIntentResolution.appWithUpdates(context));
    }

    public static MimeGroupAssertions noOp() {
        return new MimeGroupAssertions() {
            @Override
            public void assertMatchedByMimeGroup(String mimeGroup, String mimeType) {
            }

            @Override
            public void assertNotMatchedByMimeGroup(String mimeGroup, String mimeType) {
            }

            @Override
            public void assertMimeGroupInternal(String mimeGroup, Set<String> mimeTypes) {
            }
        };
    }

    public static MimeGroupAssertions notUsed() {
        return new MimeGroupAssertions() {
            @Override
            public void assertMatchedByMimeGroup(String group, String type) {
                throw new UnsupportedOperationException();
            }

            @Override
            public void assertNotMatchedByMimeGroup(String group, String type) {
                throw new UnsupportedOperationException();
            }

            @Override
            public void assertMimeGroupInternal(String group, Set<String> types) {
                throw new UnsupportedOperationException();
            }
        };
    }

    protected final MimeGroupAssertions mergeWith(MimeGroupAssertions other) {
        return new MimeGroupAssertions() {
            @Override
            public void assertMatchedByMimeGroup(String mimeGroup, String mimeType) {
                other.assertMatchedByMimeGroup(mimeGroup, mimeType);
                MimeGroupAssertions.this.assertMatchedByMimeGroup(mimeGroup, mimeType);
            }

            @Override
            public void assertNotMatchedByMimeGroup(String mimeGroup, String mimeType) {
                other.assertNotMatchedByMimeGroup(mimeGroup, mimeType);
                MimeGroupAssertions.this.assertNotMatchedByMimeGroup(mimeGroup, mimeType);
            }

            @Override
            public void assertMimeGroupInternal(String mimeGroup, Set<String> mimeTypes) {
                other.assertMimeGroupInternal(mimeGroup, mimeTypes);
                MimeGroupAssertions.this.assertMimeGroupInternal(mimeGroup, mimeTypes);
            }
        };
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/packagemanager/dynamicmime/test/src/android/dynamicmime/testapp/assertions/MimeGroupAssertions.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.uwb.cts.RangingMeasurementTest"	"testBuilder"	"CtsUwbTestCases"	"2: ui system"	"public void testBuilder() {
        int status = RangingMeasurement.RANGING_STATUS_SUCCESS;
        UwbAddress address = UwbTestUtils.getUwbAddress(false);
        long time = SystemClock.elapsedRealtimeNanos();
        AngleOfArrivalMeasurement angleMeasurement = UwbTestUtils.getAngleOfArrivalMeasurement();
        DistanceMeasurement distanceMeasurement = UwbTestUtils.getDistanceMeasurement();

        RangingMeasurement.Builder builder = new RangingMeasurement.Builder();

        builder.setStatus(status);
        tryBuild(builder, false);

        builder.setElapsedRealtimeNanos(time);
        tryBuild(builder, false);

        builder.setAngleOfArrivalMeasurement(angleMeasurement);
        tryBuild(builder, false);

        builder.setDistanceMeasurement(distanceMeasurement);
        tryBuild(builder, false);

        builder.setRemoteDeviceAddress(address);
        RangingMeasurement measurement = tryBuild(builder, true);

        assertEquals(status, measurement.getStatus());
        assertEquals(address, measurement.getRemoteDeviceAddress());
        assertEquals(time, measurement.getElapsedRealtimeNanos());
        assertEquals(angleMeasurement, measurement.getAngleOfArrivalMeasurement());
        assertEquals(distanceMeasurement, measurement.getDistanceMeasurement());
    }

    private RangingMeasurement tryBuild(RangingMeasurement.Builder builder,
            boolean expectSuccess) {
        RangingMeasurement measurement = null;
        try {
            measurement = builder.build();
            if (!expectSuccess) {
                fail(""Expected RangingMeasurement.Builder.build() to fail"");
            }
        } catch (IllegalStateException e) {
            if (expectSuccess) {
                fail(""Expected DistanceMeasurement.Builder.build() to succeed"");
            }
        }
        return measurement;
    }"	"/home/gpoor/cts-12-source/cts/tests/uwb/src/android/uwb/cts/RangingMeasurementTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.permission.cts.ActivityPermissionRationaleTest"	"permissionGrantedNoRationale"	"CtsPermissionTestCases"	"2: apps ui"	"public void permissionGrantedNoRationale() throws Exception {
        sUiAuto.grantRuntimePermission(PACKAGE_NAME, PERMISSION_NAME);

        assertAppShowRationaleIs(false);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/permission/src/android/permission/cts/ActivityPermissionRationaleTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.server.cts.SettingsIncidentTest"	"testBasicStructure"	"CtsIncidentHostTestCases"	"2: system user"	"public void testBasicStructure() throws Exception {
        SettingsServiceDumpProto dump = getDump(SettingsServiceDumpProto.parser(),
                ""dumpsys settings --proto"");

        verifySettingsServiceDumpProto(dump, PRIVACY_NONE);
    }

    static void verifySettingsServiceDumpProto(SettingsServiceDumpProto dump, final int filterLevel) throws Exception {
        if (dump.getUserSettingsCount() > 0) {
            UserSettingsProto userSettings = dump.getUserSettings(0);
            assertEquals(0, userSettings.getUserId());

            CLog.logAndDisplay(LogLevel.INFO, ""#*#*#*#*#*#*#*#*#*#*# SECURE #*#*#*#*#*#*#*#*#*#*#"");
            verifySettings(userSettings.getSecureSettings(), filterLevel);
            CLog.logAndDisplay(LogLevel.INFO, ""#*#*#*#*#*#*#*#*#*#*# SYSTEM #*#*#*#*#*#*#*#*#*#*#"");
            verifySettings(userSettings.getSystemSettings(), filterLevel);
        }

        CLog.logAndDisplay(LogLevel.INFO, ""#*#*#*#*#*#*#*#*#*#*# GLOBAL #*#*#*#*#*#*#*#*#*#*#"");
        verifySettings(dump.getGlobalSettings(), filterLevel);
    }

    private static void verifySettings(Message settings, final int filterLevel) throws Exception {
        verifySettings(getSettingProtos(settings), filterLevel);

        final List<SettingsOperationProto> ops = invoke(settings, ""getHistoricalOperationsList"");
        for (SettingsOperationProto op : ops) {
            assertTrue(op.getTimestamp() >= 0);
            assertNotNull(op.getOperation());
            // setting is optional
            if (filterLevel == PRIVACY_AUTO) {
                // SettingOperationProto is EXPLICIT by default.
                assertTrue(op.getOperation().isEmpty());
                assertTrue(op.getSetting().isEmpty());
            }
        }
    }

    private static Map<SettingProto, Destination> getSettingProtos(Message settingsProto) {
        CLog.d(""Checking out class: "" + settingsProto.getClass());

        Map<SettingProto, Destination> settings = new HashMap<>();
        for (FieldDescriptor fd : settingsProto.getDescriptorForType().getFields()) {
            if (fd.getType() != FieldDescriptor.Type.MESSAGE) {
                // Only looking for SettingProtos and messages that contain them. Skip any primitive
                // fields.
                continue;
            }
            List<Object> tmp;
            if (fd.isRepeated()) {
                tmp = (List) settingsProto.getField(fd);
            } else {
                tmp = new ArrayList<>();
                tmp.add(settingsProto.getField(fd));
            }
            Destination dest = fd.getOptions().getExtension(Privacy.privacy).getDest();
            for (Object o : tmp) {
                if (""android.providers.settings.SettingProto"".equals(fd.getMessageType().getFullName())) {
                    // The container's default privacy doesn't affect message types. However,
                    // anotations on the field override the message's default annotation. If a
                    // message field doesn't have an annotation, it is treated as EXPLICIT by
                    // default.
                    settings.put((SettingProto) o, dest == Destination.DEST_UNSET ? Destination.DEST_EXPLICIT : dest);
                } else {
                    // Sub messages don't inherit the container's default privacy. If the field had
                    // an annotation, it would override the sub message's default privacy.
                    settings.putAll(getSettingProtos((Message) o));
                }
            }
        }

        return settings;
    }

    private static <T> T invoke(Method method, Object instance, Object... args) {
        method.setAccessible(true);
        try {
            return (T) method.invoke(instance, args);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private static <T> T invoke(Message instance, String methodName, Object... args)
            throws Exception {
        final Class<?>[] inputParamTypes = Arrays.stream(args)
                .map((arg) -> toPrimitive(arg.getClass()))
                .toArray(Class[]::new);
        return invoke(
                instance.getClass().getDeclaredMethod(methodName, inputParamTypes),
                instance, args);
    }

    private static Class<?> toPrimitive(Class<?> c) {
        return c == Integer.class ? int.class : c;
    }

    private static void verifySettings(Map<SettingProto, Destination> settings, final int filterLevel) throws Exception {
        assertFalse(settings.isEmpty());

        CLog.d(""Field count: "" + settings.size());
        for (Map.Entry<SettingProto, Destination> sDPair : settings.entrySet()) {
            SettingProto setting = sDPair.getKey();
            Destination dest = sDPair.getValue();
            try {
                final String id = setting.getId();
                if (!id.isEmpty()) {
                    // _ID has to be a long converted to a String
                    Long.parseLong(id);
                }
                assertNotNull(setting.getName());
                if (filterLevel < PRIVACY_LOCAL) {
                    if  (dest == Destination.DEST_LOCAL) {
                        // Any filter that is not LOCAL should make sure local isn't printed at all.
                        String err = ""Setting '"" + setting.getName() + ""' with LOCAL privacy didn't strip data for filter level '"" + privacyToString(filterLevel) + ""'"";
                        assertTrue(err, setting.getId().isEmpty());
                        assertTrue(err, setting.getName().isEmpty());
                        assertTrue(err, setting.getPkg().isEmpty());
                        assertTrue(err, setting.getValue().isEmpty());
                        assertTrue(err, setting.getDefaultValue().isEmpty());
                    }
                    if (filterLevel < PRIVACY_EXPLICIT) {
                        if (dest == Destination.DEST_EXPLICIT) {
                            String err = ""Setting '"" + setting.getName() + ""' with EXPLICIT privacy didn't strip data for filter level '"" + privacyToString(filterLevel) + ""'"";
                            assertTrue(err, setting.getId().isEmpty());
                            assertTrue(err, setting.getName().isEmpty());
                            assertTrue(err, setting.getPkg().isEmpty());
                            assertTrue(err, setting.getValue().isEmpty());
                            assertTrue(err, setting.getDefaultValue().isEmpty());
                        }
                    }
                }
                // pkg is optional
                // value can be anything
                // default can be anything
                // default from system reported only if optional default present
            } catch (Throwable e) {
                throw new AssertionError(""Failed for setting "" + setting, e);
            }
        }
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/incident/src/com/android/server/cts/SettingsIncidentTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.renderscript.cts.BaseObjTest"	"testBaseObj"	"CtsRenderscriptTestCases"	"1: ui"	"public void testBaseObj() {
        Element E = Element.I32(mRS);
        Type.Builder TB = new Type.Builder(mRS, E);
        Type T = TB.setX(1).create();
        assertTrue(T != null);
        BaseObj B = T;
        B.setName(""int32_t"");
        try {
            B.setName(""int32_t"");
            fail(""set name twice for a BaseObj"");
        } catch (RSIllegalArgumentException e) {
        }
        T.destroy();

        T = TB.setX(2).create();
        assertTrue(T != null);
        B = T;
        try {
            B.setName("""");
            fail(""set empty name for a BaseObj"");
        } catch (RSIllegalArgumentException e) {
        }

        try {
            B.setName(null);
            fail(""set name as null string reference for a BaseObj"");
        } catch (RSIllegalArgumentException e) {
        }
        B.setName(""int32_t"");

        assertTrue(B.getName().compareTo(""int32_t"") == 0);
        B.destroy();
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/renderscript/src/android/renderscript/cts/BaseObjTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.verifier.nfc.hce.ConflictingNonPaymentEmulatorActivity"	"setPassFailButtonClickListeners"	""	"1: ui"	"public void testpackage com.android.cts.verifier.nfc.hce;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;

import com.android.cts.verifier.R;
import com.android.cts.verifier.nfc.NfcDialogs;

public class ConflictingNonPaymentEmulatorActivity extends BaseEmulatorActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);
        setupServices(this, TransportService1.COMPONENT, TransportService2.COMPONENT);
    }

    @Override
    protected void onResume() {
        super.onResume();
    }

    @Override
    void onServicesSetup(boolean result) {
        NfcDialogs.createHceTapReaderDialog(this,
                getString(R.string.nfc_hce_conflicting_non_payment_help)).show();
    }

    public static Intent buildReaderIntent(Context context) {
        Intent readerIntent = new Intent(context, SimpleReaderActivity.class);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_APDUS,
                TransportService2.APDU_COMMAND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_RESPONSES,
                TransportService2.APDU_RESPOND_SEQUENCE);
        readerIntent.putExtra(SimpleReaderActivity.EXTRA_LABEL,
                context.getString(R.string.nfc_hce_conflicting_non_payment_reader));
        return readerIntent;
    }

    @Override
    void onApduSequenceComplete(ComponentName component, long duration) {
        if (component.equals(TransportService2.COMPONENT)) {
            getPassButton().setEnabled(true);
        }
    }
}"	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/ConflictingNonPaymentEmulatorActivity.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.location.cts.gnss.asn1.supl2.supl_triggered_start.AreaIdList"	"AreaIdList"	"CtsLocationGnssTestCases"	"1: ui"	"public void test/*
 *.
 */

package android.location.cts.asn1.supl2.supl_triggered_start;

/*
 */


//
//
import android.location.cts.asn1.base.Asn1Null;
import android.location.cts.asn1.base.Asn1Object;
import android.location.cts.asn1.base.Asn1Sequence;
import android.location.cts.asn1.base.Asn1Tag;
import android.location.cts.asn1.base.BitStream;
import android.location.cts.asn1.base.BitStreamReader;
import android.location.cts.asn1.base.SequenceComponent;
import com.google.common.collect.ImmutableList;
import java.util.Collection;
import javax.annotation.Nullable;


/**
*/
public  class AreaIdList extends Asn1Sequence {
  //

  private static final Asn1Tag TAG_AreaIdList
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public AreaIdList() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_AreaIdList;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_AreaIdList != null) {
      return ImmutableList.of(TAG_AreaIdList);
    } else {
      return Asn1Sequence.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new AreaIdList from encoded stream.
   */
  public static AreaIdList fromPerUnaligned(byte[] encodedBytes) {
    AreaIdList result = new AreaIdList();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new AreaIdList from encoded stream.
   */
  public static AreaIdList fromPerAligned(byte[] encodedBytes) {
    AreaIdList result = new AreaIdList();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }



  @Override protected boolean isExtensible() {
    return false;
  }

  @Override public boolean containsExtensionValues() {
    for (SequenceComponent extensionComponent : getExtensionComponents()) {
      if (extensionComponent.isExplicitlySet()) return true;
    }
    return false;
  }

  
  private AreaIdSet areaIdSet_;
  public AreaIdSet getAreaIdSet() {
    return areaIdSet_;
  }
  /**
   * @throws ClassCastException if value is not a AreaIdSet
   */
  public void setAreaIdSet(Asn1Object value) {
    this.areaIdSet_ = (AreaIdSet) value;
  }
  public AreaIdSet setAreaIdSetToNewInstance() {
    areaIdSet_ = new AreaIdSet();
    return areaIdSet_;
  }
  
  private AreaIdSetType areaIdSetType_;
  public AreaIdSetType getAreaIdSetType() {
    return areaIdSetType_;
  }
  /**
   * @throws ClassCastException if value is not a AreaIdSetType
   */
  public void setAreaIdSetType(Asn1Object value) {
    this.areaIdSetType_ = (AreaIdSetType) value;
  }
  public AreaIdSetType setAreaIdSetTypeToNewInstance() {
    areaIdSetType_ = new AreaIdSetType();
    return areaIdSetType_;
  }
  
  private GeoAreaMappingList geoAreaMappingList_;
  public GeoAreaMappingList getGeoAreaMappingList() {
    return geoAreaMappingList_;
  }
  /**
   * @throws ClassCastException if value is not a GeoAreaMappingList
   */
  public void setGeoAreaMappingList(Asn1Object value) {
    this.geoAreaMappingList_ = (GeoAreaMappingList) value;
  }
  public GeoAreaMappingList setGeoAreaMappingListToNewInstance() {
    geoAreaMappingList_ = new GeoAreaMappingList();
    return geoAreaMappingList_;
  }
  

  

  

  @Override public Iterable<? extends SequenceComponent> getComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 0);

          @Override public boolean isExplicitlySet() {
            return getAreaIdSet() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getAreaIdSet();
          }

          @Override public void setToNewInstance() {
            setAreaIdSetToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? AreaIdSet.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""areaIdSet : ""
                    + getAreaIdSet().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 1);

          @Override public boolean isExplicitlySet() {
            return getAreaIdSetType() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return true;
          }

          @Override public Asn1Object getComponentValue() {
            return getAreaIdSetType();
          }

          @Override public void setToNewInstance() {
            setAreaIdSetTypeToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? AreaIdSetType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""areaIdSetType : ""
                    + getAreaIdSetType().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 2);

          @Override public boolean isExplicitlySet() {
            return getGeoAreaMappingList() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return true;
          }

          @Override public Asn1Object getComponentValue() {
            return getGeoAreaMappingList();
          }

          @Override public void setToNewInstance() {
            setGeoAreaMappingListToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? GeoAreaMappingList.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""geoAreaMappingList : ""
                    + getGeoAreaMappingList().toIndentedString(indent);
              }
        });
    
    return builder.build();
  }

  @Override public Iterable<? extends SequenceComponent>
                                                    getExtensionComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
      
      return builder.build();
    }

  
  
  
  
  
  
  

    

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    StringBuilder builder = new StringBuilder();
    builder.append(""AreaIdList = {\n"");
    final String internalIndent = indent + ""  "";
    for (SequenceComponent component : getComponents()) {
      if (component.isExplicitlySet()) {
        builder.append(internalIndent)
            .append(component.toIndentedString(internalIndent));
      }
    }
    if (isExtensible()) {
      builder.append(internalIndent).append(""...\n"");
      for (SequenceComponent component : getExtensionComponents()) {
        if (component.isExplicitlySet()) {
          builder.append(internalIndent)
              .append(component.toIndentedString(internalIndent));
        }
      }
    }
    builder.append(indent).append(""};\n"");
    return builder.toString();
  }
}"	"/home/gpoor/cts-12-source/cts/tests/location/location_gnss/src/android/location/cts/gnss/asn1/supl2/supl_triggered_start/AreaIdList.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.location.cts.gnss.asn1.supl2.rrlp_components.GANSSPositionMethods"	"isTagImplicit"	"CtsLocationGnssTestCases"	"1: ui"	"public void test/*
 *.
 */

package android.location.cts.asn1.supl2.rrlp_components;

/*
 */


//
//
import android.location.cts.asn1.base.Asn1Null;
import android.location.cts.asn1.base.Asn1SequenceOf;
import android.location.cts.asn1.base.Asn1Tag;
import android.location.cts.asn1.base.BitStream;
import android.location.cts.asn1.base.BitStreamReader;
import com.google.common.collect.ImmutableList;
import java.util.Collection;
import javax.annotation.Nullable;


/**
 */
public  class GANSSPositionMethods
    extends Asn1SequenceOf<GANSSPositionMethod> {
  //

  private static final Asn1Tag TAG_GANSSPositionMethods
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public GANSSPositionMethods() {
    super();
    setMinSize(1);
setMaxSize(16);

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_GANSSPositionMethods;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_GANSSPositionMethods != null) {
      return ImmutableList.of(TAG_GANSSPositionMethods);
    } else {
      return Asn1SequenceOf.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new GANSSPositionMethods from encoded stream.
   */
  public static GANSSPositionMethods fromPerUnaligned(byte[] encodedBytes) {
    GANSSPositionMethods result = new GANSSPositionMethods();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new GANSSPositionMethods from encoded stream.
   */
  public static GANSSPositionMethods fromPerAligned(byte[] encodedBytes) {
    GANSSPositionMethods result = new GANSSPositionMethods();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  
  @Override public GANSSPositionMethod createAndAddValue() {
    GANSSPositionMethod value = new GANSSPositionMethod();
    add(value);
    return value;
  }

  

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    StringBuilder builder = new StringBuilder();
    builder.append(""GANSSPositionMethods = [\n"");
    final String internalIndent = indent + ""  "";
    for (GANSSPositionMethod value : getValues()) {
      builder.append(internalIndent)
          .append(value.toIndentedString(internalIndent));
    }
    builder.append(indent).append(""];\n"");
    return builder.toString();
  }
}"	"/home/gpoor/cts-12-source/cts/tests/location/location_gnss/src/android/location/cts/gnss/asn1/supl2/rrlp_components/GANSSPositionMethods.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.renderscript.cts.Matrix3fTest"	"testScale"	"CtsRenderscriptTestCases"	"1: system"	"public void testScale() {
        float[] expectedData = new float[setData.length];
        System.arraycopy(setData, 0, expectedData, 0, setData.length);
        float scaleX = 2.0f;
        float scaleY = 3.0f;
        float scaleZ = 4.0f;
        expectedData[0] *= scaleX;
        expectedData[1] *= scaleX;
        expectedData[2] *= scaleX;
        expectedData[3] *= scaleY;
        expectedData[4] *= scaleY;
        expectedData[5] *= scaleY;
        expectedData[6] *= scaleZ;
        expectedData[7] *= scaleZ;
        expectedData[8] *= scaleZ;

        Matrix3f m = new Matrix3f(setData);
        m.scale(scaleX, scaleY, scaleZ);
        checkData(m, expectedData);

        System.arraycopy(setData, 0, expectedData, 0, setData.length);
        expectedData[0] *= scaleX;
        expectedData[1] *= scaleX;
        expectedData[2] *= scaleX;
        expectedData[3] *= scaleY;
        expectedData[4] *= scaleY;
        expectedData[5] *= scaleY;

        m = new Matrix3f(setData);
        m.scale(scaleX, scaleY);
        checkData(m, expectedData);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/renderscript/src/android/renderscript/cts/Matrix3fTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.renderscript.cts.Matrix3fTest"	"testTranspose"	"CtsRenderscriptTestCases"	"1: system"	"public void testTranspose() {
        float[] expectedData = new float[setData.length];
        System.arraycopy(setData, 0, expectedData, 0, setData.length);

        for(int i = 0; i < 2; i++) {
            for(int j = i + 1; j < 3; j++) {
                float temp = expectedData[i*3 + j];
                expectedData[i*3 + j] = expectedData[j*3 + i];
                expectedData[j*3 + i] = temp;
            }
        }

        Matrix3f m = new Matrix3f(setData);
        m.transpose();

        checkData(m, expectedData);
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/renderscript/src/android/renderscript/cts/Matrix3fTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.releaseparser.JsonPrinter"	"getTestSuiteTradefed"	""	"4: mic apps ui system"	"public void test/*
 *.
 */

package com.android.cts.releaseparser;

import com.android.cts.releaseparser.ReleaseProto.*;
import com.android.json.stream.NewlineDelimitedJsonWriter;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.nio.charset.StandardCharsets;
import java.util.Collection;
import java.util.Map;

public class JsonPrinter {
    private String mOutputFilePathPrefix;
    private ReleaseContent mRelContent;
    private NewlineDelimitedJsonWriter mJsonWriter;

    public JsonPrinter(ReleaseContent relContent, String outputFilePathPrefix) {
        mRelContent = relContent;
        mOutputFilePathPrefix = outputFilePathPrefix;
    }

    public void write() {
        try {
            open(mOutputFilePathPrefix + ""-ReleaseContent.json"");
            writeReleaseContent();
            close();

            open(mOutputFilePathPrefix + ""-AppInfo.json"");
            writeAppInfo();
            close();
            open(mOutputFilePathPrefix + ""-ApiDep.json"");
            writeApiDep(mRelContent.getEntries().values());
            close();
        } catch (IOException ex) {
            System.err.println(""Unable to write json files: "" + mOutputFilePathPrefix);
            ex.printStackTrace();
        }
    }

    private void writeReleaseContent() throws IOException {
        mJsonWriter.beginObject();
        writeReleaseIDs();
        mJsonWriter.name(""name"").value(mRelContent.getName());
        mJsonWriter.name(""version"").value(mRelContent.getVersion());
        mJsonWriter.name(""build_number"").value(mRelContent.getBuildNumber());
        mJsonWriter.name(""fullname"").value(mRelContent.getFullname());
        mJsonWriter.name(""size"").value(mRelContent.getSize());
        mJsonWriter.name(""release_type"").value(mRelContent.getReleaseType().toString());
        mJsonWriter.name(""test_suite_tradefed"").value(mRelContent.getTestSuiteTradefed());
        mJsonWriter.name(""target_arch"").value(mRelContent.getTargetArch());
        writeProperties(mRelContent.getProperties());
        writeTargetFileInfo(mRelContent.getEntries().values());
        mJsonWriter.endObject();
        mJsonWriter.newlineDelimited();
    }

    private void writeReleaseIDs() throws IOException {
        mJsonWriter.name(""release_id"").value(mRelContent.getReleaseId());
        mJsonWriter.name(""content_id"").value(mRelContent.getContentId());
    }

    private void writeProperties(Map<String, String> pMap) throws IOException {
        mJsonWriter.name(""properties"");
        mJsonWriter.beginArray();
        for (Map.Entry<String, String> pSet : pMap.entrySet()) {
            mJsonWriter.beginObject();
            mJsonWriter.name(""key"").value(pSet.getKey());
            mJsonWriter.name(""value"").value(pSet.getValue());
            mJsonWriter.endObject();
        }
        mJsonWriter.endArray();
    }

    private void writeTargetFileInfo(Collection<Entry> entries) throws IOException {
        mJsonWriter.name(""files"");
        mJsonWriter.beginArray();
        for (Entry entry : entries) {
            mJsonWriter.beginObject();
            mJsonWriter.name(""name"").value(entry.getName());
            mJsonWriter.name(""type"").value(entry.getType().toString());
            mJsonWriter.name(""size"").value(entry.getSize());
            mJsonWriter.name(""content_id"").value(entry.getContentId());
            mJsonWriter.name(""code_id"").value(entry.getCodeId());
            mJsonWriter.name(""abi_architecture"").value(entry.getAbiArchitecture());
            mJsonWriter.name(""abi_bits"").value(entry.getAbiBits());
            mJsonWriter.name(""parent_folder"").value(entry.getParentFolder());
            mJsonWriter.name(""relative_path"").value(entry.getRelativePath());
            writeStringCollection(""dependencies"", entry.getDependenciesList());
            writeStringCollection(
                    ""dynamic_loading_dependencies"", entry.getDynamicLoadingDependenciesList());
            mJsonWriter.endObject();
        }
        mJsonWriter.endArray();
    }

    private void writeAppInfo() throws IOException {
        mJsonWriter.beginObject();
        writeReleaseIDs();

        mJsonWriter.name(""apps"");
        mJsonWriter.beginArray();
        Collection<Entry> entries = mRelContent.getEntries().values();
        for (Entry entry : entries) {
            if (entry.getType() == Entry.EntryType.APK) {
                AppInfo appInfo = entry.getAppInfo();
                mJsonWriter.beginObject();
                mJsonWriter.name(""name"").value(entry.getName());
                mJsonWriter.name(""content_id"").value(entry.getContentId());
                // from AppInfo Message
                mJsonWriter.name(""package_name"").value(appInfo.getPackageName());
                mJsonWriter.name(""version_code"").value(appInfo.getVersionCode());
                mJsonWriter.name(""version_name"").value(appInfo.getVersionName());
                mJsonWriter.name(""sdk_version"").value(appInfo.getSdkVersion());
                mJsonWriter.name(""target_sdk_version"").value(appInfo.getTargetSdkVersion());
                writeFeatureCollection(""uses_features"", appInfo.getUsesFeaturesList());
                writeLibraryCollection(""uses_libraries"", appInfo.getUsesLibrariesList());
                writeStringCollection(""native_code"", appInfo.getNativeCodeList());
                writeStringCollection(""uses_permissions"", appInfo.getUsesPermissionsList());
                writeStringCollection(""activities"", appInfo.getActivitiesList());
                writeStringCollection(""services"", appInfo.getServicesList());
                writeStringCollection(""provideries"", appInfo.getProvidersList());
                writeProperties(appInfo.getProperties());
                writePackageFileContent(""package_file_content"", appInfo.getPackageFileContent());
                mJsonWriter.name(""package_signature"").value(appInfo.getPackageSignature());
                mJsonWriter.endObject();
            }
        }
        mJsonWriter.endArray();
        mJsonWriter.endObject();
        mJsonWriter.newlineDelimited();
    }

    private void writeFeatureCollection(String name, Collection<UsesFeature> features)
            throws IOException {
        mJsonWriter.name(name);
        mJsonWriter.beginArray();
        for (UsesFeature feature : features) {
            mJsonWriter.beginObject();
            mJsonWriter.name(""name"").value(feature.getName());
            mJsonWriter.name(""required"").value(feature.getRequired());
            mJsonWriter.endObject();
        }
        mJsonWriter.endArray();
    }

    private void writeLibraryCollection(String name, Collection<UsesLibrary> libraries)
            throws IOException {
        mJsonWriter.name(name);
        mJsonWriter.beginArray();
        for (UsesLibrary library : libraries) {
            mJsonWriter.beginObject();
            mJsonWriter.name(""name"").value(library.getName());
            mJsonWriter.name(""required"").value(library.getRequired());
            mJsonWriter.endObject();
        }
        mJsonWriter.endArray();
    }

    private void writeStringCollection(String name, Collection<String> strings) throws IOException {
        mJsonWriter.name(name);
        mJsonWriter.beginArray();
        for (String str : strings) {
            mJsonWriter.value(str);
        }
        mJsonWriter.endArray();
    }

    private void writePackageFileContent(String name, PackageFileContent packageFileContent)
            throws IOException {
        mJsonWriter.name(name);
        mJsonWriter.beginArray();

        Collection<Entry> entries = packageFileContent.getEntries().values();
        for (Entry entry : entries) {
            mJsonWriter.beginObject();
            mJsonWriter.name(""name"").value(entry.getName());
            mJsonWriter.name(""size"").value(entry.getSize());
            mJsonWriter.name(""content_id"").value(entry.getContentId());
            mJsonWriter.endObject();
        }
        mJsonWriter.endArray();
    }

    private void writeApiDep(Collection<Entry> entries) throws IOException {
        for (Entry entry : entries) {
            if (entry.getType() == Entry.EntryType.APK) {
                writeApiPkg(entry);
            }
        }
    }

    private void writeApiPkg(Entry entry) throws IOException {
        for (ApiPackage pkg : entry.getAppInfo().getExternalApiPackagesList()) {
            for (ApiClass clazz : pkg.getClassesList()) {
                for (ApiMethod method : clazz.getMethodsList()) {
                    mJsonWriter.beginObject();
                    mJsonWriter.name(""content_id"").value(entry.getContentId());
                    mJsonWriter.name(""api_signature"").value(getApiSignature(pkg, clazz, method));
                    mJsonWriter.name(""class"").value(clazz.getName());
                    mJsonWriter.name(""method"").value(method.getName());
                    mJsonWriter.name(""file_name"").value(entry.getName());
                    mJsonWriter.name(""release_id"").value(ReleaseParser.getReleaseId(mRelContent));
                    mJsonWriter.endObject();
                    mJsonWriter.newlineDelimited();
                }
            }
        }
    }

    private String getApiSignature(ApiPackage pkg, ApiClass clazz, ApiMethod method) {
        StringBuilder signatureBuilder = new StringBuilder();
        signatureBuilder.append(method.getReturnType());
        signatureBuilder.append("" "");
        signatureBuilder.append(clazz.getName());
        signatureBuilder.append(""."");
        signatureBuilder.append(method.getName());
        signatureBuilder.append(""("");
        signatureBuilder.append(String.join("","", method.getParametersList()));
        signatureBuilder.append("")"");
        return signatureBuilder.toString();
    }

    private void open(String fileName) throws IOException {
        File jsonFile;

        jsonFile = new File(fileName);
        FileOutputStream fOutStrem = new FileOutputStream(jsonFile);
        mJsonWriter =
                new NewlineDelimitedJsonWriter(
                        new OutputStreamWriter(fOutStrem, StandardCharsets.UTF_8));
    }

    private void close() throws IOException {
        mJsonWriter.flush();
        mJsonWriter.close();
    }
}"	"/home/gpoor/cts-12-source/cts/tools/release-parser/src/com/android/cts/releaseparser/JsonPrinter.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.os.cts.ConditionVariableTest"	"testConditionVariable"	""	"1: system"	"public void testConditionVariable() throws Throwable {
        // test open then block(long)
        mConditionVariable.open();
        long time = System.currentTimeMillis();
        assertTrue(mConditionVariable.block(BLOCK_TIME));
        assertTrue(System.currentTimeMillis() - time < TOLERANCE_MS);

        // test close then block(long)
        mConditionVariable.close();
        time = System.currentTimeMillis();
        assertFalse(mConditionVariable.block(BLOCK_TIME));
        assertTrue(System.currentTimeMillis() - time >= BLOCK_TIME);

        // test block then open
        time = System.currentTimeMillis();
        TestThread t = new TestThread(new Runnable() {

            public void run() {
                try {
                    Thread.sleep(SLEEP_TIME);
                } catch (InterruptedException e) {
                    fail(e.getMessage());
                }
                mConditionVariable.open();
            }
        });

        t.start();
        mConditionVariable.block();
        long timeDelta = System.currentTimeMillis() - time;
        assertTrue(timeDelta >= BLOCK_TIME && timeDelta <= BLOCK_TIME + BLOCK_TIME_DELTA);
        t.joinAndCheck(WAIT_TIME);

        time = System.currentTimeMillis();
        t = new TestThread(new Runnable() {

            public void run() {
                try {
                    Thread.sleep(BLOCK_TIME >> 1);
                } catch (InterruptedException e) {
                    fail(e.getMessage());
                }
                mConditionVariable.open();
            }
        });
        t.start();

        assertTrue(mConditionVariable.block(BLOCK_TIME));
        t.joinAndCheck(WAIT_TIME);
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/ConditionVariableTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.verifier.displaycutout.DisplayCutoutTestActivity"	"setPassFailButtonClickListeners"	""	"2: hide system"	"public void test/*
 *.
 */

package com.android.cts.verifier.displaycutout;

import android.graphics.Color;
import android.graphics.Rect;
import android.os.Bundle;
import android.view.DisplayCutout;
import android.view.View;
import android.view.ViewGroup;
import android.view.Window;
import android.view.WindowInsets;
import android.view.WindowInsetsController;
import android.view.WindowManager;
import android.widget.Button;
import android.widget.Toast;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

public class DisplayCutoutTestActivity extends PassFailButtons.Activity {

    private View mDescription;
    private View mLeftButtons;
    private View mTopButtons;
    private View mRightButtons;
    private View mBottomButtons;
    private View mPassFailButton;

    private Toast mToast;
    private int mButtonSize;

    final private static int FLAG_PASS_BUTTON_ENABLE = 0xFFFF;
    private int mPassButtonEnableFlag = 0;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        getWindow().requestFeature(Window.FEATURE_NO_TITLE);
        WindowManager.LayoutParams lp = getWindow().getAttributes();
        lp.layoutInDisplayCutoutMode =
                WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS;
        getWindow().setAttributes(lp);
        getWindow().getDecorView().getWindowInsetsController().hide(WindowInsets.Type.systemBars());
        getWindow().getDecorView().getWindowInsetsController().setSystemBarsBehavior(
                WindowInsetsController.BEHAVIOR_SHOW_TRANSIENT_BARS_BY_SWIPE);

        setContentView(R.layout.display_cutout);

        mDescription = findViewById(R.id.enable_buttons_desc);
        mPassFailButton = findViewById(R.id.pass_fail_buttons);
        mLeftButtons = findViewById(R.id.left_buttons);
        mTopButtons = findViewById(R.id.top_buttons);
        mRightButtons = findViewById(R.id.right_buttons);
        mBottomButtons = findViewById(R.id.bottom_buttons);
        mButtonSize = getResources().getDimensionPixelSize(R.dimen.display_cutout_test_button_size);

        setPassFailButtonClickListeners();
        // only enable pass button when all test buttons are clicked.
        getPassButton().setEnabled(false);
        getWindow().getDecorView().setOnApplyWindowInsetsListener((v, insets) -> {
                updateButtons(insets.getDisplayCutout());
                return insets;
            });

    }

    public void updateButtons(DisplayCutout cutout) {
        Rect safeInsets = new Rect();
        if (cutout != null) {
            safeInsets.set(cutout.getSafeInsetLeft(),
                    cutout.getSafeInsetTop(),
                    cutout.getSafeInsetRight(),
                    cutout.getSafeInsetBottom());
        }

        // update left buttons
        ViewGroup.MarginLayoutParams lp =
                (ViewGroup.MarginLayoutParams) mLeftButtons.getLayoutParams();
        lp.leftMargin = safeInsets.left;
        lp.topMargin = safeInsets.top + mButtonSize;
        lp.bottomMargin = safeInsets.bottom + mButtonSize;
        mLeftButtons.setLayoutParams(lp);
        mLeftButtons.setVisibility(View.VISIBLE);

        // update top buttons
        lp = (ViewGroup.MarginLayoutParams) mTopButtons.getLayoutParams();
        lp.leftMargin = safeInsets.left + mButtonSize;
        lp.topMargin = safeInsets.top;
        lp.rightMargin = safeInsets.right + mButtonSize;
        mTopButtons.setLayoutParams(lp);
        mTopButtons.setVisibility(View.VISIBLE);

        // update right buttons
        lp = (ViewGroup.MarginLayoutParams) mRightButtons.getLayoutParams();
        lp.topMargin = safeInsets.top + mButtonSize;;
        lp.rightMargin = safeInsets.right;
        lp.bottomMargin = safeInsets.bottom + mButtonSize;;
        mRightButtons.setLayoutParams(lp);
        mRightButtons.setVisibility(View.VISIBLE);

        // update bottom buttons
        lp = (ViewGroup.MarginLayoutParams) mBottomButtons.getLayoutParams();
        lp.leftMargin = safeInsets.left + mButtonSize;
        lp.rightMargin = safeInsets.right + mButtonSize;
        lp.bottomMargin = safeInsets.bottom;
        mBottomButtons.setLayoutParams(lp);
        mBottomButtons.setVisibility(View.VISIBLE);

        // update description view
        lp = (ViewGroup.MarginLayoutParams) mDescription.getLayoutParams();
        lp.leftMargin = safeInsets.left + mButtonSize * 2;
        lp.rightMargin = safeInsets.right + mButtonSize * 2;
        mDescription.setLayoutParams(lp);

        // update pass fail button view
        lp = (ViewGroup.MarginLayoutParams) mPassFailButton.getLayoutParams();
        lp.leftMargin = safeInsets.left+ mButtonSize * 2;
        lp.rightMargin = safeInsets.right + mButtonSize * 2;
        mPassFailButton.setLayoutParams(lp);
    }

    public void onButtonClicked(View v) {
        final Button button = (Button) v;
        final int buttonNumber = Integer.valueOf((button.getText()).toString());
        String toastText = ""Button #"" + buttonNumber + ""  clicked"";
        if (mToast != null) {
            mToast.cancel();
        }
        mToast = Toast.makeText(getApplicationContext(), toastText, Toast.LENGTH_SHORT);
        mToast.show();

        // Indicate this button has been clicked.
        button.setTextColor(Color.BLUE);

        enablePassButtonIfNeeded(buttonNumber);
    }

    private void enablePassButtonIfNeeded(int buttonNumber) {
        mPassButtonEnableFlag |= (1 << buttonNumber);
        if (mPassButtonEnableFlag == FLAG_PASS_BUTTON_ENABLE) {
            getPassButton().setEnabled(true);
        }
    }
}"	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/displaycutout/DisplayCutoutTestActivity.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.net.wifi.nl80211.cts.WifiNl80211ManagerTest"	"testSetOnServiceDeadCallback"	"CtsWifiTestCases"	"2: ui system"	"public void testSetOnServiceDeadCallback() {
        try {
            WifiNl80211Manager manager = mContext.getSystemService(WifiNl80211Manager.class);
            manager.setOnServiceDeadCallback(() -> {});
        } catch (Exception ignore) {}
    }

    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/nl80211/cts/WifiNl80211ManagerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.net.wifi.nl80211.cts.WifiNl80211ManagerTest"	"testSendMgmtFrame"	"CtsWifiTestCases"	"1: system"	"public void testSendMgmtFrame() {
        try {
            WifiNl80211Manager manager = mContext.getSystemService(WifiNl80211Manager.class);
            manager.sendMgmtFrame(""wlan0"", new byte[]{}, -1, Runnable::run,
                    new WifiNl80211Manager.SendMgmtFrameCallback() {
                        @Override
                        public void onAck(int elapsedTimeMs) {}

                        @Override
                        public void onFailure(int reason) {}
                    });
        } catch (Exception ignore) {}
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/nl80211/cts/WifiNl80211ManagerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.net.wifi.nl80211.cts.WifiNl80211ManagerTest"	"testGetTxPacketCounters"	"CtsWifiTestCases"	"1: system"	"public void testGetTxPacketCounters() {
        try {
            WifiNl80211Manager manager = mContext.getSystemService(WifiNl80211Manager.class);
            manager.getTxPacketCounters(""wlan0"");
        } catch (Exception ignore) {}
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/nl80211/cts/WifiNl80211ManagerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.net.wifi.nl80211.cts.WifiNl80211ManagerTest"	"testCountryCodeChangeListener"	"CtsWifiTestCases"	"1: system"	"public void testCountryCodeChangeListener() {
        TestCountryCodeChangeListener testCountryCodeChangeListener =
                new TestCountryCodeChangeListener();
        TestExecutor executor = new TestExecutor();
        WifiManager wifiManager = mContext.getSystemService(WifiManager.class);
        // Enable wifi to trigger country code change
        wifiManager.setWifiEnabled(true);
        WifiNl80211Manager manager = mContext.getSystemService(WifiNl80211Manager.class);
        // Register listener and unregister listener for API coverage only.
        // Since current cts don't have sufficient permission to call WifiNl80211Manager API.
        // Assert register fail because the CTS don't have sufficient permission to call
        // WifiNl80211Manager API which are guarded by selinux.
        assertFalse(manager.registerCountryCodeChangedListener(executor,
                testCountryCodeChangeListener));
        manager.unregisterCountryCodeChangedListener(testCountryCodeChangeListener);
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/nl80211/cts/WifiNl80211ManagerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.cts.host.utils.DeviceJUnit4ClassRunnerWithParameters"	"getTestInformation"	""	"1: ui"	"public void test/*
 *.
 */
package android.cts.host.utils;

import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.config.Option;
import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.invoker.TestInformation;
import com.android.tradefed.testtype.HostTest;
import com.android.tradefed.testtype.IAbi;
import com.android.tradefed.testtype.IAbiReceiver;
import com.android.tradefed.testtype.IBuildReceiver;
import com.android.tradefed.testtype.IDeviceTest;
import com.android.tradefed.testtype.ISetOptionReceiver;
import com.android.tradefed.testtype.ITestInformationReceiver;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.junit.Ignore;
import org.junit.runner.Description;
import org.junit.runner.Runner;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.InitializationError;
import org.junit.runners.parameterized.BlockJUnit4ClassRunnerWithParameters;
import org.junit.runners.parameterized.ParametersRunnerFactory;
import org.junit.runners.parameterized.TestWithParameters;

/**
 * Custom JUnit4 parameterized test runner that also accommodate {@link IDeviceTest}.
 */
public class DeviceJUnit4ClassRunnerWithParameters extends BlockJUnit4ClassRunnerWithParameters
        implements IDeviceTest, IBuildReceiver, IAbiReceiver, ISetOptionReceiver, ITestInformationReceiver {

    @Option(
        name = HostTest.SET_OPTION_NAME,
        description = HostTest.SET_OPTION_DESC
    )
    private Set<String> mKeyValueOptions = new HashSet<>();

    private TestInformation mTestInformation;
    private ITestDevice mDevice;
    private IBuildInfo mBuildInfo;
    private IAbi mAbi;

    public DeviceJUnit4ClassRunnerWithParameters(TestWithParameters test) throws InitializationError {
        super(test);
    }

    @Override
    public void setBuild(IBuildInfo buildInfo) {
        mBuildInfo = buildInfo;
    }


    @Override
    public void setAbi(IAbi abi) {
        mAbi = abi;
    }

    @Override
    public void setDevice(ITestDevice device) {
        mDevice = device;
    }

    @Override
    public ITestDevice getDevice() {
        return mDevice;
    }

    @Override
    public void setTestInformation(TestInformation testInformation) {
        mTestInformation = testInformation;
    }

    @Override
    public TestInformation getTestInformation() {
        return mTestInformation;
    }

    @Override
    public Description getDescription() {
        Description desc = Description.createSuiteDescription(getTestClass().getJavaClass());
        for (FrameworkMethod method : getChildren()) {
            desc.addChild(describeChild(method));
        }
        return desc;
    }

    @Override
    protected List<FrameworkMethod> getChildren() {
        List<FrameworkMethod> methods = super.getChildren();
        List<FrameworkMethod> filteredMethods = new ArrayList<>();
        for (FrameworkMethod method : methods) {
            Description desc = describeChild(method);
            if (desc.getAnnotation(Ignore.class) == null) {
                filteredMethods.add(method);
            }
        }
        return filteredMethods;
    }
    /**
     * We override createTest in order to set the device.
     */
    @Override
    public Object createTest() throws Exception {
        Object testObj = super.createTest();
        if (testObj instanceof IDeviceTest) {
            if (mDevice == null) {
                throw new IllegalArgumentException(""Missing device"");
            }
            ((IDeviceTest) testObj).setDevice(mDevice);
        }
        if (testObj instanceof IBuildReceiver) {
            if (mBuildInfo == null) {
                throw new IllegalArgumentException(""Missing build information"");
            }
            ((IBuildReceiver) testObj).setBuild(mBuildInfo);
        }
        // We are more flexible about abi information since not always available.
        if (testObj instanceof IAbiReceiver) {
            ((IAbiReceiver) testObj).setAbi(mAbi);
        }
        if (testObj instanceof ITestInformationReceiver) {
            ((ITestInformationReceiver) testObj).setTestInformation(mTestInformation);
        }
        HostTest.setOptionToLoadedObject(testObj, new ArrayList<String>(mKeyValueOptions));
        return testObj;
    }

    public static class RunnerFactory implements ParametersRunnerFactory {
        @Override
        public Runner createRunnerForTestWithParameters(TestWithParameters test)
                throws InitializationError {
            return new DeviceJUnit4ClassRunnerWithParameters(test);
        }
    }

}"	"/home/gpoor/cts-12-source/cts/hostsidetests/utils/src/android/cts/host/utils/DeviceJUnit4ClassRunnerWithParameters.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.view.cts.GLProducerThread"	"eglGetDisplay"	"CtsViewTestCases"	"1: mic"	"public void test/*
 *.
 */
package android.view.cts;

import android.graphics.SurfaceTexture;
import android.opengl.GLUtils;

import junit.framework.Assert;

import java.util.concurrent.Semaphore;
import java.util.concurrent.atomic.AtomicBoolean;

import javax.microedition.khronos.egl.EGL10;
import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.egl.EGLContext;
import javax.microedition.khronos.egl.EGLDisplay;
import javax.microedition.khronos.egl.EGLSurface;

public class GLProducerThread extends Thread {
    private final int mFrames;
    private final int mDelayMs;
    private final Semaphore mSemaphore;
    private final SurfaceTexture mSurfaceTexture;
    private final AtomicBoolean mShouldRender;
    private final GLRenderer mRenderer;

    private EGL10 mEgl;
    private EGLDisplay mEglDisplay = EGL10.EGL_NO_DISPLAY;
    private EGLContext mEglContext = EGL10.EGL_NO_CONTEXT;
    private EGLSurface mEglSurface = EGL10.EGL_NO_SURFACE;

    private static final int EGL_CONTEXT_CLIENT_VERSION = 0x3098;
    private static final int EGL_OPENGL_ES2_BIT = 4;

    public interface GLRenderer {
        void drawFrame(int frame);
    }

    private GLProducerThread(SurfaceTexture surfaceTexture, GLRenderer renderer,
            AtomicBoolean shouldRender,
            int frames, int delayMs, Semaphore semaphore) {
        mShouldRender = shouldRender;
        mFrames = frames;
        mDelayMs = delayMs;
        mSemaphore = semaphore;
        mSurfaceTexture = surfaceTexture;
        mRenderer = renderer;
    }

    GLProducerThread(SurfaceTexture surfaceTexture, GLRenderer renderer, int frames, int delayMs,
            Semaphore semaphore) {
        this(surfaceTexture, renderer, null, frames, delayMs, semaphore);
    }

    GLProducerThread(SurfaceTexture surfaceTexture, GLRenderer renderer, AtomicBoolean shouldRender,
            int delayMs, Semaphore semaphore) {
        this(surfaceTexture, renderer, shouldRender, 0, delayMs, semaphore);
    }

    private void initGL() {
        mEgl = (EGL10) EGLContext.getEGL();

        mEglDisplay = mEgl.eglGetDisplay(EGL10.EGL_DEFAULT_DISPLAY);
        if (mEglDisplay == EGL10.EGL_NO_DISPLAY) {
            throw new RuntimeException(""eglGetDisplay() failed ""
                    + GLUtils.getEGLErrorString(mEgl.eglGetError()));
        }

        int[] version = new int[2];
        if (!mEgl.eglInitialize(mEglDisplay, version)) {
            throw new RuntimeException(""eglInitialize() failed ""
                    + GLUtils.getEGLErrorString(mEgl.eglGetError()));
        }

        int[] configAttribs = {
            EGL10.EGL_BUFFER_SIZE, 32,
            EGL10.EGL_ALPHA_SIZE, 8,
            EGL10.EGL_BLUE_SIZE, 8,
            EGL10.EGL_GREEN_SIZE, 8,
            EGL10.EGL_RED_SIZE, 8,
            EGL10.EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
            EGL10.EGL_SURFACE_TYPE, EGL10.EGL_WINDOW_BIT,
            EGL10.EGL_NONE
        };

        int[] numConfigs = new int[1];
        EGLConfig[] configs = new EGLConfig[1];
        if (!mEgl.eglChooseConfig(mEglDisplay, configAttribs, configs, 1, numConfigs)
                || numConfigs[0] == 0) {
            throw new RuntimeException(""eglChooseConfig() failed"");
        }

        int[] contextAttribs = {
            EGL_CONTEXT_CLIENT_VERSION, 2,
            EGL10.EGL_NONE };

        mEglContext = mEgl.eglCreateContext(mEglDisplay,
                configs[0], EGL10.EGL_NO_CONTEXT, contextAttribs);

        mEglSurface = mEgl.eglCreateWindowSurface(mEglDisplay,
                configs[0], mSurfaceTexture, null);

        if (mEglSurface == null || mEglSurface == EGL10.EGL_NO_SURFACE) {
            int error = mEgl.eglGetError();
            if (error == EGL10.EGL_BAD_NATIVE_WINDOW) {
                throw new RuntimeException(
                        ""eglCreateWindowSurface() returned EGL_BAD_NATIVE_WINDOW."");
            }
            throw new RuntimeException(""eglCreateWindowSurface() failed ""
                                       + GLUtils.getEGLErrorString(error));
        }

        if (!mEgl.eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface, mEglContext)) {
            throw new RuntimeException(""eglMakeCurrent() failed ""
                                       + GLUtils.getEGLErrorString(mEgl.eglGetError()));
        }
    }

    private void destroyGL() {
        mEgl.eglMakeCurrent(mEglDisplay,
                EGL10.EGL_NO_SURFACE, EGL10.EGL_NO_SURFACE, EGL10.EGL_NO_CONTEXT);
        mEgl.eglDestroyContext(mEglDisplay, mEglContext);
        mEgl.eglDestroySurface(mEglDisplay, mEglSurface);
        mEglContext = EGL10.EGL_NO_CONTEXT;
        mEglSurface = EGL10.EGL_NO_SURFACE;
    }

    @Override
    public void run() {
        initGL();

        int frame = 0;
        while (frame < mFrames || (mShouldRender != null && mShouldRender.get())) {
            if (mRenderer != null) {
                mRenderer.drawFrame(frame);
            }
            mEgl.eglSwapBuffers(mEglDisplay, mEglSurface);
            Assert.assertEquals(EGL10.EGL_SUCCESS, mEgl.eglGetError());
            try {
                sleep(mDelayMs);
            } catch (InterruptedException e) {
            }
            frame++;
        }

        mSemaphore.release();
        destroyGL();
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/GLProducerThread.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.app.cts.DialogTest"	"testShow"	"CtsAppTestCases"	"1: hide"	"public void testShow() throws Throwable {
        startDialogActivity(DialogStubActivity.TEST_DIALOG_WITHOUT_THEME);
        final Dialog d = mActivity.getDialog();
        final View decor = d.getWindow().getDecorView();

        mScenario.onActivity(activity -> {
            d.hide();
        });
        mInstrumentation.waitForIdleSync();

        assertEquals(View.GONE, decor.getVisibility());
        assertFalse(d.isShowing());

        mScenario.onActivity(activity -> {
                d.show();
        });
        mInstrumentation.waitForIdleSync();

        assertEquals(View.VISIBLE, decor.getVisibility());
        assertTrue(d.isShowing());
        dialogDismiss(d);
        assertFalse(d.isShowing());
    }"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DialogTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.app.cts.DialogTest"	"testRequireViewById"	"CtsAppTestCases"	"2: ui user"	"public void testRequireViewById() throws Throwable {
        startDialogActivity(DialogStubActivity.TEST_DIALOG_WITHOUT_THEME);
        final Dialog d = mActivity.getDialog();
        assertNotNull(d);

        // set content view to a four elements layout
        mScenario.onActivity(activity -> {
            d.setContentView(R.layout.alert_dialog_text_entry);
        });
        mInstrumentation.waitForIdleSync();

        // check if four elements are right there
        assertNotNull(d.requireViewById(R.id.username_view));
        assertNotNull(d.requireViewById(R.id.username_edit));
        assertNotNull(d.requireViewById(R.id.password_view));
        assertNotNull(d.requireViewById(R.id.password_edit));
        try {
            d.requireViewById(R.id.check_box); // not present
            fail(""should not get here, check_box should not be found"");
        } catch (IllegalArgumentException e) {
            // expected
        }
        try {
            d.requireViewById(View.NO_ID); // invalid
            fail(""should not get here, NO_ID should not be found"");
        } catch (IllegalArgumentException e) {
            // expected
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DialogTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.app.cts.DialogTest"	"testOnKeyMultiple"	"CtsAppTestCases"	"1: ui"	"public void testOnKeyMultiple() {
        startDialogActivity(DialogStubActivity.TEST_ONSTART_AND_ONSTOP);
        final TestDialog d = (TestDialog) mActivity.getDialog();

        assertNull(d.keyMultipleEvent);
        d.dispatchKeyEvent(new KeyEvent(KeyEvent.ACTION_MULTIPLE, KeyEvent.KEYCODE_UNKNOWN));
        assertTrue(d.isOnKeyMultipleCalled);
        assertFalse(d.onKeyMultipleReturn);
        assertEquals(KeyEvent.KEYCODE_UNKNOWN, d.keyMultipleEvent.getKeyCode());
        assertEquals(KeyEvent.ACTION_MULTIPLE, d.keyMultipleEvent.getAction());
    }

    private MotionEvent sendTouchEvent(long downTime, int action, float x, float y) {
        long eventTime = downTime;
        if (action != MotionEvent.ACTION_DOWN) {
            eventTime += 1;
        }
        MotionEvent event = MotionEvent.obtain(downTime, eventTime, action, x, y, 0);
        event.setSource(InputDevice.SOURCE_TOUCHSCREEN);
        mInstrumentation.getUiAutomation().injectInputEvent(event, true);
        mInstrumentation.waitForIdleSync();
        return event;
    }"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DialogTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.app.cts.DialogTest"	"testDispatchKeyEvent"	"CtsAppTestCases"	"2: ui user"	"public void testDispatchKeyEvent() {
        startDialogActivity(DialogStubActivity.TEST_ONSTART_AND_ONSTOP);
        final TestDialog d = (TestDialog) mActivity.getDialog();

        sendKeys(KeyEvent.KEYCODE_0);
        assertFalse(d.dispatchKeyEventResult);
        assertEquals(KeyEvent.KEYCODE_0, d.keyEvent.getKeyCode());

        d.setOnKeyListener(new OnKeyListener() {
            public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {
                if (KeyEvent.ACTION_DOWN == event.getAction()) {
                    if (KeyEvent.KEYCODE_0 == keyCode) {
                        mIsKey0Listened = true;
                        return true;
                    }

                    if (KeyEvent.KEYCODE_1 == keyCode) {
                        mIsKey1Listened = true;
                        return true;
                    }
                }

                return false;
            }
        });

        mIsKey1Listened = false;
        sendKeys(KeyEvent.KEYCODE_1);
        assertTrue(mIsKey1Listened);

        mIsKey0Listened = false;
        sendKeys(KeyEvent.KEYCODE_0);
        assertTrue(mIsKey0Listened);
    }

    /*
     * Test point
     * 1. registerForContextMenu() will OnCreateContextMenuListener on the view to this activity,
     * so onCreateContextMenu() will be called when it is time to show the context menu.
     * 2. Close context menu will make onPanelClosed to be called,
     * and onPanelClosed will calls through to the new onPanelClosed method.
     * 3. unregisterForContextMenu() will remove the OnCreateContextMenuListener on the view,
     * so onCreateContextMenu() will not be called when try to open context menu.
     * 4. Selected a item of context menu will make onMenuItemSelected() to be called,
     * and onMenuItemSelected will calls through to the new onContextItemSelected method.
     * 5. onContextMenuClosed is called whenever the context menu is being closed (either by
     * the user canceling the menu with the back/menu button, or when an item is selected).
     */"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DialogTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.app.cts.DialogTest"	"testContextMenu"	"CtsAppTestCases"	"1: ui"	"public void testContextMenu() throws Throwable {
        startDialogActivity(DialogStubActivity.TEST_ONSTART_AND_ONSTOP);
        final TestDialog d = (TestDialog) mActivity.getDialog();
        final LinearLayout parent = new LinearLayout(mContext);
        final MockView v = new MockView(mContext);
        parent.addView(v);
        assertFalse(v.isShowContextMenuCalled);
        // Register for context menu and open it
        mScenario.onActivity(activity -> {
            d.addContentView(parent, new LinearLayout.LayoutParams(
                    ViewGroup.LayoutParams.MATCH_PARENT,
                    ViewGroup.LayoutParams.WRAP_CONTENT));
            d.registerForContextMenu(v);
            d.openContextMenu(v);
        });
        PollingCheck.waitFor(d::contextMenuHasWindowFocus);
        PollingCheck.waitFor(() -> v.isShowContextMenuCalled);
        PollingCheck.waitFor(() -> d.isOnCreateContextMenuCalled);

        assertFalse(d.isOnPanelClosedCalled);
        assertFalse(d.isOnContextMenuClosedCalled);
        // Close context menu
        d.isOnWindowFocusChangedCalled = false;
        sendKeys(KeyEvent.KEYCODE_BACK);
        PollingCheck.waitFor(() -> d.isOnPanelClosedCalled);
        // Wait for window focus change after pressing back
        PollingCheck.waitFor(() -> d.isOnWindowFocusChangedCalled);
        // Here isOnContextMenuClosedCalled should be true, see bug 1716918.
        assertFalse(d.isOnContextMenuClosedCalled);

        v.isShowContextMenuCalled = false;
        d.isOnCreateContextMenuCalled = false;
        // Unregister for context menu, and try to open it
        mScenario.onActivity(activity -> {
            d.unregisterForContextMenu(v);
        });

        mScenario.onActivity(activity -> {
            d.openContextMenu(v);
        });

        assertTrue(v.isShowContextMenuCalled);
        assertFalse(d.isOnCreateContextMenuCalled);

        // Register for context menu and open it again
        v.isShowContextMenuCalled = false;
        d.isOnCreateContextMenuCalled = false;
        mScenario.onActivity(activity -> {
            d.registerForContextMenu(v);
            d.openContextMenu(v);
        });
        PollingCheck.waitFor(() -> d.isOnCreateContextMenuCalled);
        PollingCheck.waitFor(() -> v.isShowContextMenuCalled);
        PollingCheck.waitFor(d::contextMenuHasWindowFocus);

        assertFalse(d.isOnContextItemSelectedCalled);
        assertFalse(d.isOnMenuItemSelectedCalled);
        d.isOnPanelClosedCalled = false;
        assertFalse(d.isOnContextMenuClosedCalled);
        // select a context menu item
        d.selectContextMenuItem();
        assertTrue(d.isOnMenuItemSelectedCalled);
        // Here isOnContextItemSelectedCalled should be true, see bug 1716918.
        assertFalse(d.isOnContextItemSelectedCalled);
        PollingCheck.waitFor(() -> d.isOnPanelClosedCalled);
        // Here isOnContextMenuClosedCalled should be true, see bug 1716918.
        assertFalse(d.isOnContextMenuClosedCalled);
    }"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DialogTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.app.cts.DialogTest"	"testConstructor"	"CtsAppTestCases"	"1: system"	"public void testConstructor() {
        new Dialog(mContext);
        Dialog d = new Dialog(mContext, 0);
        // According to javadoc of constructors, it will set theme to system default theme,
        // when we set no theme id or set it theme id to 0.
        // But CTS can no assert dialog theme equals system internal theme.

        d = new Dialog(mContext, R.style.TextAppearance);
        TypedArray ta =
            d.getContext().getTheme().obtainStyledAttributes(R.styleable.TextAppearance);
        assertTextAppearanceStyle(ta);

        final Window w = d.getWindow();
        ta = w.getContext().getTheme().obtainStyledAttributes(R.styleable.TextAppearance);
        assertTextAppearanceStyle(ta);
    }"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DialogTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.app.cts.DialogTest"	"testTouchEvent"	"CtsAppTestCases"	"1: system"	"public void testTouchEvent() {
        // Watch activities cover the entire screen, so there is no way to touch outside.
        assumeFalse(mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH));

        startDialogActivity(DialogStubActivity.TEST_ONSTART_AND_ONSTOP);
        final TestDialog d = (TestDialog) mActivity.getDialog();

        int dialogLocation[] = new int[2];
        d.getWindow().getDecorView().getRootView().getLocationOnScreen(dialogLocation);

        final int touchSlop = ViewConfiguration.get(mActivity).getScaledWindowTouchSlop();
        final int x = dialogLocation[0];
        final int y = dialogLocation[1] - (touchSlop + 1);

        assertNull(d.onTouchEvent);
        assertNull(d.touchEvent);
        assertFalse(d.isOnTouchEventCalled);

        // Tap outside the dialog window.  Expect the event to be ignored
        // because closeOnTouchOutside is false.
        d.setCanceledOnTouchOutside(false);

        long downTime = SystemClock.uptimeMillis();

        sendTouchEvent(downTime, MotionEvent.ACTION_DOWN, x, y).recycle();
        MotionEvent touchMotionEvent = sendTouchEvent(downTime, MotionEvent.ACTION_UP, x, y);

        assertMotionEventEquals(touchMotionEvent, d.touchEvent);
        assertTrue(d.isOnTouchEventCalled);
        assertMotionEventEquals(touchMotionEvent, d.onTouchEvent);
        d.isOnTouchEventCalled = false;
        assertTrue(d.isShowing());
        touchMotionEvent.recycle();

        // Send a touch event outside the dialog window. Expect the dialog to be dismissed
        // because closeOnTouchOutside is true.
        d.setCanceledOnTouchOutside(true);
        downTime = SystemClock.uptimeMillis();

        sendTouchEvent(downTime, MotionEvent.ACTION_DOWN, x, y).recycle();
        touchMotionEvent = sendTouchEvent(downTime, MotionEvent.ACTION_UP, x, y);

        assertMotionEventEquals(touchMotionEvent, d.touchEvent);
        assertTrue(d.isOnTouchEventCalled);
        assertMotionEventEquals(touchMotionEvent, d.onTouchEvent);
        assertFalse(d.isShowing());
        touchMotionEvent.recycle();
    }"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DialogTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.app.cts.DialogTest"	"testTrackballEvent"	"CtsAppTestCases"	"1: system"	"public void testTrackballEvent() {
        startDialogActivity(DialogStubActivity.TEST_ONSTART_AND_ONSTOP);
        final TestDialog d = (TestDialog) mActivity.getDialog();
        long eventTime = SystemClock.uptimeMillis();
        final MotionEvent trackBallEvent = MotionEvent.obtain(eventTime, eventTime,
                MotionEvent.ACTION_DOWN, 0.0f, 0.0f, 0);

        assertNull(d.trackballEvent);
        assertNull(d.onTrackballEvent);

        assertFalse(d.isOnTrackballEventCalled);
        mInstrumentation.sendTrackballEventSync(trackBallEvent);
        assertTrue(d.isOnTrackballEventCalled);
        assertMotionEventEquals(trackBallEvent, d.trackballEvent);
        assertMotionEventEquals(trackBallEvent, d.onTrackballEvent);

    }

    private void assertMotionEventEquals(final MotionEvent expected, final MotionEvent actual) {
        assertNotNull(actual);
        assertEquals(expected.getDownTime(), actual.getDownTime());
        assertEquals(expected.getEventTime(), actual.getEventTime());
        assertEquals(expected.getAction(), actual.getAction());
        assertEquals(expected.getMetaState(), actual.getMetaState());
        assertEquals(expected.getSize(), actual.getSize(), Float.MIN_VALUE);
        // As MotionEvent doc says the value of X and Y coordinate may have
        // a fraction for input devices that are sub-pixel precise,
        // so we won't assert them here.
    }"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DialogTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.app.cts.DialogTest"	"testSetContentView"	"CtsAppTestCases"	"1: user"	"public void testSetContentView() throws Throwable {
        startDialogActivity(DialogStubActivity.TEST_DIALOG_WITHOUT_THEME);
        final Dialog d = mActivity.getDialog();
        assertNotNull(d);

        // set content view to a four elements layout
        mScenario.onActivity(activity -> {
            d.setContentView(R.layout.alert_dialog_text_entry);
        });
        mInstrumentation.waitForIdleSync();

        // check if four elements are right there
        assertNotNull(d.findViewById(R.id.username_view));
        assertNotNull(d.findViewById(R.id.username_edit));
        assertNotNull(d.findViewById(R.id.password_view));
        assertNotNull(d.findViewById(R.id.password_edit));

        final LayoutInflater inflate1 = d.getLayoutInflater();

        // set content view to a two elements layout
        mScenario.onActivity(activity -> {
            d.setContentView(inflate1.inflate(R.layout.alert_dialog_text_entry_2, null));
        });
        mInstrumentation.waitForIdleSync();

        // check if only two elements are right there
        assertNotNull(d.findViewById(R.id.username_view));
        assertNotNull(d.findViewById(R.id.username_edit));
        assertNull(d.findViewById(R.id.password_view));
        assertNull(d.findViewById(R.id.password_edit));

        final WindowManager.LayoutParams lp = d.getWindow().getAttributes();
        final LayoutInflater inflate2 = mActivity.getLayoutInflater();

        // set content view to a four elements layout
        mScenario.onActivity(activity -> {
            d.setContentView(inflate2.inflate(R.layout.alert_dialog_text_entry, null), lp);
        });
        mInstrumentation.waitForIdleSync();

        // check if four elements are right there
        assertNotNull(d.findViewById(R.id.username_view));
        assertNotNull(d.findViewById(R.id.username_edit));
        assertNotNull(d.findViewById(R.id.password_view));
        assertNotNull(d.findViewById(R.id.password_edit));

        final WindowManager.LayoutParams lp2 = d.getWindow().getAttributes();
        final LayoutInflater inflate3 = mActivity.getLayoutInflater();
        lp2.height = ViewGroup.LayoutParams.WRAP_CONTENT;
        lp2.width = ViewGroup.LayoutParams.WRAP_CONTENT;

        // add a check box view
        mScenario.onActivity(activity -> {
            d.addContentView(inflate3.inflate(R.layout.checkbox_layout, null), lp2);
        });
        mInstrumentation.waitForIdleSync();

        // check if four elements are right there, and new add view there.
        assertNotNull(d.findViewById(R.id.check_box));
        assertNotNull(d.findViewById(R.id.username_view));
        assertNotNull(d.findViewById(R.id.username_edit));
        assertNotNull(d.findViewById(R.id.password_view));
        assertNotNull(d.findViewById(R.id.password_edit));
    }"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/DialogTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telephony.gba.cts.UaSecurityProtocolIdentifierTest"	"testDefaultId"	"CtsTelephonyTestCases"	"1: ui"	"public void testDefaultId() {
        UaSecurityProtocolIdentifier.Builder builder = new UaSecurityProtocolIdentifier.Builder();
        UaSecurityProtocolIdentifier sp = builder.build();
        assertNotNull(sp);
        assertEquals(UaSecurityProtocolIdentifier.ORG_NONE, sp.getOrg());
        assertArrayEquals(sp.toByteArray(), PROTO_DEFAULT);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/gba/cts/UaSecurityProtocolIdentifierTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telephony.gba.cts.UaSecurityProtocolIdentifierTest"	"testValid3gppId"	"CtsTelephonyTestCases"	"1: ui"	"public void testValid3gppId() {
        for (int i = 0; i < PROTO_3GPP_PLAIN_ID.length; i++) {
            UaSecurityProtocolIdentifier sp = testCreate3GppSpId(
                    PROTO_3GPP_PLAIN_ID[i], null, false);
            assertNotNull(sp);
            assertEquals(UaSecurityProtocolIdentifier.ORG_3GPP, sp.getOrg());
            assertEquals(PROTO_3GPP_PLAIN_ID[i], sp.getProtocol());
            assertEquals(0, sp.getTlsCipherSuite());
            assertArrayEquals(sp.toByteArray(), PROTO_3GPP_PLAIN[i]);
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/gba/cts/UaSecurityProtocolIdentifierTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telephony.gba.cts.UaSecurityProtocolIdentifierTest"	"testValid3gppIdWithTls"	"CtsTelephonyTestCases"	"1: ui"	"public void testValid3gppIdWithTls() {
        for (int i = 0; i < PROTO_3GPP_TLS_ID.length; i++) {
            for (int j = 0; j < TLS_CS_ID_SUPPORTED.length; j++) {
                UaSecurityProtocolIdentifier sp = testCreate3GppSpId(
                        PROTO_3GPP_TLS_ID[i], TLS_CS_ID_SUPPORTED[j], false);
                assertNotNull(sp);
                assertEquals(UaSecurityProtocolIdentifier.ORG_3GPP, sp.getOrg());
                assertEquals(PROTO_3GPP_TLS_ID[i], sp.getProtocol());
                assertEquals(TLS_CS_ID_SUPPORTED[j], sp.getTlsCipherSuite());
                byte[] targetData = new byte[PROTO_SIZE];
                ByteBuffer buf = ByteBuffer.wrap(targetData);
                buf.put(PROTO_3GPP_TLS[i]);
                buf.putShort(PROTO_SIZE - 2, (short) TLS_CS_ID_SUPPORTED[j]);
                assertArrayEquals(targetData, sp.toByteArray());
            }
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/gba/cts/UaSecurityProtocolIdentifierTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telephony.gba.cts.UaSecurityProtocolIdentifierTest"	"testIsTlsCipherSuiteSupported"	"CtsTelephonyTestCases"	"1: ui"	"public void testIsTlsCipherSuiteSupported() {
        Random rand = new Random();

        for (int i = 0; i < TLS_CS_ID_SUPPORTED.length; i++) {
            assertTrue(TlsParams.isTlsCipherSuiteSupported(TLS_CS_ID_SUPPORTED[i]));
        }

        for (int i = 0; i < 100; i++) {
            int val = rand.nextInt();
            if (Arrays.binarySearch(TLS_CS_ID_SUPPORTED, val) < 0) {
                assertFalse(TlsParams.isTlsCipherSuiteSupported(val));
            }
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/gba/cts/UaSecurityProtocolIdentifierTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telephony.gba.cts.UaSecurityProtocolIdentifierTest"	"testUaSecurityProtocolIdentifierBuilder"	"CtsTelephonyTestCases"	"1: ui"	"public void testUaSecurityProtocolIdentifierBuilder() {
        UaSecurityProtocolIdentifier sp = testCreate3GppSpId(
                PROTO_3GPP_TLS_ID[0], TLS_CS_ID_SUPPORTED[0], false);
        UaSecurityProtocolIdentifier.Builder builder =
                new UaSecurityProtocolIdentifier.Builder(sp);

        assertTrue(sp.equals(builder.build()));
    }

    private UaSecurityProtocolIdentifier testCreate3GppSpId(
            Integer id, Integer cs, boolean nullExpected) {
        boolean isFail = false;
        UaSecurityProtocolIdentifier sp = null;
        UaSecurityProtocolIdentifier.Builder builder = new UaSecurityProtocolIdentifier.Builder();
        builder.setOrg(UaSecurityProtocolIdentifier.ORG_3GPP);
        try {
            if (id != null) {
                builder.setProtocol(id);
            }
            if (cs != null) {
                builder.setTlsCipherSuite(cs);
            }
            sp = builder.build();
        } catch (IllegalArgumentException e) {
        }
        if (nullExpected) {
            assertNull(sp);
        } else {
            assertNotNull(sp);
        }
        return sp;
    }

    private String getRandomString(Random rand) {
        int size = rand.nextInt(64);
        byte[] arr = new byte[size];
        rand.nextBytes(arr);
        return new String(arr);
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/gba/cts/UaSecurityProtocolIdentifierTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telecom.cts.TelecomManagerNoPermissionsTest"	"testCallStateCompatPermissions"	"CtsTelecomTestCases"	"2: ui system"	"public void testCallStateCompatPermissions() throws Exception {
        if (!TestUtils.shouldTestTelecom(mContext)) {
            return;
        }

        try {
            TelecomManager tm = mContext.getSystemService(TelecomManager.class);
            assertNotNull(tm);

            TestUtils.enableCompatCommand(getInstrumentation(),
                    TestUtils.ENABLE_GET_CALL_STATE_PERMISSION_PROTECTION_STRING);
            try {

                tm.getCallState();
                fail(""TelecomManager#getCallState must require READ_PHONE_STATE when ""
                        + ""TelecomManager#ENABLE_GET_CALL_STATE_PERMISSION_PROTECTION is enabled"");
            } catch (SecurityException e) {
                // expected
            }
        } finally {
            TestUtils.resetCompatCommand(getInstrumentation(),
                    TestUtils.ENABLE_GET_CALL_STATE_PERMISSION_PROTECTION_STRING);
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom2/src/android/telecom/cts/TelecomManagerNoPermissionsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telecom.cts.TelecomManagerNoPermissionsTest"	"testGetPhoneAccountCompatPermissions"	"CtsTelecomTestCases"	"1: ui"	"public void testGetPhoneAccountCompatPermissions() throws Exception {
        if (!TestUtils.shouldTestTelecom(mContext)) {
            return;
        }

        try {
            TestUtils.enableCompatCommand(getInstrumentation(),
                    TestUtils.ENABLE_GET_PHONE_ACCOUNT_PERMISSION_PROTECTION_STRING);

            try {
                mTelecomManager.getPhoneAccount(TestUtils.TEST_DEFAULT_PHONE_ACCOUNT_HANDLE_1);
                fail(""TelecomManager#getPhoneAccount should require READ_PHONE_NUMBERS or ""
                        + ""READ_PRIVILEGED_PHONE_STATE when ""
                        + ""ENABLE_GET_PHONE_ACCOUNT_PERMISSION_PROTECTION is enabled"");
            } catch (SecurityException e) {
                //expected
            }
        } finally {
            TestUtils.resetCompatCommand(getInstrumentation(),
                    TestUtils.ENABLE_GET_PHONE_ACCOUNT_PERMISSION_PROTECTION_STRING);
        }
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom2/src/android/telecom/cts/TelecomManagerNoPermissionsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.assist.common.Utils"	"getExtraAssistBundle"	""	"3: hide ui system"	"public void test/*
 *.
 */
package android.assist.common;

import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.Bundle;
import android.os.LocaleList;
import android.os.Process;
import android.util.Log;

import org.json.JSONObject;

import java.util.ArrayList;
import java.util.Locale;

public class Utils {
    private static final String TAG = Utils.class.getSimpleName();
    public static final String TESTCASE_TYPE = ""testcase_type"";
    public static final String TESTINFO = ""testinfo"";
    public static final String ACTION_PREFIX = ""android.intent.action."";
    public static final String BROADCAST_INTENT = ACTION_PREFIX + ""ASSIST_TESTAPP"";
    public static final String BROADCAST_ASSIST_DATA_INTENT = ACTION_PREFIX + ""ASSIST_DATA"";
    public static final String BROADCAST_INTENT_START_ASSIST = ACTION_PREFIX + ""START_ASSIST"";
    public static final String ASSIST_RECEIVER_REGISTERED = ACTION_PREFIX + ""ASSIST_READY"";
    public static final String ACTION_END_OF_TEST = ACTION_PREFIX + ""END_OF_TEST"";

    public static final String ACTION_INVALIDATE = ""invalidate_action"";
    public static final String GET_CONTENT_VIEW_HEIGHT = ACTION_PREFIX + ""GET_CONTENT_VIEW_HEIGHT"";
    public static final String BROADCAST_CONTENT_VIEW_HEIGHT = ACTION_PREFIX + ""VIEW_HEIGHT"";
    public static final String SCROLL_TEXTVIEW_ACTION = ACTION_PREFIX + ""TEXTVIEW_SCROLL"";
    public static final String SCROLL_SCROLLVIEW_ACTION = ACTION_PREFIX + ""SCROLLVIEW_SCROLL"";
    public static final String TEST_ERROR = ""Error In Test:"";

    public static final String ASSIST_STRUCTURE_KEY = ""assist_structure"";
    public static final String ASSIST_CONTENT_KEY = ""assist_content"";
    public static final String ASSIST_BUNDLE_KEY = ""assist_bundle"";
    public static final String ASSIST_IS_ACTIVITY_ID_NULL = ""assist_is_activity_id_null"";
    public static final String ASSIST_SCREENSHOT_KEY = ""assist_screenshot"";
    public static final String SCREENSHOT_COLOR_KEY = ""set_screenshot_color"";
    public static final String COMPARE_SCREENSHOT_KEY = ""compare_screenshot"";
    public static final String DISPLAY_WIDTH_KEY = ""display_width"";
    public static final String DISPLAY_HEIGHT_KEY = ""dislay_height"";
    public static final String SCROLL_X_POSITION = ""scroll_x_position"";
    public static final String SCROLL_Y_POSITION = ""scroll_y_position"";
    public static final String SHOW_SESSION_FLAGS_TO_SET = ""show_session_flags_to_set"";

    /** Lifecycle Test intent constants */
    public static final String LIFECYCLE_PREFIX = ACTION_PREFIX + ""lifecycle_"";
    public static final String LIFECYCLE_HASRESUMED = LIFECYCLE_PREFIX + ""hasResumed"";
    public static final String LIFECYCLE_HASFOCUS = LIFECYCLE_PREFIX + ""hasFocus"";
    public static final String LIFECYCLE_LOSTFOCUS = LIFECYCLE_PREFIX + ""lostFocus"";
    public static final String LIFECYCLE_ONPAUSE = LIFECYCLE_PREFIX + ""onpause"";
    public static final String LIFECYCLE_ONSTOP = LIFECYCLE_PREFIX + ""onstop"";
    public static final String LIFECYCLE_ONDESTROY = LIFECYCLE_PREFIX + ""ondestroy"";

    /** Focus Change Test intent constants */
    public static final String GAINED_FOCUS = ACTION_PREFIX + ""focus_changed"";
    public static final String LOST_FOCUS = ACTION_PREFIX + ""lost_focus"";

    public static final String APP_3P_HASRESUMED = ACTION_PREFIX + ""app_3p_hasResumed"";
    public static final String APP_3P_HASDRAWED = ACTION_PREFIX + ""app_3p_hasDrawed"";
    public static final String TEST_ACTIVITY_DESTROY = ACTION_PREFIX + ""test_activity_destroy"";
    public static final String TEST_ACTIVITY_WEBVIEW_LOADED = ACTION_PREFIX + ""test_activity_webview_hasResumed"";

    // Notice: timeout belows have to be long because some devices / form factors (like car) are
    // slower.

    /** Timeout for getting back assist context */
    public static final int TIMEOUT_MS = 4 * 1_000;
    /** Timeout for an activity to resume */
    public static final int ACTIVITY_ONRESUME_TIMEOUT_MS = 8 * 1_000;

    public static final String EXTRA_REGISTER_RECEIVER = ""register_receiver"";

    /** Extras for passing the Assistant's ContentView's dimensions*/
    public static final String EXTRA_CONTENT_VIEW_HEIGHT = ""extra_content_view_height"";
    public static final String EXTRA_CONTENT_VIEW_WIDTH = ""extra_content_view_width"";
    public static final String EXTRA_DISPLAY_POINT = ""extra_display_point"";

    /*
     * Extras used to pass RemoteCallback objects responsible for IPC between test, app, and
     * service.
     */
    public static final String EXTRA_REMOTE_CALLBACK = ""extra_remote_callback"";
    public static final String EXTRA_REMOTE_CALLBACK_ACTION = ""extra_remote_callback_action"";

    public static final String EXTRA_REMOTE_CALLBACK_RECEIVING = ""extra_remote_callback_receiving"";
    public static final String EXTRA_REMOTE_CALLBACK_RECEIVING_ACTION = ""extra_remote_callback_receiving_action"";

    /** Test name suffixes */
    public static final String ASSIST_STRUCTURE = ""ASSIST_STRUCTURE"";
    public static final String DISABLE_CONTEXT = ""DISABLE_CONTEXT"";
    public static final String FLAG_SECURE = ""FLAG_SECURE"";
    public static final String LIFECYCLE = ""LIFECYCLE"";
    public static final String LIFECYCLE_NOUI = ""LIFECYCLE_NOUI"";
    public static final String SCREENSHOT = ""SCREENSHOT"";
    public static final String EXTRA_ASSIST = ""EXTRA_ASSIST"";
    public static final String VERIFY_CONTENT_VIEW = ""VERIFY_CONTENT_VIEW"";
    public static final String TEXTVIEW = ""TEXTVIEW"";
    public static final String LARGE_VIEW_HIERARCHY = ""LARGE_VIEW_HIERARCHY"";
    public static final String WEBVIEW = ""WEBVIEW"";
    public static final String FOCUS_CHANGE = ""FOCUS_CHANGE"";

    /** Session intent constants */
    public static final String HIDE_SESSION = ""android.intent.action.hide_session"";
    public static final String HIDE_SESSION_COMPLETE = ""android.intent.action.hide_session_complete"";

    /** Lifecycle activity intent constants */
    /** Session intent constants */
    public static final String HIDE_LIFECYCLE_ACTIVITY
            = ""android.intent.action.hide_lifecycle_activity"";

    /** Stub html view to load into WebView */
    public static final String WEBVIEW_HTML_URL = ""http://dev.null/thou/should?not=pass"";
    public static final String WEBVIEW_HTML_DOMAIN = ""dev.null"";
    public static final LocaleList WEBVIEW_LOCALE_LIST = new LocaleList(Locale.ROOT, Locale.US);
    public static final String WEBVIEW_HTML_GREETING = ""Hello WebView!"";
    public static final String WEBVIEW_HTML = ""<html><body><div><p>"" + WEBVIEW_HTML_GREETING
            + ""</p></div></body></html>"";

    /** Extra data to add to assist data and assist content */
    private static Bundle EXTRA_ASSIST_BUNDLE;
    private static String STRUCTURED_JSON;

    private static String MY_UID_EXTRA = ""my_uid"";

    public static final String getStructuredJSON() throws Exception {
        if (STRUCTURED_JSON == null) {
            STRUCTURED_JSON = new JSONObject()
                    .put(""@type"", ""MusicRecording"")
                    .put(""@id"", ""https://example/music/recording"")
                    .put(""url"", ""android-app://com.example/https/music/album"")
                    .put(""name"", ""Album Title"")
                    .put(""hello"", ""hi there"")
                    .put(""knownNull"", null)
                    .put(""unicode value"", ""\ud800\udc35"")
                    .put(""empty string"", """")
                    .put(""LongString"",
                        ""lkasdjfalsdkfjalsdjfalskj9i9234jl1w23j4o123j412l3j421l3kj412l3kj1l3k4j32"")
                    .put(""\ud800\udc35"", ""any-value"")
                    .put(""key with spaces"", ""any-value"")
                    .toString();
        }
        return STRUCTURED_JSON;
    }

    public static final Bundle getExtraAssistBundle() {
        if (EXTRA_ASSIST_BUNDLE == null) {
            EXTRA_ASSIST_BUNDLE = new Bundle();
            addExtraAssistDataToBundle(EXTRA_ASSIST_BUNDLE, /* addMyUid= */ false);
        }
        return EXTRA_ASSIST_BUNDLE;
    }

    public static void addExtraAssistDataToBundle(Bundle data) {
        addExtraAssistDataToBundle(data, /* addMyUid= */ true);

    }

    private static void addExtraAssistDataToBundle(Bundle data, boolean addMyUid) {
        data.putString(""hello"", ""there"");
        data.putBoolean(""isthis_true_or_false"", true);
        data.putInt(""number"", 123);
        if (addMyUid) {
            Log.i(TAG, ""adding "" + MY_UID_EXTRA + ""="" + Process.myUid());
            data.putInt(MY_UID_EXTRA, Process.myUid());
        }
    }

    /**
     * The test app associated with each test.
     */
    public static final ComponentName getTestAppComponent(String testCaseType) {
        switch (testCaseType) {
            case ASSIST_STRUCTURE:
            case LARGE_VIEW_HIERARCHY:
            case DISABLE_CONTEXT:
                return new ComponentName(
                        ""android.assist.testapp"", ""android.assist.testapp.TestApp"");
            case FLAG_SECURE:
                return new ComponentName(
                        ""android.assist.testapp"", ""android.assist.testapp.SecureActivity"");
            case LIFECYCLE:
            case LIFECYCLE_NOUI:
                return new ComponentName(
                        ""android.assist.testapp"", ""android.assist.testapp.LifecycleActivity"");
            case SCREENSHOT:
                return new ComponentName(
                        ""android.assist.testapp"", ""android.assist.testapp.ScreenshotActivity"");
            case EXTRA_ASSIST:
                return new ComponentName(
                        ""android.assist.testapp"", ""android.assist.testapp.ExtraAssistDataActivity"");
            case TEXTVIEW:
                return new ComponentName(
                        ""android.assist.testapp"", ""android.assist.testapp.TextViewActivity"");
            case WEBVIEW:
                return new ComponentName(
                        ""android.assist.testapp"", ""android.assist.testapp.WebViewActivity"");
            case FOCUS_CHANGE:
                return new ComponentName(
                        ""android.assist.testapp"", ""android.assist.testapp.FocusChangeActivity"");
            default:
                return new ComponentName("""","""");
        }
    }

    /**
     * Sets the proper action used to launch an activity in the testapp package.
     */
    public static void setTestAppAction(Intent intent, String testCaseName) {
        intent.putExtra(Utils.TESTCASE_TYPE, testCaseName);
        intent.setAction(""android.intent.action.TEST_APP_"" + testCaseName);
    }

    /**
     * Returns the amount of time to wait for assist data.
     */
    public static final int getAssistDataTimeout(String testCaseType) {
        switch (testCaseType) {
            case SCREENSHOT:
                // needs to wait for 3p activity to resume before receiving assist data.
                return TIMEOUT_MS + ACTIVITY_ONRESUME_TIMEOUT_MS;
            default:
                return TIMEOUT_MS;
        }
    }

    public static final String toBundleString(Bundle bundle) {
        if (bundle == null) {
            return ""*** Bundle is null ****"";
        }
        StringBuffer buf = new StringBuffer(""Bundle is: "");
        String testType = bundle.getString(TESTCASE_TYPE);
        if (testType != null) {
            buf.append(""testcase type = "" + testType);
        }
        ArrayList<String> info = bundle.getStringArrayList(TESTINFO);
        if (info != null) {
            for (String s : info) {
                buf.append(s + ""\n\t\t"");
            }
        }
        return buf.toString();
    }

    public static final void addErrorResult(final Bundle testinfo, final String msg) {
        testinfo.getStringArrayList(testinfo.getString(Utils.TESTCASE_TYPE))
            .add(TEST_ERROR + "" "" + msg);
    }

    public static int getExpectedUid(Bundle extras) {
        return extras.getInt(MY_UID_EXTRA);
    }

    public static Bundle bundleOfRemoteAction(String action) {
        Bundle bundle = new Bundle();
        bundle.putString(Utils.EXTRA_REMOTE_CALLBACK_ACTION, action);
        return bundle;
    }

    public static boolean isAutomotive(Context context) {
        return context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/assist/common/src/android/assist/common/Utils.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.managedprofile.DeviceIdentifiersTest"	"testProfileOwnerOnPersonalDeviceCannotGetDeviceIdentifiers"	""	"2: ui system"	"public void testProfileOwnerOnPersonalDeviceCannotGetDeviceIdentifiers() {
        // The profile owner with the READ_PHONE_STATE permission should still receive a
        // SecurityException when querying for device identifiers if it's not on an
        // organization-owned device.
        TelephonyManager telephonyManager = (TelephonyManager) mContext.getSystemService(
                Context.TELEPHONY_SERVICE);
        // Allow the APIs to also return null if the telephony feature is not supported.
        boolean hasTelephonyFeature =
                mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_TELEPHONY);

        boolean mayReturnNull = !hasTelephonyFeature;

        assertAccessDenied(telephonyManager::getDeviceId, mayReturnNull);
        assertAccessDenied(telephonyManager::getImei, mayReturnNull);
        assertAccessDenied(telephonyManager::getMeid, mayReturnNull);
        assertAccessDenied(telephonyManager::getSubscriberId, mayReturnNull);
        assertAccessDenied(telephonyManager::getSimSerialNumber, mayReturnNull);
        assertAccessDenied(telephonyManager::getNai, mayReturnNull);
        assertAccessDenied(Build::getSerial, mayReturnNull);
    }

    private static <T> void assertAccessDenied(ThrowingProvider<T> provider,
            boolean mayReturnNull) {
        try {
            T object = provider.get();
            if (mayReturnNull) {
                assertNull(object);
            } else {
                fail(""Expected SecurityException, received "" + object);
            }
        } catch (SecurityException ignored) {
            // assertion succeeded
        } catch (Throwable th) {
            fail(""Expected SecurityException but was: "" + th);
        }
    }

    private interface ThrowingProvider<T> {
        T get() throws Throwable;
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/ManagedProfile/src/com/android/cts/managedprofile/DeviceIdentifiersTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.webkit.cts.WebViewOnUiThread"	"clearHistory"	""	"2: direct ui"	"public void test/*
 *.
 */

package android.webkit.cts;

import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Picture;
import android.graphics.Rect;
import android.net.Uri;
import android.net.http.SslCertificate;
import android.os.Message;
import android.print.PrintDocumentAdapter;
import android.util.DisplayMetrics;
import android.view.View;
import android.view.ViewGroup;
import android.view.ViewParent;
import android.webkit.CookieManager;
import android.webkit.DownloadListener;
import android.webkit.ValueCallback;
import android.webkit.WebBackForwardList;
import android.webkit.WebChromeClient;
import android.webkit.WebMessage;
import android.webkit.WebMessagePort;
import android.webkit.WebSettings;
import android.webkit.WebView;
import android.webkit.WebView.HitTestResult;
import android.webkit.WebView.PictureListener;
import android.webkit.WebView.VisualStateCallback;
import android.webkit.WebViewClient;
import android.webkit.WebViewRenderProcessClient;

import com.android.compatibility.common.util.PollingCheck;

import com.google.common.util.concurrent.SettableFuture;

import java.util.concurrent.Executor;

/**
 * Many tests need to run WebView code in the UI thread. This class
 * wraps a WebView so that calls are ensured to arrive on the UI thread.
 *
 * All methods may be run on either the UI thread or test thread.
 *
 * This should remain functionally equivalent to androidx.webkit.WebViewOnUiThread.
 * Modifications to this class should be reflected in that class as necessary. See
 * http://go/modifying-webview-cts.
 */
public class WebViewOnUiThread extends WebViewSyncLoader {
    /**
     * The WebView that calls will be made on.
     */
    private WebView mWebView;

    /**
     * Wraps a WebView to ensure that methods are run on the UI thread.
     *
     * A new WebViewOnUiThread should be called during setUp so as to
     * reinitialize between calls.
     *
     * The caller is responsible for destroying the WebView instance.
     *
     * @param webView The webView that the methods should call.
     */
    public WebViewOnUiThread(WebView webView) {
        super(webView);
        mWebView = webView;
    }

    public void cleanUp() {
        super.destroy();
    }

    public void setWebViewClient(final WebViewClient webViewClient) {
        WebkitUtils.onMainThreadSync(() -> {
            mWebView.setWebViewClient(webViewClient);
        });
    }

    public void setWebChromeClient(final WebChromeClient webChromeClient) {
        WebkitUtils.onMainThreadSync(() -> {
            mWebView.setWebChromeClient(webChromeClient);
        });
    }

    /**
     * Set the webview renderer client for {@code mWebView}, on the UI thread.
     */
    public void setWebViewRenderProcessClient(
            final WebViewRenderProcessClient webViewRenderProcessClient) {
        setWebViewRenderProcessClient(mWebView, webViewRenderProcessClient);
    }

    /**
     * Set the webview renderer client for {@code webView}, on the UI thread.
     */
    public static void setWebViewRenderProcessClient(
            final WebView webView,
            final WebViewRenderProcessClient webViewRenderProcessClient) {
        WebkitUtils.onMainThreadSync(() ->
                webView.setWebViewRenderProcessClient(webViewRenderProcessClient)
        );
    }

    /**
     * Set the webview renderer client for {@code mWebView}, on the UI thread, with callbacks
     * executed by {@code executor}
     */
    public void setWebViewRenderProcessClient(
            final Executor executor, final WebViewRenderProcessClient webViewRenderProcessClient) {
        setWebViewRenderProcessClient(mWebView, executor, webViewRenderProcessClient);
    }

    /**
     * Set the webview renderer client for {@code webView}, on the UI thread, with callbacks
     * executed by {@code executor}
     */
    public static void setWebViewRenderProcessClient(
            final WebView webView,
            final Executor executor,
            final WebViewRenderProcessClient webViewRenderProcessClient) {
        WebkitUtils.onMainThreadSync(() ->
                webView.setWebViewRenderProcessClient(executor, webViewRenderProcessClient)
        );
    }

    /**
     * Get the webview renderer client currently set on {@code mWebView}, on the UI thread.
     */
    public WebViewRenderProcessClient getWebViewRenderProcessClient() {
        return getWebViewRenderProcessClient(mWebView);
    }

    /**
     * Get the webview renderer client currently set on {@code webView}, on the UI thread.
     */
    public static WebViewRenderProcessClient getWebViewRenderProcessClient(
            final WebView webView) {
        return WebkitUtils.onMainThreadSync(() -> {
            return webView.getWebViewRenderProcessClient();
        });
    }

    public void setPictureListener(final PictureListener pictureListener) {
        WebkitUtils.onMainThreadSync(() -> {
            mWebView.setPictureListener(pictureListener);
        });
    }

    public void setNetworkAvailable(final boolean available) {
        WebkitUtils.onMainThreadSync(() -> {
            mWebView.setNetworkAvailable(available);
        });
    }

    public void setDownloadListener(final DownloadListener listener) {
        WebkitUtils.onMainThreadSync(() -> {
            mWebView.setDownloadListener(listener);
        });
    }

    public void setBackgroundColor(final int color) {
        WebkitUtils.onMainThreadSync(() -> {
            mWebView.setBackgroundColor(color);
        });
    }

    public void clearCache(final boolean includeDiskFiles) {
        WebkitUtils.onMainThreadSync(() -> {
            mWebView.clearCache(includeDiskFiles);
        });
    }

    public void clearHistory() {
        WebkitUtils.onMainThreadSync(() -> {
            mWebView.clearHistory();
        });
    }

    public void requestFocus() {
        new PollingCheck(WebkitUtils.TEST_TIMEOUT_MS) {
            @Override
            protected boolean check() {
                requestFocusOnUiThread();
                return hasFocus();
            }
        }.run();
    }

    private void requestFocusOnUiThread() {
        WebkitUtils.onMainThreadSync(() -> {
            mWebView.requestFocus();
        });
    }

    private boolean hasFocus() {
        return WebkitUtils.onMainThreadSync(() -> {
            return mWebView.hasFocus();
        });
    }

    public boolean canZoomIn() {
        return WebkitUtils.onMainThreadSync(() -> {
            return mWebView.canZoomIn();
        });
    }

    public boolean canZoomOut() {
        return WebkitUtils.onMainThreadSync(() -> {
            return mWebView.canZoomOut();
        });
    }

    public boolean zoomIn() {
        return WebkitUtils.onMainThreadSync(() -> {
            return mWebView.zoomIn();
        });
    }

    public boolean zoomOut() {
        return WebkitUtils.onMainThreadSync(() -> {
            return mWebView.zoomOut();
        });
    }

    public void zoomBy(final float zoomFactor) {
        WebkitUtils.onMainThreadSync(() -> {
            mWebView.zoomBy(zoomFactor);
        });
    }

    public void setFindListener(final WebView.FindListener listener) {
        WebkitUtils.onMainThreadSync(() -> {
            mWebView.setFindListener(listener);
        });
    }

    public void removeJavascriptInterface(final String interfaceName) {
        WebkitUtils.onMainThreadSync(() -> {
            mWebView.removeJavascriptInterface(interfaceName);
        });
    }

    public WebMessagePort[] createWebMessageChannel() {
        return WebkitUtils.onMainThreadSync(() -> {
            return mWebView.createWebMessageChannel();
        });
    }

    public void postWebMessage(final WebMessage message, final Uri targetOrigin) {
        WebkitUtils.onMainThreadSync(() -> {
            mWebView.postWebMessage(message, targetOrigin);
        });
    }

    public void addJavascriptInterface(final Object object, final String name) {
        WebkitUtils.onMainThreadSync(() -> {
            mWebView.addJavascriptInterface(object, name);
        });
    }

    public void flingScroll(final int vx, final int vy) {
        WebkitUtils.onMainThreadSync(() -> {
            mWebView.flingScroll(vx, vy);
        });
    }

    public void requestFocusNodeHref(final Message hrefMsg) {
        WebkitUtils.onMainThreadSync(() -> {
            mWebView.requestFocusNodeHref(hrefMsg);
        });
    }

    public void requestImageRef(final Message msg) {
        WebkitUtils.onMainThreadSync(() -> {
            mWebView.requestImageRef(msg);
        });
    }

    public void setInitialScale(final int scaleInPercent) {
        WebkitUtils.onMainThreadSync(() -> {
                mWebView.setInitialScale(scaleInPercent);
        });
    }

    public void clearSslPreferences() {
        WebkitUtils.onMainThreadSync(() -> {
            mWebView.clearSslPreferences();
        });
    }

    public void clearClientCertPreferences(final Runnable onCleared) {
        WebkitUtils.onMainThreadSync(() -> {
            WebView.clearClientCertPreferences(onCleared);
        });
    }

    public void resumeTimers() {
        WebkitUtils.onMainThreadSync(() -> {
            mWebView.resumeTimers();
        });
    }

    public void findNext(final boolean forward) {
        WebkitUtils.onMainThreadSync(() -> {
            mWebView.findNext(forward);
        });
    }

    public void clearMatches() {
        WebkitUtils.onMainThreadSync(() -> {
            mWebView.clearMatches();
        });
    }

    public void loadUrl(final String url) {
        WebkitUtils.onMainThreadSync(() -> {
            mWebView.loadUrl(url);
        });
    }

    public void stopLoading() {
        WebkitUtils.onMainThreadSync(() -> {
            mWebView.stopLoading();
        });
    }

    /**
     * Reload the previous URL.
     */
    public void reload() {
        WebkitUtils.onMainThreadSync(() -> {
            mWebView.reload();
        });
    }

    public String getTitle() {
        return WebkitUtils.onMainThreadSync(() -> {
            return mWebView.getTitle();
        });
    }

    public WebSettings getSettings() {
        return WebkitUtils.onMainThreadSync(() -> {
            return mWebView.getSettings();
        });
    }

    public WebBackForwardList copyBackForwardList() {
        return WebkitUtils.onMainThreadSync(() -> {
            return mWebView.copyBackForwardList();
        });
    }

    public Bitmap getFavicon() {
        return WebkitUtils.onMainThreadSync(() -> {
            return mWebView.getFavicon();
        });
    }

    public String getUrl() {
        return WebkitUtils.onMainThreadSync(() -> {
            return mWebView.getUrl();
        });
    }

    public int getProgress() {
        return WebkitUtils.onMainThreadSync(() -> {
            return mWebView.getProgress();
        });
    }

    public int getHeight() {
        return WebkitUtils.onMainThreadSync(() -> {
            return mWebView.getHeight();
        });
    }

    public int getContentHeight() {
        return WebkitUtils.onMainThreadSync(() -> {
            return mWebView.getContentHeight();
        });
    }

    public boolean pageUp(final boolean top) {
        return WebkitUtils.onMainThreadSync(() -> {
            return mWebView.pageUp(top);
        });
    }

    public boolean pageDown(final boolean bottom) {
        return WebkitUtils.onMainThreadSync(() -> {
            return mWebView.pageDown(bottom);
        });
    }

    /**
     * Post a visual state listener callback for mWebView on the UI thread.
     */
    public void postVisualStateCallback(final long requestId, final VisualStateCallback callback) {
        WebkitUtils.onMainThreadSync(() -> {
            mWebView.postVisualStateCallback(requestId, callback);
        });
    }

    public int[] getLocationOnScreen() {
        final int[] location = new int[2];
        return WebkitUtils.onMainThreadSync(() -> {
            mWebView.getLocationOnScreen(location);
            return location;
        });
    }

    public float getScale() {
        return WebkitUtils.onMainThreadSync(() -> {
            return mWebView.getScale();
        });
    }

    public boolean requestFocus(final int direction,
            final Rect previouslyFocusedRect) {
        return WebkitUtils.onMainThreadSync(() -> {
            return mWebView.requestFocus(direction, previouslyFocusedRect);
        });
    }

    public HitTestResult getHitTestResult() {
        return WebkitUtils.onMainThreadSync(() -> {
            return mWebView.getHitTestResult();
        });
    }

    public int getScrollX() {
        return WebkitUtils.onMainThreadSync(() -> {
            return mWebView.getScrollX();
        });
    }

    public int getScrollY() {
        return WebkitUtils.onMainThreadSync(() -> {
            return mWebView.getScrollY();
        });
    }

    public final DisplayMetrics getDisplayMetrics() {
        return WebkitUtils.onMainThreadSync(() -> {
            return mWebView.getContext().getResources().getDisplayMetrics();
        });
    }

    public boolean requestChildRectangleOnScreen(final View child,
            final Rect rect,
            final boolean immediate) {
        return WebkitUtils.onMainThreadSync(() -> {
            return mWebView.requestChildRectangleOnScreen(child, rect,
                    immediate);
        });
    }

    public int findAll(final String find) {
        return WebkitUtils.onMainThreadSync(() -> {
            return mWebView.findAll(find);
        });
    }

    public Picture capturePicture() {
        return WebkitUtils.onMainThreadSync(() -> {
            return mWebView.capturePicture();
        });
    }

    /**
     * Execute javascript synchronously, returning the result.
     */
    public String evaluateJavascriptSync(final String script) {
        final SettableFuture<String> future = SettableFuture.create();
        evaluateJavascript(script, result -> future.set(result));
        return WebkitUtils.waitForFuture(future);
    }

    public void evaluateJavascript(final String script, final ValueCallback<String> result) {
        WebkitUtils.onMainThread(() -> mWebView.evaluateJavascript(script, result));
    }

    public void saveWebArchive(final String basename, final boolean autoname,
                               final ValueCallback<String> callback) {
        WebkitUtils.onMainThreadSync(() -> {
            mWebView.saveWebArchive(basename, autoname, callback);
        });
    }

    public SslCertificate getCertificate() {
        return WebkitUtils.onMainThreadSync(() -> {
            return mWebView.getCertificate();
        });
    }

    public WebView createWebView() {
        return WebkitUtils.onMainThreadSync(() -> {
            return new WebView(mWebView.getContext());
        });
    }

    public PrintDocumentAdapter createPrintDocumentAdapter() {
        return WebkitUtils.onMainThreadSync(() -> {
            return mWebView.createPrintDocumentAdapter();
        });
    }

    public void setLayoutHeightToMatchParent() {
        WebkitUtils.onMainThreadSync(() -> {
            ViewParent parent = mWebView.getParent();
            if (parent instanceof ViewGroup) {
                ((ViewGroup) parent).getLayoutParams().height =
                    ViewGroup.LayoutParams.MATCH_PARENT;
            }
            mWebView.getLayoutParams().height = ViewGroup.LayoutParams.MATCH_PARENT;
            mWebView.requestLayout();
        });
    }

    public void setLayoutToMatchParent() {
        WebkitUtils.onMainThreadSync(() -> {
            setMatchParent((View) mWebView.getParent());
            setMatchParent(mWebView);
            mWebView.requestLayout();
        });
    }

    public void setAcceptThirdPartyCookies(final boolean accept) {
        WebkitUtils.onMainThreadSync(() -> {
            CookieManager.getInstance().setAcceptThirdPartyCookies(mWebView, accept);
        });
    }

    public boolean acceptThirdPartyCookies() {
        return WebkitUtils.onMainThreadSync(() -> {
            return CookieManager.getInstance().acceptThirdPartyCookies(mWebView);
        });
    }

    /**
     * Accessor for underlying WebView.
     * @return The WebView being wrapped by this class.
     */
    public WebView getWebView() {
        return mWebView;
    }

    /**
     * Wait for the current state of the DOM to be ready to render on the next draw.
     */
    public void waitForDOMReadyToRender() {
        final SettableFuture<Void> future = SettableFuture.create();
        postVisualStateCallback(0, new VisualStateCallback() {
            @Override
            public void onComplete(long requestId) {
                future.set(null);
            }
        });
        WebkitUtils.waitForFuture(future);
    }

    /**
     * Capture a bitmap representation of the current WebView state.
     *
     * This synchronises so that the bitmap contents reflects the current DOM state, rather than
     * potentially capturing a previously generated frame.
     */
    public Bitmap captureBitmap() {
        getSettings().setOffscreenPreRaster(true);
        waitForDOMReadyToRender();
        return WebkitUtils.onMainThreadSync(() -> {
            Bitmap bitmap = Bitmap.createBitmap(mWebView.getWidth(), mWebView.getHeight(),
                    Bitmap.Config.ARGB_8888);
            Canvas canvas = new Canvas(bitmap);
            mWebView.draw(canvas);
            return bitmap;
        });
    }

    /**
     * Set LayoutParams to MATCH_PARENT.
     *
     * @param view Target view
     */
    private void setMatchParent(View view) {
        ViewGroup.LayoutParams params = view.getLayoutParams();
        params.height = ViewGroup.LayoutParams.MATCH_PARENT;
        params.width = ViewGroup.LayoutParams.MATCH_PARENT;
        view.setLayoutParams(params);
    }
}"	"/home/gpoor/cts-12-source/cts/libs/deviceutillegacy/src/android/webkit/cts/WebViewOnUiThread.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.renderscript.cts.refocus.BlurStack"	"getMaxDiskRadius"	"CtsRenderscriptTestCases"	"1: user"	"public void test/*
 *.
 */

package android.renderscript.cts.refocus;

import android.util.Log;

import java.util.ArrayList;

/**
 * An object that contains all the parameters that are needed in refocusing
 * filtering function, including the range of depth levels, the disc blur radius
 * of each depth level, how the depth levels are grouped into layers, which
 * layer is in focus.
 *
 *  <b> Here by ""depth"", we mean inverse depth. Pixels with larger depth values
 * are closer to the camera.
 *
 *  For a layer n, its depth interval is (@code [layerInfo[n].backDepth,
 * layerInfo[n].frontDepth]), where (@code backDepth<=frontDepth).
 *
 *  The layers are ordered from near to far; note that near layers have larger
 * depth values.
 *
 *  (@code focusLayer) is the index of the layer that is in focus, that is, has
 * zero blur.
 */

public class BlurStack {
  //private static final Log.Tag TAG = new Log.Tag(""BlurStack"");
  private static final String TAG = ""BlurStack"";
  /**
   * The cap for disc radius of blur kernels.
   */
  private static final float MAX_DISC_RADIUS = 25.0f;

  /**
   * The minimum of the interval that is used to group depth levels into
   * blending layers based on the corresponding blur disk radius.
   */
  private static final float MIN_DISK_RADIUS_STEP_SIZE = 2.0f;

  /**
   * The starting index of depth quantization level. Must be positive as zero is
   * reserved for invalid depth.
   */
  private static final int MIN_DEPTH = 1;

  /**
   * The ending index of depth quantization level. It must be a power of 2.
   */
  private static final int MAX_DEPTH = 64;

  /**
   * The scale to apply to 8-bit depthmaps.
   */
  private static final int DEPTH_SCALE = 256 / MAX_DEPTH;

  /**
   * For each depth value {@code d} within [MIN_DEPTH,MAX_DEPTH], its blur disc
   * radius is saved in {@code diskRadius[d-MIN_DEPTH]}. Hence the length
   * {@code diskRadius} is {@code MAX_DEPTH-MIN_DEPTH+1}.
   */
  private float[] diskRadiusArray;

  /**
   * A set of non-overlapping layers that covers all the depth levels. The
   * layers are ordered from front (closer to the camera) to back (farther away
   * from the camera).
   */
  private LayerInfo[] layerInfo;

  /**
   * The layer in which the focal depth belongs to. <b> For this layer, we
   * assume that it is a single depth layer. That is, the front depth and back
   * depth both equal to focal depth.
   */
  private int focusLayer;

  public static float getMaxDiskRadius() {
    return MAX_DISC_RADIUS;
  }

  /**
   * Returns the blur disk radius of a depth level.
   *
   * @param depth depth level
   * @return the blur disk radius of the depth level
   */
  public float getDiskRadius(int depth) {
    return diskRadiusArray[depth - MIN_DEPTH];
  }

  public int getNumLayers() {
    return layerInfo.length;
  }

  public LayerInfo getLayerInfo(int layer) {
    return layerInfo[layer];
  }

  /**
   * Returns the number of depths in a given layer.
   *
   * @param layer layer index
   * @return the number of depth levels in the layer
   */
  public int getNumDepths(int layer) {
    return layerInfo[layer].frontDepth - layerInfo[layer].backDepth + 1;
  }

  public int getFocusLayer() {
    return focusLayer;
  }

  /**
   * Returns the depth given the layer and the relative depth in the layer.
   *
   * @param layer the layer index
   * @param relativeDepthInLayer the relative depth index relative to the back
   *        depth of a layer
   * @return the depth
   */
  public int getDepth(int layer, int relativeDepthInLayer) {
    return layerInfo[layer].backDepth + relativeDepthInLayer;
  }

  /**
   * Creates an instance of BlurStack using depth range, focal depth, desired
   * amount of blur at infinity, and the number of blending layers.
   *
   * @param depthTransform an object that translates between floating depth and
   *        quantized depth.
   * @param focusDepth3D focus depth in 3D
   * @param depthOfField the range of depth values around focus depth 3D that
   *        has zero blur.
   * @param blurInfinity the desired amount of blur, represented as blur radius
   *        at infinity
   * @param numBlendingLayers the number of blending layers that group all the
   *        depth levels
   * @return an instance of {@code BlurStack}
   */
  public static BlurStack createFromDepthTransform(
      final DepthTransform depthTransform, float focusDepth3D,
      float depthOfField, float blurInfinity, int numBlendingLayers) {
    BlurStack blurStack = new BlurStack();
    // Finds the front and back depth levels for the focus layer.
    if (depthOfField < 0) {
      depthOfField = -depthOfField;
      Log.e(TAG, ""Negative depth of field"");
    }
    int frontFocalDepth = openglDepthToStackDepth(
        depthTransform.quantize(focusDepth3D * (1 - depthOfField)));
    int backFocalDepth = openglDepthToStackDepth(
        depthTransform.quantize(focusDepth3D * (1 + depthOfField)));
    // Computes blur disk radius for all the depth levels.
    blurStack.computeDiskRadius(depthTransform, frontFocalDepth, backFocalDepth,
        blurInfinity);

    if (numBlendingLayers >= MAX_DEPTH) {
      blurStack.generateOneLayerForEachDepth(frontFocalDepth, backFocalDepth);
    } else {
      // Sets the max variation of blur disk radius in a blending layer.
      float diskRadiusInterval = (blurStack.getDiskRadius(MIN_DEPTH)
          + blurStack.getDiskRadius(MAX_DEPTH)) / numBlendingLayers;
      diskRadiusInterval =
          Math.max(diskRadiusInterval, MIN_DISK_RADIUS_STEP_SIZE);
      // Computes {@code layerInfo, focusLayer}, assuming {@code diskRadius}
      // have been computed.
      blurStack.groupDepthLevelsIntoLayers(frontFocalDepth, backFocalDepth,
          diskRadiusInterval);
    }
    return blurStack;
  }

  @Override
  public String toString() {
    String s = ""disparity range: "" + MAX_DEPTH + "", "" + MIN_DEPTH + ""\n"";
    s += ""focus disparity: "" + layerInfo[focusLayer].frontDepth + "", ""
        + layerInfo[focusLayer].backDepth + ""\n"";
    s += ""num of layers: "" + getNumLayers() + ""\n"";
    s += ""focus layer: "" + focusLayer + ""\n"";

    for (int n = 0; n < layerInfo.length; ++n) {
      int front = layerInfo[n].frontDepth;
      int back = layerInfo[n].backDepth;
      s += ""\nlayer "" + n + "" num of disparities "" + (front - back + 1) + ""\n"";

      for (int d = front; d >= back; --d) {
        s += ""layer "" + n + "" disparity "" + d + "" disk radius ""
            + getDiskRadius(d) + ""\n"";
      }
    }

    return s;
  }

  /**
   * OpenGL depth is from 0(near) to 255(far). The depth in BlurStack is from
   * 1(far) to MAX_DEPTH(near). Converts from openglDepth to stackDepth.
   *
   * @param openglDepth openGL depth.
   * @return stackDepth stack depth.
   */
  private static int openglDepthToStackDepth(int openglDepth) {
    return MAX_DEPTH - (openglDepth / DEPTH_SCALE);
  }

  /**
   * OpenGL depth is from 0(near) to 255(far). The depth in BlurStack is from
   * 1(far) to MAX_DEPTH(near). Converts from stackDepth to openglDepth.
   *
   * @param stackDepth stack depth.
   * @return openglDepth openGL depth.
   */
  private static int stackDepthToOpenglDepth(int stackDepth) {
    return (MAX_DEPTH - stackDepth) * DEPTH_SCALE;
  }

  /**
   * A private constructor that forces users to use {@code createFromDepthRange}
   * to construct an instance of BlurStack.
   */
  private BlurStack() {}

  /**
   * Quantizes the depth range into MAX_DEPTH levels in inverse depth space, and
   * for each level, computes the blur disk radius.
   *
   * @param depthTransform an object that translates between floating depth and
   *        quantized depth.
   * @param frontFocalDepth front focal depth level
   * @param backFocalDepth back focal depth level
   * @param blurInfinity the amount of desired blur represented as the blur
   *        radius at infinity
   */
  private void computeDiskRadius(final DepthTransform depthTransform,
      int frontFocalDepth, int backFocalDepth, float blurInfinity) {
    int numLevels = MAX_DEPTH - MIN_DEPTH + 1;
    diskRadiusArray = new float[numLevels];
    float frontFocalDepth3D =
        depthTransform.reconstruct(stackDepthToOpenglDepth(frontFocalDepth));
    float backFocalDepth3D =
        depthTransform.reconstruct(stackDepthToOpenglDepth(backFocalDepth));

    // Computes the blur disk radius for each depth level.
    for (int depth = MIN_DEPTH; depth <= MAX_DEPTH; ++depth) {
      float depth3D =
          depthTransform.reconstruct(stackDepthToOpenglDepth(depth));
      float radius = 0;
      if (depth3D < frontFocalDepth3D) {
        radius = blurInfinity * (frontFocalDepth3D - depth3D) / depth3D;
      } else if (depth3D > backFocalDepth3D) {
        radius = blurInfinity * (depth3D - backFocalDepth3D) / depth3D;
      }
      diskRadiusArray[depth - MIN_DEPTH] = Math.min(radius, MAX_DISC_RADIUS);
    }
  }

  /**
   * Sets up {@code focusLayer} such that each layer contains only a single
   * depth, except that the focal layer contains frontFocalDepth and
   * backFocalDepth.
   *
   * <b> This function computes {@code layerInfo, focusLayer}.
   *
   * @param frontFocalDepth the front depth of focal layer.
   * @param backFocalDepth the back depth of focal layer.
   */
  private void generateOneLayerForEachDepth(int frontFocalDepth,
      int backFocalDepth) {
    int numLayers =
        MAX_DEPTH - MIN_DEPTH + 1 - (frontFocalDepth - backFocalDepth);
    layerInfo = new LayerInfo[numLayers];

    // Pushes single depth layers in front of the focal layer to layerInfo.
    int layer = 0;
    for (int depth = MAX_DEPTH; depth > frontFocalDepth; --depth, ++layer) {
      layerInfo[layer] = new LayerInfo(depth);
    }

    // Pushes focal layer to layerInfo.
    focusLayer = layer;
    layerInfo[layer] = new LayerInfo(frontFocalDepth, backFocalDepth);
    ++layer;

    // Pushes single depth layers behind the focal layer to layerInfo.
    for (int depth = backFocalDepth - 1; depth >= MIN_DEPTH; --depth, ++layer) {
      layerInfo[layer] = new LayerInfo(depth);
    }
  }

  /**
   * Sets up {@code focusLayer} such that within each layer, the blur radius
   * variation due to depth difference is no larger than
   * {@code diskRadiusInterval}.
   *
   * <b> This function computes {@code layerInfo, focusLayer}, assuming that
   * {@code diskRadius} have been properly initialized.
   *
   * @param frontFocalDepth the front depth of focal layer.
   * @param backFocalDepth the back depth of focal layer.
   * @diskRadiusInterval the max allowed blur disk radius difference within each
   *                     layer.
   */
  private void groupDepthLevelsIntoLayers(int frontFocalDepth,
      int backFocalDepth, float diskRadiusInterval) {
    // Groups depth levels behind the focal depth into several layers.
    // The blur radius difference in each layer is no larger than
    // diskRadiusInterval.
    ArrayList<LayerInfo> layerInfoBehindFocus =
        groupDepthLevelsBehindFocus(backFocalDepth, diskRadiusInterval);

    // Groups depth levels in front of the focal depth into several layers.
    // The blur radius difference in each layer is no larger than {@code
    // diskRadiusInterval}.
    ArrayList<LayerInfo> layerInfoInFrontOfFocus =
        groupDepthLevelsInFrontOfFocus(frontFocalDepth, diskRadiusInterval);

    // Merges the two groups of layers into one stack of layers, plus the focus
    // depth layer.
    int numLayers =
        layerInfoInFrontOfFocus.size() + 1 + layerInfoBehindFocus.size();
    layerInfo = new LayerInfo[numLayers];
    focusLayer = layerInfoInFrontOfFocus.size();

    // The merged layers is ordered from the front-most layer to the back-most
    // layer.
    for (int n = 0; n < numLayers; ++n) {
      if (n < layerInfoInFrontOfFocus.size()) {
        // Finds the corresponding layer index m in layerInfoInFrontOfFocus,
        // which is ordered from focal depth to front-most.
        int m = (layerInfoInFrontOfFocus.size() - 1) - n;
        layerInfo[n] = layerInfoInFrontOfFocus.get(m);
      } else if (n == layerInfoInFrontOfFocus.size()) {
        layerInfo[n] = new LayerInfo(frontFocalDepth, backFocalDepth);
      } else {
        // Finds the corresponding layer index m in layerInfoBehindFocus, which
        // is ordered from focal depth to back-most.
        int m = n - (layerInfoInFrontOfFocus.size() + 1);
        layerInfo[n] = layerInfoBehindFocus.get(m);
      }
    }
  }

  /**
   * Groups depth levels behind the focal depth into several layers. The blur
   * radius difference in each layer is no larger than
   * {@code diskRadiusInterval}.
   *
   * @param backFocalDepth the back depth of focal layer.
   * @param diskRadiusInterval max disk radius variation in each layer
   * @return layerInfo layering of depth levels behind the focal depth
   */
  private ArrayList<LayerInfo> groupDepthLevelsBehindFocus(int backFocalDepth,
      float diskRadiusInterval) {
    // Initializes the layerInfo array with maximum capacity needed.
    ArrayList<LayerInfo> layerInfo =
        new ArrayList<LayerInfo>(diskRadiusArray.length);

    if (backFocalDepth == MIN_DEPTH) {
      return layerInfo;
    }

    // At this point, focusDepth > minDepth.
    // Moves to the first depth behind the focus depth and initializes a layer.
    int d = backFocalDepth - 1;
    layerInfo.add(new LayerInfo(d));
    // Sets up the max radius threshold for the layer.
    float radiusThreshold = getDiskRadius(d) + diskRadiusInterval;

    // Expands the layer to include depth levels so long as the blur disk
    // radius within the layer is not larger than radiusThreshold.
    // Stops the expansion when current depth is already the minDepth.
    while (d > MIN_DEPTH) {
      // Moves to the next depth.
      d--;
      if (getDiskRadius(d) <= radiusThreshold) {
        // Expands the current layer by lowering its back depth.
        int numLayers = layerInfo.size();
        layerInfo.get(numLayers - 1).backDepth = d;
      } else {
        // Generates a new single-depth layer.
        // Expands it in the next iteration if necessary.
        layerInfo.add(new LayerInfo(d));
        radiusThreshold = getDiskRadius(d) + diskRadiusInterval;
      }
    }
    return layerInfo;
  }

  /**
   * Groups depth levels in front of the focal depth into several layers. The
   * blur radius difference in each layer is no larger than
   * {@code diskRadiusInterval}.
   *
   * @param frontFocalDepth the back depth of focal layer.
   * @param diskRadiusInterval max disk radius variation in each layer
   * @return layerInfo layering of depth levels behind the focal depth
   */
  private ArrayList<LayerInfo> groupDepthLevelsInFrontOfFocus(
      int frontFocalDepth, float diskRadiusInterval) {
    // Initializes the layerInfo array with maximum capacity needed.
    ArrayList<LayerInfo> layerInfo =
        new ArrayList<LayerInfo>(diskRadiusArray.length);

    if (frontFocalDepth == MAX_DEPTH) {
      return layerInfo;
    }

    // At this point, focusDepth < maxDepth.
    // Moves to the first depth in front of the focus depth and initializes a
    // layer.
    int d = frontFocalDepth + 1;
    layerInfo.add(new LayerInfo(d));
    // Sets up the max radius threshold for the layer.
    float radiusThreshold = getDiskRadius(d) + diskRadiusInterval;

    // Expands the layer to include depth levels so long as the blur disk
    // radius within the layer is not larger than radiusThreshold.
    // Stops the expansion when current depth is already the maxDepth.
    while (d < MAX_DEPTH) {
      // Moves to the next depth.
      d++;
      if (getDiskRadius(d) <= radiusThreshold) {
        // Expands the current layer by increasing its front depth.
        int numLayers = layerInfo.size();
        layerInfo.get(numLayers - 1).frontDepth = d;
      } else {
        // Generates a new single-depth layer.
        // Expands it in the next iteration if necessary.
        layerInfo.add(new LayerInfo(d));
        radiusThreshold = getDiskRadius(d) + diskRadiusInterval;
      }
    }
    return layerInfo;
  }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/renderscript/src/android/renderscript/cts/refocus/BlurStack.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.view.textclassifier.cts.ConversationActionTest"	"testConversationAction_minimal"	"CtsTextClassifierTestCases"	"1: ui"	"public void testConversationAction_minimal() {
        ConversationAction conversationAction =
                new ConversationAction.Builder(
                        ConversationAction.TYPE_CALL_PHONE)
                        .build();

        ConversationAction recovered =
                parcelizeDeparcelize(conversationAction,
                        ConversationAction.CREATOR);

        assertMinimalConversationAction(conversationAction);
        assertMinimalConversationAction(recovered);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/textclassifier/src/android/view/textclassifier/cts/ConversationActionTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.view.textclassifier.cts.ConversationActionTest"	"testConversationAction_full"	"CtsTextClassifierTestCases"	"1: ui"	"public void testConversationAction_full() {
        ConversationAction conversationAction =
                new ConversationAction.Builder(
                        ConversationAction.TYPE_CALL_PHONE)
                        .setConfidenceScore(1.0f)
                        .setTextReply(TEXT)
                        .setAction(REMOTE_ACTION)
                        .setExtras(EXTRAS)
                        .build();

        ConversationAction recovered =
                parcelizeDeparcelize(conversationAction,
                        ConversationAction.CREATOR);

        assertFullConversationAction(conversationAction);
        assertFullConversationAction(recovered);
    }

    private static void assertMinimalConversationAction(
            ConversationAction conversationAction) {
        assertThat(conversationAction.getAction()).isNull();
        assertThat(conversationAction.getConfidenceScore()).isWithin(FLOAT_TOLERANCE).of(0.0f);
        assertThat(conversationAction.getType()).isEqualTo(ConversationAction.TYPE_CALL_PHONE);
    }

    private static void assertFullConversationAction(
            ConversationAction conversationAction) {
        assertThat(conversationAction.getAction().getTitle()).isEqualTo(TEXT);
        assertThat(conversationAction.getConfidenceScore()).isWithin(FLOAT_TOLERANCE).of(1.0f);
        assertThat(conversationAction.getType()).isEqualTo(ConversationAction.TYPE_CALL_PHONE);
        assertThat(conversationAction.getTextReply()).isEqualTo(TEXT);
        assertThat(conversationAction.getExtras().keySet()).containsExactly(TEXT);
    }

    private static <T extends Parcelable> T parcelizeDeparcelize(
            T parcelable, Parcelable.Creator<T> creator) {
        Parcel parcel = Parcel.obtain();
        parcelable.writeToParcel(parcel, 0);
        parcel.setDataPosition(0);
        return creator.createFromParcel(parcel);
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/textclassifier/src/android/view/textclassifier/cts/ConversationActionTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.graphics.drawable.cts.AnimatedImageDrawableTest"	"testAutoMirroredDrawing"	"CtsGraphicsTestCases"	"1: direct"	"public void testAutoMirroredDrawing() {
        AnimatedImageDrawable drawable = createFromImageDecoder(RES_ID);
        assertFalse(drawable.isAutoMirrored());

        final int width = drawable.getIntrinsicWidth();
        final int height = drawable.getIntrinsicHeight();
        Bitmap normal = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
        {
            Canvas canvas = new Canvas(normal);
            drawable.draw(canvas);
        }

        Bitmap flipped = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
        {
            Canvas canvas = new Canvas(flipped);
            canvas.translate(width, 0);
            canvas.scale(-1, 1);
            drawable.draw(canvas);
        }

        for (int i = 0; i < width; ++i) {
            for (int j = 0; j < height; ++j) {
                assertEquals(normal.getPixel(i, j), flipped.getPixel(width - 1 - i, j));
            }
        }

        drawable.setAutoMirrored(true);
        drawAndCompare(normal, drawable);

        drawable.setLayoutDirection(View.LAYOUT_DIRECTION_RTL);
        drawAndCompare(flipped, drawable);

        drawable.setAutoMirrored(false);
        drawAndCompare(normal, drawable);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/drawable/cts/AnimatedImageDrawableTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.graphics.drawable.cts.AnimatedImageDrawableTest"	"testInputStream"	"CtsGraphicsTestCases"	"1: direct"	"public void testInputStream() throws Throwable {
        setupActivity();
        Resources res = getResources();
        try (InputStream in = res.openRawResource(R.drawable.animated)) {
            ImageDecoder.Source src =
                    ImageDecoder.createSource(res, in, Bitmap.DENSITY_NONE);
            AnimatedImageDrawable drawable =
                    (AnimatedImageDrawable) ImageDecoder.decodeDrawable(src);
            decodeInBackground(drawable);
        }

    }

    private byte[] getAsByteArray() {
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        try (InputStream in = getResources().openRawResource(RES_ID)) {
            byte[] buf = new byte[4096];
            int bytesRead;
            while ((bytesRead = in.read(buf)) != -1) {
                outputStream.write(buf, 0, bytesRead);
            }
        } catch (IOException e) {
            fail(""Failed to read resource: "" + e);
        }

        return outputStream.toByteArray();
    }

    private ByteBuffer getAsDirectByteBuffer() {
        byte[] array = getAsByteArray();
        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(array.length);
        byteBuffer.put(array);
        byteBuffer.position(0);
        return byteBuffer;
    }

    private AnimatedImageDrawable createFromByteBuffer(ByteBuffer byteBuffer) {
        ImageDecoder.Source src = ImageDecoder.createSource(byteBuffer);
        try {
            return (AnimatedImageDrawable) ImageDecoder.decodeDrawable(src);
        } catch (IOException e) {
            fail(""Failed to create decoder: "" + e);
            return null;
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/drawable/cts/AnimatedImageDrawableTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.graphics.drawable.cts.AnimatedImageDrawableTest"	"testDirectByteBuffer"	"CtsGraphicsTestCases"	"1: direct"	"public void testDirectByteBuffer() throws Throwable {
        setupActivity();
        ByteBuffer byteBuffer = getAsDirectByteBuffer();
        final AnimatedImageDrawable drawable = createFromByteBuffer(byteBuffer);
        decodeInBackground(drawable);
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/drawable/cts/AnimatedImageDrawableTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.graphics.drawable.cts.AnimatedImageDrawableTest"	"testRegisterCallback"	"CtsGraphicsTestCases"	"1: ui"	"public void testRegisterCallback() throws Throwable {
        setupActivity();
        AnimatedImageDrawable drawable = createFromImageDecoder(R.drawable.animated);

        mActivityRule.runOnUiThread(() -> {
            // Register a callback.
            Callback cb = new Callback(drawable);
            drawable.registerAnimationCallback(cb);
            assertTrue(drawable.unregisterAnimationCallback(cb));

            // Now that it has been removed, it cannot be removed again.
            assertFalse(drawable.unregisterAnimationCallback(cb));
        });
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/drawable/cts/AnimatedImageDrawableTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.graphics.drawable.cts.AnimatedImageDrawableTest"	"testClearCallbacks"	"CtsGraphicsTestCases"	"1: ui"	"public void testClearCallbacks() throws Throwable {
        setupActivity();
        AnimatedImageDrawable drawable = createFromImageDecoder(R.drawable.animated);

        Callback[] callbacks = new Callback[] {
            new Callback(drawable),
            new Callback(drawable),
            new Callback(drawable),
            new Callback(drawable),
            new Callback(drawable),
            new Callback(drawable),
            new Callback(drawable),
            new Callback(drawable),
        };

        mActivityRule.runOnUiThread(() -> {
            for (Callback cb : callbacks) {
                drawable.registerAnimationCallback(cb);
            }
        });

        drawable.clearAnimationCallbacks();

        for (Callback cb : callbacks) {
            // It has already been removed.
            assertFalse(drawable.unregisterAnimationCallback(cb));
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/drawable/cts/AnimatedImageDrawableTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.graphics.drawable.cts.AnimatedImageDrawableTest"	"testLifeCycleSoftware"	"CtsGraphicsTestCases"	"1: ui"	"public void testLifeCycleSoftware() throws Throwable {
        setupActivity();
        AnimatedImageDrawable drawable = createFromImageDecoder(RES_ID);

        Bitmap bm = Bitmap.createBitmap(drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight(),
                Bitmap.Config.ARGB_8888);
        Canvas canvas = new Canvas(bm);

        Callback cb = new Callback(drawable);
        mActivityRule.runOnUiThread(() -> {
            drawable.registerAnimationCallback(cb);
            drawable.draw(canvas);
        });

        assertFalse(drawable.isRunning());
        cb.assertStarted(false);
        cb.assertEnded(false);

        mActivityRule.runOnUiThread(() -> {
            drawable.start();
            assertTrue(drawable.isRunning());
            drawable.draw(canvas);
        });
        cb.waitForStart();
        cb.assertStarted(true);

        // Only run the animation one time.
        drawable.setRepeatCount(0);

        // The drawable will prevent skipping frames, so we actually have to
        // draw each frame. (Start with 1, since we already drew frame 0.)
        for (int i = 1; i < NUM_FRAMES; i++) {
            cb.waitForEnd(FRAME_DURATION);
            cb.assertEnded(false);
            mActivityRule.runOnUiThread(() -> {
                assertTrue(drawable.isRunning());
                drawable.draw(canvas);
            });
        }

        cb.waitForEnd(FRAME_DURATION);
        assertFalse(drawable.isRunning());
        cb.assertEnded(true);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/drawable/cts/AnimatedImageDrawableTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.graphics.drawable.cts.AnimatedImageDrawableTest"	"testStop"	"CtsGraphicsTestCases"	"1: ui"	"public void testStop() throws Throwable {
        setupActivity();
        AnimatedImageDrawable drawable = createFromImageDecoder(RES_ID);
        Callback cb = new Callback(drawable);
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mImageView, () -> {
            mImageView.setImageDrawable(drawable);

            drawable.registerAnimationCallback(cb);

            drawable.start();
            assertTrue(drawable.isRunning());
        });

        cb.waitForStart();
        cb.assertStarted(true);

        mActivityRule.runOnUiThread(() -> {
            drawable.stop();
            assertFalse(drawable.isRunning());
        });

        // This duration may be overkill, but we need to wait for the message
        // to post. Increasing it should help with flakiness on bots.
        cb.waitForEnd(DURATION * 3);
        cb.assertEnded(true);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/drawable/cts/AnimatedImageDrawableTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.voiceinteraction.cts.VoiceInteractionRoleTest"	"getAssistRoleHolders"	"CtsVoiceInteractionTestCases"	"2: system interaction"	"/*
 *.
 */

package android.voiceinteraction.cts;

import static com.android.compatibility.common.util.SystemUtil.callWithShellPermissionIdentity;
import static com.android.compatibility.common.util.SystemUtil.runWithShellPermissionIdentity;

import static com.google.common.truth.Truth.assertThat;

import android.app.role.RoleManager;
import android.content.ComponentName;
import android.content.Context;
import android.os.Process;
import android.platform.test.annotations.AppModeFull;
import android.provider.Settings;
import android.text.TextUtils;
import android.util.Log;

import androidx.test.core.app.ApplicationProvider;
import androidx.test.ext.junit.runners.AndroidJUnit4;

import com.android.compatibility.common.util.PollingCheck;

import org.junit.After;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;

/**
 * Tests for successfully changing ROLE_ASSISTANT. The test focuses on changing ROLE_ASSISTANT role,
 * the target voice interaction services do nothing during the test.
 */
@AppModeFull(reason = ""No need for testing role for instant app"")
@RunWith(AndroidJUnit4.class)
public class VoiceInteractionRoleTest {

    private static final String TAG = ""VoiceInteractionRoleTest"";

    private static final long TIMEOUT_MILLIS = 15 * 1000;
    private static final String VOICE_INTERACTION_HAS_RECOGNITION_SERVICE =
            ""android.voiceinteraction.service"";
    private static final String VOICE_INTERACTION_NO_RECOGNITION_SERVICE =
            ""android.voiceinteraction.norecognition"";

    private static Context sContext;
    private static RoleManager sRoleManager;

    List<String> mOriginalRoleHolders;

    @BeforeClass
    public static void oneTimeSetup() {
        sContext = ApplicationProvider.getApplicationContext();
        sRoleManager = sContext.getSystemService(RoleManager.class);
    }

    @Before
    public void setup() throws Exception {
        mOriginalRoleHolders = getAssistRoleHolders();
    }

    @After
    public void cleanup() throws Exception {
        if (mOriginalRoleHolders != null && mOriginalRoleHolders.size() > 0) {
            // Restore to original, assistant is singleton role
            addAssistRoleHolder(mOriginalRoleHolders.get(0));
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/voiceinteraction/src/android/voiceinteraction/cts/VoiceInteractionRoleTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.voiceinteraction.cts.VoiceInteractionRoleTest"	"testAssistRole_hasRecognitionService"	"CtsVoiceInteractionTestCases"	"1: interaction"	"public void testAssistRole_hasRecognitionService() throws Exception {
        roleTestingForPackage(VOICE_INTERACTION_HAS_RECOGNITION_SERVICE, /* hasRecognition= */
                true);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/voiceinteraction/src/android/voiceinteraction/cts/VoiceInteractionRoleTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.voiceinteraction.cts.VoiceInteractionRoleTest"	"testAssistRole_noRecognitionService"	"CtsVoiceInteractionTestCases"	"2: interaction user"	"public void testAssistRole_noRecognitionService() throws Exception {
        roleTestingForPackage(VOICE_INTERACTION_NO_RECOGNITION_SERVICE, /* hasRecognition= */
                false);
    }

    // TODO: Use helpers and move the assertion in Test instead of move together
    private void roleTestingForPackage(String packageName, boolean hasRecognition)
            throws Exception {
        assertThat(getAssistRoleHolders()).doesNotContain(packageName);

        addAssistRoleHolder(packageName);
        if (mOriginalRoleHolders != null && mOriginalRoleHolders.size() > 0) {
            String originalHolder = mOriginalRoleHolders.get(0);
            removeAssistRoleHolder(originalHolder);
            assertThat(getAssistRoleHolders()).doesNotContain(originalHolder);
        }
        assertThat(getAssistRoleHolders()).containsExactly(packageName);

        Callable<Boolean> condition = hasRecognition
                ? () -> !TextUtils.isEmpty(Settings.Secure.getString(sContext.getContentResolver(),
                Settings.Secure.VOICE_INTERACTION_SERVICE))
                : () -> """".equals(Settings.Secure.getString(sContext.getContentResolver(),
                        Settings.Secure.VOICE_INTERACTION_SERVICE));
        PollingCheck.check(""Make sure that Settings VOICE_INTERACTION_SERVICE ""
                + ""becomes available."", 500, condition);
        final String curVoiceInteractionComponentName = Settings.Secure.getString(
                sContext.getContentResolver(),
                Settings.Secure.VOICE_INTERACTION_SERVICE);
        String curVoiceInteractionPackageName = """";
        if (!TextUtils.isEmpty(curVoiceInteractionComponentName)) {
            curVoiceInteractionPackageName =
                    ComponentName.unflattenFromString(
                            curVoiceInteractionComponentName).getPackageName();
        }
        assertThat(curVoiceInteractionPackageName).isEqualTo(hasRecognition ? packageName : """");

        removeAssistRoleHolder(packageName);
        assertThat(getAssistRoleHolders()).doesNotContain(packageName);
    }

    private List<String> getAssistRoleHolders() throws Exception {
        return callWithShellPermissionIdentity(
                () -> sRoleManager.getRoleHolders(RoleManager.ROLE_ASSISTANT));
    }

    private void addAssistRoleHolder(String packageName)
            throws Exception {
        Log.i(TAG, ""addAssistRoleHolder for "" + packageName);
        final CallbackFuture future = new CallbackFuture(""addAssistRoleHolder"");
        runWithShellPermissionIdentity(() -> {
            sRoleManager.addRoleHolderAsUser(RoleManager.ROLE_ASSISTANT, packageName,
                    RoleManager.MANAGE_HOLDERS_FLAG_DONT_KILL_APP, Process.myUserHandle(),
                    sContext.getMainExecutor(), future);
        });
        assertThat(future.get(TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
    }

    private void removeAssistRoleHolder(String packageName)
            throws Exception {
        Log.i(TAG, ""removeAssistRoleHolder for "" + packageName);
        final CallbackFuture future = new CallbackFuture(""removeAssistRoleHolder"");
        runWithShellPermissionIdentity(
                () -> sRoleManager.removeRoleHolderAsUser(RoleManager.ROLE_ASSISTANT, packageName,
                        0, Process.myUserHandle(), sContext.getMainExecutor(), future));
        assertThat(future.get(TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
    }

    private static class CallbackFuture extends CompletableFuture<Boolean>
            implements Consumer<Boolean> {
        String mMethodName;

        CallbackFuture(String methodName) {
            mMethodName = methodName;
        }

        @Override
        public void accept(Boolean successful) {
            Log.i(TAG, mMethodName + "" result "" + successful);
            complete(successful);
        }
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/voiceinteraction/src/android/voiceinteraction/cts/VoiceInteractionRoleTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.verifier.instantapps.NotificationTestActivity"	"deviceIsGms"	""	"3: direct apps system"	"public void test/*
 *.
 */
package com.android.cts.verifier.instantapps;

import android.os.Bundle;
import android.content.pm.PackageManager;
import android.widget.TextView;

import com.android.cts.verifier.R;

/**
 * Test for manual verification of Instant Apps notification.
 *
 * The test verifies that an Instant App notification will be shown when
 * an Instant App is at foreground.
 */
public class NotificationTestActivity extends BaseTestActivity {

    private String gms_package_name = ""com.google.android.gms"";
    private String store_package_name = ""com.android.vending"";

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setInfoResources(R.string.ia_notification, R.string.ia_notification_info, -1);
        TextView extraText = (TextView) findViewById(R.id.instruction_extra_text);
        if (deviceIsGms()) {
            extraText.setText(R.string.ia_notification_instruction_label);
        } else {
            extraText.setText(R.string.ia_notification_instruction_label_no_app_market_version);
        }
    }

    private boolean deviceIsGms() {
        return deviceHasGmsCore() && deviceHasPlayStore() && !deviceHasCnFeature();
    }

    private boolean deviceHasCnFeature() {
        boolean hasCnFeature = getApplicationContext().getPackageManager().hasSystemFeature(""cn.google.services"");
        return hasCnFeature;
    }

    private boolean deviceHasGmsCore() {
        try {
            return getPackageManager().getApplicationInfo(gms_package_name, PackageManager.MATCH_DIRECT_BOOT_AUTO) != null;
        } catch (PackageManager.NameNotFoundException ex) {
            return false;
        }
    }

    private boolean deviceHasPlayStore() {
        try {
            return getPackageManager().getApplicationInfo(store_package_name, PackageManager.MATCH_DIRECT_BOOT_AUTO) != null;
        } catch (PackageManager.NameNotFoundException ex) {
            return false;
        }
    }
}"	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/instantapps/NotificationTestActivity.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.keystore.cts.performance.AttestationPerformanceTest"	"testEcKeyAttestation"	"CtsKeystoreTestCases"	"1: ui"	"public void testEcKeyAttestation() throws Exception {
        if (!TestUtils.isAttestationSupported()) {
            return;
        }

        for (byte[] challenge : ATTESTATION_CHALLENGES) {
            for (int curve : EC_CURVES) {
                measure(new KeystoreAttestationMeasurable(
                        new AndroidKeystoreEcKeyGenerator(""SHA1withECDSA"", curve, challenge),
                        curve,
                        challenge.length));
            }
        }
    }

    private class AndroidKeystoreRsaKeyGenerator extends AndroidKeystoreKeyGenerator {

        AndroidKeystoreRsaKeyGenerator(String algorithm, int keySize, byte[] challenge)
                throws Exception {
            super(algorithm);
            getKeyPairGenerator()
                    .initialize(
                            getKeyGenParameterSpecBuilder(
                                            KeyProperties.PURPOSE_SIGN
                                                    | KeyProperties.PURPOSE_VERIFY)
                                    .setKeySize(keySize)
                                    .setSignaturePaddings(
                                            TestUtils.getSignatureAlgorithmPadding(algorithm))
                                    .setDigests(TestUtils.getSignatureAlgorithmDigest(algorithm))
                                    .setAttestationChallenge(challenge)
                                    .build());
        }
    }

    private class AndroidKeystoreEcKeyGenerator extends AndroidKeystoreKeyGenerator {

        AndroidKeystoreEcKeyGenerator(String algorithm, int keySize, byte[] challenge)
                throws Exception {
            super(algorithm);
            getKeyPairGenerator()
                    .initialize(
                            getKeyGenParameterSpecBuilder(
                                            KeyProperties.PURPOSE_SIGN
                                                    | KeyProperties.PURPOSE_VERIFY)
                                    .setKeySize(keySize)
                                    .setDigests(TestUtils.getSignatureAlgorithmDigest(algorithm))
                                    .setAttestationChallenge(challenge)
                                    .build());
        }
    }

    private class KeystoreAttestationMeasurable extends KeystoreMeasurable {
        private final AndroidKeystoreKeyGenerator mKeyGen;

        KeystoreAttestationMeasurable(
                AndroidKeystoreKeyGenerator keyGen, int keySize, int challengeSize)
                throws Exception {
            super(keyGen, ""attest"", keySize, challengeSize);
            mKeyGen = keyGen;
        }

        @Override
        public void initialSetUp() throws Exception {
            mKeyGen.getKeyPairGenerator().generateKeyPair();
        }

        @Override
        public void measure() throws Exception {
            mKeyGen.getCertificateChain();
        }
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/performance/AttestationPerformanceTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.verifier.sensors.RVCVCameraPreview"	"getDefaultDisplay"	""	"2: ui system"	"public void test/*
 *.
 */
package com.android.cts.verifier.sensors;

// ----------------------------------------------------------------------

import android.content.Context;
import android.hardware.Camera;
import android.util.AttributeSet;
import android.util.Log;
import android.view.Surface;
import android.view.SurfaceHolder;
import android.view.SurfaceView;
import android.view.ViewGroup;
import android.view.WindowManager;

import java.io.IOException;
import java.lang.Math;

import com.android.cts.verifier.sensors.RVCVRecordActivity;
import com.android.cts.verifier.sensors.RVCVRecordActivity.RecordProcedureControllerCallback;

/** Camera preview class */
public class RVCVCameraPreview extends SurfaceView implements SurfaceHolder.Callback {
    private static final String TAG = ""RVCVCameraPreview"";
    private static final boolean LOCAL_LOGD = true;

    private Context mContext = null;
    private SurfaceHolder mHolder;
    private Camera mCamera;
    private float mCameraAspectRatio = 0;
    private int mCameraRotation = 0;
    private boolean mCheckStartTest = false;
    private boolean mPreviewStarted = false;

    private RVCVRecordActivity.RecordProcedureControllerCallback mRecordProcedureControllerCallback;

    /**
     * Constructor
     * @param context Activity context
     */
    public RVCVCameraPreview(Context context) {
        super(context);
        mContext = context;
        mCamera = null;
        initSurface();
    }

    /**
     * Constructor
     * @param context Activity context
     * @param attrs
     */
    public RVCVCameraPreview(Context context, AttributeSet attrs) {
        super(context, attrs);
        mContext = context;
    }

    public void init(Camera camera, float aspectRatio, int rotation)  {
        this.mCamera = camera;
        mCameraAspectRatio = aspectRatio;
        mCameraRotation = rotation;
        initSurface();
    }

    private void initSurface() {
        // Install a SurfaceHolder.Callback so we get notified when the
        // underlying surface is created and destroyed.
        mHolder = getHolder();
        mHolder.addCallback(this);

        // deprecated
        // TODO: update this code to match new API level.
        mHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
    }

    /**
     *  SurfaceHolder.Callback
     *  Surface is created, it is OK to start the camera preview now.
     */
    public void surfaceCreated(SurfaceHolder holder) {
        // The Surface has been created, now tell the camera where to draw the preview.

        if (mCamera == null) {
            // preview camera does not exist
            return;
        }
    }
    /**
     *  SurfaceHolder.Callback
     */
    public void surfaceDestroyed(SurfaceHolder holder) {
        // empty. Take care of releasing the Camera preview in your activity.
    }

    /**
     *  SurfaceHolder.Callback
     *  Restart camera preview if surface changed
     */
    public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {

        if (mHolder.getSurface() == null || mCamera == null){
            // preview surface or camera does not exist
            return;
        }

        int totalRotation = getRequiredRotation();
        mCamera.setDisplayOrientation(totalRotation);

        if (adjustLayoutParamsIfNeeded(totalRotation)) {
            // Wait on next surfaceChanged() call before proceeding
            Log.d(TAG, ""Waiting on surface change before starting preview"");
            return;
        }

        if (mPreviewStarted) {
            Log.w(TAG, ""Re-starting camera preview"");
            if (mCheckStartTest && mRecordProcedureControllerCallback != null) {
                mRecordProcedureControllerCallback.stopRecordProcedureController();
            }
            mCamera.stopPreview();
            mPreviewStarted = false;
        }
        mCheckStartTest = false;

        try {
            mCamera.setPreviewDisplay(holder);
            mCamera.startPreview();
            mPreviewStarted = true;
            if (mRecordProcedureControllerCallback != null) {
                mCheckStartTest = true;
                mRecordProcedureControllerCallback.startRecordProcedureController();
            }
        } catch (IOException e) {
            if (LOCAL_LOGD) Log.d(TAG, ""Error when starting camera preview: "" + e.getMessage());
        }
    }

    /**
     * Determine the rotation required to display the camera's preview on the screen as large as
     * possible. This function combines the device's current rotation from its default orientation
     * and the rotation of the camera.
     */
    private int getRequiredRotation() {
        WindowManager windowManager =
                (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
        int deviceRotation = 0;
        if (windowManager != null) {
            switch (windowManager.getDefaultDisplay().getRotation()) {
                case Surface.ROTATION_0:
                    deviceRotation = 0;
                    break;
                case Surface.ROTATION_90:
                    deviceRotation = 270;
                    break;
                case Surface.ROTATION_180:
                    deviceRotation = 180;
                    break;
                case Surface.ROTATION_270:
                    deviceRotation = 90;
                    break;
                default:
                    deviceRotation = 0;
                    break;
            }
        } else {
            Log.w(TAG, ""Unable to get device rotation, preview may be skewed."");
        }

        return (mCameraRotation + deviceRotation) % 360;
    }

    /**
     * Resize the layout to more closely match the desired aspect ratio, if necessary.
     *
     * @return true if we updated the layout params, false if the params look good
     */
    private boolean adjustLayoutParamsIfNeeded(int totalRotation) {
        // Determine the maximum size layout that maintains the camera's preview aspect ratio
        float cameraAspect = mCameraAspectRatio;

        // Check the camera and device rotation and invert the aspect ratio if the device is not
        // rotated at 0 or 180 degrees.
        if (totalRotation % 180 != 0) {
            // The device is rotated, so the screen should be the inverse of the aspect ratio
            cameraAspect = 1.0f / mCameraAspectRatio;
        }

        // Only adjust if there is at least 1% error between the aspects
        ViewGroup.LayoutParams layoutParams = getLayoutParams();
        int curWidth = getWidth();
        int curHeight = getHeight();
        float curAspect = (float)curWidth / (float)curHeight;
        float aspectDelta = Math.abs(cameraAspect - curAspect);
        if ((aspectDelta / cameraAspect) >= 0.01) {
            if (cameraAspect > curAspect) {
                // Camera preview is wider than the current layout. Need to shorten the current layout
                layoutParams.width = curWidth;
                layoutParams.height = (int)(curWidth / cameraAspect);
            } else {
                // Camera preview taller than the current layout. Need to narrow the current layout
                layoutParams.width = (int)(curHeight * cameraAspect);
                layoutParams.height = curHeight;
            }

            if (layoutParams.height != curHeight || layoutParams.width != curWidth) {
                Log.d(TAG, String.format(""Layout (%d, %d) -> (%d, %d)"", curWidth, curHeight,
                        layoutParams.width, layoutParams.height));
                setLayoutParams(layoutParams);
                return true;
            }
        }
        return false;
    }

    public void setRecordProcedureControllerCallback(
            RVCVRecordActivity.RecordProcedureControllerCallback callback) {
        mRecordProcedureControllerCallback = callback;
    }
}"	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/sensors/RVCVCameraPreview.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.location.cts.gnss.asn1.supl2.ulp_version_2_message_extensions.BasicProtectionParams"	"isTagImplicit"	"CtsLocationGnssTestCases"	"1: ui"	"public void test/*
 *.
 */

package android.location.cts.asn1.supl2.ulp_version_2_message_extensions;

/*
 */


//
//
import android.location.cts.asn1.base.Asn1BitString;
import android.location.cts.asn1.base.Asn1Integer;
import android.location.cts.asn1.base.Asn1Null;
import android.location.cts.asn1.base.Asn1Object;
import android.location.cts.asn1.base.Asn1OctetString;
import android.location.cts.asn1.base.Asn1Sequence;
import android.location.cts.asn1.base.Asn1Tag;
import android.location.cts.asn1.base.BitStream;
import android.location.cts.asn1.base.BitStreamReader;
import android.location.cts.asn1.base.SequenceComponent;
import com.google.common.collect.ImmutableList;
import java.util.Collection;
import javax.annotation.Nullable;


/**
*/
public  class BasicProtectionParams extends Asn1Sequence {
  //

  private static final Asn1Tag TAG_BasicProtectionParams
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public BasicProtectionParams() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_BasicProtectionParams;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_BasicProtectionParams != null) {
      return ImmutableList.of(TAG_BasicProtectionParams);
    } else {
      return Asn1Sequence.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new BasicProtectionParams from encoded stream.
   */
  public static BasicProtectionParams fromPerUnaligned(byte[] encodedBytes) {
    BasicProtectionParams result = new BasicProtectionParams();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new BasicProtectionParams from encoded stream.
   */
  public static BasicProtectionParams fromPerAligned(byte[] encodedBytes) {
    BasicProtectionParams result = new BasicProtectionParams();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }



  @Override protected boolean isExtensible() {
    return true;
  }

  @Override public boolean containsExtensionValues() {
    for (SequenceComponent extensionComponent : getExtensionComponents()) {
      if (extensionComponent.isExplicitlySet()) return true;
    }
    return false;
  }

  
  private BasicProtectionParams.keyIdentifierType keyIdentifier_;
  public BasicProtectionParams.keyIdentifierType getKeyIdentifier() {
    return keyIdentifier_;
  }
  /**
   * @throws ClassCastException if value is not a BasicProtectionParams.keyIdentifierType
   */
  public void setKeyIdentifier(Asn1Object value) {
    this.keyIdentifier_ = (BasicProtectionParams.keyIdentifierType) value;
  }
  public BasicProtectionParams.keyIdentifierType setKeyIdentifierToNewInstance() {
    keyIdentifier_ = new BasicProtectionParams.keyIdentifierType();
    return keyIdentifier_;
  }
  
  private BasicProtectionParams.basicReplayCounterType basicReplayCounter_;
  public BasicProtectionParams.basicReplayCounterType getBasicReplayCounter() {
    return basicReplayCounter_;
  }
  /**
   * @throws ClassCastException if value is not a BasicProtectionParams.basicReplayCounterType
   */
  public void setBasicReplayCounter(Asn1Object value) {
    this.basicReplayCounter_ = (BasicProtectionParams.basicReplayCounterType) value;
  }
  public BasicProtectionParams.basicReplayCounterType setBasicReplayCounterToNewInstance() {
    basicReplayCounter_ = new BasicProtectionParams.basicReplayCounterType();
    return basicReplayCounter_;
  }
  
  private BasicProtectionParams.basicMACType basicMAC_;
  public BasicProtectionParams.basicMACType getBasicMAC() {
    return basicMAC_;
  }
  /**
   * @throws ClassCastException if value is not a BasicProtectionParams.basicMACType
   */
  public void setBasicMAC(Asn1Object value) {
    this.basicMAC_ = (BasicProtectionParams.basicMACType) value;
  }
  public BasicProtectionParams.basicMACType setBasicMACToNewInstance() {
    basicMAC_ = new BasicProtectionParams.basicMACType();
    return basicMAC_;
  }
  

  

  

  @Override public Iterable<? extends SequenceComponent> getComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 0);

          @Override public boolean isExplicitlySet() {
            return getKeyIdentifier() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getKeyIdentifier();
          }

          @Override public void setToNewInstance() {
            setKeyIdentifierToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? BasicProtectionParams.keyIdentifierType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""keyIdentifier : ""
                    + getKeyIdentifier().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 1);

          @Override public boolean isExplicitlySet() {
            return getBasicReplayCounter() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getBasicReplayCounter();
          }

          @Override public void setToNewInstance() {
            setBasicReplayCounterToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? BasicProtectionParams.basicReplayCounterType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""basicReplayCounter : ""
                    + getBasicReplayCounter().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 2);

          @Override public boolean isExplicitlySet() {
            return getBasicMAC() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getBasicMAC();
          }

          @Override public void setToNewInstance() {
            setBasicMACToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? BasicProtectionParams.basicMACType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""basicMAC : ""
                    + getBasicMAC().toIndentedString(indent);
              }
        });
    
    return builder.build();
  }

  @Override public Iterable<? extends SequenceComponent>
                                                    getExtensionComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
      
      return builder.build();
    }

  
/*
 */


//

/**
 */
public static class keyIdentifierType extends Asn1OctetString {
  //

  private static final Asn1Tag TAG_keyIdentifierType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public keyIdentifierType() {
    super();
    setMinSize(8);
setMaxSize(8);

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_keyIdentifierType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_keyIdentifierType != null) {
      return ImmutableList.of(TAG_keyIdentifierType);
    } else {
      return Asn1OctetString.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new keyIdentifierType from encoded stream.
   */
  public static keyIdentifierType fromPerUnaligned(byte[] encodedBytes) {
    keyIdentifierType result = new keyIdentifierType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new keyIdentifierType from encoded stream.
   */
  public static keyIdentifierType fromPerAligned(byte[] encodedBytes) {
    keyIdentifierType result = new keyIdentifierType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override protected String getTypeName() {
    return ""keyIdentifierType"";
  }
}

  
/*
 */


//

/**
 */
public static class basicReplayCounterType extends Asn1Integer {
  //

  private static final Asn1Tag TAG_basicReplayCounterType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public basicReplayCounterType() {
    super();
    setValueRange(""0"", ""65535"");

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_basicReplayCounterType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_basicReplayCounterType != null) {
      return ImmutableList.of(TAG_basicReplayCounterType);
    } else {
      return Asn1Integer.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new basicReplayCounterType from encoded stream.
   */
  public static basicReplayCounterType fromPerUnaligned(byte[] encodedBytes) {
    basicReplayCounterType result = new basicReplayCounterType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new basicReplayCounterType from encoded stream.
   */
  public static basicReplayCounterType fromPerAligned(byte[] encodedBytes) {
    basicReplayCounterType result = new basicReplayCounterType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""basicReplayCounterType = "" + getInteger() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class basicMACType extends Asn1BitString {
  //

  private static final Asn1Tag TAG_basicMACType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public basicMACType() {
    super();
    setMinSize(32);
setMaxSize(32);

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_basicMACType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_basicMACType != null) {
      return ImmutableList.of(TAG_basicMACType);
    } else {
      return Asn1BitString.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new basicMACType from encoded stream.
   */
  public static basicMACType fromPerUnaligned(byte[] encodedBytes) {
    basicMACType result = new basicMACType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new basicMACType from encoded stream.
   */
  public static basicMACType fromPerAligned(byte[] encodedBytes) {
    basicMACType result = new basicMACType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""basicMACType = "" + getValue() + "";\n"";
  }
}

  

    

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    StringBuilder builder = new StringBuilder();
    builder.append(""BasicProtectionParams = {\n"");
    final String internalIndent = indent + ""  "";
    for (SequenceComponent component : getComponents()) {
      if (component.isExplicitlySet()) {
        builder.append(internalIndent)
            .append(component.toIndentedString(internalIndent));
      }
    }
    if (isExtensible()) {
      builder.append(internalIndent).append(""...\n"");
      for (SequenceComponent component : getExtensionComponents()) {
        if (component.isExplicitlySet()) {
          builder.append(internalIndent)
              .append(component.toIndentedString(internalIndent));
        }
      }
    }
    builder.append(indent).append(""};\n"");
    return builder.toString();
  }
}"	"/home/gpoor/cts-12-source/cts/tests/location/location_gnss/src/android/location/cts/gnss/asn1/supl2/ulp_version_2_message_extensions/BasicProtectionParams.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.verifier.sensors.sixdof.Utils.Path.ComplexMovementPath"	"isEntered"	""	"1: user"	"public void test/*
 *.
 */
package com.android.cts.verifier.sensors.sixdof.Utils.Path;

import java.util.ArrayList;
import java.util.Random;

import static com.android.cts.verifier.sensors.sixdof.Utils.MathsUtils.VECTOR_2D;
import static com.android.cts.verifier.sensors.sixdof.Utils.MathsUtils.X;
import static com.android.cts.verifier.sensors.sixdof.Utils.MathsUtils.Y;
import static com.android.cts.verifier.sensors.sixdof.Utils.MathsUtils.Z;
import static com.android.cts.verifier.sensors.sixdof.Utils.MathsUtils.dotProduct;

import com.android.cts.verifier.sensors.sixdof.Utils.MathsUtils;
import com.android.cts.verifier.sensors.sixdof.Utils.Exceptions.WaypointRingNotEnteredException;
import com.android.cts.verifier.sensors.sixdof.Utils.Path.PathUtilityClasses.Ring;
import com.android.cts.verifier.sensors.sixdof.Utils.Path.PathUtilityClasses.Waypoint;

/**
 * Handles all the path properties of the ComplexMovement Path.
 */
public class ComplexMovementPath extends com.android.cts.verifier.sensors.sixdof.Utils.Path.Path {
    public static final float DISTANCE_FOR_RING_POSITION = 0.25f;
    public static final int RINGS_PER_PATH = 5;

    private ArrayList<Ring> mRings = new ArrayList<>();
    private Random mRandomGenerator = new Random();
    private int mCurrentLap = 0;
    private float mLocationMapping[][];

    /**
     * Possible locations for a ring.
     */
    private enum RingLocations {
        ORIGINAL,
        TOP,
        DOWN,
        LEFT,
        RIGHT,
        TOP_LEFT,
        TOP_RIGHT,
        BOTTOM_LEFT,
        BOTTOM_RIGHT,
    }

    /**
     * Constructor for this class does the mapping and the creation of rings.
     *
     * @param referencePathDistances The distance between the markers in the reference path
     * @param referencePath          The reference path
     */
    public ComplexMovementPath(
            ArrayList<Float> referencePathDistances, ArrayList<Waypoint> referencePath) {
        mapNineRingLocations();
        generatePathRings(referencePathDistances, referencePath);
    }

    /**
     * Defines the different ring locations that can be used when adding the rings.
     */
    private void mapNineRingLocations() {
        mLocationMapping = new float[RingLocations.values().length][2];
        mLocationMapping[RingLocations.ORIGINAL.ordinal()] = new float[]{0f, 0f};
        mLocationMapping[RingLocations.TOP.ordinal()] =
                new float[]{0f, DISTANCE_FOR_RING_POSITION};
        mLocationMapping[RingLocations.DOWN.ordinal()] =
                new float[]{0f, -DISTANCE_FOR_RING_POSITION};
        mLocationMapping[RingLocations.LEFT.ordinal()] =
                new float[]{-DISTANCE_FOR_RING_POSITION, 0f};
        mLocationMapping[RingLocations.RIGHT.ordinal()] =
                new float[]{DISTANCE_FOR_RING_POSITION, 0f};
        mLocationMapping[RingLocations.TOP_LEFT.ordinal()] =
                new float[]{-DISTANCE_FOR_RING_POSITION, DISTANCE_FOR_RING_POSITION};
        mLocationMapping[RingLocations.TOP_RIGHT.ordinal()] =
                new float[]{DISTANCE_FOR_RING_POSITION, DISTANCE_FOR_RING_POSITION};
        mLocationMapping[RingLocations.BOTTOM_LEFT.ordinal()] =
                new float[]{-DISTANCE_FOR_RING_POSITION, -DISTANCE_FOR_RING_POSITION};
        mLocationMapping[RingLocations.BOTTOM_RIGHT.ordinal()] =
                new float[]{DISTANCE_FOR_RING_POSITION, -DISTANCE_FOR_RING_POSITION};
    }

    /**
     * Performs ComplexMovement path related checks on a marker.
     *
     * @param coordinates the coordinates for the waypoint
     * @throws WaypointRingNotEnteredException if a ring is not entered
     */
    @Override
    public void additionalChecks(float[] coordinates) throws WaypointRingNotEnteredException {
        if (mCurrentLap != 0) {
            for (Ring ring : mRings) {
                if (ring.getPathNumber() == mCurrentLap && !ring.isEntered()) {
                    throw new WaypointRingNotEnteredException();
                }
            }
        }
        mCurrentLap++;
    }

    /**
     * Generates the rings for this path.
     *
     * @param referencePathDistances The distance between the markers in the reference path
     * @param referencePath          The reference path
     */
    private void generatePathRings(
            ArrayList<Float> referencePathDistances, ArrayList<Waypoint> referencePath) {
        ArrayList<Float> distanceBetweenRingSections;
        distanceBetweenRingSections = calculateSectionDistance(referencePathDistances);
        addRingsToPath(referencePath, distanceBetweenRingSections);
    }

    /**
     * Calculates the distance between the rings in a path.
     *
     * @param referencePathDistances The distance between the markers in the reference path.
     * @return The length of a section in the different paths.
     */
    private ArrayList<Float> calculateSectionDistance(ArrayList<Float> referencePathDistances) {
        ArrayList<Float> arrayToReturn = new ArrayList<>();
        for (Float distance : referencePathDistances) {
            arrayToReturn.add(distance / (RINGS_PER_PATH + 1f));
        }
        return arrayToReturn;
    }

    /**
     * Calculates the location for the ring and adds it to the path.
     *
     * @param referencePath               The reference path.
     * @param distanceBetweenRingSections The length of a section in the different paths.
     */
    private void addRingsToPath(
            ArrayList<Waypoint> referencePath, ArrayList<Float> distanceBetweenRingSections) {
        int currentPath = 0;
        Waypoint currentWaypoint = referencePath.get(0);
        for (Float pathIntervalDistance : distanceBetweenRingSections) {
            currentPath++;
            for (int i = 0; i < RINGS_PER_PATH; i++) {
                currentWaypoint = calculateRingLocationOnPath(
                        referencePath, referencePath.indexOf(currentWaypoint), pathIntervalDistance);
                mRings.add(createRing(referencePath, currentWaypoint, currentPath));
            }
            while (!currentWaypoint.isUserGenerated()) {
                currentWaypoint = referencePath.get(referencePath.indexOf(currentWaypoint) + 1);
            }
        }
    }

    /**
     * Creates the ring that will be added onto the path.
     *
     * @param referencePath The reference path.
     * @param waypoint      The waypoint which the ring will be located at.
     * @param currentPath   The part of the lap in which the ring will be placed.
     * @return A reference to the ring created.
     */
    private Ring createRing(ArrayList<Waypoint> referencePath, Waypoint waypoint, int currentPath) {
        float[] ringCenter = waypoint.getCoordinates();
        float[] pointRotation = calculateRingRotation(ringCenter,
                referencePath.get(referencePath.indexOf(waypoint) - 1).getCoordinates());
        int randomNumber = mRandomGenerator.nextInt(RingLocations.values().length);
        RingLocations ringLocationDifference = RingLocations.values()[randomNumber];
        ringCenter[X] += mLocationMapping[ringLocationDifference.ordinal()][0];
        ringCenter[Z] += mLocationMapping[ringLocationDifference.ordinal()][1];
        ArrayList<float[]> rotatedRect = calculateRectangleHitbox(ringCenter, pointRotation);
        return new Ring(ringCenter, currentPath, pointRotation, rotatedRect);
    }

    /**
     * Calculates the orientation of the ring.
     *
     * @param location1 The location of the first point.
     * @param location2 The location of the second point.
     * @return the rotation needed to get the orientation of the ring.
     */
    private float[] calculateRingRotation(float[] location1, float[] location2) {
        float[] rotation = new float[3];
        rotation[X] = location2[X] - location1[X];
        rotation[Y] = location2[Y] - location1[Y];
        rotation[Z] = location2[Z] - location1[Z];
        return rotation;
    }

    /**
     * Calculates the next possible position for the ring to be placed at.
     *
     * @param referencePath        The reference path.
     * @param currentLocation      The location to start calculating from.
     * @param pathIntervalDistance The distance indicating how far apart the rings are going to be.
     * @return The waypoint where the ring will be placed at.
     */
    private Waypoint calculateRingLocationOnPath(
            ArrayList<Waypoint> referencePath, int currentLocation, Float pathIntervalDistance) {
        float pathRemaining = 0;
        while (currentLocation < referencePath.size() - 1) {
            pathRemaining += MathsUtils.distanceCalculationOnXYPlane(
                    referencePath.get(currentLocation).getCoordinates(),
                    referencePath.get(currentLocation + 1).getCoordinates());
            if (pathRemaining >= pathIntervalDistance) {
                return referencePath.get(currentLocation);
            }
            currentLocation++;
        }
        throw new AssertionError(
                ""calculateRingLocationOnPath: Ring number and section number don't seem to match up"");
    }

    /**
     * Calculates the rectangular hit box for the ring.
     *
     * @param centre   the middle location of the ring.
     * @param rotation the rotation to get the same orientation of the ring.
     * @return The four corners of the rectangle.
     */
    private ArrayList<float[]> calculateRectangleHitbox(float[] centre, float[] rotation) {
        ArrayList<float[]> rectangle = new ArrayList<>();
        float magnitude = (float) Math.sqrt(Math.pow(rotation[X], 2) +
                Math.pow(rotation[Z], 2));
        float lengthScaleFactor = 0.02f / magnitude;
        float widthScaleFactor = 0.17f / magnitude;

        float[] rotationInverse = {0 - rotation[X], 0 - rotation[Y]};
        float[] rotationNinety = {rotation[Y], 0 - rotation[X]};
        float[] rotationNinetyInverse = {0 - rotation[Y], rotation[X]};

        float[] midFront = new float[2];
        midFront[X] = centre[X] + (lengthScaleFactor * rotation[X]);
        midFront[Y] = centre[Y] + (lengthScaleFactor * rotation[Y]);
        float[] midRear = new float[2];
        midRear[X] = centre[X] + (lengthScaleFactor * rotationInverse[X]);
        midRear[Y] = centre[Y] + (lengthScaleFactor * rotationInverse[Y]);

        float[] frontLeft = new float[3];
        frontLeft[Z] = centre[Z];
        frontLeft[X] = midFront[X] + (widthScaleFactor * rotationNinetyInverse[X]);
        frontLeft[Y] = midFront[Y] + (widthScaleFactor * rotationNinetyInverse[Y]);
        float[] frontRight = new float[3];
        frontRight[Z] = centre[Z];
        frontRight[X] = midFront[X] + (widthScaleFactor * rotationNinety[X]);
        frontRight[Y] = midFront[Y] + (widthScaleFactor * rotationNinety[Y]);
        float[] rearLeft = new float[3];
        rearLeft[Z] = centre[Z];
        rearLeft[X] = midRear[X] + (widthScaleFactor * rotationNinetyInverse[X]);
        rearLeft[Y] = midRear[Y] + (widthScaleFactor * rotationNinetyInverse[Y]);
        float[] rearRight = new float[3];
        rearRight[Z] = centre[Z];
        rearRight[X] = midRear[X] + (widthScaleFactor * rotationNinety[X]);
        rearRight[Y] = midRear[Y] + (widthScaleFactor * rotationNinety[Y]);

        rectangle.add(frontLeft);
        rectangle.add(frontRight);
        rectangle.add(rearRight);
        rectangle.add(rearLeft);
        return rectangle;
    }

    /**
     * Check to see if a ring has been entered.
     *
     * @param location the location of the user to be tested.
     */
    public Ring hasRingBeenEntered(float[] location) {
        float xDifference, yDifference, zDifference;
        for (int i = 0; i < mRings.size(); i++) {
            if (mRings.get(i).getPathNumber() == mCurrentLap) {
                xDifference = Math.abs(mRings.get(i).getLocation()[X] - location[X]);
                yDifference = Math.abs(mRings.get(i).getLocation()[Y] - location[Y]);
                zDifference = Math.abs(mRings.get(i).getLocation()[Z] - location[Z]);
                if (xDifference < 0.17 && yDifference < 0.17 && zDifference < 0.17) {
                    if (checkCollision(mRings.get(i), location)) {
                        return mRings.get(i);
                    }
                }
            }
        }
        return null;
    }

    /**
     * Calculates whether the location of the user is in the rectangular hit box or not.
     *
     * @param ring     the ring to be tested.
     * @param location the location of the user.
     * @return true if the ring is entered and false if it is not.
     */
    private boolean checkCollision(Ring ring, float[] location) {
        float[] rectangleVector1 = new float[2];
        rectangleVector1[X] = ring.getRectangleHitBox().get(0)[X] - ring.getRectangleHitBox().get(3)[X];
        rectangleVector1[Y] = ring.getRectangleHitBox().get(0)[Y] - ring.getRectangleHitBox().get(3)[Y];

        float[] rectangleVector2 = new float[2];
        rectangleVector2[X] = ring.getRectangleHitBox().get(2)[X] - ring.getRectangleHitBox().get(3)[X];
        rectangleVector2[Y] = ring.getRectangleHitBox().get(2)[Y] - ring.getRectangleHitBox().get(3)[Y];

        float[] locationVector = new float[2];
        locationVector[X] = location[X] - ring.getRectangleHitBox().get(3)[X];
        locationVector[Y] = location[Y] - ring.getRectangleHitBox().get(3)[Y];

        if (dotProduct(rectangleVector1, locationVector, VECTOR_2D) > 0) {
            if (dotProduct(rectangleVector1, rectangleVector1, VECTOR_2D)
                    > dotProduct(rectangleVector1, locationVector, VECTOR_2D)) {
                if (dotProduct(rectangleVector2, locationVector, VECTOR_2D) > 0) {
                    if (dotProduct(rectangleVector2, rectangleVector2, VECTOR_2D)
                            > dotProduct(rectangleVector2, locationVector, VECTOR_2D)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    /**
     * Returns the list of rings.
     */
    public ArrayList<Ring> getRings() {
        return new ArrayList<>(mRings);
    }
}"	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/sensors/sixdof/Utils/Path/ComplexMovementPath.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.media.cts.AudioRecord_BufferSizeTest"	"testGetMinBufferSize"	"CtsMediaTestCases"	"3: mic system microphone"	"public void testGetMinBufferSize() throws Exception {
        if (!hasMicrophone()) {
            return;
        }
        List<Integer> failedSampleRates = new ArrayList<Integer>();
        for (int i = 0; i < SAMPLE_RATES_IN_HZ.length; i++) {
            try {
                record(SAMPLE_RATES_IN_HZ[i]);
            } catch (Throwable e) {
                Log.e(TAG, ""Sample rate: "" + SAMPLE_RATES_IN_HZ[i], e);
                failedSampleRates.add(SAMPLE_RATES_IN_HZ[i]);
                if (mAudioRecord != null) {
                    // clean up.  AudioRecords are in scarce supply.
                    mAudioRecord.release();
                    mAudioRecord = null;
                }
            }
        }
        assertTrue(""Failed sample rates: "" + failedSampleRates + "" See log for more details."",
                failedSampleRates.isEmpty());
    }

    private void record(int sampleRateInHz) {
        int bufferSize = AudioRecord.getMinBufferSize(sampleRateInHz, CHANNEL_CONFIG, AUDIO_FORMAT);
        assertTrue(bufferSize > 0);

        createAudioRecord(sampleRateInHz, bufferSize);
        // RecordingState changes are reflected synchronously (no need to poll)
        assertEquals(AudioRecord.RECORDSTATE_STOPPED, mAudioRecord.getRecordingState());

        mAudioRecord.startRecording();
        assertEquals(AudioRecord.RECORDSTATE_RECORDING, mAudioRecord.getRecordingState());

        // it is preferred to use a short array to read AudioFormat.ENCODING_PCM_16BIT data
        // but it's ok to read using using a byte array.  16 bit PCM data will be
        // stored as two bytes, native endian.
        byte[] buffer = new byte[bufferSize];
        assertTrue(mAudioRecord.read(buffer, 0, bufferSize) > 0);

        mAudioRecord.stop();
        assertEquals(AudioRecord.RECORDSTATE_STOPPED, mAudioRecord.getRecordingState());

        mAudioRecord.release();
        mAudioRecord = null;
    }

    private void createAudioRecord(final int sampleRateInHz, final int bufferSize) {
        mAudioRecord = new AudioRecord(AudioSource.DEFAULT, sampleRateInHz,
                CHANNEL_CONFIG, AUDIO_FORMAT, bufferSize);
        assertNotNull(mAudioRecord);
    }

    private boolean hasMicrophone() {
        return getContext().getPackageManager().hasSystemFeature(
                PackageManager.FEATURE_MICROPHONE);
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/AudioRecord_BufferSizeTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.RadioGroupTest"	"testConstructors"	"CtsWidgetTestCases"	"1: ui"	"public void testConstructors() {
        new RadioGroup(mActivity);

        AttributeSet attrs = getAttributeSet(R.layout.radiogroup_1);
        new RadioGroup(mActivity, attrs);
        new RadioGroup(mActivity, null);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/RadioGroupTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.RadioGroupTest"	"testSetOnHierarchyChangeListener"	"CtsWidgetTestCases"	"1: ui"	"public void testSetOnHierarchyChangeListener() {
        MockOnHierarchyChangeListener listener = new MockOnHierarchyChangeListener();
        mRadioGroup.setOnHierarchyChangeListener(listener);

        View button3 = mRadioGroup.findViewById(R.id.radio_button_3);
        listener.reset();
        mRadioGroup.removeView(button3);
        assertSame(mRadioGroup, listener.getOnChildViewRemovedParentParam());
        assertSame(button3, listener.getOnChildViewRemovedChildParam());

        listener.reset();
        mRadioGroup.addView(button3);
        assertSame(mRadioGroup, listener.getOnChildViewAddedParentParam());
        assertSame(button3, listener.getOnChildViewAddedChildParam());

        // Set listener to null
        mRadioGroup.setOnHierarchyChangeListener(null);
        // and no exceptions thrown in the following method calls
        mRadioGroup.removeView(button3);
        mRadioGroup.addView(button3);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/RadioGroupTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.RadioGroupTest"	"testInternalPassThroughHierarchyChangeListener"	"CtsWidgetTestCases"	"1: ui"	"public void testInternalPassThroughHierarchyChangeListener() {
        RadioButton newButton = new RadioButton(mActivity);

        assertEquals(View.NO_ID, newButton.getId());
        mRadioGroup.addView(newButton, new RadioGroup.LayoutParams(
                RadioGroup.LayoutParams.WRAP_CONTENT, RadioGroup.LayoutParams.WRAP_CONTENT));
        // aapt-generated IDs have a nonzero high byte; check that the ID generated by
        // RadioGroup falls within a range that will not collide with aapt IDs.
        assertEquals(0, newButton.getId() & 0xFF000000);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/RadioGroupTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.RadioGroupTest"	"testInternalCheckedStateTracker"	"CtsWidgetTestCases"	"1: ui"	"public void testInternalCheckedStateTracker() {
        RadioButton newButton = new RadioButton(mActivity);
        // inject the tracker to the button when the button is added by
        // CompoundButton#setOnCheckedChangeWidgetListener(OnCheckedChangeListener)
        mRadioGroup.addView(newButton, new RadioGroup.LayoutParams(
                RadioGroup.LayoutParams.WRAP_CONTENT, RadioGroup.LayoutParams.WRAP_CONTENT));
        MockOnCheckedChangeListener listener = new MockOnCheckedChangeListener();
        mRadioGroup.setOnCheckedChangeListener(listener);

        listener.reset();
        newButton.setChecked(true);
        // the tracker informs the checked state change of the button to the group
        assertHasCalledOnCheckedChanged(listener);

        listener.reset();
        // the tracker informs the checked state change of the button to the group
        newButton.setChecked(false);
        assertHasCalledOnCheckedChanged(listener);

        // remove the tracker from the button when the button is removed
        mRadioGroup.removeView(newButton);
        listener.reset();
        newButton.setChecked(true);
        assertHaveNotCalledOnCheckedChanged(listener);

        listener.reset();
        newButton.setChecked(false);
        assertHaveNotCalledOnCheckedChanged(listener);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/RadioGroupTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.RadioGroupTest"	"testGetCheckedRadioButtonId"	"CtsWidgetTestCases"	"1: ui"	"public void testGetCheckedRadioButtonId() {
        assertEquals(-1, mRadioGroup.getCheckedRadioButtonId());

        mRadioGroup.check(R.id.radio_button_0);
        assertEquals(R.id.radio_button_0, mRadioGroup.getCheckedRadioButtonId());

        mRadioGroup.check(R.id.radio_button_3);
        assertEquals(R.id.radio_button_3, mRadioGroup.getCheckedRadioButtonId());

        // None of the buttons inside the group has of of the following IDs
        mRadioGroup.check(4);
        assertEquals(4, mRadioGroup.getCheckedRadioButtonId());

        mRadioGroup.check(-1);
        assertEquals(-1, mRadioGroup.getCheckedRadioButtonId());

        mRadioGroup.check(-3);
        assertEquals(-3, mRadioGroup.getCheckedRadioButtonId());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/RadioGroupTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.RadioGroupTest"	"testClearCheck"	"CtsWidgetTestCases"	"1: ui"	"public void testClearCheck() {
        MockOnCheckedChangeListener listener = new MockOnCheckedChangeListener();
        mRadioGroup.setOnCheckedChangeListener(listener);

        mRadioGroup.check(R.id.radio_button_3);
        assertEquals(R.id.radio_button_3, mRadioGroup.getCheckedRadioButtonId());

        listener.reset();
        mRadioGroup.clearCheck();
        assertEquals(-1, mRadioGroup.getCheckedRadioButtonId());
        assertHasCalledOnCheckedChanged(listener);
        // uncheck the original button
        assertOnCheckedChangedParams(listener, 0, mRadioGroup, R.id.radio_button_3);

        // None of the buttons inside the group has of of the following IDs
        mRadioGroup.check(4);
        assertEquals(4, mRadioGroup.getCheckedRadioButtonId());

        listener.reset();
        mRadioGroup.clearCheck();
        assertEquals(-1, mRadioGroup.getCheckedRadioButtonId());
        // why the method is called while none of the button is checked or unchecked?
        assertHasCalledOnCheckedChanged(listener);
        assertOnCheckedChangedParams(listener, 0, mRadioGroup, -1);

        mRadioGroup.check(-1);
        assertEquals(-1, mRadioGroup.getCheckedRadioButtonId());

        listener.reset();
        mRadioGroup.clearCheck();
        assertEquals(-1, mRadioGroup.getCheckedRadioButtonId());
        // why the method is called while none of the button is checked or unchecked?
        assertHasCalledOnCheckedChanged(listener);
        assertOnCheckedChangedParams(listener, 0, mRadioGroup, -1);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/RadioGroupTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.RadioGroupTest"	"testCheck"	"CtsWidgetTestCases"	"1: ui"	"public void testCheck() {
        MockOnCheckedChangeListener listener = new MockOnCheckedChangeListener();
        mRadioGroup.setOnCheckedChangeListener(listener);
        assertEquals(-1, mRadioGroup.getCheckedRadioButtonId());

        listener.reset();
        mRadioGroup.check(R.id.radio_button_0);
        assertHasCalledOnCheckedChanged(listener);
        assertOnCheckedChangedParams(listener, 0, mRadioGroup, R.id.radio_button_0);

        listener.reset();
        mRadioGroup.check(R.id.radio_button_1);
        assertHasCalledOnCheckedChanged(listener);
        // uncheck the original button
        assertOnCheckedChangedParams(listener, 0, mRadioGroup, R.id.radio_button_0);
        // check the new button
        assertOnCheckedChangedParams(listener, 1, mRadioGroup, R.id.radio_button_1);

        listener.reset();
        mRadioGroup.check(-1);
        assertHasCalledOnCheckedChanged(listener);
        // uncheck the original button
        assertOnCheckedChangedParams(listener, 0, mRadioGroup, R.id.radio_button_1);
        assertOnCheckedChangedParams(listener, 1, mRadioGroup, -1);

        // None of the buttons inside the group has of of the following IDs
        listener.reset();
        mRadioGroup.check(-1);
        // why the method is called while none of the inside buttons has been changed
        assertHasCalledOnCheckedChanged(listener);
        assertOnCheckedChangedParams(listener, 0, mRadioGroup, -1);

        listener.reset();
        mRadioGroup.check(4);
        // why the method is called while none of the inside buttons has been changed
        assertHasCalledOnCheckedChanged(listener);
        assertOnCheckedChangedParams(listener, 0, mRadioGroup, 4);

        // Set listener to null
        mRadioGroup.setOnCheckedChangeListener(null);
        // no exceptions thrown during the following method
        mRadioGroup.check(0);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/RadioGroupTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.RadioGroupTest"	"testGenerateDefaultLayoutParams"	"CtsWidgetTestCases"	"1: ui"	"public void testGenerateDefaultLayoutParams() {
        MockRadioGroup radioGroupWrapper = new MockRadioGroup(mActivity);
        LinearLayout.LayoutParams p = radioGroupWrapper.generateDefaultLayoutParams();

        assertTrue(p instanceof RadioGroup.LayoutParams);
        assertEquals(RadioGroup.LayoutParams.WRAP_CONTENT, p.width);
        assertEquals(RadioGroup.LayoutParams.WRAP_CONTENT, p.height);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/RadioGroupTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.RadioGroupTest"	"testOnFinishInflate"	"CtsWidgetTestCases"	"1: ui"	"public void testOnFinishInflate() {
        MockRadioGroup radioGroup = new MockRadioGroup(mActivity);
        int checkId = 100;
        radioGroup.check(checkId);
        // the button is added after the check(int)method
        // and it not checked though it has exactly the checkId
        RadioButton button = new RadioButton(mActivity);
        button.setId(checkId);
        radioGroup.addView(button, new LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT));
        MockOnCheckedChangeListener listener = new MockOnCheckedChangeListener();
        radioGroup.setOnCheckedChangeListener(listener);

        // check the button which id is CheckedRadioButtonId
        listener.reset();
        assertFalse(button.isChecked());
        radioGroup.onFinishInflate();
        assertTrue(button.isChecked());
        assertHasCalledOnCheckedChanged(listener);
        assertEquals(checkId, radioGroup.getCheckedRadioButtonId());

        radioGroup = new MockRadioGroup(mActivity);
        button = new RadioButton(mActivity);
        radioGroup.addView(button, new LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.WRAP_CONTENT, LinearLayout.LayoutParams.WRAP_CONTENT));
        listener = new MockOnCheckedChangeListener();
        radioGroup.setOnCheckedChangeListener(listener);

        // nothing happens if checkedRadioButtonId is -1
        assertEquals(-1, radioGroup.getCheckedRadioButtonId());
        assertFalse(button.isChecked());
        listener.reset();
        radioGroup.onFinishInflate();
        assertHaveNotCalledOnCheckedChanged(listener);
        assertEquals(-1, radioGroup.getCheckedRadioButtonId());
        assertFalse(button.isChecked());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/RadioGroupTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.RadioGroupTest"	"testAddView"	"CtsWidgetTestCases"	"1: ui"	"public void testAddView() {
        mRadioGroup.check(R.id.radio_button_0);
        assertEquals(R.id.radio_button_0, mRadioGroup.getCheckedRadioButtonId());
        assertEquals(4, mRadioGroup.getChildCount());

        int id = R.id.radio_button_3 + 10;
        RadioButton choice4 = new RadioButton(mActivity);
        choice4.setText(""choice4"");
        choice4.setId(id);
        choice4.setChecked(true);
        mRadioGroup.addView(choice4, 4, new ViewGroup.LayoutParams(100, 200));
        assertEquals(id, mRadioGroup.getCheckedRadioButtonId());
        assertEquals(5, mRadioGroup.getChildCount());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/RadioGroupTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.RadioGroupTest"	"testOnInitializeAccessibilityNodeInfo_populatesCollectionInfo"	"CtsWidgetTestCases"	"1: ui"	"public void testOnInitializeAccessibilityNodeInfo_populatesCollectionInfo() {
        AccessibilityNodeInfo info = AccessibilityNodeInfo.obtain();
        mRadioGroup.onInitializeAccessibilityNodeInfo(info);

        AccessibilityNodeInfo.CollectionInfo colInfo = info.getCollectionInfo();
        assertNotNull(colInfo);
        assertEquals(colInfo.getRowCount(), mRadioGroup.getChildCount());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/RadioGroupTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.RadioGroupTest"	"testOnInitializeAccessibilityNodeInfo_populatesCollectionItemInfo"	"CtsWidgetTestCases"	"1: ui"	"public void testOnInitializeAccessibilityNodeInfo_populatesCollectionItemInfo() {
        RadioButton child = (RadioButton) mRadioGroup.getChildAt(1);
        child.setChecked(true);

        AccessibilityNodeInfo info = AccessibilityNodeInfo.obtain();
        child.onInitializeAccessibilityNodeInfo(info);

        AccessibilityNodeInfo.CollectionItemInfo colItemInfo = info.getCollectionItemInfo();
        assertEquals(colItemInfo.getRowIndex(), 1);
        assertEquals(colItemInfo.isSelected(), true);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/RadioGroupTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.appsearch.external.app.StorageInfoCtsTest"	"testBuildStorageInfo"	"CtsAppSearchTestCases"	"1: ui"	"public void testBuildStorageInfo() {
        StorageInfo storageInfo =
                new StorageInfo.Builder()
                        .setAliveDocumentsCount(10)
                        .setSizeBytes(1L)
                        .setAliveNamespacesCount(10)
                        .build();

        assertThat(storageInfo.getAliveDocumentsCount()).isEqualTo(10);
        assertThat(storageInfo.getSizeBytes()).isEqualTo(1L);
        assertThat(storageInfo.getAliveNamespacesCount()).isEqualTo(10);
    }"	"/home/gpoor/cts-12-source/cts/tests/appsearch/src/com/android/cts/appsearch/external/app/StorageInfoCtsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.appsearch.external.app.StorageInfoCtsTest"	"testBuildStorageInfo_withDefaults"	"CtsAppSearchTestCases"	"1: ui"	"public void testBuildStorageInfo_withDefaults() {
        StorageInfo storageInfo = new StorageInfo.Builder().build();

        assertThat(storageInfo.getAliveDocumentsCount()).isEqualTo(0);
        assertThat(storageInfo.getSizeBytes()).isEqualTo(0L);
        assertThat(storageInfo.getAliveNamespacesCount()).isEqualTo(0);
    }
}"	"/home/gpoor/cts-12-source/cts/tests/appsearch/src/com/android/cts/appsearch/external/app/StorageInfoCtsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.verifier.bluetooth.BluetoothChatService"	"listenUsingL2capChannel"	""	"1: ui"	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothServerSocket;
import android.bluetooth.BluetoothSocket;
import android.content.Context;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.util.Log;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.UUID;

/**
 * This class does all the work for setting up and managing Bluetooth
 * connections with other devices. It has a thread that listens for
 * incoming connections, a thread for connecting with a device, and a
 * thread for performing data transmissions when connected.
 */
public class BluetoothChatService {
    // Message types sent from the BluetoothChatService Handler
    public static final int MESSAGE_STATE_CHANGE = 1;
    public static final int MESSAGE_READ = 2;
    public static final int MESSAGE_WRITE = 3;
    public static final int MESSAGE_DEVICE_NAME = 4;
    public static final int MESSAGE_TOAST = 5;

    // Key names received from the BluetoothChatService Handler
    public static final String DEVICE_NAME = ""device_name"";
    public static final String TOAST = ""toast"";

    static final UUID SECURE_UUID =
            UUID.fromString(""8591d757-18ee-45e1-9b12-92875d06ba23"");
    static final UUID INSECURE_UUID =
            UUID.fromString(""301c214f-91a2-43bf-a795-09d1198a81a7"");
    static final UUID HANDSFREE_INSECURE_UUID =
            UUID.fromString(""0000111F-0000-1000-8000-00805F9B34FB"");

    // Debugging
    private static final String TAG = ""CtsBluetoothChatService"";
    private static final boolean D = true;

    // Name for the SDP record when creating server socket
    private static final String NAME_SECURE = ""CtsBluetoothChatSecure"";
    private static final String NAME_INSECURE = ""CtsBluetoothChatInsecure"";

    // Member fields
    private final BluetoothAdapter mAdapter;
    private final Handler mHandler;
    private final UUID mUuid;
    private AcceptThread mSecureAcceptThread;
    private AcceptThread mInsecureAcceptThread;
    private ConnectThread mConnectThread;
    private ConnectedThread mConnectedThread;
    private int mState;
    private boolean mBleTransport;
    private int mLePsm;
    private int mSocketConnectionType = -1;

    // Constants that indicate the current connection state
    public static final int STATE_NONE = 0;       // we're doing nothing
    public static final int STATE_LISTEN = 1;     // now listening for incoming connections
    public static final int STATE_CONNECTING = 2; // now initiating an outgoing connection
    public static final int STATE_CONNECTED = 3;  // now connected to a remote device

    /**
     * Constructor. Prepares a new BluetoothChat session.
     * @param context  The UI Activity Context
     * @param handler  A Handler to send messages back to the UI Activity
     */
    public BluetoothChatService(Context context, Handler handler, UUID uuid) {
        mAdapter = BluetoothAdapter.getDefaultAdapter();
        mState = STATE_NONE;
        mHandler = handler;
        mUuid = uuid;
        mBleTransport = false;
    }

    /**
     * Constructor. Prepares a new BluetoothChat session.
     * @param context  The UI Activity Context
     * @param handler  A Handler to send messages back to the UI Activity
     * @param useBle   A flag to use the BLE transport
     */
    public BluetoothChatService(Context context, Handler handler, boolean useBle) {
        mAdapter = BluetoothAdapter.getDefaultAdapter();
        mState = STATE_NONE;
        mHandler = handler;
        mUuid = null;
        mBleTransport = useBle;
        if (D) Log.d(TAG, ""Construct BluetoothChatService: useBle="" + useBle);
    }

    /**
     * Set the current state of the chat connection
     * @param state  An integer defining the current connection state
     */
    private synchronized void setState(int state) {
        if (D) Log.d(TAG, ""setState() "" + mState + "" -> "" + state);
        mState = state;

        // Give the new state to the Handler so the UI Activity can update
        mHandler.obtainMessage(MESSAGE_STATE_CHANGE, state, -1).sendToTarget();
    }

    /**
     * Return the current connection state. */
    public synchronized int getState() {
        return mState;
    }

    /**
     * Start the chat service. Specifically start AcceptThread to begin a
     * session in listening (server) mode. Called by the Activity onResume() */
    public synchronized void start(boolean secure) {
        if (D) Log.d(TAG, ""start secure: "" + secure + UUID.randomUUID() + "" - "" + UUID.randomUUID());

        // Cancel any thread attempting to make a connection
        if (mConnectThread != null) {mConnectThread.cancel(); mConnectThread = null;}

        // Cancel any thread currently running a connection
        if (mConnectedThread != null) {mConnectedThread.cancel(); mConnectedThread = null;}

        setState(STATE_LISTEN);

        // Start the thread to listen on a BluetoothServerSocket
        if (secure && mSecureAcceptThread == null) {
            mSecureAcceptThread = new AcceptThread(true);
            mSecureAcceptThread.start();
        }
        if (!secure && mInsecureAcceptThread == null) {
            mInsecureAcceptThread = new AcceptThread(false);
            mInsecureAcceptThread.start();
        }
    }

    /**
     * Return the assigned PSM value.
     */
    public synchronized int getPsm(boolean secure) {
        if (secure && mSecureAcceptThread != null) {
            return mSecureAcceptThread.getPsm();
        }
        else if (!secure && mInsecureAcceptThread != null) {
            return mInsecureAcceptThread.getPsm();
        }
        Log.e(TAG, ""getPsm: Invalid PSM value"");
        return 0;
    }

    /**
     * Return the socket Connection Type.
     */
    public synchronized int getSocketConnectionType() {
        return mSocketConnectionType;
    }

    /**
     * Start the ConnectThread to initiate a connection to a remote device.
     * @param device  The BluetoothDevice to connect to
     * @param secure Socket Security type - Secure (true) , Insecure (false)
     */
    public synchronized void connect(BluetoothDevice device, boolean secure) {
        if (!mBleTransport) {
            connect(device, secure, 0);
        } else {
            Log.e(TAG, ""connect: Error: LE cannot call this method!"");
        }
    }

    /**
     * Start the ConnectThread to initiate a connection to a remote device.
     * @param device  The BluetoothDevice to connect to
     * @param secure Socket Security type - Secure (true) , Insecure (false)
     * @param psm Assigned PSM value
     */
    public synchronized void connect(BluetoothDevice device, boolean secure, int psm) {
        if (D) Log.d(TAG, ""connect to: "" + device + "", psm: "" + psm + "", ble: "" + mBleTransport);

        // Cancel any thread attempting to make a connection
        if (mState == STATE_CONNECTING) {
            if (mConnectThread != null) {mConnectThread.cancel(); mConnectThread = null;}
        }

        // Cancel any thread currently running a connection
        if (mConnectedThread != null) {mConnectedThread.cancel(); mConnectedThread = null;}

        // Start the thread to connect with the given device
        mConnectThread = new ConnectThread(device, secure, psm);
        mConnectThread.start();
        setState(STATE_CONNECTING);
    }

    /**
     * Start the ConnectedThread to begin managing a Bluetooth connection
     * @param socket  The BluetoothSocket on which the connection was made
     * @param device  The BluetoothDevice that has been connected
     */
    public synchronized void connected(BluetoothSocket socket, BluetoothDevice
            device, final String socketType) {
        if (D) Log.d(TAG, ""connected, Socket Type: "" + socketType);

        // Cancel the thread that completed the connection
        if (mConnectThread != null) {mConnectThread.cancel(); mConnectThread = null;}

        // Cancel any thread currently running a connection
        if (mConnectedThread != null) {mConnectedThread.cancel(); mConnectedThread = null;}

        // Cancel the accept thread because we only want to connect to one device
        if (mSecureAcceptThread != null) {
            mSecureAcceptThread.cancel();
            mSecureAcceptThread = null;
        }
        if (mInsecureAcceptThread != null) {
            mInsecureAcceptThread.cancel();
            mInsecureAcceptThread = null;
        }

        // Start the thread to manage the connection and perform transmissions
        mConnectedThread = new ConnectedThread(socket, socketType);
        mConnectedThread.start();

        // Send the name of the connected device back to the UI Activity
        Message msg = mHandler.obtainMessage(MESSAGE_DEVICE_NAME);
        Bundle bundle = new Bundle();
        bundle.putString(DEVICE_NAME, device.getName());
        msg.setData(bundle);
        mHandler.sendMessage(msg);

        setState(STATE_CONNECTED);
    }

    /**
     * Stop all threads
     */
    public synchronized void stop() {
        if (D) Log.d(TAG, ""stop"");

        if (mConnectThread != null) {
            mConnectThread.cancel();
            mConnectThread = null;
        }

        if (mConnectedThread != null) {
            mConnectedThread.cancel();
            mConnectedThread = null;
        }

        if (mSecureAcceptThread != null) {
            mSecureAcceptThread.cancel();
            mSecureAcceptThread = null;
        }

        if (mInsecureAcceptThread != null) {
            mInsecureAcceptThread.cancel();
            mInsecureAcceptThread = null;
        }
        setState(STATE_NONE);
    }

    /**
     * Write to the ConnectedThread in an unsynchronized manner
     * @param out The bytes to write
     * @see ConnectedThread#write(byte[])
     */
    public void write(byte[] out) {
        // Create temporary object
        ConnectedThread r;
        // Synchronize a copy of the ConnectedThread
        synchronized (this) {
            if (mState != STATE_CONNECTED) return;
            r = mConnectedThread;
        }
        // Perform the write unsynchronized
        r.write(out);
    }

    /**
     * Indicate that the connection attempt failed and notify the UI Activity.
     */
    private void connectionFailed() {
        // Send a failure message back to the Activity
        Message msg = mHandler.obtainMessage(MESSAGE_TOAST);
        Bundle bundle = new Bundle();
        bundle.putString(TOAST, ""Unable to connect device"");
        msg.setData(bundle);
        mHandler.sendMessage(msg);
    }

    /**
     * Indicate that the connection was lost and notify the UI Activity.
     */
    private void connectionLost() {
        // Send a failure message back to the Activity
        Message msg = mHandler.obtainMessage(MESSAGE_TOAST);
        Bundle bundle = new Bundle();
        bundle.putString(TOAST, ""Device connection was lost"");
        msg.setData(bundle);
        mHandler.sendMessage(msg);
    }

    /**
     * This thread runs while listening for incoming connections. It behaves
     * like a server-side client. It runs until a connection is accepted
     * (or until cancelled).
     */
    private class AcceptThread extends Thread {
        // The local server socket
        private final BluetoothServerSocket mmServerSocket;
        private String mSocketType;

        public AcceptThread(boolean secure) {
            BluetoothServerSocket tmp = null;
            mSocketType = secure ? ""Secure"" : ""Insecure"";

            // Create a new listening server socket
            try {
                if (mBleTransport) {
                    if (secure) {
                        tmp = mAdapter.listenUsingL2capChannel();
                    } else {
                        tmp = mAdapter.listenUsingInsecureL2capChannel();
                    }
                } else {
                    if (secure) {
                        tmp = mAdapter.listenUsingRfcommWithServiceRecord(NAME_SECURE, mUuid);
                    } else {
                        tmp = mAdapter.listenUsingInsecureRfcommWithServiceRecord(NAME_INSECURE, mUuid);
                    }
                }
            } catch (IOException e) {
                Log.e(TAG, ""Socket Type: "" + mSocketType + "", le: "" + mBleTransport + "" listen() failed"", e);
            }
            mmServerSocket = tmp;
            if (mBleTransport) {
                // Get the assigned PSM value
                mLePsm = mmServerSocket.getPsm();
            }
        }

        public int getPsm() {
            return mLePsm;
        }

        public void run() {
            if (D) Log.d(TAG, ""Socket Type: "" + mSocketType +
                    "" BEGIN mAcceptThread"" + this);
            setName(""AcceptThread"" + mSocketType);

            BluetoothSocket socket = null;

            // Listen to the server socket if we're not connected
            while (mState != STATE_CONNECTED) {
                try {
                    // This is a blocking call and will only return on a
                    // successful connection or an exception
                    socket = mmServerSocket.accept();
                } catch (IOException e) {
                    Log.e(TAG, ""Socket Type: "" + mSocketType + "" accept() failed"", e);
                    break;
                }

                // If a connection was accepted
                if (socket != null) {
                    synchronized (BluetoothChatService.this) {
                        switch (mState) {
                        case STATE_LISTEN:
                        case STATE_CONNECTING:
                            // Situation normal. Start the connected thread.
                            mSocketConnectionType = socket.getConnectionType();
                            connected(socket, socket.getRemoteDevice(),
                                    mSocketType);
                            break;
                        case STATE_NONE:
                        case STATE_CONNECTED:
                            // Either not ready or already connected. Terminate new socket.
                            try {
                                socket.close();
                            } catch (IOException e) {
                                Log.e(TAG, ""Could not close unwanted socket"", e);
                            }
                            break;
                        }
                    }
                } else {
                    Log.i(TAG, ""Got null socket"");
                }
            }
            if (D) {
                Log.i(TAG, ""END mAcceptThread, socket Type: "" + mSocketType
                         + "", SocketConnectionType: "" + mSocketConnectionType);
            }
        }

        public void cancel() {
            if (D) Log.d(TAG, ""Socket Type"" + mSocketType + ""cancel "" + this);
            try {
                mmServerSocket.close();
            } catch (IOException e) {
                Log.e(TAG, ""Socket Type"" + mSocketType + ""close() of server failed"", e);
            }
        }
    }


    /**
     * This thread runs while attempting to make an outgoing connection
     * with a device. It runs straight through; the connection either
     * succeeds or fails.
     */
    private class ConnectThread extends Thread {
        private final BluetoothSocket mmSocket;
        private final BluetoothDevice mmDevice;
        private String mSocketType;

        public ConnectThread(BluetoothDevice device, boolean secure) {
            if (mBleTransport) {
                Log.e(TAG, ""ConnectThread: Error: LE should not call this constructor"");
            }
            mmDevice = device;
            mmSocket = connectThreadCommon(device, secure, 0);
        }

        public ConnectThread(BluetoothDevice device, boolean secure, int psm) {
            mmDevice = device;
            mmSocket = connectThreadCommon(device, secure, psm);
        }

        private BluetoothSocket connectThreadCommon(BluetoothDevice device, boolean secure, int psm) {
            BluetoothSocket tmp = null;
            mSocketType = secure ? ""Secure"" : ""Insecure"";

            // Get a BluetoothSocket for a connection with the
            // given BluetoothDevice
            try {
                if (mBleTransport) {
                    if (secure) {
                        tmp = device.createL2capChannel(psm);
                    } else {
                        tmp = device.createInsecureL2capChannel(psm);
                    }
                } else {
                    if (secure) {
                        tmp = device.createRfcommSocketToServiceRecord(mUuid);
                    } else {
                        tmp = device.createInsecureRfcommSocketToServiceRecord(mUuid);
                    }
                }
            } catch (IOException e) {
                Log.e(TAG, ""Socket Type: "" + mSocketType + ""create() failed"", e);
            }

            mSocketConnectionType = tmp.getConnectionType();

            return tmp;
        }

        public void run() {
            Log.i(TAG, ""BEGIN mConnectThread SocketType:"" + mSocketType
                  + "", mSocketConnectionType: "" + mSocketConnectionType);
            setName(""ConnectThread"" + mSocketType);

            // Always cancel discovery because it will slow down a connection
            mAdapter.cancelDiscovery();

            // Make a connection to the BluetoothSocket
            try {
                // This is a blocking call and will only return on a
                // successful connection or an exception
                mmSocket.connect();
            } catch (IOException e) {
                Log.e(TAG, ""connect() failed "", e);
                // Close the socket
                try {
                    mmSocket.close();
                } catch (IOException e2) {
                    Log.e(TAG, ""unable to close() "" + mSocketType +
                            "" socket during connection failure"", e2);
                }
                connectionFailed();
                return;
            }

            // Reset the ConnectThread because we're done
            synchronized (BluetoothChatService.this) {
                mConnectThread = null;
            }

            // Start the connected thread
            connected(mmSocket, mmDevice, mSocketType);
        }

        public void cancel() {
            try {
                mmSocket.close();
            } catch (IOException e) {
                Log.e(TAG, ""close() of connect "" + mSocketType + "" socket failed"", e);
            }
        }
    }

    /**
     * This thread runs during a connection with a remote device.
     * It handles all incoming and outgoing transmissions.
     */
    private class ConnectedThread extends Thread {
        private final BluetoothSocket mmSocket;
        private final InputStream mmInStream;
        private final OutputStream mmOutStream;

        public ConnectedThread(BluetoothSocket socket, String socketType) {
            Log.d(TAG, ""create ConnectedThread: "" + socketType);
            mmSocket = socket;
            InputStream tmpIn = null;
            OutputStream tmpOut = null;

            // Get the BluetoothSocket input and output streams
            try {
                tmpIn = socket.getInputStream();
                tmpOut = socket.getOutputStream();
            } catch (IOException e) {
                Log.e(TAG, ""temp sockets not created"", e);
            }

            mmInStream = tmpIn;
            mmOutStream = tmpOut;
        }

        public void run() {
            Log.i(TAG, ""BEGIN mConnectedThread"");
            int bytes;

            // Keep listening to the InputStream while connected
            while (true) {
                try {
                    byte[] buffer = new byte[1024];
                    // Read from the InputStream
                    bytes = mmInStream.read(buffer);

                    // Send the obtained bytes to the UI Activity
                    mHandler.obtainMessage(MESSAGE_READ, bytes, -1, buffer)
                            .sendToTarget();
                } catch (IOException e) {
                    Log.e(TAG, ""disconnected"", e);
                    connectionLost();
                    break;
                }
            }
        }

        /**
         * Write to the connected OutStream.
         * @param buffer  The bytes to write
         */
        public void write(byte[] buffer) {
            try {
                mmOutStream.write(buffer);
                mmOutStream.flush();

                // Share the sent message back to the UI Activity
                mHandler.obtainMessage(MESSAGE_WRITE, -1, -1, buffer)
                        .sendToTarget();
            } catch (IOException e) {
                Log.e(TAG, ""Exception during write"", e);
            }
        }

        public void cancel() {
            try {
                mmSocket.close();
            } catch (IOException e) {
                Log.e(TAG, ""close() of connect socket failed"", e);
            }
        }
    }
}"	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/BluetoothChatService.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.deviceinfo.SensorDeviceInfo"	"isWakeUpSensor"	""	"3: mic direct system"	"public void test/*
 *.
 */
package com.android.cts.deviceinfo;

import android.content.Context;
import android.hardware.Sensor;
import android.hardware.SensorDirectChannel;
import android.hardware.SensorManager;
import android.os.Bundle;

import com.android.compatibility.common.deviceinfo.DeviceInfo;
import com.android.compatibility.common.util.DeviceInfoStore;

import java.lang.Exception;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.List;

/**
 * Sensor device info collector.
 */
public class SensorDeviceInfo extends DeviceInfo {

    private static final String SENSOR = ""sensor"";
    private static final String REPORTING_MODE = ""reporting_mode"";
    private static final String NAME = ""name"";
    private static final String VENDOR = ""vendor"";
    private static final String TYPE = ""type"";
    private static final String VERSION = ""version"";
    private static final String MAXIMUM_RANGE = ""maximum_range"";
    private static final String RESOLUTION = ""resolution"";
    private static final String POWER = ""power"";
    private static final String MIN_DELAY = ""min_delay"";
    private static final String FIFO_RESERVED_EVENT_COUNT =
            ""fifo_reserved_event_count"";
    private static final String FIFO_MAX_EVENT_COUNT = ""fifo_max_event_count"";
    private static final String STRING_TYPE = ""string_type"";
    private static final String ID = ""id"";
    private static final String MAX_DELAY = ""max_delay"";
    private static final String IS_WAKE_UP_SENSOR = ""is_wake_up_sensor"";
    private static final String IS_DYNAMIC_SENSOR = ""is_dynamic_sensor"";
    private static final String IS_ADDITONAL_INFO_SUPPORTED =
            ""is_additional_info_supported"";
    private static final String HIGHEST_DIRECT_REPORT_RATE_LEVEL =
            ""highest_direct_report_rate_level"";
    private static final String SUPPORTED_DIRECT_CHANNEL_TYPE =
            ""supported_direct_channel_type"";
    private static final int[] CHANNEL_TYPES = new int[] {
            SensorDirectChannel.TYPE_MEMORY_FILE,
            SensorDirectChannel.TYPE_HARDWARE_BUFFER };

    @Override
    protected void collectDeviceInfo(DeviceInfoStore store) throws Exception {
        SensorManager sensorManager = (SensorManager)
                getContext().getSystemService(Context.SENSOR_SERVICE);
        List<Sensor> sensors = sensorManager.getSensorList(Sensor.TYPE_ALL);
        store.startArray(SENSOR);
        for (Sensor sensor : sensors) {
            store.startGroup();
            store.addResult(REPORTING_MODE, sensor.getReportingMode());
            store.addResult(NAME, sensor.getName());
            store.addResult(VENDOR, sensor.getVendor());
            store.addResult(TYPE, sensor.getType());
            store.addResult(VERSION, sensor.getVersion());
            store.addResult(MAXIMUM_RANGE, sensor.getMaximumRange());
            store.addResult(RESOLUTION, sensor.getResolution());
            store.addResult(POWER, sensor.getPower());
            store.addResult(MIN_DELAY, sensor.getMinDelay());
            store.addResult(FIFO_RESERVED_EVENT_COUNT,
                    sensor.getFifoReservedEventCount());
            store.addResult(FIFO_MAX_EVENT_COUNT,
                    sensor.getFifoMaxEventCount());
            store.addResult(STRING_TYPE, sensor.getStringType());
            store.addResult(ID, sensor.getId());
            store.addResult(MAX_DELAY, sensor.getMaxDelay());
            store.addResult(IS_WAKE_UP_SENSOR, sensor.isWakeUpSensor());
            store.addResult(IS_DYNAMIC_SENSOR, sensor.isDynamicSensor());
            store.addResult(IS_ADDITONAL_INFO_SUPPORTED,
                    sensor.isAdditionalInfoSupported());
            store.addResult(HIGHEST_DIRECT_REPORT_RATE_LEVEL,
                    sensor.getHighestDirectReportRateLevel());

            List<Integer> supportedChannelType = new ArrayList<>();
            for (int channelType : CHANNEL_TYPES) {
                if (sensor.isDirectChannelTypeSupported(channelType)) {
                    supportedChannelType.add(channelType);
                }
            }
            store.addArrayResult(SUPPORTED_DIRECT_CHANNEL_TYPE,
                    supportedChannelType.stream().mapToInt(i->i).toArray());
            store.endGroup();
        }
        store.endArray(); // Sensor
    }
}"	"/home/gpoor/cts-12-source/cts/tools/cts-device-info/src/com/android/cts/deviceinfo/SensorDeviceInfo.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.deviceowner.UserControlDisabledPackagesTest"	"testSetUserControlDisabledPackages"	""	"1: user"	"public void testSetUserControlDisabledPackages() throws Exception {
        ArrayList<String> protectedPackages = new ArrayList<>();
        protectedPackages.add(SIMPLE_APP_PKG);
        mDevicePolicyManager.setUserControlDisabledPackages(getWho(), protectedPackages);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/UserControlDisabledPackagesTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.deviceowner.UserControlDisabledPackagesTest"	"testLaunchActivity"	""	"1: user"	"public void testLaunchActivity() throws Exception {
        // Launch an activity so that the app exits stopped state.
        Intent intent = new Intent(Intent.ACTION_MAIN);
        intent.setClassName(SIMPLE_APP_PKG, SIMPLE_APP_ACTIVITY);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        Log.d(TAG, ""Starting "" + intent + "" on user "" + getCurrentUser().getIdentifier());
        mContext.startActivityAsUser(intent, getCurrentUser());
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/UserControlDisabledPackagesTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.deviceowner.UserControlDisabledPackagesTest"	"testForceStopWithUserControlDisabled"	""	"1: user"	"public void testForceStopWithUserControlDisabled() throws Exception {
        final ArrayList<String> pkgs = new ArrayList<>();
        pkgs.add(SIMPLE_APP_PKG);
        // Check if package is part of UserControlDisabledPackages before checking if
        // package is stopped since it is a necessary condition to prevent stopping of
        // package

        assertThat(mDevicePolicyManager.getUserControlDisabledPackages(getWho()))
                .containsExactly(SIMPLE_APP_PKG);
        assertPackageStopped(/* stopped= */ false);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/UserControlDisabledPackagesTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.deviceowner.UserControlDisabledPackagesTest"	"testClearSetUserControlDisabledPackages"	""	"1: user"	"public void testClearSetUserControlDisabledPackages() throws Exception {
        final ArrayList<String> pkgs = new ArrayList<>();
        mDevicePolicyManager.setUserControlDisabledPackages(getWho(), pkgs);
        assertThat(mDevicePolicyManager.getUserControlDisabledPackages(getWho())).isEmpty();
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/UserControlDisabledPackagesTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.deviceowner.UserControlDisabledPackagesTest"	"testForceStopWithUserControlEnabled"	""	"1: user"	"public void testForceStopWithUserControlEnabled() throws Exception {
        assertPackageStopped(/* stopped= */ true);
        assertThat(mDevicePolicyManager.getUserControlDisabledPackages(getWho())).isEmpty();
    }

    private boolean isPackageStopped(String packageName) throws Exception {
        PackageInfo packageInfo = mContext.getPackageManager()
                .getPackageInfoAsUser(packageName, PackageManager.GET_META_DATA,
                        getCurrentUser().getIdentifier());
        boolean stopped = (packageInfo.applicationInfo.flags & ApplicationInfo.FLAG_STOPPED)
                == ApplicationInfo.FLAG_STOPPED;
        Log.d(TAG, ""Application flags for "" + packageName + "" on user ""
                + getCurrentUser().getIdentifier() + "" = ""
                + Integer.toHexString(packageInfo.applicationInfo.flags) + "". Stopped: "" + stopped);
        return stopped;
    }

    private void assertPackageStopped(boolean stopped) throws Exception {
        assertWithMessage(""Package %s stopped for user %s"", SIMPLE_APP_PKG,
                getCurrentUser().getIdentifier())
                .that(isPackageStopped(SIMPLE_APP_PKG)).isEqualTo(stopped);
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceOwner/src/com/android/cts/deviceowner/UserControlDisabledPackagesTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.verifier.nfc.hcef.HceFReaderActivity"	"setPassFailButtonClickListeners"	""	"2: ui system"	"public void test/*
 *.
 */
package com.android.cts.verifier.nfc.hcef;

import android.annotation.TargetApi;
import android.nfc.NfcAdapter;
import android.nfc.NfcAdapter.ReaderCallback;
import android.nfc.Tag;
import android.nfc.tech.NfcF;
import android.os.Bundle;
import android.util.Log;
import android.view.View;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemSelectedListener;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import java.io.IOException;

@TargetApi(24)
public class HceFReaderActivity extends PassFailButtons.Activity implements ReaderCallback,
        OnItemSelectedListener {
    public static final String TAG = ""HceFReaderActivity"";

    NfcAdapter mAdapter;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.pass_fail_text);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);

        mAdapter = NfcAdapter.getDefaultAdapter(this);
    }

    @Override
    protected void onResume() {
        super.onResume();
        mAdapter.enableReaderMode(this, this, NfcAdapter.FLAG_READER_NFC_F |
                NfcAdapter.FLAG_READER_SKIP_NDEF_CHECK, null);
    }

    static byte[] createEchoCommand(byte[] nfcid2, byte[] payload) {
        byte length = (byte) (2 + nfcid2.length + payload.length);

        byte[] echo_cmd = new byte[length];
        echo_cmd[0] = length;
        echo_cmd[1] = MyHostFelicaService.CMD_ECHO;
        System.arraycopy(nfcid2, 0, echo_cmd, 2, nfcid2.length);
        System.arraycopy(payload, 0, echo_cmd, 2 + nfcid2.length, payload.length);
        return echo_cmd;
    }

    static byte[] createSuccessCommand(byte[] nfcid2) {
        byte[] cmd = new byte[2 + nfcid2.length];
        cmd[0] = (byte) (2 + nfcid2.length);
        cmd[1] = MyHostFelicaService.CMD_SUCCESS;
        System.arraycopy(nfcid2, 0, cmd, 2, nfcid2.length);
        return cmd;
    }

    static boolean verifyResponse(byte[] cmd, byte[] resp) {
        if (resp == null) return false;

        // Verify length
        if (resp[0] != resp.length) return false;
        if (resp.length != cmd.length) return false;
        // Verify cmd
        if (resp[1] != MyHostFelicaService.RESPONSE_ECHO) return false;

        // Verify rest of data
        for (int i = 2; i < resp.length; i++) {
            if (resp[i] != cmd[i]) return false;
        }

        return true;
    }

    @Override
    public void onTagDiscovered(Tag tag) {
        NfcF felica = NfcF.get(tag);
        if (felica == null) return;

        try {
            felica.connect();
     byte[] command =
      new byte[]{6, 0x00, (byte)0x40, (byte)0x01, 0x00, 0x00}; // in this case, SC of HCE-F is 4001h
     felica.transceive(command);
            for (int i = 0; i < 32; i++) {
                byte[] payload = new byte[] {0x14, (byte)i};
                byte[] echo_cmd = createEchoCommand(MyHostFelicaService.NFCID2, payload);
                byte[] resp = felica.transceive(echo_cmd);
                if (!verifyResponse(echo_cmd, resp)) {
                    Log.e(TAG, ""Echo response not correct."");
                    return;
                }
            }
            // All successful, send success cmd
            byte[] success_cmd = createSuccessCommand(MyHostFelicaService.NFCID2);
            felica.transceive(success_cmd);

            runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    getPassButton().setEnabled(true);
                }
            });
        } catch (IOException e) {
            Log.e(TAG, ""IOException, try again."");
        }
    }

    @Override
    public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {

    }

    @Override
    public void onNothingSelected(AdapterView<?> parent) {

    }
}"	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hcef/HceFReaderActivity.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.location.cts.gnss.asn1.supl2.rrlp_components.ReferenceIdentity"	"isTagImplicit"	"CtsLocationGnssTestCases"	"1: ui"	"public void test/*
 *.
 */

package android.location.cts.asn1.supl2.rrlp_components;

/*
 */


//
//
import android.location.cts.asn1.base.Asn1Null;
import android.location.cts.asn1.base.Asn1Object;
import android.location.cts.asn1.base.Asn1Sequence;
import android.location.cts.asn1.base.Asn1Tag;
import android.location.cts.asn1.base.BitStream;
import android.location.cts.asn1.base.BitStreamReader;
import android.location.cts.asn1.base.SequenceComponent;
import com.google.common.collect.ImmutableList;
import java.util.Collection;
import javax.annotation.Nullable;


/**
*/
public  class ReferenceIdentity extends Asn1Sequence {
  //

  private static final Asn1Tag TAG_ReferenceIdentity
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public ReferenceIdentity() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_ReferenceIdentity;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_ReferenceIdentity != null) {
      return ImmutableList.of(TAG_ReferenceIdentity);
    } else {
      return Asn1Sequence.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new ReferenceIdentity from encoded stream.
   */
  public static ReferenceIdentity fromPerUnaligned(byte[] encodedBytes) {
    ReferenceIdentity result = new ReferenceIdentity();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new ReferenceIdentity from encoded stream.
   */
  public static ReferenceIdentity fromPerAligned(byte[] encodedBytes) {
    ReferenceIdentity result = new ReferenceIdentity();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }



  @Override protected boolean isExtensible() {
    return false;
  }

  @Override public boolean containsExtensionValues() {
    for (SequenceComponent extensionComponent : getExtensionComponents()) {
      if (extensionComponent.isExplicitlySet()) return true;
    }
    return false;
  }

  
  private SeqOfReferenceIdentityType refBTSList_;
  public SeqOfReferenceIdentityType getRefBTSList() {
    return refBTSList_;
  }
  /**
   * @throws ClassCastException if value is not a SeqOfReferenceIdentityType
   */
  public void setRefBTSList(Asn1Object value) {
    this.refBTSList_ = (SeqOfReferenceIdentityType) value;
  }
  public SeqOfReferenceIdentityType setRefBTSListToNewInstance() {
    refBTSList_ = new SeqOfReferenceIdentityType();
    return refBTSList_;
  }
  

  

  

  @Override public Iterable<? extends SequenceComponent> getComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 0);

          @Override public boolean isExplicitlySet() {
            return getRefBTSList() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getRefBTSList();
          }

          @Override public void setToNewInstance() {
            setRefBTSListToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SeqOfReferenceIdentityType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""refBTSList : ""
                    + getRefBTSList().toIndentedString(indent);
              }
        });
    
    return builder.build();
  }

  @Override public Iterable<? extends SequenceComponent>
                                                    getExtensionComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
      
      return builder.build();
    }

  
  
  

    

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    StringBuilder builder = new StringBuilder();
    builder.append(""ReferenceIdentity = {\n"");
    final String internalIndent = indent + ""  "";
    for (SequenceComponent component : getComponents()) {
      if (component.isExplicitlySet()) {
        builder.append(internalIndent)
            .append(component.toIndentedString(internalIndent));
      }
    }
    if (isExtensible()) {
      builder.append(internalIndent).append(""...\n"");
      for (SequenceComponent component : getExtensionComponents()) {
        if (component.isExplicitlySet()) {
          builder.append(internalIndent)
              .append(component.toIndentedString(internalIndent));
        }
      }
    }
    builder.append(indent).append(""};\n"");
    return builder.toString();
  }
}"	"/home/gpoor/cts-12-source/cts/tests/location/location_gnss/src/android/location/cts/gnss/asn1/supl2/rrlp_components/ReferenceIdentity.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.apicoverage.CtsApiCoverage"	"isDirectory"	""	"3: direct ui system"	"public void test/*
 *.
 */

package com.android.cts.apicoverage;

import com.android.compatibility.common.util.CddTest;
import com.android.compatibility.common.util.ReadElf;

import org.jf.dexlib2.DexFileFactory;
import org.jf.dexlib2.Opcodes;
import org.jf.dexlib2.iface.Annotation;
import org.jf.dexlib2.iface.AnnotationElement;
import org.jf.dexlib2.iface.ClassDef;
import org.jf.dexlib2.iface.DexFile;
import org.jf.dexlib2.iface.Method;
import org.jf.dexlib2.iface.value.StringEncodedValue;

import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;

import java.io.File;
import java.io.FilenameFilter;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStream;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Locale;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import javax.xml.transform.TransformerException;

/**
 * Tool that generates a report of what Android framework methods are being called from a given
 * set of APKS. See the {@link #printUsage()} method for more details.
 */
public class CtsApiCoverage {

    private static final FilenameFilter SUPPORTED_FILE_NAME_FILTER = new FilenameFilter() {
        public boolean accept(File dir, String name) {
            String fileName = name.toLowerCase();
            return fileName.endsWith("".apk"") || fileName.endsWith("".jar"");
        }
    };

    private static final int FORMAT_TXT = 0;

    private static final int FORMAT_XML = 1;

    private static final int FORMAT_HTML = 2;

    private static final String CDD_REQUIREMENT_ANNOTATION = ""Lcom/android/compatibility/common/util/CddTest;"";

    private static final String CDD_REQUIREMENT_ELEMENT_NAME = ""requirement"";

    private static final String NDK_PACKAGE_NAME = ""ndk"";

    private static void printUsage() {
        System.out.println(""Usage: cts-api-coverage [OPTION]... [APK]..."");
        System.out.println();
        System.out.println(""Generates a report about what Android framework methods are called "");
        System.out.println(""from the given APKs."");
        System.out.println();
        System.out.println(""Use the Makefiles rules in CtsCoverage.mk to generate the report "");
        System.out.println(""rather than executing this directly. If you still want to run this "");
        System.out.println(""directly, then this must be used from the $ANDROID_BUILD_TOP "");
        System.out.println(""directory and dexdeps must be built via \""make dexdeps\""."");
        System.out.println();
        System.out.println(""Options:"");
        System.out.println(""  -o FILE                output file or standard out if not given"");
        System.out.println(""  -f [txt|xml|html]      format of output"");
        System.out.println(""  -d PATH                path to dexdeps or expected to be in $PATH"");
        System.out.println(""  -a PATH                path to the API XML file"");
        System.out.println(
                ""  -n PATH                path to the NDK API XML file, which can be updated via ndk-api-report with the ndk target"");
        System.out.println(""  -p PACKAGENAMEPREFIX   report coverage only for package that start with"");
        System.out.println(""  -t TITLE               report title"");
        System.out.println(""  -a API                 the Android API Level"");
        System.out.println(""  -b BITS                64 or 32 bits, default 64"");
        System.out.println();
        System.exit(1);
    }

    public static void main(String[] args) throws Exception {
        List<File> testApks = new ArrayList<File>();
        File outputFile = null;
        int format = FORMAT_TXT;
        String dexDeps = ""dexDeps"";
        String apiXmlPath = """";
        String napiXmlPath = """";
        PackageFilter packageFilter = new PackageFilter();
        String reportTitle = ""CTS API Coverage"";
        int apiLevel = Integer.MAX_VALUE;
        String testCasesFolder = """";
        String bits = ""64"";

        List<File> notFoundTestApks = new ArrayList<File>();
        int numTestApkArgs = 0;
        for (int i = 0; i < args.length; i++) {
            if (args[i].startsWith(""-"")) {
                if (""-o"".equals(args[i])) {
                    outputFile = new File(getExpectedArg(args, ++i));
                } else if (""-f"".equals(args[i])) {
                    String formatSpec = getExpectedArg(args, ++i);
                    if (""xml"".equalsIgnoreCase(formatSpec)) {
                        format = FORMAT_XML;
                    } else if (""txt"".equalsIgnoreCase(formatSpec)) {
                        format = FORMAT_TXT;
                    } else if (""html"".equalsIgnoreCase(formatSpec)) {
                        format = FORMAT_HTML;
                    } else {
                        printUsage();
                    }
                } else if (""-d"".equals(args[i])) {
                    dexDeps = getExpectedArg(args, ++i);
                } else if (""-a"".equals(args[i])) {
                    apiXmlPath = getExpectedArg(args, ++i);
                } else if (""-n"".equals(args[i])) {
                    napiXmlPath = getExpectedArg(args, ++i);
                } else if (""-p"".equals(args[i])) {
                    packageFilter.addPrefixToFilter(getExpectedArg(args, ++i));
                } else if (""-t"".equals(args[i])) {
                    reportTitle = getExpectedArg(args, ++i);
                } else if (""-a"".equals(args[i])) {
                    apiLevel = Integer.parseInt(getExpectedArg(args, ++i));
                } else if (""-b"".equals(args[i])) {
                    bits = getExpectedArg(args, ++i);
                } else {
                    printUsage();
                }
            } else {
                File file = new File(args[i]);
                numTestApkArgs++;
                if (file.isDirectory()) {
                    testApks.addAll(Arrays.asList(file.listFiles(SUPPORTED_FILE_NAME_FILTER)));
                    testCasesFolder = args[i];
                } else if (file.isFile()) {
                    testApks.add(file);
                } else {
                    notFoundTestApks.add(file);
                }
            }
        }

        if (!notFoundTestApks.isEmpty()) {
            String msg = String.format(Locale.US, ""%d/%d testApks not found: %s"",
                    notFoundTestApks.size(), numTestApkArgs, notFoundTestApks);
            throw new IllegalArgumentException(msg);
        }

        /*
         * 1. Create an ApiCoverage object that is a tree of Java objects representing the API
         *    in current.xml. The object will have no information about the coverage for each
         *    constructor or method yet.
         *
         * 2. For each provided APK, scan it using dexdeps, parse the output of dexdeps, and
         *    call methods on the ApiCoverage object to cumulatively add coverage stats.
         *
         * 3. Output a report based on the coverage stats in the ApiCoverage object.
         */

        ApiCoverage apiCoverage = getEmptyApiCoverage(apiXmlPath);
        CddCoverage cddCoverage = getEmptyCddCoverage();

        if (!napiXmlPath.equals("""")) {
            System.out.println(""napiXmlPath: "" + napiXmlPath);
            ApiCoverage napiCoverage = getEmptyApiCoverage(napiXmlPath);
            ApiPackage napiPackage = napiCoverage.getPackage(NDK_PACKAGE_NAME);
            System.out.println(
                    String.format(
                            ""%s, NDK Methods = %d, MemberSize = %d"",
                            napiXmlPath,
                            napiPackage.getTotalMethods(),
                            napiPackage.getMemberSize()));
            apiCoverage.addPackage(napiPackage);
        }

        // Add superclass information into api coverage.
        apiCoverage.resolveSuperClasses();

        ExecutorService service =
            Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
        List<Future> tasks = new ArrayList<>();
        for (File testApk : testApks) {
            tasks.add(addApiCoverage(service, apiCoverage, testApk, dexDeps));
            tasks.add(addCddCoverage(service, cddCoverage, testApk, apiLevel));
        }
        // Wait until all tasks finish.
        for (Future task : tasks) {
            task.get();
        }
        service.shutdown();

        // The below two coverage methods assume all classes and methods have been already
        // registered, which is why we don't run them parallelly with others.

        try {
            // Add coverage for GTest modules
            addGTestNdkApiCoverage(apiCoverage, testCasesFolder, bits);
        } catch (Exception e) {
            System.out.println(""warning: addGTestNdkApiCoverage failed to add to apiCoverage:"");
            e.printStackTrace();
        }

        try {
            // Add coverage for APK with Share Objects
            addNdkApiCoverage(apiCoverage, testCasesFolder, bits);
        } catch (Exception e) {
            System.out.println(""warning: addNdkApiCoverage failed to add to apiCoverage:"");
            e.printStackTrace();
        }

        outputCoverageReport(apiCoverage, cddCoverage, testApks, outputFile,
            format, packageFilter, reportTitle);
    }

    /** Get the argument or print out the usage and exit. */
    private static String getExpectedArg(String[] args, int index) {
        if (index < args.length) {
            return args[index];
        } else {
            printUsage();
            return null;    // Never will happen because printUsage will call exit(1)
        }
    }

    /**
     * Creates an object representing the API that will be used later to collect coverage
     * statistics as we iterate over the test APKs.
     *
     * @param apiXmlPath to the API XML file
     * @return an {@link ApiCoverage} object representing the API in current.xml without any
     *     coverage statistics yet
     */
    private static ApiCoverage getEmptyApiCoverage(String apiXmlPath)
            throws SAXException, IOException {
        XMLReader xmlReader = XMLReaderFactory.createXMLReader();
        CurrentXmlHandler currentXmlHandler = new CurrentXmlHandler();
        xmlReader.setContentHandler(currentXmlHandler);

        File currentXml = new File(apiXmlPath);
        FileReader fileReader = null;
        try {
            fileReader = new FileReader(currentXml);
            xmlReader.parse(new InputSource(fileReader));
        } finally {
            if (fileReader != null) {
                fileReader.close();
            }
        }

        return currentXmlHandler.getApi();
    }

    /**
     * Adds coverage information gleamed from running dexdeps on the APK to the
     * {@link ApiCoverage} object.
     *
     * @param apiCoverage object to which the coverage statistics will be added to
     * @param testApk containing the tests that will be scanned by dexdeps
     */
    private static Future addApiCoverage(
        ExecutorService service, ApiCoverage apiCoverage, File testApk, String dexdeps) {
        return service.submit(() -> {
            String apkPath = testApk.getPath();
            try {
                XMLReader xmlReader = XMLReaderFactory.createXMLReader();
                String testApkName = testApk.getName();
                DexDepsXmlHandler dexDepsXmlHandler = new DexDepsXmlHandler(apiCoverage, testApkName);
                xmlReader.setContentHandler(dexDepsXmlHandler);

                Process process = new ProcessBuilder(dexdeps, ""--format=xml"", apkPath).start();
                xmlReader.parse(new InputSource(process.getInputStream()));
            } catch (SAXException e) {
                // Catch this exception, but continue. SAXException is acceptable in cases
                // where the apk does not contain a classes.dex and therefore parsing won't work.
                System.err.println(""warning: dexdeps failed for: "" + apkPath);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        });
    }

    /**
     * Adds coverage information from native code symbol array to the {@link ApiCoverage} object.
     *
     * @param apiPackage object to which the coverage statistics will be added to
     * @param symArr containing native code symbols
     * @param testModules containing a list of TestModule
     * @param moduleName test module name
     */
    private static void addNdkSymArrToApiCoverage(
            ApiCoverage apiCoverage, List<TestModule> testModules)
            throws SAXException, IOException {

        final List<String> parameterTypes = new ArrayList<String>();
        final ApiPackage apiPackage = apiCoverage.getPackage(NDK_PACKAGE_NAME);

        if (apiPackage != null) {
            for (TestModule tm : testModules) {
                final String moduleName = tm.getModuleName();
                final ReadElf.Symbol[] symArr = tm.getDynSymArr();
                if (symArr != null) {
                    for (ReadElf.Symbol sym : symArr) {
                        if (sym.isGlobalUnd()) {
                            String className = sym.getExternalLibFileName();
                            ApiClass apiClass = apiPackage.getClass(className);
                            if (apiClass != null) {
                                apiClass.markMethodCovered(
                                        sym.name,
                                        parameterTypes,
                                        moduleName);
                            } else {
                                System.err.println(
                                        String.format(
                                                ""warning: addNdkApiCoverage failed to getClass: %s"",
                                                className));
                            }
                        }
                    }
                } else {
                    System.err.println(
                            String.format(
                                    ""warning: addNdkSymbolArrToApiCoverage failed to getSymArr: %s"",
                                    moduleName));
                }
            }
        } else {
            System.err.println(
                    String.format(
                            ""warning: addNdkApiCoverage failed to getPackage: %s"",
                            NDK_PACKAGE_NAME));
        }
    }

    /**
     * Adds coverage information gleamed from readelf on so in the APK to the {@link ApiCoverage}
     * object.
     *
     * @param apiCoverage object to which the coverage statistics will be added to
     * @param testCasesFolder containing GTest modules
     * @param bits 64 or 32 bits of executiable
     */
    private static void addNdkApiCoverage(
            ApiCoverage apiCoverage, String testCasesFolder, String bits)
            throws SAXException, IOException {
        ApkNdkApiReport apiReport = ApkNdkApiReport.parseTestcasesFolder(testCasesFolder, bits);
        if (apiReport != null) {
            addNdkSymArrToApiCoverage(apiCoverage, apiReport.getTestModules());
        } else {
            System.err.println(
                    String.format(
                            ""warning: addNdkApiCoverage failed to get GTestApiReport from: %s @ %s bits"",
                            testCasesFolder, bits));
        }
    }

    /**
     * Adds GTest coverage information gleamed from running ReadElf on the executiable to the {@link
     * ApiCoverage} object.
     *
     * @param apiCoverage object to which the coverage statistics will be added to
     * @param testCasesFolder containing GTest modules
     * @param bits 64 or 32 bits of executiable
     */
    private static void addGTestNdkApiCoverage(
            ApiCoverage apiCoverage, String testCasesFolder, String bits)
            throws SAXException, IOException {
        GTestApiReport apiReport = GTestApiReport.parseTestcasesFolder(testCasesFolder, bits);
        if (apiReport != null) {
            addNdkSymArrToApiCoverage(apiCoverage, apiReport.getTestModules());
        } else {
            System.err.println(
                    String.format(
                            ""warning: addGTestNdkApiCoverage failed to get GTestApiReport from: %s @ %s bits"",
                            testCasesFolder, bits));
        }
    }

    private static Future addCddCoverage(
        ExecutorService service, CddCoverage cddCoverage, File testSource, int api) {
        return service.submit(() -> {
            try {
                if (testSource.getName().endsWith("".apk"")) {
                    addCddApkCoverage(cddCoverage, testSource, api);
                } else if (testSource.getName().endsWith("".jar"")) {
                    addCddJarCoverage(cddCoverage, testSource);
                } else {
                    System.err
                        .println(""Unsupported file type for CDD coverage: "" + testSource.getPath());
                }
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        });
    }

    private static void addCddJarCoverage(CddCoverage cddCoverage, File testSource)
            throws IOException {

        Collection<Class<?>> classes = JarTestFinder.getClasses(testSource);
        for (Class<?> c : classes) {
            for (java.lang.reflect.Method m : c.getMethods()) {
                if (m.isAnnotationPresent(CddTest.class)) {
                    CddTest cddTest = m.getAnnotation(CddTest.class);
                    CddCoverage.TestMethod testMethod =
                            new CddCoverage.TestMethod(
                                    testSource.getName(), c.getName(), m.getName());
                    cddCoverage.addCoverage(cddTest.requirement(), testMethod);
                }
            }
        }
    }

    private static void addCddApkCoverage(
        CddCoverage cddCoverage, File testSource, int api)
            throws IOException {

        DexFile dexFile = null;
        try {
            dexFile = DexFileFactory.loadDexFile(testSource, Opcodes.forApi(api));
        } catch (IOException | DexFileFactory.DexFileNotFoundException e) {
            System.err.println(""Unable to load dex file: "" + testSource.getPath());
            return;
        }

        String moduleName = testSource.getName();
        for (ClassDef classDef : dexFile.getClasses()) {
            String className = classDef.getType();
            handleAnnotations(
                cddCoverage, moduleName, className, null /*methodName*/,
                classDef.getAnnotations());

            for (Method method : classDef.getMethods()) {
                String methodName = method.getName();
                handleAnnotations(
                    cddCoverage, moduleName, className, methodName, method.getAnnotations());
            }
        }
    }

    private static void handleAnnotations(
            CddCoverage cddCoverage, String moduleName, String className,
                    String methodName, Set<? extends Annotation> annotations) {
        for (Annotation annotation : annotations) {
            if (annotation.getType().equals(CDD_REQUIREMENT_ANNOTATION)) {
                for (AnnotationElement annotationElement : annotation.getElements()) {
                    if (annotationElement.getName().equals(CDD_REQUIREMENT_ELEMENT_NAME)) {
                        String cddRequirement =
                                ((StringEncodedValue) annotationElement.getValue()).getValue();
                        CddCoverage.TestMethod testMethod =
                                new CddCoverage.TestMethod(
                                        moduleName, dexToJavaName(className), methodName);
                        cddCoverage.addCoverage(cddRequirement, testMethod);
                    }
                }
            }
        }
    }

    /**
     * Given a string like Landroid/app/cts/DownloadManagerTest;
     * return android.app.cts.DownloadManagerTest.
     */
    private static String dexToJavaName(String dexName) {
        if (!dexName.startsWith(""L"") || !dexName.endsWith("";"")) {
            return dexName;
        }
        dexName = dexName.replace('/', '.');
        if (dexName.length() > 2) {
            dexName = dexName.substring(1, dexName.length() - 1);
        }
        return dexName;
    }

    private static CddCoverage getEmptyCddCoverage() {
        CddCoverage cddCoverage = new CddCoverage();
        // TODO(nicksauer): Read in the valid list of requirements
        return cddCoverage;
    }

    private static void outputCoverageReport(ApiCoverage apiCoverage, CddCoverage cddCoverage,
            List<File> testApks, File outputFile, int format, PackageFilter packageFilter,
            String reportTitle)
                throws IOException, TransformerException, InterruptedException {

        OutputStream out = outputFile != null
                ? new FileOutputStream(outputFile)
                : System.out;

        try {
            switch (format) {
                case FORMAT_TXT:
                    TextReport.printTextReport(apiCoverage, cddCoverage, packageFilter, out);
                    break;

                case FORMAT_XML:
                    XmlReport.printXmlReport(testApks, apiCoverage, cddCoverage,
                        packageFilter, reportTitle, out);
                    break;

                case FORMAT_HTML:
                    HtmlReport.printHtmlReport(testApks, apiCoverage, cddCoverage,
                        packageFilter, reportTitle, out);
                    break;
            }
        } finally {
            out.close();
        }
    }
}"	"/home/gpoor/cts-12-source/cts/tools/cts-api-coverage/src/com/android/cts/apicoverage/CtsApiCoverage.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.server.biometrics.BiometricSecurityTests"	"testBiometricStrength_ConvenienceSensor"	"CtsBiometricsTestCases"	"2: ui user"	"public void testBiometricStrength_ConvenienceSensor() throws Exception {
        final List<Integer> sensors =
                getSensorsOfTargetStrength(SensorProperties.STRENGTH_CONVENIENCE);
        assumeTrue(""testBiometricStrength_ConvenienceSensor: numSensors="" + sensors.size(),
                sensors.size() > 0);

        // Tuple of originalStrength and requestedStrength
        final int[][] testCases = {
                // Request Strong auth
                {Authenticators.BIOMETRIC_CONVENIENCE, Authenticators.BIOMETRIC_STRONG},

                // Request Weak auth
                {Authenticators.BIOMETRIC_CONVENIENCE, Authenticators.BIOMETRIC_WEAK}
        };

        for (Integer sensorId : sensors) {
            for (int i = 0; i < testCases.length; i++) {
                testBiometricStrength_forSensor_authDisallowed(sensorId,
                        testCases[i][0] /* originalStrength */,
                        testCases[i][1] /* requestedStrength */,
                        sensors.size() > 1 /* hasMultiSensors */);
            }
        }
    }

    private void testBiometricStrength_forSensor_authAllowed(int sensorId, int originalStrength,
            int requestedStrength) throws Exception {
        Log.d(TAG, ""testBiometricStrength_forSensor_authAllowed: ""
                + "", sensorId="" + sensorId
                + "", originalStrength="" + originalStrength
                + "", requestedStrength="" + requestedStrength);

        final ComponentName componentName = getComponentName(requestedStrength);

        // Reset to the original strength in case it's ever changed before the test
        updateStrengthAndVerify(sensorId, originalStrength);

        try (BiometricTestSession session = mBiometricManager.createTestSession(sensorId);
             ActivitySession activitySession = new ActivitySession(this, componentName)) {
            final int userId = 0;
            waitForAllUnenrolled();
            enrollForSensor(session, sensorId);
            final TestJournal journal =
                    TestJournalContainer.get(activitySession.getComponentName());

            // No error code should be returned for the requested strength
            int errCode = mBiometricManager.canAuthenticate(requestedStrength);
            assertEquals(""Device should allow auth with the requested biometric"",
                    BiometricManager.BIOMETRIC_SUCCESS, errCode);

            // Launch test activity
            launchActivityAndWaitForResumed(activitySession);

            BiometricCallbackHelper.State callbackState = getCallbackState(journal);
            assertNotNull(callbackState);

            BiometricServiceState state = getCurrentState();
            assertTrue(state.toString(), state.mSensorStates.sensorStates.get(sensorId).isBusy());

            // Auth should work
            successfullyAuthenticate(session, userId);
            mInstrumentation.waitForIdleSync();
            callbackState = getCallbackState(journal);
            assertNotNull(callbackState);
            assertEquals(callbackState.toString(), 0, callbackState.mNumAuthRejected);
            assertEquals(callbackState.toString(), 1, callbackState.mNumAuthAccepted);
            assertEquals(callbackState.toString(), 0, callbackState.mAcquiredReceived.size());
            assertEquals(callbackState.toString(), 0, callbackState.mErrorsReceived.size());
        }
    }

    private void testBiometricStrength_forSensor_authDisallowed(int sensorId, int originalStrength,
            int requestedStrength, boolean hasMultiSensors) throws Exception {
        Log.d(TAG, ""testBiometricStrength_forSensor_authDisallowed: ""
                + "", sensorId="" + sensorId
                + "", originalStrength="" + originalStrength
                + "", requestedStrength="" + requestedStrength
                + "", hasMultiSensors="" + hasMultiSensors);

        final ComponentName componentName = getComponentName(requestedStrength);

        // Reset to the original strength in case it's ever changed before the test
        updateStrengthAndVerify(sensorId, originalStrength);

        try (BiometricTestSession session = mBiometricManager.createTestSession(sensorId);
             ActivitySession activitySession = new ActivitySession(this, componentName)) {
            waitForAllUnenrolled();
            enrollForSensor(session, sensorId);
            final TestJournal journal =
                    TestJournalContainer.get(activitySession.getComponentName());

            // Error code should be returned for the requested strength due to insufficient strength
            int errCode = mBiometricManager.canAuthenticate(requestedStrength);
            checkErrCode(""Device shouldn't allow auth with biometrics that have insufficient""
                            + "" strength. errCode: "" + errCode,
                    errCode, BiometricManager.BIOMETRIC_ERROR_NO_HARDWARE,
                    hasMultiSensors);

            // Launch test activity
            launchActivityAndWaitForResumed(activitySession);

            // Auth shouldn't work and error code should be returned
            mInstrumentation.waitForIdleSync();
            BiometricCallbackHelper.State callbackState = getCallbackState(journal);
            assertNotNull(callbackState);
            assertEquals(callbackState.toString(), 0, callbackState.mNumAuthRejected);
            assertEquals(callbackState.toString(), 0, callbackState.mNumAuthAccepted);
            assertEquals(callbackState.toString(), 0, callbackState.mAcquiredReceived.size());
            assertEquals(callbackState.toString(), 1, callbackState.mErrorsReceived.size());
            checkErrCode(callbackState.toString(), (int) callbackState.mErrorsReceived.get(0),
                    BiometricManager.BIOMETRIC_ERROR_NO_HARDWARE, hasMultiSensors);
        }
    }

    /**
     * The strength of a Strong biometric may need to be downgraded to a weaker one if the biometric
     * requires a security update. After downgrading, the biometric may or may not be able to
     * perform auth with the requested strength. For example,
     * +-------------------+-----------------------+--------------------+----------+
     * | Original Strength | Target Strength       | Requested Strength | Result   |
     * +-------------------+-----------------------+--------------------+----------+
     * | BIOMETRIC_STRONG  | BIOMETRIC_WEAK        | BIOMETRIC_STRONG   | Error    |
     * +-------------------+-----------------------+--------------------+----------+
     * | BIOMETRIC_STRONG  | BIOMETRIC_WEAK        | BIOMETRIC_WEAK     | Accepted |
     * +-------------------+-----------------------+--------------------+----------+
     * | BIOMETRIC_STRONG  | BIOMETRIC_CONVENIENCE | BIOMETRIC_STRONG   | Error    |
     * +-------------------+-----------------------+--------------------+----------+
     * | BIOMETRIC_STRONG  | BIOMETRIC_CONVENIENCE | BIOMETRIC_WEAK     | Error    |
     * +-------------------+-----------------------+--------------------+----------+
     * Note that since BiometricPrompt does not support Convenience biometrics, currently we don't
     * have a way to test cases where the requested strength is BIOMETRIC_CONVENIENCE.
     */"	"/home/gpoor/cts-12-source/cts/tests/framework/base/biometrics/src/android/server/biometrics/BiometricSecurityTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.server.biometrics.BiometricSecurityTests"	"testBiometricStrengthDowngraded_StrongSensor"	"CtsBiometricsTestCases"	"1: ui"	"public void testBiometricStrengthDowngraded_StrongSensor() throws Exception {
        final List<Integer> sensors = getSensorsOfTargetStrength(SensorProperties.STRENGTH_STRONG);
        assumeTrue(""testBiometricStrengthDowngraded_StrongSensor: numSensors="" + sensors.size(),
                sensors.size() > 0);

        // Tuple of originalStrength, targetStrength, and requestedStrength
        final int[][] testCases = {
                // Downgrade Strong to Weak, and request Strong auth
                {Authenticators.BIOMETRIC_STRONG, Authenticators.BIOMETRIC_WEAK,
                        Authenticators.BIOMETRIC_STRONG},

                // Downgrade Strong to Weak, and request Weak auth
                {Authenticators.BIOMETRIC_STRONG, Authenticators.BIOMETRIC_WEAK,
                        Authenticators.BIOMETRIC_WEAK},

                // Downgrade Strong to Convenience, and request Strong auth
                {Authenticators.BIOMETRIC_STRONG, Authenticators.BIOMETRIC_CONVENIENCE,
                        Authenticators.BIOMETRIC_STRONG},

                // Downgrade Strong to Convenience, and request Weak auth
                {Authenticators.BIOMETRIC_STRONG, Authenticators.BIOMETRIC_CONVENIENCE,
                        Authenticators.BIOMETRIC_WEAK}
        };

        for (Integer sensorId : sensors) {
            for (int i = 0; i < testCases.length; i++) {
                testBiometricStrengthDowngraded_forSensor(sensorId,
                        testCases[i][0] /* originalStrength */,
                        testCases[i][1] /* targetStrength */,
                        testCases[i][2] /* requestedStrength */,
                        mSensorProperties.size() > 1 /* hasMultiSensors */);
            }
        }
    }

    /**
     * The strength of a Weak biometric may need to be downgraded to a weaker one if the biometric
     * requires a security update. After downgrading, the biometric may or may not be able to
     * perform auth with the requested strength. For example,
     * +-------------------+-----------------------+--------------------+--------+
     * | Original Strength | Target Strength       | Requested Strength | Result |
     * +-------------------+-----------------------+--------------------+--------+
     * | BIOMETRIC_WEAK    | BIOMETRIC_CONVENIENCE | BIOMETRIC_WEAK     | Error  |
     * +-------------------+-----------------------+--------------------+--------+
     * Note that since BiometricPrompt does not support Convenience biometrics, currently we don't
     * have a way to test cases where the requested strength is BIOMETRIC_CONVENIENCE.
     */"	"/home/gpoor/cts-12-source/cts/tests/framework/base/biometrics/src/android/server/biometrics/BiometricSecurityTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.server.biometrics.BiometricSecurityTests"	"testBiometricStrengthDowngraded_WeakSensor"	"CtsBiometricsTestCases"	"2: ui user"	"public void testBiometricStrengthDowngraded_WeakSensor() throws Exception {
        final List<Integer> sensors = getSensorsOfTargetStrength(SensorProperties.STRENGTH_WEAK);
        assumeTrue(""testBiometricStrengthDowngraded_WeakSensor: numSensors: "" + sensors.size(),
                sensors.size() > 0);

        // Tuple of originalStrength, targetStrength, and requestedStrength
        final int[][] testCases = {
                // Downgrade Weak to Convenience, and request Weak auth
                {Authenticators.BIOMETRIC_WEAK, Authenticators.BIOMETRIC_CONVENIENCE,
                        Authenticators.BIOMETRIC_WEAK}
        };

        for (Integer sensorId : sensors) {
            for (int i = 0; i < testCases.length; i++) {
                testBiometricStrengthDowngraded_forSensor(sensorId,
                        testCases[i][0] /* originalStrength */,
                        testCases[i][1] /* targetStrength */,
                        testCases[i][2] /* requestedStrength */,
                        mSensorProperties.size() > 1 /* hasMultiSensors */);
            }
        }
    }

    private void testBiometricStrengthDowngraded_forSensor(int sensorId, int originalStrength,
            int targetStrength, int requestedStrength, boolean hasMultiSensors) throws Exception {
        Log.d(TAG, ""testBiometricStrengthDowngraded_forSensor: ""
                + "", sensorId="" + sensorId
                + "", originalStrength="" + originalStrength
                + "", targetStrength="" + targetStrength
                + "", requestedStrength="" + requestedStrength
                + "", hasMultiSensors="" + hasMultiSensors);

        final ComponentName componentName = getComponentName(requestedStrength);

        try (BiometricTestSession session = mBiometricManager.createTestSession(sensorId);
             ActivitySession activitySession = new ActivitySession(this, componentName)) {
            final int userId = 0;
            waitForAllUnenrolled();
            enrollForSensor(session, sensorId);
            final TestJournal journal =
                    TestJournalContainer.get(activitySession.getComponentName());

            BiometricCallbackHelper.State callbackState;
            BiometricServiceState state;

            // Downgrade the biometric strength to the target strength
            updateStrengthAndVerify(sensorId, targetStrength);

            // After downgrading, check whether auth works
            // TODO: should check if targetStrength is at least as strong as the requestedStrength,
            // but some strength constants that are needed for the calculation are not exposed in
            // BiometricManager.
            if (targetStrength == requestedStrength) {
                Log.d(TAG, ""The targetStrength is as strong as the requestedStrength"");
                // No error code should be returned since biometric has sufficient strength if
                // request weak auth
                int errCode = mBiometricManager.canAuthenticate(requestedStrength);
                assertEquals(""Device should allow auth with the requested biometric"",
                        BiometricManager.BIOMETRIC_SUCCESS, errCode);

                // Launch test activity
                launchActivityAndWaitForResumed(activitySession);

                state = getCurrentState();
                assertTrue(state.toString(),
                        state.mSensorStates.sensorStates.get(sensorId).isBusy());

                // Auth should work
                successfullyAuthenticate(session, userId);
                mInstrumentation.waitForIdleSync();
                callbackState = getCallbackState(journal);
                assertNotNull(callbackState);
                assertEquals(callbackState.toString(), 0, callbackState.mNumAuthRejected);
                assertEquals(callbackState.toString(), 1, callbackState.mNumAuthAccepted);
                assertEquals(callbackState.toString(), 0, callbackState.mAcquiredReceived.size());
                assertEquals(callbackState.toString(), 0, callbackState.mErrorsReceived.size());
            } else {
                Log.d(TAG, ""The targetStrength is not strong enough"");
                // Error code should be returned
                int errCode = mBiometricManager.canAuthenticate(requestedStrength);
                checkErrCode(""Device shouldn't allow auth with biometrics that require security""
                                + "" update. errCode: "" + errCode,
                        errCode, BiometricManager.BIOMETRIC_ERROR_SECURITY_UPDATE_REQUIRED,
                        hasMultiSensors);

                // Launch test activity
                launchActivityAndWaitForResumed(activitySession);

                // Auth shouldn't work and error code should be returned
                mInstrumentation.waitForIdleSync();
                callbackState = getCallbackState(journal);
                assertNotNull(callbackState);
                assertEquals(callbackState.toString(), 0, callbackState.mNumAuthRejected);
                assertEquals(callbackState.toString(), 0, callbackState.mNumAuthAccepted);
                assertEquals(callbackState.toString(), 0, callbackState.mAcquiredReceived.size());
                assertEquals(callbackState.toString(), 1, callbackState.mErrorsReceived.size());
                checkErrCode(callbackState.toString(), (int) callbackState.mErrorsReceived.get(0),
                        BiometricManager.BIOMETRIC_ERROR_SECURITY_UPDATE_REQUIRED, hasMultiSensors);
            }
        }
    }

    /**
     * Trying to upgrade the strength of a Weak biometric to a stronger strength will not
     * succeed (ie, it's no-op and the biometric strength is still Weak), since the biometric's
     * actual strength can't go past its original strength. After upgrading, the biometric without
     * sufficient strength should not be able to perform the requested auth. For example,
     * +-------------------+------------------+--------------------+--------+
     * | Original Strength | Target Strength  | Requested Strength | Result |
     * +-------------------+------------------+--------------------+--------+
     * | BIOMETRIC_WEAK    | BIOMETRIC_STRONG | BIOMETRIC_STRONG   | Error  |
     * +-------------------+------------------+--------------------+--------+
     */"	"/home/gpoor/cts-12-source/cts/tests/framework/base/biometrics/src/android/server/biometrics/BiometricSecurityTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.server.biometrics.BiometricSecurityTests"	"testBiometricStrengthUpgraded_ConvenienceSensor"	"CtsBiometricsTestCases"	"1: ui"	"public void testBiometricStrengthUpgraded_ConvenienceSensor() throws Exception {
        final List<Integer> sensors =
                getSensorsOfTargetStrength(SensorProperties.STRENGTH_CONVENIENCE);
        assumeTrue(""testBiometricStrengthUpgraded_ConvenienceSensor: numSensors="" + sensors.size(),
                sensors.size() > 0);

        // Tuple of originalStrength, targetStrength, and requestedStrength
        final int[][] testCases = {
                // Upgrade Convenience to Strong, and request Strong auth
                {Authenticators.BIOMETRIC_CONVENIENCE, Authenticators.BIOMETRIC_STRONG,
                        Authenticators.BIOMETRIC_STRONG},

                // Upgrade Convenience to Strong, and request Weak auth
                {Authenticators.BIOMETRIC_CONVENIENCE, Authenticators.BIOMETRIC_STRONG,
                        Authenticators.BIOMETRIC_WEAK},

                // Upgrade Convenience to Weak, and request Weak auth
                {Authenticators.BIOMETRIC_CONVENIENCE, Authenticators.BIOMETRIC_WEAK,
                        Authenticators.BIOMETRIC_WEAK}
        };

        for (Integer sensorId : sensors) {
            for (int i = 0; i < testCases.length; i++) {
                testBiometricStrengthUpgraded_forSensor(sensorId,
                        testCases[i][0] /* originalStrength */,
                        testCases[i][1] /* targetStrength */,
                        testCases[i][2] /* requestedStrength */,
                        sensors.size() > 1 /* hasMultiSensors */);
            }
        }
    }

    private void testBiometricStrengthUpgraded_forSensor(int sensorId, int originalStrength,
            int targetStrength, int requestedStrength, boolean hasMultiSensors) throws Exception {
        Log.d(TAG, ""testBiometricStrengthUpgraded_forSensor: ""
                + ""sensorId="" + sensorId
                + "", originalStrength="" + originalStrength
                + "", targetStrength="" + targetStrength
                + "", requestedStrength="" + requestedStrength
                + "", hasMultiSensors="" + hasMultiSensors);

        final ComponentName componentName = getComponentName(requestedStrength);

        // Reset to the original strength in case it's ever changed before the test
        updateStrengthAndVerify(sensorId, originalStrength);

        try (BiometricTestSession session = mBiometricManager.createTestSession(sensorId);
             ActivitySession activitySession = new ActivitySession(this, componentName)) {
            waitForAllUnenrolled();
            enrollForSensor(session, sensorId);
            final TestJournal journal =
                    TestJournalContainer.get(activitySession.getComponentName());

            // Try to upgrade the biometric strength to the target strength. The upgrading operation
            // is no-op since the biometric can't be upgraded past its original strength.
            updateStrengthAndIdle(sensorId, targetStrength);
            final int currentStrength = getCurrentStrength(sensorId);
            assertTrue(""currentStrength: "" + currentStrength, currentStrength == originalStrength);

            // After upgrading, check whether auth works
            // Error code should be returned
            int errCode = mBiometricManager.canAuthenticate(requestedStrength);
            checkErrCode(""Device shouldn't allow auth with biometrics without sufficient strength.""
                            + "" errCode: "" + errCode,
                    errCode, BiometricManager.BIOMETRIC_ERROR_NO_HARDWARE, hasMultiSensors);

            // Launch test activity
            launchActivityAndWaitForResumed(activitySession);

            // Auth shouldn't work and error code should be returned
            mInstrumentation.waitForIdleSync();
            BiometricCallbackHelper.State callbackState = getCallbackState(journal);
            assertNotNull(callbackState);
            assertEquals(callbackState.toString(), 0, callbackState.mNumAuthRejected);
            assertEquals(callbackState.toString(), 0, callbackState.mNumAuthAccepted);
            assertEquals(callbackState.toString(), 0, callbackState.mAcquiredReceived.size());
            assertEquals(callbackState.toString(), 1, callbackState.mErrorsReceived.size());
            checkErrCode(callbackState.toString(), (int) callbackState.mErrorsReceived.get(0),
                    BiometricManager.BIOMETRIC_ERROR_NO_HARDWARE, hasMultiSensors);
        }
    }

    private void checkErrCode(String msg, int errCode, int expectedErrCode,
            boolean hasMultiSensors) {
        if (!hasMultiSensors) {
            assertTrue(msg, errCode == expectedErrCode);
        } else {
            // In the multi-sensor case, error code for the first ineligible sensor may be
            // returned so the following error codes are accepted
            assertTrue(msg, errCode == expectedErrCode
                    || errCode == BiometricManager.BIOMETRIC_ERROR_NONE_ENROLLED
                    || errCode == BiometricManager.BIOMETRIC_ERROR_NO_HARDWARE);
        }
    }

    private static ComponentName getComponentName(int requestedStrength) {
        assertTrue(""requestedStrength: "" + requestedStrength,
                requestedStrength == Authenticators.BIOMETRIC_STRONG ||
                        requestedStrength == Authenticators.BIOMETRIC_WEAK);

        if (requestedStrength == Authenticators.BIOMETRIC_STRONG) {
            return CLASS_3_BIOMETRIC_ACTIVITY;
        }
        return CLASS_2_BIOMETRIC_ACTIVITY;
    }

    private static void revertSensorStrengths() throws Exception {
        Log.d(TAG, ""revertSensorStrengths"");
        Utils.executeShellCommand(""device_config delete "" +
                DEVICE_CONFIG_NAMESPACE + "" "" +
                DEVICE_CONFIG_BIO_STRENGTH_KEY);
        // this is probably not needed, but there are not too many tests so pause to ensure
        // the settings have settled
        Thread.sleep(1000);
    }

    private void updateStrengthAndVerify(int sensorId, int targetStrength) throws Exception {
        updateSensorStrength(sensorId, targetStrength, /* verify */ true);
    }

    private void updateStrengthAndIdle(int sensorId, int targetStrength) throws Exception {
        updateSensorStrength(sensorId, targetStrength, /* verify */ false);
    }

    private void updateSensorStrength(int sensorId, int targetStrength, boolean verify)
            throws Exception {
        Log.d(TAG, ""updateStrength: update sensorId="" + sensorId + "" to targetStrength=""
                + targetStrength);
        Utils.executeShellCommand(""device_config put "" +
                DEVICE_CONFIG_NAMESPACE + "" "" +
                DEVICE_CONFIG_BIO_STRENGTH_KEY + "" "" +
                String.format(""%s:%s"", sensorId, targetStrength));

        final boolean matchesTarget = waitForSensorToBecomeStrength(sensorId, targetStrength);
        if (verify && !matchesTarget) {
            fail(""Timed out waiting for sensorId "" + sensorId + "" to become target strength: ""
                    + targetStrength);
        }
    }

    private boolean waitForSensorToBecomeStrength(int sensorId, int targetStrength)
            throws Exception {
        for (int i = 0; i < 20; i++) {
            final int currentStrength = getCurrentStrength(sensorId);
            if (currentStrength == targetStrength) {
                return true;
            }
            Log.d(TAG, ""Not at target strength yet, current: "" + currentStrength);
            Thread.sleep(300);
        }
        return false;
    }
}"	"/home/gpoor/cts-12-source/cts/tests/framework/base/biometrics/src/android/server/biometrics/BiometricSecurityTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.server.wm.WindowMetricsTestHelper"	"displayCutout"	"CtsWindowManagerDeviceTestCases"	"1: system"	"public void test/*
 *.
 */

package android.server.wm;

import static android.app.WindowConfiguration.WINDOWING_MODE_FREEFORM;
import static android.view.WindowInsets.Type.displayCutout;
import static android.view.WindowInsets.Type.navigationBars;
import static android.view.WindowInsets.Type.statusBars;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import android.app.Activity;
import android.content.Context;
import android.graphics.Insets;
import android.graphics.Point;
import android.graphics.Rect;
import android.view.Display;
import android.view.View;
import android.view.WindowInsets;
import android.view.WindowManager;
import android.view.WindowMetrics;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/** Helper class to test {@link WindowMetrics} behaviors. */
public class WindowMetricsTestHelper {
    public static void assertMetricsMatchesLayout(WindowMetrics currentMetrics,
            WindowMetrics maxMetrics, Rect layoutBounds, WindowInsets layoutInsets) {
        assertMetricsMatchesLayout(currentMetrics, maxMetrics, layoutBounds, layoutInsets,
                false /* isFreeformActivity */);
    }

    public static void assertMetricsMatchesLayout(WindowMetrics currentMetrics,
            WindowMetrics maxMetrics, Rect layoutBounds, WindowInsets layoutInsets,
            boolean isFreeformActivity) {
        assertEquals(layoutBounds, currentMetrics.getBounds());
        // Freeform activities doesn't guarantee max window metrics bounds is larger than current
        // window metrics bounds. The bounds of a freeform activity is unlimited except that
        // it must be contained in display bounds.
        if (!isFreeformActivity) {
            assertTrue(maxMetrics.getBounds().width()
                    >= currentMetrics.getBounds().width());
            assertTrue(maxMetrics.getBounds().height()
                    >= currentMetrics.getBounds().height());
        }
        final int insetsType = statusBars() | navigationBars() | displayCutout();
        assertEquals(layoutInsets.getInsets(insetsType),
                currentMetrics.getWindowInsets().getInsets(insetsType));
        assertEquals(layoutInsets.getDisplayCutout(),
                currentMetrics.getWindowInsets().getDisplayCutout());
    }

    /**
     * Verifies two scenarios for a {@link Context}.
     * <ul>
     *     <li>{@link WindowManager#getCurrentWindowMetrics()} matches
     *     {@link Display#getSize(Point)}</li>
     *     <li>{@link WindowManager#getMaximumWindowMetrics()} and {@link Display#getSize(Point)}
     *     either matches DisplayArea bounds which the {@link Context} is attached to, or matches
     *     {@link WindowManager#getCurrentWindowMetrics()} if sandboxing is applied.</li>
     * </ul>
     * @param context the context under test
     * @param displayAreaBounds the bounds of the DisplayArea
     */
    public static void assertMetricsValidity(Context context, Rect displayAreaBounds) {
        final boolean isFreeForm = context instanceof Activity
                && context.getResources().getConfiguration().windowConfiguration
                .getWindowingMode() == WINDOWING_MODE_FREEFORM;
        final WindowManager windowManager = context.getSystemService(WindowManager.class);
        // Freeform activity doesn't inset the navigation bar and cutout area.
        final Rect currentBounds =
                isFreeForm ? windowManager.getCurrentWindowMetrics().getBounds() :
                        getBoundsExcludingNavigationBarAndCutout(
                                windowManager.getCurrentWindowMetrics());
        final Rect maxBounds = windowManager.getMaximumWindowMetrics().getBounds();
        final Display display = context.getDisplay();
        assertBoundsMatchDisplay(maxBounds, currentBounds, display);

        // Max window bounds should match either DisplayArea bounds, or current window bounds.
        if (maxWindowBoundsSandboxed(displayAreaBounds, maxBounds)) {
            // Max window bounds are sandboxed, so max window bounds and real display size
            // should match current window bounds.
            assertEquals(""Max window size matches current window size, due to sandboxing"",
                    currentBounds, maxBounds);
        } else {
            // Max window bounds are not sandboxed, so max window bounds and real display size
            // should match display area bounds.
            assertEquals(""Display area bounds must match max window size"",
                    displayAreaBounds, maxBounds);
        }
    }

    /**
     * Verifies for the provided bounds and display:
     * <ul>
     *     <li>{@link WindowManager#getCurrentWindowMetrics()} matches
     *     {@link Display#getSize(Point)}</li>
     *     <li>{@link WindowManager#getMaximumWindowMetrics()} matches
     *     {@link Display#getRealSize(Point)}
     * </ul>
     * @param maxBounds the bounds from {@link WindowManager#getMaximumWindowMetrics()}
     * @param currentBounds the bounds from {@link WindowManager#getCurrentWindowMetrics()}
     * @param display the display to compare bounds against
     */
    static void assertBoundsMatchDisplay(Rect maxBounds, Rect currentBounds, Display display) {
        // Check window bounds
        final Point displaySize = new Point();
        display.getSize(displaySize);
        assertEquals(""Reported display width must match window width"",
                displaySize.x, currentBounds.width());
        assertEquals(""Reported display height must match window height"",
                displaySize.y, currentBounds.height());

        // Max window bounds should match real display size.
        final Point realDisplaySize = new Point();
        display.getRealSize(realDisplaySize);
        assertEquals(""Reported real display width must match max window width"",
                realDisplaySize.x, maxBounds.width());
        assertEquals(""Reported real display height must match max window height"",
                realDisplaySize.y, maxBounds.height());
    }

    public static Rect getBoundsExcludingNavigationBarAndCutout(WindowMetrics windowMetrics) {
        WindowInsets windowInsets = windowMetrics.getWindowInsets();
        final Insets insetsWithCutout =
                windowInsets.getInsetsIgnoringVisibility(navigationBars() | displayCutout());

        final Rect bounds = windowMetrics.getBounds();
        return inset(bounds, insetsWithCutout);
    }

    /**
     * Returns {@code true} if the bounds from {@link WindowManager#getMaximumWindowMetrics()} are
     * sandboxed, so are smaller than the DisplayArea.
     */
    static boolean maxWindowBoundsSandboxed(Rect displayAreaBounds, Rect maxBounds) {
        return maxBounds.width() < displayAreaBounds.width()
                || maxBounds.height() < displayAreaBounds.height();
    }

    private static Rect inset(Rect original, Insets insets) {
        final int left = original.left + insets.left;
        final int top = original.top + insets.top;
        final int right = original.right - insets.right;
        final int bottom = original.bottom - insets.bottom;
        return new Rect(left, top, right, bottom);
    }

    public static class OnLayoutChangeListener implements View.OnLayoutChangeListener {
        private final CountDownLatch mLayoutLatch = new CountDownLatch(1);

        private volatile Rect mOnLayoutBoundsInScreen;
        private volatile WindowInsets mOnLayoutInsets;

        @Override
        public void onLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft,
                int oldTop, int oldRight, int oldBottom) {
            synchronized (this) {
                mOnLayoutBoundsInScreen = new Rect(left, top, right, bottom);
                // Convert decorView's bounds from window coordinates to screen coordinates.
                final int[] locationOnScreen = new int[2];
                v.getLocationOnScreen(locationOnScreen);
                mOnLayoutBoundsInScreen.offset(locationOnScreen[0], locationOnScreen[1]);

                mOnLayoutInsets = v.getRootWindowInsets();
                mLayoutLatch.countDown();
            }
        }

        public Rect getLayoutBounds() {
            synchronized (this) {
                return mOnLayoutBoundsInScreen;
            }
        }

        public WindowInsets getLayoutInsets() {
            synchronized (this) {
                return mOnLayoutInsets;
            }
        }

        void waitForLayout() {
            try {
                assertTrue(""Timed out waiting for layout."",
                        mLayoutLatch.await(4, TimeUnit.SECONDS));
            } catch (InterruptedException e) {
                throw new AssertionError(e);
            }
        }
    }
}"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/WindowMetricsTestHelper.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telephony.embms.cts.MbmsStreamingTestBase"	"TestCallback"	"CtsTelephonyTestCases"	"1: ui"	"public void test/*
 *
 */

package android.telephony.embms.cts;

import static androidx.test.InstrumentationRegistry.getContext;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import android.annotation.Nullable;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.IBinder;
import android.os.RemoteException;
import android.telephony.MbmsStreamingSession;
import android.telephony.cts.embmstestapp.CtsStreamingService;
import android.telephony.cts.embmstestapp.ICtsStreamingMiddlewareControl;
import android.telephony.mbms.MbmsStreamingSessionCallback;
import android.telephony.mbms.StreamingServiceInfo;

import com.android.internal.os.SomeArgs;

import java.util.List;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import org.junit.After;
import org.junit.Before;

public class MbmsStreamingTestBase {
    protected static final int ASYNC_TIMEOUT = 10000;

    protected static class TestCallback extends MbmsStreamingSessionCallback {
        private final BlockingQueue<SomeArgs> mErrorCalls = new LinkedBlockingQueue<>();
        private final BlockingQueue<SomeArgs> mStreamingServicesUpdatedCalls =
                new LinkedBlockingQueue<>();
        private final BlockingQueue<SomeArgs> mMiddlewareReadyCalls = new LinkedBlockingQueue<>();
        private int mNumErrorCalls = 0;

        @Override
        public void onError(int errorCode, @Nullable String message) {
            mNumErrorCalls += 1;
            SomeArgs args = SomeArgs.obtain();
            args.arg1 = errorCode;
            args.arg2 = message;
            mErrorCalls.add(args);
        }

        @Override
        public void onStreamingServicesUpdated(List<StreamingServiceInfo> services) {
            SomeArgs args = SomeArgs.obtain();
            args.arg1 = services;
            mStreamingServicesUpdatedCalls.add(args);
        }

        @Override
        public void onMiddlewareReady() {
            mMiddlewareReadyCalls.add(SomeArgs.obtain());
        }

        public SomeArgs waitOnError() {
            try {
                return mErrorCalls.poll(ASYNC_TIMEOUT, TimeUnit.MILLISECONDS);
            } catch (InterruptedException e) {
                return null;
            }
        }

        public SomeArgs waitOnStreamingServicesUpdated() {
            try {
                return mStreamingServicesUpdatedCalls.poll(ASYNC_TIMEOUT, TimeUnit.MILLISECONDS);
            } catch (InterruptedException e) {
                return null;
            }
        }

        public boolean waitOnMiddlewareReady() {
            try {
                return mMiddlewareReadyCalls.poll(ASYNC_TIMEOUT, TimeUnit.MILLISECONDS) != null;
            } catch (InterruptedException e) {
                return false;
            }
        }

        public int getNumErrorCalls() {
            return mNumErrorCalls;
        }
    }

    Context mContext;
    HandlerThread mHandlerThread;
    Executor mCallbackExecutor;
    ICtsStreamingMiddlewareControl mMiddlewareControl;
    MbmsStreamingSession mStreamingSession;
    TestCallback mCallback = new TestCallback();

    @Before
    public void setUp() throws Exception {
        mContext = getContext();
        mHandlerThread = new HandlerThread(""EmbmsCtsTestWorker"");
        mHandlerThread.start();
        mCallbackExecutor = (new Handler(mHandlerThread.getLooper()))::post;
        mCallback = new TestCallback();
        getControlBinder();
        setupStreamingSession();
    }

    @After
    public void tearDown() throws Exception {
        mHandlerThread.quit();
        mStreamingSession.close();
        mMiddlewareControl.reset();
    }

    private void setupStreamingSession() throws Exception {
        mStreamingSession = MbmsStreamingSession.create(
                mContext, mCallbackExecutor, mCallback);
        assertNotNull(mStreamingSession);
        assertTrue(mCallback.waitOnMiddlewareReady());
        assertEquals(0, mCallback.getNumErrorCalls());
        List initializeCall = (List) mMiddlewareControl.getStreamingSessionCalls().get(0);
        assertEquals(CtsStreamingService.METHOD_INITIALIZE, initializeCall.get(0));
    }

    private void getControlBinder() throws InterruptedException {
        Intent bindIntent = new Intent(CtsStreamingService.CONTROL_INTERFACE_ACTION);
        bindIntent.setComponent(CtsStreamingService.CONTROL_INTERFACE_COMPONENT);
        final CountDownLatch bindLatch = new CountDownLatch(1);

        boolean success = mContext.bindService(bindIntent, new ServiceConnection() {
            @Override
            public void onServiceConnected(ComponentName name, IBinder service) {
                mMiddlewareControl = ICtsStreamingMiddlewareControl.Stub.asInterface(service);
                bindLatch.countDown();
            }

            @Override
            public void onServiceDisconnected(ComponentName name) {
                mMiddlewareControl = null;
            }
        }, Context.BIND_AUTO_CREATE);
        if (!success) {
            fail(""Failed to get control interface -- bind error"");
        }
        bindLatch.await(ASYNC_TIMEOUT, TimeUnit.MILLISECONDS);
    }

    protected List<List<Object>> getMiddlewareCalls(String methodName) throws RemoteException {
        return ((List<List<Object>>) mMiddlewareControl.getStreamingSessionCalls()).stream()
                .filter((elem) -> elem.get(0).equals(methodName))
                .collect(Collectors.toList());
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/embms/cts/MbmsStreamingTestBase.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.compatibility.common.util.devicepolicy.provisioning.SilentProvisioningTestManager"	"getReceviedProfileProvisionedIntent"	""	"2: ui user"	"public void test/*
 *.
 */
package com.android.compatibility.common.util.devicepolicy.provisioning;

import static android.app.admin.DevicePolicyManager.ACTION_MANAGED_PROFILE_PROVISIONED;
import static android.app.admin.DevicePolicyManager.ACTION_PROVISION_MANAGED_PROFILE;
import static android.content.Intent.ACTION_MANAGED_PROFILE_ADDED;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.os.RemoteException;
import android.support.test.uiautomator.UiDevice;
import android.util.Log;

import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.BlockingBroadcastReceiver;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

// TODO(b/183395856): Remove once the remaining silent provisioning tests are removed.
public class SilentProvisioningTestManager {
    private static final long TIMEOUT_SECONDS = 120L;
    private static final String TAG = ""SilentProvisioningTest"";

    private final LinkedBlockingQueue<Boolean> mProvisioningResults = new LinkedBlockingQueue(1);

    private final IBooleanCallback mProvisioningResultCallback = new IBooleanCallback.Stub() {
        @Override
        public void onResult(boolean result) {
            try {
                mProvisioningResults.put(result);
            } catch (InterruptedException e) {
                Log.e(TAG, ""IBooleanCallback.callback"", e);
            }
        }
    };

    private final Context mContext;
    private Intent mReceivedProfileProvisionedIntent;

    public SilentProvisioningTestManager(Context context) {
        mContext = context.getApplicationContext();
    }

    public Intent getReceviedProfileProvisionedIntent() {
        return mReceivedProfileProvisionedIntent;
    }

    public boolean startProvisioningAndWait(Intent provisioningIntent) throws InterruptedException {
        wakeUpAndDismissInsecureKeyguard();
        mContext.startActivity(getStartIntent(provisioningIntent));
        Log.i(TAG, ""startActivity on user "" + mContext.getUserId() + "" with "" + provisioningIntent);

        if (ACTION_PROVISION_MANAGED_PROFILE.equals(provisioningIntent.getAction())) {
            return waitManagedProfileProvisioning();
        } else {
            return waitDeviceOwnerProvisioning();
        }
    }

    private boolean waitDeviceOwnerProvisioning() throws InterruptedException {
        return pollProvisioningResult();
    }

    private boolean waitManagedProfileProvisioning() throws InterruptedException {
        BlockingBroadcastReceiver managedProfileProvisionedReceiver =
                new BlockingBroadcastReceiver(mContext, ACTION_MANAGED_PROFILE_PROVISIONED);
        BlockingBroadcastReceiver managedProfileAddedReceiver =
                new BlockingBroadcastReceiver(mContext, ACTION_MANAGED_PROFILE_ADDED);
        try {
            managedProfileProvisionedReceiver.register();
            managedProfileAddedReceiver.register();

            if (!pollProvisioningResult()) {
                return false;
            }

            mReceivedProfileProvisionedIntent =
                    managedProfileProvisionedReceiver.awaitForBroadcast(
                            TimeUnit.SECONDS.toMillis(TIMEOUT_SECONDS));
            if (mReceivedProfileProvisionedIntent == null) {
                Log.i(TAG, ""managedProfileProvisionedReceiver.awaitForBroadcast(): failed"");
                return false;
            }

            if (managedProfileAddedReceiver.awaitForBroadcast(
                    TimeUnit.SECONDS.toMillis(TIMEOUT_SECONDS)) == null) {
                Log.i(TAG, ""managedProfileAddedReceiver.awaitForBroadcast(): failed"");
                return false;
            }
        } finally {
            managedProfileProvisionedReceiver.unregisterQuietly();
            managedProfileAddedReceiver.unregisterQuietly();
        }
        return true;
    }

    private boolean pollProvisioningResult() throws InterruptedException {
        Boolean result = mProvisioningResults.poll(TIMEOUT_SECONDS, TimeUnit.SECONDS);
        if (result == null) {
            Log.i(TAG, ""ManagedProvisioning doesn't return result within ""
                    + TIMEOUT_SECONDS + "" seconds "");
            return false;
        }

        if (!result) {
            Log.i(TAG, ""Failed to provision"");
            return false;
        }
        return true;
    }

    private Intent getStartIntent(Intent intent) {
        final Bundle bundle = new Bundle();
        bundle.putParcelable(Intent.EXTRA_INTENT, intent);
        bundle.putBinder(StartProvisioningActivity.EXTRA_BOOLEAN_CALLBACK,
                mProvisioningResultCallback.asBinder());
        return new Intent(mContext, StartProvisioningActivity.class)
                .putExtras(bundle)
                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    }

    private static void wakeUpAndDismissInsecureKeyguard() {
        try {
            UiDevice uiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
            uiDevice.wakeUp();
            uiDevice.pressMenu();
        } catch (RemoteException e) {
            Log.e(TAG, ""wakeUpScreen"", e);
        }
    }

    private static class BlockingReceiver extends BroadcastReceiver {

        private final CountDownLatch mLatch = new CountDownLatch(1);
        private final Context mContext;
        private final String mAction;
        private Intent mReceivedIntent;

        private BlockingReceiver(Context context, String action) {
            mContext = context;
            mAction = action;
            mReceivedIntent = null;
        }

        public void register() {
            mContext.registerReceiver(this, new IntentFilter(mAction));
        }

        public boolean await() throws InterruptedException {
            return mLatch.await(TIMEOUT_SECONDS, TimeUnit.SECONDS);
        }

        public Intent getReceivedIntent() {
            return mReceivedIntent;
        }

        @Override
        public void onReceive(Context context, Intent intent) {
            mReceivedIntent = intent;
            mLatch.countDown();
        }
    }
}"	"/home/gpoor/cts-12-source/cts/common/device-side/util-axt/src/com/android/compatibility/common/util/devicepolicy/provisioning/SilentProvisioningTestManager.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"test.java.com.android.bedstead.testapp.TestAppInstanceReferenceTest"	"TestApis"	""	"2: ui user"	"/*
 *.
 */

package com.android.bedstead.testapp;

import static android.Manifest.permission.INTERACT_ACROSS_USERS;

import static com.google.common.truth.Truth.assertThat;

import static org.testng.Assert.assertThrows;

import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;

import com.android.bedstead.harrier.BedsteadJUnit4;
import com.android.bedstead.harrier.DeviceState;
import com.android.bedstead.harrier.annotations.EnsureHasSecondaryUser;
import com.android.bedstead.harrier.annotations.RequireRunOnPrimaryUser;
import com.android.bedstead.nene.TestApis;
import com.android.bedstead.nene.packages.Package;
import com.android.bedstead.nene.permissions.PermissionContext;
import com.android.bedstead.nene.users.UserReference;
import com.android.compatibility.common.util.PollingCheck;
import com.android.eventlib.EventLogs;
import com.android.eventlib.events.broadcastreceivers.BroadcastReceivedEvent;

import org.junit.Before;
import org.junit.ClassRule;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

@RunWith(BedsteadJUnit4.class)
public class TestAppInstanceReferenceTest {

    @ClassRule @Rule
    public static final DeviceState sDeviceState = new DeviceState();

    private static final TestApis sTestApis = new TestApis();
    private static final Context sContext = sTestApis.context().instrumentedContext();
    private static final UserReference sUser = sTestApis.users().instrumented();

    private TestAppProvider mTestAppProvider;

    private static final String INTENT_ACTION = ""com.android.bedstead.testapp.test_action"";
    private static final IntentFilter INTENT_FILTER = new IntentFilter(INTENT_ACTION);
    private static final Intent INTENT = new Intent(INTENT_ACTION);
    private static final String INTENT_ACTION_2 = ""com.android.bedstead.testapp.test_action2"";
    private static final IntentFilter INTENT_FILTER_2 = new IntentFilter(INTENT_ACTION_2);
    private static final Intent INTENT_2 = new Intent(INTENT_ACTION_2);

    @Before
    public void setup() {
        mTestAppProvider = new TestAppProvider();
    }"	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/testapp/src/test/java/com/android/bedstead/testapp/TestAppInstanceReferenceTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"test.java.com.android.bedstead.testapp.TestAppInstanceReferenceTest"	"testApp_returnsTestApp"	""	"1: user"	"public void testApp_returnsTestApp() {
        TestApp testApp = mTestAppProvider.any();
        TestAppInstanceReference testAppInstance = testApp.instance(sUser);

        assertThat(testAppInstance.testApp()).isEqualTo(testApp);
    }"	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/testapp/src/test/java/com/android/bedstead/testapp/TestAppInstanceReferenceTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"test.java.com.android.bedstead.testapp.TestAppInstanceReferenceTest"	"isNotNull"	""	"1: user"	"public void activities_any_returnsActivity() {
        TestApp testApp = mTestAppProvider.any();
        try (TestAppInstanceReference testAppInstance = testApp.install(sUser)) {
            assertThat(testAppInstance.activities().any()).isNotNull();
        }
    }"	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/testapp/src/test/java/com/android/bedstead/testapp/TestAppInstanceReferenceTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"test.java.com.android.bedstead.testapp.TestAppInstanceReferenceTest"	"killProcess_keepAlive_processIsRunningAgain"	""	"1: user"	"public void killProcess_keepAlive_processIsRunningAgain() {
        TestApp testApp = mTestAppProvider.any();
        try (TestAppInstanceReference testAppInstance = testApp.install(sUser)) {
            testAppInstance.keepAlive();

            testAppInstance.process().kill();

            PollingCheck.waitFor(() -> testApp.reference().runningProcess(sUser) != null);
        }
    }

    // We cannot test that after stopKeepAlive it does not restart, as we'd have to wait an
    // unbounded amount of time"	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/testapp/src/test/java/com/android/bedstead/testapp/TestAppInstanceReferenceTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"test.java.com.android.bedstead.testapp.TestAppInstanceReferenceTest"	"stop_processIsNotRunning"	""	"1: user"	"public void stop_processIsNotRunning() {
        TestApp testApp = mTestAppProvider.any();
        try (TestAppInstanceReference testAppInstance = testApp.install(sUser)) {
            testAppInstance.activities().any().start();

            testAppInstance.stop();

            assertThat(testApp.reference().runningProcesses()).isEmpty();
        }
    }"	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/testapp/src/test/java/com/android/bedstead/testapp/TestAppInstanceReferenceTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"test.java.com.android.bedstead.testapp.TestAppInstanceReferenceTest"	"isEmpty"	""	"1: user"	"public void stop_previouslyCalledKeepAlive_processDoesNotRestart() {
        TestApp testApp = mTestAppProvider.any();
        try (TestAppInstanceReference testAppInstance = testApp.install(sUser)) {
            testAppInstance.activities().any().start();
            testAppInstance.keepAlive();

            testAppInstance.stop();

            assertThat(testApp.reference().runningProcesses()).isEmpty();
        }
    }"	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/testapp/src/test/java/com/android/bedstead/testapp/TestAppInstanceReferenceTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"test.java.com.android.bedstead.testapp.TestAppInstanceReferenceTest"	"process_isNotRunning_returnsNull"	""	"1: user"	"public void process_isNotRunning_returnsNull() {
        TestApp testApp = mTestAppProvider.any();
        try (TestAppInstanceReference testAppInstance = testApp.install(sUser)) {
            assertThat(testAppInstance.process()).isNull();
        }
    }"	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/testapp/src/test/java/com/android/bedstead/testapp/TestAppInstanceReferenceTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"test.java.com.android.bedstead.testapp.TestAppInstanceReferenceTest"	"process_isRunning_isNotNull"	""	"1: user"	"public void process_isRunning_isNotNull() {
        TestApp testApp = mTestAppProvider.any();
        try (TestAppInstanceReference testAppInstance = testApp.install(sUser)) {
            testAppInstance.activities().any().start();

            assertThat(testAppInstance.process()).isNotNull();
        }
    }"	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/testapp/src/test/java/com/android/bedstead/testapp/TestAppInstanceReferenceTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"test.java.com.android.bedstead.testapp.TestAppInstanceReferenceTest"	"registerReceiver_receivesBroadcast"	""	"1: user"	"public void registerReceiver_receivesBroadcast() {
        TestApp testApp = mTestAppProvider.any();
        try (TestAppInstanceReference testAppInstance = testApp.install(sUser)) {
            testAppInstance.registerReceiver(INTENT_FILTER);

            sContext.sendBroadcast(INTENT);

            EventLogs<BroadcastReceivedEvent> logs =
                    BroadcastReceivedEvent.queryPackage(testApp.packageName())
                    .whereIntent().action().isEqualTo(INTENT_ACTION);
            assertThat(logs.poll()).isNotNull();
        }
    }"	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/testapp/src/test/java/com/android/bedstead/testapp/TestAppInstanceReferenceTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"test.java.com.android.bedstead.testapp.TestAppInstanceReferenceTest"	"registerReceiver_multipleIntentFilters_receivesAllMatchingBroadcasts"	""	"1: user"	"public void registerReceiver_multipleIntentFilters_receivesAllMatchingBroadcasts() {
        TestApp testApp = mTestAppProvider.any();
        try (TestAppInstanceReference testAppInstance = testApp.install(sUser)) {
            testAppInstance.registerReceiver(INTENT_FILTER);
            testAppInstance.registerReceiver(INTENT_FILTER_2);

            sContext.sendBroadcast(INTENT);
            sContext.sendBroadcast(INTENT_2);

            EventLogs<BroadcastReceivedEvent> logs =
                    BroadcastReceivedEvent.queryPackage(testApp.packageName())
                            .whereIntent().action().isEqualTo(INTENT_ACTION);
            EventLogs<BroadcastReceivedEvent> logs2 =
                    BroadcastReceivedEvent.queryPackage(testApp.packageName())
                            .whereIntent().action().isEqualTo(INTENT_ACTION_2);
            assertThat(logs.poll()).isNotNull();
            assertThat(logs2.poll()).isNotNull();
        }
    }"	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/testapp/src/test/java/com/android/bedstead/testapp/TestAppInstanceReferenceTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"test.java.com.android.bedstead.testapp.TestAppInstanceReferenceTest"	"registerReceiver_processIsRunning"	""	"1: user"	"public void registerReceiver_processIsRunning() {
        TestApp testApp = mTestAppProvider.any();
        try (TestAppInstanceReference testAppInstance = testApp.install(sUser)) {

            testAppInstance.registerReceiver(INTENT_FILTER);

            assertThat(testApp.reference().runningProcess(sUser)).isNotNull();
        }
    }"	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/testapp/src/test/java/com/android/bedstead/testapp/TestAppInstanceReferenceTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"test.java.com.android.bedstead.testapp.TestAppInstanceReferenceTest"	"stop_registeredReceiver_doesNotReceiveBroadcast"	""	"1: user"	"public void stop_registeredReceiver_doesNotReceiveBroadcast() {
        TestApp testApp = mTestAppProvider.any();
        try (TestAppInstanceReference testAppInstance = testApp.install(sUser)) {
            testAppInstance.registerReceiver(INTENT_FILTER);

            testAppInstance.stop();
            sContext.sendBroadcast(INTENT);

            EventLogs<BroadcastReceivedEvent> logs =
                    BroadcastReceivedEvent.queryPackage(testApp.packageName())
                            .whereIntent().action().isEqualTo(INTENT_ACTION);
            assertThat(logs.get()).isNull();
        }
    }"	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/testapp/src/test/java/com/android/bedstead/testapp/TestAppInstanceReferenceTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"test.java.com.android.bedstead.testapp.TestAppInstanceReferenceTest"	"unregisterReceiver_registeredReceiver_doesNotReceiveBroadcast"	""	"1: user"	"public void unregisterReceiver_registeredReceiver_doesNotReceiveBroadcast() {
        TestApp testApp = mTestAppProvider.any();
        try (TestAppInstanceReference testAppInstance = testApp.install(sUser)) {
            testAppInstance.registerReceiver(INTENT_FILTER);

            testAppInstance.unregisterReceiver(INTENT_FILTER);
            sContext.sendBroadcast(INTENT);

            EventLogs<BroadcastReceivedEvent> logs =
                    BroadcastReceivedEvent.queryPackage(testApp.packageName())
                            .whereIntent().action().isEqualTo(INTENT_ACTION);
            assertThat(logs.get()).isNull();
        }
    }"	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/testapp/src/test/java/com/android/bedstead/testapp/TestAppInstanceReferenceTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"test.java.com.android.bedstead.testapp.TestAppInstanceReferenceTest"	"unregisterReceiver_doesNotUnregisterOtherReceivers"	""	"1: user"	"public void unregisterReceiver_doesNotUnregisterOtherReceivers() {
        TestApp testApp = mTestAppProvider.any();
        try (TestAppInstanceReference testAppInstance = testApp.install(sUser)) {
            testAppInstance.registerReceiver(INTENT_FILTER);
            testAppInstance.registerReceiver(INTENT_FILTER_2);

            testAppInstance.unregisterReceiver(INTENT_FILTER);
            sContext.sendBroadcast(INTENT);
            sContext.sendBroadcast(INTENT_2);

            EventLogs<BroadcastReceivedEvent> logs =
                    BroadcastReceivedEvent.queryPackage(testApp.packageName())
                            .whereIntent().action().isEqualTo(INTENT_ACTION);
            EventLogs<BroadcastReceivedEvent> logs2 =
                    BroadcastReceivedEvent.queryPackage(testApp.packageName())
                            .whereIntent().action().isEqualTo(INTENT_ACTION_2);
            assertThat(logs.get()).isNull();
            assertThat(logs2.poll()).isNotNull();
        }
    }"	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/testapp/src/test/java/com/android/bedstead/testapp/TestAppInstanceReferenceTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"test.java.com.android.bedstead.testapp.TestAppInstanceReferenceTest"	"keepAlive_processIsRunning"	""	"1: user"	"public void keepAlive_processIsRunning() {
        TestApp testApp = mTestAppProvider.any();
        try (TestAppInstanceReference testAppInstance = testApp.install(sUser)) {

            testAppInstance.keepAlive();

            assertThat(testApp.reference().runningProcess(sUser)).isNotNull();
        }
    }"	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/testapp/src/test/java/com/android/bedstead/testapp/TestAppInstanceReferenceTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"test.java.com.android.bedstead.testapp.TestAppInstanceReferenceTest"	"registerReceiver_appIsKilled_stillReceivesBroadcast"	""	"1: user"	"public void registerReceiver_appIsKilled_stillReceivesBroadcast() {
        TestApp testApp = mTestAppProvider.any();
        try (TestAppInstanceReference testAppInstance = testApp.install(sUser)) {
            testAppInstance.registerReceiver(INTENT_FILTER);
            testApp.reference().runningProcess(sUser).kill();
            PollingCheck.waitFor(() -> testApp.reference().runningProcess(sUser) != null);

            sContext.sendBroadcast(INTENT);

            EventLogs<BroadcastReceivedEvent> logs =
                    BroadcastReceivedEvent.queryPackage(testApp.packageName())
                            .whereIntent().action().isEqualTo(INTENT_ACTION);
            assertThat(logs.poll()).isNotNull();
        }
    }
}"	"/home/gpoor/cts-12-source/cts/common/device-side/bedstead/testapp/src/test/java/com/android/bedstead/testapp/TestAppInstanceReferenceTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.app.cts.WearableExtenderTest"	"testWearableExtender"	"CtsAppTestCases"	"2: hide ui"	"public void testWearableExtender() {
        final String bridgeTag = ""bridge_tag"";
        final String dismissalId = ""dismissal_id"";
        final int contentActionIndex = 2;
        final Bitmap background = Bitmap.createBitmap(10, 10, Config.ARGB_8888);
        PendingIntent pendingIntent = PendingIntent.getActivity(mContext, 0, new Intent(), PendingIntent.FLAG_MUTABLE_UNAUDITED);
        Notification page1 = new Notification.Builder(mContext, ""test id"")
            .setSmallIcon(1)
            .setContentTitle(""page1"")
            .build();
        Notification page2 = new Notification.Builder(mContext, ""test id"")
            .setSmallIcon(1)
            .setContentTitle(""page2"")
            .build();
        List<Notification> pages = new ArrayList<>();
        pages.add(page2);
        final int gravity = Gravity.LEFT;
        final int icon = 3;
        final int height = 4;
        final int size = 5;
        final int timeout = 6;

        WearableExtender extender = new WearableExtender()
                .setStartScrollBottom(true)
                .setContentIntentAvailableOffline(true)
                .setHintContentIntentLaunchesActivity(true)
                .setBridgeTag(bridgeTag)
                .setDismissalId(dismissalId)
                .setContentAction(contentActionIndex)
                // deprecated methods follow
                .setBackground(background)
                .setGravity(gravity)
                .setContentIcon(icon)
                .setContentIconGravity(gravity)
                .setCustomContentHeight(height)
                .setCustomSizePreset(size)
                .setDisplayIntent(pendingIntent)
                .setHintAmbientBigPicture(true)
                .setHintAvoidBackgroundClipping(true)
                .setHintHideIcon(true)
                .setHintScreenTimeout(timeout)
                .setHintShowBackgroundOnly(true)
                .addPage(page1)
                .clearPages()
                .addPages(pages);

        assertTrue(extender.getStartScrollBottom());
        assertTrue(extender.getContentIntentAvailableOffline());
        assertTrue(extender.getHintContentIntentLaunchesActivity());
        assertEquals(bridgeTag, extender.getBridgeTag());
        assertEquals(dismissalId, extender.getDismissalId());
        assertEquals(contentActionIndex, extender.getContentAction());
        // deprecated methods follow
        assertEquals(background, extender.getBackground());
        assertEquals(gravity, extender.getGravity());
        assertEquals(icon, extender.getContentIcon());
        assertEquals(gravity, extender.getContentIconGravity());
        assertEquals(height, extender.getCustomContentHeight());
        assertEquals(size, extender.getCustomSizePreset());
        assertEquals(pendingIntent, extender.getDisplayIntent());
        assertTrue(extender.getHintAmbientBigPicture());
        assertTrue(extender.getHintAvoidBackgroundClipping());
        assertTrue(extender.getHintHideIcon());
        assertEquals(timeout, extender.getHintScreenTimeout());
        assertTrue(extender.getHintShowBackgroundOnly());
        assertEquals(1, extender.getPages().size());
        assertEquals(page2, extender.getPages().get(0));
    }"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/WearableExtenderTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.app.cts.WearableExtenderTest"	"testWriteToParcel"	"CtsAppTestCases"	"2: hide ui"	"public void testWriteToParcel() {
        final String bridgeTag = ""bridge_tag"";
        final String dismissalId = ""dismissal_id"";
        final int contentActionIndex = 2;
        Notification.Action action = newActionBuilder().build();
        final Bitmap background = Bitmap.createBitmap(10, 10, Config.ARGB_8888);
        PendingIntent pendingIntent = PendingIntent.getActivity(mContext, 0, new Intent(), PendingIntent.FLAG_MUTABLE_UNAUDITED);
        Notification page1 = new Notification.Builder(mContext, ""test id"")
            .setSmallIcon(1)
            .setContentTitle(""page1"")
            .build();
        Notification page2 = new Notification.Builder(mContext, ""test id"")
            .setSmallIcon(1)
            .setContentTitle(""page2"")
            .build();
        List<Notification> pages = new ArrayList<>();
        pages.add(page2);
        final int gravity = Gravity.LEFT;
        final int icon = 3;
        final int height = 4;
        final int size = 5;
        final int timeout = 6;

        Notification notif = new Notification.Builder(mContext, ""test id"")
                .setSmallIcon(1)
                .setContentTitle(""test_title"")
                .extend(new Notification.WearableExtender()
                        .setStartScrollBottom(true)
                        .setContentIntentAvailableOffline(true)
                        .setHintContentIntentLaunchesActivity(true)
                        .setBridgeTag(bridgeTag)
                        .setDismissalId(dismissalId)
                        .addAction(action)
                        .setContentAction(contentActionIndex)
                        // deprecated methods follow
                        .setBackground(background)
                        .setGravity(gravity)
                        .setContentIcon(icon)
                        .setContentIconGravity(gravity)
                        .setCustomContentHeight(height)
                        .setCustomSizePreset(size)
                        .setDisplayIntent(pendingIntent)
                        .setHintAmbientBigPicture(true)
                        .setHintAvoidBackgroundClipping(true)
                        .setHintHideIcon(true)
                        .setHintScreenTimeout(timeout)
                        .setHintShowBackgroundOnly(true)
                        .addPage(page1))
                .build();

        Parcel parcel = Parcel.obtain();
        notif.writeToParcel(parcel, 0);
        parcel.setDataPosition(0);
        Notification result = new Notification(parcel);

        WearableExtender extender = new WearableExtender(result);
        assertTrue(extender.getStartScrollBottom());
        assertTrue(extender.getContentIntentAvailableOffline());
        assertTrue(extender.getHintContentIntentLaunchesActivity());
        assertEquals(bridgeTag, extender.getBridgeTag());
        assertEquals(dismissalId, extender.getDismissalId());
        assertEquals(contentActionIndex, extender.getContentAction());
        assertEquals(1, extender.getActions().size());
        // deprecated methods follow
        assertNotNull(extender.getBackground());
        assertEquals(gravity, extender.getGravity());
        assertEquals(icon, extender.getContentIcon());
        assertEquals(gravity, extender.getContentIconGravity());
        assertEquals(height, extender.getCustomContentHeight());
        assertEquals(size, extender.getCustomSizePreset());
        assertEquals(pendingIntent, extender.getDisplayIntent());
        assertTrue(extender.getHintAmbientBigPicture());
        assertTrue(extender.getHintAvoidBackgroundClipping());
        assertTrue(extender.getHintHideIcon());
        assertEquals(timeout, extender.getHintScreenTimeout());
        assertTrue(extender.getHintShowBackgroundOnly());
        assertEquals(1, extender.getPages().size());
    }

    private static Notification.Action.Builder newActionBuilder() {
        return new Notification.Action.Builder(0, ""title"", null);
    }

    /** Notification.Action.WearableExtender functions */"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/WearableExtenderTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.app.cts.WearableExtenderTest"	"testWearableExtenderActions"	"CtsAppTestCases"	"1: ui"	"public void testWearableExtenderActions() {
        Notification.Action a = newActionBuilder().build();
        Notification.Action b = newActionBuilder().build();
        Notification.Action c = newActionBuilder().build();
        List<Action> actions = new ArrayList<>();
        actions.add(b);
        actions.add(c);

        WearableExtender extender = new WearableExtender()
                .addAction(a)
                .addActions(actions)
                .setContentAction(1);

        assertEquals(3, extender.getActions().size());
        assertEquals(b, extender.getActions().get(extender.getContentAction()));
    }"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/WearableExtenderTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.app.cts.WearableExtenderTest"	"testWearableExtender_clearActions"	"CtsAppTestCases"	"1: ui"	"public void testWearableExtender_clearActions() {
        WearableExtender extender = new WearableExtender()
                .addAction(newActionBuilder().build());

        extender.clearActions();

        assertEquals(0, extender.getActions().size());
    }"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/WearableExtenderTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.app.cts.WearableExtenderTest"	"testWearableExtender_clone"	"CtsAppTestCases"	"1: ui"	"public void testWearableExtender_clone() {
        final String bridgeTag = ""bridge_tag"";
        final String dismissalId = ""dismissal_id"";
        final int contentActionIndex = 2;
        WearableExtender original = new WearableExtender()
                .addAction(newActionBuilder().build())
                .setStartScrollBottom(true)
                .setContentIntentAvailableOffline(true)
                .setHintContentIntentLaunchesActivity(true)
                .setBridgeTag(bridgeTag)
                .setDismissalId(dismissalId)
                .setContentAction(contentActionIndex);

        // WHEN the enter is cloned
        WearableExtender clone = original.clone();
        // and WHEN the original is modified
        original.clearActions();

        assertTrue(clone.getStartScrollBottom());
        assertTrue(clone.getContentIntentAvailableOffline());
        assertTrue(clone.getHintContentIntentLaunchesActivity());
        assertEquals(bridgeTag, clone.getBridgeTag());
        assertEquals(dismissalId, clone.getDismissalId());
        assertEquals(contentActionIndex, clone.getContentAction());
        assertEquals(1, clone.getActions().size());
    }"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/WearableExtenderTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.app.cts.WearableExtenderTest"	"testWearableExtender_extend"	"CtsAppTestCases"	"1: ui"	"public void testWearableExtender_extend() {
        final String title = ""test_title"";
        final String bridgeTag = ""bridge_tag"";
        final String dismissalId = ""dismissal_id"";
        final int contentActionIndex = 2;
        Notification.Builder notifBuilder = new Notification.Builder(mContext, ""test id"")
                .setSmallIcon(1)
                .setContentTitle(title);
        WearableExtender extender = new WearableExtender()
                .addAction(newActionBuilder().build())
                .setStartScrollBottom(true)
                .setContentIntentAvailableOffline(true)
                .setHintContentIntentLaunchesActivity(true)
                .setBridgeTag(bridgeTag)
                .setDismissalId(dismissalId)
                .setContentAction(contentActionIndex);

        extender.extend(notifBuilder);

        WearableExtender result = new WearableExtender(notifBuilder.build());
        assertTrue(result.getStartScrollBottom());
        assertTrue(result.getContentIntentAvailableOffline());
        assertTrue(result.getHintContentIntentLaunchesActivity());
        assertEquals(bridgeTag, result.getBridgeTag());
        assertEquals(dismissalId, result.getDismissalId());
        assertEquals(contentActionIndex, result.getContentAction());
        assertEquals(1, result.getActions().size());
    }"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/WearableExtenderTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.app.cts.WearableExtenderTest"	"testActionWearableExtender_constructor_copy"	"CtsAppTestCases"	"1: ui"	"public void testActionWearableExtender_constructor_copy() {
        Action.WearableExtender extender = new Action.WearableExtender();

        // set a flag to ensure flags are copied correctly
        extender.setAvailableOffline(false);

        // deprecated setters
        extender.setInProgressLabel(""inProgress"");
        extender.setConfirmLabel(""confirm"");
        extender.setCancelLabel(""cancel"");

        Action action = extender.extend(newActionBuilder()).build();

        Action.WearableExtender copiedExtender = new Action.WearableExtender(action);

        assertEquals(""available offline set via flags"", false, copiedExtender.isAvailableOffline());

        // deprecated getters
        assertEquals(""has correct progress label"", ""inProgress"", copiedExtender.getInProgressLabel());
        assertEquals(""has correct confirm label"", ""confirm"", copiedExtender.getConfirmLabel());
        assertEquals(""has correct cancel label"", ""cancel"", copiedExtender.getCancelLabel());
    }"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/WearableExtenderTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.view.accessibility.cts.AccessibilityActionTest"	"testParcel"	"CtsAccessibilityTestCases"	"1: system"	"public void testParcel() {
        AccessibilityAction systemAction =
                new AccessibilityAction(ACTION_ID, LABEL);

        final Parcel parcel = Parcel.obtain();
        systemAction.writeToParcel(parcel, systemAction.describeContents());
        parcel.setDataPosition(0);
        AccessibilityAction result =
                AccessibilityAction.CREATOR.createFromParcel(parcel);

        assertEquals(ACTION_ID, result.getId());
        assertEquals(LABEL, result.getLabel());
    }

    /**
     * Tests constructor of the class.
     */"	"/home/gpoor/cts-12-source/cts/tests/accessibility/src/android/view/accessibility/cts/AccessibilityActionTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.view.accessibility.cts.AccessibilityActionTest"	"testConstructor"	"CtsAccessibilityTestCases"	"1: system"	"public void testConstructor() {
        AccessibilityAction systemAction =
                new AccessibilityAction(ACTION_ID, LABEL);

        assertEquals(ACTION_ID, systemAction.getId());
        assertEquals(LABEL, systemAction.getLabel());
    }

}"	"/home/gpoor/cts-12-source/cts/tests/accessibility/src/android/view/accessibility/cts/AccessibilityActionTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.verifier.sensors.GyroscopeMeasurementTestActivity"	"GyroscopeMeasurementTestActivity"	""	"2: ui user"	"public void test/*
 *.
 */

package com.android.cts.verifier.sensors;

import com.android.cts.verifier.R;
import com.android.cts.verifier.sensors.base.SensorCtsVerifierTestActivity;
import com.android.cts.verifier.sensors.renderers.GLRotationGuideRenderer;

import android.hardware.Sensor;
import android.hardware.SensorManager;
import android.hardware.cts.helpers.SensorCalibratedUncalibratedVerifier;
import android.hardware.cts.helpers.TestSensorEnvironment;
import android.hardware.cts.helpers.sensoroperations.TestSensorOperation;
import android.hardware.cts.helpers.sensorverification.GyroscopeIntegrationVerification;

import java.util.concurrent.TimeUnit;

/**
 * Semi-automated test that focuses on characteristics associated with Gyroscope measurements.
 */
public class GyroscopeMeasurementTestActivity extends SensorCtsVerifierTestActivity {
    private static final float THRESHOLD_CALIBRATED_UNCALIBRATED_RAD_SEC = 0.01f;
    private static final float THRESHOLD_AXIS_UNDER_ROTATION_DEG = 10.0f;
    private static final float THRESHOLD_AXIS_UNDER_NO_ROTATION_DEG = 50.0f;

    private static final int ROTATE_360_DEG = 360;
    private static final int ROTATION_COLLECTION_SEC = 10;

    private static final int X_AXIS = 0;
    private static final int Y_AXIS = 1;
    private static final int Z_AXIS = 2;

    private final GLRotationGuideRenderer mRenderer = new GLRotationGuideRenderer();

    public GyroscopeMeasurementTestActivity() {
        super(GyroscopeMeasurementTestActivity.class, true);
    }

    @Override
    protected void activitySetUp() throws InterruptedException {
        getTestLogger().logInstructions(R.string.snsr_gyro_device_placement);
        waitForUserToContinue();
        initializeGlSurfaceView(mRenderer);
    }

    @Override
    protected void activityCleanUp() {
        closeGlSurfaceView();
    }

    @SuppressWarnings(""unused"")
    public String testDeviceStatic() throws Throwable {
        return verifyMeasurements(
                R.string.snsr_gyro_device_static,
                -1 /* rotationAxis */,
                0 /* expectationDeg */);
    }

    @SuppressWarnings(""unused"")
    public String testRotateClockwise() throws Throwable {
        return verifyMeasurements(R.string.snsr_gyro_rotate_device, Z_AXIS, -ROTATE_360_DEG);
    }

    @SuppressWarnings(""unused"")
    public String testRotateCounterClockwise() throws Throwable {
        return verifyMeasurements(R.string.snsr_gyro_rotate_device, Z_AXIS, ROTATE_360_DEG);
    }

    @SuppressWarnings(""unused"")
    public String testRotateRightSide() throws Throwable {
        return verifyMeasurements(R.string.snsr_gyro_rotate_device, Y_AXIS, ROTATE_360_DEG);
    }

    @SuppressWarnings(""unused"")
    public String testRotateLeftSide() throws Throwable {
        return verifyMeasurements(R.string.snsr_gyro_rotate_device, Y_AXIS, -ROTATE_360_DEG);
    }

    @SuppressWarnings(""unused"")
    public String testRotateTopSide() throws Throwable {
        return verifyMeasurements(R.string.snsr_gyro_rotate_device, X_AXIS, -ROTATE_360_DEG);
    }

    @SuppressWarnings(""unused"")
    public String testRotateBottomSide() throws Throwable {
        return verifyMeasurements(R.string.snsr_gyro_rotate_device, X_AXIS, ROTATE_360_DEG);
    }

    /**
     * Verifies that the relationship between readings from calibrated and their corresponding
     * uncalibrated sensors comply to the following equation:
     *      calibrated = uncalibrated - bias
     */
    @SuppressWarnings(""unused"")
    public String testCalibratedAndUncalibrated() throws Throwable {
        setRendererRotation(Z_AXIS, false);

        setFirstExecutionInstruction(R.string.snsr_keep_device_rotating_clockwise);

        getTestLogger().logWaitForSound();

        TestSensorEnvironment calibratedEnvironment = new TestSensorEnvironment(
                getApplicationContext(),
                Sensor.TYPE_GYROSCOPE,
                SensorManager.SENSOR_DELAY_FASTEST);
        TestSensorEnvironment uncalibratedEnvironment = new TestSensorEnvironment(
                getApplicationContext(),
                Sensor.TYPE_GYROSCOPE_UNCALIBRATED,
                SensorManager.SENSOR_DELAY_FASTEST);
        SensorCalibratedUncalibratedVerifier verifier = new SensorCalibratedUncalibratedVerifier(
                calibratedEnvironment,
                uncalibratedEnvironment,
                THRESHOLD_CALIBRATED_UNCALIBRATED_RAD_SEC);

        try {
            verifier.execute();
        } finally {
            playSound();
        }
        return null;
    }

    /**
     * This test verifies that the Gyroscope measures the appropriate angular position.
     *
     * The test takes a set of samples from the sensor under test and calculates the angular
     * position for each axis that the sensor data collects. It then compares it against the test
     * expectations that are represented by signed values. It verifies that the readings have the
     * right magnitude.
     */
    private String verifyMeasurements(int instructionsResId, int rotationAxis, int expectationDeg)
            throws Throwable {
        setRendererRotation(rotationAxis, expectationDeg >= 0);

        setFirstExecutionInstruction(instructionsResId);

        getTestLogger().logWaitForSound();

        TestSensorEnvironment environment = new TestSensorEnvironment(
                getApplicationContext(),
                Sensor.TYPE_GYROSCOPE,
                SensorManager.SENSOR_DELAY_FASTEST);
        TestSensorOperation sensorOperation = TestSensorOperation
                .createOperation(environment, ROTATION_COLLECTION_SEC, TimeUnit.SECONDS);

        int gyroscopeAxes = environment.getSensorAxesCount();
        int[] expectationsDeg = getExpectationsDeg(gyroscopeAxes, rotationAxis, expectationDeg);
        float[] thresholdsDeg = getThresholdsDeg(gyroscopeAxes, rotationAxis);
        GyroscopeIntegrationVerification integrationVerification =
                new GyroscopeIntegrationVerification(expectationsDeg, thresholdsDeg);
        sensorOperation.addVerification(integrationVerification);

        try {
            sensorOperation.execute(getCurrentTestNode());
        } finally {
            playSound();
        }
        return null;
    }

    private int[] getExpectationsDeg(int axes, int rotationAxis, int expectationDeg) {
        int[] expectationsDeg = new int[axes];
        for (int i = 0; i < axes; ++i) {
            // tests assume that rotation is expected on one axis at a time
            expectationsDeg[i] = (i == rotationAxis) ? expectationDeg : 0;
        }
        return expectationsDeg;
    }

    private float[] getThresholdsDeg(int axes, int rotationAxis) {
        float[] thresholdsDeg = new float[axes];
        for (int i = 0; i < axes; ++i) {
            // tests set a high threshold on the axes where rotation is not expected, to account
            // for movement from the operator
            // the rotation axis has a lower threshold to ensure the gyroscope's accuracy
            thresholdsDeg[i] = (i == rotationAxis)
                    ? THRESHOLD_AXIS_UNDER_ROTATION_DEG
                    : THRESHOLD_AXIS_UNDER_NO_ROTATION_DEG;
        }
        return thresholdsDeg;
    }

    private void setRendererRotation(int rotationAxis, boolean positiveRotation) {
        int axis1 = 0;
        int axis2 = 0;
        int axis3 = 0;
        switch (rotationAxis) {
            case X_AXIS:
                axis1 = positiveRotation ? 1 : -1;
                break;
            case Y_AXIS:
                axis2 = positiveRotation ? 1 : -1;
                break;
            case Z_AXIS:
                axis3 = positiveRotation ? 1 : -1;
                break;
        }
        mRenderer.setRotation(axis1, axis2, axis3);
    }
}"	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/sensors/GyroscopeMeasurementTestActivity.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.util.cts.EventLogTest"	"testWriteEventWithOversizeValueLimitElision"	"CtsUtilTestCases"	"2: ui system"	"public void testWriteEventWithOversizeValueLimitElision() throws Exception {
        // make sure big events are postsed and only elided to no less than about 4K.
        StringBuilder longString = new StringBuilder();
        for (int i = 0; i < 1000; i++) longString.append(""xyzzy"");

        Object[] longArray = new Object[1000];
        for (int i = 0; i < 1000; i++) longArray[i] = 12345;

        Long markerData = System.currentTimeMillis();
        EventLog.writeEvent(ANSWER_TAG, markerData);
        EventLog.writeEvent(ANSWER_TAG, longString.toString());
        EventLog.writeEvent(ANSWER_TAG, ""hi"", longString.toString());
        EventLog.writeEvent(ANSWER_TAG, 12345, longString.toString());
        EventLog.writeEvent(ANSWER_TAG, 12345L, longString.toString());
        EventLog.writeEvent(ANSWER_TAG, 42.4242f, longString.toString());
        EventLog.writeEvent(ANSWER_TAG, longString.toString(), longString.toString());
        EventLog.writeEvent(ANSWER_TAG, longArray);
        List<Event> events = getEventsAfterMarker(markerData, ANSWER_TAG);
        assertEquals(7, events.size());

        final int big = 4000; // expect at least this many bytes to get through.

        // subtract: string header (type + length)
        String val0 = (String) events.get(0).getData();
        assertNull(""getData on object 0 raised a WTF"", events.get(0).getLastError());
        assertTrue(""big string 0 seems short"", big < val0.length());

        // subtract: array header, ""hi"" header, ""hi"", string header
        Object[] arr1 = (Object[]) events.get(1).getData();
        assertNull(""getData on object 1 raised a WTF"", events.get(1).getLastError());
        assertEquals(2, arr1.length);
        assertEquals(""hi"", arr1[0]);
        assertTrue(""big string 1 seems short"", big < ((String) arr1[1]).length());

        // subtract: array header, int (type + value), string header
        Object[] arr2 = (Object[]) events.get(2).getData();
        assertNull(""getData on object 2 raised a WTF"", events.get(2).getLastError());
        assertEquals(2, arr2.length);
        assertEquals(12345, arr2[0]);
        assertTrue(""big string 2 seems short"", big < ((String) arr2[1]).length());

        // subtract: array header, long, string header
        Object[] arr3 = (Object[]) events.get(3).getData();
        assertNull(""getData on object 3 raised a WTF"", events.get(3).getLastError());
        assertEquals(2, arr3.length);
        assertEquals(12345L, arr3[0]);
        assertTrue(""big string 3 seems short"", big < ((String) arr3[1]).length());

        // subtract: array header, float, string header
        Object[] arr4 = (Object[]) events.get(4).getData();
        assertNull(""getData on object 4 raised a WTF"", events.get(4).getLastError());
        assertEquals(2, arr4.length);
        assertEquals(42.4242f, arr4[0]);
        assertTrue(""big string 4 seems short"", big < ((String) arr4[1]).length());

        // subtract: array header, string header (second string is dropped entirely)
        String string5 = (String) events.get(5).getData();
        assertNull(""getData on object 5 raised a WTF"", events.get(5).getLastError());
        assertTrue(""big string 5 seems short"", big < string5.length());

        Object[] arr6 = (Object[]) events.get(6).getData();
        assertNull(""getData on object 6 raised a WTF"", events.get(6).getLastError());
        assertEquals(255, arr6.length);
        assertEquals(12345, arr6[0]);
        assertEquals(12345, arr6[arr6.length - 1]);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/util/src/android/util/cts/EventLogTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.util.cts.EventLogTest"	"testOversizeStringMayBeTruncated"	"CtsUtilTestCases"	"2: ui system"	"public void testOversizeStringMayBeTruncated() throws Exception {
        // make sure big events elide from the end, not the  from the front or middle.
        StringBuilder longBuilder = new StringBuilder();

        // build a long string where the prefix is never repeated
        for (int step = 1; step < 256; step += 2) { // all odds are relatively prime to 256
            for (int i = 0; i < 255; i++) {
                longBuilder.append(String.valueOf((char) (((step * i) % 256) + 1))); // never emit 0
            }
        }
        String longString = longBuilder.toString(); // 32K

        Long markerData = System.currentTimeMillis();
        EventLog.writeEvent(ANSWER_TAG, markerData);
        EventLog.writeEvent(ANSWER_TAG, longString);

        List<Event> events = getEventsAfterMarker(markerData, ANSWER_TAG);
        assertEquals(1, events.size());

        // subtract: string header (type + length)
        String out = (String) events.get(0).getData();
        assertNull(""getData on big string raised a WTF"", events.get(0).getLastError());
        assertEquals(""output is not a prefix of the input"", 0, longString.indexOf(out), 0);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/util/src/android/util/cts/EventLogTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.util.cts.EventLogTest"	"testWriteEvent"	"CtsUtilTestCases"	"1: system"	"public void testWriteEvent() throws Exception {
        long markerData = System.currentTimeMillis();
        EventLog.writeEvent(ANSWER_TAG, markerData);
        EventLog.writeEvent(ANSWER_TAG, 12345);
        EventLog.writeEvent(ANSWER_TAG, 23456L);
        EventLog.writeEvent(ANSWER_TAG, 42.4242f);
        EventLog.writeEvent(ANSWER_TAG, ""Test"");
        EventLog.writeEvent(ANSWER_TAG, 12345, 23456L, 42.4242f, ""Test"");

        List<EventLog.Event> events = getEventsAfterMarker(markerData, ANSWER_TAG);
        assertEquals(5, events.size());
        assertEquals(ANSWER_TAG, events.get(0).getTag());
        assertEquals(12345, events.get(0).getData());
        assertEquals(23456L, events.get(1).getData());
        assertEquals(42.4242f, events.get(2).getData());
        assertEquals(""Test"", events.get(3).getData());

        Object[] arr = (Object[]) events.get(4).getData();
        assertEquals(4, arr.length);
        assertEquals(12345, arr[0]);
        assertEquals(23456L, arr[1]);
        assertEquals(42.4242f, arr[2]);
        assertEquals(""Test"", arr[3]);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/util/src/android/util/cts/EventLogTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.util.cts.EventLogTest"	"testWriteNullEvent"	"CtsUtilTestCases"	"1: system"	"public void testWriteNullEvent() throws Exception {
        Long markerData = System.currentTimeMillis();
        EventLog.writeEvent(ANSWER_TAG, markerData);
        EventLog.writeEvent(ANSWER_TAG, (String) null);
        EventLog.writeEvent(ANSWER_TAG, 12345, null);

        List<EventLog.Event> events = getEventsAfterMarker(markerData, ANSWER_TAG);
        assertEquals(2, events.size());
        assertEquals(""NULL"", events.get(0).getData());

        Object[] arr = (Object[]) events.get(1).getData();
        assertEquals(2, arr.length);
        assertEquals(12345, arr[0]);
        assertEquals(""NULL"", arr[1]);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/util/src/android/util/cts/EventLogTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.util.cts.EventLogTest"	"testReadDataWhenNone"	"CtsUtilTestCases"	"1: system"	"public void testReadDataWhenNone() throws Exception {
        Long markerData = System.currentTimeMillis();
        EventLog.writeEvent(ANSWER_TAG, markerData);
        EventLog.writeEvent(ANSWER_TAG);

        List<EventLog.Event> events = getEventsAfterMarker(markerData, ANSWER_TAG);
        assertEquals(1, events.size());
        assertEquals(""getData on empty data did not return null"", null, events.get(0).getData());
        assertNull(""getData on object 0 raised a WTF"", events.get(0).getLastError());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/util/src/android/util/cts/EventLogTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.util.cts.EventLogTest"	"testReadEvents"	"CtsUtilTestCases"	"1: system"	"public void testReadEvents() throws Exception {
        Long markerData = System.currentTimeMillis();
        EventLog.writeEvent(ANSWER_TAG, markerData);

        Long data0 = markerData + 1;
        EventLog.writeEvent(ANSWER_TAG, data0);

        Long data1 = data0 + 1;
        EventLog.writeEvent(PI_TAG, data1);

        Long data2 = data1 + 1;
        EventLog.writeEvent(E_TAG, data2);

        List<Event> events = getEventsAfterMarker(markerData, ANSWER_TAG, PI_TAG, E_TAG);
        assertEquals(3, events.size());
        verifyEvent(events.get(0), ANSWER_TAG, data0);
        verifyEvent(events.get(1), PI_TAG, data1);
        verifyEvent(events.get(2), E_TAG, data2);

        events = getEventsAfterMarker(markerData, ANSWER_TAG, E_TAG);
        assertEquals(2, events.size());
        verifyEvent(events.get(0), ANSWER_TAG, data0);
        verifyEvent(events.get(1), E_TAG, data2);

        events = getEventsAfterMarker(markerData, ANSWER_TAG);
        assertEquals(1, events.size());
        verifyEvent(events.get(0), ANSWER_TAG, data0);
    }

    /** Return elements after and the event that has the marker data and matching tag. */
    private List<Event> getEventsAfterMarker(Object marker, int... tags)
            throws IOException, InterruptedException {
        List<Event> events = new ArrayList<>();
        // Give the message some time to show up in the log
        Thread.sleep(20);
        EventLog.readEvents(tags, events);

        for (Iterator<Event> itr = events.iterator(); itr.hasNext(); ) {
            Event event = itr.next();
            itr.remove();
            if (marker.equals(event.getData())) {
                break;
            }
        }

        verifyEventTimes(events);

        return events;
    }

    private void verifyEvent(Event event, int expectedTag, Object expectedData) {
        assertEquals(Process.myPid(), event.getProcessId());
        assertEquals(Process.myTid(), event.getThreadId());
        assertEquals(expectedTag, event.getTag());
        assertEquals(expectedData, event.getData());
    }

    private void verifyEventTimes(List<Event> events) {
        for (int i = 0; i + 1 < events.size(); i++) {
            long time = events.get(i).getTimeNanos();
            long nextTime = events.get(i).getTimeNanos();
            assertTrue(time <= nextTime);
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/util/src/android/util/cts/EventLogTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.compatibility.common.util.SystemUtil"	"grantRuntimePermission"	""	"5: mic direct ui system user"	"public void test/*
 *.
 */

package com.android.compatibility.common.util;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import android.app.ActivityManager;
import android.app.ActivityManager.MemoryInfo;
import android.app.Instrumentation;
import android.app.UiAutomation;
import android.content.Context;
import android.os.ParcelFileDescriptor;
import android.os.StatFs;
import android.util.Log;

import androidx.annotation.NonNull;
import androidx.test.InstrumentationRegistry;

import com.android.modules.utils.build.SdkLevel;

import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.concurrent.Callable;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Predicate;

public class SystemUtil {
    private static final String TAG = ""CtsSystemUtil"";
    private static final long TIMEOUT_MILLIS = 10000;

    public static long getFreeDiskSize(Context context) {
        final StatFs statFs = new StatFs(context.getFilesDir().getAbsolutePath());
        return (long)statFs.getAvailableBlocks() * statFs.getBlockSize();
    }

    public static long getFreeMemory(Context context) {
        final MemoryInfo info = new MemoryInfo();
        ((ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE)).getMemoryInfo(info);
        return info.availMem;
    }

    public static long getTotalMemory(Context context) {
        final MemoryInfo info = new MemoryInfo();
        ((ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE)).getMemoryInfo(info);
        return info.totalMem;
    }

    /**
     * Executes a shell command using shell user identity, and return the standard output in string
     * <p>Note: calling this function requires API level 21 or above
     * @param instrumentation {@link Instrumentation} instance, obtained from a test running in
     * instrumentation framework
     * @param cmd the command to run
     * @return the standard output of the command
     * @throws Exception
     */
    public static String runShellCommand(Instrumentation instrumentation, String cmd)
            throws IOException {
        return runShellCommand(instrumentation.getUiAutomation(), cmd);
    }

    /**
     * Executes a shell command using shell user identity, and return the standard output in string
     * <p>Note: calling this function requires API level 21 or above
     * @param automation {@link UiAutomation} instance, obtained from a test running in
     * instrumentation framework
     * @param cmd the command to run
     * @return the standard output of the command
     * @throws Exception
     */
    public static String runShellCommand(UiAutomation automation, String cmd)
            throws IOException {
        return new String(runShellCommandByteOutput(automation, cmd));
    }

    /**
     * Executes a shell command using shell user identity, and return the standard output as a byte
     * array
     * <p>Note: calling this function requires API level 21 or above
     *
     * @param automation {@link UiAutomation} instance, obtained from a test running in
     *                   instrumentation framework
     * @param cmd        the command to run
     * @return the standard output of the command as a byte array
     */
    static byte[] runShellCommandByteOutput(UiAutomation automation, String cmd)
            throws IOException {
        checkCommandBeforeRunning(cmd);
        ParcelFileDescriptor pfd = automation.executeShellCommand(cmd);
        try (FileInputStream fis = new ParcelFileDescriptor.AutoCloseInputStream(pfd)) {
            return FileUtils.readInputStreamFully(fis);
        }
    }

    private static void checkCommandBeforeRunning(String cmd) {
        Log.v(TAG, ""Running command: "" + cmd);
        if (cmd.startsWith(""pm grant "") || cmd.startsWith(""pm revoke "")) {
            throw new UnsupportedOperationException(""Use UiAutomation.grantRuntimePermission() ""
                    + ""or revokeRuntimePermission() directly, which are more robust."");
        }
    }

    /**
     * Simpler version of {@link #runShellCommand(Instrumentation, String)}.
     */
    public static String runShellCommand(String cmd) {
        try {
            return runShellCommand(InstrumentationRegistry.getInstrumentation(), cmd);
        } catch (IOException e) {
            fail(""Failed reading command output: "" + e);
            return """";
        }
    }

    /**
     * Like {@link #runShellCommand(String)} but throws if anything was printed to stderr on S+, and
     * delegates to {@link #runShellCommand(String)} on older platforms for compatibility.
     */
    public static String runShellCommandOrThrow(String cmd) {
        if (!SdkLevel.isAtLeastS()) {
            return runShellCommand(cmd);
        }
        UiAutomation automation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            checkCommandBeforeRunning(cmd);

            ParcelFileDescriptor[] fds = automation.executeShellCommandRwe(cmd);
            ParcelFileDescriptor fdOut = fds[0];
            ParcelFileDescriptor fdIn = fds[1];
            ParcelFileDescriptor fdErr = fds[2];

            if (fdIn != null) {
                try {
                    // not using stdin
                    fdIn.close();
                } catch (Exception e) {
                    // Ignore
                }
            }

            String out;
            String err;
            try (FileInputStream fis = new ParcelFileDescriptor.AutoCloseInputStream(fdOut)) {
                out = new String(FileUtils.readInputStreamFully(fis));
            }
            try (FileInputStream fis = new ParcelFileDescriptor.AutoCloseInputStream(fdErr)) {
                err = new String(FileUtils.readInputStreamFully(fis));
            }
            if (!err.isEmpty()) {
                fail(""Command failed:\n$ "" + cmd +
                        ""\n\nstderr:\n"" + err +
                        ""\n\nstdout:\n"" + out);
            }
            return out;
        } catch (IOException e) {
            fail(""Failed reading command output: "" + e);
            return """";
        }
    }

    /**
     * Same as {@link #runShellCommand(String)}, with optionally
     * check the result using {@code resultChecker}.
     */
    public static String runShellCommand(String cmd, Predicate<String> resultChecker) {
        final String result = runShellCommand(cmd);
        if (resultChecker != null) {
            assertTrue(""Assertion failed. Command was: "" + cmd + ""\n""
                    + ""Output was:\n"" + result,
                    resultChecker.test(result));
        }
        return result;
    }

    /**
     * Same as {@link #runShellCommand(String)}, but fails if the output is not empty.
     */
    public static String runShellCommandForNoOutput(String cmd) {
        final String result = runShellCommand(cmd);
        assertTrue(""Command failed. Command was: "" + cmd + ""\n""
                + ""Didn't expect any output, but the output was:\n"" + result,
                result.length() == 0);
        return result;
    }

    /**
     * Runs a command and print the result on logcat.
     */
    public static void runCommandAndPrintOnLogcat(String logtag, String cmd) {
        Log.i(logtag, ""Executing: "" + cmd);
        final String output = runShellCommand(cmd);
        for (String line : output.split(""\\n"", -1)) {
            Log.i(logtag, line);
        }
    }

    /**
     * Runs a command and return the section matching the patterns.
     *
     * @see TextUtils#extractSection
     */
    public static String runCommandAndExtractSection(String cmd,
            String extractionStartRegex, boolean startInclusive,
            String extractionEndRegex, boolean endInclusive) {
        return TextUtils.extractSection(runShellCommand(cmd), extractionStartRegex, startInclusive,
                extractionEndRegex, endInclusive);
    }

    /**
     * Runs a {@link ThrowingSupplier} adopting Shell's permissions, and returning the result.
     */
    public static <T> T runWithShellPermissionIdentity(@NonNull ThrowingSupplier<T> supplier) {
        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        AtomicReference<T> result = new AtomicReference<>();
        runWithShellPermissionIdentity(automan, () -> result.set(supplier.get()));
        return result.get();
    }

    /**
     * Runs a {@link ThrowingSupplier} adopting a subset of Shell's permissions,
     * and returning the result.
     */
    public static <T> T runWithShellPermissionIdentity(@NonNull ThrowingSupplier<T> supplier,
            String... permissions) {
        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        AtomicReference<T> result = new AtomicReference<>();
        runWithShellPermissionIdentity(automan, () -> result.set(supplier.get()), permissions);
        return result.get();
    }

    /**
     * Runs a {@link ThrowingRunnable} adopting Shell's permissions.
     */
    public static void runWithShellPermissionIdentity(@NonNull ThrowingRunnable runnable) {
        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        runWithShellPermissionIdentity(automan, runnable);
    }

    /**
     * Runs a {@link ThrowingRunnable} adopting a subset of Shell's permissions.
     */
    public static void runWithShellPermissionIdentity(@NonNull ThrowingRunnable runnable,
            String... permissions) {
        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        runWithShellPermissionIdentity(automan, runnable, permissions);
    }

    /**
     * Runs a {@link ThrowingRunnable} adopting Shell's permissions, where you can specify the
     * uiAutomation used.
     */
    public static void runWithShellPermissionIdentity(
            @NonNull UiAutomation automan, @NonNull ThrowingRunnable runnable) {
        runWithShellPermissionIdentity(automan, runnable, null /* permissions */);
    }

    /**
     * Runs a {@link ThrowingRunnable} adopting Shell's permissions, where you can specify the
     * uiAutomation used.
     * @param automan UIAutomation to use.
     * @param runnable The code to run with Shell's identity.
     * @param permissions A subset of Shell's permissions. Passing {@code null} will use all
     *                    available permissions.
     */
    public static void runWithShellPermissionIdentity(@NonNull UiAutomation automan,
            @NonNull ThrowingRunnable runnable, String... permissions) {
        automan.adoptShellPermissionIdentity(permissions);
        try {
            runnable.run();
        } catch (Exception e) {
            throw new RuntimeException(""Caught exception"", e);
        } finally {
            automan.dropShellPermissionIdentity();
        }
    }

    /**
     * Calls a {@link Callable} adopting Shell's permissions.
     */
    public static <T> T callWithShellPermissionIdentity(@NonNull Callable<T> callable)
            throws Exception {
        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        automan.adoptShellPermissionIdentity();
        try {
            return callable.call();
        } finally {
            automan.dropShellPermissionIdentity();
        }
    }

    /**
     * Calls a {@link Callable} adopting Shell's permissions.
     *
     * @param callable The code to call with Shell's identity.
     * @param permissions A subset of Shell's permissions. Passing {@code null} will use all
     *                    available permissions.     */
    public static <T> T callWithShellPermissionIdentity(@NonNull Callable<T> callable,
            String... permissions) throws Exception {
        final UiAutomation automan = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        automan.adoptShellPermissionIdentity(permissions);
        try {
            return callable.call();
        } finally {
            automan.dropShellPermissionIdentity();
        }
    }

    /**
     * Make sure that a {@link Runnable} eventually finishes without throwing a {@link
     * Exception}.
     *
     * @param r The {@link Runnable} to run.
     */
    public static void eventually(@NonNull ThrowingRunnable r) {
        eventually(r, TIMEOUT_MILLIS);
    }

    /**
     * Make sure that a {@link Runnable} eventually finishes without throwing a {@link
     * Exception}.
     *
     * @param r The {@link Runnable} to run.
     * @param r The number of milliseconds to wait for r to not throw
     */
    public static void eventually(@NonNull ThrowingRunnable r, long timeoutMillis) {
        long start = System.currentTimeMillis();

        while (true) {
            try {
                r.run();
                return;
            } catch (Throwable e) {
                if (System.currentTimeMillis() - start < timeoutMillis) {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException ignored) {
                        throw new RuntimeException(e);
                    }
                } else {
                    throw new RuntimeException(e);
                }
            }
        }
    }

    /**
     * Make sure that a {@link Callable} eventually finishes without throwing a {@link
     * Exception}.
     *
     * @param c The {@link Callable} to run.
     *
     * @return The return value of {@code c}
     */
    public static <T> T getEventually(@NonNull Callable<T> c) throws Exception {
        return getEventually(c, TIMEOUT_MILLIS);
    }

    /**
     * Make sure that a {@link Callable} eventually finishes without throwing a {@link
     * Exception}.
     *
     * @param c The {@link Callable} to run.
     * @param timeoutMillis The number of milliseconds to wait for r to not throw
     *
     * @return The return value of {@code c}
     */
    public static <T> T getEventually(@NonNull Callable<T> c, long timeoutMillis) throws Exception {
        long start = System.currentTimeMillis();

        while (true) {
            try {
                return c.call();
            } catch (Throwable e) {
                if (System.currentTimeMillis() - start < timeoutMillis) {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException ignored) {
                        throw new RuntimeException(e);
                    }
                } else {
                    throw e;
                }
            }
        }
    }
}"	"/home/gpoor/cts-12-source/cts/common/device-side/util-axt/src/com/android/compatibility/common/util/SystemUtil.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.view.inputmethod.cts.util.TestActivity"	"finish"	"CtsInputMethodTestCases"	"2: mic ui"	"public void test/*
 *.
 */

package android.view.inputmethod.cts.util;

import static android.view.WindowManager.LayoutParams.SOFT_INPUT_STATE_UNCHANGED;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.view.Window;
import android.view.WindowManager;

import androidx.annotation.AnyThread;
import androidx.annotation.NonNull;
import androidx.annotation.UiThread;
import androidx.test.platform.app.InstrumentationRegistry;

import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Function;

public class TestActivity extends Activity {

    private static final AtomicReference<Function<TestActivity, View>> sInitializer =
            new AtomicReference<>();

    private Function<TestActivity, View> mInitializer = null;

    private AtomicBoolean mIgnoreBackKey = new AtomicBoolean();

    private long mOnBackPressedCallCount;

    /**
     * Controls how {@link #onBackPressed()} behaves.
     *
     * <p>TODO: Use {@link android.app.AppComponentFactory} instead to customise the behavior of
     * {@link TestActivity}.</p>
     *
     * @param ignore {@code true} when {@link TestActivity} should do nothing when
     *               {@link #onBackPressed()} is called
     */
    @AnyThread
    public void setIgnoreBackKey(boolean ignore) {
        mIgnoreBackKey.set(ignore);
    }

    @UiThread
    public long getOnBackPressedCallCount() {
        return mOnBackPressedCallCount;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        if (mInitializer == null) {
            mInitializer = sInitializer.get();
        }
        // Currently SOFT_INPUT_STATE_UNSPECIFIED isn't appropriate for CTS test because there is no
        // clear spec about how it behaves.  In order to make our tests deterministic, currently we
        // must use SOFT_INPUT_STATE_UNCHANGED.
        // TODO(Bug 77152727): Remove the following code once we define how
        // SOFT_INPUT_STATE_UNSPECIFIED actually behaves.
        setSoftInputState(SOFT_INPUT_STATE_UNCHANGED);
        setContentView(mInitializer.apply(this));
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void onBackPressed() {
        ++mOnBackPressedCallCount;
        if (mIgnoreBackKey.get()) {
            return;
        }
        super.onBackPressed();
    }

    /**
     * Launches {@link TestActivity} with the given initialization logic for content view.
     *
     * <p>As long as you are using {@link androidx.test.runner.AndroidJUnitRunner}, the test
     * runner automatically calls {@link Activity#finish()} for the {@link Activity} launched when
     * the test finished.  You do not need to explicitly call {@link Activity#finish()}.</p>
     *
     * @param activityInitializer initializer to supply {@link View} to be passed to
     *                           {@link Activity#setContentView(View)}
     * @return {@link TestActivity} launched
     */
    public static TestActivity startSync(
            @NonNull Function<TestActivity, View> activityInitializer) {
        return startSync(activityInitializer, 0 /* noAnimation */);
    }

    /**
     * Launches {@link TestActivity} with the given initialization logic for content view.
     *
     * <p>As long as you are using {@link androidx.test.runner.AndroidJUnitRunner}, the test
     * runner automatically calls {@link Activity#finish()} for the {@link Activity} launched when
     * the test finished.  You do not need to explicitly call {@link Activity#finish()}.</p>
     *
     * @param activityInitializer initializer to supply {@link View} to be passed to
     *                           {@link Activity#setContentView(View)}
     * @param additionalFlags flags to be set to {@link Intent#setFlags(int)}
     * @return {@link TestActivity} launched
     */
    public static TestActivity startSync(
            @NonNull Function<TestActivity, View> activityInitializer,
            int additionalFlags) {
        sInitializer.set(activityInitializer);
        final Intent intent = new Intent()
                .setAction(Intent.ACTION_MAIN)
                .setClass(InstrumentationRegistry.getInstrumentation().getContext(),
                        TestActivity.class)
                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                .addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK)
                .addFlags(additionalFlags);
        return (TestActivity) InstrumentationRegistry
                .getInstrumentation().startActivitySync(intent);
    }

    public static TestActivity startNewTaskSync(
            @NonNull Function<TestActivity, View> activityInitializer) {
        sInitializer.set(activityInitializer);
        final Intent intent = new Intent()
                .setAction(Intent.ACTION_MAIN)
                .setClass(InstrumentationRegistry.getInstrumentation().getContext(),
                        TestActivity.class)
                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                .addFlags(Intent.FLAG_ACTIVITY_NEW_DOCUMENT);
        return (TestActivity) InstrumentationRegistry
                .getInstrumentation().startActivitySync(intent);
    }


    public static TestActivity startSameTaskAndClearTopSync(
            @NonNull Function<TestActivity, View> activityInitializer) {
        sInitializer.set(activityInitializer);
        final Intent intent = new Intent()
                .setAction(Intent.ACTION_MAIN)
                .setClass(InstrumentationRegistry.getInstrumentation().getContext(),
                        TestActivity.class)
                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                .addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
        return (TestActivity) InstrumentationRegistry
                .getInstrumentation().startActivitySync(intent);
    }

    /**
     * Updates {@link WindowManager.LayoutParams#softInputMode}.
     *
     * @param newState One of {@link WindowManager.LayoutParams#SOFT_INPUT_STATE_UNSPECIFIED},
     *                 {@link WindowManager.LayoutParams#SOFT_INPUT_STATE_UNCHANGED},
     *                 {@link WindowManager.LayoutParams#SOFT_INPUT_STATE_HIDDEN},
     *                 {@link WindowManager.LayoutParams#SOFT_INPUT_STATE_ALWAYS_HIDDEN},
     *                 {@link WindowManager.LayoutParams#SOFT_INPUT_STATE_VISIBLE},
     *                 {@link WindowManager.LayoutParams#SOFT_INPUT_STATE_ALWAYS_VISIBLE}
     */
    private void setSoftInputState(int newState) {
        final Window window = getWindow();
        final int currentSoftInputMode = window.getAttributes().softInputMode;
        final int newSoftInputMode =
                (currentSoftInputMode & ~WindowManager.LayoutParams.SOFT_INPUT_MASK_STATE)
                        | newState;
        window.setSoftInputMode(newSoftInputMode);
    }
}"	"/home/gpoor/cts-12-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/util/TestActivity.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.host.multiuser.SecondaryUsersTest"	"testSwitchToSecondaryUserBeforeBootComplete"	"CtsMultiUserHostTestCases"	"4: ui system interaction user"	"public void testSwitchToSecondaryUserBeforeBootComplete() throws Exception {
        assumeIsAutomotive();

        getDevice().nonBlockingReboot();
        getDevice().waitForBootComplete(TimeUnit.MINUTES.toMillis(2));

        boolean isUserSecondary = false;
        long ti = System.currentTimeMillis();

        // TODO(b/138944230): Verify if current user is secondary when the UI is ready for user
        // interaction. A possibility is to check if the CarLauncher is started in the
        // Activity Stack, but this becomes tricky in OEM implementation, where CarLauncher is
        // replaced with another launcher. Launcher can usually identify by
        // android.intent.category.HOME (type=home) and priority = -1000. But there is no clear way
        // to determine this via adb.
        while (System.currentTimeMillis() - ti < SECONDARY_USER_BOOT_COMPLETE_TIMEOUT_MS) {
            isUserSecondary = getDevice().isUserSecondary(getDevice().getCurrentUser());
            if (isUserSecondary) {
                break;
            }
            Thread.sleep(POLL_INTERVAL_MS);
        }
        assertWithMessage(""Must switch to secondary user before boot complete"")
                .that(isUserSecondary).isTrue();
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/multiuser/src/android/host/multiuser/SecondaryUsersTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.hdmicec.cts.playback.HdmiCecDeviceSelectForPlaybackTest"	"HdmiCecDeviceSelectForPlaybackTest"	"CtsHdmiCecHostTestCases"	"2: mic ui"	"/*
 *.
 */

package android.hdmicec.cts.playback;

import android.hdmicec.cts.BaseHdmiCecCtsTest;
import android.hdmicec.cts.CecMessage;
import android.hdmicec.cts.CecOperand;
import android.hdmicec.cts.HdmiCecConstants;
import android.hdmicec.cts.LogicalAddress;

import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;

import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.RuleChain;
import org.junit.runner.RunWith;

import java.util.concurrent.TimeUnit;

/**
 * HDMI CEC test to verify the device selection API for playback devices
 */
@RunWith(DeviceJUnit4ClassRunner.class)
public class HdmiCecDeviceSelectForPlaybackTest extends BaseHdmiCecCtsTest {


    public HdmiCecDeviceSelectForPlaybackTest() {
        super(HdmiCecConstants.CEC_DEVICE_TYPE_PLAYBACK_DEVICE);
    }

    @Rule
    public RuleChain ruleChain =
            RuleChain.outerRule(CecRules.requiresCec(this))
                    .around(CecRules.requiresLeanback(this))
                    .around(
                            CecRules.requiresDeviceType(
                                    this, HdmiCecConstants.CEC_DEVICE_TYPE_PLAYBACK_DEVICE))
                    .around(hdmiCecClient);

    private String setPowerStateChangeOnActiveSourceLost(String valToSet) throws Exception {
        ITestDevice device = getDevice();
        String previousPowerStateChange = device.executeShellCommand(""cmd hdmi_control cec_setting ""
                + ""get power_state_change_on_active_source_lost"").split("" = "")[1].trim();
        device.executeShellCommand(""cmd hdmi_control cec_setting ""
                + ""set power_state_change_on_active_source_lost "" + valToSet);
        return previousPowerStateChange;
    }

    private int getUnusedPhysicalAddress(int initialValue, int usedValue) {
        if (initialValue == usedValue)
            return 0x2000;
        return initialValue;
    }

    private void reportPhysicalAddress(LogicalAddress logicalAddress, int physicalAddress,
            int deviceType) throws Exception {
        String formattedPhysicalAddress = CecMessage.formatParams(physicalAddress,
                HdmiCecConstants.PHYSICAL_ADDRESS_LENGTH);
        String formattedDeviceType = CecMessage.formatParams(deviceType);
        hdmiCecClient.sendCecMessage(
                logicalAddress,
                LogicalAddress.BROADCAST,
                CecOperand.REPORT_PHYSICAL_ADDRESS,
                formattedPhysicalAddress + formattedDeviceType
        );
    }

    /**
     * Tests that the DUT sends a {@code <Routing Change>} when a different device
     * from the network is selected.
     */"	"/home/gpoor/cts-12-source/cts/hostsidetests/hdmicec/src/android/hdmicec/cts/playback/HdmiCecDeviceSelectForPlaybackTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.autofillservice.cts.activities.AbstractAutoFillActivity"	"unregisterCallback"	"CtsAutoFillServiceTestCases"	"2: ui system"	"public void test/*
 *.
 */

package android.autofillservice.cts.activities;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import android.app.Activity;
import android.autofillservice.cts.testcore.AutofillTestWatcher;
import android.autofillservice.cts.testcore.MyAutofillCallback;
import android.autofillservice.cts.testcore.Timeouts;
import android.graphics.Bitmap;
import android.graphics.Rect;
import android.os.Bundle;
import android.view.PixelCopy;
import android.view.View;
import android.view.autofill.AutofillManager;

import androidx.annotation.NonNull;

import com.android.compatibility.common.util.RetryableException;
import com.android.compatibility.common.util.SynchronousPixelCopy;
import com.android.compatibility.common.util.Timeout;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
  * Base class for all activities in this test suite
  */
public abstract class AbstractAutoFillActivity extends Activity {

    private final CountDownLatch mDestroyedLatch = new CountDownLatch(1);
    protected final String mTag = getClass().getSimpleName();
    private MyAutofillCallback mCallback;

    /**
     * Run an action in the UI thread, and blocks caller until the action is finished.
     */
    public final void syncRunOnUiThread(Runnable action) {
        syncRunOnUiThread(action, Timeouts.UI_TIMEOUT.ms());
    }

    /**
     * Run an action in the UI thread, and blocks caller until the action is finished or it times
     * out.
     */
    public final void syncRunOnUiThread(Runnable action, long timeoutMs) {
        final CountDownLatch latch = new CountDownLatch(1);
        runOnUiThread(() -> {
            action.run();
            latch.countDown();
        });
        try {
            if (!latch.await(timeoutMs, TimeUnit.MILLISECONDS)) {
                throw new RetryableException(""action on UI thread timed out after %d ms"",
                        timeoutMs);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(""Interrupted"", e);
        }
    }

    public AutofillManager getAutofillManager() {
        return getSystemService(AutofillManager.class);
    }

    /**
     * Takes a screenshot from the whole activity.
     *
     * <p><b>Note:</b> this screenshot only contains the contents of the activity, it doesn't
     * include the autofill UIs; if you need to check that, please use
     * {@link UiBot#takeScreenshot()} instead.
     */
    public Bitmap takeScreenshot() {
        return takeScreenshot(findViewById(android.R.id.content).getRootView());
    }

    /**
     * Takes a screenshot from the a view.
     */
    public Bitmap takeScreenshot(View view) {
        final Rect srcRect = new Rect();
        syncRunOnUiThread(() -> view.getGlobalVisibleRect(srcRect));
        final Bitmap dest = Bitmap.createBitmap(
                srcRect.width(), srcRect.height(), Bitmap.Config.ARGB_8888);

        final SynchronousPixelCopy copy = new SynchronousPixelCopy();
        final int copyResult = copy.request(getWindow(), srcRect, dest);
        assertThat(copyResult).isEqualTo(PixelCopy.SUCCESS);

        return dest;
    }

    /**
     * Registers and returns a custom callback for autofill events.
     *
     * <p>Note: caller doesn't need to call {@link #unregisterCallback()}, it will be automatically
     * unregistered on {@link #finish()}.
     */
    public MyAutofillCallback registerCallback() {
        assertWithMessage(""already registered"").that(mCallback).isNull();
        mCallback = new MyAutofillCallback();
        getAutofillManager().registerCallback(mCallback);
        return mCallback;
    }

    /**
     * Unregister the callback from the {@link AutofillManager}.
     *
     * <p>This method just neeed to be called when a test case wants to explicitly test the behavior
     * of the activity when the callback is unregistered.
     */
    public void unregisterCallback() {
        assertWithMessage(""not registered"").that(mCallback).isNotNull();
        unregisterNonNullCallback();
    }

    /**
     * Waits until {@link #onDestroy()} is called.
     */
    public void waitUntilDestroyed(@NonNull Timeout timeout) throws InterruptedException {
        if (!mDestroyedLatch.await(timeout.ms(), TimeUnit.MILLISECONDS)) {
            throw new RetryableException(timeout, ""activity %s not destroyed"", this);
        }
    }

    private void unregisterNonNullCallback() {
        getAutofillManager().unregisterCallback(mCallback);
        mCallback = null;
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        AutofillTestWatcher.registerActivity(""onCreate()"", this);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();

        // Activitiy is typically unregistered at finish(), but we need to unregister here too
        // for the cases where it's destroyed due to a config change (like device rotation).
        AutofillTestWatcher.unregisterActivity(""onDestroy()"", this);
        mDestroyedLatch.countDown();
    }

    @Override
    public void finish() {
        finishOnly();
        AutofillTestWatcher.unregisterActivity(""finish()"", this);
    }

    /**
     * Finishes the activity, without unregistering it from {@link AutofillTestWatcher}.
     */
    public void finishOnly() {
        if (mCallback != null) {
            unregisterNonNullCallback();
        }
        super.finish();
    }

    /**
     * Clears focus from input fields.
     */
    public void clearFocus() {
        throw new UnsupportedOperationException(""Not implemented by "" + getClass());
    }
}"	"/home/gpoor/cts-12-source/cts/tests/autofillservice/src/android/autofillservice/cts/activities/AbstractAutoFillActivity.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.content.pm.cts.shortcutmanager.packages.ShortcutConfirmPin"	"isValid"	""	"2: apps system"	"public void test/*
 *.
 */
package android.content.pm.cts.shortcutmanager.packages;

import android.app.Activity;
import android.content.pm.LauncherApps;
import android.content.pm.LauncherApps.PinItemRequest;
import android.content.pm.ShortcutInfo;
import android.content.pm.cts.shortcutmanager.common.Constants;
import android.content.pm.cts.shortcutmanager.common.ReplyUtil;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.util.DisplayMetrics;
import android.util.Log;

import java.util.Objects;

/**
 * Activity that receives a ""pin shortcut"" request, and accepts automatically.
 */
public class ShortcutConfirmPin extends Activity {
    private static final String TAG = ""ShortcutConfirmPin"";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        Log.i(TAG, ""ShortcutConfirmPin.onCreate"");

        String replyAction = null;
        try {
            final LauncherApps launcherApps = getSystemService(LauncherApps.class);
            final PinItemRequest request = launcherApps.getPinItemRequest(getIntent());

            // This really must be non-null; otherwise we can't send a reply.
            final ShortcutInfo shortcut = request.getShortcutInfo();
            if (shortcut == null) {
                Log.e(TAG, ""request.getShortcutInfo() NOT expected to be NULL"");
                return;
            }

            replyAction = shortcut.getExtras().getString(Constants.EXTRA_REPLY_ACTION);

            if (!request.isValid()) {
                ReplyUtil.sendReply(this, replyAction, ""request.isValid() expected to be TRUE"");
                return;
            }
            if (request.getRequestType() != PinItemRequest.REQUEST_TYPE_SHORTCUT) {
                ReplyUtil.sendReply(this, replyAction,
                        ""request.getRequestType() expected to be REQUEST_TYPE_SHORTCUT"");
                return;
            }

            if (shortcut.getExtras().getBoolean(Constants.IGNORE)) {
                // Send a reply so that the caller can tell if the request has been sent,
                // and ignored.
                ReplyUtil.sendReply(this, replyAction, Constants.REQUEST_IGNORED_MESSAGE);
                return;
            }

            // Check the shortcut's fields.
            final boolean expectPinned = shortcut.getExtras().getBoolean(Constants.ALREADY_PINNED);
            if (shortcut.isPinned() != expectPinned) {
                ReplyUtil.sendReply(this, replyAction, ""isPinned() expected to be "" + expectPinned);
                return;
            }

            final String expectLabel = shortcut.getExtras().getString(Constants.LABEL);
            if (!Objects.equals(expectLabel, shortcut.getShortLabel())) {
                ReplyUtil.sendReply(this, replyAction,
                        ""getShortLabel() expected to be '"" + expectLabel + ""', but was '""
                        + shortcut.getShortLabel() + ""'"");
                return;
            }
            final Drawable icon = launcherApps.getShortcutBadgedIconDrawable(
                    shortcut, DisplayMetrics.DENSITY_DEFAULT);
            if (shortcut.getExtras().getBoolean(Constants.HAS_ICON)) {
                // Send a reply so that the caller can tell if the request has been sent,
                // and ignored.
                if (icon == null) {
                    ReplyUtil.sendReply(this, replyAction, ""Expected to have icon"");
                    return;
                }
            } else {
                if (icon != null) {
                    ReplyUtil.sendReply(this, replyAction, ""Not expected to have icon"");
                    return;
                }
            }

            request.accept();
            if (request.isValid()) {
                ReplyUtil.sendReply(this, replyAction,
                        ""request.isValid() expected to be FALSE after accept()"");
                return;
            }
            ReplyUtil.sendSuccessReply(this, replyAction);
            Log.e(TAG, ""Sent reply"");
        } catch (Exception e) {
            Log.e(TAG, ""Caught exception"", e);
            if (replyAction != null) {
                ReplyUtil.sendReply(this, replyAction, ""Caught exception: "" + e);
            }
        } finally {
            finish();
        }
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/shortcutmanager/packages/src/android/content/pm/cts/shortcutmanager/packages/ShortcutConfirmPin.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.media.cts.AudioHelper"	"currentTimeMillis"	""	"2: ui system"	"public void test/*
 *.
 */

package android.media.cts;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import com.android.compatibility.common.util.CddTest;
import com.android.compatibility.common.util.DeviceReportLog;
import com.android.compatibility.common.util.ResultType;
import com.android.compatibility.common.util.ResultUnit;
import java.nio.ByteBuffer;

import org.junit.Assert;

import android.annotation.IntRange;
import android.annotation.NonNull;
import android.annotation.Nullable;
import android.media.AudioAttributes;
import android.media.AudioFormat;
import android.media.AudioManager;
import android.media.AudioRecord;
import android.media.AudioTimestamp;
import android.media.AudioTrack;
import android.os.Looper;
import android.os.PersistableBundle;
import android.util.Log;

import androidx.test.InstrumentationRegistry;

// Used for statistics and loopers in listener tests.
// See AudioRecordTest.java and AudioTrack_ListenerTest.java.
public class AudioHelper {

    // asserts key equals expected in the metrics bundle.
    public static void assertMetricsKeyEquals(
            PersistableBundle metrics, String key, Object expected) {
        Object actual = metrics.get(key);
        assertEquals(""metric "" + key + "" actual "" + actual + "" != "" + "" expected "" + expected,
                expected, actual);
    }

    // asserts key exists in the metrics bundle.
    public static void assertMetricsKey(PersistableBundle metrics, String key) {
        Object actual = metrics.get(key);
        assertNotNull(""metric "" + key + "" does not exist"", actual);
    }

    // create sine waves or chirps for data arrays
    public static byte[] createSoundDataInByteArray(int bufferSamples, final int sampleRate,
            final double frequency, double sweep) {
        final double rad = 2 * Math.PI * frequency / sampleRate;
        byte[] vai = new byte[bufferSamples];
        sweep = Math.PI * sweep / ((double)sampleRate * vai.length);
        for (int j = 0; j < vai.length; j++) {
            int unsigned =  (int)(Math.sin(j * (rad + j * sweep)) * Byte.MAX_VALUE)
                    + Byte.MAX_VALUE & 0xFF;
            vai[j] = (byte) unsigned;
        }
        return vai;
    }

    public static short[] createSoundDataInShortArray(int bufferSamples, final int sampleRate,
            final double frequency, double sweep) {
        final double rad = 2 * Math.PI * frequency / sampleRate;
        short[] vai = new short[bufferSamples];
        sweep = Math.PI * sweep / ((double)sampleRate * vai.length);
        for (int j = 0; j < vai.length; j++) {
            vai[j] = (short)(Math.sin(j * (rad + j * sweep)) * Short.MAX_VALUE);
        }
        return vai;
    }

    public static float[] createSoundDataInFloatArray(int bufferSamples, final int sampleRate,
            final double frequency, double sweep) {
        final double rad = 2 * Math.PI * frequency / sampleRate;
        float[] vaf = new float[bufferSamples];
        sweep = Math.PI * sweep / ((double)sampleRate * vaf.length);
        for (int j = 0; j < vaf.length; j++) {
            vaf[j] = (float)(Math.sin(j * (rad + j * sweep)));
        }
        return vaf;
    }

    /**
     * Create and fill a short array with complete sine waves so we can
     * hear buffer underruns more easily.
     */
    public static short[] createSineWavesShort(int numFrames, int samplesPerFrame,
            int numCycles, double amplitude) {
        final short[] data = new short[numFrames * samplesPerFrame];
        final double rad = numCycles * 2.0 * Math.PI / numFrames;
        for (int j = 0; j < data.length;) {
            short sample = (short)(amplitude * Math.sin(j * rad) * Short.MAX_VALUE);
            for (int sampleIndex = 0; sampleIndex < samplesPerFrame; sampleIndex++) {
                data[j++] = sample;
            }
        }
        return data;
    }

    public static int frameSizeFromFormat(AudioFormat format) {
        return format.getChannelCount()
                * format.getBytesPerSample(format.getEncoding());
    }

    public static int frameCountFromMsec(int ms, AudioFormat format) {
        return ms * format.getSampleRate() / 1000;
    }

    public static class Statistics {
        public void add(double value) {
            final double absValue = Math.abs(value);
            mSum += value;
            mSumAbs += absValue;
            mMaxAbs = Math.max(mMaxAbs, absValue);
            ++mCount;
        }

        public double getAvg() {
            if (mCount == 0) {
                return 0;
            }
            return mSum / mCount;
        }

        public double getAvgAbs() {
            if (mCount == 0) {
                return 0;
            }
            return mSumAbs / mCount;
        }

        public double getMaxAbs() {
            return mMaxAbs;
        }

        private int mCount = 0;
        private double mSum = 0;
        private double mSumAbs = 0;
        private double mMaxAbs = 0;
    }

    // for listener tests
    // lightweight java.util.concurrent.Future*
    public static class FutureLatch<T>
    {
        private T mValue;
        private boolean mSet;
        public void set(T value)
        {
            synchronized (this) {
                assert !mSet;
                mValue = value;
                mSet = true;
                notify();
            }
        }
        public T get()
        {
            T value;
            synchronized (this) {
                while (!mSet) {
                    try {
                        wait();
                    } catch (InterruptedException e) {
                        ;
                    }
                }
                value = mValue;
            }
            return value;
        }
    }

    // for listener tests
    // represents a factory for T
    public interface MakesSomething<T>
    {
        T makeSomething();
    }

    // for listener tests
    // used to construct an object in the context of an asynchronous thread with looper
    public static class MakeSomethingAsynchronouslyAndLoop<T>
    {
        private Thread mThread;
        volatile private Looper mLooper;
        private final MakesSomething<T> mWhatToMake;

        public MakeSomethingAsynchronouslyAndLoop(MakesSomething<T> whatToMake)
        {
            assert whatToMake != null;
            mWhatToMake = whatToMake;
        }

        public T make()
        {
            final FutureLatch<T> futureLatch = new FutureLatch<T>();
            mThread = new Thread()
            {
                @Override
                public void run()
                {
                    Looper.prepare();
                    mLooper = Looper.myLooper();
                    T something = mWhatToMake.makeSomething();
                    futureLatch.set(something);
                    Looper.loop();
                }
            };
            mThread.start();
            return futureLatch.get();
        }
        public void join()
        {
            mLooper.quit();
            try {
                mThread.join();
            } catch (InterruptedException e) {
                ;
            }
            // avoid dangling references
            mLooper = null;
            mThread = null;
        }
    }

    public static int outChannelMaskFromInChannelMask(int channelMask) {
        switch (channelMask) {
            case AudioFormat.CHANNEL_IN_MONO:
                return AudioFormat.CHANNEL_OUT_MONO;
            case AudioFormat.CHANNEL_IN_STEREO:
                return AudioFormat.CHANNEL_OUT_STEREO;
            default:
                return AudioFormat.CHANNEL_INVALID;
        }
    }

    @CddTest(requirement=""5.10/C-1-6,C-1-7"")
    public static class TimestampVerifier {

        // CDD 5.6 1ms timestamp accuracy
        private static final double TEST_MAX_JITTER_MS_ALLOWED = 6.; // a validity check
        private static final double TEST_STD_JITTER_MS_ALLOWED = 3.; // flaky tolerance 3x
        private static final double TEST_STD_JITTER_MS_WARN = 1.;    // CDD requirement warning

        // CDD 5.6 100ms track startup latency
        private static final double TEST_STARTUP_TIME_MS_ALLOWED = 500.; // error
        private final double TEST_STARTUP_TIME_MS_WARN;                  // warning
        private static final double TEST_STARTUP_TIME_MS_INFO = 100.;    // informational

        private static final int MILLIS_PER_SECOND = 1000;
        private static final long NANOS_PER_MILLISECOND = 1000000;
        private static final long NANOS_PER_SECOND = NANOS_PER_MILLISECOND * MILLIS_PER_SECOND;
        private static final String REPORT_LOG_NAME = ""CtsMediaTestCases"";

        private final String mTag;
        private final int mSampleRate;
        private final long mStartFrames; // initial timestamp condition for verification.

        // Running statistics
        private int mCount = 0;
        private long mLastFrames = 0;
        private long mLastTimeNs = 0;
        private int mJitterCount = 0;
        private double mMeanJitterMs = 0.;
        private double mSecondMomentJitterMs = 0.;
        private double mMaxAbsJitterMs = 0.;
        private int mWarmupCount = 0;

        public TimestampVerifier(@Nullable String tag, @IntRange(from=4000) int sampleRate,
                                 long startFrames, boolean isProAudioDevice) {
            mTag = tag;  // Log accepts null
            mSampleRate = sampleRate;
            mStartFrames = startFrames;
            // Warning if higher than MUST value for pro audio.  Zero means ignore.
            TEST_STARTUP_TIME_MS_WARN = isProAudioDevice ? 200. : 0.;
        }

        public int getJitterCount() { return mJitterCount; }
        public double getMeanJitterMs() { return mMeanJitterMs; }
        public double getStdJitterMs() { return Math.sqrt(mSecondMomentJitterMs / mJitterCount); }
        public double getMaxAbsJitterMs() { return mMaxAbsJitterMs; }
        public double getStartTimeNs() {
            return mLastTimeNs - ((mLastFrames - mStartFrames) * NANOS_PER_SECOND / mSampleRate);
        }

        public void add(@NonNull AudioTimestamp ts) {
            final long frames = ts.framePosition;
            final long timeNs = ts.nanoTime;

            assertTrue(mTag + "" timestamps must have causal time"", System.nanoTime() >= timeNs);

            if (mCount > 0) { // need delta info from previous iteration (skipping first)
                final long deltaFrames = frames - mLastFrames;
                final long deltaTimeNs = timeNs - mLastTimeNs;

                if (deltaFrames == 0 && deltaTimeNs == 0) return;

                final double deltaFramesNs = (double)deltaFrames * NANOS_PER_SECOND / mSampleRate;
                final double jitterMs = (deltaTimeNs - deltaFramesNs)  // actual - expected
                        * (1. / NANOS_PER_MILLISECOND);

                Log.d(mTag, ""frames("" + frames
                        + "") timeNs("" + timeNs
                        + "") lastframes("" + mLastFrames
                        + "") lastTimeNs("" + mLastTimeNs
                        + "") deltaFrames("" + deltaFrames
                        + "") deltaTimeNs("" + deltaTimeNs
                        + "") jitterMs("" + jitterMs + "")"");
                assertTrue(mTag + "" timestamp time should be increasing"", deltaTimeNs >= 0);
                assertTrue(mTag + "" timestamp frames should be increasing"", deltaFrames >= 0);

                if (mLastFrames != 0) {
                    if (mWarmupCount++ > 1) { // ensure device is warmed up
                        // Welford's algorithm
                        // https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance
                        ++mJitterCount;
                        final double delta = jitterMs - mMeanJitterMs;
                        mMeanJitterMs += delta / mJitterCount;
                        final double delta2 = jitterMs - mMeanJitterMs;
                        mSecondMomentJitterMs += delta * delta2;

                        // jitterMs is signed, so max uses abs() here.
                        final double absJitterMs = Math.abs(jitterMs);
                        if (absJitterMs > mMaxAbsJitterMs) {
                            mMaxAbsJitterMs = absJitterMs;
                        }
                    }
                }
            }
            ++mCount;
            mLastFrames = frames;
            mLastTimeNs = timeNs;
        }

        public void verifyAndLog(long trackStartTimeNs, @Nullable String logName) {
            // enough timestamps?
            assertTrue(mTag + "" need at least 2 jitter measurements"", mJitterCount >= 2);

            // Compute startup time and std jitter.
            final int startupTimeMs =
                    (int) ((getStartTimeNs() - trackStartTimeNs) / NANOS_PER_MILLISECOND);
            final double stdJitterMs = getStdJitterMs();

            // Check startup time
            assertTrue(mTag + "" expect startupTimeMs "" + startupTimeMs
                            + "" <= "" + TEST_STARTUP_TIME_MS_ALLOWED,
                    startupTimeMs <= TEST_STARTUP_TIME_MS_ALLOWED);
            if (TEST_STARTUP_TIME_MS_WARN > 0 && startupTimeMs > TEST_STARTUP_TIME_MS_WARN) {
                Log.w(mTag, ""CDD warning: startup time "" + startupTimeMs
                        + "" > "" + TEST_STARTUP_TIME_MS_WARN);
            } else if (startupTimeMs > TEST_STARTUP_TIME_MS_INFO) {
                Log.i(mTag, ""CDD informational: startup time "" + startupTimeMs
                        + "" > "" + TEST_STARTUP_TIME_MS_INFO);
            }

            // Check maximum jitter
            assertTrue(mTag + "" expect maxAbsJitterMs("" + mMaxAbsJitterMs + "") < ""
                            + TEST_MAX_JITTER_MS_ALLOWED,
                    mMaxAbsJitterMs < TEST_MAX_JITTER_MS_ALLOWED);

            // Check std jitter
            if (stdJitterMs > TEST_STD_JITTER_MS_WARN) {
                Log.w(mTag, ""CDD warning: std timestamp jitter "" + stdJitterMs
                        + "" > "" + TEST_STD_JITTER_MS_WARN);
            }
            assertTrue(mTag + "" expect stdJitterMs "" + stdJitterMs +
                            "" < "" + TEST_STD_JITTER_MS_ALLOWED,
                    stdJitterMs < TEST_STD_JITTER_MS_ALLOWED);

            Log.d(mTag, ""startupTimeMs("" + startupTimeMs
                    + "") meanJitterMs("" + mMeanJitterMs
                    + "") maxAbsJitterMs("" + mMaxAbsJitterMs
                    + "") stdJitterMs("" + stdJitterMs
                    + "")"");

            // Log results if logName is provided
            if (logName != null) {
                DeviceReportLog log = new DeviceReportLog(REPORT_LOG_NAME, logName);
                // ReportLog needs at least one Value and Summary.
                log.addValue(""startup_time_ms"", startupTimeMs,
                        ResultType.LOWER_BETTER, ResultUnit.MS);
                log.addValue(""maximum_abs_jitter_ms"", mMaxAbsJitterMs,
                        ResultType.LOWER_BETTER, ResultUnit.MS);
                log.addValue(""mean_jitter_ms"", mMeanJitterMs,
                        ResultType.LOWER_BETTER, ResultUnit.MS);
                log.setSummary(""std_jitter_ms"", stdJitterMs,
                        ResultType.LOWER_BETTER, ResultUnit.MS);
                log.submit(InstrumentationRegistry.getInstrumentation());
            }
        }
    }

    /* AudioRecordAudit extends AudioRecord to allow concurrent playback
     * of read content to an AudioTrack.  This is for testing only.
     * For general applications, it is NOT recommended to extend AudioRecord.
     * This affects AudioRecord timing.
     */
    public static class AudioRecordAudit extends AudioRecord {
        public AudioRecordAudit(int audioSource, int sampleRate, int channelMask,
                int format, int bufferSize, boolean isChannelIndex) {
            this(audioSource, sampleRate, channelMask, format, bufferSize, isChannelIndex,
                    AudioManager.STREAM_MUSIC, 500 /*delayMs*/);
        }

        public AudioRecordAudit(int audioSource, int sampleRate, int channelMask,
                int format, int bufferSize,
                boolean isChannelIndex, int auditStreamType, int delayMs) {
            // without channel index masks, one could call:
            // super(audioSource, sampleRate, channelMask, format, bufferSize);
            super(new AudioAttributes.Builder()
                            .setInternalCapturePreset(audioSource)
                            .build(),
                    (isChannelIndex
                            ? new AudioFormat.Builder().setChannelIndexMask(channelMask)
                                    : new AudioFormat.Builder().setChannelMask(channelMask))
                            .setEncoding(format)
                            .setSampleRate(sampleRate)
                            .build(),
                    bufferSize,
                    AudioManager.AUDIO_SESSION_ID_GENERATE);

            if (delayMs >= 0) { // create an AudioTrack
                final int channelOutMask = isChannelIndex ? channelMask :
                    outChannelMaskFromInChannelMask(channelMask);
                final int bufferOutFrames = sampleRate * delayMs / 1000;
                final int bufferOutSamples = bufferOutFrames
                        * AudioFormat.channelCountFromOutChannelMask(channelOutMask);
                final int bufferOutSize = bufferOutSamples
                        * AudioFormat.getBytesPerSample(format);

                // Caution: delayMs too large results in buffer sizes that cannot be created.
                mTrack = new AudioTrack.Builder()
                                .setAudioAttributes(new AudioAttributes.Builder()
                                        .setLegacyStreamType(auditStreamType)
                                        .build())
                                .setAudioFormat((isChannelIndex ?
                                  new AudioFormat.Builder().setChannelIndexMask(channelOutMask) :
                                  new AudioFormat.Builder().setChannelMask(channelOutMask))
                                        .setEncoding(format)
                                        .setSampleRate(sampleRate)
                                        .build())
                                .setBufferSizeInBytes(bufferOutSize)
                                .build();
                Assert.assertEquals(AudioTrack.STATE_INITIALIZED, mTrack.getState());
                mPosition = 0;
                mFinishAtMs = 0;
            }
        }

        @Override
        public int read(byte[] audioData, int offsetInBytes, int sizeInBytes) {
            // for byte array access we verify format is 8 bit PCM (typical use)
            Assert.assertEquals(TAG + "": format mismatch"",
                    AudioFormat.ENCODING_PCM_8BIT, getAudioFormat());
            int samples = super.read(audioData, offsetInBytes, sizeInBytes);
            if (mTrack != null) {
                Assert.assertEquals(samples, mTrack.write(audioData, offsetInBytes, samples));
                mPosition += samples / mTrack.getChannelCount();
            }
            return samples;
        }

        @Override
        public int read(byte[] audioData, int offsetInBytes, int sizeInBytes, int readMode) {
            // for byte array access we verify format is 8 bit PCM (typical use)
            Assert.assertEquals(TAG + "": format mismatch"",
                    AudioFormat.ENCODING_PCM_8BIT, getAudioFormat());
            int samples = super.read(audioData, offsetInBytes, sizeInBytes, readMode);
            if (mTrack != null) {
                Assert.assertEquals(samples, mTrack.write(audioData, offsetInBytes, samples,
                        AudioTrack.WRITE_BLOCKING));
                mPosition += samples / mTrack.getChannelCount();
            }
            return samples;
        }

        @Override
        public int read(short[] audioData, int offsetInShorts, int sizeInShorts) {
            // for short array access we verify format is 16 bit PCM (typical use)
            Assert.assertEquals(TAG + "": format mismatch"",
                    AudioFormat.ENCODING_PCM_16BIT, getAudioFormat());
            int samples = super.read(audioData, offsetInShorts, sizeInShorts);
            if (mTrack != null) {
                Assert.assertEquals(samples, mTrack.write(audioData, offsetInShorts, samples));
                mPosition += samples / mTrack.getChannelCount();
            }
            return samples;
        }

        @Override
        public int read(short[] audioData, int offsetInShorts, int sizeInShorts, int readMode) {
            // for short array access we verify format is 16 bit PCM (typical use)
            Assert.assertEquals(TAG + "": format mismatch"",
                    AudioFormat.ENCODING_PCM_16BIT, getAudioFormat());
            int samples = super.read(audioData, offsetInShorts, sizeInShorts, readMode);
            if (mTrack != null) {
                Assert.assertEquals(samples, mTrack.write(audioData, offsetInShorts, samples,
                        AudioTrack.WRITE_BLOCKING));
                mPosition += samples / mTrack.getChannelCount();
            }
            return samples;
        }

        @Override
        public int read(float[] audioData, int offsetInFloats, int sizeInFloats, int readMode) {
            // for float array access we verify format is float PCM (typical use)
            Assert.assertEquals(TAG + "": format mismatch"",
                    AudioFormat.ENCODING_PCM_FLOAT, getAudioFormat());
            int samples = super.read(audioData, offsetInFloats, sizeInFloats, readMode);
            if (mTrack != null) {
                Assert.assertEquals(samples, mTrack.write(audioData, offsetInFloats, samples,
                        AudioTrack.WRITE_BLOCKING));
                mPosition += samples / mTrack.getChannelCount();
            }
            return samples;
        }

        @Override
        public int read(ByteBuffer audioBuffer, int sizeInBytes) {
            int bytes = super.read(audioBuffer, sizeInBytes);
            if (mTrack != null) {
                // read does not affect position and limit of the audioBuffer.
                // we make a duplicate to change that for writing to the output AudioTrack
                // which does check position and limit.
                ByteBuffer copy = audioBuffer.duplicate();
                copy.position(0).limit(bytes);  // read places data at the start of the buffer.
                Assert.assertEquals(bytes, mTrack.write(copy, bytes, AudioTrack.WRITE_BLOCKING));
                mPosition += bytes /
                        (mTrack.getChannelCount()
                                * AudioFormat.getBytesPerSample(mTrack.getAudioFormat()));
            }
            return bytes;
        }

        @Override
        public int read(ByteBuffer audioBuffer, int sizeInBytes, int readMode) {
            int bytes = super.read(audioBuffer, sizeInBytes, readMode);
            if (mTrack != null) {
                // read does not affect position and limit of the audioBuffer.
                // we make a duplicate to change that for writing to the output AudioTrack
                // which does check position and limit.
                ByteBuffer copy = audioBuffer.duplicate();
                copy.position(0).limit(bytes);  // read places data at the start of the buffer.
                Assert.assertEquals(bytes, mTrack.write(copy, bytes, AudioTrack.WRITE_BLOCKING));
                mPosition += bytes /
                        (mTrack.getChannelCount()
                                * AudioFormat.getBytesPerSample(mTrack.getAudioFormat()));
            }
            return bytes;
        }

        @Override
        public void startRecording() {
            super.startRecording();
            if (mTrack != null) {
                mTrack.play();
            }
        }

        @Override
        public void stop() {
            super.stop();
            if (mTrack != null) {
                if (mPosition > 0) { // stop may be called multiple times.
                    final int remainingFrames = mPosition - mTrack.getPlaybackHeadPosition();
                    mFinishAtMs = System.currentTimeMillis()
                            + remainingFrames * 1000 / mTrack.getSampleRate();
                    mPosition = 0;
                }
                mTrack.stop(); // allows remaining data to play out
            }
        }

        @Override
        public void release() {
            super.release();
            if (mTrack != null) {
                final long remainingMs = mFinishAtMs - System.currentTimeMillis();
                if (remainingMs > 0) {
                    try {
                        Thread.sleep(remainingMs);
                    } catch (InterruptedException e) {
                        ;
                    }
                }
                mTrack.release();
                mTrack = null;
            }
        }

        public AudioTrack mTrack;
        private final static String TAG = ""AudioRecordAudit"";
        private int mPosition;
        private long mFinishAtMs;
    }

    /* AudioRecordAudit extends AudioRecord to allow concurrent playback
     * of read content to an AudioTrack.  This is for testing only.
     * For general applications, it is NOT recommended to extend AudioRecord.
     * This affects AudioRecord timing.
     */
    public static class AudioRecordAuditNative extends AudioRecordNative {
        public AudioRecordAuditNative() {
            super();
            // Caution: delayMs too large results in buffer sizes that cannot be created.
            mTrack = new AudioTrackNative();
        }

        public boolean open(int numChannels, int sampleRate, boolean useFloat, int numBuffers) {
            if (super.open(numChannels, sampleRate, useFloat, numBuffers)) {
                if (!mTrack.open(numChannels, sampleRate, useFloat, 2 /* numBuffers */)) {
                    mTrack = null; // remove track
                }
                return true;
            }
            return false;
        }

        public void close() {
            super.close();
            if (mTrack != null) {
                mTrack.close();
            }
        }

        public boolean start() {
            if (super.start()) {
                if (mTrack != null) {
                    mTrack.start();
                }
                return true;
            }
            return false;
        }

        public boolean stop() {
            if (super.stop()) {
                if (mTrack != null) {
                    mTrack.stop(); // doesn't allow remaining data to play out
                }
                return true;
            }
            return false;
        }

        public int read(short[] audioData, int offsetInShorts, int sizeInShorts, int readFlags) {
            int samples = super.read(audioData, offsetInShorts, sizeInShorts, readFlags);
            if (mTrack != null) {
                Assert.assertEquals(samples, mTrack.write(audioData, offsetInShorts, samples,
                        AudioTrackNative.WRITE_FLAG_BLOCKING));
                mPosition += samples / mTrack.getChannelCount();
            }
            return samples;
        }

        public int read(float[] audioData, int offsetInFloats, int sizeInFloats, int readFlags) {
            int samples = super.read(audioData, offsetInFloats, sizeInFloats, readFlags);
            if (mTrack != null) {
                Assert.assertEquals(samples, mTrack.write(audioData, offsetInFloats, samples,
                        AudioTrackNative.WRITE_FLAG_BLOCKING));
                mPosition += samples / mTrack.getChannelCount();
            }
            return samples;
        }

        public AudioTrackNative mTrack;
        private final static String TAG = ""AudioRecordAuditNative"";
        private int mPosition;
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/media/common/src/android/media/cts/AudioHelper.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.uirendering.cts.util.BitmapDumper"	"list"	"CtsUiRenderingTestCases"	"3: direct ui user"	"public void test/*
 *.
 */
package android.uirendering.cts.util;

import android.graphics.Bitmap;
import android.os.Environment;
import android.uirendering.cts.differencevisualizers.DifferenceVisualizer;
import android.util.Log;

import com.android.compatibility.common.util.BitmapUtils;

import java.io.File;

/**
 * A utility class that will allow the user to save bitmaps to the sdcard on the device.
 */
public final class BitmapDumper {
    private final static String TAG = ""BitmapDumper"";
    private final static String IDEAL_RENDERING_FILE_NAME = ""idealCapture.png"";
    private final static String TESTED_RENDERING_FILE_NAME = ""testedCapture.png"";
    private final static String VISUALIZER_RENDERING_FILE_NAME = ""visualizer.png"";
    private final static String SINGULAR_FILE_NAME = ""capture.png"";
    private final static String CAPTURE_SUB_DIRECTORY = Environment.getExternalStorageDirectory()
            + ""/UiRenderingCaptures/"";

    private BitmapDumper() {}

    /**
     * Deletes the specific files for the given test in a given class.
     */
    public static void deleteFileInClassFolder(String className, String testName) {
        File directory = new File(CAPTURE_SUB_DIRECTORY + className);

        String[] children = directory.list();
        if (children == null) {
            return;
        }
        for (String file : children) {
            if (file.startsWith(testName)) {
                new File(directory, file).delete();
            }
        }
    }

    public static void createSubDirectory(String className) {
        File saveDirectory = new File(CAPTURE_SUB_DIRECTORY + className);
        if (saveDirectory.exists()) {
            return;
        }
        // Create the directory if it isn't already created.
        saveDirectory.mkdirs();
    }

    /**
     * Saves two files, one the capture of an ideal drawing, and one the capture of the tested
     * drawing. The third file saved is a bitmap that is returned from the given visualizer's
     * method.
     * The files are saved to the sdcard directory
     */
    public static void dumpBitmaps(Bitmap idealBitmap, Bitmap testedBitmap, String testName,
            String className, DifferenceVisualizer differenceVisualizer) {
        Bitmap visualizerBitmap;

        int width = idealBitmap.getWidth();
        int height = idealBitmap.getHeight();
        int[] testedArray = new int[width * height];
        int[] idealArray = new int[width * height];
        idealBitmap.getPixels(testedArray, 0, width, 0, 0, width, height);
        testedBitmap.getPixels(idealArray, 0, width, 0, 0, width, height);
        int[] visualizerArray = differenceVisualizer.getDifferences(idealArray, testedArray);
        visualizerBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
        visualizerBitmap.setPixels(visualizerArray, 0, width, 0, 0, width, height);
        Bitmap croppedBitmap = Bitmap.createBitmap(testedBitmap, 0, 0, width, height);

        saveFile(className, testName, IDEAL_RENDERING_FILE_NAME, idealBitmap);
        saveFile(className, testName, TESTED_RENDERING_FILE_NAME, croppedBitmap);
        saveFile(className, testName, VISUALIZER_RENDERING_FILE_NAME, visualizerBitmap);
    }

    public static void dumpBitmap(Bitmap bitmap, String testName, String className) {
        if (bitmap == null) {
            Log.d(TAG, ""File not saved, bitmap was null for test : "" + testName);
            return;
        }
        saveFile(className, testName, SINGULAR_FILE_NAME, bitmap);
    }

    private static void saveFile(String className, String testName, String fileName, Bitmap bitmap) {
        BitmapUtils.saveBitmap(bitmap, CAPTURE_SUB_DIRECTORY + className,
                testName + ""_"" + fileName);
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/uirendering27/src/android/uirendering/cts/util/BitmapDumper.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.provider.cts.media.MediaStoreAudioTestHelper"	"currentTimeMillis"	"CtsProviderTestCases"	"3: mic ui system"	"/*
 *.
 */

package android.provider.cts.media;

import android.content.ContentResolver;
import android.content.ContentValues;
import android.net.Uri;
import android.os.Build;
import android.provider.MediaStore;
import android.provider.MediaStore.Audio.Media;
import android.provider.cts.ProviderTestUtils;

import androidx.test.filters.SdkSuppress;
import androidx.test.runner.AndroidJUnit4;

import junit.framework.Assert;

import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.File;
import java.io.IOException;

/**
 * This class contains fake data and convenient methods for testing:
 * {@link MediaStore.Audio.Media}
 * {@link MediaStore.Audio.Genres}
 * {@link MediaStore.Audio.Genres.Members}
 * {@link MediaStore.Audio.Playlists}
 * {@link MediaStore.Audio.Playlists.Members}
 * {@link MediaStore.Audio.Albums}
 * {@link MediaStore.Audio.Artists}
 * {@link MediaStore.Audio.Artists.Albums}
 *
 * @see MediaStore_Audio_MediaTest
 * @see MediaStore_Audio_GenresTest
 * @see MediaStore_Audio_Genres_MembersTest
 * @see MediaStore_Audio_PlaylistsTest
 * @see MediaStore_Audio_Playlists_MembersTest
 * @see MediaStore_Audio_ArtistsTest
 * @see MediaStore_Audio_Artists_AlbumsTest
 * @see MediaStore_Audio_AlbumsTest
 */
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.R)
@RunWith(AndroidJUnit4.class)
public class MediaStoreAudioTestHelper {
    public static abstract class MockAudioMediaInfo {
        public abstract ContentValues getContentValues(String volumeName);

        public Uri insert(ContentResolver contentResolver, String volumeName) {
            final Uri dirUri = MediaStore.Audio.Media.getContentUri(volumeName);
            final ContentValues values = getContentValues(volumeName);
            contentResolver.delete(dirUri, MediaStore.Audio.Media.DATA + ""=?"", new String[] {
                    values.getAsString(MediaStore.Audio.Media.DATA)
            });

            final Uri itemUri = contentResolver.insert(dirUri, values);
            Assert.assertNotNull(itemUri);
            return itemUri;
        }

        public int delete(ContentResolver contentResolver, Uri uri) {
            return contentResolver.delete(uri, null, null);
        }
    }

    public static class Audio1 extends MockAudioMediaInfo {
        private Audio1() {
        }

        private static Audio1 sInstance = new Audio1();

        public static Audio1 getInstance() {
            return sInstance;
        }

        public static final int IS_RINGTONE = 0;
        public static final int IS_NOTIFICATION = 0;
        public static final int IS_ALARM = 0;
        public static final int IS_RECORDING = 0;
        public static final int IS_MUSIC = 1;
        public static final int YEAR = 1992;
        public static final int TRACK = 1;
        public static final int DURATION = 340000;
        public static final String COMPOSER = ""Bruce Swedien"";
        public static final String ARTIST = ""Michael Jackson"";
        public static final String ALBUM = ""Dangerous"";
        public static final String TITLE = ""Jam"";
        public static final int SIZE = 2737870;
        public static final String MIME_TYPE = ""audio/x-mpeg"";
        public static final String FILE_NAME = ""Jam.mp3"";
        public static final String DISPLAY_NAME = FILE_NAME;
        public static final long DATE_MODIFIED = System.currentTimeMillis() / 1000;
        public static final String GENRE = ""POP"";

        @Override
        public ContentValues getContentValues(String volumeName) {
            ContentValues values = new ContentValues();
            try {
                final File data;
                if (MediaStore.VOLUME_INTERNAL.equals(volumeName)) {
                    data = new File(""/data/data/android.provider.cts/files/"", FILE_NAME);
                } else {
                    data = new File(ProviderTestUtils.stageDir(volumeName), FILE_NAME);
                }
                values.put(Media.DATA, data.getAbsolutePath());
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            values.put(Media.DATE_MODIFIED, DATE_MODIFIED);
            values.put(Media.DISPLAY_NAME, DISPLAY_NAME);
            values.put(Media.MIME_TYPE, MIME_TYPE);
            values.put(Media.SIZE, SIZE);
            values.put(Media.TITLE, TITLE);
            values.put(Media.ALBUM, ALBUM);
            values.put(Media.ARTIST, ARTIST);
            values.put(Media.COMPOSER, COMPOSER);
            values.put(Media.DURATION, DURATION);
            values.put(Media.TRACK, TRACK);
            values.put(Media.YEAR, YEAR);
            values.put(Media.IS_MUSIC, IS_MUSIC);
            values.put(Media.IS_ALARM, IS_ALARM);
            values.put(Media.IS_NOTIFICATION, IS_NOTIFICATION);
            values.put(Media.IS_RECORDING, IS_RECORDING);
            values.put(Media.IS_RINGTONE, IS_RINGTONE);
            return values;
        }
    }

    public static class Audio2 extends MockAudioMediaInfo {
        private Audio2() {
        }

        private static Audio2 sInstance = new Audio2();

        public static Audio2 getInstance() {
            return sInstance;
        }

        public static final int IS_RINGTONE = 1;
        public static final int IS_NOTIFICATION = 0;
        public static final int IS_ALARM = 0;
        public static final int IS_MUSIC = 0;
        public static final int YEAR = 1992;
        public static final int TRACK = 1001;
        public static final int DURATION = 338000;
        public static final String COMPOSER = ""Bruce Swedien"";
        public static final String ARTIST =
            ""Michael Jackson - Live And Dangerous - National Stadium Bucharest"";
        public static final String ALBUM =
            ""Michael Jackson - Live And Dangerous - National Stadium Bucharest"";
        public static final String TITLE = ""Jam"";
        public static final int SIZE = 2737321;
        public static final String MIME_TYPE = ""audio/x-mpeg"";
        public static final String FILE_NAME = ""Jam_live.mp3"";
        public static final String DISPLAY_NAME = FILE_NAME;
        public static final long DATE_MODIFIED = System.currentTimeMillis() / 1000;

        @Override
        public ContentValues getContentValues(String volumeName) {
            ContentValues values = new ContentValues();
            try {
                final File data;
                if (MediaStore.VOLUME_INTERNAL.equals(volumeName)) {
                    data = new File(""/data/data/android.provider.cts/files/"", FILE_NAME);
                } else {
                    data = new File(ProviderTestUtils.stageDir(volumeName), FILE_NAME);
                }
                values.put(Media.DATA, data.getAbsolutePath());
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
            values.put(Media.DATE_MODIFIED, DATE_MODIFIED);
            values.put(Media.DISPLAY_NAME, DISPLAY_NAME);
            values.put(Media.MIME_TYPE, MIME_TYPE);
            values.put(Media.SIZE, SIZE);
            values.put(Media.TITLE, TITLE);
            values.put(Media.ALBUM, ALBUM);
            values.put(Media.ARTIST, ARTIST);
            values.put(Media.COMPOSER, COMPOSER);
            values.put(Media.DURATION, DURATION);
            values.put(Media.TRACK, TRACK);
            values.put(Media.YEAR, YEAR);
            values.put(Media.IS_MUSIC, IS_MUSIC);
            values.put(Media.IS_ALARM, IS_ALARM);
            values.put(Media.IS_NOTIFICATION, IS_NOTIFICATION);
            values.put(Media.IS_RINGTONE, IS_RINGTONE);
            return values;
        }
    }

    public static class Audio3 extends Audio1 {
        private Audio3() {
        }

        private static Audio3 sInstance = new Audio3();

        public static Audio3 getInstance() {
            return sInstance;
        }

        @Override
        public ContentValues getContentValues(String volumeName) {
            ContentValues values = super.getContentValues(volumeName);
            values.put(Media.DATA, values.getAsString(Media.DATA) + "".3.mp3"");
            return values;
        }
    }

    public static class Audio4 extends Audio1 {
        private Audio4() {
        }

        private static Audio4 sInstance = new Audio4();

        public static Audio4 getInstance() {
            return sInstance;
        }

        @Override
        public ContentValues getContentValues(String volumeName) {
            ContentValues values = super.getContentValues(volumeName);
            values.put(Media.DATA, values.getAsString(Media.DATA) + "".4.mp3"");
            return values;
        }
    }

    public static class Audio5 extends Audio1 {
        private Audio5() {
        }

        private static Audio5 sInstance = new Audio5();

        public static Audio5 getInstance() {
            return sInstance;
        }

        @Override
        public ContentValues getContentValues(String volumeName) {
            ContentValues values = super.getContentValues(volumeName);
            values.put(Media.DATA, values.getAsString(Media.DATA) + "".5.mp3"");
            return values;
        }
    }

    public static class Audio6 extends Audio1 {
        private Audio6() {
        }

        private static Audio6 sInstance = new Audio6();

        public static Audio6 getInstance() {
            return sInstance;
        }
        public static final String ARTIST =
                ""Michael Jackson - Live And Dangerous - National Stadium Bucharest"";

        @Override
        public ContentValues getContentValues(String volumeName) {
            ContentValues values = super.getContentValues(volumeName);
            values.put(Media.DATA, values.getAsString(Media.DATA) + "".6.mp3"");
            values.put(Media.ARTIST, ARTIST);
            return values;
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/media/MediaStoreAudioTestHelper.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.verifier.sensors.base.BaseSensorTestActivity"	"SensorTestLogger"	""	"5: hide ui system interaction user"	"public void test/*

 *.
 */

package com.android.cts.verifier.sensors.base;

import android.content.ActivityNotFoundException;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.hardware.cts.helpers.ActivityResultMultiplexedLatch;
import android.media.MediaPlayer;
import android.opengl.GLSurfaceView;
import android.os.Bundle;
import android.os.SystemClock;
import android.os.Vibrator;
import android.provider.Settings;
import android.text.TextUtils;
import android.text.format.DateUtils;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.LinearLayout;
import android.widget.ScrollView;
import android.widget.TextView;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.TestResult;
import com.android.cts.verifier.sensors.helpers.SensorFeaturesDeactivator;
import com.android.cts.verifier.sensors.reporting.SensorTestDetails;

import junit.framework.Assert;

import java.util.ArrayList;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

/**
 * A base Activity that is used to build different methods to execute tests inside CtsVerifier.
 * i.e. CTS tests, and semi-automated CtsVerifier tests.
 *
 * This class provides access to the following flow:
 *      Activity set up
 *          Execute tests (implemented by sub-classes)
 *      Activity clean up
 *
 * Currently the following class structure is available:
 * - BaseSensorTestActivity                 : provides the platform to execute Sensor tests inside
 *      |                                     CtsVerifier, and logging support
 *      |
 *      -- SensorCtsTestActivity            : an activity that can be inherited from to wrap a CTS
 *      |                                     sensor test, and execute it inside CtsVerifier
 *      |                                     these tests do not require any operator interaction
 *      |
 *      -- SensorCtsVerifierTestActivity    : an activity that can be inherited to write sensor
 *                                            tests that require operator interaction
 */
public abstract class BaseSensorTestActivity
        extends PassFailButtons.Activity
        implements View.OnClickListener, Runnable, ISensorTestStateContainer {
    @Deprecated
    protected static final String LOG_TAG = ""SensorTest"";

    protected final Class mTestClass;

    private final int mLayoutId;
    private final SensorFeaturesDeactivator mSensorFeaturesDeactivator;

    private final ExecutorService mExecutorService = Executors.newSingleThreadExecutor();
    private final SensorTestLogger mTestLogger = new SensorTestLogger();
    private final ActivityResultMultiplexedLatch mActivityResultMultiplexedLatch =
            new ActivityResultMultiplexedLatch();
    private final ArrayList<CountDownLatch> mWaitForUserLatches = new ArrayList<CountDownLatch>();

    private ScrollView mLogScrollView;
    private LinearLayout mLogLayout;
    private Button mNextButton;
    private Button mPassButton;
    private Button mFailButton;
    private Button mRetryButton;

    private GLSurfaceView mGLSurfaceView;
    private boolean mUsingGlSurfaceView;

    // Flag for Retry button appearance.
    private boolean mShouldRetry = false;
    private int mRetryCount = 0;

    /**
     * Constructor to be used by subclasses.
     *
     * @param testClass The class that contains the tests. It is dependant on test executor
     *                  implemented by subclasses.
     */
    protected BaseSensorTestActivity(Class testClass) {
        this(testClass, R.layout.sensor_test);
    }

    /**
     * Constructor to be used by subclasses. It allows to provide a custom layout for the test UI.
     *
     * @param testClass The class that contains the tests. It is dependant on test executor
     *                  implemented by subclasses.
     * @param layoutId The Id of the layout to use for the test UI. The layout must contain all the
     *                 elements in the base layout {@code R.layout.sensor_test}.
     */
    protected BaseSensorTestActivity(Class testClass, int layoutId) {
        mTestClass = testClass;
        mLayoutId = layoutId;
        mSensorFeaturesDeactivator = new SensorFeaturesDeactivator(this);
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(mLayoutId);

        mLogScrollView = (ScrollView) findViewById(R.id.log_scroll_view);
        mLogLayout = (LinearLayout) findViewById(R.id.log_layout);
        mNextButton = (Button) findViewById(R.id.next_button);
        mNextButton.setOnClickListener(this);
        mPassButton = (Button) findViewById(R.id.pass_button);
        mFailButton = (Button) findViewById(R.id.fail_button);
        mGLSurfaceView = (GLSurfaceView) findViewById(R.id.gl_surface_view);
        mRetryButton = (Button) findViewById(R.id.retry_button);
        mRetryButton.setOnClickListener(new retryButtonListener());

        updateNextButton(false /*enabled*/);
        mExecutorService.execute(this);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        mExecutorService.shutdownNow();
    }

    @Override
    protected void onPause() {
        super.onPause();
        if (mUsingGlSurfaceView) {
            mGLSurfaceView.onPause();
        }
    }

    @Override
    protected void onResume() {
        super.onResume();
        if (mUsingGlSurfaceView) {
            mGLSurfaceView.onResume();
        }
    }

    @Override
    public void onClick(View target) {
        mShouldRetry = false;

        synchronized (mWaitForUserLatches) {
            for (CountDownLatch latch : mWaitForUserLatches) {
                latch.countDown();
            }
            mWaitForUserLatches.clear();
        }
    }

    private class retryButtonListener implements View.OnClickListener {

        @Override
        public void onClick(View v) {
            mShouldRetry = true;
            ++mRetryCount;

            synchronized (mWaitForUserLatches) {
                for (CountDownLatch latch : mWaitForUserLatches) {
                    latch.countDown();
                }
                mWaitForUserLatches.clear();
            }
        }
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        mActivityResultMultiplexedLatch.onActivityResult(requestCode, resultCode);
    }

    /**
     * The main execution {@link Thread}.
     *
     * This function executes in a background thread, allowing the test run freely behind the
     * scenes. It provides the following execution hooks:
     *  - Activity SetUp/CleanUp (not available in JUnit)
     *  - executeTests: to implement several execution engines
     */
    @Override
    public void run() {
        long startTimeNs = SystemClock.elapsedRealtimeNanos();
        String testName = getTestClassName();

        SensorTestDetails testDetails;
        try {
            mSensorFeaturesDeactivator.requestDeactivationOfFeatures();
            testDetails = new SensorTestDetails(testName, SensorTestDetails.ResultCode.PASS);
        } catch (Throwable e) {
            testDetails = new SensorTestDetails(testName, ""DeactivateSensorFeatures"", e);
        }

        SensorTestDetails.ResultCode resultCode = testDetails.getResultCode();
        if (resultCode == SensorTestDetails.ResultCode.SKIPPED) {
            // this is an invalid state at this point of the test setup
            throw new IllegalStateException(""Deactivation of features cannot skip the test."");
        }
        if (resultCode == SensorTestDetails.ResultCode.PASS) {
            testDetails = executeActivityTests(testName);
        }

        // we consider all remaining states at this point, because we could have been half way
        // deactivating features
        try {
            mSensorFeaturesDeactivator.requestToRestoreFeatures();
        } catch (Throwable e) {
            testDetails = new SensorTestDetails(testName, ""RestoreSensorFeatures"", e);
        }

        mTestLogger.logTestDetails(testDetails);
        mTestLogger.logExecutionTime(startTimeNs);

        // because we cannot enforce test failures in several devices, set the test UI so the
        // operator can report the result of the test
        promptUserToSetResult(testDetails);
    }

    /**
     * A general set up routine. It executes only once before the first test case.
     *
     * NOTE: implementers must be aware of the interrupted status of the worker thread, and let
     * {@link InterruptedException} propagate.
     *
     * @throws Throwable An exception that denotes the failure of set up. No tests will be executed.
     */
    protected void activitySetUp() throws Throwable {}

    /**
     * A general clean up routine. It executes upon successful execution of {@link #activitySetUp()}
     * and after all the test cases.
     *
     * NOTE: implementers must be aware of the interrupted status of the worker thread, and handle
     * it in two cases:
     * - let {@link InterruptedException} propagate
     * - if it is invoked with the interrupted status, prevent from showing any UI

     * @throws Throwable An exception that will be logged and ignored, for ease of implementation
     *                   by subclasses.
     */
    protected void activityCleanUp() throws Throwable {}

    /**
     * Performs the work of executing the tests.
     * Sub-classes implementing different execution methods implement this method.
     *
     * @return A {@link SensorTestDetails} object containing information about the executed tests.
     */
    protected abstract SensorTestDetails executeTests() throws InterruptedException;

    /**
     * Get mShouldRetry to check if test is required to retry.
     */
    protected boolean getShouldRetry() {
        return mShouldRetry;
    }

    @Override
    public SensorTestLogger getTestLogger() {
        return mTestLogger;
    }

    @Deprecated
    protected void appendText(int resId) {
        mTestLogger.logInstructions(resId);
    }

    @Deprecated
    protected void appendText(String text) {
        TextAppender textAppender = new TextAppender(R.layout.snsr_instruction);
        textAppender.setText(text);
        textAppender.append();
    }

    @Deprecated
    protected void clearText() {
        this.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                mLogLayout.removeAllViews();
            }
        });
    }

    /**
     * Waits for the operator to acknowledge a requested action.
     *
     * @param waitMessageResId The action requested to the operator.
     */
    protected void waitForUser(int waitMessageResId) throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);
        synchronized (mWaitForUserLatches) {
            mWaitForUserLatches.add(latch);
        }

        mTestLogger.logInstructions(waitMessageResId);
        setNextButtonText(waitMessageResId);

        updateRetryButton(true);
        updateNextButton(true);
        latch.await();
        updateRetryButton(false);
        updateNextButton(false);
    }

    /**
     * Waits for the operator to acknowledge to begin execution.
     */
    protected void waitForUserToBegin() throws InterruptedException {
        waitForUser(R.string.snsr_wait_to_begin);
    }

    /**
     * Waits for the operator to acknowledge to retry execution.
     */
    protected void waitForUserToRetry() throws InterruptedException {
        mShouldRetry = true;
        waitForUser(R.string.snsr_wait_to_retry);
    }

    /**
     * Waits for the operator to acknowledge to finish execution.
     */
    protected void waitForUserToFinish() throws InterruptedException {
        mShouldRetry = true;
        waitForUser(R.string.snsr_wait_to_finish);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void waitForUserToContinue() throws InterruptedException {
        waitForUser(R.string.snsr_wait_for_user);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int executeActivity(String action) throws InterruptedException {
        return executeActivity(new Intent(action));
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int executeActivity(Intent intent) throws InterruptedException {
        ActivityResultMultiplexedLatch.Latch latch = mActivityResultMultiplexedLatch.bindThread();
        try {
            startActivityForResult(intent, latch.getRequestCode());
        } catch (ActivityNotFoundException e) {
            // handle exception gracefully
            // Among all defined activity results, RESULT_CANCELED offers the semantic closest to
            // represent absent setting activity.
            return RESULT_CANCELED;
        }
        return latch.await();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean hasSystemFeature(String feature) {
        PackageManager pm = getPackageManager();
        return pm.hasSystemFeature(feature);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean hasActivity(String action) {
        PackageManager pm = getPackageManager();
        return pm.resolveActivity(new Intent(action), PackageManager.MATCH_DEFAULT_ONLY) != null;
    }

    /**
     * Initializes and shows the {@link GLSurfaceView} available to tests.
     * NOTE: initialization can be performed only once, usually inside {@link #activitySetUp()}.
     */
    protected void initializeGlSurfaceView(final GLSurfaceView.Renderer renderer) {
        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                mGLSurfaceView.setVisibility(View.VISIBLE);
                mGLSurfaceView.setRenderer(renderer);
                mUsingGlSurfaceView = true;
            }
        });
    }

    /**
     * Closes and hides the {@link GLSurfaceView}.
     */
    protected void closeGlSurfaceView() {
        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                if (!mUsingGlSurfaceView) {
                    return;
                }
                mGLSurfaceView.setVisibility(View.GONE);
                mGLSurfaceView.onPause();
                mUsingGlSurfaceView = false;
            }
        });
    }

    /**
     * Plays a (default) sound as a notification for the operator.
     */
    protected void playSound() throws InterruptedException {
        MediaPlayer player = MediaPlayer.create(this, Settings.System.DEFAULT_NOTIFICATION_URI);
        if (player == null) {
            Log.e(LOG_TAG, ""MediaPlayer unavailable."");
            return;
        }
        player.start();
        try {
            Thread.sleep(500);
        } finally {
            player.stop();
        }
    }

    /**
     * Makes the device vibrate for the given amount of time.
     */
    protected void vibrate(int timeInMs) {
        Vibrator vibrator = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);
        vibrator.vibrate(timeInMs);
    }

    /**
     * Makes the device vibrate following the given pattern.
     * See {@link Vibrator#vibrate(long[], int)} for more information.
     */
    protected void vibrate(long[] pattern) {
        Vibrator vibrator = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);
        vibrator.vibrate(pattern, -1);
    }

    // TODO: move to sensor assertions
    protected String assertTimestampSynchronization(
            long eventTimestamp,
            long receivedTimestamp,
            long deltaThreshold,
            String sensorName) {
        long timestampDelta = Math.abs(eventTimestamp - receivedTimestamp);
        String timestampMessage = getString(
                R.string.snsr_event_time,
                receivedTimestamp,
                eventTimestamp,
                timestampDelta,
                deltaThreshold,
                sensorName);
        Assert.assertTrue(timestampMessage, timestampDelta < deltaThreshold);
        return timestampMessage;
    }

    protected String getTestClassName() {
        if (mTestClass == null) {
            return ""<unknown>"";
        }
        return mTestClass.getName();
    }

    protected void setLogScrollViewListener(View.OnTouchListener listener) {
        mLogScrollView.setOnTouchListener(listener);
    }

    private void setTestResult(SensorTestDetails testDetails) {
        // the name here, must be the Activity's name because it is what CtsVerifier expects
        String name = super.getClass().getName();
        String summary = mTestLogger.getOverallSummary();
        SensorTestDetails.ResultCode resultCode = testDetails.getResultCode();
        switch(resultCode) {
            case SKIPPED:
                TestResult.setPassedResult(this, name, summary);
                break;
            case PASS:
            case WARNING:
                TestResult.setPassedResult(this, name, summary);
                break;
            case FAIL:
                TestResult.setFailedResult(this, name, summary);
                break;
            case INTERRUPTED:
                // do not set a result, just return so the test can complete
                break;
            default:
                throw new IllegalStateException(""Unknown ResultCode: "" + resultCode);
        }
    }

    private SensorTestDetails executeActivityTests(String testName) {
        SensorTestDetails testDetails;
        try {
            activitySetUp();
            testDetails = new SensorTestDetails(testName, SensorTestDetails.ResultCode.PASS);
        } catch (Throwable e) {
            testDetails = new SensorTestDetails(testName, ""ActivitySetUp"", e);
        }

        SensorTestDetails.ResultCode resultCode = testDetails.getResultCode();
        if (resultCode == SensorTestDetails.ResultCode.PASS) {
            // TODO: implement execution filters:
            //      - execute all tests and report results officially
            //      - execute single test or failed tests only
            try {
                testDetails = executeTests();
            } catch (Throwable e) {
                // we catch and continue because we have to guarantee a proper clean-up sequence
                testDetails = new SensorTestDetails(testName, ""TestExecution"", e);
            }
        }

        // clean-up executes for all states, even on SKIPPED and INTERRUPTED there might be some
        // intermediate state that needs to be taken care of
        try {
            activityCleanUp();
        } catch (Throwable e) {
            testDetails = new SensorTestDetails(testName, ""ActivityCleanUp"", e);
        }

        return testDetails;
    }

    private void promptUserToSetResult(SensorTestDetails testDetails) {
        SensorTestDetails.ResultCode resultCode = testDetails.getResultCode();
        if (resultCode == SensorTestDetails.ResultCode.FAIL) {
            mTestLogger.logInstructions(R.string.snsr_test_complete_with_errors);
            enableTestResultButton(
                    mFailButton,
                    R.string.fail_button_text,
                    testDetails.cloneAndChangeResultCode(SensorTestDetails.ResultCode.FAIL));
        } else if (resultCode != SensorTestDetails.ResultCode.INTERRUPTED) {
            mTestLogger.logInstructions(R.string.snsr_test_complete);
            enableTestResultButton(
                    mPassButton,
                    R.string.pass_button_text,
                    testDetails.cloneAndChangeResultCode(SensorTestDetails.ResultCode.PASS));
        }
    }

    private void updateNextButton(final boolean enabled) {
        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                mNextButton.setEnabled(enabled);
            }
        });
    }

    /**
     * Set the text for next button by instruction message.
     * During retry, next button text is changed to notify users.
     *
     * @param waitMessageResId The action requested to the operator.
     */
    private void setNextButtonText(int waitMessageResId) {
        int nextButtonText;
        switch (waitMessageResId) {
            case R.string.snsr_wait_to_retry:
                nextButtonText = R.string.fail_and_next_button_text;
                break;
            case R.string.snsr_wait_to_finish:
                nextButtonText = R.string.finish_button_text;
                break;
            default:
                nextButtonText = R.string.next_button_text;
                break;
        }
        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                mNextButton.setText(nextButtonText);
            }
        });
    }

    /**
     * Update the retry button status.
     * During retry, show retry execution count. If not to retry, make retry button invisible.
     *
     * @param enabled The status of button.
     */
    private void updateRetryButton(final boolean enabled) {
        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                if (mShouldRetry) {
                    String showRetryCount = String.format(
                        ""%s (%d)"", getResources().getText(R.string.retry_button_text), mRetryCount);
                    mRetryButton.setText(showRetryCount);
                    mRetryButton.setVisibility(View.VISIBLE);
                    mRetryButton.setEnabled(enabled);
                } else {
                    mRetryButton.setVisibility(View.GONE);
                    mRetryCount = 0;
                }
            }
        });
    }

    private void enableTestResultButton(
            final Button button,
            final int textResId,
            final SensorTestDetails testDetails) {
        final View.OnClickListener listener = new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                setTestResult(testDetails);
                finish();
            }
        };

        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                mNextButton.setVisibility(View.GONE);
                mRetryButton.setVisibility(View.GONE);
                button.setText(textResId);
                button.setOnClickListener(listener);
                button.setVisibility(View.VISIBLE);
            }
        });
    }

    // a logger available until sensor reporting is in place
    public class SensorTestLogger {
        private static final String SUMMARY_SEPARATOR = "" | "";

        private final StringBuilder mOverallSummaryBuilder = new StringBuilder(""\n"");

        public void logCustomView(View view) {
            new ViewAppender(view).append();
        }

        void logTestStart(String testName) {
            // TODO: log the sensor information and expected execution time of each test
            TextAppender textAppender = new TextAppender(R.layout.snsr_test_title);
            textAppender.setText(testName);
            textAppender.append();
        }

        public void logInstructions(int instructionsResId, Object ... params) {
            TextAppender textAppender = new TextAppender(R.layout.snsr_instruction);
            textAppender.setText(getString(instructionsResId, params));
            textAppender.append();
        }

        public void logMessage(int messageResId, Object ... params) {
            TextAppender textAppender = new TextAppender(R.layout.snsr_message);
            textAppender.setText(getString(messageResId, params));
            textAppender.append();
        }

        public void logWaitForSound() {
            logInstructions(R.string.snsr_test_play_sound);
        }

        public void logTestDetails(SensorTestDetails testDetails) {
            String name = testDetails.getName();
            String summary = testDetails.getSummary();
            SensorTestDetails.ResultCode resultCode = testDetails.getResultCode();
            switch (resultCode) {
                case SKIPPED:
                    logTestSkip(name, summary);
                    break;
                case PASS:
                case WARNING:
                    mShouldRetry = false;
                    logTestPass(name, summary);
                    break;
                case FAIL:
                    logTestFail(name, summary);
                    break;
                case INTERRUPTED:
                    // do nothing, the test was interrupted so do we
                    break;
                default:
                    throw new IllegalStateException(""Unknown ResultCode: "" + resultCode);
            }
        }

        void logTestPass(String testName, String testSummary) {
            testSummary = getValidTestSummary(testSummary, R.string.snsr_test_pass);
            logTestEnd(R.layout.snsr_success, testSummary);
            Log.d(LOG_TAG, testSummary);
            saveResult(testName, SensorTestDetails.ResultCode.PASS, testSummary);
        }

        public void logTestFail(String testName, String testSummary) {
            testSummary = getValidTestSummary(testSummary, R.string.snsr_test_fail);
            logTestEnd(R.layout.snsr_error, testSummary);
            Log.e(LOG_TAG, testSummary);
            saveResult(testName, SensorTestDetails.ResultCode.FAIL, testSummary);
        }

        void logTestSkip(String testName, String testSummary) {
            testSummary = getValidTestSummary(testSummary, R.string.snsr_test_skipped);
            logTestEnd(R.layout.snsr_warning, testSummary);
            Log.i(LOG_TAG, testSummary);
            saveResult(testName, SensorTestDetails.ResultCode.SKIPPED, testSummary);
        }

        String getOverallSummary() {
            return mOverallSummaryBuilder.toString();
        }

        void logExecutionTime(long startTimeNs) {
            if (Thread.currentThread().isInterrupted()) {
                return;
            }
            long executionTimeNs = SystemClock.elapsedRealtimeNanos() - startTimeNs;
            long executionTimeSec = TimeUnit.NANOSECONDS.toSeconds(executionTimeNs);
            // TODO: find a way to format times with nanosecond accuracy and longer than 24hrs
            String formattedElapsedTime = DateUtils.formatElapsedTime(executionTimeSec);
            logMessage(R.string.snsr_execution_time, formattedElapsedTime);
        }

        private void logTestEnd(int textViewResId, String testSummary) {
            TextAppender textAppender = new TextAppender(textViewResId);
            textAppender.setText(testSummary);
            textAppender.append();
        }

        private String getValidTestSummary(String testSummary, int defaultSummaryResId) {
            if (TextUtils.isEmpty(testSummary)) {
                return getString(defaultSummaryResId);
            }
            return testSummary;
        }

        private void saveResult(
                String testName,
                SensorTestDetails.ResultCode resultCode,
                String summary) {
            mOverallSummaryBuilder.append(testName);
            mOverallSummaryBuilder.append(SUMMARY_SEPARATOR);
            mOverallSummaryBuilder.append(resultCode.name());
            mOverallSummaryBuilder.append(SUMMARY_SEPARATOR);
            mOverallSummaryBuilder.append(summary);
            mOverallSummaryBuilder.append(""\n"");
        }
    }

    private class ViewAppender {
        protected final View mView;

        public ViewAppender(View view) {
            mView = view;
        }

        public void append() {
            runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    mLogLayout.addView(mView);
                    mLogScrollView.post(new Runnable() {
                        @Override
                        public void run() {
                            mLogScrollView.fullScroll(View.FOCUS_DOWN);
                        }
                    });
                }
            });
        }
    }

    private class TextAppender extends ViewAppender{
        private final TextView mTextView;

        public TextAppender(int textViewResId) {
            super(getLayoutInflater().inflate(textViewResId, null /* viewGroup */));
            mTextView = (TextView) mView;
        }

        public void setText(String text) {
            mTextView.setText(text);
        }

        public void setText(int textResId) {
            mTextView.setText(textResId);
        }
    }
}"	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/sensors/base/BaseSensorTestActivity.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.cts.install.lib.host.InstallUtilsHost"	"isNotNull"	""	"3: direct ui system"	"public void test/*
 *.
 */

package android.cts.install.lib.host;

import static com.android.cts.shim.lib.ShimPackage.SHIM_APEX_PACKAGE_NAME;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import com.android.ddmlib.Log;
import com.android.tradefed.build.BuildInfoKey;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.invoker.TestInformation;
import com.android.tradefed.testtype.junit4.BaseHostJUnit4Test;
import com.android.tradefed.util.CommandResult;
import com.android.tradefed.util.CommandStatus;
import com.android.tradefed.util.FileUtil;
import com.android.tradefed.util.IRunUtil;
import com.android.tradefed.util.RunUtil;
import com.android.tradefed.util.SystemUtil;

import com.google.common.base.Stopwatch;

import java.io.File;
import java.io.IOException;
import java.time.Duration;
import java.util.List;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Utilities to facilitate installation in tests on host side.
 */
public class InstallUtilsHost {
    private static final String TAG = InstallUtilsHost.class.getSimpleName();
    private static final String APEX_INFO_EXTRACT_REGEX =
            "".*package:\\sname='(\\S+)\\'\\sversionCode='(\\d+)'\\s.*"";

    private final IRunUtil mRunUtil = new RunUtil();
    private BaseHostJUnit4Test mTest = null;
    private TestInformation mTestInfo = null;

    public InstallUtilsHost(BaseHostJUnit4Test test) {
        mTest = test;
    }

    public InstallUtilsHost(TestInformation testInfo) {
        assertThat(testInfo).isNotNull();
        mTestInfo = testInfo;
    }

    /**
     * Return {@code true} if and only if device supports updating apex.
     */
    public boolean isApexUpdateSupported() throws Exception {
        return getTestInfo().getDevice().getBooleanProperty(""ro.apex.updatable"", false);
    }

    /**
     * Return {@code true} if and only if device supports file system checkpoint.
     */
    public boolean isCheckpointSupported() throws Exception {
        CommandResult result = getTestInfo().getDevice().executeShellV2Command(
                ""sm supports-checkpoint"");
        assertWithMessage(""Failed to check if file system checkpoint is supported : %s"",
                result.getStderr()).that(result.getStatus()).isEqualTo(CommandStatus.SUCCESS);
        return ""true"".equals(result.getStdout().trim());
    }

    /**
     * Uninstalls a shim apex only if it's latest version is installed on /data partition (i.e.
     * it has a version higher than {@code 1}).
     *
     * <p>This is purely to optimize tests run time. Since uninstalling an apex requires a reboot,
     * and only a small subset of tests successfully install an apex, this code avoids ~10
     * unnecessary reboots.
     */
    public void uninstallShimApexIfNecessary() throws Exception {
        if (!isApexUpdateSupported()) {
            // Device doesn't support updating apex. Nothing to uninstall.
            return;
        }
        final ITestDevice.ApexInfo shimApex = getShimApex().orElseThrow(
                () -> new AssertionError(""Can't find "" + SHIM_APEX_PACKAGE_NAME));
        if (shimApex.sourceDir.startsWith(""/system"")) {
            // System version is active, nothing to uninstall.
            return;
        }
        // Non system version is active, need to uninstall it and reboot the device.
        Log.i(TAG, ""Uninstalling shim apex"");
        final String errorMessage =
                getTestInfo().getDevice().uninstallPackage(SHIM_APEX_PACKAGE_NAME);
        if (errorMessage != null) {
            Log.e(TAG, ""Failed to uninstall "" + SHIM_APEX_PACKAGE_NAME + "" : "" + errorMessage);
        } else {
            getTestInfo().getDevice().reboot();
            final ITestDevice.ApexInfo shim = getShimApex().orElseThrow(
                    () -> new AssertionError(""Can't find "" + SHIM_APEX_PACKAGE_NAME));
            assertThat(shim.versionCode).isEqualTo(1L);
            assertThat(shim.sourceDir).startsWith(""/system"");
        }
    }

    /**
     * Returns the active shim apex as optional.
     */
    public Optional<ITestDevice.ApexInfo> getShimApex() throws DeviceNotAvailableException {
        return getTestInfo().getDevice().getActiveApexes().stream().filter(
                apex -> apex.name.equals(SHIM_APEX_PACKAGE_NAME)).findAny();
    }

    /**
     * Retrieve package name and version code from test apex file.
     *
     * @param apex input apex file to retrieve the info from
     */
    public ITestDevice.ApexInfo getApexInfo(File apex) {
        String aaptOutput = runCmd(String.format(""aapt dump badging %s"", apex.getAbsolutePath()));
        String[] lines = aaptOutput.split(""\n"");
        Pattern p = Pattern.compile(APEX_INFO_EXTRACT_REGEX);
        for (String l : lines) {
            Matcher m = p.matcher(l);
            if (m.matches()) {
                return new ITestDevice.ApexInfo(m.group(1), Long.parseLong(m.group(2)));
            }
        }
        return null;
    }

    /**
     * Installs packages using staged install flow and waits for pre-reboot verification to complete
     */
    public String installStagedPackage(File pkg) throws Exception {
        return getTestInfo().getDevice().installPackage(pkg, false, ""--staged"");
    }

    /**
     * Install multiple package at the same time
     */
    public void installApexes(String... filenames) throws Exception {
        String[] args = new String[filenames.length + 1];
        args[0] = ""install-multi-package"";
        for (int i = 0; i < filenames.length; i++) {
            args[i + 1] = getTestFile(filenames[i]).getAbsolutePath();
        }
        String stdout = getTestInfo().getDevice().executeAdbCommand(args);
        assertThat(stdout).isNotNull();
    }

    /**
     * Waits for given {@code timeout} for {@code filePath} to be deleted.
     */
    public void waitForFileDeleted(String filePath, Duration timeout) throws Exception {
        Stopwatch stopwatch = Stopwatch.createStarted();
        while (true) {
            if (!getTestInfo().getDevice().doesFileExist(filePath)) {
                return;
            }
            if (stopwatch.elapsed().compareTo(timeout) > 0) {
                break;
            }
            Thread.sleep(500);
        }
        throw new AssertionError(""Timed out waiting for "" + filePath + "" to be deleted"");
    }

    /**
     * Get the test file.
     *
     * @param testFileName name of the file
     */
    public File getTestFile(String testFileName) throws IOException {
        File testFile = null;

        final List<File> testCasesDirs = SystemUtil.getTestCasesDirs(getTestInfo().getBuildInfo());
        for (File testCasesDir : testCasesDirs) {
            testFile = searchTestFile(testCasesDir, testFileName);
            if (testFile != null) {
                return testFile;
            }
        }

        File hostLinkedDir = getTestInfo().getBuildInfo().getFile(
                BuildInfoKey.BuildInfoFileKey.HOST_LINKED_DIR);
        if (hostLinkedDir != null) {
            testFile = searchTestFile(hostLinkedDir, testFileName);
        }
        if (testFile != null) {
            return testFile;
        }

        // Find the file in the buildinfo.
        File buildInfoFile = getTestInfo().getBuildInfo().getFile(testFileName);
        if (buildInfoFile != null) {
            return buildInfoFile;
        }

        throw new IOException(""Cannot find "" + testFileName);
    }

    /**
     * Searches the file with the given name under the given directory, returns null if not found.
     */
    private File searchTestFile(File baseSearchFile, String testFileName) {
        if (baseSearchFile != null && baseSearchFile.isDirectory()) {
            File testFile = FileUtil.findFile(baseSearchFile, testFileName);
            if (testFile != null && testFile.isFile()) {
                return testFile;
            }
        }
        return null;
    }

    private String runCmd(String cmd) {
        Log.d(""About to run command: %s"", cmd);
        CommandResult result = mRunUtil.runTimedCmd(1000 * 60 * 5, cmd.split(""\\s+""));
        assertThat(result).isNotNull();
        assertWithMessage(String.format(""Command %s failed"", cmd)).that(result.getStatus())
                .isEqualTo(CommandStatus.SUCCESS);
        Log.d(""output:\n%s"", result.getStdout());
        return result.getStdout();
    }

    private TestInformation getTestInfo() {
        if (mTestInfo == null) {
            mTestInfo = mTest.getTestInformation();
            assertThat(mTestInfo).isNotNull();
        }
        return mTestInfo;
    }
}"	"/home/gpoor/cts-12-source/cts/libs/install/src/android/cts/install/lib/host/InstallUtilsHost.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.autofillservice.cts.unittests.ImageTransformationTest"	"testAllNullBuilder"	"CtsAutoFillServiceTestCases"	"1: ui"	"@SuppressWarnings(""deprecation"")
    public void testAllNullBuilder() {
        assertThrows(NullPointerException.class,
                () ->  new ImageTransformation.Builder(null, null, 0));
    }"	"/home/gpoor/cts-12-source/cts/tests/autofillservice/src/android/autofillservice/cts/unittests/ImageTransformationTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.autofillservice.cts.unittests.ImageTransformationTest"	"testNullAutofillIdBuilder"	"CtsAutoFillServiceTestCases"	"1: ui"	"@SuppressWarnings(""deprecation"")
    public void testNullAutofillIdBuilder() {
        assertThrows(NullPointerException.class,
                () ->  new ImageTransformation.Builder(null, Pattern.compile(""""), 1));
    }"	"/home/gpoor/cts-12-source/cts/tests/autofillservice/src/android/autofillservice/cts/unittests/ImageTransformationTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.autofillservice.cts.unittests.ImageTransformationTest"	"testNullRegexBuilder"	"CtsAutoFillServiceTestCases"	"1: ui"	"@SuppressWarnings(""deprecation"")
    public void testNullRegexBuilder() {
        assertThrows(NullPointerException.class,
                () ->  new ImageTransformation.Builder(new AutofillId(1), null, 1));
    }"	"/home/gpoor/cts-12-source/cts/tests/autofillservice/src/android/autofillservice/cts/unittests/ImageTransformationTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.autofillservice.cts.unittests.ImageTransformationTest"	"testNullSubstBuilder"	"CtsAutoFillServiceTestCases"	"1: ui"	"@SuppressWarnings(""deprecation"")
    public void testNullSubstBuilder() {
        assertThrows(IllegalArgumentException.class,
                () ->  new ImageTransformation.Builder(new AutofillId(1), Pattern.compile(""""), 0));
    }"	"/home/gpoor/cts-12-source/cts/tests/autofillservice/src/android/autofillservice/cts/unittests/ImageTransformationTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.autofillservice.cts.inline.DatasetFilteringInlineTest"	"DatasetFilteringInlineTest"	"CtsAutoFillServiceTestCases"	"1: ui"	"public void test/*
 *.
 */

package android.autofillservice.cts.inline;

import static android.autofillservice.cts.testcore.Helper.getContext;
import static android.autofillservice.cts.testcore.InstrumentedAutoFillServiceInlineEnabled.SERVICE_NAME;

import android.autofillservice.cts.commontests.DatasetFilteringTest;
import android.autofillservice.cts.testcore.Helper;
import android.autofillservice.cts.testcore.InlineUiBot;

import org.junit.rules.TestRule;

public class DatasetFilteringInlineTest extends DatasetFilteringTest {
    public DatasetFilteringInlineTest() {
        super(getInlineUiBot());
    }


    @Override
    public TestRule getMainTestRule() {
        return InlineUiBot.annotateRule(super.getMainTestRule());
    }

    @Override
    protected boolean isInlineMode() {
        return true;
    }

    @Override
    protected void enableService() {
        Helper.enableAutofillService(getContext(), SERVICE_NAME);
    }
}"	"/home/gpoor/cts-12-source/cts/tests/autofillservice/src/android/autofillservice/cts/inline/DatasetFilteringInlineTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.accessibilityservice.cts.AccessibilitySoftKeyboardTest"	"testSwitchToInputMethod"	"CtsAccessibilityServiceTestCases"	"2: ui system"	"public void testSwitchToInputMethod() throws Exception {
        final SoftKeyboardController controller = mService.getSoftKeyboardController();
        String currentIME = Settings.Secure.getString(
                mService.getContentResolver(), Settings.Secure.DEFAULT_INPUT_METHOD);
        assertNotEquals(Ime1Constants.IME_ID, currentIME);
        // Enable a dummy IME for this test.
        try (TestImeSession imeSession = new TestImeSession(Ime1Constants.IME_ID)) {
            // Switch to the dummy IME.
            final boolean success = controller.switchToInputMethod(Ime1Constants.IME_ID);
            currentIME = Settings.Secure.getString(
                    mService.getContentResolver(), Settings.Secure.DEFAULT_INPUT_METHOD);

            // The current IME should be set to the dummy IME successfully.
            assertTrue(success);
            assertEquals(Ime1Constants.IME_ID, currentIME);
        }
    }

    private void assertCanSetAndGetShowModeAndCallbackHappens(
            int mode, InstrumentedAccessibilityService service)
            throws Exception  {
        final SoftKeyboardController controller = service.getSoftKeyboardController();
        mLastCallbackValue = -1;
        final boolean setShowModeReturns =
                service.getOnService(() -> controller.setShowMode(mode));
        assertTrue(setShowModeReturns);
        waitForCallbackValueWithLock(mode);
        assertEquals(mode, controller.getShowMode());
    }

    private void waitForCallbackValueWithLock(int expectedValue) throws Exception {
        long timeoutTimeMillis = SystemClock.uptimeMillis() + AsyncUtils.DEFAULT_TIMEOUT_MS;

        while (SystemClock.uptimeMillis() < timeoutTimeMillis) {
            synchronized(mLock) {
                if (mLastCallbackValue == expectedValue) {
                    return;
                }
                try {
                    mLock.wait(timeoutTimeMillis - SystemClock.uptimeMillis());
                } catch (InterruptedException e) {
                    // Wait until timeout.
                }
            }
        }

        throw new IllegalStateException(""last callback value <"" + mLastCallbackValue
                + ""> does not match expected value < "" + expectedValue + "">"");
    }

    /**
     * Activity for testing the AccessibilityService API for hiding and showing the soft keyboard.
     */
    public static class SoftKeyboardModesActivity extends AccessibilityTestActivity {
        public SoftKeyboardModesActivity() {
            super();
        }

        @Override
        public void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.accessibility_soft_keyboard_modes_test);
        }
    }

    private class TestImeSession implements AutoCloseable {
        TestImeSession(String imeId) {
            // Enable the dummy IME by shell command.
            final String enableImeCommand = ShellCommandUtils.enableIme(imeId);
            ShellCommandBuilder.create(mInstrumentation)
                    .addCommand(enableImeCommand)
                    .run();
        }

        @Override
        public void close() throws Exception {
            // Reset IMEs by shell command.
            ShellCommandBuilder.create(mInstrumentation)
                    .addCommand(ShellCommandUtils.resetImes())
                    .run();
        }
    }
}"	"/home/gpoor/cts-12-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilitySoftKeyboardTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.hardware.cts.helpers.SensorCtsHelper"	"getSensorTestDataDirectory"	"CtsSensorTestCases"	"4: direct ui system user"	"public void test/*
 *.
 */
package android.hardware.cts.helpers;

import android.hardware.Sensor;
import android.os.Environment;
import android.os.Process;
import android.util.Log;

import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.SystemUtil;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Set of static helper methods for CTS tests.
 */
//TODO: Refactor this class into several more well defined helper classes, look at StatisticsUtils
public class SensorCtsHelper {

    private static final long NANOS_PER_MILLI = 1000000;

    /**
     * Private constructor for static class.
     */
    private SensorCtsHelper() {}

    /**
     * Get low and high percentiles values of an array
     *
     * @param lowPercentile Lower boundary percentile, range [0, 1]
     * @param highPercentile Higher boundary percentile, range [0, 1]
     *
     * @throws IllegalArgumentException if the collection or percentiles is null or empty.
     */
    public static <TValue extends Comparable<? super TValue>> List<TValue> getPercentileValue(
            Collection<TValue> collection, float lowPecentile, float highPercentile) {
        validateCollection(collection);
        if (lowPecentile > highPercentile || lowPecentile < 0 || highPercentile > 1) {
            throw new IllegalStateException(""percentile has to be in range [0, 1], and "" +
                    ""lowPecentile has to be less than or equal to highPercentile"");
        }

        List<TValue> arrayCopy = new ArrayList<TValue>(collection);
        Collections.sort(arrayCopy);

        List<TValue> percentileValues = new ArrayList<TValue>();
        // lower percentile: rounding upwards, index range 1 .. size - 1 for percentile > 0
        // for percentile == 0, index will be 0.
        int lowArrayIndex = Math.min(arrayCopy.size() - 1,
                arrayCopy.size() - (int)(arrayCopy.size() * (1 - lowPecentile)));
        percentileValues.add(arrayCopy.get(lowArrayIndex));

        // upper percentile: rounding downwards, index range 0 .. size - 2 for percentile < 1
        // for percentile == 1, index will be size - 1.
        // Also, lower bound by lowerArrayIndex to avoid low percentile value being higher than
        // high percentile value.
        int highArrayIndex = Math.max(lowArrayIndex, (int)(arrayCopy.size() * highPercentile - 1));
        percentileValues.add(arrayCopy.get(highArrayIndex));
        return percentileValues;
    }

    /**
     * Calculate the mean of a collection.
     *
     * @throws IllegalArgumentException if the collection is null or empty
     */
    public static <TValue extends Number> double getMean(Collection<TValue> collection) {
        validateCollection(collection);

        double sum = 0.0;
        for(TValue value : collection) {
            sum += value.doubleValue();
        }
        return sum / collection.size();
    }

    /**
     * Calculate the bias-corrected sample variance of a collection.
     *
     * @throws IllegalArgumentException if the collection is null or empty
     */
    public static <TValue extends Number> double getVariance(Collection<TValue> collection) {
        validateCollection(collection);

        double mean = getMean(collection);
        ArrayList<Double> squaredDiffs = new ArrayList<Double>();
        for(TValue value : collection) {
            double difference = mean - value.doubleValue();
            squaredDiffs.add(Math.pow(difference, 2));
        }

        double sum = 0.0;
        for (Double value : squaredDiffs) {
            sum += value;
        }
        return sum / (squaredDiffs.size() - 1);
    }

    /**
     * @return The (measured) sampling rate of a collection of {@link TestSensorEvent}.
     */
    public static long getSamplingPeriodNs(List<TestSensorEvent> collection) {
        int collectionSize = collection.size();
        if (collectionSize < 2) {
            return 0;
        }
        TestSensorEvent firstEvent = collection.get(0);
        TestSensorEvent lastEvent = collection.get(collectionSize - 1);
        return (lastEvent.timestamp - firstEvent.timestamp) / (collectionSize - 1);
    }

    /**
     * Calculate the bias-corrected standard deviation of a collection.
     *
     * @throws IllegalArgumentException if the collection is null or empty
     */
    public static <TValue extends Number> double getStandardDeviation(
            Collection<TValue> collection) {
        return Math.sqrt(getVariance(collection));
    }

    /**
     * Convert a period to frequency in Hz.
     */
    public static <TValue extends Number> double getFrequency(TValue period, TimeUnit unit) {
        return 1000000000 / (TimeUnit.NANOSECONDS.convert(1, unit) * period.doubleValue());
    }

    /**
     * Convert a frequency in Hz into a period.
     */
    public static <TValue extends Number> double getPeriod(TValue frequency, TimeUnit unit) {
        return 1000000000 / (TimeUnit.NANOSECONDS.convert(1, unit) * frequency.doubleValue());
    }

    /**
     * If value lies outside the boundary limit, then return the nearer bound value.
     * Otherwise, return the value unchanged.
     */
    public static <TValue extends Number> double clamp(TValue val, TValue min, TValue max) {
        return Math.min(max.doubleValue(), Math.max(min.doubleValue(), val.doubleValue()));
    }

    /**
     * @return The magnitude (norm) represented by the given array of values.
     */
    public static double getMagnitude(float[] values) {
        float sumOfSquares = 0.0f;
        for (float value : values) {
            sumOfSquares += value * value;
        }
        double magnitude = Math.sqrt(sumOfSquares);
        return magnitude;
    }

    /**
     * Helper method to sleep for a given duration.
     */
    public static void sleep(long duration, TimeUnit timeUnit) throws InterruptedException {
        long durationNs = TimeUnit.NANOSECONDS.convert(duration, timeUnit);
        Thread.sleep(durationNs / NANOS_PER_MILLI, (int) (durationNs % NANOS_PER_MILLI));
    }

    /**
     * Format an assertion message.
     *
     * @param label the verification name
     * @param environment the environment of the test
     *
     * @return The formatted string
     */
    public static String formatAssertionMessage(String label, TestSensorEnvironment environment) {
        return formatAssertionMessage(label, environment, ""Failed"");
    }

    /**
     * Format an assertion message with a custom message.
     *
     * @param label the verification name
     * @param environment the environment of the test
     * @param format the additional format string
     * @param params the additional format params
     *
     * @return The formatted string
     */
    public static String formatAssertionMessage(
            String label,
            TestSensorEnvironment environment,
            String format,
            Object ... params) {
        return formatAssertionMessage(label, environment, String.format(format, params));
    }

    /**
     * Format an assertion message.
     *
     * @param label the verification name
     * @param environment the environment of the test
     * @param extras the additional information for the assertion
     *
     * @return The formatted string
     */
    public static String formatAssertionMessage(
            String label,
            TestSensorEnvironment environment,
            String extras) {
        return String.format(
                ""%s | sensor='%s', samplingPeriod=%dus, maxReportLatency=%dus | %s"",
                label,
                environment.getSensor().getName(),
                environment.getRequestedSamplingPeriodUs(),
                environment.getMaxReportLatencyUs(),
                extras);
    }

    /**
     * Format an array of floats.
     *
     * @param array the array of floats
     *
     * @return The formatted string
     */
    public static String formatFloatArray(float[] array) {
        StringBuilder sb = new StringBuilder();
        if (array.length > 1) {
            sb.append(""("");
        }
        for (int i = 0; i < array.length; i++) {
            sb.append(String.format(""%.2f"", array[i]));
            if (i != array.length - 1) {
                sb.append("", "");
            }
        }
        if (array.length > 1) {
            sb.append("")"");
        }
        return sb.toString();
    }

    /**
     * @return A {@link File} representing a root directory to store sensor tests data.
     */
    public static File getSensorTestDataDirectory() throws IOException {
        File dataDirectory = new File(Environment.getExternalStorageDirectory(), ""sensorTests/"");
        return createDirectoryStructure(dataDirectory);
    }

    /**
     * Creates the directory structure for the given sensor test data sub-directory.
     *
     * @param subdirectory The sub-directory's name.
     */
    public static File getSensorTestDataDirectory(String subdirectory) throws IOException {
        File subdirectoryFile = new File(getSensorTestDataDirectory(), subdirectory);
        return createDirectoryStructure(subdirectoryFile);
    }

    /**
     * Sanitizes a string so it can be used in file names.
     *
     * @param value The string to sanitize.
     * @return The sanitized string.
     *
     * @throws SensorTestPlatformException If the string cannot be sanitized.
     */
    public static String sanitizeStringForFileName(String value)
            throws SensorTestPlatformException {
        String sanitizedValue = value.replaceAll(""[^a-zA-Z0-9_\\-]"", ""_"");
        if (sanitizedValue.matches(""_*"")) {
            throw new SensorTestPlatformException(
                    ""Unable to sanitize string '%s' for file name."",
                    value);
        }
        return sanitizedValue;
    }

    /**
     * Ensures that the directory structure represented by the given {@link File} is created.
     */
    private static File createDirectoryStructure(File directoryStructure) throws IOException {
        directoryStructure.mkdirs();
        if (!directoryStructure.isDirectory()) {
            throw new IOException(""Unable to create directory structure for ""
                    + directoryStructure.getAbsolutePath());
        }
        return directoryStructure;
    }

    /**
     * Validate that a collection is not null or empty.
     *
     * @throws IllegalStateException if collection is null or empty.
     */
    private static <T> void validateCollection(Collection<T> collection) {
        if(collection == null || collection.size() == 0) {
            throw new IllegalStateException(""Collection cannot be null or empty"");
        }
    }

    public static String getUnitsForSensor(Sensor sensor) {
        switch(sensor.getType()) {
            case Sensor.TYPE_ACCELEROMETER:
                return ""m/s^2"";
            case Sensor.TYPE_MAGNETIC_FIELD:
            case Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED:
                return ""uT"";
            case Sensor.TYPE_GYROSCOPE:
            case Sensor.TYPE_GYROSCOPE_UNCALIBRATED:
                return ""radians/sec"";
            case Sensor.TYPE_PRESSURE:
                return ""hPa"";
        };
        return """";
    }

    public static boolean hasMaxResolutionRequirement(Sensor sensor, boolean hasHifiSensors) {
        switch (sensor.getType()) {
            case Sensor.TYPE_ACCELEROMETER:
            case Sensor.TYPE_ACCELEROMETER_UNCALIBRATED:
            case Sensor.TYPE_GYROSCOPE:
            case Sensor.TYPE_GYROSCOPE_UNCALIBRATED:
            case Sensor.TYPE_MAGNETIC_FIELD:
            case Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED:
            case Sensor.TYPE_HINGE_ANGLE:
            case Sensor.TYPE_PROXIMITY:
            case Sensor.TYPE_SIGNIFICANT_MOTION:
            case Sensor.TYPE_STEP_DETECTOR:
            case Sensor.TYPE_STEP_COUNTER:
            case Sensor.TYPE_HEART_RATE:
            case Sensor.TYPE_STATIONARY_DETECT:
            case Sensor.TYPE_MOTION_DETECT:
            case Sensor.TYPE_LOW_LATENCY_OFFBODY_DETECT:
                return true;

            case Sensor.TYPE_PRESSURE:
                // Pressure sensor only has a resolution requirement when there are HiFi sensors
                return hasHifiSensors;
        }
        return false;
    }

    public static float getRequiredMaxResolutionForSensor(Sensor sensor) {
        switch (sensor.getType()) {
            case Sensor.TYPE_ACCELEROMETER:
            case Sensor.TYPE_ACCELEROMETER_UNCALIBRATED:
            case Sensor.TYPE_GYROSCOPE:
            case Sensor.TYPE_GYROSCOPE_UNCALIBRATED:
                // Accelerometer and gyroscope must have at least 12 bits
                // of resolution. The maximum resolution calculation uses
                // slightly more than twice the maximum range because
                //   1) the sensor must be able to report values from
                //      [-maxRange, maxRange] without saturating
                //   2) to allow for slight rounding errors
                return (float)(2.001f * sensor.getMaximumRange() / Math.pow(2, 12));
            case Sensor.TYPE_MAGNETIC_FIELD:
            case Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED:
                // Magnetometer must have a resolution equal to or denser
                // than 0.6 uT
                return 0.6f;
            case Sensor.TYPE_PRESSURE:
                // Pressure sensor must have at least 80 LSB / hPa which is
                // equivalent to 0.0125 hPa / LSB. Allow for a small margin of
                // error due to rounding errors.
                return 1.01f * (1.0f / 80.0f);
            case Sensor.TYPE_HINGE_ANGLE:
                // Hinge angle sensor must have a resolution the same or smaller
                // than 360 degrees.
                return 360f;
            case Sensor.TYPE_PROXIMITY:
                // Binary prox sensors must have a resolution of 5, but it's not
                // expected / recommended that prox sensors use higher than
                // this.
                return 5f;
        }

        // Any sensor not specified above must use a resolution of 1.
        return 1.0f;
    }

    public static boolean hasMinResolutionRequirement(Sensor sensor) {
        switch (sensor.getType()) {
            case Sensor.TYPE_ACCELEROMETER:
            case Sensor.TYPE_ACCELEROMETER_UNCALIBRATED:
            case Sensor.TYPE_GYROSCOPE:
            case Sensor.TYPE_GYROSCOPE_UNCALIBRATED:
            case Sensor.TYPE_MAGNETIC_FIELD:
            case Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED:
            case Sensor.TYPE_SIGNIFICANT_MOTION:
            case Sensor.TYPE_STEP_DETECTOR:
            case Sensor.TYPE_STEP_COUNTER:
            case Sensor.TYPE_HEART_RATE:
            case Sensor.TYPE_STATIONARY_DETECT:
            case Sensor.TYPE_MOTION_DETECT:
            case Sensor.TYPE_LOW_LATENCY_OFFBODY_DETECT:
                return true;
        }
        return false;
    }

    public static float getRequiredMinResolutionForSensor(Sensor sensor) {
        switch (sensor.getType()) {
            case Sensor.TYPE_ACCELEROMETER:
            case Sensor.TYPE_ACCELEROMETER_UNCALIBRATED:
            case Sensor.TYPE_GYROSCOPE:
            case Sensor.TYPE_GYROSCOPE_UNCALIBRATED:
            case Sensor.TYPE_MAGNETIC_FIELD:
            case Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED:
                // Accelerometer, gyroscope, and mag are expected to have at most 24 bits of
                // resolution. The minimum resolution calculation uses slightly more than twice
                // the maximum range because:
                //   1) the sensor must be able to report values from [-maxRange, maxRange] without
                //      saturating
                //   2) to allow for slight rounding errors
                return (float)(2.001f * sensor.getMaximumRange() / Math.pow(2, 24));
        }

        // Any sensor not specified above must use a resolution of 1.
        return 1.0f;
    }

    public static String sensorTypeShortString(int type) {
        switch (type) {
            case Sensor.TYPE_ACCELEROMETER:
                return ""Accel"";
            case Sensor.TYPE_GYROSCOPE:
                return ""Gyro"";
            case Sensor.TYPE_MAGNETIC_FIELD:
                return ""Mag"";
            case Sensor.TYPE_ACCELEROMETER_UNCALIBRATED:
                return ""UncalAccel"";
            case Sensor.TYPE_GYROSCOPE_UNCALIBRATED:
                return ""UncalGyro"";
            case Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED:
                return ""UncalMag"";
            default:
                return ""Type_"" + type;
        }
    }

    public static class TestResultCollector {
        private List<AssertionError> mErrorList = new ArrayList<>();
        private List<String> mErrorStringList = new ArrayList<>();
        private String mTestName;
        private String mTag;

        public TestResultCollector() {
            this(""Test"");
        }

        public TestResultCollector(String test) {
            this(test, ""SensorCtsTest"");
        }

        public TestResultCollector(String test, String tag) {
            mTestName = test;
            mTag = tag;
        }

        public void perform(Runnable r) {
            perform(r, """");
        }

        public void perform(Runnable r, String s) {
            try {
                Log.d(mTag, mTestName + "" running "" + (s.isEmpty() ? ""..."" : s));
                r.run();
            } catch (AssertionError e) {
                mErrorList.add(e);
                mErrorStringList.add(s);
                Log.e(mTag, mTestName + "" error: "" + e.getMessage());
            }
        }

        public void judge() throws AssertionError {
            if (mErrorList.isEmpty() && mErrorStringList.isEmpty()) {
                return;
            }

            if (mErrorList.size() != mErrorStringList.size()) {
                throw new IllegalStateException(""Mismatch error and error message"");
            }

            StringBuffer buf = new StringBuffer();
            for (int i = 0; i < mErrorList.size(); ++i) {
                buf.append(""Test ("").append(mErrorStringList.get(i)).append("") - Error: "")
                    .append(mErrorList.get(i).getMessage()).append(""; "");
            }
            throw new AssertionError(buf.toString());
        }
    }

    public static String bytesToHex(byte[] bytes, int offset, int length) {
        if (offset == -1) {
            offset = 0;
        }

        if (length == -1) {
            length = bytes.length;
        }

        final char[] hexArray = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
        char[] hexChars = new char[length * 3];
        int v;
        for (int i = 0; i < length; i++) {
            v = bytes[offset + i] & 0xFF;
            hexChars[i * 3] = hexArray[v >>> 4];
            hexChars[i * 3 + 1] = hexArray[v & 0x0F];
            hexChars[i * 3 + 2] = ' ';
        }
        return new String(hexChars);
    }

    public static void makeMyPackageActive() throws IOException {
        final String command = ""cmd sensorservice reset-uid-state ""
                +  InstrumentationRegistry.getTargetContext().getPackageName()
                + "" --user "" + Process.myUserHandle().getIdentifier();
        SystemUtil.runShellCommand(InstrumentationRegistry.getInstrumentation(), command);
    }

    public static void makeMyPackageIdle() throws IOException {
        final String command = ""cmd sensorservice set-uid-state ""
                + InstrumentationRegistry.getTargetContext().getPackageName() + "" idle""
                + "" --user "" + Process.myUserHandle().getIdentifier();
        SystemUtil.runShellCommand(InstrumentationRegistry.getInstrumentation(), command);
    }
}"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/helpers/SensorCtsHelper.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.app.usage.cts.NetworkUsageStatsTest"	"getIsDefault"	"CtsUsageStatsTestCases"	"3: interfaces ui system"	"public void test/**
 * Copyright (C) 2015 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the ""License""); you may not
 * use this file except in compliance with the License. You may obtain a copy
 * of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

package android.app.usage.cts;

import android.app.AppOpsManager;
import android.app.usage.NetworkStatsManager;
import android.app.usage.NetworkStats;
import android.content.Context;
import android.content.pm.PackageManager;
import android.net.ConnectivityManager;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkInfo;
import android.net.NetworkRequest;
import android.net.TrafficStats;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.ParcelFileDescriptor;
import android.os.Process;
import android.os.RemoteException;
import android.os.SystemClock;
import android.platform.test.annotations.AppModeFull;
import android.telephony.TelephonyManager;
import android.test.InstrumentationTestCase;
import android.util.Log;

import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;
import java.net.UnknownHostException;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.Scanner;
import java.net.HttpURLConnection;

import libcore.io.IoUtils;
import libcore.io.Streams;

import static android.app.usage.NetworkStats.Bucket.DEFAULT_NETWORK_ALL;
import static android.app.usage.NetworkStats.Bucket.DEFAULT_NETWORK_NO;
import static android.app.usage.NetworkStats.Bucket.DEFAULT_NETWORK_YES;
import static android.app.usage.NetworkStats.Bucket.METERED_ALL;
import static android.app.usage.NetworkStats.Bucket.METERED_YES;
import static android.app.usage.NetworkStats.Bucket.METERED_NO;
import static android.app.usage.NetworkStats.Bucket.STATE_ALL;
import static android.app.usage.NetworkStats.Bucket.STATE_DEFAULT;
import static android.app.usage.NetworkStats.Bucket.STATE_FOREGROUND;
import static android.app.usage.NetworkStats.Bucket.TAG_NONE;
import static android.app.usage.NetworkStats.Bucket.UID_ALL;

public class NetworkUsageStatsTest extends InstrumentationTestCase {
    private static final String LOG_TAG = ""NetworkUsageStatsTest"";
    private static final String APPOPS_SET_SHELL_COMMAND = ""appops set {0} {1} {2}"";
    private static final String APPOPS_GET_SHELL_COMMAND = ""appops get {0} {1}"";

    private static final long MINUTE = 1000 * 60;
    private static final int TIMEOUT_MILLIS = 15000;

    private static final String CHECK_CONNECTIVITY_URL = ""http://www.265.com/"";
    private static final int HOST_RESOLUTION_RETRIES = 4;
    private static final int HOST_RESOLUTION_INTERVAL_MS = 500;

    private static final int NETWORK_TAG = 0xf00d;
    private static final long THRESHOLD_BYTES = 2 * 1024 * 1024;  // 2 MB

    private abstract class NetworkInterfaceToTest {
        private boolean mMetered;
        private boolean mIsDefault;

        abstract int getNetworkType();
        abstract int getTransportType();

        public boolean getMetered() {
            return mMetered;
        }

        public void setMetered(boolean metered) {
            this.mMetered = metered;
        }

        public boolean getIsDefault() {
            return mIsDefault;
        }

        public void setIsDefault(boolean isDefault) {
            mIsDefault = isDefault;
        }

        abstract String getSystemFeature();
        abstract String getErrorMessage();
    }

    private final NetworkInterfaceToTest[] mNetworkInterfacesToTest =
            new NetworkInterfaceToTest[] {
                    new NetworkInterfaceToTest() {
                        @Override
                        public int getNetworkType() {
                            return ConnectivityManager.TYPE_WIFI;
                        }

                        @Override
                        public int getTransportType() {
                            return NetworkCapabilities.TRANSPORT_WIFI;
                        }

                        @Override
                        public String getSystemFeature() {
                            return PackageManager.FEATURE_WIFI;
                        }

                        @Override
                        public String getErrorMessage() {
                            return "" Please make sure you are connected to a WiFi access point."";
                        }
                    },
                    new NetworkInterfaceToTest() {
                        @Override
                        public int getNetworkType() {
                            return ConnectivityManager.TYPE_MOBILE;
                        }

                        @Override
                        public int getTransportType() {
                            return NetworkCapabilities.TRANSPORT_CELLULAR;
                        }

                        @Override
                        public String getSystemFeature() {
                            return PackageManager.FEATURE_TELEPHONY;
                        }

                        @Override
                        public String getErrorMessage() {
                            return "" Please make sure you have added a SIM card with data plan to"" +
                                    "" your phone, have enabled data over cellular and in case of"" +
                                    "" dual SIM devices, have selected the right SIM "" +
                                    ""for data connection."";
                        }
                    }
    };

    private String mPkg;
    private NetworkStatsManager mNsm;
    private ConnectivityManager mCm;
    private PackageManager mPm;
    private long mStartTime;
    private long mEndTime;

    private long mBytesRead;
    private String mWriteSettingsMode;
    private String mUsageStatsMode;

    private void exerciseRemoteHost(Network network, URL url) throws Exception {
        NetworkInfo networkInfo = mCm.getNetworkInfo(network);
        if (networkInfo == null) {
            Log.w(LOG_TAG, ""Network info is null"");
        } else {
            Log.w(LOG_TAG, ""Network: "" + networkInfo.toString());
        }
        InputStreamReader in = null;
        HttpURLConnection urlc = null;
        String originalKeepAlive = System.getProperty(""http.keepAlive"");
        System.setProperty(""http.keepAlive"", ""false"");
        try {
            TrafficStats.setThreadStatsTag(NETWORK_TAG);
            urlc = (HttpURLConnection) network.openConnection(url);
            urlc.setConnectTimeout(TIMEOUT_MILLIS);
            urlc.setUseCaches(false);
            // Disable compression so we generate enough traffic that assertWithinPercentage will
            // not be affected by the small amount of traffic (5-10kB) sent by the test harness.
            urlc.setRequestProperty(""Accept-Encoding"", ""identity"");
            urlc.connect();
            boolean ping = urlc.getResponseCode() == 200;
            if (ping) {
                in = new InputStreamReader(
                        (InputStream) urlc.getContent());

                mBytesRead = 0;
                while (in.read() != -1) ++mBytesRead;
            }
        } catch (Exception e) {
            Log.i(LOG_TAG, ""Badness during exercising remote server: "" + e);
        } finally {
            TrafficStats.clearThreadStatsTag();
            if (in != null) {
                try {
                    in.close();
                } catch (IOException e) {
                    // don't care
                }
            }
            if (urlc != null) {
                urlc.disconnect();
            }
            if (originalKeepAlive == null) {
                System.clearProperty(""http.keepAlive"");
            } else {
                System.setProperty(""http.keepAlive"", originalKeepAlive);
            }
        }
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mNsm = (NetworkStatsManager) getInstrumentation().getContext()
                .getSystemService(Context.NETWORK_STATS_SERVICE);
        mNsm.setPollForce(true);

        mCm = (ConnectivityManager) getInstrumentation().getContext()
                .getSystemService(Context.CONNECTIVITY_SERVICE);

        mPm = getInstrumentation().getContext().getPackageManager();

        mPkg = getInstrumentation().getContext().getPackageName();

        mWriteSettingsMode = getAppOpsMode(AppOpsManager.OPSTR_WRITE_SETTINGS);
        setAppOpsMode(AppOpsManager.OPSTR_WRITE_SETTINGS, ""allow"");
        mUsageStatsMode = getAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS);
    }

    @Override
    protected void tearDown() throws Exception {
        if (mWriteSettingsMode != null) {
            setAppOpsMode(AppOpsManager.OPSTR_WRITE_SETTINGS, mWriteSettingsMode);
        }
        if (mUsageStatsMode != null) {
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, mUsageStatsMode);
        }
        super.tearDown();
    }

    private void setAppOpsMode(String appop, String mode) throws Exception {
        final String command = MessageFormat.format(APPOPS_SET_SHELL_COMMAND, mPkg, appop, mode);
        SystemUtil.runShellCommand(command);
    }

    private String getAppOpsMode(String appop) throws Exception {
        final String command = MessageFormat.format(APPOPS_GET_SHELL_COMMAND, mPkg, appop);
        String result = SystemUtil.runShellCommand(command);
        if (result == null) {
            Log.w(LOG_TAG, ""App op "" + appop + "" could not be read."");
        }
        return result;
    }

    private boolean isInForeground() throws IOException {
        String result = SystemUtil.runShellCommand(getInstrumentation(),
                ""cmd activity get-uid-state "" + Process.myUid());
        return result.contains(""FOREGROUND"");
    }

    private class NetworkCallback extends ConnectivityManager.NetworkCallback {
        private long mTolerance;
        private URL mUrl;
        public boolean success;
        public boolean metered;
        public boolean isDefault;

        NetworkCallback(long tolerance, URL url) {
            mTolerance = tolerance;
            mUrl = url;
            success = false;
            metered = false;
            isDefault = false;
        }

        // The test host only has IPv4. So on a dual-stack network where IPv6 connects before IPv4,
        // we need to wait until IPv4 is available or the test will spuriously fail.
        private void waitForHostResolution(Network network) {
            for (int i = 0; i < HOST_RESOLUTION_RETRIES; i++) {
                try {
                    network.getAllByName(mUrl.getHost());
                    return;
                } catch (UnknownHostException e) {
                    SystemClock.sleep(HOST_RESOLUTION_INTERVAL_MS);
                }
            }
            fail(String.format(""%s could not be resolved on network %s (%d attempts %dms apart)"",
                  mUrl.getHost(), network, HOST_RESOLUTION_RETRIES, HOST_RESOLUTION_INTERVAL_MS));
        }

        @Override
        public void onAvailable(Network network) {
            try {
                mStartTime = System.currentTimeMillis() - mTolerance;
                isDefault = network.equals(mCm.getActiveNetwork());
                waitForHostResolution(network);
                exerciseRemoteHost(network, mUrl);
                mEndTime = System.currentTimeMillis() + mTolerance;
                success = true;
                metered = !mCm.getNetworkCapabilities(network)
                        .hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED);
                synchronized(NetworkUsageStatsTest.this) {
                    NetworkUsageStatsTest.this.notify();
                }
            } catch (Exception e) {
                Log.w(LOG_TAG, ""exercising remote host failed."", e);
                success = false;
            }
        }
    }

    private boolean shouldTestThisNetworkType(int networkTypeIndex, final long tolerance)
            throws Exception {
        boolean hasFeature = mPm.hasSystemFeature(
                mNetworkInterfacesToTest[networkTypeIndex].getSystemFeature());
        if (!hasFeature) {
            return false;
        }
        NetworkCallback callback = new NetworkCallback(tolerance, new URL(CHECK_CONNECTIVITY_URL));
        mCm.requestNetwork(new NetworkRequest.Builder()
                .addTransportType(mNetworkInterfacesToTest[networkTypeIndex].getTransportType())
                .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                .build(), callback);
        synchronized(this) {
            try {
                wait((int)(TIMEOUT_MILLIS * 1.2));
            } catch (InterruptedException e) {
            }
        }
        if (callback.success) {
            mNetworkInterfacesToTest[networkTypeIndex].setMetered(callback.metered);
            mNetworkInterfacesToTest[networkTypeIndex].setIsDefault(callback.isDefault);
            return true;
        }

        // This will always fail at this point as we know 'hasFeature' is true.
        assertFalse (mNetworkInterfacesToTest[networkTypeIndex].getSystemFeature() +
                "" is a reported system feature, "" +
                ""however no corresponding connected network interface was found or the attempt "" +
                ""to connect has timed out (timeout = "" + TIMEOUT_MILLIS + ""ms)."" +
                mNetworkInterfacesToTest[networkTypeIndex].getErrorMessage(), hasFeature);
        return false;
    }

    private String getSubscriberId(int networkIndex) {
        int networkType = mNetworkInterfacesToTest[networkIndex].getNetworkType();
        if (ConnectivityManager.TYPE_MOBILE == networkType) {
            TelephonyManager tm = (TelephonyManager) getInstrumentation().getContext()
                    .getSystemService(Context.TELEPHONY_SERVICE);
            return ShellIdentityUtils.invokeMethodWithShellPermissions(tm,
                    (telephonyManager) -> telephonyManager.getSubscriberId());
        }
        return """";
    }

    @AppModeFull"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/NetworkUsageStatsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.app.usage.cts.NetworkUsageStatsTest"	"testDeviceSummary"	"CtsUsageStatsTestCases"	"2: interfaces ui"	"public void testDeviceSummary() throws Exception {
        for (int i = 0; i < mNetworkInterfacesToTest.length; ++i) {
            if (!shouldTestThisNetworkType(i, MINUTE/2)) {
                continue;
            }
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, ""allow"");
            NetworkStats.Bucket bucket = null;
            try {
                bucket = mNsm.querySummaryForDevice(
                        mNetworkInterfacesToTest[i].getNetworkType(), getSubscriberId(i),
                        mStartTime, mEndTime);
            } catch (RemoteException | SecurityException e) {
                fail(""testDeviceSummary fails with exception: "" + e.toString());
            }
            assertNotNull(bucket);
            assertTimestamps(bucket);
            assertEquals(bucket.getState(), STATE_ALL);
            assertEquals(bucket.getUid(), UID_ALL);
            assertEquals(bucket.getMetered(), METERED_ALL);
            assertEquals(bucket.getDefaultNetworkStatus(), DEFAULT_NETWORK_ALL);
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, ""deny"");
            try {
                bucket = mNsm.querySummaryForDevice(
                        mNetworkInterfacesToTest[i].getNetworkType(), getSubscriberId(i),
                        mStartTime, mEndTime);
                fail(""negative testDeviceSummary fails: no exception thrown."");
            } catch (RemoteException e) {
                fail(""testDeviceSummary fails with exception: "" + e.toString());
            } catch (SecurityException e) {
                // expected outcome
            }
        }
    }

    @AppModeFull"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/NetworkUsageStatsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.app.usage.cts.NetworkUsageStatsTest"	"testUserSummary"	"CtsUsageStatsTestCases"	"3: interfaces ui user"	"public void testUserSummary() throws Exception {
        for (int i = 0; i < mNetworkInterfacesToTest.length; ++i) {
            if (!shouldTestThisNetworkType(i, MINUTE/2)) {
                continue;
            }
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, ""allow"");
            NetworkStats.Bucket bucket = null;
            try {
                bucket = mNsm.querySummaryForUser(
                        mNetworkInterfacesToTest[i].getNetworkType(), getSubscriberId(i),
                        mStartTime, mEndTime);
            } catch (RemoteException | SecurityException e) {
                fail(""testUserSummary fails with exception: "" + e.toString());
            }
            assertNotNull(bucket);
            assertTimestamps(bucket);
            assertEquals(bucket.getState(), STATE_ALL);
            assertEquals(bucket.getUid(), UID_ALL);
            assertEquals(bucket.getMetered(), METERED_ALL);
            assertEquals(bucket.getDefaultNetworkStatus(), DEFAULT_NETWORK_ALL);
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, ""deny"");
            try {
                bucket = mNsm.querySummaryForUser(
                        mNetworkInterfacesToTest[i].getNetworkType(), getSubscriberId(i),
                        mStartTime, mEndTime);
                fail(""negative testUserSummary fails: no exception thrown."");
            } catch (RemoteException e) {
                fail(""testUserSummary fails with exception: "" + e.toString());
            } catch (SecurityException e) {
                // expected outcome
            }
        }
    }

    @AppModeFull"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/NetworkUsageStatsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.app.usage.cts.NetworkUsageStatsTest"	"testAppSummary"	"CtsUsageStatsTestCases"	"3: interfaces apps ui"	"public void testAppSummary() throws Exception {
        for (int i = 0; i < mNetworkInterfacesToTest.length; ++i) {
            // Use tolerance value that large enough to make sure stats of at
            // least one bucket is included. However, this is possible that
            // the test will see data of different app but with the same UID
            // that created before testing.
            // TODO: Consider query stats before testing and use the difference to verify.
            if (!shouldTestThisNetworkType(i, MINUTE * 120)) {
                continue;
            }
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, ""allow"");
            NetworkStats result = null;
            try {
                result = mNsm.querySummary(
                        mNetworkInterfacesToTest[i].getNetworkType(), getSubscriberId(i),
                        mStartTime, mEndTime);
                assertNotNull(result);
                NetworkStats.Bucket bucket = new NetworkStats.Bucket();
                long totalTxPackets = 0;
                long totalRxPackets = 0;
                long totalTxBytes = 0;
                long totalRxBytes = 0;
                boolean hasCorrectMetering = false;
                boolean hasCorrectDefaultStatus = false;
                int expectedMetering = mNetworkInterfacesToTest[i].getMetered() ?
                        METERED_YES : METERED_NO;
                int expectedDefaultStatus = mNetworkInterfacesToTest[i].getIsDefault() ?
                        DEFAULT_NETWORK_YES : DEFAULT_NETWORK_NO;
                while (result.hasNextBucket()) {
                    assertTrue(result.getNextBucket(bucket));
                    assertTimestamps(bucket);
                    hasCorrectMetering |= bucket.getMetered() == expectedMetering;
                    if (bucket.getUid() == Process.myUid()) {
                        totalTxPackets += bucket.getTxPackets();
                        totalRxPackets += bucket.getRxPackets();
                        totalTxBytes += bucket.getTxBytes();
                        totalRxBytes += bucket.getRxBytes();
                        hasCorrectDefaultStatus |=
                                bucket.getDefaultNetworkStatus() == expectedDefaultStatus;
                    }
                }
                assertFalse(result.getNextBucket(bucket));
                assertTrue(""Incorrect metering for NetworkType: "" +
                        mNetworkInterfacesToTest[i].getNetworkType(), hasCorrectMetering);
                assertTrue(""Incorrect isDefault for NetworkType: "" +
                        mNetworkInterfacesToTest[i].getNetworkType(), hasCorrectDefaultStatus);
                assertTrue(""No Rx bytes usage for uid "" + Process.myUid(), totalRxBytes > 0);
                assertTrue(""No Rx packets usage for uid "" + Process.myUid(), totalRxPackets > 0);
                assertTrue(""No Tx bytes usage for uid "" + Process.myUid(), totalTxBytes > 0);
                assertTrue(""No Tx packets usage for uid "" + Process.myUid(), totalTxPackets > 0);
            } finally {
                if (result != null) {
                    result.close();
                }
            }
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, ""deny"");
            try {
                result = mNsm.querySummary(
                        mNetworkInterfacesToTest[i].getNetworkType(), getSubscriberId(i),
                        mStartTime, mEndTime);
                fail(""negative testAppSummary fails: no exception thrown."");
            } catch (RemoteException e) {
                fail(""testAppSummary fails with exception: "" + e.toString());
            } catch (SecurityException e) {
                // expected outcome
            }
        }
    }

    @AppModeFull"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/NetworkUsageStatsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.app.usage.cts.NetworkUsageStatsTest"	"testAppDetails"	"CtsUsageStatsTestCases"	"1: interfaces"	"public void testAppDetails() throws Exception {
        for (int i = 0; i < mNetworkInterfacesToTest.length; ++i) {
            // Relatively large tolerance to accommodate for history bucket size.
            if (!shouldTestThisNetworkType(i, MINUTE * 120)) {
                continue;
            }
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, ""allow"");
            NetworkStats result = null;
            try {
                result = mNsm.queryDetails(
                        mNetworkInterfacesToTest[i].getNetworkType(), getSubscriberId(i),
                        mStartTime, mEndTime);
                long totalBytesWithSubscriberId = getTotalAndAssertNotEmpty(result);

                // Test without filtering by subscriberId
                result = mNsm.queryDetails(
                        mNetworkInterfacesToTest[i].getNetworkType(), null,
                        mStartTime, mEndTime);

                assertTrue(""More bytes with subscriberId filter than without."",
                        getTotalAndAssertNotEmpty(result) >= totalBytesWithSubscriberId);
            } catch (RemoteException | SecurityException e) {
                fail(""testAppDetails fails with exception: "" + e.toString());
            } finally {
                if (result != null) {
                    result.close();
                }
            }
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, ""deny"");
            try {
                result = mNsm.queryDetails(
                        mNetworkInterfacesToTest[i].getNetworkType(), getSubscriberId(i),
                        mStartTime, mEndTime);
                fail(""negative testAppDetails fails: no exception thrown."");
            } catch (RemoteException e) {
                fail(""testAppDetails fails with exception: "" + e.toString());
            } catch (SecurityException e) {
                // expected outcome
            }
        }
    }

    @AppModeFull"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/NetworkUsageStatsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.app.usage.cts.NetworkUsageStatsTest"	"testUidDetails"	"CtsUsageStatsTestCases"	"2: interfaces ui"	"public void testUidDetails() throws Exception {
        for (int i = 0; i < mNetworkInterfacesToTest.length; ++i) {
            // Relatively large tolerance to accommodate for history bucket size.
            if (!shouldTestThisNetworkType(i, MINUTE * 120)) {
                continue;
            }
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, ""allow"");
            NetworkStats result = null;
            try {
                result = mNsm.queryDetailsForUid(
                        mNetworkInterfacesToTest[i].getNetworkType(), getSubscriberId(i),
                        mStartTime, mEndTime, Process.myUid());
                assertNotNull(result);
                NetworkStats.Bucket bucket = new NetworkStats.Bucket();
                long totalTxPackets = 0;
                long totalRxPackets = 0;
                long totalTxBytes = 0;
                long totalRxBytes = 0;
                while (result.hasNextBucket()) {
                    assertTrue(result.getNextBucket(bucket));
                    assertTimestamps(bucket);
                    assertEquals(bucket.getState(), STATE_ALL);
                    assertEquals(bucket.getMetered(), METERED_ALL);
                    assertEquals(bucket.getDefaultNetworkStatus(), DEFAULT_NETWORK_ALL);
                    assertEquals(bucket.getUid(), Process.myUid());
                    totalTxPackets += bucket.getTxPackets();
                    totalRxPackets += bucket.getRxPackets();
                    totalTxBytes += bucket.getTxBytes();
                    totalRxBytes += bucket.getRxBytes();
                }
                assertFalse(result.getNextBucket(bucket));
                assertTrue(""No Rx bytes usage for uid "" + Process.myUid(), totalRxBytes > 0);
                assertTrue(""No Rx packets usage for uid "" + Process.myUid(), totalRxPackets > 0);
                assertTrue(""No Tx bytes usage for uid "" + Process.myUid(), totalTxBytes > 0);
                assertTrue(""No Tx packets usage for uid "" + Process.myUid(), totalTxPackets > 0);
            } finally {
                if (result != null) {
                    result.close();
                }
            }
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, ""deny"");
            try {
                result = mNsm.queryDetailsForUid(
                        mNetworkInterfacesToTest[i].getNetworkType(), getSubscriberId(i),
                        mStartTime, mEndTime, Process.myUid());
                fail(""negative testUidDetails fails: no exception thrown."");
            } catch (SecurityException e) {
                // expected outcome
            }
        }
    }

    @AppModeFull"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/NetworkUsageStatsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.app.usage.cts.NetworkUsageStatsTest"	"testTagDetails"	"CtsUsageStatsTestCases"	"2: interfaces ui"	"public void testTagDetails() throws Exception {
        for (int i = 0; i < mNetworkInterfacesToTest.length; ++i) {
            // Relatively large tolerance to accommodate for history bucket size.
            if (!shouldTestThisNetworkType(i, MINUTE * 120)) {
                continue;
            }
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, ""allow"");
            NetworkStats result = null;
            try {
                result = mNsm.queryDetailsForUidTag(
                        mNetworkInterfacesToTest[i].getNetworkType(), getSubscriberId(i),
                        mStartTime, mEndTime, Process.myUid(), NETWORK_TAG);
                assertNotNull(result);
                NetworkStats.Bucket bucket = new NetworkStats.Bucket();
                long totalTxPackets = 0;
                long totalRxPackets = 0;
                long totalTxBytes = 0;
                long totalRxBytes = 0;
                while (result.hasNextBucket()) {
                    assertTrue(result.getNextBucket(bucket));
                    assertTimestamps(bucket);
                    assertEquals(bucket.getState(), STATE_ALL);
                    assertEquals(bucket.getMetered(), METERED_ALL);
                    assertEquals(bucket.getDefaultNetworkStatus(), DEFAULT_NETWORK_ALL);
                    assertEquals(bucket.getUid(), Process.myUid());
                    if (bucket.getTag() == NETWORK_TAG) {
                        totalTxPackets += bucket.getTxPackets();
                        totalRxPackets += bucket.getRxPackets();
                        totalTxBytes += bucket.getTxBytes();
                        totalRxBytes += bucket.getRxBytes();
                    }
                }
                assertTrue(""No Rx bytes tagged with 0x"" + Integer.toHexString(NETWORK_TAG)
                        + "" for uid "" + Process.myUid(), totalRxBytes > 0);
                assertTrue(""No Rx packets tagged with 0x"" + Integer.toHexString(NETWORK_TAG)
                        + "" for uid "" + Process.myUid(), totalRxPackets > 0);
                assertTrue(""No Tx bytes tagged with 0x"" + Integer.toHexString(NETWORK_TAG)
                        + "" for uid "" + Process.myUid(), totalTxBytes > 0);
                assertTrue(""No Tx packets tagged with 0x"" + Integer.toHexString(NETWORK_TAG)
                        + "" for uid "" + Process.myUid(), totalTxPackets > 0);
            } finally {
                if (result != null) {
                    result.close();
                }
            }
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, ""deny"");
            try {
                result = mNsm.queryDetailsForUidTag(
                        mNetworkInterfacesToTest[i].getNetworkType(), getSubscriberId(i),
                        mStartTime, mEndTime, Process.myUid(), NETWORK_TAG);
                fail(""negative testUidDetails fails: no exception thrown."");
            } catch (SecurityException e) {
                // expected outcome
            }
        }
    }

    class QueryResult {
        public final int tag;
        public final int state;
        public final long total;

        public QueryResult(int tag, int state, NetworkStats stats) {
            this.tag = tag;
            this.state = state;
            total = getTotalAndAssertNotEmpty(stats, tag, state);
        }

        public String toString() {
            return String.format(""QueryResult(tag=%s state=%s total=%d)"",
                    tagToString(tag), stateToString(state), total);
        }
    }

    private NetworkStats getNetworkStatsForTagState(int i, int tag, int state) {
        return mNsm.queryDetailsForUidTagState(
                mNetworkInterfacesToTest[i].getNetworkType(), getSubscriberId(i),
                mStartTime, mEndTime, Process.myUid(), tag, state);
    }

    private void assertWithinPercentage(String msg, long expected, long actual, int percentage) {
        long lowerBound = expected * (100 - percentage) / 100;
        long upperBound = expected * (100 + percentage) / 100;
        msg = String.format(""%s: %d not within %d%% of %d"", msg, actual, percentage, expected);
        assertTrue(msg, lowerBound <= actual);
        assertTrue(msg, upperBound >= actual);
    }

    private void assertAlmostNoUnexpectedTraffic(NetworkStats result, int expectedTag,
            int expectedState, long maxUnexpected) {
        long total = 0;
        NetworkStats.Bucket bucket = new NetworkStats.Bucket();
        while (result.hasNextBucket()) {
            assertTrue(result.getNextBucket(bucket));
            total += bucket.getRxBytes() + bucket.getTxBytes();
        }
        if (total <= maxUnexpected) return;

        fail(String.format(""More than %d bytes of traffic when querying for ""
                + ""tag %s state %s. Last bucket: uid=%d tag=%s state=%s bytes=%d/%d"",
                maxUnexpected, tagToString(expectedTag), stateToString(expectedState),
                bucket.getUid(), tagToString(bucket.getTag()), stateToString(bucket.getState()),
                bucket.getRxBytes(), bucket.getTxBytes()));
    }

    @AppModeFull"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/NetworkUsageStatsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.app.usage.cts.NetworkUsageStatsTest"	"testUidTagStateDetails"	"CtsUsageStatsTestCases"	"2: interfaces ui"	"public void testUidTagStateDetails() throws Exception {
        for (int i = 0; i < mNetworkInterfacesToTest.length; ++i) {
            // Relatively large tolerance to accommodate for history bucket size.
            if (!shouldTestThisNetworkType(i, MINUTE * 120)) {
                continue;
            }
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, ""allow"");
            NetworkStats result = null;
            try {
                int currentState = isInForeground() ? STATE_FOREGROUND : STATE_DEFAULT;
                int otherState = (currentState == STATE_DEFAULT) ? STATE_FOREGROUND : STATE_DEFAULT;

                int[] tagsWithTraffic = {NETWORK_TAG, TAG_NONE};
                int[] statesWithTraffic = {currentState, STATE_ALL};
                ArrayList<QueryResult> resultsWithTraffic = new ArrayList<>();

                int[] statesWithNoTraffic = {otherState};
                int[] tagsWithNoTraffic = {NETWORK_TAG + 1};
                ArrayList<QueryResult> resultsWithNoTraffic = new ArrayList<>();

                // Expect to see traffic when querying for any combination of a tag in
                // tagsWithTraffic and a state in statesWithTraffic.
                for (int tag : tagsWithTraffic) {
                    for (int state : statesWithTraffic) {
                        result = getNetworkStatsForTagState(i, tag, state);
                        resultsWithTraffic.add(new QueryResult(tag, state, result));
                        result.close();
                        result = null;
                    }
                }

                // Expect that the results are within a few percentage points of each other.
                // This is ensures that FIN retransmits after the transfer is complete don't cause
                // the test to be flaky. The test URL currently returns just over 100k so this
                // should not be too noisy. It also ensures that the traffic sent by the test
                // harness, which is untagged, won't cause a failure.
                long firstTotal = resultsWithTraffic.get(0).total;
                for (QueryResult queryResult : resultsWithTraffic) {
                    assertWithinPercentage(queryResult + """", firstTotal, queryResult.total, 10);
                }

                // Expect to see no traffic when querying for any tag in tagsWithNoTraffic or any
                // state in statesWithNoTraffic.
                for (int tag : tagsWithNoTraffic) {
                    for (int state : statesWithTraffic) {
                        result = getNetworkStatsForTagState(i, tag, state);
                        assertAlmostNoUnexpectedTraffic(result, tag, state, firstTotal / 100);
                        result.close();
                        result = null;
                    }
                }
                for (int tag : tagsWithTraffic) {
                    for (int state : statesWithNoTraffic) {
                        result = getNetworkStatsForTagState(i, tag, state);
                        assertAlmostNoUnexpectedTraffic(result, tag, state, firstTotal / 100);
                        result.close();
                        result = null;
                    }
                }
            } finally {
                if (result != null) {
                    result.close();
                }
            }
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, ""deny"");
            try {
                result = mNsm.queryDetailsForUidTag(
                        mNetworkInterfacesToTest[i].getNetworkType(), getSubscriberId(i),
                        mStartTime, mEndTime, Process.myUid(), NETWORK_TAG);
                fail(""negative testUidDetails fails: no exception thrown."");
            } catch (SecurityException e) {
                // expected outcome
            }
        }
    }

    @AppModeFull"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/NetworkUsageStatsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.app.usage.cts.NetworkUsageStatsTest"	"testCallback"	"CtsUsageStatsTestCases"	"2: interfaces ui"	"public void testCallback() throws Exception {
        for (int i = 0; i < mNetworkInterfacesToTest.length; ++i) {
            // Relatively large tolerance to accommodate for history bucket size.
            if (!shouldTestThisNetworkType(i, MINUTE/2)) {
                continue;
            }
            setAppOpsMode(AppOpsManager.OPSTR_GET_USAGE_STATS, ""allow"");

            TestUsageCallback usageCallback = new TestUsageCallback();
            HandlerThread thread = new HandlerThread(""callback-thread"");
            thread.start();
            Handler handler = new Handler(thread.getLooper());
            mNsm.registerUsageCallback(mNetworkInterfacesToTest[i].getNetworkType(),
                    getSubscriberId(i), THRESHOLD_BYTES, usageCallback, handler);

            // TODO: Force traffic and check whether the callback is invoked.
            // Right now the test only covers whether the callback can be registered, but not
            // whether it is invoked upon data usage since we don't have a scalable way of
            // storing files of >2MB in CTS.

            mNsm.unregisterUsageCallback(usageCallback);
        }
    }

    private String tagToString(Integer tag) {
        if (tag == null) return ""null"";
        switch (tag) {
            case TAG_NONE:
                return ""TAG_NONE"";
            default:
                return ""0x"" + Integer.toHexString(tag);
        }
    }

    private String stateToString(Integer state) {
        if (state == null) return ""null"";
        switch (state) {
            case STATE_ALL:
                return ""STATE_ALL"";
            case STATE_DEFAULT:
                return ""STATE_DEFAULT"";
            case STATE_FOREGROUND:
                return ""STATE_FOREGROUND"";
        }
        throw new IllegalArgumentException(""Unknown state "" + state);
    }

    private long getTotalAndAssertNotEmpty(NetworkStats result, Integer expectedTag,
            Integer expectedState) {
        assertTrue(result != null);
        NetworkStats.Bucket bucket = new NetworkStats.Bucket();
        long totalTxPackets = 0;
        long totalRxPackets = 0;
        long totalTxBytes = 0;
        long totalRxBytes = 0;
        while (result.hasNextBucket()) {
            assertTrue(result.getNextBucket(bucket));
            assertTimestamps(bucket);
            if (expectedTag != null) assertEquals(bucket.getTag(), (int) expectedTag);
            if (expectedState != null) assertEquals(bucket.getState(), (int) expectedState);
            assertEquals(bucket.getMetered(), METERED_ALL);
            assertEquals(bucket.getDefaultNetworkStatus(), DEFAULT_NETWORK_ALL);
            if (bucket.getUid() == Process.myUid()) {
                totalTxPackets += bucket.getTxPackets();
                totalRxPackets += bucket.getRxPackets();
                totalTxBytes += bucket.getTxBytes();
                totalRxBytes += bucket.getRxBytes();
            }
        }
        assertFalse(result.getNextBucket(bucket));
        String msg = String.format(""uid %d tag %s state %s"",
                Process.myUid(), tagToString(expectedTag), stateToString(expectedState));
        assertTrue(""No Rx bytes usage for "" + msg, totalRxBytes > 0);
        assertTrue(""No Rx packets usage for "" + msg, totalRxPackets > 0);
        assertTrue(""No Tx bytes usage for "" + msg, totalTxBytes > 0);
        assertTrue(""No Tx packets usage for "" + msg, totalTxPackets > 0);

        return totalRxBytes + totalTxBytes;
    }

    private long getTotalAndAssertNotEmpty(NetworkStats result) {
        return getTotalAndAssertNotEmpty(result, null, STATE_ALL);
    }

    private void assertTimestamps(final NetworkStats.Bucket bucket) {
        assertTrue(""Start timestamp "" + bucket.getStartTimeStamp() + "" is less than "" +
                mStartTime, bucket.getStartTimeStamp() >= mStartTime);
        assertTrue(""End timestamp "" + bucket.getEndTimeStamp() + "" is greater than "" +
                mEndTime, bucket.getEndTimeStamp() <= mEndTime);
    }

    private static class TestUsageCallback extends NetworkStatsManager.UsageCallback {
        @Override
        public void onThresholdReached(int networkType, String subscriberId) {
            Log.v(LOG_TAG, ""Called onThresholdReached for networkType="" + networkType
                    + "" subscriberId="" + subscriberId);
        }
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/app.usage/src/android/app/usage/cts/NetworkUsageStatsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"java.android.signature.cts.api.SignatureTest"	"testSignature"	""	"1: system"	"public void testSignature() {
        runWithTestResultObserver(mResultObserver -> {
            Set<JDiffClassDescription> unexpectedClasses = loadUnexpectedClasses();
            for (JDiffClassDescription classDescription : unexpectedClasses) {
                Class<?> unexpectedClass = findUnexpectedClass(classDescription, mClassProvider);
                if (unexpectedClass != null) {
                    mResultObserver.notifyFailure(
                            FailureType.UNEXPECTED_CLASS,
                            classDescription.getAbsoluteClassName(),
                            ""Class should not be accessible to this APK"");
                }
            }

            ApiComplianceChecker complianceChecker =
                    new ApiComplianceChecker(mResultObserver, mClassProvider);

            // Load classes from any API files that form the base which the expected APIs extend.
            loadBaseClasses(complianceChecker);
            // Load classes from system API files and check for signature compliance.
            checkClassesSignatureCompliance(complianceChecker, expectedApiFiles, unexpectedClasses,
                    false /* isPreviousApi */);
            // Load classes from previous API files and check for signature compliance.
            checkClassesSignatureCompliance(complianceChecker, previousApiFiles, unexpectedClasses,
                    true /* isPreviousApi */);

            // After done parsing all expected API files, perform any deferred checks.
            complianceChecker.checkDeferred();
        });
    }

    private static <T> Predicate<T> not(Predicate<T> predicate) {
        return predicate.negate();
    }

    private Class<?> findUnexpectedClass(JDiffClassDescription classDescription,
            ClassProvider classProvider) {
        try {
            return ReflectionHelper.findMatchingClass(classDescription, classProvider);
        } catch (ClassNotFoundException e) {
            return null;
        }
    }

    private Set<JDiffClassDescription> loadUnexpectedClasses() {
        ApiDocumentParser apiDocumentParser = new ApiDocumentParser(TAG);
        return parseApiResourcesAsStream(apiDocumentParser, unexpectedApiFiles)
                .collect(Collectors.toCollection(SignatureTest::newSetOfClassDescriptions));
    }

    private static TreeSet<JDiffClassDescription> newSetOfClassDescriptions() {
        return new TreeSet<>(Comparator.comparing(JDiffClassDescription::getAbsoluteClassName));
    }

    private void loadBaseClasses(ApiComplianceChecker complianceChecker) {
        ApiDocumentParser apiDocumentParser = new ApiDocumentParser(TAG);
        parseApiResourcesAsStream(apiDocumentParser, baseApiFiles)
                .forEach(complianceChecker::addBaseClass);
    }

    private void checkClassesSignatureCompliance(ApiComplianceChecker complianceChecker,
            String[] classes, Set<JDiffClassDescription> unexpectedClasses, boolean isPreviousApi) {
        ApiDocumentParser apiDocumentParser = new ApiDocumentParser(TAG);
        parseApiResourcesAsStream(apiDocumentParser, classes)
                .filter(not(unexpectedClasses::contains))
                .map(clazz -> clazz.setPreviousApiFlag(isPreviousApi))
                .forEach(complianceChecker::checkSignatureCompliance);
    }

}"	"/home/gpoor/cts-12-source/cts/tests/signature/api-check/src/java/android/signature/cts/api/SignatureTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.hardware.camera2.cts.testcases.Camera2ConcurrentAndroidTestCase"	"isInstantApp"	"CtsCameraTestCases"	"2: ui system"	"public void test/*
 *.
 */

package android.hardware.camera2.cts.testcases;

import static android.hardware.camera2.cts.CameraTestUtils.*;
import static com.android.ex.camera2.blocking.BlockingStateCallback.*;

import android.content.Context;
import android.graphics.ImageFormat;
import android.graphics.Rect;
import android.hardware.camera2.CameraCaptureSession;
import android.hardware.camera2.CameraCaptureSession.CaptureCallback;
import android.hardware.camera2.CameraCharacteristics;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CameraManager;
import android.hardware.camera2.CaptureRequest;
import android.hardware.camera2.params.MandatoryStreamCombination;
import android.hardware.camera2.params.MandatoryStreamCombination.MandatoryStreamInformation;
import android.hardware.camera2.params.OutputConfiguration;
import android.hardware.camera2.cts.Camera2ParameterizedTestCase;
import android.hardware.camera2.cts.CameraTestUtils;
import android.hardware.camera2.cts.helpers.CameraErrorCollector;
import android.hardware.camera2.cts.helpers.StaticMetadata;
import android.hardware.camera2.cts.helpers.StaticMetadata.CheckLevel;
import android.os.Handler;
import android.os.HandlerThread;
import android.test.AndroidTestCase;
import android.util.Log;
import android.view.Surface;
import android.view.WindowManager;

import com.android.ex.camera2.blocking.BlockingSessionCallback;
import com.android.ex.camera2.blocking.BlockingStateCallback;

import java.io.File;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Set;

public class Camera2ConcurrentAndroidTestCase extends Camera2ParameterizedTestCase {
    private static final String TAG = ""Camera2ConcurrentAndroidTestCase"";
    private static final boolean VERBOSE = Log.isLoggable(TAG, Log.VERBOSE);
    public static class CameraTestInfo {
        public String mCameraId;
        public CameraDevice mCamera;
        public StaticMetadata mStaticInfo;
        public MandatoryStreamCombination[] mMandatoryStreamCombinations;
        public CameraCaptureSession mCameraSession;
        public BlockingSessionCallback mCameraSessionListener;
        public BlockingStateCallback mCameraListener;
        public CameraTestInfo(String cameraId, StaticMetadata staticInfo,
                MandatoryStreamCombination[] mandatoryStreamCombinations,
                BlockingStateCallback cameraListener) {
            mCameraId = cameraId;
            mStaticInfo = staticInfo;
            mMandatoryStreamCombinations = mandatoryStreamCombinations;
            mCameraListener = cameraListener;
        }
    };
    protected Set<Set<String>> mConcurrentCameraIdCombinations;
    protected HashMap<String, CameraTestInfo> mCameraTestInfos;
    // include both standalone camera IDs and ""hidden"" physical camera IDs
    protected String[] mAllCameraIds;
    protected HashMap<String, StaticMetadata> mAllStaticInfo;
    protected Handler mHandler;
    protected HandlerThread mHandlerThread;
    protected CameraErrorCollector mCollector;
    protected String mDebugFileNameBase;

    protected WindowManager mWindowManager;

    /**
     * Set up the camera2 test case required environments, including CameraManager,
     * HandlerThread, Camera IDs, and CameraStateCallback etc.
     */
    @Override
    public void setUp() throws Exception {
        super.setUp();
        mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
        mHandlerThread = new HandlerThread(TAG);
        mHandlerThread.start();
        mHandler = new Handler(mHandlerThread.getLooper());
        mCollector = new CameraErrorCollector();

        File filesDir = mContext.getPackageManager().isInstantApp()
                ? mContext.getFilesDir()
                : mContext.getExternalFilesDir(null);

        mDebugFileNameBase = filesDir.getPath();
        mAllStaticInfo = new HashMap<String, StaticMetadata>();
        List<String> hiddenPhysicalIds = new ArrayList<>();
        for (String cameraId : mCameraIdsUnderTest) {
            CameraCharacteristics props = mCameraManager.getCameraCharacteristics(cameraId);
            StaticMetadata staticMetadata = new StaticMetadata(props,
                    CheckLevel.ASSERT, /*collector*/null);
            mAllStaticInfo.put(cameraId, staticMetadata);
            for (String physicalId : props.getPhysicalCameraIds()) {
                if (!Arrays.asList(mCameraIdsUnderTest).contains(physicalId) &&
                        !hiddenPhysicalIds.contains(physicalId)) {
                    hiddenPhysicalIds.add(physicalId);
                    props = mCameraManager.getCameraCharacteristics(physicalId);
                    staticMetadata = new StaticMetadata(
                            mCameraManager.getCameraCharacteristics(physicalId),
                            CheckLevel.ASSERT, /*collector*/null);
                    mAllStaticInfo.put(physicalId, staticMetadata);
                }
            }
        }
        mConcurrentCameraIdCombinations =
                CameraTestUtils.getConcurrentCameraIds(mCameraManager, mAdoptShellPerm);
        assertNotNull(""Unable to get concurrent camera combinations"",
                mConcurrentCameraIdCombinations);
        mCameraTestInfos = new HashMap<String, CameraTestInfo>();
        for (Set<String> cameraIdComb : mConcurrentCameraIdCombinations) {
            for (String cameraId : cameraIdComb) {
                if (!mCameraTestInfos.containsKey(cameraId)) {
                    StaticMetadata staticMetadata = mAllStaticInfo.get(cameraId);
                    assertTrue(""camera id"" + cameraId + ""'s metadata not found in mAllStaticInfo"",
                            staticMetadata != null);
                    CameraCharacteristics.Key<MandatoryStreamCombination[]> mandatoryStreamsKey =
                            CameraCharacteristics.SCALER_MANDATORY_CONCURRENT_STREAM_COMBINATIONS;
                    MandatoryStreamCombination[] combinations =
                            staticMetadata.getCharacteristics().get(mandatoryStreamsKey);
                    assertTrue(""Concurrent streaming camera id "" + cameraId +
                            ""  MUST have mandatory stream combinations"",
                            (combinations != null) && (combinations.length > 0));
                    mCameraTestInfos.put(cameraId,
                            new CameraTestInfo(cameraId, staticMetadata, combinations,
                                  new BlockingStateCallback()));
                }
            }
        }

        mAllCameraIds = new String[mCameraIdsUnderTest.length + hiddenPhysicalIds.size()];
        System.arraycopy(mCameraIdsUnderTest, 0, mAllCameraIds, 0, mCameraIdsUnderTest.length);
        for (int i = 0; i < hiddenPhysicalIds.size(); i++) {
            mAllCameraIds[mCameraIdsUnderTest.length + i] = hiddenPhysicalIds.get(i);
        }
    }

    @Override
    public void tearDown() throws Exception {
        try {
            if (mHandlerThread != null) {
                mHandlerThread.quitSafely();
            }
            mHandler = null;

            if (mCollector != null) {
                mCollector.verify();
            }
        } catch (Throwable e) {
            // When new Exception(e) is used, exception info will be printed twice.
            throw new Exception(e.getMessage());
        } finally {
            super.tearDown();
        }
    }

    /**
     * Start capture with given {@link #CaptureRequest}.
     *
     * @param request The {@link #CaptureRequest} to be captured.
     * @param repeating If the capture is single capture or repeating.
     * @param listener The {@link #CaptureCallback} camera device used to notify callbacks.
     * @param handler The handler camera device used to post callbacks.
     */
    protected void startCapture(String cameraId, CaptureRequest request, boolean repeating,
            CaptureCallback listener, Handler handler) throws Exception {
        if (VERBOSE) Log.v(TAG, ""Starting capture from device"");
        CameraTestInfo info = mCameraTestInfos.get(cameraId);
        assertTrue(""CameraTestInfo not found for camera id "" + cameraId, info != null);
        if (repeating) {
            info.mCameraSession.setRepeatingRequest(request, listener, handler);
        } else {
            info.mCameraSession.capture(request, listener, handler);
        }
    }

    /**
     * Stop the current active capture.
     *
     * @param fast When it is true, {@link CameraDevice#flush} is called, the stop capture
     * could be faster.
     */
    protected void stopCapture(String cameraId, boolean fast) throws Exception {
        if (VERBOSE) Log.v(TAG, ""Stopping capture"");

        CameraTestInfo info = mCameraTestInfos.get(cameraId);
        assertTrue(""CameraTest info not found for camera id "" + cameraId, info != null);
        if (fast) {
            /**
             * Flush is useful for canceling long exposure single capture, it also could help
             * to make the streaming capture stop sooner.
             */
            info.mCameraSession.abortCaptures();
            info.mCameraSessionListener.getStateWaiter().
                    waitForState(BlockingSessionCallback.SESSION_READY, CAMERA_IDLE_TIMEOUT_MS);
        } else {
            info.mCameraSession.close();
            info.mCameraSessionListener.getStateWaiter().
                    waitForState(BlockingSessionCallback.SESSION_CLOSED, CAMERA_IDLE_TIMEOUT_MS);
        }
    }

    /**
     * Open a {@link #CameraDevice camera device} and get the StaticMetadata for a given camera id.
     * The default mCameraListener is used to wait for states.
     *
     * @param cameraId The id of the camera device to be opened.
     */
    protected void openDevice(String cameraId) throws Exception {
        CameraTestInfo info = mCameraTestInfos.get(cameraId);
        assertTrue(""CameraTest info not found for camera id "" + cameraId, info != null);
        openDevice(cameraId, info.mCameraListener);
    }

    /**
     * Open a {@link #CameraDevice} and get the StaticMetadata for a given camera id and listener.
     *
     * @param cameraId The id of the camera device to be opened.
     * @param listener The {@link #BlockingStateCallback} used to wait for states.
     */
    protected void openDevice(String cameraId, BlockingStateCallback listener) throws Exception {
        CameraTestInfo info = mCameraTestInfos.get(cameraId);
        assertTrue(""CameraTest info not found for camera id "" + cameraId, info != null);

        info.mCamera = CameraTestUtils.openCamera(
                mCameraManager, cameraId, listener, mHandler);
        mCollector.setCameraId(cameraId);
        if (VERBOSE) {
            Log.v(TAG, ""Camera "" + cameraId + "" is opened"");
        }
    }

    /**
     * Create a {@link #CameraCaptureSession} using the currently open camera with
     * OutputConfigurations.
     *
     * @param outputSurfaces The set of output surfaces to configure for this session
     */
    protected void createSessionByConfigs(String cameraId,
            List<OutputConfiguration> outputConfigs) throws Exception {
        CameraTestInfo info = mCameraTestInfos.get(cameraId);
        assertTrue(""CameraTest info not found for camera id "" + cameraId, info != null);

        info.mCameraSessionListener = new BlockingSessionCallback();
        info.mCameraSession = CameraTestUtils.configureCameraSessionWithConfig(info.mCamera,
                outputConfigs, info.mCameraSessionListener, mHandler);
    }

    /**
     * Close a {@link #CameraDevice camera device} and clear the associated StaticInfo field for a
     * given camera id. The default mCameraListener is used to wait for states.
     * <p>
     * This function must be used along with the {@link #openDevice} for the
     * same camera id.
     * </p>
     *
     * @param cameraId The id of the {@link #CameraDevice camera device} to be closed.
     */
    protected void closeDevice(String cameraId) {
        CameraTestInfo info = mCameraTestInfos.get(cameraId);
        assertTrue(""CameraTest info not found for camera id "" + cameraId, info != null);
        closeDevice(cameraId, info.mCameraListener);
    }

    /**
     * Close a {@link #CameraDevice camera device} and clear the associated StaticInfo field for a
     * given camera id and listener.
     * <p>
     * This function must be used along with the {@link #openDevice} for the
     * same camera id.
     * </p>
     *
     * @param cameraId The id of the camera device to be closed.
     * @param listener The BlockingStateCallback used to wait for states.
     */
    protected void closeDevice(String cameraId, BlockingStateCallback listener) {
        CameraTestInfo info = mCameraTestInfos.get(cameraId);
        assertTrue(""CameraTest info not found for camera id "" + cameraId, info != null);

        if (info.mCamera != null) {
            info.mCamera.close();
            listener.waitForState(STATE_CLOSED, CAMERA_CLOSE_TIMEOUT_MS);
            info.mCamera = null;
            info.mCameraSession = null;
            info.mCameraSessionListener = null;
            if (VERBOSE) {
                Log.v(TAG, ""Camera "" + cameraId + "" is closed"");
            }
        }
    }

}"	"/home/gpoor/cts-12-source/cts/tests/camera/src/android/hardware/camera2/cts/testcases/Camera2ConcurrentAndroidTestCase.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.verifier.sensors.sixdof.Utils.Manager"	"stopListening"	""	"4: interfaces ui system user"	"public void test/*
 *.
 */
package com.android.cts.verifier.sensors.sixdof.Utils;

import com.android.cts.verifier.sensors.sixdof.Dialogs.BaseResultsDialog;
import com.android.cts.verifier.sensors.sixdof.Interfaces.AccuracyListener;
import com.android.cts.verifier.sensors.sixdof.Interfaces.BaseUiListener;
import com.android.cts.verifier.sensors.sixdof.Interfaces.ComplexMovementListener;
import com.android.cts.verifier.sensors.sixdof.Interfaces.RobustnessListener;
import com.android.cts.verifier.sensors.sixdof.Renderer.BaseRenderer;
import com.android.cts.verifier.sensors.sixdof.Utils.Exceptions.WaypointAreaCoveredException;
import com.android.cts.verifier.sensors.sixdof.Utils.Exceptions.WaypointDistanceException;
import com.android.cts.verifier.sensors.sixdof.Utils.Exceptions.WaypointException;
import com.android.cts.verifier.sensors.sixdof.Utils.Exceptions.WaypointRingNotEnteredException;
import com.android.cts.verifier.sensors.sixdof.Utils.Exceptions.WaypointStartPointException;
import com.android.cts.verifier.sensors.sixdof.Utils.Path.ReferencePath;
import com.android.cts.verifier.sensors.sixdof.Utils.Path.PathUtilityClasses.Ring;
import com.android.cts.verifier.sensors.sixdof.Utils.Path.PathUtilityClasses.RotationData;
import com.android.cts.verifier.sensors.sixdof.Utils.Path.PathUtilityClasses.Waypoint;
import com.android.cts.verifier.sensors.sixdof.Utils.PoseProvider.PoseData;
import com.android.cts.verifier.sensors.sixdof.Utils.ResultObjects.ResultObject;
import com.android.cts.verifier.sensors.sixdof.Utils.TestPhase.AccuracyTest;
import com.android.cts.verifier.sensors.sixdof.Utils.TestPhase.ComplexMovementTest;
import com.android.cts.verifier.sensors.sixdof.Utils.TestPhase.RobustnessTest;

import android.content.Context;

import java.util.ArrayList;
import java.util.HashMap;

/**
 * Manages all of the tests.
 */
public class Manager {
    private Lap mLap = Lap.LAP_1;
    public static final int MAX_MARKER_NUMBER = 5;
    private ReferencePath mReferencePath = new ReferencePath();
    private AccuracyTest mAccuracyTest;
    private RobustnessTest mRobustnessTest;
    private ComplexMovementTest mComplexMovementTest;
    private TestReport mTestReport;
    private float mRemainingPath;
    private long mTimeRemaining;

    public enum Lap {
        LAP_1,
        LAP_2,
        LAP_3,
        LAP_4,
    }

    private ComplexMovementListener mComplexMovementListener;
    private RobustnessListener mRobustnessListener;
    private AccuracyListener mAccuracyListener;
    private BaseUiListener mBaseUiListener;

    /**
     * Links the listeners to the activity.
     *
     * @param context reference to the activity.
     */
    public void setupListeners(Context context) {
        mAccuracyListener = (AccuracyListener) context;
        mRobustnessListener = (RobustnessListener) context;
        mComplexMovementListener = (ComplexMovementListener) context;
        mBaseUiListener = (BaseUiListener) context;
    }

    /**
     * Removes the references to the activity so that the activity can be properly terminated.
     */
    public void stopListening() {
        mRobustnessListener = null;
        mAccuracyListener = null;
        mBaseUiListener = null;
        mComplexMovementListener = null;
    }

    public void ringEntered(Ring ring) {
        mComplexMovementListener.onRingEntered(ring);
    }

    /**
     * Indicated that the pose provider is ready.
     */
    public void onPoseProviderReady() {
        mBaseUiListener.onPoseProviderReady();
    }

    /**
     * Constructor for the class.
     *
     * @param testReport a reference to the test report to be used to record failures.
     */
    public Manager(TestReport testReport) {
        mTestReport = testReport;
    }

    /**
     * Adds the waypoint data to the appropriate path.
     *
     * @param coordinates   the coordinates to use for the waypoint.
     * @param userGenerated indicates whether the data was user created or system created.
     * @throws WaypointDistanceException    if the location is too close to another.
     * @throws WaypointAreaCoveredException if the area covered by the user is too little.
     * @throws WaypointStartPointException  if the location is not close enough to the start.
     */
    public void addPoseDataToPath(
            float[] coordinates, boolean userGenerated)
            throws WaypointAreaCoveredException, WaypointDistanceException,
            WaypointStartPointException, WaypointRingNotEnteredException {
        switch (mLap) {
            case LAP_1:
                try {
                    mReferencePath.createWaypointAndAddToPath(coordinates, userGenerated, mLap);
                } catch (WaypointStartPointException exception) {
                    float[] initialCoords = mReferencePath.getPathMarkers().get(0).getCoordinates();
                    String initialWaypointCoords =
                            MathsUtils.coordinatesToString(initialCoords);
                    String distance = String.valueOf(
                            MathsUtils.distanceCalculationInXYZSpace(
                                    initialCoords, coordinates));
                    String details = ""Not close enough to initial waypoint:\n""
                            + ""Distance:""
                            + distance
                            + ""\nInitial Waypoint Coordinates: ""
                            + initialWaypointCoords
                            + ""\nAttempted placement coordinates: ""
                            + MathsUtils.coordinatesToString(coordinates);
                    mTestReport.setFailDetails(details);

                    // We still need to give the exception to UI to display message.
                    throw exception;
                }

                if (mReferencePath.getPathMarkersSize() == MAX_MARKER_NUMBER) {
                    mAccuracyListener.lap1Complete();
                }
                break;
            case LAP_2:
                mAccuracyTest.addWaypointDataToPath(coordinates, userGenerated, mLap);
                break;
            case LAP_3:
                mRobustnessTest.addWaypointDataToPath(coordinates, userGenerated, mLap);
                break;
            case LAP_4:
                mComplexMovementTest.addWaypointDataToPath(coordinates, userGenerated, mLap);
                break;
            default:
                throw new AssertionError(""addPoseDataToPath default: Unrecognised lap"", null);
        }
        if (userGenerated) {
            mBaseUiListener.onWaypointPlaced();
        }
    }

    /**
     * Removes the last marker from the current lap.
     */
    public void removeLastAddedMarker() {
        boolean resetTest;
        switch (mLap) {
            case LAP_1:
                resetTest = mReferencePath.removeLastMarker();
                break;
            case LAP_2:
                resetTest = mAccuracyTest.removeLastAddedMarker();
                break;
            case LAP_3:
                resetTest = mRobustnessTest.removeLastAddedMarker();
                break;
            case LAP_4:
                resetTest = mComplexMovementTest.removeLastAddedMarker();
                break;
            default:
                throw new AssertionError(""removeLastAddedMarker default: Unrecognised lap"", null);
        }
        if (resetTest) {
            mAccuracyListener.onReset();
        }
    }

    /**
     * Initiates the accuracy test.
     */
    public void startAccuracyTest() {
        mAccuracyTest = new AccuracyTest(mReferencePath, mTestReport, this);
        mLap = Lap.LAP_2;
    }

    /**
     * Initiates the robustness test.
     */
    public void startRobustnessTest() {
        mRobustnessTest = new RobustnessTest(mReferencePath, mTestReport, this,
                BaseRenderer.getDeviceRotation((Context) mBaseUiListener));
        mLap = Lap.LAP_3;

    }

    /**
     * Initiates the complex movement test.
     */
    public void startComplexMovementTest() {
        mComplexMovementTest = new ComplexMovementTest(mReferencePath, mTestReport, this);
        mLap = Lap.LAP_4;
    }

    /**
     * Indicates that the accuracy test has been completed.
     *
     * @param passList A list to indicate whether the test passes or not.
     */
    public void onAccuracyTestCompleted(HashMap<BaseResultsDialog.ResultType, Boolean> passList) {
        mBaseUiListener.onResult(new ResultObject(passList));
    }

    /**
     * Indicates that the robustness test has been completed.
     *
     * @param robustnessTestResults List containing information about whether the tests failed or
     *                              passed.
     */
    public void onRobustnessTestCompleted(HashMap<BaseResultsDialog.ResultType, Boolean> robustnessTestResults) {
        ResultObject robustnessResult = new ResultObject(robustnessTestResults);
        mBaseUiListener.onResult(robustnessResult);
    }

    /**
     * Indicates that the complex movement test has been completed.
     *
     * @param complexMovementTestResults List containing information about whether the tests failed
     *                                   or passed.
     */
    public void onComplexMovementTestCompleted(HashMap<BaseResultsDialog.ResultType, Boolean> complexMovementTestResults) {
        ResultObject complexMovementResult = new ResultObject(complexMovementTestResults);

        if (complexMovementResult.hasPassed()) {
            mTestReport.setTestState(TestReport.TestStatus.PASS);
        }

        mBaseUiListener.onResult(complexMovementResult);
    }

    /**
     * Sets the path remaining for the user to travel.
     */
    public void calculateRemainingPath() {
        mRemainingPath = mReferencePath.calculatePathRemaining();
    }

    /**
     * Uses the current rotation and location to calculate the rotation detail's. Also gives the UI
     * information about the rotation.
     *
     * @param rotations   Quaternion containing the current rotation.
     * @param translation The location the rotation occurred.
     */
    public void calculateRotationData(float[] rotations, float[] translation) {
        RotationData rotationData = mRobustnessTest.getRotationData(rotations, translation);
        if (rotationData != null) {
            mRobustnessListener.onNewRotationData(rotationData);
        }
    }

    /**
     * Sets the time remaining to place a waypoint.
     */
    public void calculateTimeRemaining() {
        mTimeRemaining = mRobustnessTest.getTimeRemaining();
    }

    /**
     * Handles new pose data.
     *
     * @param currentPose The current pose data.
     */
    public void onNewPoseData(PoseData currentPose) {
        if (mReferencePath.getCurrentPathSize() != 0) {
            switch (mLap) {
                case LAP_1:
                    calculateRemainingPath();
                    break;
                case LAP_2:
                    break;
                case LAP_3:
                    if (mRobustnessTest.getTestPathMarkersSize() > 0) {
                        calculateTimeRemaining();
                        calculateRotationData(currentPose.getRotationAsFloats(), currentPose.getTranslationAsFloats());
                    }
                    break;
                case LAP_4:
                    mComplexMovementTest.checkIfARingHasBeenPassed(currentPose.getTranslationAsFloats());
                    break;
            }
            try {
                addPoseDataToPath(currentPose.getTranslationAsFloats(),
                        false);
            } catch (WaypointException e) {
                throw new AssertionError(
                        ""System added waypoint should not be validated"", e);
            }
        }
    }

    /**
     * Returns the distance remaining to travel by the user.
     */
    public float getRemainingPath() {
        return mRemainingPath;
    }

    /**
     * Returns the makers in the reference path.
     */
    public ArrayList<Waypoint> getReferencePathMarkers() {
        return mReferencePath.getPathMarkers();
    }

    /**
     * Returns the makers in the accuracy test path.
     */
    public ArrayList<Waypoint> getTestPathMarkers() {
        return mAccuracyTest.getTestPathMarkers();
    }

    /**
     * Returns the time remaining to place the marker.
     */
    public long getTimeRemaining() {
        return mTimeRemaining;
    }

    /**
     * Returns the markers in the robustness test path.
     */
    public ArrayList<Waypoint> getRobustnessMarker() {
        return mRobustnessTest.getTestPathMarkers();
    }

    /**
     * Returns the current phase of the test.
     */
    public Lap getLap() {
        return mLap;
    }

    /**
     * Returns the rings in the ComplexMovement path.
     */
    public ArrayList<Ring> getRings() {
        return mComplexMovementTest.getRings();
    }

    /**
     * Returns the makers in the ComplexMovement test path.
     */
    public ArrayList<Waypoint> getComplexMovementTestMarkers() {
        return mComplexMovementTest.getTestPathMarkers();
    }
}"	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/sensors/sixdof/Utils/Manager.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.location.cts.gnss.asn1.supl2.ver2_ulp_components.ApplicationID"	"isTagImplicit"	"CtsLocationGnssTestCases"	"1: ui"	"public void test/*
 *.
 */

package android.location.cts.asn1.supl2.ver2_ulp_components;

/*
 */


//
//
import android.location.cts.asn1.base.Asn1IA5String;
import android.location.cts.asn1.base.Asn1Null;
import android.location.cts.asn1.base.Asn1Object;
import android.location.cts.asn1.base.Asn1Sequence;
import android.location.cts.asn1.base.Asn1Tag;
import android.location.cts.asn1.base.BitStream;
import android.location.cts.asn1.base.BitStreamReader;
import android.location.cts.asn1.base.SequenceComponent;
import com.google.common.collect.ImmutableList;
import java.util.Collection;
import javax.annotation.Nullable;


/**
*/
public  class ApplicationID extends Asn1Sequence {
  //

  private static final Asn1Tag TAG_ApplicationID
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public ApplicationID() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_ApplicationID;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_ApplicationID != null) {
      return ImmutableList.of(TAG_ApplicationID);
    } else {
      return Asn1Sequence.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new ApplicationID from encoded stream.
   */
  public static ApplicationID fromPerUnaligned(byte[] encodedBytes) {
    ApplicationID result = new ApplicationID();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new ApplicationID from encoded stream.
   */
  public static ApplicationID fromPerAligned(byte[] encodedBytes) {
    ApplicationID result = new ApplicationID();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }



  @Override protected boolean isExtensible() {
    return true;
  }

  @Override public boolean containsExtensionValues() {
    for (SequenceComponent extensionComponent : getExtensionComponents()) {
      if (extensionComponent.isExplicitlySet()) return true;
    }
    return false;
  }

  
  private ApplicationID.appProviderType appProvider_;
  public ApplicationID.appProviderType getAppProvider() {
    return appProvider_;
  }
  /**
   * @throws ClassCastException if value is not a ApplicationID.appProviderType
   */
  public void setAppProvider(Asn1Object value) {
    this.appProvider_ = (ApplicationID.appProviderType) value;
  }
  public ApplicationID.appProviderType setAppProviderToNewInstance() {
    appProvider_ = new ApplicationID.appProviderType();
    return appProvider_;
  }
  
  private ApplicationID.appNameType appName_;
  public ApplicationID.appNameType getAppName() {
    return appName_;
  }
  /**
   * @throws ClassCastException if value is not a ApplicationID.appNameType
   */
  public void setAppName(Asn1Object value) {
    this.appName_ = (ApplicationID.appNameType) value;
  }
  public ApplicationID.appNameType setAppNameToNewInstance() {
    appName_ = new ApplicationID.appNameType();
    return appName_;
  }
  
  private ApplicationID.appVersionType appVersion_;
  public ApplicationID.appVersionType getAppVersion() {
    return appVersion_;
  }
  /**
   * @throws ClassCastException if value is not a ApplicationID.appVersionType
   */
  public void setAppVersion(Asn1Object value) {
    this.appVersion_ = (ApplicationID.appVersionType) value;
  }
  public ApplicationID.appVersionType setAppVersionToNewInstance() {
    appVersion_ = new ApplicationID.appVersionType();
    return appVersion_;
  }
  

  

  

  @Override public Iterable<? extends SequenceComponent> getComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 0);

          @Override public boolean isExplicitlySet() {
            return getAppProvider() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getAppProvider();
          }

          @Override public void setToNewInstance() {
            setAppProviderToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? ApplicationID.appProviderType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""appProvider : ""
                    + getAppProvider().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 1);

          @Override public boolean isExplicitlySet() {
            return getAppName() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getAppName();
          }

          @Override public void setToNewInstance() {
            setAppNameToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? ApplicationID.appNameType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""appName : ""
                    + getAppName().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 2);

          @Override public boolean isExplicitlySet() {
            return getAppVersion() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return true;
          }

          @Override public Asn1Object getComponentValue() {
            return getAppVersion();
          }

          @Override public void setToNewInstance() {
            setAppVersionToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? ApplicationID.appVersionType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""appVersion : ""
                    + getAppVersion().toIndentedString(indent);
              }
        });
    
    return builder.build();
  }

  @Override public Iterable<? extends SequenceComponent>
                                                    getExtensionComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
      
      return builder.build();
    }

  
/*
 */


//

/**
 */
public static class appProviderType extends Asn1IA5String {
  //

  private static final Asn1Tag TAG_appProviderType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public appProviderType() {
    super();
    setMinSize(1);
setMaxSize(24);

    
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_appProviderType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_appProviderType != null) {
      return ImmutableList.of(TAG_appProviderType);
    } else {
      return Asn1IA5String.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new appProviderType from encoded stream.
   */
  public static appProviderType fromPerUnaligned(byte[] encodedBytes) {
    appProviderType result = new appProviderType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new appProviderType from encoded stream.
   */
  public static appProviderType fromPerAligned(byte[] encodedBytes) {
    appProviderType result = new appProviderType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""appProviderType = "" + getValue() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class appNameType extends Asn1IA5String {
  //

  private static final Asn1Tag TAG_appNameType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public appNameType() {
    super();
    setMinSize(1);
setMaxSize(32);

    
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_appNameType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_appNameType != null) {
      return ImmutableList.of(TAG_appNameType);
    } else {
      return Asn1IA5String.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new appNameType from encoded stream.
   */
  public static appNameType fromPerUnaligned(byte[] encodedBytes) {
    appNameType result = new appNameType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new appNameType from encoded stream.
   */
  public static appNameType fromPerAligned(byte[] encodedBytes) {
    appNameType result = new appNameType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""appNameType = "" + getValue() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class appVersionType extends Asn1IA5String {
  //

  private static final Asn1Tag TAG_appVersionType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public appVersionType() {
    super();
    setMinSize(1);
setMaxSize(8);

    
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_appVersionType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_appVersionType != null) {
      return ImmutableList.of(TAG_appVersionType);
    } else {
      return Asn1IA5String.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new appVersionType from encoded stream.
   */
  public static appVersionType fromPerUnaligned(byte[] encodedBytes) {
    appVersionType result = new appVersionType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new appVersionType from encoded stream.
   */
  public static appVersionType fromPerAligned(byte[] encodedBytes) {
    appVersionType result = new appVersionType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""appVersionType = "" + getValue() + "";\n"";
  }
}

  

    

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    StringBuilder builder = new StringBuilder();
    builder.append(""ApplicationID = {\n"");
    final String internalIndent = indent + ""  "";
    for (SequenceComponent component : getComponents()) {
      if (component.isExplicitlySet()) {
        builder.append(internalIndent)
            .append(component.toIndentedString(internalIndent));
      }
    }
    if (isExtensible()) {
      builder.append(internalIndent).append(""...\n"");
      for (SequenceComponent component : getExtensionComponents()) {
        if (component.isExplicitlySet()) {
          builder.append(internalIndent)
              .append(component.toIndentedString(internalIndent));
        }
      }
    }
    builder.append(indent).append(""};\n"");
    return builder.toString();
  }
}"	"/home/gpoor/cts-12-source/cts/tests/location/location_gnss/src/android/location/cts/gnss/asn1/supl2/ver2_ulp_components/ApplicationID.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.renderscript.cts.SamplerTest"	"testSamplerBuilder"	"CtsRenderscriptTestCases"	"1: ui"	"public void testSamplerBuilder() {
        for (int aniso = 1; aniso <= 4; aniso++) {
            for (Sampler.Value minV : Sampler.Value.values()) {
                for (Sampler.Value magV : Sampler.Value.values()) {
                    for (Sampler.Value wrapSV : Sampler.Value.values()) {
                        for (Sampler.Value wrapTV : Sampler.Value.values()) {
                            Sampler.Builder b = new Sampler.Builder(mRS);
                            b.setAnisotropy(aniso);

                            // Some value combinations are illegal
                            boolean validMin = contains(mMinValues, minV);
                            boolean validMag = contains(mMagValues, magV);
                            boolean validS = contains(mWrapValues, wrapSV);
                            boolean validT = contains(mWrapValues, wrapTV);

                            try {
                                b.setMinification(minV);
                            } catch (IllegalArgumentException e) {
                                assertFalse(validMin);
                            }
                            try {
                                b.setMagnification(magV);
                            } catch (IllegalArgumentException e) {
                                assertFalse(validMag);
                            }
                            try {
                                b.setWrapS(wrapSV);
                            } catch (IllegalArgumentException e) {
                                assertFalse(validS);
                            }
                            try {
                                b.setWrapT(wrapTV);
                            } catch (IllegalArgumentException e) {
                                assertFalse(validT);
                            }

                            if (validMin && validMag && validS && validT) {
                                b.create();
                            }
                        }
                    }
                }
            }
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/renderscript/src/android/renderscript/cts/SamplerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.renderscript.cts.SamplerTest"	"testPrebuiltSamplers"	"CtsRenderscriptTestCases"	"1: ui"	"public void testPrebuiltSamplers() {
        assertTrue(Sampler.CLAMP_LINEAR(mRS) != null);
        assertTrue(Sampler.CLAMP_LINEAR_MIP_LINEAR(mRS) != null);
        assertTrue(Sampler.CLAMP_NEAREST(mRS) != null);
        assertTrue(Sampler.WRAP_LINEAR(mRS) != null);
        assertTrue(Sampler.WRAP_LINEAR_MIP_LINEAR(mRS) != null);
        assertTrue(Sampler.WRAP_NEAREST(mRS) != null);
        assertTrue(Sampler.MIRRORED_REPEAT_NEAREST(mRS) != null);
        assertTrue(Sampler.MIRRORED_REPEAT_LINEAR(mRS) != null);
        assertTrue(Sampler.MIRRORED_REPEAT_LINEAR_MIP_LINEAR(mRS) != null);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/renderscript/src/android/renderscript/cts/SamplerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.rollback.lib.RollbackUtils"	"isStaged"	""	"1: system"	"public void test/*
 *.
 */

package com.android.cts.rollback.lib;

import static com.google.common.truth.Truth.assertThat;

import android.app.ActivityManager;
import android.app.AlarmManager;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.VersionedPackage;
import android.content.rollback.PackageRollbackInfo;
import android.content.rollback.RollbackInfo;
import android.content.rollback.RollbackManager;
import android.util.Log;

import androidx.test.InstrumentationRegistry;

import com.android.cts.install.lib.InstallUtils;
import com.android.cts.install.lib.LocalIntentSender;
import com.android.cts.install.lib.TestApp;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.CountDownLatch;
import java.util.function.Predicate;
import java.util.function.Supplier;

/**
 * Utilities to facilitate testing rollbacks.
 */
public class RollbackUtils {

    private static final String TAG = ""RollbackTest"";

    /**
     * Time between repeated checks in {@link #retry}.
     */
    private static final long RETRY_CHECK_INTERVAL_MILLIS = 500;

    /**
     * Maximum number of checks in {@link #retry} before a timeout occurs.
     */
    private static final long RETRY_MAX_INTERVALS = 20;


    /**
     * Gets the RollbackManager for the instrumentation context.
     */
    public static RollbackManager getRollbackManager() {
        Context context = InstrumentationRegistry.getContext();
        RollbackManager rm = (RollbackManager) context.getSystemService(Context.ROLLBACK_SERVICE);
        if (rm == null) {
            throw new AssertionError(""Failed to get RollbackManager"");
        }
        return rm;
    }

    /**
     * Returns a rollback for the given rollback Id, if found. Otherwise, returns null.
     */
    private static RollbackInfo getRollbackById(List<RollbackInfo> rollbacks, int rollbackId) {
        for (RollbackInfo rollback :rollbacks) {
            if (rollback.getRollbackId() == rollbackId) {
                return rollback;
            }
        }
        return null;
    }

    /**
     * Returns an available rollback for the given package name. Returns null
     * if there are no available rollbacks, and throws an assertion if there
     * is more than one.
     */
    public static RollbackInfo getAvailableRollback(String packageName) {
        RollbackManager rm = getRollbackManager();
        return getUniqueRollbackInfoForPackage(rm.getAvailableRollbacks(), packageName);
    }

    /**
     * Returns a recently committed rollback for the given package name. Returns null
     * if there are no available rollbacks, and throws an assertion if there
     * is more than one.
     */
    public static RollbackInfo getCommittedRollback(String packageName) {
        RollbackManager rm = getRollbackManager();
        return getUniqueRollbackInfoForPackage(rm.getRecentlyCommittedRollbacks(), packageName);
    }

    /**
     * Returns a recently committed rollback for the given rollback Id.
     * Returns null if no committed rollback with a matching Id was found.
     */
    public static RollbackInfo getCommittedRollbackById(int rollbackId) {
        RollbackManager rm = getRollbackManager();
        return getRollbackById(rm.getRecentlyCommittedRollbacks(), rollbackId);
    }

    /**
     * Commit the given rollback. This method won't return until the committed session is made
     * ready or failed. The caller is safe to immediately reboot the device right after the call.
     * @throws AssertionError if the rollback fails.
     */
    public static void rollback(int rollbackId, TestApp... causePackages)
            throws InterruptedException {
        List<VersionedPackage> causes = new ArrayList<>();
        for (TestApp cause : causePackages) {
            causes.add(cause.getVersionedPackage());
        }

        RollbackManager rm = getRollbackManager();
        LocalIntentSender sender = new LocalIntentSender();
        rm.commitRollback(rollbackId, causes, sender.getIntentSender());
        Intent result = sender.getResult();
        int status = result.getIntExtra(RollbackManager.EXTRA_STATUS,
                RollbackManager.STATUS_FAILURE);
        if (status != RollbackManager.STATUS_SUCCESS) {
            String message = result.getStringExtra(RollbackManager.EXTRA_STATUS_MESSAGE);
            throw new AssertionError(message);
        }

        RollbackInfo committed = getCommittedRollbackById(rollbackId);
        if (committed.isStaged()) {
            InstallUtils.waitForSessionReady(committed.getCommittedSessionId());
        }
    }

    /**
     * Forwards the device clock time by {@code offsetMillis}.
     */
    public static void forwardTimeBy(long offsetMillis) {
        setTime(System.currentTimeMillis() + offsetMillis);
        Log.i(TAG, ""Forwarded time on device by "" + offsetMillis + "" millis"");
    }

    /**
     * Returns the RollbackInfo with a given package in the list of rollbacks.
     * Throws an assertion failure if there is more than one such rollback
     * info. Returns null if there are no such rollback infos.
     */
    public static RollbackInfo getUniqueRollbackInfoForPackage(List<RollbackInfo> rollbacks,
            String packageName) {
        RollbackInfo found = null;
        for (RollbackInfo rollback : rollbacks) {
            for (PackageRollbackInfo info : rollback.getPackages()) {
                if (packageName.equals(info.getPackageName())) {
                    assertThat(found).isNull();
                    found = rollback;
                    break;
                }
            }
        }
        return found;
    }

    /**
     * Returns an available rollback matching the specified package name. If no such rollback is
     * available, getAvailableRollbacks is called repeatedly until one becomes available. An
     * assertion is raised if this does not occur after a certain number of checks.
     */
    public static RollbackInfo waitForAvailableRollback(String packageName)
            throws InterruptedException {
        return retry(() -> getAvailableRollback(packageName),
                Objects::nonNull, ""Rollback did not become available."");
    }

    /**
     * If there is no available rollback matching the specified package name, this returns
     * immediately. If such a rollback is available, getAvailableRollbacks is called repeatedly
     * until it is no longer available. An assertion is raised if this does not occur after a
     * certain number of checks.
     */
    public static void waitForUnavailableRollback(String packageName) throws InterruptedException {
        retry(() -> getAvailableRollback(packageName), Objects::isNull,
                ""Rollback did not become unavailable"");
    }

    private static boolean hasRollbackInclude(List<RollbackInfo> rollbacks, String packageName) {
        return rollbacks.stream().anyMatch(
                ri -> ri.getPackages().stream().anyMatch(
                        pri -> packageName.equals(pri.getPackageName())));
    }

    /**
     * Retries until all rollbacks including {@code packageName} are gone. An assertion is raised if
     * this does not occur after a certain number of checks.
     */
    public static void waitForRollbackGone(
            Supplier<List<RollbackInfo>> supplier, String packageName) throws InterruptedException {
        retry(supplier, rollbacks -> !hasRollbackInclude(rollbacks, packageName),
                ""Rollback containing "" + packageName + "" did not go away"");
    }

    private static <T> T retry(Supplier<T> supplier, Predicate<T> predicate, String message)
            throws InterruptedException {
        for (int i = 0; i < RETRY_MAX_INTERVALS; i++) {
            T result = supplier.get();
            if (predicate.test(result)) {
                return result;
            }
            Thread.sleep(RETRY_CHECK_INTERVAL_MILLIS);
        }
        throw new AssertionError(message);
    }

    /**
     * Send broadcast to crash {@code packageName} {@code count} times. If {@code count} is at least
     * {@link PackageWatchdog#TRIGGER_FAILURE_COUNT}, watchdog crash detection will be triggered.
     */
    public static void sendCrashBroadcast(String packageName,
            int count) throws InterruptedException, IOException {
        for (int i = 0; i < count; ++i) {
            launchPackageForCrash(packageName);
        }
    }

    private static void setTime(long millis) {
        Context context = InstrumentationRegistry.getContext();
        AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
        am.setTime(millis);
    }

    /**
     * Launches {@code packageName} with {@link Intent#ACTION_MAIN} and
     * waits for a CRASH broadcast from the launched app.
     */
    private static void launchPackageForCrash(String packageName)
            throws InterruptedException, IOException {
        // Force stop the package before launching it to make sure it isn't
        // stuck in a non-launchable state. And wait a second afterwards to
        // avoid interfering with when we launch the app.
        Log.i(TAG, ""Force stopping "" + packageName);
        Context context = InstrumentationRegistry.getContext();
        ActivityManager am = context.getSystemService(ActivityManager.class);
        am.forceStopPackage(packageName);
        Thread.sleep(1000);

        // Register a receiver to listen for the CRASH broadcast.
        CountDownLatch latch = new CountDownLatch(1);
        IntentFilter crashFilter = new IntentFilter();
        crashFilter.addAction(""com.android.tests.rollback.CRASH"");
        crashFilter.addCategory(Intent.CATEGORY_DEFAULT);
        BroadcastReceiver crashReceiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                Log.i(TAG, ""Received CRASH broadcast from "" + packageName);
                latch.countDown();
            }
        };
        context.registerReceiver(crashReceiver, crashFilter);

        // Launch the app.
        Intent intent = new Intent(Intent.ACTION_MAIN);
        intent.setPackage(packageName);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        intent.addCategory(Intent.CATEGORY_LAUNCHER);
        Log.i(TAG, ""Launching "" + packageName + "" with "" + intent);
        context.startActivity(intent);

        Log.i(TAG, ""Waiting for CRASH broadcast from "" + packageName);
        latch.await();

        context.unregisterReceiver(crashReceiver);

        // Sleep long enough for packagewatchdog to be notified of crash
        Thread.sleep(1000);
    }
}"	"/home/gpoor/cts-12-source/cts/libs/rollback/src/com/android/cts/rollback/lib/RollbackUtils.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.normalapp.ClientTest"	"testQuery"	""	"2: direct apps"	"public void testQuery() throws Exception {
        // query activities without flags
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            final List<ResolveInfo> resolveInfo = InstrumentationRegistry.getContext()
                    .getPackageManager().queryIntentActivities(queryIntent, 0 /*flags*/);
            if (resolveInfo == null || resolveInfo.size() == 0) {
                fail(""didn't resolve any intents"");
            }
            assertThat(resolveInfo.size(), is(2));
            assertThat(resolveInfo.get(0).activityInfo.packageName,
                    is(""com.android.cts.normalapp""));
            assertThat(resolveInfo.get(0).activityInfo.name,
                    is(""com.android.cts.normalapp.ExposedActivity""));
            assertThat(resolveInfo.get(0).isInstantAppAvailable,
                    is(false));
            assertThat(resolveInfo.get(1).activityInfo.packageName,
                    is(""com.android.cts.normalapp""));
            assertThat(resolveInfo.get(1).activityInfo.name,
                    is(""com.android.cts.normalapp.NormalActivity""));
            assertThat(resolveInfo.get(1).isInstantAppAvailable,
                    is(false));
        }

        // query activities asking for ephemeral apps [we should only get normal apps]
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            final int MATCH_EPHEMERAL = 0x00800000;

            final List<ResolveInfo> resolveInfo = InstrumentationRegistry.getContext()
                    .getPackageManager().queryIntentActivities(queryIntent, MATCH_EPHEMERAL);
            if (resolveInfo == null || resolveInfo.size() == 0) {
                fail(""didn't resolve any intents"");
            }
            assertThat(resolveInfo.size(), is(2));
            assertThat(resolveInfo.get(0).activityInfo.packageName,
                    is(""com.android.cts.normalapp""));
            assertThat(resolveInfo.get(0).activityInfo.name,
                    is(""com.android.cts.normalapp.ExposedActivity""));
            assertThat(resolveInfo.get(0).isInstantAppAvailable,
                    is(false));
            assertThat(resolveInfo.get(1).activityInfo.packageName,
                    is(""com.android.cts.normalapp""));
            assertThat(resolveInfo.get(1).activityInfo.name,
                    is(""com.android.cts.normalapp.NormalActivity""));
            assertThat(resolveInfo.get(1).isInstantAppAvailable,
                    is(false));
        }

        // query activities; directed package
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            queryIntent.setPackage(EPHEMERAL_1_PKG);
            final List<ResolveInfo> resolveInfo = InstrumentationRegistry.getContext()
                    .getPackageManager().queryIntentActivities(queryIntent, 0 /*flags*/);
            assertThat(resolveInfo.size(), is(0));
        }

        // query activities; directed component
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            queryIntent.setComponent(
                    new ComponentName(EPHEMERAL_1_PKG,
                            ""com.android.cts.ephemeralapp1.EphemeralActivity""));
            final List<ResolveInfo> resolveInfo = InstrumentationRegistry.getContext()
                    .getPackageManager().queryIntentActivities(queryIntent, 0 /*flags*/);
            assertThat(resolveInfo.size(), is(0));
        }

        // query services without flags
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            final List<ResolveInfo> resolveInfo = InstrumentationRegistry.getContext()
                    .getPackageManager().queryIntentServices(queryIntent, 0 /*flags*/);
            if (resolveInfo == null || resolveInfo.size() == 0) {
                fail(""didn't resolve any intents"");
            }
            assertThat(resolveInfo.size(), is(2));
            assertThat(resolveInfo.get(0).serviceInfo.packageName,
                    is(""com.android.cts.normalapp""));
            assertThat(resolveInfo.get(0).serviceInfo.name,
                    is(""com.android.cts.normalapp.ExposedService""));
            assertThat(resolveInfo.get(0).isInstantAppAvailable,
                    is(false));
            assertThat(resolveInfo.get(1).serviceInfo.packageName,
                    is(""com.android.cts.normalapp""));
            assertThat(resolveInfo.get(1).serviceInfo.name,
                    is(""com.android.cts.normalapp.NormalService""));
            assertThat(resolveInfo.get(1).isInstantAppAvailable,
                    is(false));
        }

        // query services asking for ephemeral apps [we should only get normal apps]
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            final int MATCH_EPHEMERAL = 0x00800000;

            final List<ResolveInfo> resolveInfo = InstrumentationRegistry.getContext()
                    .getPackageManager().queryIntentServices(queryIntent, MATCH_EPHEMERAL);
            if (resolveInfo == null || resolveInfo.size() == 0) {
                fail(""didn't resolve any intents"");
            }
            assertThat(resolveInfo.size(), is(2));
            assertThat(resolveInfo.get(0).serviceInfo.packageName,
                    is(""com.android.cts.normalapp""));
            assertThat(resolveInfo.get(0).serviceInfo.name,
                    is(""com.android.cts.normalapp.ExposedService""));
            assertThat(resolveInfo.get(0).isInstantAppAvailable,
                    is(false));
            assertThat(resolveInfo.get(1).serviceInfo.packageName,
                    is(""com.android.cts.normalapp""));
            assertThat(resolveInfo.get(1).serviceInfo.name,
                    is(""com.android.cts.normalapp.NormalService""));
            assertThat(resolveInfo.get(1).isInstantAppAvailable,
                    is(false));
        }

        // query services; directed package
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            queryIntent.setPackage(EPHEMERAL_1_PKG);
            final List<ResolveInfo> resolveInfo = InstrumentationRegistry.getContext()
                    .getPackageManager().queryIntentServices(queryIntent, 0 /*flags*/);
            assertThat(resolveInfo.size(), is(0));
        }

        // query services; directed component
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            queryIntent.setComponent(
                    new ComponentName(EPHEMERAL_1_PKG,
                            ""com.android.cts.ephemeralapp1.EphemeralService""));
            final List<ResolveInfo> resolveInfo = InstrumentationRegistry.getContext()
                    .getPackageManager().queryIntentServices(queryIntent, 0 /*flags*/);
            assertThat(resolveInfo.size(), is(0));
        }

        // query content providers without flags
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            final List<ResolveInfo> resolveInfo = InstrumentationRegistry
                    .getContext().getPackageManager().queryIntentContentProviders(
                            queryIntent, 0 /*flags*/);
            if (resolveInfo == null || resolveInfo.size() == 0) {
                fail(""didn't resolve any intents"");
            }
            assertThat(resolveInfo.size(), is(2));
            assertThat(resolveInfo.get(0).providerInfo.packageName,
                    is(""com.android.cts.normalapp""));
            assertThat(resolveInfo.get(0).providerInfo.name,
                    is(""com.android.cts.normalapp.ExposedProvider""));
            assertThat(resolveInfo.get(1).providerInfo.packageName,
                    is(""com.android.cts.normalapp""));
            assertThat(resolveInfo.get(1).providerInfo.name,
                    is(""com.android.cts.normalapp.NormalProvider""));
            assertThat(resolveInfo.get(1).isInstantAppAvailable,
                    is(false));
        }

        // query content providers asking for ephemeral apps [we should only get normal apps]
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            final int MATCH_EPHEMERAL = 0x00800000;

            final List<ResolveInfo> resolveInfo = InstrumentationRegistry.getContext()
                    .getPackageManager().queryIntentContentProviders(
                            queryIntent, MATCH_EPHEMERAL);
            if (resolveInfo == null || resolveInfo.size() == 0) {
                fail(""didn't resolve any intents"");
            }
            assertThat(resolveInfo.size(), is(2));
            assertThat(resolveInfo.get(0).providerInfo.packageName,
                    is(""com.android.cts.normalapp""));
            assertThat(resolveInfo.get(0).providerInfo.name,
                    is(""com.android.cts.normalapp.ExposedProvider""));
            assertThat(resolveInfo.get(1).providerInfo.packageName,
                    is(""com.android.cts.normalapp""));
            assertThat(resolveInfo.get(1).providerInfo.name,
                    is(""com.android.cts.normalapp.NormalProvider""));
            assertThat(resolveInfo.get(1).isInstantAppAvailable,
                    is(false));
        }

        // query content providers; directed package
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            queryIntent.setPackage(EPHEMERAL_1_PKG);
            final List<ResolveInfo> resolveInfo = InstrumentationRegistry.getContext()
                    .getPackageManager().queryIntentContentProviders(queryIntent, 0 /*flags*/);
            assertThat(resolveInfo.size(), is(0));
        }

        // query content providers; directed component
        {
            final Intent queryIntent = new Intent(ACTION_QUERY);
            queryIntent.setComponent(
                    new ComponentName(EPHEMERAL_1_PKG,
                            ""com.android.cts.ephemeralapp1.EphemeralProvider""));
            final List<ResolveInfo> resolveInfo = InstrumentationRegistry.getContext()
                    .getPackageManager().queryIntentContentProviders(queryIntent, 0 /*flags*/);
            assertThat(resolveInfo.size(), is(0));
        }
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/NormalApp/src/com/android/cts/normalapp/ClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.normalapp.ClientTest"	"testStartNormal"	""	"1: direct"	"public void testStartNormal() throws Exception {
        // start the normal activity
        {
            final Intent startNormalIntent = new Intent(ACTION_START_NORMAL_ACTIVITY)
                    .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            InstrumentationRegistry.getContext().startActivity(startNormalIntent, null /*options*/);
            final TestResult testResult = getResult();
            assertThat(testResult.getPackageName(),
                    is(""com.android.cts.normalapp""));
            assertThat(testResult.getComponentName(),
                    is(""NormalActivity""));
            assertThat(testResult.getException(),
                    is(""android.content.pm.PackageManager$NameNotFoundException""));
        }

        // start the normal activity; directed package
        {
            final Intent startNormalIntent = new Intent(ACTION_START_NORMAL_ACTIVITY)
                    .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            startNormalIntent.setPackage(""com.android.cts.normalapp"");
            InstrumentationRegistry.getContext().startActivity(startNormalIntent, null /*options*/);
            final TestResult testResult = getResult();
            assertThat(testResult.getPackageName(),
                    is(""com.android.cts.normalapp""));
            assertThat(testResult.getComponentName(),
                    is(""NormalActivity""));
            assertThat(testResult.getException(),
                    is(""android.content.pm.PackageManager$NameNotFoundException""));
        }

        // start the normal activity; directed component
        {
            final Intent startNormalIntent = new Intent(ACTION_START_NORMAL_ACTIVITY)
                    .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            startNormalIntent.setComponent(new ComponentName(
                    ""com.android.cts.normalapp"", ""com.android.cts.normalapp.NormalActivity""));
            InstrumentationRegistry.getContext().startActivity(startNormalIntent, null /*options*/);
            final TestResult testResult = getResult();
            assertThat(testResult.getPackageName(),
                    is(""com.android.cts.normalapp""));
            assertThat(testResult.getComponentName(),
                    is(""NormalActivity""));
            assertThat(testResult.getException(),
                    is(""android.content.pm.PackageManager$NameNotFoundException""));
        }

        // connect to the normal provider
        {
            final String provider = ""content://com.android.cts.normalapp.provider/table"";
            final Cursor testCursor = InstrumentationRegistry
                    .getContext().getContentResolver().query(
                            Uri.parse(provider),
                            null /*projection*/,
                            null /*selection*/,
                            null /*selectionArgs*/,
                            null /*sortOrder*/);
            assertThat(testCursor, is(notNullValue()));
            assertThat(testCursor.getCount(), is(1));
            assertThat(testCursor.getColumnCount(), is(2));
            assertThat(testCursor.moveToFirst(), is(true));
            assertThat(testCursor.getInt(0), is(1));
            assertThat(testCursor.getString(1), is(""NormalProvider""));
        }
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/NormalApp/src/com/android/cts/normalapp/ClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.normalapp.ClientTest"	"testStartEphemeral"	""	"2: direct apps"	"public void testStartEphemeral() throws Exception {
        // start the ephemeral activity; no EXTERNAL flag
        try {
            final Intent startEphemeralIntent = new Intent(ACTION_START_OTHER_EPHEMERAL_ACTIVITY)
                    .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            InstrumentationRegistry.getContext().startActivity(
                    startEphemeralIntent, null /*options*/);
            final TestResult testResult = getResult();
            fail();
        } catch (ActivityNotFoundException expected) {
        }

        // start the ephemeral activity; EXTERNAL flag
        {
            final Intent startEphemeralIntent = new Intent(ACTION_START_OTHER_EPHEMERAL_ACTIVITY)
                    .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_MATCH_EXTERNAL);
            InstrumentationRegistry.getContext().startActivity(
                    startEphemeralIntent, null /*options*/);
            final TestResult testResult = getResult();
            assertThat(EPHEMERAL_2_PKG, is(testResult.getPackageName()));
            assertThat(ACTION_START_OTHER_EPHEMERAL_ACTIVITY, is(testResult.getIntent().getAction()));
        }


        // start the ephemeral activity; directed package, no EXTERNAL flag
        try {
            final Intent startEphemeralIntent = new Intent(ACTION_START_EPHEMERAL_ACTIVITY)
                    .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            startEphemeralIntent.setPackage(EPHEMERAL_1_PKG);
            InstrumentationRegistry.getContext().startActivity(
                    startEphemeralIntent, null /*options*/);
            final TestResult testResult = getResult();
            fail();
        } catch (ActivityNotFoundException expected) {
        }

        // start the ephemeral activity; directed package, includes EXTERNAL flag
        {
            final Intent startEphemeralIntent = new Intent(ACTION_START_EPHEMERAL_ACTIVITY)
                    .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_MATCH_EXTERNAL);
            startEphemeralIntent.setPackage(EPHEMERAL_1_PKG);
            InstrumentationRegistry.getContext().startActivity(
                    startEphemeralIntent, null /*options*/);
            final TestResult testResult = getResult();
            assertThat(EPHEMERAL_1_PKG, is(testResult.getPackageName()));
            assertThat(ACTION_START_EPHEMERAL_ACTIVITY, is(testResult.getIntent().getAction()));
        }

        // start the ephemeral activity; directed component
        try {
            final Intent startEphemeralIntent = new Intent(ACTION_START_EPHEMERAL_ACTIVITY)
                    .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            startEphemeralIntent.setComponent(
                    new ComponentName(EPHEMERAL_1_PKG,
                            ""com.android.cts.ephemeralapp1.EphemeralActivity""));
            InstrumentationRegistry.getContext().startActivity(
                    startEphemeralIntent, null /*options*/);
            final TestResult testResult = getResult();
            fail();
        } catch (ActivityNotFoundException expected) {
        }

        // start the ephemeral activity; using VIEW/BROWSABLE
        {
            final Intent startViewIntent = new Intent(Intent.ACTION_VIEW)
                    .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            startViewIntent.addCategory(Intent.CATEGORY_BROWSABLE);
            startViewIntent.setData(Uri.parse(""https://cts.google.com/ephemeral""));
            InstrumentationRegistry.getContext().startActivity(
                    startViewIntent, null /*options*/);
            final TestResult testResult = getResult();
            assertThat(EPHEMERAL_1_PKG, is(testResult.getPackageName()));
            assertThat(""EphemeralActivity"", is(testResult.getComponentName()));
            assertThat(Intent.ACTION_VIEW, is(testResult.getIntent().getAction()));
            assertThat(testResult.getIntent().getCategories(), hasItems(Intent.CATEGORY_BROWSABLE));
            assertThat(""https://cts.google.com/ephemeral"",
                    is(testResult.getIntent().getData().toString()));
        }

        final ContentResolver contentResolver =
                InstrumentationRegistry.getContext().getContentResolver();
 // TODO(b/120026065): Re-enable this when we fine a more reliable way to toggle the setting
 /*
        final int originalSetting = Secure.getInt(contentResolver, Secure.INSTANT_APPS_ENABLED, 1);
        Secure.putInt(contentResolver, Secure.INSTANT_APPS_ENABLED, 0);
        try {
            // start the ephemeral activity; using VIEW/BROWSABLE with setting disabled
            try {
                final Intent startViewIntent = new Intent(Intent.ACTION_VIEW)
                        .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                startViewIntent.addCategory(Intent.CATEGORY_BROWSABLE);
                startViewIntent.setData(Uri.parse(""https://cts.google.com/ephemeral""));
                InstrumentationRegistry.getContext().startActivity(
                        startViewIntent, null);
                final TestResult testResult = getResult();
                fail();
            } catch (TestResultNotFoundException expected) {
                // we shouldn't resolve to our instant app
            }

            // start the ephemeral activity; EXTERNAL flag with setting disabled
            {
                final Intent startEphemeralIntent = new Intent(ACTION_START_EPHEMERAL_ACTIVITY)
                        .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
                                | Intent.FLAG_ACTIVITY_MATCH_EXTERNAL);
                InstrumentationRegistry.getContext().startActivity(
                        startEphemeralIntent, null);
                final TestResult testResult = getResult();
                assertThat(""com.android.cts.ephemeralapp1"", is(testResult.getPackageName()));
                assertThat(ACTION_START_EPHEMERAL_ACTIVITY, is(testResult.getIntent().getAction()));
            }

        } finally {
            Secure.putInt(contentResolver, Secure.INSTANT_APPS_ENABLED, originalSetting);
        }
 */

        // connect to the instant app provider
        {
            final String provider = ""content://com.android.cts.ephemeralapp1.provider/table"";
            final Cursor testCursor = contentResolver.query(
                            Uri.parse(provider),
                            null /*projection*/,
                            null /*selection*/,
                            null /*selectionArgs*/,
                            null /*sortOrder*/);
            assertThat(testCursor, is(nullValue()));
        }
    }

    /** Tests getting changed packages for instant app. */"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/NormalApp/src/com/android/cts/normalapp/ClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.normalapp.ClientTest"	"testGetChangedPackages"	""	"1: apps"	"public void testGetChangedPackages() {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();

        // Query changed packages without permission, and we should only get normal apps.
        final ChangedPackages changedPackages = pm.getChangedPackages(0);
        assertThat(changedPackages.getPackageNames()).doesNotContain(EPHEMERAL_1_PKG);

        // Query changed packages with permission, and we should be able to get ephemeral apps.
        runWithShellPermissionIdentity(() -> {
            final ChangedPackages changesInstantApp = pm.getChangedPackages(0);
            assertThat(changesInstantApp.getPackageNames()).contains(EPHEMERAL_1_PKG);
        }, Manifest.permission.ACCESS_INSTANT_APPS);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/NormalApp/src/com/android/cts/normalapp/ClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.normalapp.ClientTest"	"isTrue"	""	"2: apps user"	"public void uninstall_userInstalledApp_shouldBeUserInitiated() {
        runWithShellPermissionIdentity(() -> {
            final boolean userInitiated = uninstallAndWaitForExtraUserInitiated(
                    InstrumentationRegistry.getContext(), EPHEMERAL_1_PKG);

            assertThat(userInitiated).isTrue();
        }, Manifest.permission.DELETE_PACKAGES, Manifest.permission.ACCESS_INSTANT_APPS);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/NormalApp/src/com/android/cts/normalapp/ClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.normalapp.ClientTest"	"isFalse"	""	"3: apps system user"	"public void uninstall_pruneInstantApp_shouldNotBeUserInitiated() {
        runWithShellPermissionIdentity(() -> {
            final boolean userInitiated = pruneInstantAppAndWaitForExtraUserInitiated(
                    InstrumentationRegistry.getContext(), EPHEMERAL_1_PKG);

            assertThat(userInitiated).isFalse();
        }, Manifest.permission.WRITE_SECURE_SETTINGS, Manifest.permission.ACCESS_INSTANT_APPS);
    }

    /**
     * Uninstall the package and wait for the package removed intent.
     *
     * @return The value of {@link Intent#EXTRA_USER_INITIATED} associated with the intent.
     */
    private boolean uninstallAndWaitForExtraUserInitiated(Context context, String packageName) {
        final Runnable uninstall = () -> {
            final PackageInstaller packageInstaller = context.getPackageManager()
                    .getPackageInstaller();
            packageInstaller.uninstall(packageName, null);
        };

        final Intent packageRemoved = executeAndWaitForPackageRemoved(
                context, packageName, uninstall);
        return packageRemoved.getBooleanExtra(Intent.EXTRA_USER_INITIATED, false);
    }

    /**
     * Runs the shell command {@code pm trim-caches} to invoke system to prune instant applications.
     * Waits for the package removed intent and returns the extra filed.
     *
     * @return The value of {@link Intent#EXTRA_USER_INITIATED} associated with the intent.
     */
    private boolean pruneInstantAppAndWaitForExtraUserInitiated(Context context,
            String packageName) {
        final String defaultPeriod = Settings.Global.getString(context.getContentResolver(),
                INSTALLED_INSTANT_APP_MIN_CACHE_PERIOD);
        final Runnable trimCaches = () -> {
            // Updates installed instant app minimum cache period to zero to ensure that system
            // could uninstall instant apps when trim-caches is invoked.
            Settings.Global.putInt(context.getContentResolver(),
                    INSTALLED_INSTANT_APP_MIN_CACHE_PERIOD, 0);
            SystemUtil.runShellCommand(""pm trim-caches "" + Long.MAX_VALUE + "" internal"");
        };

        try {
            final Intent packageRemoved = executeAndWaitForPackageRemoved(
                    context, packageName, trimCaches);
            return packageRemoved.getBooleanExtra(Intent.EXTRA_USER_INITIATED, false);
        } finally {
            Settings.Global.putString(context.getContentResolver(),
                    INSTALLED_INSTANT_APP_MIN_CACHE_PERIOD, defaultPeriod);
        }
    }

    /**
     * Executes a command and waits for the package removed intent.
     *
     * @return The {@link Intent#ACTION_PACKAGE_REMOVED} associated with the given package name.
     */
    private Intent executeAndWaitForPackageRemoved(Context context, String packageName,
            Runnable command) {
        final IntentFilter filter = new IntentFilter(Intent.ACTION_PACKAGE_REMOVED);
        filter.addDataScheme(""package"");
        filter.addDataSchemeSpecificPart(packageName, PatternMatcher.PATTERN_LITERAL);
        final BlockingQueue<Intent> intentQueue = new LinkedBlockingQueue<>();
        final BroadcastReceiver removedReceiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                try {
                    intentQueue.put(intent);
                } catch (InterruptedException e) {
                    fail(""Cannot add intent to intent blocking queue!"");
                }
            }
        };
        context.registerReceiver(removedReceiver, filter);
        try {
            command.run();
            final Intent intent = intentQueue.poll(60 /* timeout */, TimeUnit.SECONDS);
            assertNotNull(""Timed out to wait for package removed intent"", intent);
            return intent;
        } catch (InterruptedException e) {
            fail(""Failed to get package removed intent: "" + e.getMessage());
        } finally {
            context.unregisterReceiver(removedReceiver);
        }
        return null;
    }

    private TestResult getResult() {
        final TestResult result;
        try {
            result = mResultQueue.poll(5, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        if (result == null) {
            throw new TestResultNotFoundException(
                    ""Activity didn't receive a Result in 5 seconds"");
        }
        return result;
    }

    private static class TestResultNotFoundException extends IllegalStateException {
        public TestResultNotFoundException(String description) {
            super(description);
        }
    }

    private static class ActivityBroadcastReceiver extends BroadcastReceiver {
        private final SynchronousQueue<TestResult> mQueue;
        public ActivityBroadcastReceiver(SynchronousQueue<TestResult> queue) {
            mQueue = queue;
        }

        @Override
        public void onReceive(Context context, Intent intent) {
            try {
                mQueue.offer(intent.getParcelableExtra(TestResult.EXTRA_TEST_RESULT),
                        5, TimeUnit.SECONDS);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/EphemeralTestApp/NormalApp/src/com/android/cts/normalapp/ClientTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.server.wm.AmProfileTests"	"testAmStartStartProfilerSamplingStreaming"	"CtsWindowManagerDeviceTestCases"	"1: ui"	"public void testAmStartStartProfilerSamplingStreaming() throws Exception {
        testProfile(false, true, true);
    }

    private void testProfile(final boolean startActivityFirst, final boolean sampling,
            final boolean streaming) throws Exception {
        final ActivitySession activitySession;
        if (startActivityFirst) {
            activitySession = createManagedActivityClientSession().startActivity(
                    new Intent().setComponent(PROFILEABLE_APP_ACTIVITY));
            startProfiling(PROFILEABLE_APP_ACTIVITY.getPackageName(), sampling, streaming);
        } else {
            activitySession = startActivityProfiling(PROFILEABLE_APP_ACTIVITY, sampling, streaming);
        }

        // Go to home screen and then warm start the activity to generate some interesting trace.
        launchHomeActivity();
        launchActivity(PROFILEABLE_APP_ACTIVITY);

        executeShellCommand(getStopProfileCmd(PROFILEABLE_APP_ACTIVITY));

        activitySession.sendCommandAndWaitReply(COMMAND_WAIT_FOR_PROFILE_OUTPUT);
        verifyOutputFileFormat(streaming);
    }

    /** Starts profiler on a started process. */
    private static void startProfiling(String processName, boolean sampling, boolean streaming) {
        final StringBuilder builder = new StringBuilder(""am profile start"");
        appendProfileParameters(builder, sampling, streaming);
        builder.append(String.format("" %s %s"", processName, OUTPUT_FILE_PATH));
        executeShellCommand(builder.toString());
    }

    /** Starts the activity with profiler. */
    private ActivitySession startActivityProfiling(ComponentName activityName, boolean sampling,
            boolean streaming) {
        return createManagedActivityClientSession().startActivity(new DefaultLaunchProxy() {

            @Override
            public boolean shouldWaitForLaunched() {
                // The shell command included ""-W"".
                return false;
            }

            @Override
            public void execute() {
                final StringBuilder builder = new StringBuilder();
                builder.append(String.format(""am start -n %s -W -S --start-profiler %s"",
                        getActivityName(activityName), OUTPUT_FILE_PATH));
                appendProfileParameters(builder, sampling, streaming);
                mLaunchInjector.setupShellCommand(builder);
                executeShellCommand(builder.toString());
            }
        });
    }

    private static void appendProfileParameters(StringBuilder builder, boolean sampling,
            boolean streaming) {
        if (sampling) {
            builder.append("" --sampling 1000"");
        }
        if (streaming) {
            builder.append("" --streaming"");
        }
    }

    private static String getStopProfileCmd(final ComponentName activityName) {
        return ""am profile stop "" + activityName.getPackageName();
    }

    private void verifyOutputFileFormat(final boolean streaming) throws Exception {
        // This is a hack. The am service has to write to /data/local/tmp because it doesn't have
        // access to the sdcard. The test cannot read from /data/local/tmp. This allows us to
        // scan the content to validate what is needed for this test.
        final String firstLine = executeShellCommand(""head -1 "" + OUTPUT_FILE_PATH);

        final String expectedFirstWord = streaming ? FIRST_WORD_STREAMING : FIRST_WORD_NO_STREAMING;
        assertThat(
                ""data size"", firstLine.length(), greaterThanOrEqualTo(expectedFirstWord.length()));
        final String actualFirstWord = firstLine.substring(0, expectedFirstWord.length());
        assertEquals(""Unexpected first word"", expectedFirstWord, actualFirstWord);

        // Clean up.
        executeShellCommand(""rm -f "" + OUTPUT_FILE_PATH);
    }
}"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/AmProfileTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.quickaccesswallet.cts.GetWalletCardsResponseTest"	"testParcel_toParcel"	"CtsQuickAccessWalletTestCases"	"1: ui"	"public void testParcel_toParcel() {
        Intent intent = new Intent(mContext, QuickAccessWalletActivity.class);
        WalletCard card1 = new WalletCard.Builder(
                ""card1"",
                Icon.createWithBitmap(createBitmap(""1"")),
                ""content description"",
                PendingIntent.getActivity(mContext, 0, intent, PendingIntent.FLAG_IMMUTABLE))
                .build();

        WalletCard card2 = new WalletCard.Builder(
                ""card2"",
                Icon.createWithBitmap(createBitmap(""2"")),
                ""content description"",
                PendingIntent.getActivity(mContext, 0, intent, PendingIntent.FLAG_IMMUTABLE))
                .build();

        GetWalletCardsResponse response =
                new GetWalletCardsResponse(Arrays.asList(card1, card2), 1);
        Parcel p = Parcel.obtain();
        response.writeToParcel(p, 0);
        p.setDataPosition(0);
        GetWalletCardsResponse newResponse = GetWalletCardsResponse.CREATOR.createFromParcel(p);
        assertThat(newResponse.getWalletCards()).hasSize(2);
        assertThat(newResponse.getWalletCards().get(0).getCardId()).isEqualTo(""card1"");
        TestUtils.compareIcons(mContext,
                response.getWalletCards().get(0).getCardImage(),
                newResponse.getWalletCards().get(0).getCardImage());
        TestUtils.compareIcons(mContext,
                response.getWalletCards().get(1).getCardImage(),
                newResponse.getWalletCards().get(1).getCardImage());
        assertThat(newResponse.getWalletCards().get(1).getCardId()).isEqualTo(""card2"");
        assertThat(newResponse.getSelectedIndex()).isEqualTo(1);
    }

    private Bitmap createBitmap(String cardNumber) {
        Bitmap bitmap = Bitmap.createBitmap(CARD_WIDTH, CARD_HEIGHT, Bitmap.Config.ARGB_8888);
        Canvas canvas = new Canvas(bitmap);
        canvas.drawColor(Color.WHITE);
        Paint paint = new Paint();
        paint.setColor(Color.BLACK);
        canvas.drawText(cardNumber, 0, 0, paint);
        return bitmap;
    }
}"	"/home/gpoor/cts-12-source/cts/tests/quickaccesswallet/src/android/quickaccesswallet/cts/GetWalletCardsResponseTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.os.cts.PowerManager_WakeLockTest"	"testPowerManagerWakeLock"	""	"2: ui system"	"public void testPowerManagerWakeLock() throws InterruptedException {
        PowerManager pm = (PowerManager)  getContext().getSystemService(Context.POWER_SERVICE);
        WakeLock wl = pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK, TAG);
        assertNotNull(wl.toString());

        wl.acquire();
        assertTrue(wl.isHeld());
        wl.release();
        assertFalse(wl.isHeld());

        // Try ref-counted acquire/release
        wl.setReferenceCounted(true);
        wl.acquire();
        assertTrue(wl.isHeld());
        wl.acquire();
        assertTrue(wl.isHeld());
        wl.release();
        assertTrue(wl.isHeld());
        wl.release();
        assertFalse(wl.isHeld());

        // Try non-ref-counted
        wl.setReferenceCounted(false);
        wl.acquire();
        assertTrue(wl.isHeld());
        wl.acquire();
        assertTrue(wl.isHeld());
        wl.release();
        assertFalse(wl.isHeld());

        // test acquire(long)
        wl.acquire(PowerManagerTest.TIME);
        assertTrue(wl.isHeld());
        Thread.sleep(PowerManagerTest.TIME + PowerManagerTest.MORE_TIME);
        assertFalse(wl.isHeld());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/PowerManager_WakeLockTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.os.cts.PowerManager_WakeLockTest"	"testWakeLockTimeout"	""	"2: ui system"	"public void testWakeLockTimeout() throws Exception {
        final PowerManager pm = getContext().getSystemService(PowerManager.class);

        final WakeLock lock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG);
        lock.acquire(2000);
        SystemClock.sleep(4000);

        lock.release();
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/PowerManager_WakeLockTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.content.cts.IntentTest"	"testUris"	"CtsContentTestCases"	"1: apps"	"public void testUris() {
        checkIntentUri(
                ""intent:#Intent;action=android.test.FOO;end"",
                null,
                new Intent().setAction(""android.test.FOO""));
        checkIntentUri(
                ""intent:#Intent;category=android.test.FOO;end"",
                null,
                new Intent().setAction(Intent.ACTION_VIEW).addCategory(""android.test.FOO""));
        checkIntentUri(
                ""intent:#Intent;action=android.test.FOO;launchFlags=0x20;end"",
                null,
                new Intent().setAction(""android.test.FOO"").setFlags(0x20));
        checkIntentUri(
                ""intent://www.example.com/blah#Intent;scheme=http;end"",
                null,
                new Intent().setAction(Intent.ACTION_VIEW)
                        .setData(Uri.parse(""http://www.example.com/blah"")));
        checkIntentUri(
                ""intent://www.example.com/blah#Intent;scheme=http;component=com.exfoo/com.argh.Bar;end"",
                null,
                new Intent().setAction(Intent.ACTION_VIEW)
                        .setData(Uri.parse(""http://www.example.com/blah""))
                        .setComponent(new ComponentName(""com.exfoo"", ""com.argh.Bar"")));
        checkIntentUri(
                ""intent://www.example.com/blah#fragment#Intent;scheme=http;end"",
                null,
                new Intent().setAction(Intent.ACTION_VIEW)
                        .setData(Uri.parse(""http://www.example.com/blah#fragment"")));
        checkIntentUri(
                ""intent://www.example.com/blah#Intent;scheme=http;action=android.test.foo;end"",
                null,
                new Intent().setAction(""android.test.foo"")
                        .setData(Uri.parse(""http://www.example.com/blah"")));
        checkIntentUri(
                ""intent:foo#Intent;scheme=mailto;type=image/foo;end"",
                null,
                new Intent().setAction(Intent.ACTION_VIEW)
                        .setDataAndType(Uri.parse(""mailto:foo""), ""image/foo""));
        checkIntentUri(
                ""intent:foo#Intent;scheme=mailto;S.string=text;end"",
                null,
                new Intent().setAction(Intent.ACTION_VIEW)
                        .setData(Uri.parse(""mailto:foo""))
                        .putExtra(""string"", ""text""));
        checkIntentUri(
                ""intent:#Intent;action=android.test.FOO;S.string=text;end"",
                null,
                new Intent().setAction(""android.test.FOO"").putExtra(""string"", ""text""));
        checkIntentUri(
                ""intent:foo#Intent;scheme=mailto;i.int=1000;end"",
                null,
                new Intent().setAction(Intent.ACTION_VIEW)
                        .setData(Uri.parse(""mailto:foo""))
                        .putExtra(""int"", 1000));
        checkIntentUri(
                ""intent:foo#Intent;scheme=mailto;l.long=1000;end"",
                null,
                new Intent().setAction(Intent.ACTION_VIEW)
                        .setData(Uri.parse(""mailto:foo""))
                        .putExtra(""long"", (long) 1000));
        checkIntentUri(
                ""intent:foo#Intent;scheme=mailto;B.boolean=true;end"",
                null,
                new Intent().setAction(Intent.ACTION_VIEW)
                        .setData(Uri.parse(""mailto:foo""))
                        .putExtra(""boolean"", true));
        checkIntentUri(
                ""intent:foo#Intent;scheme=mailto;f.float=10.4;end"",
                null,
                new Intent().setAction(Intent.ACTION_VIEW)
                        .setData(Uri.parse(""mailto:foo""))
                        .putExtra(""float"", 10.4f));
        checkIntentUri(
                ""intent:foo#Intent;scheme=mailto;d.double=10.4;end"",
                null,
                new Intent().setAction(Intent.ACTION_VIEW)
                        .setData(Uri.parse(""mailto:foo""))
                        .putExtra(""double"", (double) 10.4));
        checkIntentUri(
                ""intent:#Intent;S.string=text;i.int=1000;l.long=1000;B.boolean=true;f.float=10.4;end"",
                null,
                new Intent().setAction(Intent.ACTION_VIEW).putExtra(""string"", ""text"")
                        .putExtra(""int"", 1000).putExtra(""long"", (long) 1000)
                        .putExtra(""boolean"", true).putExtra(""float"", 10.4f));
        checkIntentUri(
                ""intent:foo#Intent;scheme=mailto;SEL;scheme=foobar;action=android.test.FOO;end"",
                null,
                makeSelector(new Intent(Intent.ACTION_VIEW).setData(Uri.parse(""mailto:foo"")),
                        new Intent(""android.test.FOO"").setData(Uri.parse(""foobar:""))));
        checkIntentUri(
                ""intent:foo#Intent;scheme=mailto;SEL;action=android.test.FOO;package=com.myapp;end"",
                null,
                makeSelector(new Intent(Intent.ACTION_VIEW).setData(Uri.parse(""mailto:foo"")),
                        new Intent(""android.test.FOO"").setPackage(""com.myapp"")));
        checkIntentUri(
                ""intent:foo#Intent;scheme=mailto;SEL;action=android.test.FOO;component=com.exfoo/com.argh.Bar;end"",
                null,
                makeSelector(new Intent(Intent.ACTION_VIEW).setData(Uri.parse(""mailto:foo"")),
                        new Intent(""android.test.FOO"")
                                .setComponent(new ComponentName(""com.exfoo"", ""com.argh.Bar""))));

        checkIntentUri(
                ""intent:#Intent;action=android.test.FOO;package=com.myapp;end"",
                ""android-app://com.myapp#Intent;action=android.test.FOO;end"",
                new Intent().setAction(""android.test.FOO"").setPackage(""com.myapp""));
        checkIntentUri(
                ""intent:#Intent;action=android.intent.action.MAIN;package=com.myapp;end"",
                ""android-app://com.myapp"",
                new Intent().setAction(Intent.ACTION_MAIN).setPackage(""com.myapp""));
        checkIntentUri(
                ""intent:#Intent;package=com.myapp;end"",
                ""android-app://com.myapp#Intent;action=android.intent.action.VIEW;end"",
                new Intent().setAction(Intent.ACTION_VIEW).setPackage(""com.myapp""));
        checkIntentUri(
                ""intent:#Intent;category=android.test.FOO;package=com.myapp;end"",
                ""android-app://com.myapp#Intent;action=android.intent.action.VIEW;category=android.test.FOO;end"",
                new Intent().setAction(Intent.ACTION_VIEW).addCategory(""android.test.FOO"")
                        .setPackage(""com.myapp""));
        checkIntentUri(
                ""intent:#Intent;action=android.test.FOO;launchFlags=0x20;package=com.myapp;end"",
                ""android-app://com.myapp#Intent;action=android.test.FOO;launchFlags=0x20;end"",
                new Intent().setAction(""android.test.FOO"").setFlags(0x20)
                        .setPackage(""com.myapp""));
        checkIntentUri(
                ""intent://www.example.com/blah#Intent;scheme=http;package=com.myapp;end"",
                ""android-app://com.myapp/http/www.example.com/blah"",
                new Intent().setAction(Intent.ACTION_VIEW)
                        .setData(Uri.parse(""http://www.example.com/blah""))
                        .setPackage(""com.myapp""));
        checkIntentUri(
                ""intent://www.example.com/blah#Intent;scheme=http;package=com.myapp;component=com.exfoo/com.argh.Bar;end"",
                ""android-app://com.myapp/http/www.example.com/blah#Intent;component=com.exfoo/com.argh.Bar;end"",
                new Intent().setAction(Intent.ACTION_VIEW)
                        .setData(Uri.parse(""http://www.example.com/blah""))
                        .setComponent(new ComponentName(""com.exfoo"", ""com.argh.Bar""))
                        .setPackage(""com.myapp""));
        checkIntentUri(
                ""intent://www.example.com/blah#fragment#Intent;scheme=http;package=com.myapp;end"",
                ""android-app://com.myapp/http/www.example.com/blah#fragment"",
                new Intent().setAction(Intent.ACTION_VIEW)
                        .setData(Uri.parse(""http://www.example.com/blah#fragment""))
                        .setPackage(""com.myapp""));
        checkIntentUri(
                ""intent://www.example.com/blah#fragment#Intent;scheme=http;action=android.test.FOO;package=com.myapp;end"",
                ""android-app://com.myapp/http/www.example.com/blah#fragment#Intent;action=android.test.FOO;end"",
                new Intent().setAction(""android.test.FOO"")
                        .setData(Uri.parse(""http://www.example.com/blah#fragment""))
                        .setPackage(""com.myapp""));
        checkIntentUri(
                ""intent://www.example.com/blah#Intent;scheme=http;package=com.myapp;end"",
                ""android-app://com.myapp/http/www.example.com/blah"",
                new Intent().setAction(Intent.ACTION_VIEW)
                        .setData(Uri.parse(""http://www.example.com/blah""))
                        .setPackage(""com.myapp""));
        checkIntentUri(
                ""intent:#Intent;scheme=mailto;type=image/foo;package=com.myapp;end"",
                ""android-app://com.myapp/mailto#Intent;type=image/foo;end"",
                new Intent().setAction(Intent.ACTION_VIEW)
                        .setDataAndType(Uri.parse(""mailto:""), ""image/foo"")
                        .setPackage(""com.myapp""));
        checkIntentUri(
                ""intent:#Intent;scheme=mailto;package=com.myapp;S.string=text;end"",
                ""android-app://com.myapp/mailto#Intent;S.string=text;end"",
                new Intent().setAction(Intent.ACTION_VIEW).putExtra(""string"", ""text"")
                        .setData(Uri.parse(""mailto:"")).setPackage(""com.myapp""));
        checkIntentUri(
                ""intent:#Intent;action=android.test.FOO;package=com.myapp;S.string=text;end"",
                ""android-app://com.myapp#Intent;action=android.test.FOO;S.string=text;end"",
                new Intent().setAction(""android.test.FOO"").putExtra(""string"", ""text"")
                        .setPackage(""com.myapp""));
        checkIntentUri(
                ""intent:#Intent;scheme=mailto;package=com.myapp;i.int=1000;end"",
                ""android-app://com.myapp/mailto#Intent;i.int=1000;end"",
                new Intent().setAction(Intent.ACTION_VIEW).putExtra(""int"", 1000)
                        .setData(Uri.parse(""mailto:"")).setPackage(""com.myapp""));
        checkIntentUri(
                ""intent:#Intent;scheme=mailto;package=com.myapp;l.long=1000;end"",
                ""android-app://com.myapp/mailto#Intent;l.long=1000;end"",
                new Intent().setAction(Intent.ACTION_VIEW).putExtra(""long"", (long) 1000)
                        .setData(Uri.parse(""mailto:"")).setPackage(""com.myapp""));
        checkIntentUri(
                ""intent:#Intent;scheme=mailto;package=com.myapp;B.boolean=true;end"",
                ""android-app://com.myapp/mailto#Intent;B.boolean=true;end"",
                new Intent().setAction(Intent.ACTION_VIEW).putExtra(""boolean"", true)
                        .setData(Uri.parse(""mailto:"")).setPackage(""com.myapp""));
        checkIntentUri(
                ""intent:#Intent;scheme=mailto;package=com.myapp;f.float=10.4;end"",
                ""android-app://com.myapp/mailto#Intent;f.float=10.4;end"",
                new Intent().setAction(Intent.ACTION_VIEW).putExtra(""float"", 10.4f)
                        .setData(Uri.parse(""mailto:"")).setPackage(""com.myapp""));
        checkIntentUri(
                ""intent:#Intent;scheme=mailto;package=com.myapp;d.double=10.4;end"",
                ""android-app://com.myapp/mailto#Intent;d.double=10.4;end"",
                new Intent().setAction(Intent.ACTION_VIEW).putExtra(""double"", (double) 10.4)
                        .setData(Uri.parse(""mailto:"")).setPackage(""com.myapp""));
        checkIntentUri(
                ""intent:#Intent;package=com.myapp;S.string=text;i.int=1000;l.long=1000;B.boolean=true;f.float=10.4;end"",
                ""android-app://com.myapp#Intent;action=android.intent.action.VIEW;S.string=text;i.int=1000;l.long=1000;B.boolean=true;f.float=10.4;end"",
                new Intent().setAction(Intent.ACTION_VIEW).putExtra(""string"", ""text"")
                        .putExtra(""int"", 1000).putExtra(""long"", (long) 1000)
                        .putExtra(""boolean"", true).putExtra(""float"", 10.4f)
                        .setPackage(""com.myapp""));
        checkIntentUri(
                ""intent://example.org/db?123#Intent;scheme=z39.50r;end"",
                null,
                new Intent().setAction(Intent.ACTION_VIEW)
                        .setData(Uri.parse(""z39.50r://example.org/db?123"")));
    }

    private boolean compareIntents(Intent expected, Intent actual) {
        if (!Objects.equals(expected.getAction(), actual.getAction())) {
            return false;
        }
        if (!Objects.equals(expected.getData(), actual.getData())) {
            return false;
        }
        if (!Objects.equals(expected.getType(), actual.getType())) {
            return false;
        }
        if (!Objects.equals(expected.getIdentifier(), actual.getIdentifier())) {
            return false;
        }
        if (!Objects.equals(expected.getPackage(), actual.getPackage())) {
            return false;
        }
        if (!Objects.equals(expected.getComponent(), actual.getComponent())) {
            return false;
        }
        if (expected.getFlags() != actual.getFlags()) {
            return false;
        }
        Set<String> expectedCat = expected.getCategories();
        Set<String> actualCat = actual.getCategories();
        if (expectedCat != actualCat) {
            if (expectedCat == null || actualCat == null) {
                return false;
            }
            for (String cat : expectedCat) {
                if (!actual.hasCategory(cat)) {
                    return false;
                }
            }
            for (String cat : actualCat) {
                if (!expected.hasCategory(cat)) {
                    return false;
                }
            }
        }
        Bundle extras1 = expected.getExtras();
        Bundle extras2 = actual.getExtras();
        if (extras1 != extras2) {
            if (extras1 == null || extras2 == null) {
                return false;
            }
            for (String key : extras1.keySet()) {
                if (!Objects.equals(extras1.get(key), extras2.get(key))) {
                    return false;
                }
            }
            for (String key : extras2.keySet()) {
                if (!Objects.equals(extras1.get(key), extras2.get(key))) {
                    return false;
                }
            }
        }
        return true;
    }

    private void assertEqualsIntent(String msg, Intent expected, Intent actual) {
        if (!compareIntents(expected, actual)) {
            failNotEquals(msg, expected, actual);
        }
        Intent expectedSel = expected.getSelector();
        Intent actualSel = actual.getSelector();
        if (expectedSel != actualSel) {
            if (expectedSel == null || actualSel == null) {
                failNotEquals(msg, expected, actual);
            }
            if (!compareIntents(expectedSel, actualSel)) {
                failNotEquals(msg, expected, actual);
            }
        }
    }

    private void checkIntentUri(String intentSchemeUri, String androidAppSchemeUri, Intent intent) {
        if (intentSchemeUri != null) {
            try {
                Intent genIntent = Intent.parseUri(intentSchemeUri, 0);
                assertEqualsIntent(""Implicitly converting "" + intentSchemeUri + "" to Intent"",
                        intent, genIntent);
                genIntent = Intent.parseUri(intentSchemeUri, Intent.URI_INTENT_SCHEME);
                assertEqualsIntent(""Explicitly converting "" + intentSchemeUri + "" to Intent"",
                        intent, genIntent);
            } catch (URISyntaxException e) {
                fail(""Failure parsing "" + intentSchemeUri + "": "" + e);
            }
            String genUri = intent.toUri(Intent.URI_INTENT_SCHEME);
            assertEquals(""Converting "" + intent + "" to intent: uri"",
                    intentSchemeUri, genUri);
        }
        if (androidAppSchemeUri != null) {
            try {
                Intent genIntent = Intent.parseUri(androidAppSchemeUri, 0);
                assertEqualsIntent(""Implicitly converting "" + androidAppSchemeUri + "" to Intent"",
                        intent, genIntent);
                genIntent = Intent.parseUri(intentSchemeUri, Intent.URI_ANDROID_APP_SCHEME);
                assertEqualsIntent(""Explicitly converting "" + androidAppSchemeUri + "" to Intent"",
                        intent, genIntent);
            } catch (URISyntaxException e) {
                fail(""Failure parsing "" + androidAppSchemeUri + "": "" + e);
            }
            String genUri = intent.toUri(Intent.URI_ANDROID_APP_SCHEME);
            assertEquals(""Converting "" + intent + "" to android-app: uri"",
                    androidAppSchemeUri, genUri);
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/IntentTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.content.cts.IntentTest"	"testToURI"	"CtsContentTestCases"	"1: ui"	"public void testToURI() {
        mIntent = new Intent();
        assertEquals("""", mIntent.toURI());

        mIntent.setData(TEST_URI);
        assertTrue(mIntent.toURI().indexOf(TEST_URI.toString()) != -1);

        mIntent.setAction(TEST_ACTION);
        assertTrue(mIntent.toURI().indexOf(""action="" + TEST_ACTION) != -1);

        mIntent.addCategory(TEST_CATEGORY);
        assertTrue(mIntent.toURI().indexOf(""category="") != -1);

        mIntent.setType(TEST_TYPE);
        assertTrue(mIntent.toURI().indexOf(""type="" + TEST_TYPE) != -1);

        mIntent.setIdentifier(TEST_IDENTIFIER);
        assertTrue(mIntent.toURI().indexOf(""identifier="" + TEST_IDENTIFIER) != -1);

        mIntent.setFlags(1);
        assertFalse(mIntent.toURI().indexOf(""launchFlags="" + Integer.toHexString(1)) != -1);

        mIntent.setComponent(mComponentName);
        assertTrue(mIntent.toURI().indexOf(
                ""component="" + mComponentName.flattenToShortString()) != -1);

        final String stringValue = ""testString"";
        mIntent.putExtra(TEST_EXTRA_NAME, stringValue);

        assertTrue(mIntent.toURI().indexOf(getString(""S"", TEST_EXTRA_NAME, stringValue)) != -1);

        mIntent.putExtra(TEST_EXTRA_NAME, true);

        assertTrue(mIntent.toURI().indexOf(getString(""B"", TEST_EXTRA_NAME, true)) != -1);

        final byte b = 1;
        mIntent.putExtra(TEST_EXTRA_NAME, b);
        assertTrue(mIntent.toURI().indexOf(getString(""b"", TEST_EXTRA_NAME, b)) != -1);

        final Character testChar = 'a';
        mIntent.putExtra(TEST_EXTRA_NAME, testChar);

        assertTrue(mIntent.toURI().indexOf(getString(""c"", TEST_EXTRA_NAME, testChar)) != -1);

        final double testDouble = 1;
        mIntent.putExtra(TEST_EXTRA_NAME, testDouble);
        assertTrue(mIntent.toURI().indexOf(getString(""d"", TEST_EXTRA_NAME, testDouble)) != -1);

        final int testInt = 1;
        mIntent.putExtra(TEST_EXTRA_NAME, testInt);
        assertTrue(mIntent.toURI().indexOf(getString(""i"", TEST_EXTRA_NAME, testInt)) != -1);

        final long testLong = 1l;
        mIntent.putExtra(TEST_EXTRA_NAME, testLong);
        assertTrue(mIntent.toURI().indexOf(getString(""l"", TEST_EXTRA_NAME, testLong)) != -1);
        final short testShort = 1;
        mIntent.putExtra(TEST_EXTRA_NAME, testShort);
        assertTrue(mIntent.toURI().indexOf(getString(""s"", TEST_EXTRA_NAME, testShort)) != -1);
        assertTrue(mIntent.toURI().indexOf(""end"") != -1);
    }

    private String getString(String entryType, String key, Object value) {
        StringBuilder uri = new StringBuilder();
        uri.append(entryType);
        uri.append('.');
        uri.append(Uri.encode(key));
        uri.append('=');
        uri.append(Uri.encode(value.toString()));
        return uri.toString();
    }

    static Intent makeSelector(Intent baseIntent, Intent selectorIntent) {
        baseIntent.setSelector(selectorIntent);
        return baseIntent;
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/IntentTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.content.cts.IntentTest"	"testNormalizeMimeType"	"CtsContentTestCases"	"1: ui"	"public void testNormalizeMimeType() {
        assertEquals(null, Intent.normalizeMimeType(null));
        assertEquals(""text/plain"", Intent.normalizeMimeType(""text/plain; charset=UTF-8""));
        assertEquals(""text/x-vcard"", Intent.normalizeMimeType(""text/x-vCard""));
        assertEquals(""foo/bar"", Intent.normalizeMimeType(""   foo/bar    ""));
    }

    private static class TestSerializable implements Serializable {
        static final long serialVersionUID = 1l;
        public String Name;
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/content/src/android/content/cts/IntentTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.hardware.cts.helpers.sensorverification.JitterVerificationTest"	"testVerify"	"CtsSensorTestCases"	"1: ui"	"public void testVerify() {
        final int SAMPLE_SIZE = 100;
        // for unit testing the verification, only the parameter 'sensorMightHaveMoreListeners' is
        // required
        TestSensorEnvironment environment = new TestSensorEnvironment(
                null /* context */,
                null /* sensor */,
                false /* sensorMightHaveMoreListeners */,
                0 /*samplingPeriodUs */,
                0 /* maxReportLatencyUs */);

        // 100 samples at 1000Hz
        long[] timestamps = new long[SAMPLE_SIZE];
        for (int i = 0; i < SAMPLE_SIZE; i++) {
            timestamps[i] = i * 100000;
        }
        SensorStats stats = new SensorStats();
        ISensorVerification verification = getVerification(1, timestamps);
        verification.verify(environment, stats);
        verifyStats(stats, true, 0.0);

        // 90 samples at 1000Hz, 10 samples at 2000Hz
        long timestamp = 0;
        for (int i = 0; i < SAMPLE_SIZE; i++) {
            timestamps[i] = timestamp;
            timestamp += (i % 10 == 0) ? 500000 : 1000000;
        }
        stats = new SensorStats();
        verification = getVerification(1, timestamps);
        try {
            verification.verify(environment, stats);
            throw new Error(""Expected an AssertionError"");
        } catch (AssertionError e) {
            // Expected;
        }
        verifyStats(stats, false, 25); // 500 us range (250 us in single-sided sense)
                                       // divide by 1ms requested sample time x 100%
    }"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/helpers/sensorverification/JitterVerificationTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.autofillservice.cts.dropdown.PreFilledLoginActivityTest"	"testSanitization"	"CtsAutoFillServiceTestCases"	"3: mic ui user"	"public void testSanitization() throws Exception {
        // Set service.
        enableService();

        // Set expectations.
        sReplier.addResponse(new CannedFillResponse.Builder()
                .setRequiredSavableIds(SAVE_DATA_TYPE_PASSWORD, ID_USERNAME, ID_PASSWORD)
                .build());

        // Change view contents.
        mActivity.onUsernameLabel((v) -> v.setText(""DA USER""));
        mActivity.onPasswordLabel((v) -> v.setText(R.string.new_password_label));

        // Trigger auto-fill.
        mActivity.onUsername((v) -> v.requestFocus());

        // Assert sanitization on fill request:
        final FillRequest fillRequest = sReplier.getNextFillRequest();

        // ...dynamic text should be sanitized.
        assertTextIsSanitized(fillRequest.structure, ID_USERNAME_LABEL);

        // ...password label should be ok because it was set from other resource id
        assertTextFromResources(fillRequest.structure, ID_PASSWORD_LABEL, ""DA PASSWORD"", false,
                ""new_password_label"");

        // ...username and password should be ok because they were set in the SML
        assertTextAndValue(findNodeByResourceId(fillRequest.structure, ID_USERNAME),
                ""secret_agent"");
        assertTextAndValue(findNodeByResourceId(fillRequest.structure, ID_PASSWORD), ""T0p S3cr3t"");

        // Trigger save
        mActivity.onUsername((v) -> v.setText(""malkovich""));
        mActivity.onPassword((v) -> v.setText(""malkovich""));
        mActivity.tapLogin();

        // Assert the snack bar is shown and tap ""Save"".
        mUiBot.saveForAutofill(true, SAVE_DATA_TYPE_PASSWORD);
        final SaveRequest saveRequest = sReplier.getNextSaveRequest();

        // Assert sanitization on save: everything should be available!
        assertTextOnly(findNodeByResourceId(saveRequest.structure, ID_USERNAME_LABEL), ""DA USER"");
        assertTextFromResources(saveRequest.structure, ID_PASSWORD_LABEL, ""DA PASSWORD"", false,
                ""new_password_label"");
        assertTextAndValue(findNodeByResourceId(saveRequest.structure, ID_USERNAME), ""malkovich"");
        assertTextAndValue(findNodeByResourceId(saveRequest.structure, ID_PASSWORD), ""malkovich"");
    }
}"	"/home/gpoor/cts-12-source/cts/tests/autofillservice/src/android/autofillservice/cts/dropdown/PreFilledLoginActivityTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.os.cts.StatFsTest"	"testStatFs"	""	"1: direct"	"public void testStatFs() {
        File path = Environment.getDataDirectory();
        StatFs stat = new StatFs(path.getPath());

        assertTrue(stat.getBlockSize() > 0);
        assertTrue(stat.getBlockCount() > 0);
        assertTrue(stat.getFreeBlocks() >= stat.getAvailableBlocks());
        assertTrue(stat.getAvailableBlocks() > 0);

        assertTrue(stat.getBlockSizeLong() > 0);
        assertTrue(stat.getBlockCountLong() > 0);
        assertTrue(stat.getFreeBlocksLong() >= stat.getAvailableBlocksLong());
        assertTrue(stat.getAvailableBlocksLong() > 0);

        assertTrue(stat.getFreeBytes() > 0);
        assertTrue(stat.getAvailableBytes() > 0);
        assertTrue(stat.getTotalBytes() > 0);

        path = Environment.getRootDirectory();
        stat.restat(path.getPath());

        assertTrue(stat.getBlockSize() > 0);
        assertTrue(stat.getBlockCount() > 0);
        assertTrue(stat.getFreeBlocks() >= stat.getAvailableBlocks());
        assertTrue(stat.getAvailableBlocks() >= 0);

        assertTrue(stat.getBlockSizeLong() > 0);
        assertTrue(stat.getBlockCountLong() > 0);
        assertTrue(stat.getFreeBlocksLong() >= stat.getAvailableBlocksLong());
        assertTrue(stat.getAvailableBlocksLong() >= 0);

        assertTrue(stat.getFreeBytes() >= 0);
        assertTrue(stat.getAvailableBytes() >= 0);
        assertTrue(stat.getTotalBytes() > 0);
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/StatFsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.media.cts.MediaRouter2Test"	"markCallbacksAsTested"	"CtsMediaTestCases"	"3: direct ui system"	"public void markCallbacksAsTested() {
        // Due to CTS coverage tool's bug, it doesn't count the callback methods as tested even if
        // we have tests for them. This method just directly calls those methods so that the tool
        // can recognize the callback methods as tested.

        RouteCallback routeCallback = new RouteCallback() {};
        routeCallback.onRoutesAdded(null);
        routeCallback.onRoutesChanged(null);
        routeCallback.onRoutesRemoved(null);

        TransferCallback transferCallback = new TransferCallback() {};
        transferCallback.onTransfer(null, null);
        transferCallback.onTransferFailure(null);

        ControllerCallback controllerCallback = new ControllerCallback() {};
        controllerCallback.onControllerUpdated(null);

        OnGetControllerHintsListener listener = route -> null;
        listener.onGetControllerHints(null);
    }

    // Helper for getting routes easily. Uses original ID as a key
    private static Map<String, MediaRoute2Info> createRouteMap(List<MediaRoute2Info> routes) {
        Map<String, MediaRoute2Info> routeMap = new HashMap<>();
        for (MediaRoute2Info route : routes) {
            routeMap.put(route.getOriginalId(), route);
        }
        return routeMap;
    }

    private Map<String, MediaRoute2Info> waitAndGetRoutes(List<String> routeTypes)
            throws Exception {
        CountDownLatch latch = new CountDownLatch(1);

        RouteCallback routeCallback = new RouteCallback() {
            @Override
            public void onRoutesAdded(List<MediaRoute2Info> routes) {
                for (MediaRoute2Info route : routes) {
                    if (!route.isSystemRoute()) {
                        latch.countDown();
                    }
                }
            }
        };

        mRouter2.registerRouteCallback(mExecutor, routeCallback,
                new RouteDiscoveryPreference.Builder(routeTypes, true).build());
        try {
            latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS);
            return createRouteMap(mRouter2.getRoutes());
        } finally {
            mRouter2.unregisterRouteCallback(routeCallback);
        }
    }

    static void releaseControllers(@NonNull List<RoutingController> controllers) {
        for (RoutingController controller : controllers) {
            controller.release();
        }
    }

    /**
     * Returns a list of original route IDs of the given route list.
     */
    private List<String> getOriginalRouteIds(@NonNull List<MediaRoute2Info> routes) {
        List<String> result = new ArrayList<>();
        for (MediaRoute2Info route : routes) {
            result.add(route.getOriginalId());
        }
        return result;
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaRouter2Test.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.media.cts.MediaRouter2Test"	"emptyList"	"CtsMediaTestCases"	"2: ui system"	"/*
 *.
 */

package android.media.cts;

import static android.content.Context.AUDIO_SERVICE;
import static android.media.MediaRoute2Info.FEATURE_LIVE_AUDIO;
import static android.media.MediaRoute2Info.PLAYBACK_VOLUME_VARIABLE;
import static android.media.cts.StubMediaRoute2ProviderService.FEATURES_SPECIAL;
import static android.media.cts.StubMediaRoute2ProviderService.FEATURE_SAMPLE;
import static android.media.cts.StubMediaRoute2ProviderService.ROUTE_ID1;
import static android.media.cts.StubMediaRoute2ProviderService.ROUTE_ID2;
import static android.media.cts.StubMediaRoute2ProviderService.ROUTE_ID3_SESSION_CREATION_FAILED;
import static android.media.cts.StubMediaRoute2ProviderService.ROUTE_ID4_TO_SELECT_AND_DESELECT;
import static android.media.cts.StubMediaRoute2ProviderService.ROUTE_ID5_TO_TRANSFER_TO;
import static android.media.cts.StubMediaRoute2ProviderService.ROUTE_ID_SPECIAL_FEATURE;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertTrue;
import static org.testng.Assert.assertThrows;

import android.Manifest;
import android.annotation.NonNull;
import android.content.Context;
import android.content.pm.PackageManager;
import android.media.AudioManager;
import android.media.MediaRoute2Info;
import android.media.MediaRouter2;
import android.media.MediaRouter2.ControllerCallback;
import android.media.MediaRouter2.OnGetControllerHintsListener;
import android.media.MediaRouter2.RouteCallback;
import android.media.MediaRouter2.RoutingController;
import android.media.MediaRouter2.TransferCallback;
import android.media.RouteDiscoveryPreference;
import android.os.Bundle;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.LargeTest;
import android.text.TextUtils;

import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.PollingCheck;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

@RunWith(AndroidJUnit4.class)
@AppModeFull(reason = ""The system should be able to bind to StubMediaRoute2ProviderService"")
@LargeTest
@NonMediaMainlineTest
public class MediaRouter2Test {
    private static final String TAG = ""MR2Test"";
    Context mContext;
    private MediaRouter2 mRouter2;
    private Executor mExecutor;
    private AudioManager mAudioManager;
    private RouteCallback mRouterDummyCallback = new RouteCallback(){};
    private StubMediaRoute2ProviderService mService;

    private static final int TIMEOUT_MS = 5000;
    private static final int WAIT_MS = 2000;

    private static final String TEST_KEY = ""test_key"";
    private static final String TEST_VALUE = ""test_value"";
    private static final RouteDiscoveryPreference EMPTY_DISCOVERY_PREFERENCE =
            new RouteDiscoveryPreference.Builder(Collections.emptyList(), false).build();
    private static final RouteDiscoveryPreference LIVE_AUDIO_DISCOVERY_PREFERENCE =
            new RouteDiscoveryPreference.Builder(
                    Collections.singletonList(FEATURE_LIVE_AUDIO), false).build();

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getTargetContext();
        mRouter2 = MediaRouter2.getInstance(mContext);
        mExecutor = Executors.newSingleThreadExecutor();
        mAudioManager = (AudioManager) mContext.getSystemService(AUDIO_SERVICE);

        MediaRouter2TestActivity.startActivity(mContext);

        // In order to make the system bind to the test service,
        // set a non-empty discovery preference while app is in foreground.
        List<String> features = new ArrayList<>();
        features.add(""A test feature"");
        RouteDiscoveryPreference preference =
                new RouteDiscoveryPreference.Builder(features, false).build();
        mRouter2.registerRouteCallback(mExecutor, mRouterDummyCallback, preference);

        new PollingCheck(TIMEOUT_MS) {
            @Override
            protected boolean check() {
                StubMediaRoute2ProviderService service =
                        StubMediaRoute2ProviderService.getInstance();
                if (service != null) {
                    mService = service;
                    return true;
                }
                return false;
            }
        }.run();
        mService.initializeRoutes();
        mService.publishRoutes();
    }

    @After
    public void tearDown() throws Exception {
        mRouter2.unregisterRouteCallback(mRouterDummyCallback);
        MediaRouter2TestActivity.finishActivity();
        if (mService != null) {
            mService.clear();
            mService = null;
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaRouter2Test.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.media.cts.MediaRouter2Test"	"testGetRoutes"	"CtsMediaTestCases"	"1: system"	"public void testGetRoutes() throws Exception {
        Map<String, MediaRoute2Info> routes = waitAndGetRoutes(FEATURES_SPECIAL);

        int remoteRouteCount = 0;
        for (MediaRoute2Info route : routes.values()) {
            if (!route.isSystemRoute()) {
                remoteRouteCount++;
            }
        }

        assertEquals(1, remoteRouteCount);
        assertNotNull(routes.get(ROUTE_ID_SPECIAL_FEATURE));
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaRouter2Test.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.media.cts.MediaRouter2Test"	"testTransferToSuccess"	"CtsMediaTestCases"	"1: system"	"public void testTransferToSuccess() throws Exception {
        final List<String> sampleRouteFeature = new ArrayList<>();
        sampleRouteFeature.add(FEATURE_SAMPLE);

        Map<String, MediaRoute2Info> routes = waitAndGetRoutes(sampleRouteFeature);
        MediaRoute2Info route = routes.get(ROUTE_ID1);
        assertNotNull(route);

        final CountDownLatch successLatch = new CountDownLatch(1);
        final CountDownLatch failureLatch = new CountDownLatch(1);
        final List<RoutingController> controllers = new ArrayList<>();

        // Create session with this route
        TransferCallback controllerCallback = new TransferCallback() {
            @Override
            public void onTransfer(RoutingController oldController,
                    RoutingController newController) {
                assertEquals(mRouter2.getSystemController(), oldController);
                assertTrue(createRouteMap(newController.getSelectedRoutes()).containsKey(
                        ROUTE_ID1));
                controllers.add(newController);
                successLatch.countDown();
            }

            @Override
            public void onTransferFailure(MediaRoute2Info requestedRoute) {
                failureLatch.countDown();
            }
        };

        // TODO: Remove this once the MediaRouter2 becomes always connected to the service.
        RouteCallback routeCallback = new RouteCallback() {};
        mRouter2.registerRouteCallback(mExecutor, routeCallback, EMPTY_DISCOVERY_PREFERENCE);

        try {
            mRouter2.registerTransferCallback(mExecutor, controllerCallback);
            mRouter2.transferTo(route);
            assertTrue(successLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));

            // onSessionCreationFailed should not be called.
            assertFalse(failureLatch.await(WAIT_MS, TimeUnit.MILLISECONDS));
        } finally {
            releaseControllers(controllers);
            mRouter2.unregisterRouteCallback(routeCallback);
            mRouter2.unregisterTransferCallback(controllerCallback);
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaRouter2Test.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.media.cts.MediaRouter2Test"	"testRoutingControllerSelectAndDeselectRoute"	"CtsMediaTestCases"	"1: system"	"public void testRoutingControllerSelectAndDeselectRoute() throws Exception {
        final List<String> sampleRouteType = new ArrayList<>();
        sampleRouteType.add(FEATURE_SAMPLE);

        Map<String, MediaRoute2Info> routes = waitAndGetRoutes(sampleRouteType);
        MediaRoute2Info routeToBegin = routes.get(ROUTE_ID1);
        assertNotNull(routeToBegin);

        final CountDownLatch onTransferLatch = new CountDownLatch(1);
        final CountDownLatch onControllerUpdatedLatchForSelect = new CountDownLatch(1);
        final CountDownLatch onControllerUpdatedLatchForDeselect = new CountDownLatch(1);
        final List<RoutingController> controllers = new ArrayList<>();


        // Create session with ROUTE_ID1
        TransferCallback transferCallback = new TransferCallback() {
            @Override
            public void onTransfer(RoutingController oldController,
                    RoutingController newController) {
                assertEquals(mRouter2.getSystemController(), oldController);
                assertTrue(getOriginalRouteIds(newController.getSelectedRoutes()).contains(
                        ROUTE_ID1));
                controllers.add(newController);
                onTransferLatch.countDown();
            }
        };

        ControllerCallback controllerCallback = new ControllerCallback() {
            @Override
            public void onControllerUpdated(RoutingController controller) {
                if (onTransferLatch.getCount() != 0
                        || !TextUtils.equals(controllers.get(0).getId(), controller.getId())) {
                    return;
                }

                if (onControllerUpdatedLatchForSelect.getCount() != 0) {
                    assertEquals(2, controller.getSelectedRoutes().size());
                    assertTrue(getOriginalRouteIds(controller.getSelectedRoutes())
                            .contains(ROUTE_ID1));
                    assertTrue(getOriginalRouteIds(controller.getSelectedRoutes())
                            .contains(ROUTE_ID4_TO_SELECT_AND_DESELECT));
                    assertFalse(getOriginalRouteIds(controller.getSelectableRoutes())
                            .contains(ROUTE_ID4_TO_SELECT_AND_DESELECT));
                    assertTrue(getOriginalRouteIds(controller.getDeselectableRoutes())
                            .contains(ROUTE_ID4_TO_SELECT_AND_DESELECT));

                    onControllerUpdatedLatchForSelect.countDown();
                } else {
                    assertEquals(1, controller.getSelectedRoutes().size());
                    assertTrue(getOriginalRouteIds(controller.getSelectedRoutes())
                            .contains(ROUTE_ID1));
                    assertFalse(getOriginalRouteIds(controller.getSelectedRoutes())
                            .contains(ROUTE_ID4_TO_SELECT_AND_DESELECT));
                    assertTrue(getOriginalRouteIds(controller.getSelectableRoutes())
                            .contains(ROUTE_ID4_TO_SELECT_AND_DESELECT));
                    assertFalse(getOriginalRouteIds(controller.getDeselectableRoutes())
                            .contains(ROUTE_ID4_TO_SELECT_AND_DESELECT));

                    onControllerUpdatedLatchForDeselect.countDown();
                }
            }
        };


        // TODO: Remove this once the MediaRouter2 becomes always connected to the service.
        RouteCallback routeCallback = new RouteCallback() {};
        mRouter2.registerRouteCallback(mExecutor, routeCallback, EMPTY_DISCOVERY_PREFERENCE);

        try {
            mRouter2.registerTransferCallback(mExecutor, transferCallback);
            mRouter2.registerControllerCallback(mExecutor, controllerCallback);
            mRouter2.transferTo(routeToBegin);
            assertTrue(onTransferLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));

            assertEquals(1, controllers.size());
            RoutingController controller = controllers.get(0);
            assertTrue(getOriginalRouteIds(controller.getSelectableRoutes())
                    .contains(ROUTE_ID4_TO_SELECT_AND_DESELECT));

            // Select ROUTE_ID4_TO_SELECT_AND_DESELECT
            MediaRoute2Info routeToSelectAndDeselect = routes.get(
                    ROUTE_ID4_TO_SELECT_AND_DESELECT);
            assertNotNull(routeToSelectAndDeselect);

            controller.selectRoute(routeToSelectAndDeselect);
            assertTrue(onControllerUpdatedLatchForSelect.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));

            controller.deselectRoute(routeToSelectAndDeselect);
            assertTrue(onControllerUpdatedLatchForDeselect.await(
                    TIMEOUT_MS, TimeUnit.MILLISECONDS));
        } finally {
            releaseControllers(controllers);
            mRouter2.unregisterRouteCallback(routeCallback);
            mRouter2.unregisterTransferCallback(transferCallback);
            mRouter2.unregisterControllerCallback(controllerCallback);
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaRouter2Test.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.media.cts.MediaRouter2Test"	"testRoutingControllerTransferToRoute"	"CtsMediaTestCases"	"1: system"	"public void testRoutingControllerTransferToRoute() throws Exception {
        final List<String> sampleRouteType = new ArrayList<>();
        sampleRouteType.add(FEATURE_SAMPLE);

        Map<String, MediaRoute2Info> routes = waitAndGetRoutes(sampleRouteType);
        MediaRoute2Info routeToBegin = routes.get(ROUTE_ID1);
        assertNotNull(routeToBegin);

        final CountDownLatch onTransferLatch = new CountDownLatch(1);
        final CountDownLatch onControllerUpdatedLatch = new CountDownLatch(1);
        final List<RoutingController> controllers = new ArrayList<>();

        // Create session with ROUTE_ID1
        TransferCallback transferCallback = new TransferCallback() {
            @Override
            public void onTransfer(RoutingController oldController,
                    RoutingController newController) {
                assertEquals(mRouter2.getSystemController(), oldController);
                assertTrue(getOriginalRouteIds(newController.getSelectedRoutes()).contains(
                        ROUTE_ID1));
                controllers.add(newController);
                onTransferLatch.countDown();
            }
        };

        ControllerCallback controllerCallback = new ControllerCallback() {
            @Override
            public void onControllerUpdated(RoutingController controller) {
                if (onTransferLatch.getCount() != 0
                        || !TextUtils.equals(controllers.get(0).getId(), controller.getId())) {
                    return;
                }
                assertEquals(1, controller.getSelectedRoutes().size());
                assertFalse(getOriginalRouteIds(controller.getSelectedRoutes()).contains(
                        ROUTE_ID1));
                assertTrue(getOriginalRouteIds(controller.getSelectedRoutes())
                        .contains(ROUTE_ID5_TO_TRANSFER_TO));
                onControllerUpdatedLatch.countDown();
            }
        };

        // TODO: Remove this once the MediaRouter2 becomes always connected to the service.
        RouteCallback routeCallback = new RouteCallback() {};
        mRouter2.registerRouteCallback(mExecutor, routeCallback, EMPTY_DISCOVERY_PREFERENCE);

        try {
            mRouter2.registerTransferCallback(mExecutor, transferCallback);
            mRouter2.registerControllerCallback(mExecutor, controllerCallback);
            mRouter2.transferTo(routeToBegin);
            assertTrue(onTransferLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));

            assertEquals(1, controllers.size());
            RoutingController controller = controllers.get(0);

            // Transfer to ROUTE_ID5_TO_TRANSFER_TO
            MediaRoute2Info routeToTransferTo = routes.get(ROUTE_ID5_TO_TRANSFER_TO);
            assertNotNull(routeToTransferTo);

            mRouter2.transferTo(routeToTransferTo);
            assertTrue(onControllerUpdatedLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
        } finally {
            releaseControllers(controllers);
            mRouter2.unregisterRouteCallback(routeCallback);
            mRouter2.unregisterControllerCallback(controllerCallback);
            mRouter2.unregisterTransferCallback(transferCallback);
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaRouter2Test.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.media.cts.MediaRouter2Test"	"testControllerCallbackUnregister"	"CtsMediaTestCases"	"1: system"	"public void testControllerCallbackUnregister() throws Exception {
        final List<String> sampleRouteType = new ArrayList<>();
        sampleRouteType.add(FEATURE_SAMPLE);

        Map<String, MediaRoute2Info> routes = waitAndGetRoutes(sampleRouteType);
        MediaRoute2Info routeToBegin = routes.get(ROUTE_ID1);
        assertNotNull(routeToBegin);

        final CountDownLatch onTransferLatch = new CountDownLatch(1);
        final CountDownLatch onControllerUpdatedLatch = new CountDownLatch(1);
        final List<RoutingController> controllers = new ArrayList<>();

        // Create session with ROUTE_ID1
        TransferCallback transferCallback = new TransferCallback() {
            @Override
            public void onTransfer(RoutingController oldController,
                    RoutingController newController) {
                assertEquals(mRouter2.getSystemController(), oldController);
                assertTrue(getOriginalRouteIds(newController.getSelectedRoutes()).contains(
                        ROUTE_ID1));
                controllers.add(newController);
                onTransferLatch.countDown();
            }
        };
        ControllerCallback controllerCallback = new ControllerCallback() {
            @Override
            public void onControllerUpdated(RoutingController controller) {
                if (onTransferLatch.getCount() != 0
                        || !TextUtils.equals(controllers.get(0).getId(), controller.getId())) {
                    return;
                }
                assertEquals(1, controller.getSelectedRoutes().size());
                assertFalse(getOriginalRouteIds(controller.getSelectedRoutes()).contains(
                        ROUTE_ID1));
                assertTrue(getOriginalRouteIds(controller.getSelectedRoutes())
                        .contains(ROUTE_ID5_TO_TRANSFER_TO));
                onControllerUpdatedLatch.countDown();
            }
        };

        // TODO: Remove this once the MediaRouter2 becomes always connected to the service.
        RouteCallback routeCallback = new RouteCallback() {};
        mRouter2.registerRouteCallback(mExecutor, routeCallback, EMPTY_DISCOVERY_PREFERENCE);

        try {
            mRouter2.registerTransferCallback(mExecutor, transferCallback);
            mRouter2.registerControllerCallback(mExecutor, controllerCallback);
            mRouter2.transferTo(routeToBegin);
            assertTrue(onTransferLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));

            assertEquals(1, controllers.size());

            // Transfer to ROUTE_ID5_TO_TRANSFER_TO
            MediaRoute2Info routeToTransferTo = routes.get(ROUTE_ID5_TO_TRANSFER_TO);
            assertNotNull(routeToTransferTo);

            mRouter2.unregisterControllerCallback(controllerCallback);
            mRouter2.transferTo(routeToTransferTo);
            assertFalse(onControllerUpdatedLatch.await(WAIT_MS, TimeUnit.MILLISECONDS));
        } finally {
            releaseControllers(controllers);
            mRouter2.unregisterRouteCallback(routeCallback);
            mRouter2.unregisterControllerCallback(controllerCallback);
            mRouter2.unregisterTransferCallback(transferCallback);
        }
    }

    // TODO: Add tests for onStop() when provider releases the session."	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaRouter2Test.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.media.cts.MediaRouter2Test"	"testStop"	"CtsMediaTestCases"	"1: system"	"public void testStop() throws Exception {
        final List<String> sampleRouteType = new ArrayList<>();
        sampleRouteType.add(FEATURE_SAMPLE);

        Map<String, MediaRoute2Info> routes = waitAndGetRoutes(sampleRouteType);
        MediaRoute2Info routeTransferFrom = routes.get(ROUTE_ID1);
        assertNotNull(routeTransferFrom);

        final CountDownLatch onTransferLatch = new CountDownLatch(1);
        final CountDownLatch onControllerUpdatedLatch = new CountDownLatch(1);
        final CountDownLatch onStopLatch = new CountDownLatch(1);
        final List<RoutingController> controllers = new ArrayList<>();

        TransferCallback transferCallback = new TransferCallback() {
            @Override
            public void onTransfer(RoutingController oldController,
                    RoutingController newController) {
                assertEquals(mRouter2.getSystemController(), oldController);
                assertTrue(getOriginalRouteIds(newController.getSelectedRoutes()).contains(
                        ROUTE_ID1));
                controllers.add(newController);
                onTransferLatch.countDown();
            }
            @Override
            public void onStop(RoutingController controller) {
                if (onTransferLatch.getCount() != 0
                        || !TextUtils.equals(
                        controllers.get(0).getId(), controller.getId())) {
                    return;
                }
                onStopLatch.countDown();
            }
        };

        ControllerCallback controllerCallback = new ControllerCallback() {
            @Override
            public void onControllerUpdated(RoutingController controller) {
                if (onTransferLatch.getCount() != 0
                        || !TextUtils.equals(controllers.get(0).getId(), controller.getId())) {
                    return;
                }
                onControllerUpdatedLatch.countDown();
            }
        };

        // TODO: Remove this once the MediaRouter2 becomes always connected to the service.
        RouteCallback routeCallback = new RouteCallback() {};
        mRouter2.registerRouteCallback(mExecutor, routeCallback, EMPTY_DISCOVERY_PREFERENCE);

        try {
            mRouter2.registerTransferCallback(mExecutor, transferCallback);
            mRouter2.registerControllerCallback(mExecutor, controllerCallback);
            mRouter2.transferTo(routeTransferFrom);
            assertTrue(onTransferLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));

            assertEquals(1, controllers.size());
            RoutingController controller = controllers.get(0);

            mRouter2.stop();

            // Select ROUTE_ID5_TO_TRANSFER_TO
            MediaRoute2Info routeToSelect = routes.get(ROUTE_ID4_TO_SELECT_AND_DESELECT);
            assertNotNull(routeToSelect);

            // This call should be ignored.
            // The onSessionInfoChanged() shouldn't be called.
            controller.selectRoute(routeToSelect);
            assertFalse(onControllerUpdatedLatch.await(WAIT_MS, TimeUnit.MILLISECONDS));

            // onStop should be called.
            assertTrue(onStopLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
        } finally {
            releaseControllers(controllers);
            mRouter2.unregisterRouteCallback(routeCallback);
            mRouter2.unregisterControllerCallback(controllerCallback);
            mRouter2.unregisterTransferCallback(transferCallback);
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaRouter2Test.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.media.cts.MediaRouter2Test"	"testRoutingControllerRelease"	"CtsMediaTestCases"	"1: system"	"public void testRoutingControllerRelease() throws Exception {
        final List<String> sampleRouteType = new ArrayList<>();
        sampleRouteType.add(FEATURE_SAMPLE);

        Map<String, MediaRoute2Info> routes = waitAndGetRoutes(sampleRouteType);
        MediaRoute2Info routeTransferFrom = routes.get(ROUTE_ID1);
        assertNotNull(routeTransferFrom);

        final CountDownLatch onTransferLatch = new CountDownLatch(1);
        final CountDownLatch onControllerUpdatedLatch = new CountDownLatch(1);
        final CountDownLatch onStopLatch = new CountDownLatch(1);
        final List<RoutingController> controllers = new ArrayList<>();

        TransferCallback transferCallback = new TransferCallback() {
            @Override
            public void onTransfer(RoutingController oldController,
                    RoutingController newController) {
                assertEquals(mRouter2.getSystemController(), oldController);
                assertTrue(getOriginalRouteIds(newController.getSelectedRoutes()).contains(
                        ROUTE_ID1));
                controllers.add(newController);
                onTransferLatch.countDown();
            }
            @Override
            public void onStop(RoutingController controller) {
                if (onTransferLatch.getCount() != 0
                        || !TextUtils.equals(
                                controllers.get(0).getId(), controller.getId())) {
                    return;
                }
                onStopLatch.countDown();
            }
        };

        ControllerCallback controllerCallback = new ControllerCallback() {
            @Override
            public void onControllerUpdated(RoutingController controller) {
                if (onTransferLatch.getCount() != 0
                        || !TextUtils.equals(controllers.get(0).getId(), controller.getId())) {
                    return;
                }
                onControllerUpdatedLatch.countDown();
            }
        };

       // TODO: Remove this once the MediaRouter2 becomes always connected to the service.
        RouteCallback routeCallback = new RouteCallback() {};
        mRouter2.registerRouteCallback(mExecutor, routeCallback, EMPTY_DISCOVERY_PREFERENCE);

        try {
            mRouter2.registerTransferCallback(mExecutor, transferCallback);
            mRouter2.registerControllerCallback(mExecutor, controllerCallback);
            mRouter2.transferTo(routeTransferFrom);
            assertTrue(onTransferLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));

            assertEquals(1, controllers.size());
            RoutingController controller = controllers.get(0);

            // Release controller. Future calls should be ignored.
            controller.release();

            // Select ROUTE_ID5_TO_TRANSFER_TO
            MediaRoute2Info routeToSelect = routes.get(ROUTE_ID4_TO_SELECT_AND_DESELECT);
            assertNotNull(routeToSelect);

            // This call should be ignored.
            // The onSessionInfoChanged() shouldn't be called.
            controller.selectRoute(routeToSelect);
            assertFalse(onControllerUpdatedLatch.await(WAIT_MS, TimeUnit.MILLISECONDS));

            // onStop should be called.
            assertTrue(onStopLatch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
        } finally {
            releaseControllers(controllers);
            mRouter2.unregisterRouteCallback(routeCallback);
            mRouter2.unregisterControllerCallback(controllerCallback);
            mRouter2.unregisterTransferCallback(transferCallback);
        }
    }

    // TODO: Consider adding tests with bluetooth connection/disconnection."	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaRouter2Test.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.media.cts.MediaRouter2Test"	"testGetSystemController"	"CtsMediaTestCases"	"1: system"	"public void testGetSystemController() {
        final RoutingController systemController = mRouter2.getSystemController();
        assertNotNull(systemController);
        assertFalse(systemController.isReleased());

        for (MediaRoute2Info route : systemController.getSelectedRoutes()) {
            assertTrue(route.isSystemRoute());
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaRouter2Test.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.media.cts.MediaRouter2Test"	"testGetControllers"	"CtsMediaTestCases"	"1: system"	"public void testGetControllers() {
        List<RoutingController> controllers = mRouter2.getControllers();
        assertNotNull(controllers);
        assertFalse(controllers.isEmpty());
        assertSame(mRouter2.getSystemController(), controllers.get(0));
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaRouter2Test.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.media.cts.MediaRouter2Test"	"testGetController"	"CtsMediaTestCases"	"1: system"	"public void testGetController() {
        String systemControllerId = mRouter2.getSystemController().getId();
        RoutingController controllerById = mRouter2.getController(systemControllerId);
        assertNotNull(controllerById);
        assertEquals(systemControllerId, controllerById.getId());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaRouter2Test.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.media.cts.MediaRouter2Test"	"testVolumeHandlingWhenVolumeFixed"	"CtsMediaTestCases"	"1: system"	"public void testVolumeHandlingWhenVolumeFixed() {
        if (!mAudioManager.isVolumeFixed()) {
            return;
        }
        MediaRoute2Info selectedSystemRoute =
                mRouter2.getSystemController().getSelectedRoutes().get(0);
        assertEquals(MediaRoute2Info.PLAYBACK_VOLUME_FIXED,
                selectedSystemRoute.getVolumeHandling());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaRouter2Test.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.media.cts.MediaRouter2Test"	"testCallbacksAreCalledWhenVolumeChanged"	"CtsMediaTestCases"	"1: system"	"public void testCallbacksAreCalledWhenVolumeChanged() throws Exception {
        if (mAudioManager.isVolumeFixed()) {
            return;
        }

        final int maxVolume = mAudioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC);
        final int minVolume = mAudioManager.getStreamMinVolume(AudioManager.STREAM_MUSIC);
        final int originalVolume = mAudioManager.getStreamVolume(AudioManager.STREAM_MUSIC);

        MediaRoute2Info selectedSystemRoute =
                mRouter2.getSystemController().getSelectedRoutes().get(0);

        assertEquals(maxVolume, selectedSystemRoute.getVolumeMax());
        assertEquals(originalVolume, selectedSystemRoute.getVolume());
        assertEquals(PLAYBACK_VOLUME_VARIABLE,
                selectedSystemRoute.getVolumeHandling());

        final int targetVolume = originalVolume == minVolume
                ? originalVolume + 1 : originalVolume - 1;
        final CountDownLatch latch = new CountDownLatch(1);
        RouteCallback routeCallback = new RouteCallback() {
            @Override
            public void onRoutesChanged(List<MediaRoute2Info> routes) {
                for (MediaRoute2Info route : routes) {
                    if (route.getId().equals(selectedSystemRoute.getId())
                            && route.getVolume() == targetVolume) {
                        latch.countDown();
                        break;
                    }
                }
            }
        };

        mRouter2.registerRouteCallback(mExecutor, routeCallback, LIVE_AUDIO_DISCOVERY_PREFERENCE);

        try {
            mAudioManager.setStreamVolume(AudioManager.STREAM_MUSIC, targetVolume, 0);
            assertTrue(latch.await(TIMEOUT_MS, TimeUnit.MILLISECONDS));
        } finally {
            mRouter2.unregisterRouteCallback(routeCallback);
            mAudioManager.setStreamVolume(AudioManager.STREAM_MUSIC, originalVolume, 0);
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaRouter2Test.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.media.cts.MediaRouter2Test"	"testGettingSystemMediaRouter2WithoutPermissionThrowsSecurityException"	"CtsMediaTestCases"	"1: system"	"public void testGettingSystemMediaRouter2WithoutPermissionThrowsSecurityException() {
        // Make sure that the permission is not given.
        assertNotEquals(PackageManager.PERMISSION_GRANTED,
                mContext.checkSelfPermission(Manifest.permission.MEDIA_CONTENT_CONTROL));

        assertThrows(SecurityException.class,
                () -> MediaRouter2.getInstance(mContext, mContext.getPackageName()));
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/MediaRouter2Test.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.verifier.bluetooth.BleCocClientTestBaseActivity"	"setPassFailButtonClickListeners"	""	"1: ui"	"public void test/*
 *.
 */

package com.android.cts.verifier.bluetooth;

import android.app.AlertDialog;
import android.app.Dialog;
import android.app.ProgressDialog;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothManager;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.os.Handler;
import android.widget.ListView;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import java.util.ArrayList;
import java.util.List;
import android.util.Log;

public class BleCocClientTestBaseActivity extends PassFailButtons.Activity {
    public static final String TAG = ""BleCocClientTestBase"";

    private static final boolean STEP_EXECUTION = false;

    private final int TEST_BLE_LE_CONNECTED = 0;
    private final int TEST_BLE_GOT_PSM = 1;
    private final int TEST_BLE_COC_CONNECTED = 2;
    private final int TEST_BLE_CONNECTION_TYPE_CHECKED = 3;
    private final int TEST_BLE_DATA_8BYTES_SENT = 4;
    private final int TEST_BLE_DATA_8BYTES_READ = 5;
    private final int TEST_BLE_DATA_EXCHANGED = 6;
    private final int TEST_BLE_CLIENT_DISCONNECTED = 7;
    private static final int PASS_FLAG_ALL = 0x00FF;

    private TestAdapter mTestAdapter;
    private long mPassed;
    private Dialog mDialog;
    private Handler mHandler;

    private static final long BT_ON_DELAY = 10000;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.ble_server_start);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);

        mTestAdapter = new TestAdapter(this, setupTestList());
        ListView listView = (ListView) findViewById(R.id.ble_server_tests);
        listView.setAdapter(mTestAdapter);

        mPassed = 0;
        mHandler = new Handler();
    }

    @Override
    public void onResume() {
        super.onResume();

        IntentFilter filter = new IntentFilter();

        filter.addAction(BleCocClientService.BLE_LE_CONNECTED);
        filter.addAction(BleCocClientService.BLE_GOT_PSM);
        filter.addAction(BleCocClientService.BLE_COC_CONNECTED);
        filter.addAction(BleCocClientService.BLE_CONNECTION_TYPE_CHECKED);
        filter.addAction(BleCocClientService.BLE_DATA_8BYTES_SENT);
        filter.addAction(BleCocClientService.BLE_DATA_8BYTES_READ);
        filter.addAction(BleCocClientService.BLE_DATA_LARGEBUF_READ);
        filter.addAction(BleCocClientService.BLE_LE_DISCONNECTED);

        filter.addAction(BleCocClientService.BLE_BLUETOOTH_DISCONNECTED);
        filter.addAction(BleCocClientService.BLE_BLUETOOTH_DISABLED);
        filter.addAction(BleCocClientService.BLE_BLUETOOTH_MISMATCH_SECURE);
        filter.addAction(BleCocClientService.BLE_BLUETOOTH_MISMATCH_INSECURE);
        filter.addAction(BleCocClientService.BLE_CLIENT_ERROR);

        registerReceiver(mBroadcast, filter);
    }

    @Override
    public void onPause() {
        super.onPause();
        closeDialog();
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        unregisterReceiver(mBroadcast);
        closeDialog();
    }

    private synchronized void closeDialog() {
        if (mDialog != null) {
            mDialog.dismiss();
            mDialog = null;
        }
    }

    private synchronized void showProgressDialog() {
        closeDialog();

        ProgressDialog dialog = new ProgressDialog(this);
        dialog.setTitle(R.string.ble_test_running);
        dialog.setProgressStyle(ProgressDialog.STYLE_SPINNER);
        dialog.setMessage(getString(R.string.ble_test_running_message));
        dialog.setCanceledOnTouchOutside(false);
        mDialog = dialog;
        mDialog.show();
    }

    private List<Integer> setupTestList() {
        ArrayList<Integer> testList = new ArrayList<Integer>();
        testList.add(R.string.ble_coc_client_le_connect);
        testList.add(R.string.ble_coc_client_get_psm);
        testList.add(R.string.ble_coc_client_coc_connect);
        testList.add(R.string.ble_coc_client_check_connection_type);
        testList.add(R.string.ble_coc_client_send_data_8bytes);
        testList.add(R.string.ble_coc_client_receive_data_8bytes);
        testList.add(R.string.ble_coc_client_data_exchange);
        testList.add(R.string.ble_client_disconnect_name);
        return testList;
    }

    private void showErrorDialog(int titleId, int messageId, boolean finish) {
        AlertDialog.Builder builder = new AlertDialog.Builder(this)
                .setTitle(titleId)
                .setMessage(messageId);
        if (finish) {
            builder.setOnCancelListener(new Dialog.OnCancelListener() {
                @Override
                public void onCancel(DialogInterface dialog) {
                    finish();
                }
            });
        }
        builder.create().show();
    }

    private BroadcastReceiver mBroadcast = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            boolean showProgressDialog = false;
            closeDialog();

            String action = intent.getAction();
            String newAction = null;
            String actionName = null;
            long previousPassed = mPassed;
            final Intent startIntent = new Intent(BleCocClientTestBaseActivity.this, BleCocClientService.class);
            if (action != null) {
                Log.d(TAG, ""Processing "" + action);
            }
            switch (action) {
            case BleCocClientService.BLE_LE_CONNECTED:
                actionName = getString(R.string.ble_coc_client_le_connect);
                mTestAdapter.setTestPass(TEST_BLE_LE_CONNECTED);
                mPassed |= (1 << TEST_BLE_LE_CONNECTED);
                // Start LE Service Discovery and then read the PSM
                newAction = BleCocClientService.BLE_COC_CLIENT_ACTION_GET_PSM;
                break;

            case BleCocClientService.BLE_GOT_PSM:
                actionName = getString(R.string.ble_coc_client_get_psm);
                mTestAdapter.setTestPass(TEST_BLE_GOT_PSM);
                mPassed |= (1 << TEST_BLE_GOT_PSM);
                // Connect the LE CoC
                newAction = BleCocClientService.BLE_COC_CLIENT_ACTION_COC_CLIENT_CONNECT;
                break;

            case BleCocClientService.BLE_COC_CONNECTED:
                actionName = getString(R.string.ble_coc_client_coc_connect);
                mTestAdapter.setTestPass(TEST_BLE_COC_CONNECTED);
                mPassed |= (1 << TEST_BLE_COC_CONNECTED);
                // Check the connection type
                newAction = BleCocClientService.BLE_COC_CLIENT_ACTION_CHECK_CONNECTION_TYPE;
                break;

            case BleCocClientService.BLE_CONNECTION_TYPE_CHECKED:
                actionName = getString(R.string.ble_coc_client_check_connection_type);
                mTestAdapter.setTestPass(TEST_BLE_CONNECTION_TYPE_CHECKED);
                mPassed |= (1 << TEST_BLE_CONNECTION_TYPE_CHECKED);
                // Send 8 bytes
                newAction = BleCocClientService.BLE_COC_CLIENT_ACTION_SEND_DATA_8BYTES;
                break;

            case BleCocClientService.BLE_DATA_8BYTES_SENT:
                actionName = getString(R.string.ble_coc_client_send_data_8bytes);
                mTestAdapter.setTestPass(TEST_BLE_DATA_8BYTES_SENT);
                mPassed |= (1 << TEST_BLE_DATA_8BYTES_SENT);
                // Read 8 bytes
                newAction = BleCocClientService.BLE_COC_CLIENT_ACTION_READ_DATA_8BYTES;
                break;

            case BleCocClientService.BLE_DATA_8BYTES_READ:
                actionName = getString(R.string.ble_coc_client_receive_data_8bytes);
                mTestAdapter.setTestPass(TEST_BLE_DATA_8BYTES_READ);
                mPassed |= (1 << TEST_BLE_DATA_8BYTES_READ);
                // Do data exchanges
                newAction = BleCocClientService.BLE_COC_CLIENT_ACTION_EXCHANGE_DATA;
                break;

            case BleCocClientService.BLE_DATA_LARGEBUF_READ:
                actionName = getString(R.string.ble_coc_client_data_exchange);
                mTestAdapter.setTestPass(TEST_BLE_DATA_EXCHANGED);
                mPassed |= (1 << TEST_BLE_DATA_EXCHANGED);
                // Disconnect
                newAction = BleCocClientService.BLE_CLIENT_ACTION_CLIENT_DISCONNECT;
                break;

            case BleCocClientService.BLE_BLUETOOTH_DISCONNECTED:
                mTestAdapter.setTestPass(TEST_BLE_CLIENT_DISCONNECTED);
                mPassed |= (1 << TEST_BLE_CLIENT_DISCONNECTED);
                // all tests done
                newAction = null;
                break;

            case BleCocClientService.BLE_BLUETOOTH_DISABLED:
                showErrorDialog(R.string.ble_bluetooth_disable_title, R.string.ble_bluetooth_disable_message, true);
                break;

            case BleCocClientService.BLE_BLUETOOTH_MISMATCH_SECURE:
                showErrorDialog(R.string.ble_bluetooth_mismatch_title, R.string.ble_bluetooth_mismatch_secure_message, true);
                break;

            case BleCocClientService.BLE_BLUETOOTH_MISMATCH_INSECURE:
                showErrorDialog(R.string.ble_bluetooth_mismatch_title, R.string.ble_bluetooth_mismatch_insecure_message, true);
                break;

            default:
                Log.e(TAG, ""onReceive: Error: unhandled action="" + action);
            }

            if (previousPassed != mPassed) {
                String logMessage = String.format(""Passed Flags has changed from 0x%08X to 0x%08X. Delta=0x%08X"",
                                                  previousPassed, mPassed, mPassed ^ previousPassed);
                Log.d(TAG, logMessage);
            }

            mTestAdapter.notifyDataSetChanged();

            if (newAction != null) {
                Log.d(TAG, ""Starting "" + newAction);
                startIntent.setAction(newAction);
                if (STEP_EXECUTION) {
                    closeDialog();
                    final boolean showProgressDialogValue = showProgressDialog;
                    mDialog = new AlertDialog.Builder(BleCocClientTestBaseActivity.this)
                            .setTitle(actionName)
                            .setMessage(R.string.ble_test_finished)
                            .setCancelable(false)
                            .setPositiveButton(R.string.ble_test_next,
                                    new DialogInterface.OnClickListener() {
                                        @Override
                                        public void onClick(DialogInterface dialog, int which) {
                                            closeDialog();
                                            if (showProgressDialogValue) {
                                                showProgressDialog();
                                            }
                                            startService(startIntent);
                                        }
                                    })
                            .show();
                } else {
                    if (showProgressDialog) {
                        showProgressDialog();
                    }
                    startService(startIntent);
                }
            } else {
                closeDialog();
            }

            if (mPassed == PASS_FLAG_ALL) {
                Log.d(TAG, ""All Tests Passed."");
                getPassButton().setEnabled(true);
            }
        }
    };
}"	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/bluetooth/BleCocClientTestBaseActivity.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.autofillservice.cts.unittests.AutofillManagerTest"	"testHasEnabledAutofillServices"	"CtsAutoFillServiceTestCases"	"2: ui system"	"@AppModeFull(reason = ""Package cannot install in instant app mode"")
    public void testHasEnabledAutofillServices() throws Exception {
        // Verify the calling application's AutofillService is initially disabled
        runQueryAutofillStatusActivityAndVerifyResult(AUTOFILL_DISABLE);

        // Enable calling application's AutofillService
        enableOutsidePackageTestAutofillService();

        // Verify the calling application's AutofillService is enabled
        runQueryAutofillStatusActivityAndVerifyResult(AUTOFILL_ENABLE);

        // Update the calling application package and verify the calling application's
        // AutofillService is still enabled
        install(OUTSIDE_QUERYAUTOFILLSTATUS_APK);
        runQueryAutofillStatusActivityAndVerifyResult(AUTOFILL_ENABLE);
    }

    private void enableOutsidePackageTestAutofillService() {
        final String outsidePackageAutofillServiceName =
                ""android.autofill.cts2/.NoOpAutofillService"";
        Helper.enableAutofillService(sContext, outsidePackageAutofillServiceName);
    }

    private void install(String apk) {
        final String installResult = runShellCommand(
                ""pm install -r /data/local/tmp/cts/autofill/"" + apk);
        Log.d(TAG, ""install result = "" + installResult);
        assertThat(installResult.trim()).isEqualTo(""Success"");
    }

    /**
     * Start an activity that uses hasEnabledAutofillServices() to query its AutofillService
     * status and return the status result to the caller. Then we verify the status result from
     * the Activity.
     */
    private void runQueryAutofillStatusActivityAndVerifyResult(int expectedStatus) {
        final String actionAutofillStatusActivityFinish =
                ""ACTION_AUTOFILL_STATUS_ACTIVITY_FINISH_"" + SystemClock.uptimeMillis();

        // register a activity finish receiver
        final BlockingBroadcastReceiver receiver = new BlockingBroadcastReceiver(sContext,
                actionAutofillStatusActivityFinish);
        receiver.register();

        // Start an Activity from another package
        final Intent outsideActivity = new Intent();
        outsideActivity.setComponent(new ComponentName(""android.autofill.cts2"",
                ""android.autofill.cts2.QueryAutofillStatusActivity""));
        outsideActivity.setFlags(FLAG_ACTIVITY_NEW_TASK);
        final Intent broadcastIntent = new Intent(actionAutofillStatusActivityFinish);
        final PendingIntent pendingIntent = PendingIntent.getBroadcast(sContext, 0, broadcastIntent,
                PendingIntent.FLAG_IMMUTABLE);
        outsideActivity.putExtra(""finishBroadcast"", pendingIntent);
        sContext.startActivity(outsideActivity);

        // Verify the finish broadcast is received.
        final Intent intent = receiver.awaitForBroadcast();
        assertThat(intent).isNotNull();
        // Verify the status result code.
        final int statusResultCode = receiver.getResultCode();
        Log.d(TAG, ""hasEnabledAutofillServices statusResultCode = "" + statusResultCode);
        assertThat(statusResultCode).isEqualTo(expectedStatus);

        // unregister receiver
        receiver.unregisterQuietly();
    }
}"	"/home/gpoor/cts-12-source/cts/tests/autofillservice/src/android/autofillservice/cts/unittests/AutofillManagerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.devicepolicy.MixedManagedProfileOwnerTestApi25"	"removeTestUsers"	"CtsDevicePolicyManagerTestCases"	"2: ui user"	"/*
 *.
 */

package com.android.cts.devicepolicy;

import static com.android.cts.devicepolicy.DeviceAdminFeaturesCheckerRule.FEATURE_MANAGED_USERS;

import com.android.cts.devicepolicy.DeviceAdminFeaturesCheckerRule.RequiresAdditionalFeatures;
import com.android.cts.devicepolicy.annotations.PermissionsTest;

import org.junit.Test;

/**
 * Set of tests for managed profile owner use cases that also apply to device owners.
 * Tests that should be run identically in both cases are added in DeviceAndProfileOwnerTestApi25.
 */
// We need managed users to be supported in order to create a profile of the user owner.
@RequiresAdditionalFeatures({FEATURE_MANAGED_USERS})
public class MixedManagedProfileOwnerTestApi25 extends DeviceAndProfileOwnerTestApi25 {
    private int mParentUserId = -1;

    @Override
    public void setUp() throws Exception {
        super.setUp();

        removeTestUsers();
        mParentUserId = mPrimaryUserId;
        createManagedProfile();
    }

    private void createManagedProfile() throws Exception {
        mUserId = createManagedProfile(mParentUserId);
        switchUser(mParentUserId);
        startUserAndWait(mUserId);

        installAppAsUser(DEVICE_ADMIN_APK, mUserId);
        setProfileOwnerOrFail(DEVICE_ADMIN_PKG + ""/"" + ADMIN_RECEIVER_TEST_CLASS, mUserId);
        startUserAndWait(mUserId);
    }

    @Override
    public void tearDown() throws Exception {
        removeUser(mUserId);

        super.tearDown();
    }

    @Override
    @PermissionsTest"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/MixedManagedProfileOwnerTestApi25.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.location.cts.gnss.asn1.supl2.rrlp_components.SeqOfGANSSSatelliteElement"	"isTagImplicit"	"CtsLocationGnssTestCases"	"1: ui"	"public void test/*
 *.
 */

package android.location.cts.asn1.supl2.rrlp_components;

/*
 */


//
//
import android.location.cts.asn1.base.Asn1Null;
import android.location.cts.asn1.base.Asn1SequenceOf;
import android.location.cts.asn1.base.Asn1Tag;
import android.location.cts.asn1.base.BitStream;
import android.location.cts.asn1.base.BitStreamReader;
import com.google.common.collect.ImmutableList;
import java.util.Collection;
import javax.annotation.Nullable;


/**
 */
public  class SeqOfGANSSSatelliteElement
    extends Asn1SequenceOf<GANSSSatelliteElement> {
  //

  private static final Asn1Tag TAG_SeqOfGANSSSatelliteElement
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public SeqOfGANSSSatelliteElement() {
    super();
    setMinSize(1);
setMaxSize(32);

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_SeqOfGANSSSatelliteElement;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_SeqOfGANSSSatelliteElement != null) {
      return ImmutableList.of(TAG_SeqOfGANSSSatelliteElement);
    } else {
      return Asn1SequenceOf.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new SeqOfGANSSSatelliteElement from encoded stream.
   */
  public static SeqOfGANSSSatelliteElement fromPerUnaligned(byte[] encodedBytes) {
    SeqOfGANSSSatelliteElement result = new SeqOfGANSSSatelliteElement();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new SeqOfGANSSSatelliteElement from encoded stream.
   */
  public static SeqOfGANSSSatelliteElement fromPerAligned(byte[] encodedBytes) {
    SeqOfGANSSSatelliteElement result = new SeqOfGANSSSatelliteElement();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  
  @Override public GANSSSatelliteElement createAndAddValue() {
    GANSSSatelliteElement value = new GANSSSatelliteElement();
    add(value);
    return value;
  }

  

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    StringBuilder builder = new StringBuilder();
    builder.append(""SeqOfGANSSSatelliteElement = [\n"");
    final String internalIndent = indent + ""  "";
    for (GANSSSatelliteElement value : getValues()) {
      builder.append(internalIndent)
          .append(value.toIndentedString(internalIndent));
    }
    builder.append(indent).append(""];\n"");
    return builder.toString();
  }
}"	"/home/gpoor/cts-12-source/cts/tests/location/location_gnss/src/android/location/cts/gnss/asn1/supl2/rrlp_components/SeqOfGANSSSatelliteElement.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.renderscript.cts.refocus.RefocusFilter"	"finish"	"CtsRenderscriptTestCases"	"1: ui"	"public void test/*
 *.
 */

package android.renderscript.cts.refocus;

import android.graphics.Bitmap;
import android.renderscript.RenderScript;
import android.util.Log;

/**
 * An abstract class that implements refocus filtering using Render Script. The
 * main function is {@code compute}. All other functions and data structures are
 * supporting this main function. Subclasses need to implement individual steps
 * based on pixel representation, e.g., uint8 or float32.
 *
 * @param <ScriptType> pixel representation, which can be float of byte.
 *
 */
public abstract class RefocusFilter<ScriptType> {
  //private static final Log.Tag TAG = new Log.Tag(""RefocusFilter"");
  protected static final String TAG = ""RefocusFilter"";
  // Render Script context.
  protected RenderScript renderScript;

  // Script functions in .rs file.
  protected ScriptType scriptC;

  /*
   * A constructor that initializes the class.
   *
   * @param rs the Render Script context.
   */
  public RefocusFilter(RenderScript rs) {
    renderScript = rs;
  }

  /*
   * A function that implements refocus filtering using Render Script.
   *
   * @param inputImage an RGBD image. RGB channels of the input image form the
   * color image. The D channel has a range of [1,BlurStack.MAX_DEPTH], where 0
   * is reserved for invalid padded pixels. Depth here refers to inverse depth
   * (i.e., disparity), where larger depths are closer to the camera.
   *
   * @param blurStack an object that has all the parameters for refocus
   * filtering, including: the number of blending layers, the depth levels in
   * each blending layer, focal depth, etc. For details, please refer to the
   * definition of {@code BlurStack}.
   *
   * @return a {@code Bitmap} of the filtering result
   */
  /*
    Commented out for now to define in derived classes
    so that images after each stage could be extracted
   */
  protected Bitmap compute(Bitmap inputImage, BlurStack blurStack) {

    // Initializes {@code scriptC} and allocates required memory buffers
    // (defined in subclasses) that interface between Java and Render Script.
    initializeScriptAndBuffers(inputImage,
        blurStack.getLayerInfo(blurStack.getFocusLayer()));

    // Processes layers from back-most to focal depth (including the focal
    // depth).
    if (!processLayersFromBackToFocus(blurStack)) {
      return null;
    }

    // Processes layers from front-most to focal depth (excluding the focal
    // depth).
    if (!processLayersFromFrontToFocus(blurStack)) {
      return null;
    }

    // Extracts the result from .rs file to Java.
    Bitmap resultImage = extractResultImage();
    renderScript.finish();

    Log.d(TAG, ""filterAndBlendAllLayersUsingKernel is finished"");
    return resultImage;
  }

  /*
   * Process layers from back-most to focal depth (including the focal depth).
   */
  protected boolean processLayersFromBackToFocus(BlurStack blurStack) {
    for (int targetLayer = blurStack.getNumLayers() - 1;
        targetLayer >= blurStack.getFocusLayer(); --targetLayer) {
      // Sets up target layer info in Render Script.
      LayerInfo layerInfo = blurStack.getLayerInfo(targetLayer);
      setTargetLayer(layerInfo);

      // For a layer that is behind the focal depth, its back depth has the
      // largest blur kernel radius. Uses the kernel radius as dilation radius
      // of this layer.
      int dilationRadius = getKernelRadius(layerInfo.backDepth, blurStack);
      setBlendInfo(dilationRadius);

      // Sends blur kernel matrix data to Render Script.
      setKernelData(targetLayer, blurStack);

      // Marks active pixels (pixels that on this layer).
      // Marks pixels that are close enough (within dilationRadius) to the
      // active pixels.
      // Computes distance transform of the active pixels in their neighborhood
      // and use the distance value as matte for layer blending later.
      computeLayerMatteBehindFocalDepth();

      // Computes filtering for pixels on the target layer and saves the
      // filtering result in a buffer {@code g_fuzzy_image} in .rs file.
      filterLayerBehindFocalDepth();

      // Replaces active pixels in {@code g_sharp_image} with the filtering
      // result saved in {@code g_fuzzy_image}. The replacement is soft,
      // blending {@code g_sharp_image} and {@code g_fuzzy_image} using the
      // computed matte. Uses the blending result as the sharp input image for
      // the next iteration.
      updateSharpImageUsingFuzzyImage();
    }
    return true;
  }

  /*
   * Processes layers from front-most to focal depth (excluding the focal depth)
   */
  protected boolean processLayersFromFrontToFocus(BlurStack blurStack) {
    // At this point, the input image {@code g_sharp_image} has been updated by
    // the first pass from back-most layer to focus layer {@code
    // processLayersFromBackToFocus}.
    for (int targetLayer = 0; targetLayer < blurStack.getFocusLayer();
        ++targetLayer) {
      // Sets up target layer info in Render Script.
      LayerInfo layerInfo = blurStack.getLayerInfo(targetLayer);
      setTargetLayer(layerInfo);

      // For a layer that is in front of the focal depth, its front depth has
      // the largest blur kernel radius. Uses the kernel radius as dilation
      // radius of this layer.
      int dilationRadius = getKernelRadius(layerInfo.frontDepth, blurStack);
      setBlendInfo(dilationRadius);

      // Sends blur kernel matrix data to Render Script.
      setKernelData(targetLayer, blurStack);

      // Marks active pixels (pixels that on this layer).
      // Marks pixels that are close enough (within dilationRadius) to the
      // active pixels.
      // Computes distance transform of the active pixels in their neighborhood
      // and use the distance value as matte for layer blending later.
      computeLayerMatteInFrontOfFocalDepth();

      // Computes filtering for pixels on the target layer and accumulates the
      // filtering result to an buffer {@code g_fuzzy_image} in .rs file.
      // The accumulating operation is soft, using the computed matte values.
      filterLayerInFrontOfFocalDepth();
    }

    // Fills in the pixels on or behind the focal depth in {@code g_fuzzy_image}
    // using pixels in {@code g_sharp_image}. Does the filling in a soft way by
    // blending using the matte. Uses the blending result (saved in {@code
    // g_fuzzy_image}) as the final output image.
    finalizeFuzzyImageUsingSharpImage();
    return true;
  }

  private static int getKernelRadius(int depth, BlurStack blurStack) {
    int kernelRadius = KernelDataForRenderScript
        .computeKernelRadiusFromDiskRadius(blurStack.getDiskRadius(depth));
    return kernelRadius;
  }

  // ///////////////////////////////////////////////////////////////////////////
  //
  // The following abstract functions must be implemented in a subclass.
  //
  // ///////////////////////////////////////////////////////////////////////////

  // Initializes the member {@code scriptC} and allocate memory buffers (defined
  // in a subclass) that interface between Java and .rs file.
  protected abstract void initializeScriptAndBuffers(Bitmap inputImage,
      LayerInfo focalLayer);

  // Extracts the result image from memory buffer.
  protected abstract Bitmap extractResultImage();

  // Sets target layer info in .rs file.
  protected abstract void setTargetLayer(LayerInfo layerInfo);

  // Sets dilation radius in .rs file for blending target layer.
  protected abstract void setBlendInfo(int dilationRadius);

  /*
   * A function that prepares the blur kernels for the target layer and passes
   * them to the Render Script. Each depth value in the layer has a kernel. The
   * kernels are packed in a memory buffer. Auxiliary information for parsing
   * the memory buffer is also prepared and passed to Render Script.
   *
   * @param targetLayer the index of a target layer
   *
   * @param blurStack a BlurStack object that has the layer structure of the
   * refocus filter task in Java
   */
  protected abstract void setKernelData(int targetLayer, BlurStack blurStack);

  protected abstract void computeLayerMatteBehindFocalDepth();

  protected abstract void filterLayerBehindFocalDepth();

  protected abstract void updateSharpImageUsingFuzzyImage();

  protected abstract void computeLayerMatteInFrontOfFocalDepth();

  protected abstract void filterLayerInFrontOfFocalDepth();

  protected abstract void finalizeFuzzyImageUsingSharpImage();
}"	"/home/gpoor/cts-12-source/cts/tests/tests/renderscript/src/android/renderscript/cts/refocus/RefocusFilter.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.deviceidle.DeviceIdleWhitelistTest"	"getSystemWhitelist"	"CtsDeviceIdleHostTestCases"	"2: apps system"	"/*
 *.
 */

package com.android.cts.deviceidle;

import static org.junit.Assert.*;

import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.log.LogUtil;
import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;
import com.android.tradefed.testtype.junit4.BaseHostJUnit4Test;

import org.junit.After;
import org.junit.Assume;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.ArrayList;
import java.util.List;

/**
 * Tests that it is possible to remove apps from the system whitelist
 */
@RunWith(DeviceJUnit4ClassRunner.class)
public class DeviceIdleWhitelistTest extends BaseHostJUnit4Test {

    private static final String DEVICE_IDLE_COMMAND_PREFIX = ""cmd deviceidle sys-whitelist "";
    private static final String RESET_SYS_WHITELIST_COMMAND = ""cmd deviceidle sys-whitelist reset"";
    private static final String SHOW_SYS_WHITELIST_COMMAND = DEVICE_IDLE_COMMAND_PREFIX;

    private List<String> mOriginalSystemWhitelist;

    @Before
    public void setUp() throws Exception {
        getDevice().executeShellCommand(RESET_SYS_WHITELIST_COMMAND);
        mOriginalSystemWhitelist = getSystemWhitelist();
        if (mOriginalSystemWhitelist.size() < 1) {
            LogUtil.CLog.w(""No packages found in system whitelist"");
            Assume.assumeTrue(false);
        }
    }

    @After
    public void tearDown() throws Exception {
        getDevice().executeShellCommand(RESET_SYS_WHITELIST_COMMAND);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/deviceidle/src/com/android/cts/deviceidle/DeviceIdleWhitelistTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.deviceidle.DeviceIdleWhitelistTest"	"testRemoveFromSysWhitelist"	"CtsDeviceIdleHostTestCases"	"1: system"	"public void testRemoveFromSysWhitelist() throws Exception {
        final String packageToRemove = mOriginalSystemWhitelist.get(0);
        getDevice().executeShellCommand(DEVICE_IDLE_COMMAND_PREFIX + ""-"" + packageToRemove);
        final List<String> newWhitelist = getSystemWhitelist();
        assertFalse(""Package "" + packageToRemove + "" not removed from whitelist"",
                newWhitelist.contains(packageToRemove));
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/deviceidle/src/com/android/cts/deviceidle/DeviceIdleWhitelistTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.deviceidle.DeviceIdleWhitelistTest"	"testRemovesPersistedAcrossReboots"	"CtsDeviceIdleHostTestCases"	"1: system"	"public void testRemovesPersistedAcrossReboots() throws Exception {
        for (int i = 0; i < mOriginalSystemWhitelist.size(); i+=2) {
            // remove odd indexed packages from the whitelist
            getDevice().executeShellCommand(
                    DEVICE_IDLE_COMMAND_PREFIX + ""-"" + mOriginalSystemWhitelist.get(i));
        }
        final List<String> whitelistBeforeReboot = getSystemWhitelist();
        Thread.sleep(10_000); // write to disk happens after 5 seconds
        getDevice().reboot();
        Thread.sleep(5_000); // to make sure service is initialized
        final List<String> whitelistAfterReboot = getSystemWhitelist();
        assertEquals(whitelistBeforeReboot.size(), whitelistAfterReboot.size());
        for (int i = 0; i < whitelistBeforeReboot.size(); i++) {
            assertTrue(whitelistAfterReboot.contains(whitelistBeforeReboot.get(i)));
        }
    }

    private List<String> getSystemWhitelist() throws DeviceNotAvailableException {
        final String output = getDevice().executeShellCommand(SHOW_SYS_WHITELIST_COMMAND).trim();
        final List<String> packages = new ArrayList<>();
        for (String line : output.split(""\n"")) {
            final int i = line.indexOf(',');
            if (i > 0) {
                packages.add(line.substring(0, i));
            }
        }
        return packages;
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/deviceidle/src/com/android/cts/deviceidle/DeviceIdleWhitelistTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.location.cts.gnss.asn1.supl2.ver2_ulp_components.SupportedWCDMAInfo"	"isTagImplicit"	"CtsLocationGnssTestCases"	"1: ui"	"public void test/*
 *.
 */

package android.location.cts.asn1.supl2.ver2_ulp_components;

/*
 */


//
//
import android.location.cts.asn1.base.Asn1Boolean;
import android.location.cts.asn1.base.Asn1Null;
import android.location.cts.asn1.base.Asn1Object;
import android.location.cts.asn1.base.Asn1Sequence;
import android.location.cts.asn1.base.Asn1Tag;
import android.location.cts.asn1.base.BitStream;
import android.location.cts.asn1.base.BitStreamReader;
import android.location.cts.asn1.base.SequenceComponent;
import com.google.common.collect.ImmutableList;
import java.util.Collection;
import javax.annotation.Nullable;


/**
*/
public  class SupportedWCDMAInfo extends Asn1Sequence {
  //

  private static final Asn1Tag TAG_SupportedWCDMAInfo
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public SupportedWCDMAInfo() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_SupportedWCDMAInfo;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_SupportedWCDMAInfo != null) {
      return ImmutableList.of(TAG_SupportedWCDMAInfo);
    } else {
      return Asn1Sequence.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new SupportedWCDMAInfo from encoded stream.
   */
  public static SupportedWCDMAInfo fromPerUnaligned(byte[] encodedBytes) {
    SupportedWCDMAInfo result = new SupportedWCDMAInfo();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new SupportedWCDMAInfo from encoded stream.
   */
  public static SupportedWCDMAInfo fromPerAligned(byte[] encodedBytes) {
    SupportedWCDMAInfo result = new SupportedWCDMAInfo();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }



  @Override protected boolean isExtensible() {
    return true;
  }

  @Override public boolean containsExtensionValues() {
    for (SequenceComponent extensionComponent : getExtensionComponents()) {
      if (extensionComponent.isExplicitlySet()) return true;
    }
    return false;
  }

  
  private SupportedWCDMAInfo.mRLType mRL_;
  public SupportedWCDMAInfo.mRLType getMRL() {
    return mRL_;
  }
  /**
   * @throws ClassCastException if value is not a SupportedWCDMAInfo.mRLType
   */
  public void setMRL(Asn1Object value) {
    this.mRL_ = (SupportedWCDMAInfo.mRLType) value;
  }
  public SupportedWCDMAInfo.mRLType setMRLToNewInstance() {
    mRL_ = new SupportedWCDMAInfo.mRLType();
    return mRL_;
  }
  

  

  

  @Override public Iterable<? extends SequenceComponent> getComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 0);

          @Override public boolean isExplicitlySet() {
            return getMRL() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getMRL();
          }

          @Override public void setToNewInstance() {
            setMRLToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SupportedWCDMAInfo.mRLType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""mRL : ""
                    + getMRL().toIndentedString(indent);
              }
        });
    
    return builder.build();
  }

  @Override public Iterable<? extends SequenceComponent>
                                                    getExtensionComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
      
      return builder.build();
    }

  
/*
 */


//

/**
 */
public static class mRLType extends Asn1Boolean {
  //

  private static final Asn1Tag TAG_mRLType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public mRLType() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_mRLType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_mRLType != null) {
      return ImmutableList.of(TAG_mRLType);
    } else {
      return Asn1Boolean.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new mRLType from encoded stream.
   */
  public static mRLType fromPerUnaligned(byte[] encodedBytes) {
    mRLType result = new mRLType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new mRLType from encoded stream.
   */
  public static mRLType fromPerAligned(byte[] encodedBytes) {
    mRLType result = new mRLType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""mRLType = "" + getValue() + "";\n"";
  }
}

  

    

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    StringBuilder builder = new StringBuilder();
    builder.append(""SupportedWCDMAInfo = {\n"");
    final String internalIndent = indent + ""  "";
    for (SequenceComponent component : getComponents()) {
      if (component.isExplicitlySet()) {
        builder.append(internalIndent)
            .append(component.toIndentedString(internalIndent));
      }
    }
    if (isExtensible()) {
      builder.append(internalIndent).append(""...\n"");
      for (SequenceComponent component : getExtensionComponents()) {
        if (component.isExplicitlySet()) {
          builder.append(internalIndent)
              .append(component.toIndentedString(internalIndent));
        }
      }
    }
    builder.append(indent).append(""};\n"");
    return builder.toString();
  }
}"	"/home/gpoor/cts-12-source/cts/tests/location/location_gnss/src/android/location/cts/gnss/asn1/supl2/ver2_ulp_components/SupportedWCDMAInfo.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.bluetooth.cts.HearingAidProfileTest"	"isBleSupported"	"CtsBluetoothTestCases"	"2: ui system"	"public void test/*
 *.
 */

package android.bluetooth.cts;

import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothHearingAid;
import android.bluetooth.BluetoothManager;
import android.bluetooth.BluetoothProfile;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.test.AndroidTestCase;
import android.test.suitebuilder.annotation.MediumTest;
import android.util.Log;

import java.io.IOException;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.TimeUnit;

/**
 * Unit test cases for {@link BluetoothHearingAid}.
 * <p>
 * To run the test, use adb shell am instrument -e class 'android.bluetooth.HearingAidProfileTest'
 * -w 'com.android.bluetooth.tests/android.bluetooth.BluetoothTestRunner'
 */
public class HearingAidProfileTest extends AndroidTestCase {
    private static final String TAG = ""HearingAidProfileTest"";

    private static final int WAIT_FOR_INTENT_TIMEOUT_MS = 10000; // ms to wait for intent callback
    private static final int PROXY_CONNECTION_TIMEOUT_MS = 500;  // ms timeout for Proxy Connect
    // ADAPTER_ENABLE_TIMEOUT_MS = AdapterState.BLE_START_TIMEOUT_DELAY +
    //                              AdapterState.BREDR_START_TIMEOUT_DELAY
    private static final int ADAPTER_ENABLE_TIMEOUT_MS = 8000;
    // ADAPTER_DISABLE_TIMEOUT_MS = AdapterState.BLE_STOP_TIMEOUT_DELAY +
    //                                  AdapterState.BREDR_STOP_TIMEOUT_DELAY
    private static final int ADAPTER_DISABLE_TIMEOUT_MS = 5000;

    private boolean mIsHearingAidSupported;
    private boolean mIsBleSupported;
    private BluetoothHearingAid mService;
    private BluetoothAdapter mBluetoothAdapter;
    private BroadcastReceiver mIntentReceiver;

    private Condition mConditionProfileIsConnected;
    private ReentrantLock mProfileConnectedlock;
    private boolean mIsProfileReady;

    private static List<Integer> mValidConnectionStates = new ArrayList<Integer>(
        Arrays.asList(BluetoothProfile.STATE_CONNECTING, BluetoothProfile.STATE_CONNECTED,
                      BluetoothProfile.STATE_DISCONNECTED, BluetoothProfile.STATE_DISCONNECTING));

    private List<BluetoothDevice> mIntentCallbackDeviceList;

    public void setUp() throws Exception {
        if (!isBleSupported()) return;
        mIsBleSupported = true;

        BluetoothManager manager = (BluetoothManager) mContext.getSystemService(
                Context.BLUETOOTH_SERVICE);
        mBluetoothAdapter = manager.getAdapter();

        if (!BTAdapterUtils.enableAdapter(mBluetoothAdapter, mContext)) {
            Log.e(TAG, ""Unable to enable Bluetooth Adapter!"");
            assertTrue(mBluetoothAdapter.isEnabled());
        }

        mProfileConnectedlock = new ReentrantLock();
        mConditionProfileIsConnected  = mProfileConnectedlock.newCondition();
        mIsProfileReady = false;
        mService = null;
        mIsHearingAidSupported = mBluetoothAdapter.getProfileProxy(getContext(),
                                                  new HearingAidsServiceListener(),
                                                  BluetoothProfile.HEARING_AID);
        if (!mIsHearingAidSupported) return;
    }

    @Override
    public void tearDown() {
        if (!mIsBleSupported) return;

        if (!BTAdapterUtils.disableAdapter(mBluetoothAdapter, mContext)) {
            Log.e(TAG, ""Unable to disable Bluetooth Adapter!"");
            assertTrue(mBluetoothAdapter.isEnabled());
        }
    }

    /**
     * Basic test case to make sure that Hearing Aid Profile Proxy can connect.
     */
    @MediumTest"	"/home/gpoor/cts-12-source/cts/tests/tests/bluetooth/src/android/bluetooth/cts/HearingAidProfileTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.bluetooth.cts.HearingAidProfileTest"	"test_getConnectionStateChangedIntent"	"CtsBluetoothTestCases"	"1: system"	"public void test_getConnectionStateChangedIntent() {
        if (!(mIsBleSupported && mIsHearingAidSupported)) {
            return;
        }

        waitForProfileConnect();
        assertTrue(mIsProfileReady);
        assertNotNull(mService);

        // Find out how many Hearing Aid bonded devices
        List<BluetoothDevice> bondedDeviceList = new ArrayList();
        int numDevices = 0;
        for (int connectionState : mValidConnectionStates) {
            List<BluetoothDevice> deviceList;

            deviceList = mService.getDevicesMatchingConnectionStates(new int[]{connectionState});
            bondedDeviceList.addAll(deviceList);
            numDevices += deviceList.size();
        }

        if (numDevices <= 0) return;
        Log.d(TAG, ""Number Hearing Aids devices bonded="" + numDevices);

        mIntentCallbackDeviceList = new ArrayList();

        // Set up the Connection State Changed receiver
        IntentFilter filter = new IntentFilter();
        filter.addAction(BluetoothHearingAid.ACTION_CONNECTION_STATE_CHANGED);
        mIntentReceiver = new HearingAidIntentReceiver();
        mContext.registerReceiver(mIntentReceiver, filter);

        Log.d(TAG, ""test_getConnectionStateChangedIntent: disable adapter and wait"");
        assertTrue(BTAdapterUtils.disableAdapter(mBluetoothAdapter, mContext));

        Log.d(TAG, ""test_getConnectionStateChangedIntent: enable adapter and wait"");
        assertTrue(BTAdapterUtils.enableAdapter(mBluetoothAdapter, mContext));

        int sanityCount = WAIT_FOR_INTENT_TIMEOUT_MS;
        while ((numDevices != mIntentCallbackDeviceList.size()) && (sanityCount > 0)) {
            final int SLEEP_QUANTUM_MS = 100;
            sleep(SLEEP_QUANTUM_MS);
            sanityCount -= SLEEP_QUANTUM_MS;
        }

        // Tear down
        mContext.unregisterReceiver(mIntentReceiver);

        Log.d(TAG, ""test_getConnectionStateChangedIntent: number of bonded device=""
              + numDevices + "", mIntentCallbackDeviceList.size()=""
              + mIntentCallbackDeviceList.size());
        for (BluetoothDevice device : mIntentCallbackDeviceList) {
            assertTrue(bondedDeviceList.contains(device));
        }
    }

    private boolean waitForProfileConnect() {
        mProfileConnectedlock.lock();
        try {
            // Wait for the Adapter to be disabled
            while (!mIsProfileReady) {
                if (!mConditionProfileIsConnected.await(
                    PROXY_CONNECTION_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
                    // Timeout
                    Log.e(TAG, ""Timeout while waiting for Profile Connect"");
                    break;
                } // else spurious wakeups
            }
        } catch(InterruptedException e) {
            Log.e(TAG, ""waitForProfileConnect: interrrupted"");
        } finally {
            mProfileConnectedlock.unlock();
        }
        return mIsProfileReady;
    }

    private final class HearingAidsServiceListener
            implements BluetoothProfile.ServiceListener {

        public void onServiceConnected(int profile, BluetoothProfile proxy) {
            mProfileConnectedlock.lock();
            mService = (BluetoothHearingAid) proxy;
            mIsProfileReady = true;
            try {
                mConditionProfileIsConnected.signal();
            } finally {
                mProfileConnectedlock.unlock();
            }
        }

        public void onServiceDisconnected(int profile) {
            mProfileConnectedlock.lock();
            mIsProfileReady = false;
            mService = null;
            mProfileConnectedlock.unlock();
        }
    }

    private class HearingAidIntentReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            if (BluetoothHearingAid.ACTION_CONNECTION_STATE_CHANGED.equals(intent.getAction())) {
                int state = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, -1);
                int previousState = intent.getIntExtra(BluetoothProfile.EXTRA_PREVIOUS_STATE, -1);
                BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);

                Log.d(TAG,""HearingAidIntentReceiver.onReceive: device="" + device
                      + "", state="" + state + "", previousState="" + previousState);

                checkValidConnectionState(state);
                checkValidConnectionState(previousState);

                mIntentCallbackDeviceList.add(device);
            }
        }
    }

    private void checkDeviceListAndStates(List<BluetoothDevice> deviceList, int connectionState) {
        Log.d(TAG, ""checkDeviceListAndStates(): size="" + deviceList.size()
              + "", connectionState="" + connectionState);
        for (BluetoothDevice device : deviceList) {
            int deviceConnectionState = mService.getConnectionState(device);
            assertEquals(""Mismatched connection state for "" + device,
                         connectionState, deviceConnectionState);
        }
    }

    private void checkValidConnectionState(int connectionState) {
        assertTrue(mValidConnectionStates.contains(connectionState));
    }

    // Returns whether offloaded scan batching is supported.
    private boolean isBleBatchScanSupported() {
        return mBluetoothAdapter.isOffloadedScanBatchingSupported();
    }

    // Check if Bluetooth LE feature is supported on DUT.
    private boolean isBleSupported() {
        return getContext().getPackageManager()
                .hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE);
    }

    private static void sleep(long t) {
        try {
            Thread.sleep(t);
        } catch (InterruptedException e) {}
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/bluetooth/src/android/bluetooth/cts/HearingAidProfileTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.os.cts.ParcelFileDescriptorProcessTest"	"isInstantApp"	""	"3: apps system interaction"	"public void test/*
 *.
 */

package android.os.cts;

import android.app.ActivityManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.os.IBinder;
import android.os.ParcelFileDescriptor;
import android.os.RemoteException;
import android.os.SystemClock;
import android.test.AndroidTestCase;

import com.google.common.util.concurrent.AbstractFuture;

import junit.framework.ComparisonFailure;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

/**
 * Test various cross-process {@link ParcelFileDescriptor} interactions.
 */
public class ParcelFileDescriptorProcessTest extends AndroidTestCase {

    private Intent redIntent;
    private Intent blueIntent;
    private PeerConnection redConn;
    private PeerConnection blueConn;
    private IParcelFileDescriptorPeer red;
    private IParcelFileDescriptorPeer blue;

    public static class PeerConnection extends AbstractFuture<IParcelFileDescriptorPeer>
            implements ServiceConnection {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            set(IParcelFileDescriptorPeer.Stub.asInterface(service));
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
        }

        @Override
        public IParcelFileDescriptorPeer get() throws InterruptedException, ExecutionException {
            try {
                return get(5, TimeUnit.SECONDS);
            } catch (TimeoutException e) {
                throw new RuntimeException(e);
            }
        }
    }

    private static void assertContains(String expected, String actual) {
        if (actual.contains(expected)) return;
        throw new ComparisonFailure("""", expected, actual);
    }

    private static void crash(IParcelFileDescriptorPeer peer) {
        try {
            peer.crash();
        } catch (RemoteException e) {
        }
        SystemClock.sleep(500);
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        final Context context = getContext();

        // Bring up both remote processes and wire them to each other
        redIntent = new Intent();
        redIntent.setComponent(new ComponentName(
                ""android.os.cts"", ""android.os.cts.ParcelFileDescriptorPeer$Red""));
        blueIntent = new Intent();
        blueIntent.setComponent(new ComponentName(
                ""android.os.cts"", ""android.os.cts.ParcelFileDescriptorPeer$Blue""));
        redConn = new PeerConnection();
        blueConn = new PeerConnection();
        context.startService(redIntent);
        context.startService(blueIntent);
        getContext().bindService(redIntent, redConn, 0);
        getContext().bindService(blueIntent, blueConn, 0);
        red = redConn.get();
        blue = blueConn.get();
        red.setPeer(blue);
        blue.setPeer(red);
    }

    @Override
    protected void tearDown() throws Exception {
        super.tearDown();

        final Context context = getContext();
        context.unbindService(redConn);
        context.unbindService(blueConn);
        context.stopService(redIntent);
        context.stopService(blueIntent);

        // Instant Apps don't have the KILL_BACKGROUND_PROCESSES permission
        if (!context.getPackageManager().isInstantApp()) {
            final ActivityManager am = (ActivityManager) mContext.getSystemService(
                    Context.ACTIVITY_SERVICE);
            am.killBackgroundProcesses(context.getPackageName());
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorProcessTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.os.cts.ParcelFileDescriptorProcessTest"	"testSocketGiantError"	""	"1: ui"	"public void testSocketGiantError() throws Exception {
        // red <--> blue
        red.setupSocket();
        blue.doGet();

        final StringBuilder builder = new StringBuilder();
        for (int i = 0; i < 1024; i++) {
            builder.append(i).append("","");
        }
        final String msg = builder.toString();
        red.closeWithError(msg);

        // we should at least see the first 512 chars
        assertContains(msg.substring(0, 512), blue.checkError());
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/ParcelFileDescriptorProcessTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.scopedstorage.cts.host.LegacyStorageHostTest"	"testRenameDirectoryAndUpdateDB_hasW"	""	"1: direct"	"public void testRenameDirectoryAndUpdateDB_hasW() throws Exception {
        runDeviceTest(""testRenameDirectoryAndUpdateDB_hasW"");
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/LegacyStorageHostTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.scopedstorage.cts.host.LegacyStorageHostTest"	"testLegacySystemGalleryCanRenameImagesAndVideosWithoutDbUpdates"	""	"1: system"	"public void testLegacySystemGalleryCanRenameImagesAndVideosWithoutDbUpdates() throws Exception {
        runDeviceTest(""testLegacySystemGalleryCanRenameImagesAndVideosWithoutDbUpdates"");
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/LegacyStorageHostTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.scopedstorage.cts.host.LegacyStorageHostTest"	"testLegacySystemGalleryWithoutWESCannotRename"	""	"1: system"	"public void testLegacySystemGalleryWithoutWESCannotRename() throws Exception {
        revokePermissions(""android.permission.WRITE_EXTERNAL_STORAGE"");
        runDeviceTest(""testLegacySystemGalleryWithoutWESCannotRename"");
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/LegacyStorageHostTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.scopedstorage.cts.host.LegacyStorageHostTest"	"isTrue"	""	"1: user"	"/*
 *.
 */

package android.scopedstorage.cts.host;

import static com.google.common.truth.Truth.assertThat;

import android.platform.test.annotations.AppModeFull;

import com.android.tradefed.device.contentprovider.ContentProviderHandler;
import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Runs the legacy file path access tests.
 */
@RunWith(DeviceJUnit4ClassRunner.class)
@AppModeFull
public class LegacyStorageHostTest extends BaseHostTestCase {

    private boolean mIsExternalStorageSetup;

    private ContentProviderHandler mContentProviderHandler;

    /**
     * Runs the given phase of LegacyFileAccessTest by calling into the device.
     * Throws an exception if the test phase fails.
     */
    void runDeviceTest(String phase) throws Exception {
        assertThat(runDeviceTests(""android.scopedstorage.cts.legacy"",
                ""android.scopedstorage.cts.legacy.LegacyStorageTest"", phase)).isTrue();
    }

    /**
     * <p> Keep in mind that granting WRITE_EXTERNAL_STORAGE also grants READ_EXTERNAL_STORAGE,
     * so in order to test a case where the reader has only WRITE, we must explicitly revoke READ.
     */
    private void grantPermissions(String... perms) throws Exception {
        int currentUserId = getCurrentUserId();
        for (String perm : perms) {
            executeShellCommand(""pm grant --user %d android.scopedstorage.cts.legacy %s"",
                    currentUserId, perm);
        }
    }

    private void revokePermissions(String... perms) throws Exception {
        int currentUserId = getCurrentUserId();
        for (String perm : perms) {
            executeShellCommand(""pm revoke --user %d android.scopedstorage.cts.legacy %s"",
                    currentUserId, perm);
        }
    }

    /**
     * Creates a file {@code filePath} in shell and may bypass Media Provider restrictions for
     * creating file.
     */
    private void createFileAsShell(String filePath) throws Exception {
        executeShellCommand(""touch %s"", filePath);
        assertThat(getDevice().doesFileExist(filePath)).isTrue();
    }

    private void setupExternalStorage() throws Exception {
        if (!mIsExternalStorageSetup) {
            runDeviceTest(""setupExternalStorage"");
            mIsExternalStorageSetup = true;
        }
    }

    @Before
    public void setup() throws Exception {
        mContentProviderHandler = new ContentProviderHandler(getDevice());
        mContentProviderHandler.setUp();
        setupExternalStorage();
        // Granting WRITE automatically grants READ as well, so we grant them both explicitly by
        // default in order to avoid confusion. Test cases that don't want any of those permissions
        // have to revoke the unwanted permissions.
        grantPermissions(""android.permission.WRITE_EXTERNAL_STORAGE"",
                ""android.permission.READ_EXTERNAL_STORAGE"");
    }

    @After
    public void tearDown() throws Exception {
        mContentProviderHandler.tearDown();
        revokePermissions(""android.permission.WRITE_EXTERNAL_STORAGE"",
                ""android.permission.READ_EXTERNAL_STORAGE"");
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/LegacyStorageHostTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.car.cts.powerpolicy.PowerPolicyDef"	"getDisables"	"CtsCarHostTestCases"	"6: mic ui system interaction user microphone"	"public void test/*
 *.
 */

package android.car.cts.powerpolicy;

import com.android.tradefed.log.LogUtil.CLog;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.StringTokenizer;

public final class PowerPolicyDef {
    public static final String[] ENABLED_HEADERS =
            {""enabledComponents"", ""Enabled components""};
    public static final String[] DISABLED_HEADERS =
            {""disabledComponents"", ""Disabled components""};
    public static final int STRING_BUILDER_BUF_SIZE = 1024;

    private final String mPolicyId;
    private final PowerComponent[] mEnables;
    private final PowerComponent[] mDisables;

    private PowerPolicyDef(String policyId, PowerComponent[] enables, PowerComponent[] disables) {
        mPolicyId = policyId;
        mEnables = enables;
        mDisables = disables;
    }

    public String getPolicyId() {
        return mPolicyId;
    }

    public PowerComponent[] getEnables() {
        return mEnables;
    }

    public PowerComponent[] getDisables() {
        return mDisables;
    }

    @Override
    public String toString() {
        String[] enables = Arrays.stream(mEnables).map(PowerComponent::getValue)
                .toArray(String[]::new);
        String[] disables = Arrays.stream(mDisables).map(PowerComponent::getValue)
                .toArray(String[]::new);
        StringBuilder str = new StringBuilder();
        str.append(mPolicyId);
        if (enables.length > 0) {
            str.append("" --enable "").append(String.join("","", enables));
        }
        if (disables.length > 0) {
            str.append("" --disable "").append(String.join("","", disables));
        }
        return str.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        PowerPolicyDef that = (PowerPolicyDef) o;
        return Objects.equals(mPolicyId, that.mPolicyId)
                && Arrays.equals(mEnables, that.mEnables)
                && Arrays.equals(mDisables, that.mDisables);
    }

    @Override
    public int hashCode() {
        int result = Objects.hash(mPolicyId);
        result = 31 * result + Arrays.hashCode(mEnables);
        result = 31 * result + Arrays.hashCode(mDisables);
        return result;
    }

    public static PowerPolicyDef parse(String policyDefStr, boolean hasPolicyId, int offset)
            throws Exception {
        if (policyDefStr == null) {
            throw new IllegalArgumentException(""null policyDefStr parameter"");
        }
        CLog.d(""policyDefStr: "" + policyDefStr);

        StringTokenizer tokens = new StringTokenizer(policyDefStr, ""():"");
        String policyId = hasPolicyId
                ? tokens.nextToken().trim().substring(offset).trim() : IdSet.NONE;

        if (!search(ENABLED_HEADERS, tokens.nextToken().trim())) {
            throw new IllegalArgumentException(""malformatted enabled headers string: ""
                    + policyDefStr);
        }

        int idx = 0;
        String[] enables = null;
        String tmpStr = tokens.nextToken().trim();
        CLog.d(""enables: "" + tmpStr);
        for (String hdr : DISABLED_HEADERS) {
            idx = tmpStr.indexOf(hdr);
            if (idx >= 0) {
                tmpStr = tmpStr.substring(0, idx).trim();
                if (!tmpStr.isEmpty()) {
                    enables = tmpStr.split("",\\s*"");
                }
                break;
            }
        }
        if (idx < 0) {
            throw new IllegalArgumentException(""malformatted disabled headers string: ""
                    + policyDefStr);
        }
        PowerComponent[] enabledComps = PowerComponent.asComponentArray(enables);

        String[] disables = null;
        tmpStr = tokens.nextToken().trim();
        CLog.d(""disables: "" + tmpStr);
        if (!tmpStr.isEmpty()) {
            disables = tmpStr.split("",\\s*"");
        }
        PowerComponent[] disabledComps = PowerComponent.asComponentArray(disables);

        return new PowerPolicyDef(policyId, enabledComps, disabledComps);
    }

    public static PowerPolicyDef createWithComponentOff(String component)
            throws Exception {
        PowerComponent removingComp = PowerComponent.valueOf(component);

        ArrayList<PowerComponent> enableList = new ArrayList<PowerComponent>(
                Arrays.asList(ComponentList.ALL_COMPONENTS));
        if (!enableList.remove(removingComp)) {
            throw new IllegalArgumentException(component + "" is not in the all list"");
        }

        PowerComponent[] enables = enableList.toArray(new PowerComponent[0]);
        PowerComponent[] disables = {removingComp};
        String policyId = component + ""_disable"";

        return new PowerPolicyDef(policyId, enables, disables);
    }

    private static boolean search(String[] strList, String str) {
        return Arrays.stream(strList).anyMatch(s -> str.contains(s));
    }

    public static final class IdSet {
        public static final String DEFAULT_ALL_ON = ""system_power_policy_all_on"";
        public static final String INITIAL_ALL_ON = ""system_power_policy_initiall_on"";
        public static final String NO_USER_INTERACTION = ""system_power_policy_no_user_interaction"";
        public static final String NONE = ""none"";
        public static final String TEST1 = ""test1"";
        public static final String TEST2 = ""test2"";
        public static final String ERROR_TEST1 = ""error_test1"";
        public static final String ERROR_TEST2 = ""error_test2"";
        public static final String LISTENER_TEST = ""listener_test"";
    }

    public enum PowerComponent {
        NONE(""none""),
        UNKNOWN(""UNKNOWN""),
        AUDIO(""AUDIO""),
        MEDIA(""MEDIA""),
        DISPLAY(""DISPLAY""),
        BLUETOOTH(""BLUETOOTH""),
        WIFI(""WIFI""),
        CELLULAR(""CELLULAR""),
        ETHERNET(""ETHERNET""),
        PROJECTION(""PROJECTION""),
        NFC(""NFC""),
        INPUT(""INPUT""),
        VOICE_INTERACTION(""VOICE_INTERACTION""),
        VISUAL_INTERACTION(""VISUAL_INTERACTION""),
        TRUSTED_DEVICE_DETECTION(""TRUSTED_DEVICE_DETECTION""),
        LOCATION(""LOCATION""),
        MICROPHONE(""MICROPHONE""),
        CPU(""CPU"");

        private final String mValue;

        PowerComponent(String v) {
            mValue = v;
        }

        public String getValue() {
            return mValue;
        }

        public static PowerComponent[] asComponentArray(String[] componentNames) {
            if (componentNames == null) {
                return new PowerComponent[0];
            }
            normalizeComponentName(componentNames);
            PowerComponent[] compArray = Arrays.stream(componentNames).map(PowerComponent::valueOf)
                    .filter(e -> e != NONE).toArray(PowerComponent[]::new);
            Arrays.sort(compArray);
            return compArray;
        }

        public static PowerComponent[] asComponentArray(List<String> nameList) {
            if (nameList == null) {
                return new PowerComponent[0];
            }
            return asComponentArray(nameList.toArray(new String[0]));
        }

        private static void normalizeComponentName(String[] comps) {
            for (int i = 0; i < comps.length; i++) {
                try {
                    PowerComponent.valueOf(comps[i]);
                } catch (Exception e) {
                    if (comps[i] != null && comps[i].equals(""none"")) {
                        comps[i] = ""NONE"";
                    }
                }
            }
        }
    }

    private static final class ComponentList {
        static final PowerComponent[] ALL_COMPONENTS = {
            PowerComponent.AUDIO,
            PowerComponent.MEDIA,
            PowerComponent.DISPLAY,
            PowerComponent.BLUETOOTH,
            PowerComponent.WIFI,
            PowerComponent.CELLULAR,
            PowerComponent.ETHERNET,
            PowerComponent.PROJECTION,
            PowerComponent.NFC,
            PowerComponent.INPUT,
            PowerComponent.VOICE_INTERACTION,
            PowerComponent.VISUAL_INTERACTION,
            PowerComponent.TRUSTED_DEVICE_DETECTION,
            PowerComponent.LOCATION,
            PowerComponent.MICROPHONE,
            PowerComponent.CPU
        };

        static final PowerComponent[] INIT_ALL_ON_ENABLE = {
            PowerComponent.AUDIO,
            PowerComponent.DISPLAY,
            PowerComponent.CPU
        };

        static final PowerComponent[] INIT_ALL_ON_DISABLE = {
            PowerComponent.MEDIA,
            PowerComponent.BLUETOOTH,
            PowerComponent.WIFI,
            PowerComponent.CELLULAR,
            PowerComponent.ETHERNET,
            PowerComponent.PROJECTION,
            PowerComponent.NFC,
            PowerComponent.INPUT,
            PowerComponent.VOICE_INTERACTION,
            PowerComponent.VISUAL_INTERACTION,
            PowerComponent.TRUSTED_DEVICE_DETECTION,
            PowerComponent.LOCATION,
            PowerComponent.MICROPHONE
        };

        static final PowerComponent[] DEFAULT_ALL_ON_ENABLE = ALL_COMPONENTS;
        static final PowerComponent[] DEFAULT_ALL_ON_DISABLE = {};

        static final PowerComponent[] NO_USER_INTERACT_ENABLE = {
            PowerComponent.WIFI,
            PowerComponent.CELLULAR,
            PowerComponent.ETHERNET,
            PowerComponent.TRUSTED_DEVICE_DETECTION,
            PowerComponent.CPU
        };

        static final PowerComponent[] NO_USER_INTERACT_DISABLE = {
            PowerComponent.AUDIO,
            PowerComponent.MEDIA,
            PowerComponent.DISPLAY,
            PowerComponent.BLUETOOTH,
            PowerComponent.PROJECTION,
            PowerComponent.NFC,
            PowerComponent.INPUT,
            PowerComponent.VOICE_INTERACTION,
            PowerComponent.VISUAL_INTERACTION,
            PowerComponent.LOCATION,
            PowerComponent.MICROPHONE
        };

        static final PowerComponent[] TEST1_ENABLE =  ALL_COMPONENTS;
        static final PowerComponent[] TEST1_DISABLE = {};

        static final PowerComponent[] TEST2_ENABLE = {};
        static final PowerComponent[] TEST2_DISABLE = ALL_COMPONENTS;

        static final PowerComponent[] ERROR_TEST1_ENABLE = ALL_COMPONENTS;
        static final PowerComponent[] ERROR_TEST1_DISABLE = {PowerComponent.UNKNOWN};

        static final PowerComponent[] ERROR_TEST2_ENABLE = {
            PowerComponent.AUDIO,
            PowerComponent.MEDIA,
            PowerComponent.DISPLAY,
            PowerComponent.UNKNOWN,
            PowerComponent.WIFI,
            PowerComponent.CELLULAR,
            PowerComponent.ETHERNET,
            PowerComponent.PROJECTION,
            PowerComponent.NFC,
            PowerComponent.INPUT,
            PowerComponent.VOICE_INTERACTION,
            PowerComponent.VISUAL_INTERACTION,
            PowerComponent.TRUSTED_DEVICE_DETECTION,
            PowerComponent.LOCATION,
            PowerComponent.MICROPHONE,
            PowerComponent.CPU
        };
        static final PowerComponent[] ERROR_TEST2_DISABLE = {};

        static final PowerComponent[] RUNTIME_DEFAULT_ENABLE = ALL_COMPONENTS;
        static final PowerComponent[] RUNTIME_DEFAULT_DISABLE = {};

        static final PowerComponent[] RUNTIME_SILENT_ENABLE = {
            PowerComponent.AUDIO,
            PowerComponent.MEDIA,
            PowerComponent.DISPLAY,
            PowerComponent.BLUETOOTH,
            PowerComponent.WIFI,
            PowerComponent.CELLULAR,
            PowerComponent.ETHERNET,
            PowerComponent.PROJECTION,
            PowerComponent.NFC,
            PowerComponent.INPUT,
            PowerComponent.VOICE_INTERACTION,
            PowerComponent.VISUAL_INTERACTION,
            PowerComponent.TRUSTED_DEVICE_DETECTION,
            PowerComponent.LOCATION,
            PowerComponent.MICROPHONE,
            PowerComponent.CPU
        };
        static final PowerComponent[] RUNTIME_SILENT_DISABLE = {};

        static final PowerComponent[] LISTENER_TEST_ENABLE = {
            PowerComponent.MEDIA,
            PowerComponent.DISPLAY,
            PowerComponent.BLUETOOTH,
            PowerComponent.WIFI,
            PowerComponent.CELLULAR,
            PowerComponent.ETHERNET,
            PowerComponent.PROJECTION,
            PowerComponent.NFC,
            PowerComponent.INPUT,
            PowerComponent.VOICE_INTERACTION,
            PowerComponent.VISUAL_INTERACTION,
            PowerComponent.TRUSTED_DEVICE_DETECTION,
            PowerComponent.LOCATION,
            PowerComponent.CPU
        };

        static final PowerComponent[] LISTENER_TEST_DISABLE = {
            PowerComponent.AUDIO,
            PowerComponent.MICROPHONE
        };
    }

    public static final class PolicySet {
        public static final int TOTAL_DEFAULT_REGISTERED_POLICIES = 2;

        public static final PowerPolicyDef
                INITIAL_ALL_ON = new PowerPolicyDef(IdSet.INITIAL_ALL_ON,
                ComponentList.INIT_ALL_ON_ENABLE, ComponentList.INIT_ALL_ON_DISABLE);

        public static final PowerPolicyDef
                DEFAULT_ALL_ON = new PowerPolicyDef(IdSet.DEFAULT_ALL_ON,
                ComponentList.DEFAULT_ALL_ON_ENABLE, ComponentList.DEFAULT_ALL_ON_DISABLE);

        public static final PowerPolicyDef
                NO_USER_INTERACT = new PowerPolicyDef(IdSet.NO_USER_INTERACTION,
                ComponentList.NO_USER_INTERACT_ENABLE, ComponentList.NO_USER_INTERACT_DISABLE);

        public static final PowerPolicyDef TEST1 = new PowerPolicyDef(IdSet.TEST1,
                ComponentList.TEST1_ENABLE, ComponentList.TEST1_DISABLE);

        public static final PowerPolicyDef TEST2 = new PowerPolicyDef(IdSet.TEST2,
                ComponentList.TEST2_ENABLE, ComponentList.TEST2_DISABLE);

        public static final PowerPolicyDef ERROR_TEST1 = new PowerPolicyDef(IdSet.ERROR_TEST1,
                ComponentList.ERROR_TEST1_ENABLE, ComponentList.ERROR_TEST1_DISABLE);

        public static final PowerPolicyDef ERROR_TEST2 = new PowerPolicyDef(IdSet.ERROR_TEST2,
                ComponentList.ERROR_TEST2_ENABLE, ComponentList.ERROR_TEST2_DISABLE);

        public static final PowerPolicyDef LISTENER_TEST = new PowerPolicyDef(IdSet.LISTENER_TEST,
                ComponentList.LISTENER_TEST_ENABLE, ComponentList.LISTENER_TEST_DISABLE);
    }

    public static final class ComponentSet {
        public static final PowerPolicyDef RUNTIME_DEFAULT = new PowerPolicyDef(null,
                ComponentList.RUNTIME_DEFAULT_ENABLE, ComponentList.RUNTIME_DEFAULT_DISABLE);

        public static final PowerPolicyDef RUNTIME_SILENT = new PowerPolicyDef(null,
                ComponentList.RUNTIME_SILENT_ENABLE, ComponentList.RUNTIME_SILENT_DISABLE);
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/car/src/android/car/cts/powerpolicy/PowerPolicyDef.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.delegate.NetworkLoggingDelegateTest"	"isHeadlessSystemUserMode"	""	"2: system user"	"public void test/*
 *.
 */
package com.android.cts.delegate;

import static android.app.admin.DeviceAdminReceiver.ACTION_NETWORK_LOGS_AVAILABLE;

import static com.android.cts.delegate.DelegateTestUtils.assertExpectException;

import static com.google.common.truth.Truth.assertThat;

import android.app.admin.DevicePolicyManager;
import android.content.IntentFilter;
import android.os.UserManager;
import android.util.Log;

import com.android.bedstead.dpmwrapper.TestAppHelper;
import com.android.cts.delegate.DelegateTestUtils.DelegatedLogsReceiver;

import java.io.IOException;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.concurrent.CountDownLatch;

/**
 * Tests that a delegate app with DELEGATION_NETWORK_LOGGING is able to control and access
 * network logging.
 */
public final class NetworkLoggingDelegateTest extends BaseJUnit3TestCase {

    private static final String TAG = ""NetworkLoggingDelegateTest"";

    private static final String[] URL_LIST = {
            ""example.edu"",
            ""ipv6.google.com"",
            ""google.co.jp"",
            ""google.fr"",
            ""google.com.br"",
            ""google.com.tr"",
            ""google.co.uk"",
            ""google.de""
    };

    // TODO(b/176993670): receiver needed to forward intents from device owner user to current user
    // on headless system user mode. Might be removed once tests are refactor to use proper IPC.
    private DelegatedLogsReceiver mReceiver;

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        if (UserManager.isHeadlessSystemUserMode()) {
            mReceiver = new DelegatedLogsReceiver();
            TestAppHelper.registerTestCaseReceiver(mContext, mReceiver,
                    new IntentFilter(ACTION_NETWORK_LOGS_AVAILABLE));
        }

        DelegatedLogsReceiver.sBatchCountDown = new CountDownLatch(1);
    }

    @Override
    protected void tearDown() throws Exception {
        super.tearDown();

        if (mReceiver != null) {
            TestAppHelper.unregisterTestCaseReceiver(mContext, mReceiver);
        }
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DelegateApp/src/com/android/cts/delegate/NetworkLoggingDelegateTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.systemui.cts.LightBarTestBase"	"exists"	"CtsSystemUiTestCases"	"2: ui system"	"public void test/*
 *
 */

package android.systemui.cts;

import static androidx.test.InstrumentationRegistry.getInstrumentation;

import static org.junit.Assert.fail;
import static org.junit.Assume.assumeFalse;
import static org.junit.Assume.assumeTrue;

import android.app.ActivityManager;
import android.content.Context;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.graphics.Bitmap;
import android.graphics.Color;
import android.graphics.Rect;
import android.util.Log;
import android.view.DisplayCutout;
import android.view.WindowInsets;

import androidx.test.InstrumentationRegistry;
import androidx.test.rule.ActivityTestRule;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.FileSystems;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Locale;

public class LightBarTestBase {

    private static final String TAG = ""LightBarTestBase"";

    public static final Path DUMP_PATH = FileSystems.getDefault()
            .getPath(""/sdcard/LightBarTestBase/"");

    public static final int WAIT_TIME = 2000;

    private static final int COLOR_DIFF_THESHOLDS = 2;

    private ArrayList<Rect> mCutouts;

    protected Bitmap takeStatusBarScreenshot(LightBarBaseActivity activity) {
        Bitmap fullBitmap = getInstrumentation().getUiAutomation().takeScreenshot();
        return Bitmap.createBitmap(fullBitmap, 0, 0, fullBitmap.getWidth(), activity.getTop());
    }

    protected Bitmap takeNavigationBarScreenshot(LightBarBaseActivity activity) {
        Bitmap fullBitmap = getInstrumentation().getUiAutomation().takeScreenshot();
        return Bitmap.createBitmap(fullBitmap, 0, activity.getBottom(), fullBitmap.getWidth(),
                fullBitmap.getHeight() - activity.getBottom());
    }

    protected void dumpBitmap(Bitmap bitmap, String name) {
        File dumpDir = DUMP_PATH.toFile();
        if (!dumpDir.exists()) {
            dumpDir.mkdirs();
        }

        Path filePath = DUMP_PATH.resolve(name + "".png"");
        Log.e(TAG, ""Dumping failed bitmap to "" + filePath);
        FileOutputStream fileStream = null;
        try {
            fileStream = new FileOutputStream(filePath.toFile());
            bitmap.compress(Bitmap.CompressFormat.PNG, 85, fileStream);
            fileStream.flush();
        } catch (Exception e) {
            Log.e(TAG, ""Dumping bitmap failed."", e);
        } finally {
            if (fileStream != null) {
                try {
                    fileStream.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    protected void checkNavigationBarDivider(LightBarBaseActivity activity, int dividerColor,
            int backgroundColor, String methodName) {
        final Bitmap bitmap = takeNavigationBarScreenshot(activity);
        int[] pixels = new int[bitmap.getHeight() * bitmap.getWidth()];
        bitmap.getPixels(pixels, 0, bitmap.getWidth(), 0, 0, bitmap.getWidth(), bitmap.getHeight());

        loadCutout(activity);
        int backgroundColorPixelCount = 0;
        int shiftY = activity.getBottom();
        for (int i = 0; i < pixels.length; i++) {
            int x = i % bitmap.getWidth();
            int y = i / bitmap.getWidth();

            if (pixels[i] == backgroundColor
                    || isInsideCutout(x, shiftY + y)) {
                backgroundColorPixelCount++;
            }
        }
        assumeNavigationBarChangesColor(backgroundColorPixelCount, pixels.length);

        int diffCount = 0;
        for (int col = 0; col < bitmap.getWidth(); col++) {
            if (isInsideCutout(col, shiftY)) {
                continue;
            }

            if (!isColorSame(dividerColor, pixels[col])) {
                diffCount++;
            }
        }

        boolean success = false;
        try {
            assertLessThan(String.format(Locale.ENGLISH,
                    ""There are invalid color pixels. expected= 0x%08x"", dividerColor),
                    0.3f, (float) diffCount / (float)bitmap.getWidth(),
                    ""Is the divider colored according to android:navigationBarDividerColor ""
                            + "" in the theme?"");
            success = true;
        } finally {
            if (!success) {
                dumpBitmap(bitmap, methodName);
            }
        }
    }

    private static boolean isColorSame(int c1, int c2) {
        return Math.abs(Color.alpha(c1) - Color.alpha(c2)) < COLOR_DIFF_THESHOLDS
                && Math.abs(Color.red(c1) - Color.red(c2)) < COLOR_DIFF_THESHOLDS
                && Math.abs(Color.green(c1) - Color.green(c2)) < COLOR_DIFF_THESHOLDS
                && Math.abs(Color.blue(c1) - Color.blue(c2)) < COLOR_DIFF_THESHOLDS;
    }

    protected void assumeNavigationBarChangesColor(int backgroundColorPixelCount, int totalPixel) {
        assumeTrue(""Not enough background pixels. The navigation bar may not be able to change ""
                + ""color."", backgroundColorPixelCount > 0.3f * totalPixel);
    }

    protected ArrayList loadCutout(LightBarBaseActivity activity) {
        mCutouts = new ArrayList<>();
        InstrumentationRegistry.getInstrumentation().runOnMainSync(()-> {
            WindowInsets windowInsets = activity.getRootWindowInsets();
            DisplayCutout displayCutout = windowInsets.getDisplayCutout();
            if (displayCutout != null) {
                mCutouts.addAll(displayCutout.getBoundingRects());
            }
        });
        return mCutouts;
    }

    protected boolean isInsideCutout(int x, int y) {
        for (Rect cutout : mCutouts) {
            if (cutout.contains(x, y)) {
                return true;
            }
        }
        return false;
    }

    protected void assertMoreThan(String what, float expected, float actual, String hint) {
        if (!(actual > expected)) {
            fail(what + "": expected more than "" + expected * 100 + ""%, but only got "" + actual * 100
                    + ""%; "" + hint);
        }
    }

    protected void assertLessThan(String what, float expected, float actual, String hint) {
        if (!(actual < expected)) {
            fail(what + "": expected less than "" + expected * 100 + ""%, but got "" + actual * 100
                    + ""%; "" + hint);
        }
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/systemui/src/android/systemui/cts/LightBarTestBase.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.view.cts.ViewTreeObserverTest"	"testAddOnGlobalFocusChangeListener"	"CtsViewTestCases"	"1: ui"	"public void testAddOnGlobalFocusChangeListener() throws Throwable {
        final View view1 = mActivity.findViewById(R.id.view1);
        final View view2 = mActivity.findViewById(R.id.view2);

        mActivityRule.runOnUiThread(view1::requestFocus);

        mViewTreeObserver = mLinearLayout.getViewTreeObserver();
        final ViewTreeObserver.OnGlobalFocusChangeListener listener =
                mock(ViewTreeObserver.OnGlobalFocusChangeListener.class);
        mViewTreeObserver.addOnGlobalFocusChangeListener(listener);

        mActivityRule.runOnUiThread(view2::requestFocus);
        mInstrumentation.waitForIdleSync();
        verify(listener, within(TIMEOUT_MS)).onGlobalFocusChanged(view1, view2);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/ViewTreeObserverTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.view.cts.ViewTreeObserverTest"	"testAddOnTouchModeChangeListener"	"CtsViewTestCases"	"1: ui"	"public void testAddOnTouchModeChangeListener() throws Throwable {
        // let the button be touch mode.
        CtsTouchUtils.emulateTapOnViewCenter(mInstrumentation, mActivityRule, mButton);

        mViewTreeObserver = mButton.getViewTreeObserver();

        final ViewTreeObserver.OnTouchModeChangeListener listener =
                mock(ViewTreeObserver.OnTouchModeChangeListener.class);
        mViewTreeObserver.addOnTouchModeChangeListener(listener);

        mActivityRule.runOnUiThread(mButton::requestFocusFromTouch);
        mInstrumentation.waitForIdleSync();

        verify(listener, within(TIMEOUT_MS)).onTouchModeChanged(anyBoolean());
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/ViewTreeObserverTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.view.cts.ViewTreeObserverTest"	"testRemoveOnGlobalFocusChangeListener"	"CtsViewTestCases"	"3: ui system interaction"	"public void testRemoveOnGlobalFocusChangeListener() throws Throwable {
        final View view1 = mActivity.findViewById(R.id.view1);
        final View view2 = mActivity.findViewById(R.id.view2);

        mActivityRule.runOnUiThread(view1::requestFocus);

        mViewTreeObserver = mLinearLayout.getViewTreeObserver();
        final ViewTreeObserver.OnGlobalFocusChangeListener listener =
                mock(ViewTreeObserver.OnGlobalFocusChangeListener.class);
        mViewTreeObserver.addOnGlobalFocusChangeListener(listener);
        mActivityRule.runOnUiThread(view2::requestFocus);
        mInstrumentation.waitForIdleSync();
        verify(listener, within(TIMEOUT_MS)).onGlobalFocusChanged(view1, view2);

        reset(listener);
        mViewTreeObserver.removeOnGlobalFocusChangeListener(listener);
        mActivityRule.runOnUiThread(view1::requestFocus);
        mInstrumentation.waitForIdleSync();
        // Since we've unregistered our listener, we expect it to not be called even after
        // we've waited for a couple of seconds
        SystemClock.sleep(TIMEOUT_MS);
        verifyZeroInteractions(listener);
    }

    @LargeTest"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/ViewTreeObserverTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.view.cts.ViewTreeObserverTest"	"testRemoveOnTouchModeChangeListener"	"CtsViewTestCases"	"3: ui system interaction"	"public void testRemoveOnTouchModeChangeListener() throws Throwable {
        // let the button be touch mode.
        CtsTouchUtils.emulateTapOnViewCenter(mInstrumentation, mActivityRule, mButton);

        mViewTreeObserver = mButton.getViewTreeObserver();

        final ViewTreeObserver.OnTouchModeChangeListener listener =
                mock(ViewTreeObserver.OnTouchModeChangeListener.class);
        mViewTreeObserver.addOnTouchModeChangeListener(listener);
        mActivityRule.runOnUiThread(mButton::requestFocusFromTouch);
        mInstrumentation.waitForIdleSync();

        verify(listener, within(TIMEOUT_MS)).onTouchModeChanged(anyBoolean());

        reset(listener);
        mViewTreeObserver.removeOnTouchModeChangeListener(listener);
        mActivityRule.runOnUiThread(mButton::requestFocusFromTouch);
        mInstrumentation.waitForIdleSync();

        // Since we've unregistered our listener we expect it to not be called even after
        // we've waited for a couple of seconds
        SystemClock.sleep(TIMEOUT_MS);
        verifyZeroInteractions(listener);
    }

    @LargeTest"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/ViewTreeObserverTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.view.cts.ViewTreeObserverTest"	"testAccessOnScrollChangedListener"	"CtsViewTestCases"	"3: ui system interaction"	"public void testAccessOnScrollChangedListener() throws Throwable {
        layout(R.layout.scrollview_layout);
        final ScrollView scrollView = (ScrollView) mActivity.findViewById(R.id.scroll_view);

        mViewTreeObserver = scrollView.getViewTreeObserver();

        final ViewTreeObserver.OnScrollChangedListener listener =
                mock(ViewTreeObserver.OnScrollChangedListener.class);
        mViewTreeObserver.addOnScrollChangedListener(listener);

        mActivityRule.runOnUiThread(() -> scrollView.fullScroll(View.FOCUS_DOWN));
        mInstrumentation.waitForIdleSync();
        verify(listener, within(TIMEOUT_MS)).onScrollChanged();

        reset(listener);

        mViewTreeObserver.removeOnScrollChangedListener(listener);
        mActivityRule.runOnUiThread(() -> scrollView.fullScroll(View.FOCUS_UP));
        // Since we've unregistered our listener, we expect it to not be called even after
        // we've waited for a couple of seconds
        SystemClock.sleep(TIMEOUT_MS);
        verifyZeroInteractions(listener);
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/ViewTreeObserverTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.view.cts.ViewTreeObserverTest"	"testRemoveGlobalOnLayoutListener"	"CtsViewTestCases"	"2: system interaction"	"public void testRemoveGlobalOnLayoutListener() {
        mViewTreeObserver = mLinearLayout.getViewTreeObserver();

        final ViewTreeObserver.OnGlobalLayoutListener listener =
                mock(ViewTreeObserver.OnGlobalLayoutListener.class);
        mViewTreeObserver.addOnGlobalLayoutListener(listener);
        mViewTreeObserver.dispatchOnGlobalLayout();
        verify(listener, times(1)).onGlobalLayout();

        reset(listener);
        mViewTreeObserver.removeGlobalOnLayoutListener(listener);
        mViewTreeObserver.dispatchOnGlobalLayout();
        // Since we've unregistered our listener, we expect it to not be called even after
        // we've waited for a couple of seconds
        SystemClock.sleep(TIMEOUT_MS);
        verifyZeroInteractions(listener);
    }

    @LargeTest"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/ViewTreeObserverTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.view.cts.ViewTreeObserverTest"	"testRemoveOnGlobalLayoutListener"	"CtsViewTestCases"	"2: system interaction"	"public void testRemoveOnGlobalLayoutListener() {
        mViewTreeObserver = mLinearLayout.getViewTreeObserver();

        final ViewTreeObserver.OnGlobalLayoutListener listener =
                mock(ViewTreeObserver.OnGlobalLayoutListener.class);
        mViewTreeObserver.addOnGlobalLayoutListener(listener);
        mViewTreeObserver.dispatchOnGlobalLayout();
        verify(listener, times(1)).onGlobalLayout();

        reset(listener);
        mViewTreeObserver.removeOnGlobalLayoutListener(listener);
        mViewTreeObserver.dispatchOnGlobalLayout();
        // Since we've unregistered our listener, we expect it to not be called even after
        // we've waited for a couple of seconds
        SystemClock.sleep(TIMEOUT_MS);
        verifyZeroInteractions(listener);
    }

    @LargeTest"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/ViewTreeObserverTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.view.cts.ViewTreeObserverTest"	"testRemoveOnPreDrawListener"	"CtsViewTestCases"	"2: system interaction"	"public void testRemoveOnPreDrawListener() {
        mViewTreeObserver = mLinearLayout.getViewTreeObserver();

        final ViewTreeObserver.OnPreDrawListener listener =
                mock(ViewTreeObserver.OnPreDrawListener.class);
        mViewTreeObserver.addOnPreDrawListener(listener);
        mViewTreeObserver.dispatchOnPreDraw();
        verify(listener, times(1)).onPreDraw();

        reset(listener);
        mViewTreeObserver.removeOnPreDrawListener(listener);
        mViewTreeObserver.dispatchOnPreDraw();
        // Since we've unregistered our listener, we expect it to not be called even after
        // we've waited for a couple of seconds
        SystemClock.sleep(TIMEOUT_MS);
        verifyZeroInteractions(listener);
    }

    @LargeTest"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/ViewTreeObserverTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.view.cts.ViewTreeObserverTest"	"testFrameCommitListener"	"CtsViewTestCases"	"1: interaction"	"public void testFrameCommitListener() throws Throwable {
        mViewTreeObserver = mLinearLayout.getViewTreeObserver();

        final Runnable activeListener = mock(Runnable.class);
        final Runnable removedListener = mock(Runnable.class);
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mLinearLayout, () -> {
            mViewTreeObserver.registerFrameCommitCallback(activeListener);
            mViewTreeObserver.registerFrameCommitCallback(removedListener);
            mViewTreeObserver.unregisterFrameCommitCallback(removedListener);
        });
        verify(activeListener, within(TIMEOUT_MS)).run();
        verifyZeroInteractions(removedListener);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/ViewTreeObserverTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.location.cts.gnss.asn1.supl2.supl_triggered_start.WLANAreaId"	"isTagImplicit"	"CtsLocationGnssTestCases"	"1: ui"	"public void test/*
 *.
 */

package android.location.cts.asn1.supl2.supl_triggered_start;

/*
 */


//
//
import android.location.cts.asn1.base.Asn1BitString;
import android.location.cts.asn1.base.Asn1Null;
import android.location.cts.asn1.base.Asn1Object;
import android.location.cts.asn1.base.Asn1Sequence;
import android.location.cts.asn1.base.Asn1Tag;
import android.location.cts.asn1.base.BitStream;
import android.location.cts.asn1.base.BitStreamReader;
import android.location.cts.asn1.base.SequenceComponent;
import com.google.common.collect.ImmutableList;
import java.util.Collection;
import javax.annotation.Nullable;


/**
*/
public  class WLANAreaId extends Asn1Sequence {
  //

  private static final Asn1Tag TAG_WLANAreaId
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public WLANAreaId() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_WLANAreaId;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_WLANAreaId != null) {
      return ImmutableList.of(TAG_WLANAreaId);
    } else {
      return Asn1Sequence.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new WLANAreaId from encoded stream.
   */
  public static WLANAreaId fromPerUnaligned(byte[] encodedBytes) {
    WLANAreaId result = new WLANAreaId();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new WLANAreaId from encoded stream.
   */
  public static WLANAreaId fromPerAligned(byte[] encodedBytes) {
    WLANAreaId result = new WLANAreaId();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }



  @Override protected boolean isExtensible() {
    return true;
  }

  @Override public boolean containsExtensionValues() {
    for (SequenceComponent extensionComponent : getExtensionComponents()) {
      if (extensionComponent.isExplicitlySet()) return true;
    }
    return false;
  }

  
  private WLANAreaId.apMACAddressType apMACAddress_;
  public WLANAreaId.apMACAddressType getApMACAddress() {
    return apMACAddress_;
  }
  /**
   * @throws ClassCastException if value is not a WLANAreaId.apMACAddressType
   */
  public void setApMACAddress(Asn1Object value) {
    this.apMACAddress_ = (WLANAreaId.apMACAddressType) value;
  }
  public WLANAreaId.apMACAddressType setApMACAddressToNewInstance() {
    apMACAddress_ = new WLANAreaId.apMACAddressType();
    return apMACAddress_;
  }
  

  

  

  @Override public Iterable<? extends SequenceComponent> getComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 0);

          @Override public boolean isExplicitlySet() {
            return getApMACAddress() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getApMACAddress();
          }

          @Override public void setToNewInstance() {
            setApMACAddressToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? WLANAreaId.apMACAddressType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""apMACAddress : ""
                    + getApMACAddress().toIndentedString(indent);
              }
        });
    
    return builder.build();
  }

  @Override public Iterable<? extends SequenceComponent>
                                                    getExtensionComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
      
      return builder.build();
    }

  
/*
 */


//

/**
 */
public static class apMACAddressType extends Asn1BitString {
  //

  private static final Asn1Tag TAG_apMACAddressType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public apMACAddressType() {
    super();
    setMinSize(48);
setMaxSize(48);

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_apMACAddressType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_apMACAddressType != null) {
      return ImmutableList.of(TAG_apMACAddressType);
    } else {
      return Asn1BitString.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new apMACAddressType from encoded stream.
   */
  public static apMACAddressType fromPerUnaligned(byte[] encodedBytes) {
    apMACAddressType result = new apMACAddressType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new apMACAddressType from encoded stream.
   */
  public static apMACAddressType fromPerAligned(byte[] encodedBytes) {
    apMACAddressType result = new apMACAddressType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""apMACAddressType = "" + getValue() + "";\n"";
  }
}

  

    

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    StringBuilder builder = new StringBuilder();
    builder.append(""WLANAreaId = {\n"");
    final String internalIndent = indent + ""  "";
    for (SequenceComponent component : getComponents()) {
      if (component.isExplicitlySet()) {
        builder.append(internalIndent)
            .append(component.toIndentedString(internalIndent));
      }
    }
    if (isExtensible()) {
      builder.append(internalIndent).append(""...\n"");
      for (SequenceComponent component : getExtensionComponents()) {
        if (component.isExplicitlySet()) {
          builder.append(internalIndent)
              .append(component.toIndentedString(internalIndent));
        }
      }
    }
    builder.append(indent).append(""};\n"");
    return builder.toString();
  }
}"	"/home/gpoor/cts-12-source/cts/tests/location/location_gnss/src/android/location/cts/gnss/asn1/supl2/supl_triggered_start/WLANAreaId.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.server.wm.MultiDisplayLockedKeyguardTests"	"testVirtualDisplayHidesContentWhenLocked"	"CtsWindowManagerDeviceTestCases"	"1: hide"	"public void testVirtualDisplayHidesContentWhenLocked() {
        final LockScreenSession lockScreenSession = createManagedLockScreenSession();
        lockScreenSession.setLockCredential();

        // Create new usual virtual display.
        final DisplayContent newDisplay = createManagedVirtualDisplaySession()
                .setPublicDisplay(true)
                .createDisplay();
        mWmState.assertVisibility(VIRTUAL_DISPLAY_ACTIVITY, true /* visible */);

        // Launch activity on new secondary display.
        launchActivityOnDisplay(TEST_ACTIVITY, newDisplay.mId);
        mWmState.assertVisibility(TEST_ACTIVITY, true /* visible */);

        // Lock the device.
        lockScreenSession.gotoKeyguard();
        waitAndAssertActivityState(TEST_ACTIVITY, STATE_STOPPED,
                ""Expected stopped activity on secondary display "");
        mWmState.assertVisibility(TEST_ACTIVITY, false /* visible */);

        // Unlock and check if visibility is back.
        lockScreenSession.unlockDevice();

        lockScreenSession.enterAndConfirmLockCredential();
        mWmState.waitAndAssertKeyguardGone();
        waitAndAssertActivityState(TEST_ACTIVITY, STATE_RESUMED,
                ""Expected resumed activity on secondary display"");
        mWmState.assertVisibility(TEST_ACTIVITY, true /* visible */);
    }

    /**
     * Tests that private display cannot show content while device locked.
     */"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplayLockedKeyguardTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.server.wm.MultiDisplayLockedKeyguardTests"	"testPrivateDisplayHideContentWhenLocked"	"CtsWindowManagerDeviceTestCases"	"1: hide"	"public void testPrivateDisplayHideContentWhenLocked() {
        final LockScreenSession lockScreenSession = createManagedLockScreenSession();
        lockScreenSession.setLockCredential();

        final DisplayContent newDisplay = createManagedVirtualDisplaySession()
                .setPublicDisplay(false)
                .createDisplay();
        launchActivityOnDisplay(TEST_ACTIVITY, newDisplay.mId);

        lockScreenSession.gotoKeyguard();

        waitAndAssertActivityState(TEST_ACTIVITY, STATE_STOPPED,
                ""Expected stopped activity on private display"");
        mWmState.assertVisibility(TEST_ACTIVITY, false /* visible */);
    }

    /**
     * Tests whether a FLAG_DISMISS_KEYGUARD activity on a secondary display dismisses the keyguard.
     */"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplayLockedKeyguardTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.server.wm.MultiDisplayLockedKeyguardTests"	"supportsMultiDisplay"	"CtsWindowManagerDeviceTestCases"	"1: ui"	"/*
 *
 */

package android.server.wm;

import static android.server.wm.WindowManagerState.STATE_RESUMED;
import static android.server.wm.WindowManagerState.STATE_STOPPED;
import static android.server.wm.ActivityManagerTestBase.LockScreenSession.FLAG_REMOVE_ACTIVITIES_ON_CLOSE;
import static android.server.wm.app.Components.DISMISS_KEYGUARD_ACTIVITY;
import static android.server.wm.app.Components.SHOW_WHEN_LOCKED_ACTIVITY;
import static android.server.wm.app.Components.TEST_ACTIVITY;
import static android.server.wm.app.Components.VIRTUAL_DISPLAY_ACTIVITY;

import static org.junit.Assume.assumeTrue;

import android.platform.test.annotations.Presubmit;
import android.server.wm.WindowManagerState.DisplayContent;

import androidx.test.filters.FlakyTest;

import org.junit.Before;
import org.junit.Test;

/**
 * Display tests that require a locked keyguard.
 *
 * <p>Build/Install/Run:
 *     atest CtsWindowManagerDeviceTestCases:MultiDisplayLockedKeyguardTests
 */
@Presubmit
@android.server.wm.annotation.Group3
public class MultiDisplayLockedKeyguardTests extends MultiDisplayTestBase {

    @Before
    @Override
    public void setUp() throws Exception {
        super.setUp();

        assumeTrue(supportsMultiDisplay());
        assumeTrue(supportsSecureLock());
    }

    /**
     * Test that virtual display content is hidden when device is locked.
     */"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplayLockedKeyguardTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.server.wm.MultiDisplayLockedKeyguardTests"	"testDismissKeyguard_secondaryDisplay"	"CtsWindowManagerDeviceTestCases"	"1: ui"	"public void testDismissKeyguard_secondaryDisplay() {
        final LockScreenSession lockScreenSession =
                mObjectTracker.manage(new LockScreenSession(FLAG_REMOVE_ACTIVITIES_ON_CLOSE));
        lockScreenSession.setLockCredential();

        final DisplayContent newDisplay = createManagedVirtualDisplaySession()
                .setPublicDisplay(true)
                .createDisplay();

        lockScreenSession.gotoKeyguard();
        mWmState.assertKeyguardShowingAndNotOccluded();
        getLaunchActivityBuilder().setUseInstrumentation()
                .setTargetActivity(DISMISS_KEYGUARD_ACTIVITY).setNewTask(true)
                .setMultipleTask(true).setDisplayId(newDisplay.mId)
                .setWaitForLaunched(false).execute();
        waitAndAssertActivityState(DISMISS_KEYGUARD_ACTIVITY, STATE_STOPPED,
                ""Expected stopped activity on secondary display"");
        lockScreenSession.enterAndConfirmLockCredential();
        mWmState.waitAndAssertKeyguardGone();
        mWmState.assertVisibility(DISMISS_KEYGUARD_ACTIVITY, true);
    }"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplayLockedKeyguardTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.server.wm.MultiDisplayLockedKeyguardTests"	"testDismissKeyguard_whileOccluded_secondaryDisplay"	"CtsWindowManagerDeviceTestCases"	"1: ui"	"public void testDismissKeyguard_whileOccluded_secondaryDisplay() {
        final LockScreenSession lockScreenSession =
                mObjectTracker.manage(new LockScreenSession(FLAG_REMOVE_ACTIVITIES_ON_CLOSE));
        lockScreenSession.setLockCredential();

        final DisplayContent newDisplay = createManagedVirtualDisplaySession()
                .setPublicDisplay(true)
                .createDisplay();

        lockScreenSession.gotoKeyguard();
        mWmState.assertKeyguardShowingAndNotOccluded();
        launchActivity(SHOW_WHEN_LOCKED_ACTIVITY);
        mWmState.computeState(SHOW_WHEN_LOCKED_ACTIVITY);
        mWmState.assertVisibility(SHOW_WHEN_LOCKED_ACTIVITY, true);
        getLaunchActivityBuilder().setUseInstrumentation()
                .setTargetActivity(DISMISS_KEYGUARD_ACTIVITY).setNewTask(true)
                .setMultipleTask(true).setDisplayId(newDisplay.mId)
                .setWaitForLaunched(false).execute();
        waitAndAssertActivityState(DISMISS_KEYGUARD_ACTIVITY, STATE_STOPPED,
                ""Expected stopped activity on secondary display"");
        lockScreenSession.enterAndConfirmLockCredential();
        mWmState.waitAndAssertKeyguardGone();
        mWmState.computeState(DISMISS_KEYGUARD_ACTIVITY);
        mWmState.assertVisibility(DISMISS_KEYGUARD_ACTIVITY, true);
        mWmState.assertVisibility(SHOW_WHEN_LOCKED_ACTIVITY, true);
    }
}"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/MultiDisplayLockedKeyguardTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.thermal.cts.NativeThermalTest"	"nativeTestRegisterThermalStatusListener"	"CtsThermalTestCases"	"1: ui"	"/*
 *.
 */

package android.thermal.cts;

import android.content.Context;
import android.os.PowerManager;
import android.support.test.uiautomator.UiDevice;
import androidx.test.InstrumentationRegistry;
import androidx.test.runner.AndroidJUnit4;
import com.google.common.base.Strings;

import org.junit.After;
import org.junit.Before;
import org.junit.runner.RunWith;
import org.junit.Test;

import java.io.IOException;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

import static org.junit.Assert.fail;

/**
 * Tests native thermal API for get current thermal status, register and unregister
 * thermal status listeners.
 */
@RunWith(AndroidJUnit4.class)
public class NativeThermalTest {
    private UiDevice mUiDevice;
    private Executor mExec = Executors.newSingleThreadExecutor();

    private native String nativeTestGetCurrentThermalStatus(int level);
    private native String nativeTestRegisterThermalStatusListener();
    private native String nativeTestThermalStatusRegisterNullListener();
    private native String nativeTestThermalStatusListenerDoubleRegistration();
    private native String nativeTestGetThermalHeadroom();

    @Before
    public void setUp() throws Exception {
        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
    }

    @After
    public void tearDown() throws Exception {
        mUiDevice.executeShellCommand(""cmd thermalservice reset"");
    }

    /**
     * Helper function to set override status
     */
    public void setOverrideStatus (int level)  throws Exception {
        mUiDevice.executeShellCommand(""cmd thermalservice override-status "" + level);
    }

    /**
     * Confirm that we can get thermal status.
     *
     * @throws Exception
     */"	"/home/gpoor/cts-12-source/cts/tests/tests/libthermalndk/src/android/thermal/cts/NativeThermalTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.thermal.cts.NativeThermalTest"	"testGetThermalHeadroom"	"CtsThermalTestCases"	"1: system"	"public void testGetThermalHeadroom() throws Exception {
        final String failureMessage = nativeTestGetThermalHeadroom();
        if (!Strings.isNullOrEmpty(failureMessage)) {
            fail(failureMessage);
        }
    }

    static {
        System.loadLibrary(""ctsthermal_jni"");
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/libthermalndk/src/android/thermal/cts/NativeThermalTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.location.cts.fine.GeofencingTest"	"currentTimeMillis"	"CtsLocationFineTestCases"	"2: ui system"	"/*
 *.
 */

package android.location.cts.fine;

import static android.location.LocationManager.FUSED_PROVIDER;

import static com.android.compatibility.common.util.LocationUtils.createLocation;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.fail;

import android.app.PendingIntent;
import android.content.Context;
import android.content.Intent;
import android.location.Criteria;
import android.location.LocationManager;
import android.location.cts.common.ProximityPendingIntentCapture;
import android.util.Log;

import androidx.test.core.app.ApplicationProvider;
import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.LocationUtils;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.Objects;

@RunWith(AndroidJUnit4.class)
public class GeofencingTest {

    private static final String TAG = ""GeofenceManagerTest"";

    private static final long TIMEOUT_MS = 5000;
    private static final long FAILURE_TIMEOUT_MS = 200;

    private static final String TEST_PROVIDER = ""test_provider"";

    private Context mContext;
    private LocationManager mManager;

    @Before
    public void setUp() throws Exception {
        LocationUtils.registerMockLocationProvider(InstrumentationRegistry.getInstrumentation(),
                true);

        long seed = System.currentTimeMillis();
        Log.i(TAG, ""location random seed: "" + seed);

        mContext = ApplicationProvider.getApplicationContext();
        mManager = Objects.requireNonNull(mContext.getSystemService(LocationManager.class));

        for (String provider : mManager.getAllProviders()) {
            mManager.removeTestProvider(provider);
        }

        mManager.addTestProvider(TEST_PROVIDER,
                true,
                false,
                true,
                false,
                false,
                false,
                false,
                Criteria.POWER_MEDIUM,
                Criteria.ACCURACY_FINE);
        mManager.setTestProviderEnabled(TEST_PROVIDER, true);
    }

    @After
    public void tearDown() throws Exception {
        if (mManager != null) {
            for (String provider : mManager.getAllProviders()) {
                mManager.removeTestProvider(provider);
            }
        }

        LocationUtils.registerMockLocationProvider(InstrumentationRegistry.getInstrumentation(),
                false);
    }"	"/home/gpoor/cts-12-source/cts/tests/location/location_fine/src/android/location/cts/fine/GeofencingTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.database.sqlite.cts.SQLiteCursorTest"	"testConstructor"	"CtsDatabaseTestCases"	"1: direct"	"public void testConstructor() {
        SQLiteDirectCursorDriver cursorDriver = new SQLiteDirectCursorDriver(mDatabase,
                TEST_SQL, TABLE_NAME, null);
        try {
            new SQLiteCursor(mDatabase, cursorDriver, TABLE_NAME, null);
            fail(""constructor didn't throw IllegalArgumentException when SQLiteQuery is null"");
        } catch (IllegalArgumentException e) {
        }

        // get SQLiteCursor by querying database
        SQLiteCursor cursor = getCursor();
        assertNotNull(cursor);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/database/src/android/database/sqlite/cts/SQLiteCursorTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.provider.cts.SettingsPanelTest"	"isCar"	"CtsProviderTestCases"	"2: ui system"	"/*
 *.
 */

package android.provider.cts;

import static com.google.common.truth.Truth.assertThat;
import static org.junit.Assume.assumeFalse;
import static org.junit.Assume.assumeTrue;

import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.provider.Settings;
import android.support.test.uiautomator.By;
import android.support.test.uiautomator.UiDevice;
import android.support.test.uiautomator.UiObject2;
import android.support.test.uiautomator.Until;

import com.android.compatibility.common.util.RequiredServiceRule;

import androidx.test.InstrumentationRegistry;
import androidx.test.filters.MediumTest;
import androidx.test.runner.AndroidJUnit4;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.Arrays;

/**
 * Tests related SettingsPanels:
 *
 * atest SettingsPanelTest
 */
@MediumTest
@RunWith(AndroidJUnit4.class)
public class SettingsPanelTest {

    private static final int TIMEOUT = 8000;

    private static final String RESOURCE_DONE = ""done"";
    private static final String RESOURCE_SEE_MORE = ""see_more"";
    private static final String RESOURCE_TITLE = ""panel_title"";

    private String mSettingsPackage;
    private String mLauncherPackage;

    private Context mContext;
    private boolean mHasTouchScreen;
    private boolean mHasBluetooth;

    private UiDevice mDevice;

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getTargetContext();
        mDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());

        final PackageManager packageManager = mContext.getPackageManager();

        mHasTouchScreen = packageManager.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN)
                || packageManager.hasSystemFeature(PackageManager.FEATURE_FAKETOUCH);
        mHasBluetooth = packageManager.hasSystemFeature(PackageManager.FEATURE_BLUETOOTH);

        Intent launcherIntent = new Intent(Intent.ACTION_MAIN);
        launcherIntent.addCategory(Intent.CATEGORY_HOME);
        mLauncherPackage = packageManager.resolveActivity(launcherIntent,
                PackageManager.MATCH_DEFAULT_ONLY).activityInfo.packageName;

        Intent settingsIntent = new Intent(android.provider.Settings.ACTION_SETTINGS);
        mSettingsPackage = packageManager.resolveActivity(settingsIntent,
                PackageManager.MATCH_DEFAULT_ONLY).activityInfo.packageName;

        assumeFalse(""Skipping test: Auto does not support provider android.settings.panel"", isCar());
        assumeFalse(
            ""Skipping test: Watch does not support provider android.settings.panel"", isWatch());
    }

    @After
    public void cleanUp() {
        mDevice.pressHome();
        mDevice.wait(Until.hasObject(By.pkg(mLauncherPackage).depth(0)), TIMEOUT);
    }

    // Check correct package is opened"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/SettingsPanelTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.provider.cts.SettingsPanelTest"	"isNull"	"CtsProviderTestCases"	"2: ui ui ui system"	"public void wifiPanel_seeMoreButton_launchesIntoSettings() {
        // Launch panel
        launchWifiPanel();
        String currentPackage = mDevice.getCurrentPackageName();
        assertThat(currentPackage).isEqualTo(mSettingsPackage);

        // Click the see more button
        assumeTrue(mHasTouchScreen);
        pressSeeMore();

        UiObject2 titleView = mDevice.findObject(By.res(mSettingsPackage, RESOURCE_TITLE));
        assertThat(titleView).isNull();
    }

    private void launchVolumePanel() {
        launchPanel(Settings.Panel.ACTION_VOLUME);
    }

    private void launchInternetPanel() {
        launchPanel(Settings.Panel.ACTION_INTERNET_CONNECTIVITY);
    }

    private void launchNfcPanel() {
        assumeTrue(mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_NFC));
        launchPanel(Settings.Panel.ACTION_NFC);
    }

    private void launchWifiPanel() {
        assumeTrue(mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WIFI));
        launchPanel(Settings.Panel.ACTION_WIFI);
    }

    private void launchPanel(String action) {
        // Start from the home screen
        mDevice.pressHome();
        mDevice.wait(Until.hasObject(By.pkg(mLauncherPackage).depth(0)), TIMEOUT);

        Intent intent = new Intent(action);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK
                | Intent.FLAG_ACTIVITY_CLEAR_TASK);    // Clear out any previous instances
        mContext.startActivity(intent);

        // Wait for the app to appear
        mDevice.wait(Until.hasObject(By.pkg(mSettingsPackage).depth(0)), TIMEOUT);
    }

    private void pressDone() {
        if (mHasTouchScreen) {
            mDevice.findObject(By.res(mSettingsPackage, RESOURCE_DONE)).click();
            mDevice.wait(Until.hasObject(By.pkg(mLauncherPackage).depth(0)), TIMEOUT);
        } else {
            mDevice.pressBack();
        }
    }

    private void pressSeeMore() {
        mDevice.findObject(By.res(mSettingsPackage, RESOURCE_SEE_MORE)).click();
        mDevice.wait(Until.hasObject(By.pkg(mSettingsPackage).depth(0)), TIMEOUT);
    }

    private boolean isCar() {
        PackageManager pm = mContext.getPackageManager();
        return pm.hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);
    }

    private boolean isWatch() {
      return mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH);
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/SettingsPanelTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.delegate.AppRestrictionsIsCallerDelegateHelper"	"isCallerApplicationRestrictionsManagingPackage"	""	"1: system"	"public void test/*
 *.
 */

package com.android.cts.delegate;

import static com.google.common.truth.Truth.assertThat;

import android.app.admin.DevicePolicyManager;
import android.test.InstrumentationTestCase;

/**
 *  A helper for testing the {@link
 *  DevicePolicyManager#isCallerApplicationRestrictionsManagingPackage()} method.
 *  <p>The method names start with ""test"" to be recognized by {@link InstrumentationTestCase}.
 */
public class AppRestrictionsIsCallerDelegateHelper extends InstrumentationTestCase {

    private DevicePolicyManager mDevicePolicyManager;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mDevicePolicyManager =
            getInstrumentation().getContext().getSystemService(DevicePolicyManager.class);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DelegateApp/src/com/android/cts/delegate/AppRestrictionsIsCallerDelegateHelper.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.app.cts.AlertDialog_BuilderCursorTest"	"AlertDialog_BuilderCursorTest"	"CtsAppTestCases"	"1: ui"	"public void test/*
 *.
 */

package android.app.cts;

import static org.mockito.Mockito.*;

import android.app.AlertDialog;
import android.app.AlertDialog.Builder;
import android.app.Instrumentation;
import android.app.stubs.DialogStubActivity;
import android.content.ContentValues;
import android.content.Context;
import android.content.DialogInterface;
import android.content.DialogInterface.OnClickListener;
import android.content.DialogInterface.OnMultiChoiceClickListener;
import android.database.Cursor;
import android.database.sqlite.SQLiteCursor;
import android.database.sqlite.SQLiteDatabase;
import android.test.ActivityInstrumentationTestCase2;
import android.test.suitebuilder.annotation.MediumTest;
import android.widget.ListView;

import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.PollingCheck;

import java.io.File;

@MediumTest
public class AlertDialog_BuilderCursorTest
        extends ActivityInstrumentationTestCase2<DialogStubActivity> {
    private Builder mBuilder;
    private Context mContext;
    private Instrumentation mInstrumentation;
    private AlertDialog mDialog;
    private ListView mListView;

    private static final String TEXT_COLUMN_NAME = ""text"";
    private static final String CHECKED_COLUMN_NAME = ""checked"";

    private String[] mTextContent;
    private boolean[] mCheckedContent;

    private String[] mProjectionWithChecked;
    private String[] mProjectionWithoutChecked;

    private SQLiteDatabase mDatabase;
    private File mDatabaseFile;
    private Cursor mCursor;

    private OnClickListener mOnClickListener = mock(OnClickListener.class);

    /**
     * Multi-choice click listener that is registered on our {@link AlertDialog} when it's in
     * multi-choide mode. Note that this needs to be a separate class that is also protected (not
     * private) so that Mockito can ""spy"" on it.
     */
    protected class MultiChoiceClickListener implements OnMultiChoiceClickListener {
        private boolean[] mCheckedTracker;

        public MultiChoiceClickListener(boolean[] checkedTracker) {
            mCheckedTracker = checkedTracker;
        }

        @Override
        public void onClick(DialogInterface dialog, int which,
                boolean isChecked) {
            // Update the underlying database with the new checked
            // state for the specific row
            mCursor.moveToPosition(which);
            ContentValues valuesToUpdate = new ContentValues();
            valuesToUpdate.put(CHECKED_COLUMN_NAME, isChecked ? 1 : 0);
            mDatabase.update(""test"", valuesToUpdate,
                    TEXT_COLUMN_NAME + "" = ?"",
                    new String[] { mCursor.getString(1) } );
            mCursor.requery();
            mCheckedTracker[which] = isChecked;
        }
    }

    public AlertDialog_BuilderCursorTest() {
        super(""android.app.stubs"", DialogStubActivity.class);
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mBuilder = null;
        mInstrumentation = getInstrumentation();
        mContext = getActivity();

        PollingCheck.waitFor(() -> getActivity().hasWindowFocus());

        mListView = null;
        mDialog = null;

        // Local test data for the tests
        mTextContent = new String[] { ""Adele"", ""Beyonce"", ""Ciara"", ""Dido"" };
        mCheckedContent = new boolean[] { false, false, true, false };

        // Two projections - one with ""checked"" column and one without
        mProjectionWithChecked = new String[] {
                ""_id"",                       // 0
                TEXT_COLUMN_NAME,            // 1
                CHECKED_COLUMN_NAME          // 2
        };
        mProjectionWithoutChecked = new String[] {
                ""_id"",                       // 0
                TEXT_COLUMN_NAME             // 1
        };

        File dbDir = mContext.getDir(""tests"", Context.MODE_PRIVATE);
        mDatabaseFile = new File(dbDir, ""database_alert_dialog_test.db"");
        if (mDatabaseFile.exists()) {
            mDatabaseFile.delete();
        }
        mDatabase = SQLiteDatabase.openOrCreateDatabase(mDatabaseFile.getPath(), null);
        assertNotNull(mDatabase);
        // Create and populate a test table
        mDatabase.execSQL(
                ""CREATE TABLE test (_id INTEGER PRIMARY KEY, "" + TEXT_COLUMN_NAME +
                        "" TEXT, "" + CHECKED_COLUMN_NAME + "" INTEGER);"");
        for (int i = 0; i < mTextContent.length; i++) {
            mDatabase.execSQL(""INSERT INTO test ("" + TEXT_COLUMN_NAME + "", "" +
                    CHECKED_COLUMN_NAME + "") VALUES ('"" + mTextContent[i] + ""', "" +
                    (mCheckedContent[i] ? ""1"" : ""0"") + "");"");
        }
    }

    @Override
    protected void tearDown() throws Exception {
        if (mCursor != null) {
            // Close the cursor on the UI thread as the list view in the alert dialog
            // will get notified of any change to the underlying cursor.
            InstrumentationRegistry.getInstrumentation().runOnMainSync(
                    () -> {
                        mCursor.close();
                        mCursor = null;
                    });
        }
        if (mDatabase != null) {
            mDatabase.close();
        }
        if (mDatabaseFile != null) {
            mDatabaseFile.delete();
        }

        super.tearDown();
    }"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/AlertDialog_BuilderCursorTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.app.cts.AlertDialog_BuilderCursorTest"	"testSetCursor"	"CtsAppTestCases"	"2: ui interaction"	"public void testSetCursor() throws Throwable {
        // Use a projection without ""checked"" column
        mCursor = mDatabase.query(""test"", mProjectionWithoutChecked,
                null, null, null, null, null);
        assertNotNull(mCursor);

        runTestOnUiThread(
                () -> {
                    mBuilder = new Builder(mContext);
                    mBuilder.setCursor(mCursor, mOnClickListener, TEXT_COLUMN_NAME);
                    mDialog = mBuilder.show();
                    mListView = mDialog.getListView();
                    mListView.performItemClick(null, 0, 0);
                });
        mInstrumentation.waitForIdleSync();
        final SQLiteCursor selected = (SQLiteCursor) mListView.getSelectedItem();
        assertEquals(mCursor.getString(1), selected.getString(1));
        verify(mOnClickListener, times(1)).onClick(mDialog, 0);
        verifyNoMoreInteractions(mOnClickListener);
    }"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/AlertDialog_BuilderCursorTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.app.cts.AlertDialog_BuilderCursorTest"	"testSetSingleChoiceItemsWithParamCursor"	"CtsAppTestCases"	"2: ui interaction"	"public void testSetSingleChoiceItemsWithParamCursor() throws Throwable {
        // Use a projection without ""checked"" column
        mCursor = mDatabase.query(""test"", mProjectionWithoutChecked,
                null, null, null, null, null);
        assertNotNull(mCursor);

        runTestOnUiThread(
                () -> {
                    mBuilder = new Builder(mContext);
                    mBuilder.setSingleChoiceItems(mCursor, 0, TEXT_COLUMN_NAME, mOnClickListener);
                    mDialog = mBuilder.show();
                    mListView = mDialog.getListView();
                    mListView.performItemClick(null, 0, 0);
                });
        mInstrumentation.waitForIdleSync();
        final SQLiteCursor selected = (SQLiteCursor) mListView.getSelectedItem();
        assertEquals(mCursor.getString(1), selected.getString(1));
        verify(mOnClickListener, times(1)).onClick(mDialog, 0);
        verifyNoMoreInteractions(mOnClickListener);
    }"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/AlertDialog_BuilderCursorTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.app.cts.AlertDialog_BuilderCursorTest"	"testSetMultiChoiceItemsWithParamCursor"	"CtsAppTestCases"	"2: ui interaction"	"public void testSetMultiChoiceItemsWithParamCursor() throws Throwable {
        mCursor = mDatabase.query(""test"", mProjectionWithChecked,
                null, null, null, null, null);
        assertNotNull(mCursor);

        final boolean[] checkedTracker = mCheckedContent.clone();
        final OnMultiChoiceClickListener mockMultiChoiceClickListener =
                spy(new MultiChoiceClickListener(checkedTracker));
        runTestOnUiThread(
                () -> {
                    mBuilder = new Builder(mContext);
                    mBuilder.setMultiChoiceItems(mCursor, CHECKED_COLUMN_NAME, TEXT_COLUMN_NAME,
                            mockMultiChoiceClickListener);
                    mDialog = mBuilder.show();
                    mListView = mDialog.getListView();
                    mListView.performItemClick(null, 0, 0);
                });
        mInstrumentation.waitForIdleSync();

        SQLiteCursor selected = (SQLiteCursor) mListView.getSelectedItem();
        assertEquals(mCursor.getString(0), selected.getString(0));
        verify(mockMultiChoiceClickListener, times(1)).onClick(mDialog, 0, true);
        // Verify that our multi-choice listener was invoked to update our tracker array
        assertTrue(checkedTracker[0]);
        assertFalse(checkedTracker[1]);
        assertTrue(checkedTracker[2]);
        assertFalse(checkedTracker[3]);

        runTestOnUiThread(() -> mListView.performItemClick(null, 1, 1));
        mInstrumentation.waitForIdleSync();

        selected = (SQLiteCursor) mListView.getSelectedItem();
        assertEquals(mCursor.getString(1), selected.getString(1));
        verify(mockMultiChoiceClickListener, times(1)).onClick(mDialog, 1, true);
        // Verify that our multi-choice listener was invoked to update our tracker array
        assertTrue(checkedTracker[0]);
        assertTrue(checkedTracker[1]);
        assertTrue(checkedTracker[2]);
        assertFalse(checkedTracker[3]);

        verifyNoMoreInteractions(mockMultiChoiceClickListener);
    }
}"	"/home/gpoor/cts-12-source/cts/tests/app/src/android/app/cts/AlertDialog_BuilderCursorTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.translation.cts.CtsTestIme"	"register"	"CtsTranslationTestCases"	"2: ui system"	"public void test/*
 *.
 */

package android.translation.cts;

import static android.translation.cts.Helper.ACTION_ASSERT_UI_TRANSLATION_CALLBACK_ON_FINISH;
import static android.translation.cts.Helper.ACTION_ASSERT_UI_TRANSLATION_CALLBACK_ON_PAUSE;
import static android.translation.cts.Helper.ACTION_ASSERT_UI_TRANSLATION_CALLBACK_ON_RESUME;
import static android.translation.cts.Helper.ACTION_ASSERT_UI_TRANSLATION_CALLBACK_ON_START;
import static android.translation.cts.Helper.ACTION_REGISTER_UI_TRANSLATION_CALLBACK;
import static android.translation.cts.Helper.ACTION_UNREGISTER_UI_TRANSLATION_CALLBACK;
import static android.translation.cts.Helper.EXTRA_FINISH_COMMAND;
import static android.translation.cts.Helper.EXTRA_SOURCE_LOCALE;
import static android.translation.cts.Helper.EXTRA_TARGET_LOCALE;
import static android.translation.cts.Helper.EXTRA_VERIFY_RESULT;

import android.app.PendingIntent;
import android.app.PendingIntent.CanceledException;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.icu.util.ULocale;
import android.inputmethodservice.InputMethodService;
import android.view.View;
import android.view.inputmethod.EditorInfo;
import android.view.translation.UiTranslationManager;
import android.view.translation.UiTranslationStateCallback;
import android.widget.LinearLayout;
import android.util.Log;
import android.util.Pair;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;

/**
 * Implementation of {@link InputMethodService} used in CTS tests.
 */
public final class CtsTestIme extends InputMethodService {

    private static final String TAG = ""CtsTestIme"";

    static String IME_SERVICE_PACKAGE = ""android.translation.cts"";

    private Context mContext;
    private FakeTranslationStateCallback mCallback;
    private CommandReceiver mReceiver;

    @Override
    public View onCreateInputView() {
        return new LinearLayout(this);
    }

    @Override
    public void onCreate() {
        super.onCreate();
        mContext = getApplicationContext();
        if (mReceiver == null) {
            mReceiver = new CommandReceiver(mContext);
            mReceiver.register();
        }
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        if (mReceiver != null) {
            mReceiver.unRegister();
            mReceiver = null;
        }
    }

    void registerUiTranslationStateCallback(Intent intent) {
        final UiTranslationManager manager = mContext.getSystemService(UiTranslationManager.class);
        mCallback = new FakeTranslationStateCallback();
        final Executor executor = Executors.newSingleThreadExecutor();
        manager.registerUiTranslationStateCallback(executor, mCallback);

        notifyCommandDone(intent, /* resultIntent= */ null);
    }

    void unregisterUiTranslationStateCallback(Intent intent) {
        final UiTranslationManager manager = mContext.getSystemService(UiTranslationManager.class);
        manager.unregisterUiTranslationStateCallback(mCallback);

        notifyCommandDone(intent, /* resultIntent= */ null);
    }

    void assertOnStart(Intent intent) {
        final Pair<ULocale, ULocale> startedLanguagePair = mCallback.getStartedLanguagePair();
        final Intent result = new Intent();
        result.putExtra(EXTRA_SOURCE_LOCALE, startedLanguagePair.first);
        result.putExtra(EXTRA_TARGET_LOCALE, startedLanguagePair.second);
        notifyCommandDone(intent, result);
    }

    void assertOnFinish(Intent intent) {
        final Intent result = new Intent();
        result.putExtra(EXTRA_VERIFY_RESULT, mCallback.isOnFinishedCalled());
        notifyCommandDone(intent, result);
    }

    void assertOnResume(Intent intent) {
        final Intent result = new Intent();
        result.putExtra(EXTRA_VERIFY_RESULT, mCallback.isOnResumedCalled());
        notifyCommandDone(intent, result);
    }

    void assertOnPause(Intent intent) {
        final Intent result = new Intent();
        result.putExtra(EXTRA_VERIFY_RESULT, mCallback.isOnPausedCalled());
        notifyCommandDone(intent, result);
    }

    private void notifyCommandDone(Intent sourceIntent, Intent resultIntent) {
        final PendingIntent pendingIntent = sourceIntent.getParcelableExtra(EXTRA_FINISH_COMMAND);
        if (pendingIntent != null) {
            try {
                final String action = sourceIntent.getAction();
                switch(action) {
                    case ACTION_REGISTER_UI_TRANSLATION_CALLBACK:
                    case ACTION_UNREGISTER_UI_TRANSLATION_CALLBACK:
                        pendingIntent.send();
                        break;
                    case ACTION_ASSERT_UI_TRANSLATION_CALLBACK_ON_START:
                    case ACTION_ASSERT_UI_TRANSLATION_CALLBACK_ON_FINISH:
                    case ACTION_ASSERT_UI_TRANSLATION_CALLBACK_ON_RESUME:
                    case ACTION_ASSERT_UI_TRANSLATION_CALLBACK_ON_PAUSE:
                        if (resultIntent != null) {
                            pendingIntent.send(mContext, 0, resultIntent);
                        } else {
                            Log.w(TAG, ""Should have resultIntent for "" + action);
                        }
                        break;
                }
            } catch (CanceledException e) {
                Log.w(TAG, ""Pending intent "" + pendingIntent + "" canceled"");
            }
        }
        mCallback.resetStates();
    }

    private final class CommandReceiver extends BroadcastReceiver {

        Context mContext;

        CommandReceiver(Context context) {
            mContext = context;
        }

        @Override
        public void onReceive(Context context, Intent intent) {
            final String action = intent.getAction();
            switch(action) {
                case ACTION_REGISTER_UI_TRANSLATION_CALLBACK:
                    registerUiTranslationStateCallback(intent);
                    break;
                case ACTION_UNREGISTER_UI_TRANSLATION_CALLBACK:
                    unregisterUiTranslationStateCallback(intent);
                    break;
                case ACTION_ASSERT_UI_TRANSLATION_CALLBACK_ON_START:
                    assertOnStart(intent);
                    break;
                case ACTION_ASSERT_UI_TRANSLATION_CALLBACK_ON_FINISH:
                    assertOnFinish(intent);
                    break;
                case ACTION_ASSERT_UI_TRANSLATION_CALLBACK_ON_RESUME:
                    assertOnResume(intent);
                    break;
                case ACTION_ASSERT_UI_TRANSLATION_CALLBACK_ON_PAUSE:
                    assertOnPause(intent);
                    break;
            }
        }

        void register() {
            final IntentFilter filter = new IntentFilter();
            filter.addAction(ACTION_REGISTER_UI_TRANSLATION_CALLBACK);
            filter.addAction(ACTION_UNREGISTER_UI_TRANSLATION_CALLBACK);
            filter.addAction(ACTION_ASSERT_UI_TRANSLATION_CALLBACK_ON_START);
            filter.addAction(ACTION_ASSERT_UI_TRANSLATION_CALLBACK_ON_FINISH);
            filter.addAction(ACTION_ASSERT_UI_TRANSLATION_CALLBACK_ON_RESUME);
            filter.addAction(ACTION_ASSERT_UI_TRANSLATION_CALLBACK_ON_PAUSE);
            mContext.registerReceiver(this, filter);
        }

        void unRegister() {
            mContext.unregisterReceiver(this);
        }
    }
}"	"/home/gpoor/cts-12-source/cts/tests/translation/src/android/translation/cts/CtsTestIme.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.net.wifi.rtt.cts.WifiRttTest"	"testRangingToTest11mcAp"	"CtsWifiTestCases"	"2: direct ui"	"public void testRangingToTest11mcAp() throws InterruptedException {
        if (!shouldTestWifiRtt(getContext())) {
            return;
        }

        // Scan for IEEE 802.11mc supporting APs
        ScanResult testAp = scanForTest11mcCapableAp(NUM_SCANS_SEARCHING_FOR_IEEE80211MC_AP);
        assertNotNull(
                ""Cannot find any test APs which support RTT / IEEE 802.11mc - please verify that ""
                        + ""your test setup includes them!"", testAp);

        // Perform RTT operations
        RangingRequest.Builder builder = new RangingRequest.Builder();
        builder.addAccessPoint(testAp);
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            builder.setRttBurstSize(RangingRequest.getMaxRttBurstSize());
            assertTrue(RangingRequest.getDefaultRttBurstSize()
                    >= RangingRequest.getMinRttBurstSize());
            assertTrue(RangingRequest.getDefaultRttBurstSize()
                    <= RangingRequest.getMaxRttBurstSize());
        }
        RangingRequest request = builder.build();
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            assertEquals(1, request.getRttResponders().size());
        }

        List<RangingResult> allResults = new ArrayList<>();
        int numFailures = 0;
        int distanceSum = 0;
        int distanceMin = 0;
        int distanceMax = 0;
        int[] statuses = new int[NUM_OF_RTT_ITERATIONS];
        int[] distanceMms = new int[NUM_OF_RTT_ITERATIONS];
        int[] distanceStdDevMms = new int[NUM_OF_RTT_ITERATIONS];
        int[] rssis = new int[NUM_OF_RTT_ITERATIONS];
        int[] numAttempted = new int[NUM_OF_RTT_ITERATIONS];
        int[] numSuccessful = new int[NUM_OF_RTT_ITERATIONS];
        long[] timestampsMs = new long[NUM_OF_RTT_ITERATIONS];
        byte[] lastLci = null;
        byte[] lastLcr = null;
        for (int i = 0; i < NUM_OF_RTT_ITERATIONS; ++i) {
            ResultCallback callback = new ResultCallback();
            mWifiRttManager.startRanging(request, mExecutor, callback);
            assertTrue(""Wi-Fi RTT results: no callback on iteration "" + i,
                    callback.waitForCallback());

            List<RangingResult> currentResults = callback.getResults();
            assertNotNull(""Wi-Fi RTT results: null results (onRangingFailure) on iteration "" + i,
                    currentResults);
            assertEquals(""Wi-Fi RTT results: unexpected # of results (expect 1) on iteration "" + i,
                    1, currentResults.size());
            RangingResult result = currentResults.get(0);
            assertEquals(""Wi-Fi RTT results: invalid result (wrong BSSID) entry on iteration "" + i,
                    result.getMacAddress().toString(), testAp.BSSID);
            assertNull(""Wi-Fi RTT results: invalid result (non-null PeerHandle) entry on iteration ""
                    + i, result.getPeerHandle());

            allResults.add(result);
            int status = result.getStatus();
            statuses[i] = status;
            if (status == RangingResult.STATUS_SUCCESS) {
                if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
                    assertEquals(
                            ""Wi-Fi RTT results: invalid result (wrong rttBurstSize) entry on ""
                                    + ""iteration ""
                                    + i,
                            result.getNumAttemptedMeasurements(),
                            RangingRequest.getMaxRttBurstSize());
                    assertTrue(""Wi-Fi RTT results: should be a 802.11MC measurement"",
                            result.is80211mcMeasurement());
                }
                distanceSum += result.getDistanceMm();
                if (i == 0) {
                    distanceMin = result.getDistanceMm();
                    distanceMax = result.getDistanceMm();
                } else {
                    distanceMin = Math.min(distanceMin, result.getDistanceMm());
                    distanceMax = Math.max(distanceMax, result.getDistanceMm());
                }

                assertTrue(""Wi-Fi RTT results: invalid RSSI on iteration "" + i,
                        result.getRssi() >= MIN_VALID_RSSI);

                distanceMms[i - numFailures] = result.getDistanceMm();
                distanceStdDevMms[i - numFailures] = result.getDistanceStdDevMm();
                rssis[i - numFailures] = result.getRssi();
                numAttempted[i - numFailures] = result.getNumAttemptedMeasurements();
                numSuccessful[i - numFailures] = result.getNumSuccessfulMeasurements();
                timestampsMs[i - numFailures] = result.getRangingTimestampMillis();

                byte[] currentLci = result.getLci();
                byte[] currentLcr = result.getLcr();
                if (i - numFailures > 0) {
                    assertTrue(""Wi-Fi RTT results: invalid result (LCI mismatch) on iteration "" + i,
                            Arrays.equals(currentLci, lastLci));
                    assertTrue(""Wi-Fi RTT results: invalid result (LCR mismatch) on iteration "" + i,
                            Arrays.equals(currentLcr, lastLcr));
                }
                lastLci = currentLci;
                lastLcr = currentLcr;
            } else {
                numFailures++;
            }
            // Sleep a while to avoid stress AP.
            Thread.sleep(intervalMs);
        }

        // Save results to log
        int numGoodResults = NUM_OF_RTT_ITERATIONS - numFailures;
        DeviceReportLog reportLog = new DeviceReportLog(TAG, ""testRangingToTestAp"");
        reportLog.addValues(""status_codes"", statuses, ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""distance_mm"", Arrays.copyOf(distanceMms, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""distance_stddev_mm"", Arrays.copyOf(distanceStdDevMms, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""rssi_dbm"", Arrays.copyOf(rssis, numGoodResults), ResultType.NEUTRAL,
                ResultUnit.NONE);
        reportLog.addValues(""num_attempted"", Arrays.copyOf(numAttempted, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""num_successful"", Arrays.copyOf(numSuccessful, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""timestamps"", Arrays.copyOf(timestampsMs, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.submit();

        // Analyze results
        assertTrue(""Wi-Fi RTT failure rate exceeds threshold: FAIL="" + numFailures + "", ITERATIONS=""
                        + NUM_OF_RTT_ITERATIONS + "", AP RSSI="" + testAp.level
                        + "", AP SSID="" + testAp.SSID,
                numFailures <= NUM_OF_RTT_ITERATIONS * MAX_FAILURE_RATE_PERCENT / 100);
        if (numFailures != NUM_OF_RTT_ITERATIONS) {
            double distanceAvg = (double) distanceSum / (NUM_OF_RTT_ITERATIONS - numFailures);
            assertTrue(""Wi-Fi RTT: Variation (max direction) exceeds threshold, Variation =""
                            + (distanceMax - distanceAvg),
                    (distanceMax - distanceAvg) <= MAX_VARIATION_FROM_AVERAGE_DISTANCE_MM);
            assertTrue(""Wi-Fi RTT: Variation (min direction) exceeds threshold, Variation =""
                            + (distanceAvg - distanceMin),
                    (distanceAvg - distanceMin) <= MAX_VARIATION_FROM_AVERAGE_DISTANCE_MM);
            for (int i = 0; i < numGoodResults; ++i) {
                assertNotSame(""Number of attempted measurements is 0"", 0, numAttempted[i]);
                assertNotSame(""Number of successful measurements is 0"", 0, numSuccessful[i]);
            }
        }
    }

    /**
     * Validate that when a request contains more range operations than allowed (by API) that we
     * get an exception.
     */"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/rtt/cts/WifiRttTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.net.wifi.rtt.cts.WifiRttTest"	"testRangingToTestNon11mcAp"	"CtsWifiTestCases"	"2: direct ui"	"public void testRangingToTestNon11mcAp() throws InterruptedException {
        if (!shouldTestWifiRtt(getContext())
                || !WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            return;
        }

        // Scan for Non-IEEE 802.11mc supporting APs
        ScanResult testAp = scanForTestNon11mcCapableAp(NUM_SCANS_SEARCHING_FOR_IEEE80211MC_AP);
        assertNotNull(
                ""Cannot find any test APs which are Non-IEEE 802.11mc - please verify that""
                        + "" your test setup includes them!"", testAp);

        // Perform RTT operations
        RangingRequest.Builder builder = new RangingRequest.Builder();
        builder.addNon80211mcCapableAccessPoint(testAp);
        builder.setRttBurstSize(RangingRequest.getMaxRttBurstSize());
        RangingRequest request = builder.build();

        List<RangingResult> allResults = new ArrayList<>();
        int numFailures = 0;
        int distanceSum = 0;
        int distanceMin = 0;
        int distanceMax = 0;
        int[] statuses = new int[NUM_OF_RTT_ITERATIONS];
        int[] distanceMms = new int[NUM_OF_RTT_ITERATIONS];
        boolean[] distanceInclusionMap = new boolean[NUM_OF_RTT_ITERATIONS];
        int[] distanceStdDevMms = new int[NUM_OF_RTT_ITERATIONS];
        int[] rssis = new int[NUM_OF_RTT_ITERATIONS];
        int[] numAttempted = new int[NUM_OF_RTT_ITERATIONS];
        int[] numSuccessful = new int[NUM_OF_RTT_ITERATIONS];
        long[] timestampsMs = new long[NUM_OF_RTT_ITERATIONS];
        byte[] lastLci = null;
        byte[] lastLcr = null;
        for (int i = 0; i < NUM_OF_RTT_ITERATIONS; ++i) {
            ResultCallback callback = new ResultCallback();
            mWifiRttManager.startRanging(request, mExecutor, callback);
            assertTrue(""Wi-Fi RTT results: no callback on iteration "" + i,
                    callback.waitForCallback());

            List<RangingResult> currentResults = callback.getResults();
            assertNotNull(
                    ""Wi-Fi RTT results: null results (onRangingFailure) on iteration "" + i,
                    currentResults);
            assertEquals(
                    ""Wi-Fi RTT results: unexpected # of results (expect 1) on iteration "" + i,
                    1, currentResults.size());
            RangingResult result = currentResults.get(0);
            assertEquals(
                    ""Wi-Fi RTT results: invalid result (wrong BSSID) entry on iteration "" + i,
                    result.getMacAddress().toString(), testAp.BSSID);

            assertNull(
                    ""Wi-Fi RTT results: invalid result (non-null PeerHandle) entry on iteration ""
                            + i, result.getPeerHandle());

            allResults.add(result);
            int status = result.getStatus();
            statuses[i] = status;
            if (status == RangingResult.STATUS_SUCCESS) {
                assertFalse(""Wi-Fi RTT results: should not be a 802.11MC measurement"",
                        result.is80211mcMeasurement());
                distanceSum += result.getDistanceMm();

                assertTrue(""Wi-Fi RTT results: invalid RSSI on iteration "" + i,
                        result.getRssi() >= MIN_VALID_RSSI);

                distanceMms[i - numFailures] = result.getDistanceMm();
                distanceStdDevMms[i - numFailures] = result.getDistanceStdDevMm();
                rssis[i - numFailures] = result.getRssi();
                // For one-sided RTT the number of packets attempted in a burst is not available,
                // So we set the result to be the same as used in the request.
                numAttempted[i - numFailures] = request.getRttBurstSize();
                numSuccessful[i - numFailures] = result.getNumSuccessfulMeasurements();
                timestampsMs[i - numFailures] = result.getRangingTimestampMillis();

                byte[] currentLci = result.getLci();
                byte[] currentLcr = result.getLcr();
                if (i - numFailures > 0) {
                    assertTrue(""Wi-Fi RTT results: invalid result (LCI mismatch) on iteration "" + i,
                            Arrays.equals(currentLci, lastLci));
                    assertTrue(""Wi-Fi RTT results: invalid result (LCR mismatch) on iteration "" + i,
                            Arrays.equals(currentLcr, lastLcr));
                }
                lastLci = currentLci;
                lastLcr = currentLcr;
            } else {
                numFailures++;
            }
            // Sleep a while to avoid stress AP.
            Thread.sleep(intervalMs);
        }
        // Save results to log
        int numGoodResults = NUM_OF_RTT_ITERATIONS - numFailures;
        DeviceReportLog reportLog = new DeviceReportLog(TAG, ""testRangingToTestAp"");
        reportLog.addValues(""status_codes"", statuses, ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""distance_mm"", Arrays.copyOf(distanceMms, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""distance_stddev_mm"",
                Arrays.copyOf(distanceStdDevMms, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""rssi_dbm"", Arrays.copyOf(rssis, numGoodResults),
                ResultType.NEUTRAL,
                ResultUnit.NONE);
        reportLog.addValues(""num_attempted"", Arrays.copyOf(numAttempted, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""num_successful"", Arrays.copyOf(numSuccessful, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""timestamps"", Arrays.copyOf(timestampsMs, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.submit();

        /** TODO(b/192909380): enable the performance verification after device fix.
            // Analyze results
            assertTrue(""Wi-Fi RTT failure rate exceeds threshold: FAIL="" + numFailures
                            + "", ITERATIONS=""
                            + NUM_OF_RTT_ITERATIONS + "", AP RSSI="" + testAp.level
                            + "", AP SSID="" + testAp.SSID,
                    numFailures <= NUM_OF_RTT_ITERATIONS * MAX_NON11MC_FAILURE_RATE_PERCENT / 100);

            if (numFailures != NUM_OF_RTT_ITERATIONS) {
                // Calculate an initial average using all measurements to determine distance outliers
                double distanceAvg = (double) distanceSum / (NUM_OF_RTT_ITERATIONS - numFailures);
                // Now figure out the distance outliers and mark them in the distance inclusion map
                int validDistances = 0;
                for (int i = 0; i < (NUM_OF_RTT_ITERATIONS - numFailures); i++) {
                    if (distanceMms[i] - MAX_VARIATION_FROM_AVERAGE_DISTANCE_MM < distanceAvg) {
                        // Distances that are in range for the distribution are included in the map
                        distanceInclusionMap[i] = true;
                        validDistances++;
                    } else {
                        // Distances that are out of range for the distribution are excluded in the map
                        distanceInclusionMap[i] = false;
                    }
                }

                assertTrue(""After fails+outlier removal greater that 50% distances must remain: "" +
                        NUM_OF_RTT_ITERATIONS / 2, validDistances > NUM_OF_RTT_ITERATIONS / 2);

                // Remove the distance outliers and find the new average, min and max.
                distanceSum = 0;
                distanceMax = Integer.MIN_VALUE;
                distanceMin = Integer.MAX_VALUE;
                for (int i = 0; i < (NUM_OF_RTT_ITERATIONS - numFailures); i++) {
                    if (distanceInclusionMap[i]) {
                        distanceSum += distanceMms[i];
                        distanceMin = Math.min(distanceMin, distanceMms[i]);
                        distanceMax = Math.max(distanceMax, distanceMms[i]);
                    }
                }
                distanceAvg = (double) distanceSum / validDistances;
                assertTrue(""Wi-Fi RTT: Variation (max direction) exceeds threshold, Variation =""
                                + (distanceMax - distanceAvg),
                        (distanceMax - distanceAvg) <= MAX_VARIATION_FROM_AVERAGE_DISTANCE_MM);
                assertTrue(""Wi-Fi RTT: Variation (min direction) exceeds threshold, Variation =""
                                + (distanceAvg - distanceMin),
                        (distanceAvg - distanceMin) <= MAX_VARIATION_FROM_AVERAGE_DISTANCE_MM);
                for (int i = 0; i < numGoodResults; ++i) {
                    assertNotSame(""Number of attempted measurements is 0"", 0, numAttempted[i]);
                    assertNotSame(""Number of successful measurements is 0"", 0, numSuccessful[i]);
                }
         */
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/rtt/cts/WifiRttTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.net.wifi.rtt.cts.WifiRttTest"	"testRequestTooLarge"	"CtsWifiTestCases"	"1: ui"	"public void testRequestTooLarge() throws InterruptedException {
        if (!shouldTestWifiRtt(getContext())) {
            return;
        }
        ScanResult testAp = scanForTest11mcCapableAp(NUM_SCANS_SEARCHING_FOR_IEEE80211MC_AP);
        assertNotNull(
                ""Cannot find any test APs which support RTT / IEEE 802.11mc - please verify that ""
                        + ""your test setup includes them!"", testAp);

        RangingRequest.Builder builder = new RangingRequest.Builder();
        List<ScanResult> scanResults = new ArrayList<>();
        for (int i = 0; i < RangingRequest.getMaxPeers() - 2; ++i) {
            scanResults.add(testAp);
        }
        builder.addAccessPoints(scanResults);

        ScanResult testApNon80211mc = null;
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            testApNon80211mc = scanForTestNon11mcCapableAp(NUM_SCANS_SEARCHING_FOR_IEEE80211MC_AP);
        }
        if (testApNon80211mc == null) {
            builder.addAccessPoints(List.of(testAp, testAp, testAp));
        } else {
            builder.addNon80211mcCapableAccessPoints(List.of(testApNon80211mc, testApNon80211mc,
                    testApNon80211mc));
        }

        try {
            mWifiRttManager.startRanging(builder.build(), mExecutor, new ResultCallback());
        } catch (IllegalArgumentException e) {
            return;
        }

        fail(""Did not receive expected IllegalArgumentException when tried to range to too ""
                + ""many peers"");
    }

    /**
     * Verify ResponderLocation API
     */"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/rtt/cts/WifiRttTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.net.wifi.rtt.cts.WifiRttTest"	"testRangingToTestApWithResponderLocation"	"CtsWifiTestCases"	"1: ui"	"public void testRangingToTestApWithResponderLocation() throws InterruptedException {
        if (!shouldTestWifiRtt(getContext())) {
            return;
        }
        // Scan for IEEE 802.11mc supporting APs
        ScanResult testAp = scanForTest11mcCapableAp(NUM_SCANS_SEARCHING_FOR_IEEE80211MC_AP);
        assertNotNull(
                ""Cannot find any test APs which support RTT / IEEE 802.11mc - please verify that ""
                        + ""your test setup includes them!"", testAp);

        // Perform RTT operations
        RangingRequest request = new RangingRequest.Builder().addAccessPoint(testAp).build();
        ResultCallback callback = new ResultCallback();
        mWifiRttManager.startRanging(request, mExecutor, callback);
        assertTrue(""Wi-Fi RTT results: no callback! "",
                callback.waitForCallback());

        RangingResult result = callback.getResults().get(0);
        assertEquals(""Ranging request not success"",
                result.getStatus(), RangingResult.STATUS_SUCCESS);
        ResponderLocation responderLocation = result.getUnverifiedResponderLocation();
        if (responderLocation == null) {
            return;
        }
        assertTrue(""ResponderLocation is not valid"", responderLocation.isLciSubelementValid());

        // Check LCI related APIs
        int exceptionCount = 0;
        int apiCount = 0;
        try {
            apiCount++;
            responderLocation.getLatitudeUncertainty();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getLatitude();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getLongitudeUncertainty();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getLongitude();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getAltitudeType();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getAltitudeUncertainty();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getAltitude();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getDatum();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getRegisteredLocationAgreementIndication();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getLciVersion();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            assertNotNull(responderLocation.toLocation());
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        // If LCI is not valid, all APIs should throw exception, otherwise no exception.
        assertEquals(""Exception number should equal to API number"",
                responderLocation.isLciSubelementValid()? 0 : apiCount, exceptionCount);

        // Verify ZaxisSubelement APIs
        apiCount = 0;
        exceptionCount = 0;

        try {
            apiCount++;
            responderLocation.getExpectedToMove();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }

        try {
            apiCount++;
            responderLocation.getFloorNumber();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }

        try {
            apiCount++;
            responderLocation.getHeightAboveFloorMeters();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }

        try {
            apiCount++;
            responderLocation.getHeightAboveFloorUncertaintyMeters();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        // If Zaxis is not valid, all APIs should throw exception, otherwise no exception.
        assertEquals(""Exception number should equal to API number"",
                responderLocation.isZaxisSubelementValid() ? 0 : apiCount, exceptionCount);
        // Verify civic location
        if (responderLocation.toCivicLocationAddress() == null) {
            assertNull(responderLocation.toCivicLocationSparseArray());
        } else {
            assertNotNull(responderLocation.toCivicLocationSparseArray());
        }
        // Verify map image
        if (responderLocation.getMapImageUri() == null) {
            assertNull(responderLocation.getMapImageMimeType());
        } else {
            assertNotNull(responderLocation.getMapImageMimeType());
        }
        boolean extraInfoOnAssociationIndication =
                responderLocation.getExtraInfoOnAssociationIndication();
        assertNotNull(""ColocatedBSSID list should be nonNull"",
                responderLocation.getColocatedBssids());
    }

    /**
     * Verify ranging request with aware peer Mac address and peer handle.
     */"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/rtt/cts/WifiRttTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.net.wifi.rtt.cts.WifiRttTest"	"testAwareRttWithMacAddress"	"CtsWifiTestCases"	"1: ui"	"public void testAwareRttWithMacAddress() throws InterruptedException {
        if (!(shouldTestWifiRtt(getContext()) && shouldTestWifiAware(getContext()))) {
            return;
        }
        RangingRequest request = new RangingRequest.Builder()
                .addWifiAwarePeer(MAC).build();
        ResultCallback callback = new ResultCallback();
        mWifiRttManager.startRanging(request, mExecutor, callback);
        assertTrue(""Wi-Fi RTT results: no callback"",
                callback.waitForCallback());
        List<RangingResult> rangingResults = callback.getResults();
        assertNotNull(""Wi-Fi RTT results: null results"", rangingResults);
        assertEquals(1, rangingResults.size());
        assertEquals(RangingResult.STATUS_FAIL, rangingResults.get(0).getStatus());
    }

    /**
     * Verify ranging request with aware peer handle.
     */"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/rtt/cts/WifiRttTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.net.wifi.rtt.cts.WifiRttTest"	"testAwareRttWithPeerHandle"	"CtsWifiTestCases"	"1: ui"	"public void testAwareRttWithPeerHandle() throws InterruptedException {
        if (!(shouldTestWifiRtt(getContext()) && shouldTestWifiAware(getContext()))) {
            return;
        }
        PeerHandle peerHandle = mock(PeerHandle.class);
        RangingRequest request = new RangingRequest.Builder()
                .addWifiAwarePeer(peerHandle).build();
        ResultCallback callback = new ResultCallback();
        mWifiRttManager.startRanging(request, mExecutor, callback);
        assertTrue(""Wi-Fi RTT results: no callback"",
                callback.waitForCallback());
        List<RangingResult> rangingResults = callback.getResults();
        assertNotNull(""Wi-Fi RTT results: null results"", rangingResults);
        assertEquals(""Invalid peerHandle should return 0 result"", 0, rangingResults.size());
    }

    /**
     * Test Wi-Fi One-sided RTT ranging operation:
     * - Scan for visible APs for the test AP (which do not support IEEE 802.11mc) and are operating
     * - in the 5GHz band.
     * - Perform N (constant) RTT operations
     * - Remove outliers while insuring greater than 50% of the results still remain
     * - Validate:
     *   - Failure ratio < threshold (constant)
     *   - Result margin < threshold (constant)
     */"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/rtt/cts/WifiRttTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.verifier.usb.device.UsbDeviceTestActivity"	"getAccessoryList"	""	"5: mic interfaces direct ui system"	"public void test/*
 *.
 */

package com.android.cts.verifier.usb.device;

import static com.android.cts.verifier.usb.Util.runAndAssertException;

import static org.junit.Assert.assertArrayEquals;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertTrue;

import android.app.PendingIntent;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.hardware.usb.UsbConfiguration;
import android.hardware.usb.UsbConstants;
import android.hardware.usb.UsbDevice;
import android.hardware.usb.UsbDeviceConnection;
import android.hardware.usb.UsbEndpoint;
import android.hardware.usb.UsbInterface;
import android.hardware.usb.UsbManager;
import android.hardware.usb.UsbRequest;
import android.os.Build;
import android.os.Bundle;
import android.util.ArraySet;
import android.util.Log;
import android.util.Pair;
import android.view.View;
import android.widget.ProgressBar;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

import java.nio.BufferOverflowException;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicInteger;

public class UsbDeviceTestActivity extends PassFailButtons.Activity {
    private static final String ACTION_USB_PERMISSION =
            ""com.android.cts.verifier.usb.device.USB_PERMISSION"";
    private static final String LOG_TAG = UsbDeviceTestActivity.class.getSimpleName();
    private static final int TIMEOUT_MILLIS = 5000;
    private static final int LARGE_BUFFER_SIZE = 124619;

    private UsbManager mUsbManager;
    private BroadcastReceiver mUsbDeviceConnectionReceiver;
    private BroadcastReceiver mUsbDeviceAttachedReceiver;
    private BroadcastReceiver mUsbDevicePermissionReceiver;
    private Thread mTestThread;
    private TextView mStatus;
    private ProgressBar mProgress;

    /**
     * Some N and older accessories do not send a zero sized package after a request that is a
     * multiple of the maximum package size.
     */
    private boolean mDoesCompanionZeroTerminate;

    private static long now() {
        return System.nanoTime() / 1000000;
    }

    /**
     * Check if we should expect a zero sized transfer after a certain sized transfer
     *
     * @param transferSize The size of the previous transfer
     *
     * @return {@code true} if a zero sized transfer is expected
     */
    private boolean isZeroTransferExpected(int transferSize, @NonNull UsbEndpoint ep) {
        return mDoesCompanionZeroTerminate && transferSize % ep.getMaxPacketSize() == 0;
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.usb_main);
        setInfoResources(R.string.usb_device_test, R.string.usb_device_test_info, -1);

        mStatus = (TextView) findViewById(R.id.status);
        mProgress = (ProgressBar) findViewById(R.id.progress_bar);

        mUsbManager = getSystemService(UsbManager.class);

        getPassButton().setEnabled(false);

        IntentFilter filter = new IntentFilter();
        filter.addAction(ACTION_USB_PERMISSION);
        filter.addAction(UsbManager.ACTION_USB_DEVICE_ATTACHED);

        mStatus.setText(R.string.usb_device_test_step1);

        mUsbDeviceConnectionReceiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                synchronized (UsbDeviceTestActivity.this) {
                    UsbDevice device = intent.getParcelableExtra(UsbManager.EXTRA_DEVICE);

                    switch (intent.getAction()) {
                        case UsbManager.ACTION_USB_DEVICE_ATTACHED:
                            if (!AoapInterface.isDeviceInAoapMode(device)) {
                                mStatus.setText(R.string.usb_device_test_step2);
                            }

                            if (getApplicationContext().getApplicationInfo().targetSdkVersion
                                    >= Build.VERSION_CODES.Q) {
                                try {
                                    device.getSerialNumber();
                                    fail(""Serial number could be read"", null);
                                    return;
                                } catch (SecurityException expected) {
                                    // expected as app cannot read serial number without permission
                                }
                            }

                            mUsbManager.requestPermission(device,
                                    PendingIntent.getBroadcast(UsbDeviceTestActivity.this, 0,
                                            new Intent(ACTION_USB_PERMISSION), PendingIntent.FLAG_MUTABLE_UNAUDITED));
                            break;
                        case ACTION_USB_PERMISSION:
                            boolean granted = intent.getBooleanExtra(
                                    UsbManager.EXTRA_PERMISSION_GRANTED, false);

                            if (granted) {
                                if (!AoapInterface.isDeviceInAoapMode(device)) {
                                    mStatus.setText(R.string.usb_device_test_step3);

                                    UsbDeviceConnection connection = mUsbManager.openDevice(device);
                                    try {
                                        makeThisDeviceAnAccessory(connection);
                                    } finally {
                                        connection.close();
                                    }
                                } else {
                                    mStatus.setText(R.string.usb_device_test_step4);
                                    mProgress.setIndeterminate(true);
                                    mProgress.setVisibility(View.VISIBLE);

                                    unregisterReceiver(mUsbDeviceConnectionReceiver);
                                    mUsbDeviceConnectionReceiver = null;

                                    // Do not run test on main thread
                                    mTestThread = new Thread() {
                                        @Override
                                        public void run() {
                                            runTests(device);
                                        }
                                    };

                                    mTestThread.start();
                                }
                            } else {
                                fail(""Permission to connect to "" + device.getProductName()
                                        + "" not granted"", null);
                            }
                            break;
                    }
                }
            }
        };

        registerReceiver(mUsbDeviceConnectionReceiver, filter);
    }

    /**
     * Indicate that the test failed.
     */
    private void fail(@Nullable String s, @Nullable Throwable e) {
        Log.e(LOG_TAG, s, e);
        setTestResultAndFinish(false);
    }

    /**
     * Converts the device under test into an Android accessory. Accessories are USB hosts that are
     * detected on the device side via {@link UsbManager#getAccessoryList()}.
     *
     * @param connection The connection to the USB device
     */
    private void makeThisDeviceAnAccessory(@NonNull UsbDeviceConnection connection) {
        AoapInterface.sendString(connection, AoapInterface.ACCESSORY_STRING_MANUFACTURER,
                ""Android CTS"");
        AoapInterface.sendString(connection, AoapInterface.ACCESSORY_STRING_MODEL,
                ""Android device under CTS test"");
        AoapInterface.sendString(connection, AoapInterface.ACCESSORY_STRING_DESCRIPTION,
                ""Android device running CTS verifier"");
        AoapInterface.sendString(connection, AoapInterface.ACCESSORY_STRING_VERSION, ""2"");
        AoapInterface.sendString(connection, AoapInterface.ACCESSORY_STRING_URI,
                ""https://source.android.com/compatibility/cts/verifier.html"");
        AoapInterface.sendString(connection, AoapInterface.ACCESSORY_STRING_SERIAL, ""0"");
        AoapInterface.sendAoapStart(connection);
    }

    /**
     * Switch to next test.
     *
     * @param connection   Connection to the USB device
     * @param in           The in endpoint
     * @param out          The out endpoint
     * @param nextTestName The name of the new test
     */
    private void nextTest(@NonNull UsbDeviceConnection connection, @NonNull UsbEndpoint in,
            @NonNull UsbEndpoint out, @NonNull CharSequence nextTestName) {
        Log.v(LOG_TAG, ""Finishing previous test"");

        // Make sure name length is not a multiple of 8 to avoid zero-termination issues
        StringBuilder safeNextTestName = new StringBuilder(nextTestName);
        if (nextTestName.length() % 8 == 0) {
            safeNextTestName.append(' ');
        }

        // Send name of next test
        assertTrue(safeNextTestName.length() <= Byte.MAX_VALUE);
        ByteBuffer nextTestNameBuffer = Charset.forName(""UTF-8"")
                .encode(CharBuffer.wrap(safeNextTestName));
        byte[] sizeBuffer = { (byte) nextTestNameBuffer.limit() };
        int numSent = connection.bulkTransfer(out, sizeBuffer, 1, 0);
        assertEquals(1, numSent);

        numSent = connection.bulkTransfer(out, nextTestNameBuffer.array(),
                nextTestNameBuffer.limit(), 0);
        assertEquals(nextTestNameBuffer.limit(), numSent);

        // Receive result of last test
        byte[] lastTestResultBytes = new byte[1];
        int numReceived = connection.bulkTransfer(in, lastTestResultBytes,
                lastTestResultBytes.length, TIMEOUT_MILLIS);
        assertEquals(1, numReceived);
        assertEquals(1, lastTestResultBytes[0]);

        // Send ready signal
        sizeBuffer[0] = 42;
        numSent = connection.bulkTransfer(out, sizeBuffer, 1, 0);
        assertEquals(1, numSent);

        Log.i(LOG_TAG, ""Running test \"""" + safeNextTestName + ""\"""");
    }

    /**
     * Receive a transfer that has size zero using bulk-transfer.
     *
     * @param connection Connection to the USB device
     * @param in         The in endpoint
     */
    private void receiveZeroSizedTransfer(@NonNull UsbDeviceConnection connection,
            @NonNull UsbEndpoint in) {
        byte[] buffer = new byte[1];
        int numReceived = connection.bulkTransfer(in, buffer, 1, TIMEOUT_MILLIS);
        assertEquals(0, numReceived);
    }

    /**
     * Send some data and expect it to be echoed back.
     *
     * @param connection Connection to the USB device
     * @param in         The in endpoint
     * @param out        The out endpoint
     * @param size       The number of bytes to send
     */
    private void echoBulkTransfer(@NonNull UsbDeviceConnection connection,
            @NonNull UsbEndpoint in, @NonNull UsbEndpoint out, int size) {
        byte[] sentBuffer = new byte[size];
        Random r = new Random();
        r.nextBytes(sentBuffer);

        int numSent = connection.bulkTransfer(out, sentBuffer, sentBuffer.length, 0);
        assertEquals(size, numSent);

        byte[] receivedBuffer = new byte[size];
        int numReceived = connection.bulkTransfer(in, receivedBuffer, receivedBuffer.length,
                TIMEOUT_MILLIS);
        assertEquals(size, numReceived);

        assertArrayEquals(sentBuffer, receivedBuffer);

        if (isZeroTransferExpected(size, in)) {
            receiveZeroSizedTransfer(connection, in);
        }
    }

    /**
     * Send some data and expect it to be echoed back (but have an offset in the send buffer).
     *
     * @param connection Connection to the USB device
     * @param in         The in endpoint
     * @param out        The out endpoint
     * @param size       The number of bytes to send
     */
    private void echoBulkTransferOffset(@NonNull UsbDeviceConnection connection,
            @NonNull UsbEndpoint in, @NonNull UsbEndpoint out, int offset, int size) {
        byte[] sentBuffer = new byte[offset + size];
        Random r = new Random();
        r.nextBytes(sentBuffer);

        int numSent = connection.bulkTransfer(out, sentBuffer, offset, size, 0);
        assertEquals(size, numSent);

        byte[] receivedBuffer = new byte[offset + size];
        int numReceived = connection.bulkTransfer(in, receivedBuffer, offset, size, TIMEOUT_MILLIS);
        assertEquals(size, numReceived);

        for (int i = 0; i < offset + size; i++) {
            if (i < offset) {
                assertEquals(0, receivedBuffer[i]);
            } else {
                assertEquals(sentBuffer[i], receivedBuffer[i]);
            }
        }

        if (isZeroTransferExpected(size, in)) {
            receiveZeroSizedTransfer(connection, in);
        }
    }

    /**
     * Send a transfer that is large.
     *
     * @param connection Connection to the USB device
     * @param in         The in endpoint
     * @param out        The out endpoint
     */
    private void echoLargeBulkTransfer(@NonNull UsbDeviceConnection connection,
            @NonNull UsbEndpoint in, @NonNull UsbEndpoint out) {
        int totalSize = LARGE_BUFFER_SIZE;
        byte[] sentBuffer = new byte[totalSize];
        Random r = new Random();
        r.nextBytes(sentBuffer);

        int numSent = connection.bulkTransfer(out, sentBuffer, sentBuffer.length, 0);

        // Buffer will be completely transferred
        assertEquals(LARGE_BUFFER_SIZE, numSent);

        byte[] receivedBuffer = new byte[totalSize];
        int numReceived = connection.bulkTransfer(in, receivedBuffer, receivedBuffer.length,
                TIMEOUT_MILLIS);

        // All of the buffer will be echoed back
        assertEquals(LARGE_BUFFER_SIZE, numReceived);

        for (int i = 0; i < totalSize; i++) {
            assertEquals(sentBuffer[i], receivedBuffer[i]);
        }

        if (isZeroTransferExpected(LARGE_BUFFER_SIZE, in)) {
            receiveZeroSizedTransfer(connection, in);
        }
    }

    /**
     * Receive data but supply an empty buffer. This causes the thread to block until any data is
     * sent. The zero-sized receive-transfer just returns without data and the next transfer can
     * actually read the data.
     *
     * @param connection Connection to the USB device
     * @param in         The in endpoint
     * @param buffer     The buffer to use
     * @param offset     The offset into the buffer
     * @param length     The lenght of data to receive
     */
    private void receiveWithEmptyBuffer(@NonNull UsbDeviceConnection connection,
            @NonNull UsbEndpoint in, @Nullable byte[] buffer, int offset, int length) {
        long startTime = now();
        int numReceived;
        if (offset == 0) {
            numReceived = connection.bulkTransfer(in, buffer, length, 0);
        } else {
            numReceived = connection.bulkTransfer(in, buffer, offset, length, 0);
        }
        long endTime = now();
        assertEquals(-1, numReceived);

        // The transfer should block
        assertTrue(endTime - startTime > 100);

        numReceived = connection.bulkTransfer(in, new byte[1], 1, 0);
        assertEquals(1, numReceived);
    }

    /**
     * Tests {@link UsbDeviceConnection#controlTransfer}.
     *
     * <p>Note: We cannot send ctrl data to the device as it thinks it talks to an accessory, hence
     * the testing is currently limited.</p>
     *
     * @param connection The connection to use for testing
     *
     * @throws Throwable
     */
    private void ctrlTransferTests(@NonNull UsbDeviceConnection connection) throws Throwable {
        runAndAssertException(() -> connection.controlTransfer(0, 0, 0, 0, null, 1, 0),
                IllegalArgumentException.class);

        runAndAssertException(() -> connection.controlTransfer(0, 0, 0, 0, new byte[1], -1, 0),
                IllegalArgumentException.class);

        runAndAssertException(() -> connection.controlTransfer(0, 0, 0, 0, new byte[1], 2, 0),
                IllegalArgumentException.class);

        runAndAssertException(() -> connection.controlTransfer(0, 0, 0, 0, null, 0, 1, 0),
                IllegalArgumentException.class);

        runAndAssertException(() -> connection.controlTransfer(0, 0, 0, 0, new byte[1], 0, -1, 0),
                IllegalArgumentException.class);

        runAndAssertException(() -> connection.controlTransfer(0, 0, 0, 0, new byte[1], 1, 1, 0),
                IllegalArgumentException.class);
    }

    /**
     * Search an {@link UsbInterface} for an {@link UsbEndpoint endpoint} of a certain direction.
     *
     * @param iface     The interface to search
     * @param direction The direction the endpoint is for.
     *
     * @return The first endpoint found or {@link null}.
     */
    private @NonNull UsbEndpoint getEndpoint(@NonNull UsbInterface iface, int direction) {
        for (int i = 0; i < iface.getEndpointCount(); i++) {
            UsbEndpoint ep = iface.getEndpoint(i);
            if (ep.getDirection() == direction) {
                return ep;
            }
        }

        throw new IllegalStateException(""Could not find "" + direction + "" endpoint in ""
                + iface.getName());
    }

    /**
     * Receive a transfer that has size zero using deprecated usb-request methods.
     *
     * @param connection Connection to the USB device
     * @param in         The in endpoint
     */
    private void receiveZeroSizeRequestLegacy(@NonNull UsbDeviceConnection connection,
            @NonNull UsbEndpoint in) {
        UsbRequest receiveZero = new UsbRequest();
        boolean isInited = receiveZero.initialize(connection, in);
        assertTrue(isInited);
        ByteBuffer zeroBuffer = ByteBuffer.allocate(1);
        receiveZero.queue(zeroBuffer, 1);

        UsbRequest finished = connection.requestWait();
        assertEquals(receiveZero, finished);
        assertEquals(0, zeroBuffer.position());
    }

    /**
     * Send a USB request using the {@link UsbRequest#queue legacy path} and receive it back.
     *
     * @param connection      The connection to use
     * @param in              The endpoint to receive requests from
     * @param out             The endpoint to send requests to
     * @param size            The size of the request to send
     * @param originalSize    The size of the original buffer
     * @param sliceStart      The start of the final buffer in the original buffer
     * @param sliceEnd        The end of the final buffer in the original buffer
     * @param positionInSlice The position parameter in the final buffer
     * @param limitInSlice    The limited parameter in the final buffer
     * @param useDirectBuffer If the buffer to be used should be a direct buffer
     */
    private void echoUsbRequestLegacy(@NonNull UsbDeviceConnection connection,
            @NonNull UsbEndpoint in, @NonNull UsbEndpoint out, int size, int originalSize,
            int sliceStart, int sliceEnd, int positionInSlice, int limitInSlice,
            boolean useDirectBuffer) {
        Random random = new Random();

        UsbRequest sent = new UsbRequest();
        boolean isInited = sent.initialize(connection, out);
        assertTrue(isInited);
        Object sentClientData = new Object();
        sent.setClientData(sentClientData);

        UsbRequest receive = new UsbRequest();
        isInited = receive.initialize(connection, in);
        assertTrue(isInited);
        Object receiveClientData = new Object();
        receive.setClientData(receiveClientData);

        ByteBuffer bufferSent;
        if (useDirectBuffer) {
            bufferSent = ByteBuffer.allocateDirect(originalSize);
        } else {
            bufferSent = ByteBuffer.allocate(originalSize);
        }
        for (int i = 0; i < originalSize; i++) {
            bufferSent.put((byte) random.nextInt());
        }
        bufferSent.position(sliceStart);
        bufferSent.limit(sliceEnd);
        ByteBuffer bufferSentSliced = bufferSent.slice();
        bufferSentSliced.position(positionInSlice);
        bufferSentSliced.limit(limitInSlice);

        bufferSent.position(0);
        bufferSent.limit(originalSize);

        ByteBuffer bufferReceived;
        if (useDirectBuffer) {
            bufferReceived = ByteBuffer.allocateDirect(originalSize);
        } else {
            bufferReceived = ByteBuffer.allocate(originalSize);
        }
        bufferReceived.position(sliceStart);
        bufferReceived.limit(sliceEnd);
        ByteBuffer bufferReceivedSliced = bufferReceived.slice();
        bufferReceivedSliced.position(positionInSlice);
        bufferReceivedSliced.limit(limitInSlice);

        bufferReceived.position(0);
        bufferReceived.limit(originalSize);

        boolean wasQueued = receive.queue(bufferReceivedSliced, size);
        assertTrue(wasQueued);
        wasQueued = sent.queue(bufferSentSliced, size);
        assertTrue(wasQueued);

        for (int reqRun = 0; reqRun < 2; reqRun++) {
            UsbRequest finished;

            try {
                finished = connection.requestWait();
            } catch (BufferOverflowException e) {
                if (size > bufferSentSliced.limit() || size > bufferReceivedSliced.limit()) {
                    Log.e(LOG_TAG, ""Expected failure"", e);
                    continue;
                } else {
                    throw e;
                }
            }

            // Should we have gotten a failure?
            if (finished == receive) {
                // We should have gotten an exception if size > limit
                assertTrue(bufferReceivedSliced.limit() >= size);

                assertEquals(size, bufferReceivedSliced.position());

                for (int i = 0; i < size; i++) {
                    if (i < size) {
                        assertEquals(bufferSent.get(i), bufferReceived.get(i));
                    } else {
                        assertEquals(0, bufferReceived.get(i));
                    }
                }

                assertSame(receiveClientData, finished.getClientData());
                assertSame(in, finished.getEndpoint());
            } else {
                assertEquals(size, bufferSentSliced.position());

                // We should have gotten an exception if size > limit
                assertTrue(bufferSentSliced.limit() >= size);
                assertSame(sent, finished);
                assertSame(sentClientData, finished.getClientData());
                assertSame(out, finished.getEndpoint());
            }
            finished.close();
        }

        if (isZeroTransferExpected(size, in)) {
            receiveZeroSizeRequestLegacy(connection, in);
        }
    }

    /**
     * Receive a transfer that has size zero using current usb-request methods.
     *
     * @param connection Connection to the USB device
     * @param in         The in endpoint
     */
    private void receiveZeroSizeRequest(@NonNull UsbDeviceConnection connection,
            @NonNull UsbEndpoint in) {
        UsbRequest receiveZero = new UsbRequest();
        boolean isInited = receiveZero.initialize(connection, in);
        assertTrue(isInited);
        ByteBuffer zeroBuffer = ByteBuffer.allocate(1);
        receiveZero.queue(zeroBuffer);

        UsbRequest finished = connection.requestWait();
        assertEquals(receiveZero, finished);
        assertEquals(0, zeroBuffer.position());
    }

    /**
     * Send a USB request and receive it back.
     *
     * @param connection      The connection to use
     * @param in              The endpoint to receive requests from
     * @param out             The endpoint to send requests to
     * @param originalSize    The size of the original buffer
     * @param sliceStart      The start of the final buffer in the original buffer
     * @param sliceEnd        The end of the final buffer in the original buffer
     * @param positionInSlice The position parameter in the final buffer
     * @param limitInSlice    The limited parameter in the final buffer
     * @param useDirectBuffer If the buffer to be used should be a direct buffer
     */
    private void echoUsbRequest(@NonNull UsbDeviceConnection connection, @NonNull UsbEndpoint in,
            @NonNull UsbEndpoint out, int originalSize, int sliceStart, int sliceEnd,
            int positionInSlice, int limitInSlice, boolean useDirectBuffer,
            boolean makeSendBufferReadOnly) {
        Random random = new Random();

        UsbRequest sent = new UsbRequest();
        boolean isInited = sent.initialize(connection, out);
        assertTrue(isInited);
        Object sentClientData = new Object();
        sent.setClientData(sentClientData);

        UsbRequest receive = new UsbRequest();
        isInited = receive.initialize(connection, in);
        assertTrue(isInited);
        Object receiveClientData = new Object();
        receive.setClientData(receiveClientData);

        ByteBuffer bufferSent;
        if (useDirectBuffer) {
            bufferSent = ByteBuffer.allocateDirect(originalSize);
        } else {
            bufferSent = ByteBuffer.allocate(originalSize);
        }
        for (int i = 0; i < originalSize; i++) {
            bufferSent.put((byte) random.nextInt());
        }
        if (makeSendBufferReadOnly) {
            bufferSent = bufferSent.asReadOnlyBuffer();
        }
        bufferSent.position(sliceStart);
        bufferSent.limit(sliceEnd);
        ByteBuffer bufferSentSliced = bufferSent.slice();
        bufferSentSliced.position(positionInSlice);
        bufferSentSliced.limit(limitInSlice);

        bufferSent.position(0);
        bufferSent.limit(originalSize);

        ByteBuffer bufferReceived;
        if (useDirectBuffer) {
            bufferReceived = ByteBuffer.allocateDirect(originalSize);
        } else {
            bufferReceived = ByteBuffer.allocate(originalSize);
        }
        bufferReceived.position(sliceStart);
        bufferReceived.limit(sliceEnd);
        ByteBuffer bufferReceivedSliced = bufferReceived.slice();
        bufferReceivedSliced.position(positionInSlice);
        bufferReceivedSliced.limit(limitInSlice);

        bufferReceived.position(0);
        bufferReceived.limit(originalSize);

        boolean wasQueued = receive.queue(bufferReceivedSliced);
        assertTrue(wasQueued);
        wasQueued = sent.queue(bufferSentSliced);
        assertTrue(wasQueued);

        for (int reqRun = 0; reqRun < 2; reqRun++) {
            UsbRequest finished = connection.requestWait();

            if (finished == receive) {
                assertEquals(limitInSlice, bufferReceivedSliced.limit());
                assertEquals(limitInSlice, bufferReceivedSliced.position());

                for (int i = 0; i < originalSize; i++) {
                    if (i >= sliceStart + positionInSlice && i < sliceStart + limitInSlice) {
                        assertEquals(bufferSent.get(i), bufferReceived.get(i));
                    } else {
                        assertEquals(0, bufferReceived.get(i));
                    }
                }

                assertSame(receiveClientData, finished.getClientData());
                assertSame(in, finished.getEndpoint());
            } else {
                assertEquals(limitInSlice, bufferSentSliced.limit());
                assertEquals(limitInSlice, bufferSentSliced.position());

                assertSame(sent, finished);
                assertSame(sentClientData, finished.getClientData());
                assertSame(out, finished.getEndpoint());
            }
            finished.close();
        }

        if (isZeroTransferExpected(sliceStart + limitInSlice - (sliceStart + positionInSlice), in)) {
            receiveZeroSizeRequest(connection, in);
        }
    }

    /**
     * Send a USB request using the {@link UsbRequest#queue legacy path} and receive it back.
     *
     * @param connection      The connection to use
     * @param in              The endpoint to receive requests from
     * @param out             The endpoint to send requests to
     * @param size            The size of the request to send
     * @param useDirectBuffer If the buffer to be used should be a direct buffer
     */
    private void echoUsbRequestLegacy(@NonNull UsbDeviceConnection connection,
            @NonNull UsbEndpoint in, @NonNull UsbEndpoint out, int size, boolean useDirectBuffer) {
        echoUsbRequestLegacy(connection, in, out, size, size, 0, size, 0, size, useDirectBuffer);
    }

    /**
     * Send a USB request and receive it back.
     *
     * @param connection      The connection to use
     * @param in              The endpoint to receive requests from
     * @param out             The endpoint to send requests to
     * @param size            The size of the request to send
     * @param useDirectBuffer If the buffer to be used should be a direct buffer
     */
    private void echoUsbRequest(@NonNull UsbDeviceConnection connection, @NonNull UsbEndpoint in,
            @NonNull UsbEndpoint out, int size, boolean useDirectBuffer) {
        echoUsbRequest(connection, in, out, size, 0, size, 0, size, useDirectBuffer, false);
    }

    /**
     * Send a USB request which more than the allowed size and receive it back.
     *
     * @param connection      The connection to use
     * @param in              The endpoint to receive requests from
     * @param out             The endpoint to send requests to
     */
    private void echoLargeUsbRequestLegacy(@NonNull UsbDeviceConnection connection,
            @NonNull UsbEndpoint in, @NonNull UsbEndpoint out) {
        Random random = new Random();
        int totalSize = LARGE_BUFFER_SIZE;

        UsbRequest sent = new UsbRequest();
        boolean isInited = sent.initialize(connection, out);
        assertTrue(isInited);

        UsbRequest receive = new UsbRequest();
        isInited = receive.initialize(connection, in);
        assertTrue(isInited);

        byte[] sentBytes = new byte[totalSize];
        random.nextBytes(sentBytes);
        ByteBuffer bufferSent = ByteBuffer.wrap(sentBytes);

        byte[] receivedBytes = new byte[totalSize];
        ByteBuffer bufferReceived = ByteBuffer.wrap(receivedBytes);

        boolean wasQueued = receive.queue(bufferReceived, totalSize);
        assertTrue(wasQueued);
        wasQueued = sent.queue(bufferSent, totalSize);
        assertTrue(wasQueued);

        for (int requestNum = 0; requestNum < 2; requestNum++) {
            UsbRequest finished = connection.requestWait();
            if (finished == receive) {
                // Entire buffer is received
                assertEquals(bufferReceived.position(), totalSize);
                for (int i = 0; i < totalSize; i++) {
                    assertEquals(sentBytes[i], receivedBytes[i]);
                }
            } else {
                assertSame(sent, finished);
            }
            finished.close();
        }

        if (isZeroTransferExpected(LARGE_BUFFER_SIZE, in)) {
            receiveZeroSizedTransfer(connection, in);
        }
    }

    /**
     * Time out while waiting for USB requests.
     *
     * @param connection The connection to use
     */
    private void timeoutWhileWaitingForUsbRequest(@NonNull UsbDeviceConnection connection)
            throws Throwable {
        runAndAssertException(() -> connection.requestWait(-1), IllegalArgumentException.class);

        long startTime = now();
        runAndAssertException(() -> connection.requestWait(100), TimeoutException.class);
        assertTrue(now() - startTime >= 100);
        assertTrue(now() - startTime < 400);

        startTime = now();
        runAndAssertException(() -> connection.requestWait(0), TimeoutException.class);
        assertTrue(now() - startTime < 400);
    }

    /**
     * Receive a USB request before a timeout triggers
     *
     * @param connection The connection to use
     * @param in         The endpoint to receive requests from
     */
    private void receiveAfterTimeout(@NonNull UsbDeviceConnection connection,
            @NonNull UsbEndpoint in, long timeout) throws InterruptedException, TimeoutException {
        UsbRequest reqQueued = new UsbRequest();
        ByteBuffer buffer = ByteBuffer.allocate(1);

        reqQueued.initialize(connection, in);
        reqQueued.queue(buffer);

        // Let the kernel receive and process the request
        Thread.sleep(50);

        long startTime = now();
        UsbRequest reqFinished = connection.requestWait(timeout);
        assertTrue(now() - startTime < timeout + 50);
        assertSame(reqQueued, reqFinished);
        reqFinished.close();
    }

    /**
     * Send a USB request with size 0 using the {@link UsbRequest#queue legacy path}.
     *
     * @param connection      The connection to use
     * @param out             The endpoint to send requests to
     * @param useDirectBuffer Send data from a direct buffer
     */
    private void sendZeroLengthRequestLegacy(@NonNull UsbDeviceConnection connection,
            @NonNull UsbEndpoint out, boolean useDirectBuffer) {
        UsbRequest sent = new UsbRequest();
        boolean isInited = sent.initialize(connection, out);
        assertTrue(isInited);

        ByteBuffer buffer;
        if (useDirectBuffer) {
            buffer = ByteBuffer.allocateDirect(0);
        } else {
            buffer = ByteBuffer.allocate(0);
        }

        boolean isQueued = sent.queue(buffer, 0);
        assertTrue(isQueued);
        UsbRequest finished = connection.requestWait();
        assertSame(finished, sent);
        finished.close();
    }

    /**
     * Send a USB request with size 0.
     *
     * @param connection      The connection to use
     * @param out             The endpoint to send requests to
     * @param useDirectBuffer Send data from a direct buffer
     */
    private void sendZeroLengthRequest(@NonNull UsbDeviceConnection connection,
            @NonNull UsbEndpoint out, boolean useDirectBuffer) {
        UsbRequest sent = new UsbRequest();
        boolean isInited = sent.initialize(connection, out);
        assertTrue(isInited);

        ByteBuffer buffer;
        if (useDirectBuffer) {
            buffer = ByteBuffer.allocateDirect(0);
        } else {
            buffer = ByteBuffer.allocate(0);
        }

        boolean isQueued = sent.queue(buffer);
        assertTrue(isQueued);
        UsbRequest finished = connection.requestWait();
        assertSame(finished, sent);
        finished.close();
    }

    /**
     * Send a USB request with a null buffer.
     *
     * @param connection      The connection to use
     * @param out             The endpoint to send requests to
     */
    private void sendNullRequest(@NonNull UsbDeviceConnection connection,
            @NonNull UsbEndpoint out) {
        UsbRequest sent = new UsbRequest();
        boolean isInited = sent.initialize(connection, out);
        assertTrue(isInited);

        boolean isQueued = sent.queue(null);
        assertTrue(isQueued);
        UsbRequest finished = connection.requestWait();
        assertSame(finished, sent);
        finished.close();
    }

    /**
     * Receive a USB request with size 0.
     *
     * @param connection      The connection to use
     * @param in             The endpoint to recevie requests from
     */
    private void receiveZeroLengthRequestLegacy(@NonNull UsbDeviceConnection connection,
            @NonNull UsbEndpoint in, boolean useDirectBuffer) {
        UsbRequest zeroReceived = new UsbRequest();
        boolean isInited = zeroReceived.initialize(connection, in);
        assertTrue(isInited);

        UsbRequest oneReceived = new UsbRequest();
        isInited = oneReceived.initialize(connection, in);
        assertTrue(isInited);

        ByteBuffer buffer;
        if (useDirectBuffer) {
            buffer = ByteBuffer.allocateDirect(0);
        } else {
            buffer = ByteBuffer.allocate(0);
        }

        ByteBuffer buffer1;
        if (useDirectBuffer) {
            buffer1 = ByteBuffer.allocateDirect(1);
        } else {
            buffer1 = ByteBuffer.allocate(1);
        }

        boolean isQueued = zeroReceived.queue(buffer);
        assertTrue(isQueued);
        isQueued = oneReceived.queue(buffer1);
        assertTrue(isQueued);

        // We expect both to be returned after some time
        ArrayList<UsbRequest> finished = new ArrayList<>(2);

        // We expect both request to come back after the delay, but then quickly
        long startTime = now();
        finished.add(connection.requestWait());
        long firstReturned = now();
        finished.add(connection.requestWait());
        long secondReturned = now();

        assertTrue(firstReturned - startTime > 100);
        assertTrue(secondReturned - firstReturned < 100);

        assertTrue(finished.contains(zeroReceived));
        assertTrue(finished.contains(oneReceived));
    }

    /**
     * Tests the {@link UsbRequest#queue legacy implementaion} of {@link UsbRequest} and
     * {@link UsbDeviceConnection#requestWait()}.
     *
     * @param connection The connection to use for testing
     * @param iface      The interface of the android accessory interface of the device
     * @throws Throwable
     */
    private void usbRequestLegacyTests(@NonNull UsbDeviceConnection connection,
            @NonNull UsbInterface iface) throws Throwable {
        // Find bulk in and out endpoints
        assertTrue(iface.getEndpointCount() == 2);
        final UsbEndpoint in = getEndpoint(iface, UsbConstants.USB_DIR_IN);
        final UsbEndpoint out = getEndpoint(iface, UsbConstants.USB_DIR_OUT);
        assertNotNull(in);
        assertNotNull(out);

        // Single threaded send and receive
        nextTest(connection, in, out, ""Echo 1 byte"");
        echoUsbRequestLegacy(connection, in, out, 1, true);

        nextTest(connection, in, out, ""Echo 1 byte"");
        echoUsbRequestLegacy(connection, in, out, 1, false);

        nextTest(connection, in, out, ""Echo 16384 bytes"");
        echoUsbRequestLegacy(connection, in, out, 16384, true);

        nextTest(connection, in, out, ""Echo 16384 bytes"");
        echoUsbRequestLegacy(connection, in, out, 16384, false);

        nextTest(connection, in, out, ""Echo large buffer"");
        echoLargeUsbRequestLegacy(connection, in, out);

        // Send empty requests
        sendZeroLengthRequestLegacy(connection, out, true);
        sendZeroLengthRequestLegacy(connection, out, false);

        // waitRequest with timeout
        timeoutWhileWaitingForUsbRequest(connection);

        nextTest(connection, in, out, ""Receive byte after some time"");
        receiveAfterTimeout(connection, in, 400);

        nextTest(connection, in, out, ""Receive byte immediately"");
        // Make sure the data is received before we queue the request for it
        Thread.sleep(50);
        receiveAfterTimeout(connection, in, 0);

        /* TODO: Unreliable

        // Zero length means waiting for the next data and then return
        nextTest(connection, in, out, ""Receive byte after some time"");
        receiveZeroLengthRequestLegacy(connection, in, true);

        nextTest(connection, in, out, ""Receive byte after some time"");
        receiveZeroLengthRequestLegacy(connection, in, true);

        */

        // UsbRequest.queue ignores position, limit, arrayOffset, and capacity
        nextTest(connection, in, out, ""Echo 42 bytes"");
        echoUsbRequestLegacy(connection, in, out, 42, 42, 0, 42, 5, 42, false);

        nextTest(connection, in, out, ""Echo 42 bytes"");
        echoUsbRequestLegacy(connection, in, out, 42, 42, 0, 42, 0, 36, false);

        nextTest(connection, in, out, ""Echo 42 bytes"");
        echoUsbRequestLegacy(connection, in, out, 42, 42, 5, 42, 0, 36, false);

        nextTest(connection, in, out, ""Echo 42 bytes"");
        echoUsbRequestLegacy(connection, in, out, 42, 42, 0, 36, 0, 31, false);

        nextTest(connection, in, out, ""Echo 42 bytes"");
        echoUsbRequestLegacy(connection, in, out, 42, 47, 0, 47, 0, 47, false);

        nextTest(connection, in, out, ""Echo 42 bytes"");
        echoUsbRequestLegacy(connection, in, out, 42, 47, 5, 47, 0, 42, false);

        nextTest(connection, in, out, ""Echo 42 bytes"");
        echoUsbRequestLegacy(connection, in, out, 42, 47, 0, 42, 0, 42, false);

        nextTest(connection, in, out, ""Echo 42 bytes"");
        echoUsbRequestLegacy(connection, in, out, 42, 47, 0, 47, 5, 47, false);

        nextTest(connection, in, out, ""Echo 42 bytes"");
        echoUsbRequestLegacy(connection, in, out, 42, 47, 5, 47, 5, 36, false);

        // Illegal arguments
        final UsbRequest req1 = new UsbRequest();
        runAndAssertException(() -> req1.initialize(null, in), NullPointerException.class);
        runAndAssertException(() -> req1.initialize(connection, null), NullPointerException.class);
        boolean isInited = req1.initialize(connection, in);
        assertTrue(isInited);
        runAndAssertException(() -> req1.queue(null, 0), NullPointerException.class);
        runAndAssertException(() -> req1.queue(ByteBuffer.allocate(1).asReadOnlyBuffer(), 1),
                IllegalArgumentException.class);
        req1.close();

        // Cannot queue closed request
        runAndAssertException(() -> req1.queue(ByteBuffer.allocate(1), 1),
                NullPointerException.class);
        runAndAssertException(() -> req1.queue(ByteBuffer.allocateDirect(1), 1),
                NullPointerException.class);
    }

    /**
     * Repeat c n times
     *
     * @param c The character to repeat
     * @param n The number of times to repeat
     *
     * @return c repeated n times
     */
    public static String repeat(char c, int n) {
        final StringBuilder result = new StringBuilder();
        for (int i = 0; i < n; i++) {
            if (c != ' ' && i % 10 == 0) {
                result.append(i / 10);
            } else {
                result.append(c);
            }
        }
        return result.toString();
    }

    /**
     * Tests {@link UsbRequest} and {@link UsbDeviceConnection#requestWait()}.
     *
     * @param connection The connection to use for testing
     * @param iface      The interface of the android accessory interface of the device
     * @throws Throwable
     */
    private void usbRequestTests(@NonNull UsbDeviceConnection connection,
            @NonNull UsbInterface iface) throws Throwable {
        // Find bulk in and out endpoints
        assertTrue(iface.getEndpointCount() == 2);
        final UsbEndpoint in = getEndpoint(iface, UsbConstants.USB_DIR_IN);
        final UsbEndpoint out = getEndpoint(iface, UsbConstants.USB_DIR_OUT);
        assertNotNull(in);
        assertNotNull(out);

        // Single threaded send and receive
        nextTest(connection, in, out, ""Echo 1 byte"");
        echoUsbRequest(connection, in, out, 1, true);

        nextTest(connection, in, out, ""Echo 1 byte"");
        echoUsbRequest(connection, in, out, 1, false);

        nextTest(connection, in, out, ""Echo 16384 bytes"");
        echoUsbRequest(connection, in, out, 16384, true);

        nextTest(connection, in, out, ""Echo 16384 bytes"");
        echoUsbRequest(connection, in, out, 16384, false);

        // Send empty requests
        sendZeroLengthRequest(connection, out, true);
        sendZeroLengthRequest(connection, out, false);
        sendNullRequest(connection, out);

        /* TODO: Unreliable

        // Zero length means waiting for the next data and then return
        nextTest(connection, in, out, ""Receive byte after some time"");
        receiveZeroLengthRequest(connection, in, true);

        nextTest(connection, in, out, ""Receive byte after some time"");
        receiveZeroLengthRequest(connection, in, true);

        */

        for (int startOfSlice : new int[]{0, 1}) {
            for (int endOffsetOfSlice : new int[]{0, 2}) {
                for (int positionInSlice : new int[]{0, 5}) {
                    for (int limitOffsetInSlice : new int[]{0, 11}) {
                        for (boolean useDirectBuffer : new boolean[]{true, false}) {
                            for (boolean makeSendBufferReadOnly : new boolean[]{true, false}) {
                                int sliceSize = 42 + positionInSlice + limitOffsetInSlice;
                                int originalSize = sliceSize + startOfSlice + endOffsetOfSlice;

                                nextTest(connection, in, out, ""Echo 42 bytes"");

                                // Log buffer, slice, and data offsets
                                Log.i(LOG_TAG,
                                        ""buffer"" + (makeSendBufferReadOnly ? ""(ro): ["" : "":     ["")
                                                + repeat('.', originalSize) + ""]"");
                                Log.i(LOG_TAG,
                                        ""slice:     "" + repeat(' ', startOfSlice) + "" ["" + repeat(
                                                '.', sliceSize) + ""]"");
                                Log.i(LOG_TAG,
                                        ""data:      "" + repeat(' ', startOfSlice + positionInSlice)
                                                + "" ["" + repeat('.', 42) + ""]"");

                                echoUsbRequest(connection, in, out, originalSize, startOfSlice,
                                        originalSize - endOffsetOfSlice, positionInSlice,
                                        sliceSize - limitOffsetInSlice, useDirectBuffer,
                                        makeSendBufferReadOnly);
                            }
                        }
                    }
                }
            }
        }

        // Illegal arguments
        final UsbRequest req1 = new UsbRequest();
        runAndAssertException(() -> req1.initialize(null, in), NullPointerException.class);
        runAndAssertException(() -> req1.initialize(connection, null), NullPointerException.class);
        boolean isInited = req1.initialize(connection, in);
        assertTrue(isInited);
        runAndAssertException(() -> req1.queue(ByteBuffer.allocate(16384 + 1).asReadOnlyBuffer()),
                IllegalArgumentException.class);
        runAndAssertException(() -> req1.queue(ByteBuffer.allocate(1).asReadOnlyBuffer()),
                IllegalArgumentException.class);
        req1.close();

        // Cannot queue closed request
        runAndAssertException(() -> req1.queue(ByteBuffer.allocate(1)),
                IllegalStateException.class);
        runAndAssertException(() -> req1.queue(ByteBuffer.allocateDirect(1)),
                IllegalStateException.class);

        // Initialize
        UsbRequest req2 = new UsbRequest();
        isInited = req2.initialize(connection, in);
        assertTrue(isInited);
        isInited = req2.initialize(connection, out);
        assertTrue(isInited);
        req2.close();

        // Close
        req2 = new UsbRequest();
        req2.close();

        req2.initialize(connection, in);
        req2.close();
        req2.close();
    }

    /** State of a {@link UsbRequest} in flight */
    private static class RequestState {
        final ByteBuffer buffer;
        final Object clientData;

        private RequestState(ByteBuffer buffer, Object clientData) {
            this.buffer = buffer;
            this.clientData = clientData;
        }
    }

    /** Recycles elements that might be expensive to create */
    private abstract class Recycler<T> {
        private final Random mRandom;
        private final LinkedList<T> mData;

        protected Recycler() {
            mData = new LinkedList<>();
            mRandom = new Random();
        }

        /**
         * Add a new element to be recycled.
         *
         * @param newElement The element that is not used anymore and can be used by someone else.
         */
        private void recycle(@NonNull T newElement) {
            synchronized (mData) {
                if (mRandom.nextBoolean()) {
                    mData.addLast(newElement);
                } else {
                    mData.addFirst(newElement);
                }
            }
        }

        /**
         * Get a recycled element or create a new one if needed.
         *
         * @return An element that can be used (maybe recycled)
         */
        private @NonNull T get() {
            T recycledElement;

            try {
                synchronized (mData) {
                    recycledElement = mData.pop();
                }
            } catch (NoSuchElementException ignored) {
                recycledElement = create();
            }

            reset(recycledElement);

            return recycledElement;
        }

        /** Reset internal state of {@code recycledElement} */
        protected abstract void reset(@NonNull T recycledElement);

        /** Create a new element */
        protected abstract @NonNull T create();

        /** Get all elements that are currently recycled and waiting to be used again */
        public @NonNull LinkedList<T> getAll() {
            return mData;
        }
    }

    /**
     * Common code between {@link QueuerThread} and {@link ReceiverThread}.
     */
    private class TestThread extends Thread {
        /** State copied from the main thread (see runTest()) */
        protected final UsbDeviceConnection mConnection;
        protected final Recycler<UsbRequest> mInRequestRecycler;
        protected final Recycler<UsbRequest> mOutRequestRecycler;
        protected final Recycler<ByteBuffer> mBufferRecycler;
        protected final HashMap<UsbRequest, RequestState> mRequestsInFlight;
        protected final HashMap<Integer, Integer> mData;
        protected final ArrayList<Throwable> mErrors;

        protected volatile boolean mShouldStop;

        TestThread(@NonNull UsbDeviceConnection connection,
                @NonNull Recycler<UsbRequest> inRequestRecycler,
                @NonNull Recycler<UsbRequest> outRequestRecycler,
                @NonNull Recycler<ByteBuffer> bufferRecycler,
                @NonNull HashMap<UsbRequest, RequestState> requestsInFlight,
                @NonNull HashMap<Integer, Integer> data,
                @NonNull ArrayList<Throwable> errors) {
            super();

            mShouldStop = false;
            mConnection = connection;
            mBufferRecycler = bufferRecycler;
            mInRequestRecycler = inRequestRecycler;
            mOutRequestRecycler = outRequestRecycler;
            mRequestsInFlight = requestsInFlight;
            mData = data;
            mErrors = errors;
        }

        /**
         * Stop thread
         */
        void abort() {
            mShouldStop = true;
            interrupt();
        }
    }

    /**
     * A thread that queues matching write and read {@link UsbRequest requests}. We expect the
     * writes to be echoed back and return in unchanged in the read requests.
     * <p> This thread just issues the requests and does not care about them anymore after the
     * system took them. The {@link ReceiverThread} handles the result of both write and read
     * requests.</p>
     */
    private class QueuerThread extends TestThread {
        private static final int MAX_IN_FLIGHT = 64;
        private static final long RUN_TIME = 10 * 1000;

        private final AtomicInteger mCounter;

        /**
         * Create a new thread that queues matching write and read UsbRequests.
         *
         * @param connection Connection to communicate with
         * @param inRequestRecycler Pool of in-requests that can be reused
         * @param outRequestRecycler Pool of out-requests that can be reused
         * @param bufferRecycler Pool of byte buffers that can be reused
         * @param requestsInFlight State of the requests currently in flight
         * @param data Mapping counter -> data
         * @param counter An atomic counter
         * @param errors Pool of throwables created by threads like this
         */
        QueuerThread(@NonNull UsbDeviceConnection connection,
                @NonNull Recycler<UsbRequest> inRequestRecycler,
                @NonNull Recycler<UsbRequest> outRequestRecycler,
                @NonNull Recycler<ByteBuffer> bufferRecycler,
                @NonNull HashMap<UsbRequest, RequestState> requestsInFlight,
                @NonNull HashMap<Integer, Integer> data,
                @NonNull AtomicInteger counter,
                @NonNull ArrayList<Throwable> errors) {
            super(connection, inRequestRecycler, outRequestRecycler, bufferRecycler,
                    requestsInFlight, data, errors);

            mCounter = counter;
        }

        @Override
        public void run() {
            Random random = new Random();

            long endTime = now() + RUN_TIME;

            while (now() < endTime && !mShouldStop) {
                try {
                    int counter = mCounter.getAndIncrement();

                    if (counter % 1024 == 0) {
                        Log.i(LOG_TAG, ""Counter is "" + counter);
                    }

                    // Write [1:counter:data]
                    UsbRequest writeRequest = mOutRequestRecycler.get();
                    ByteBuffer writeBuffer = mBufferRecycler.get();
                    int data = random.nextInt();
                    writeBuffer.put((byte)1).putInt(counter).putInt(data);
                    writeBuffer.flip();

                    // Send read that will receive the data back from the write as the other side
                    // will echo all requests.
                    UsbRequest readRequest = mInRequestRecycler.get();
                    ByteBuffer readBuffer = mBufferRecycler.get();

                    // Register requests
                    synchronized (mRequestsInFlight) {
                        // Wait until previous requests were processed
                        while (mRequestsInFlight.size() > MAX_IN_FLIGHT) {
                            try {
                                mRequestsInFlight.wait();
                            } catch (InterruptedException e) {
                                break;
                            }
                        }

                        if (mShouldStop) {
                            break;
                        } else {
                            mRequestsInFlight.put(writeRequest, new RequestState(writeBuffer,
                                    writeRequest.getClientData()));
                            mRequestsInFlight.put(readRequest, new RequestState(readBuffer,
                                    readRequest.getClientData()));
                            mRequestsInFlight.notifyAll();
                        }
                    }

                    // Store which data was written for the counter
                    synchronized (mData) {
                        mData.put(counter, data);
                    }

                    // Send both requests to the system. Once they finish the ReceiverThread will
                    // be notified
                    boolean isQueued = writeRequest.queue(writeBuffer);
                    assertTrue(isQueued);

                    isQueued = readRequest.queue(readBuffer, 9);
                    assertTrue(isQueued);
                } catch (Throwable t) {
                    synchronized (mErrors) {
                        mErrors.add(t);
                        mErrors.notify();
                    }
                    break;
                }
            }
        }
    }

    /**
     * A thread that receives processed UsbRequests and compares the expected result. The requests
     * can be both read and write requests. The requests were created and given to the system by
     * the {@link QueuerThread}.
     */
    private class ReceiverThread extends TestThread {
        private final UsbEndpoint mOut;

        /**
         * Create a thread that receives processed UsbRequests and compares the expected result.
         *
         * @param connection Connection to communicate with
         * @param out Endpoint to queue write requests on
         * @param inRequestRecycler Pool of in-requests that can be reused
         * @param outRequestRecycler Pool of out-requests that can be reused
         * @param bufferRecycler Pool of byte buffers that can be reused
         * @param requestsInFlight State of the requests currently in flight
         * @param data Mapping counter -> data
         * @param errors Pool of throwables created by threads like this
         */
        ReceiverThread(@NonNull UsbDeviceConnection connection, @NonNull UsbEndpoint out,
                @NonNull Recycler<UsbRequest> inRequestRecycler,
                @NonNull Recycler<UsbRequest> outRequestRecycler,
                @NonNull Recycler<ByteBuffer> bufferRecycler,
                @NonNull HashMap<UsbRequest, RequestState> requestsInFlight,
                @NonNull HashMap<Integer, Integer> data, @NonNull ArrayList<Throwable> errors) {
            super(connection, inRequestRecycler, outRequestRecycler, bufferRecycler,
                    requestsInFlight, data, errors);

            mOut = out;
        }

        @Override
        public void run() {
            while (!mShouldStop) {
                try {
                    // Wait until a request is queued as mConnection.requestWait() cannot be
                    // interrupted.
                    synchronized (mRequestsInFlight) {
                        while (mRequestsInFlight.isEmpty()) {
                            try {
                                mRequestsInFlight.wait();
                            } catch (InterruptedException e) {
                                break;
                            }
                        }

                        if (mShouldStop) {
                            break;
                        }
                    }

                    // Receive request
                    UsbRequest request = mConnection.requestWait();
                    assertNotNull(request);

                    // Find the state the request should have
                    RequestState state;
                    synchronized (mRequestsInFlight) {
                        state = mRequestsInFlight.remove(request);
                        mRequestsInFlight.notifyAll();
                    }

                    // Compare client data
                    assertSame(state.clientData, request.getClientData());

                    // There is nothing more to check about write requests, but for read requests
                    // (the ones going to an out endpoint) we know that it just an echoed back write
                    // request.
                    if (!request.getEndpoint().equals(mOut)) {
                        state.buffer.flip();

                        // Read request buffer, check that data is correct
                        byte alive = state.buffer.get();
                        int counter = state.buffer.getInt();
                        int receivedData = state.buffer.getInt();

                        // We stored which data-combinations were written
                        int expectedData;
                        synchronized(mData) {
                            expectedData = mData.remove(counter);
                        }

                        // Make sure read request matches a write request we sent before
                        assertEquals(1, alive);
                        assertEquals(expectedData, receivedData);
                    }

                    // Recycle buffers and requests so they can be reused later.
                    mBufferRecycler.recycle(state.buffer);

                    if (request.getEndpoint().equals(mOut)) {
                        mOutRequestRecycler.recycle(request);
                    } else {
                        mInRequestRecycler.recycle(request);
                    }
                } catch (Throwable t) {
                    synchronized (mErrors) {
                        mErrors.add(t);
                        mErrors.notify();
                    }
                    break;
                }
            }
        }
    }

    /**
     * Run reconnecttest.
     *
     * @param device The device to run the test against. This device is running
     *               com.android.cts.verifierusbcompanion.DeviceTestCompanion
     *
     * @throws Throwable
     */
    private void reconnectTest(@NonNull UsbDevice device) throws Throwable {
        UsbDeviceConnection connection = mUsbManager.openDevice(device);
        assertNotNull(connection);

        assertFalse(connection.getFileDescriptor() == -1);
        assertNotNull(connection.getRawDescriptors());
        assertFalse(connection.getRawDescriptors().length == 0);
        assertEquals(device.getSerialNumber(), connection.getSerial());
        runAndAssertException(() -> connection.setConfiguration(null), NullPointerException.class);
        connection.close();
    }

    /**
     * <p> This attachedtask the requests and does not care about them anymore after the
     * system took them. The {@link attachedTask} handles the test after the main test done.
     * It should start after device reconnect success.</p>
     */
    private ArrayList<Throwable> attachedTask() {
        final ArrayList<Throwable> mErrors = new ArrayList<>();

        // Reconnect and give permission time should under 9 second
        long mAttachedConfirmTime = 9 * 1000;

        CompletableFuture<Void> mAttachedThreadFinished = new CompletableFuture<>();

        IntentFilter filter = new IntentFilter();
        filter.addAction(ACTION_USB_PERMISSION);
        filter.addAction(UsbManager.ACTION_USB_DEVICE_ATTACHED);

        mUsbDeviceAttachedReceiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                synchronized (UsbDeviceTestActivity.this) {
                    UsbDevice device = intent.getParcelableExtra(UsbManager.EXTRA_DEVICE);

                    switch (intent.getAction()) {
                        case UsbManager.ACTION_USB_DEVICE_ATTACHED:
                            if (!AoapInterface.isDeviceInAoapMode(device)) {
                                mStatus.setText(R.string.usb_device_test_step2);
                            }

                            mUsbManager.requestPermission(device,
                                    PendingIntent.getBroadcast(UsbDeviceTestActivity.this, 0,
                                         new Intent(ACTION_USB_PERMISSION), PendingIntent.FLAG_MUTABLE_UNAUDITED));
                            break;
                    }
                }
            }
        };

        mUsbDevicePermissionReceiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                synchronized (UsbDeviceTestActivity.this) {
                    UsbDevice device = intent.getParcelableExtra(UsbManager.EXTRA_DEVICE);
                    switch (intent.getAction()) {
                        case ACTION_USB_PERMISSION:
                            boolean granted = intent.getBooleanExtra(
                                    UsbManager.EXTRA_PERMISSION_GRANTED, false);
                            if (granted) {
                                if (!AoapInterface.isDeviceInAoapMode(device)) {
                                    mStatus.setText(R.string.usb_device_test_step3);

                                    UsbDeviceConnection connection =
                                            mUsbManager.openDevice(device);
                                    try {
                                        makeThisDeviceAnAccessory(connection);
                                    } finally {
                                        connection.close();
                                    }
                                } else {
                                    mStatus.setText(R.string.usb_device_test_step4);
                                    mProgress.setIndeterminate(true);
                                    mProgress.setVisibility(View.VISIBLE);

                                    UsbDeviceConnection connection =
                                            mUsbManager.openDevice(device);
                                    assertNotNull(connection);

                                    try {
                                        setConfigurationTests(device);
                                    } catch (Throwable e) {
                                        synchronized (mErrors) {
                                            mErrors.add(e);
                                        }
                                    }
                                    try {
                                        reconnectTest(device);
                                    } catch (Throwable e) {
                                        synchronized (mErrors) {
                                            mErrors.add(e);
                                        }
                                    }

                                    mAttachedThreadFinished.complete(null);
                                }
                            } else {
                                fail(""Permission to connect to "" + device.getProductName()
                                        + "" not granted"", null);
                            }
                            break;
                    }
                }
            }
        };

        registerReceiver(mUsbDeviceAttachedReceiver, filter);
        registerReceiver(mUsbDevicePermissionReceiver, filter);

        try {
            mAttachedThreadFinished.get(mAttachedConfirmTime, TimeUnit.MILLISECONDS);
        } catch (Throwable e) {
            synchronized (mErrors) {
                mErrors.add(e);
            }
        }

        unregisterReceiver(mUsbDeviceAttachedReceiver);
        mUsbDeviceAttachedReceiver = null;

        unregisterReceiver(mUsbDevicePermissionReceiver);
        mUsbDevicePermissionReceiver = null;

        return mErrors;
    }

    /**
     * Tests parallel issuance and receiving of {@link UsbRequest usb requests}.
     *
     * @param connection The connection to use for testing
     * @param iface      The interface of the android accessory interface of the device
     */
    private void parallelUsbRequestsTests(@NonNull UsbDeviceConnection connection,
            @NonNull UsbInterface iface) {
        // Find bulk in and out endpoints
        assertTrue(iface.getEndpointCount() == 2);
        final UsbEndpoint in = getEndpoint(iface, UsbConstants.USB_DIR_IN);
        final UsbEndpoint out = getEndpoint(iface, UsbConstants.USB_DIR_OUT);
        assertNotNull(in);
        assertNotNull(out);

        // Recycler for requests for the in-endpoint
        Recycler<UsbRequest> inRequestRecycler = new Recycler<UsbRequest>() {
            @Override
            protected void reset(@NonNull UsbRequest recycledElement) {
                recycledElement.setClientData(new Object());
            }

            @Override
            protected @NonNull UsbRequest create() {
                UsbRequest request = new UsbRequest();
                request.initialize(connection, in);

                return request;
            }
        };

        // Recycler for requests for the in-endpoint
        Recycler<UsbRequest> outRequestRecycler = new Recycler<UsbRequest>() {
            @Override
            protected void reset(@NonNull UsbRequest recycledElement) {
                recycledElement.setClientData(new Object());
            }

            @Override
            protected @NonNull UsbRequest create() {
                UsbRequest request = new UsbRequest();
                request.initialize(connection, out);

                return request;
            }
        };

        // Recycler for requests for read and write buffers
        Recycler<ByteBuffer> bufferRecycler = new Recycler<ByteBuffer>() {
            @Override
            protected void reset(@NonNull ByteBuffer recycledElement) {
                recycledElement.rewind();
            }

            @Override
            protected @NonNull ByteBuffer create() {
                return ByteBuffer.allocateDirect(9);
            }
        };

        HashMap<UsbRequest, RequestState> requestsInFlight = new HashMap<>();

        // Data in the requests
        HashMap<Integer, Integer> data = new HashMap<>();
        AtomicInteger counter = new AtomicInteger(0);

        // Errors created in the threads
        ArrayList<Throwable> errors = new ArrayList<>();

        // Create two threads that queue read and write requests
        QueuerThread queuer1 = new QueuerThread(connection, inRequestRecycler,
                outRequestRecycler, bufferRecycler, requestsInFlight, data, counter, errors);
        QueuerThread queuer2 = new QueuerThread(connection, inRequestRecycler,
                outRequestRecycler, bufferRecycler, requestsInFlight, data, counter, errors);

        // Create a thread that receives the requests after they are processed.
        ReceiverThread receiver = new ReceiverThread(connection, out, inRequestRecycler,
                outRequestRecycler, bufferRecycler, requestsInFlight, data, errors);

        nextTest(connection, in, out, ""Echo until stop signal"");

        queuer1.start();
        queuer2.start();
        receiver.start();

        Log.i(LOG_TAG, ""Waiting for queuers to stop"");

        try {
            queuer1.join();
            queuer2.join();
        } catch (InterruptedException e) {
            synchronized(errors) {
                errors.add(e);
            }
        }

        if (errors.isEmpty()) {
            Log.i(LOG_TAG, ""Wait for all requests to finish"");
            synchronized (requestsInFlight) {
                while (!requestsInFlight.isEmpty()) {
                    try {
                        requestsInFlight.wait();
                    } catch (InterruptedException e) {
                        synchronized(errors) {
                            errors.add(e);
                        }
                        break;
                    }
                }
            }

            receiver.abort();

            try {
                receiver.join();
            } catch (InterruptedException e) {
                synchronized(errors) {
                    errors.add(e);
                }
            }

            // Close all requests that are currently recycled
            inRequestRecycler.getAll().forEach(UsbRequest::close);
            outRequestRecycler.getAll().forEach(UsbRequest::close);
        } else {
            receiver.abort();
        }

        for (Throwable t : errors) {
            Log.e(LOG_TAG, ""Error during test"", t);
        }

        byte[] stopBytes = new byte[9];
        connection.bulkTransfer(out, stopBytes, 9, 0);

        // If we had any error make the test fail
        assertEquals(0, errors.size());
    }

    /**
     * Tests {@link UsbDeviceConnection#bulkTransfer}.
     *
     * @param connection The connection to use for testing
     * @param iface      The interface of the android accessory interface of the device
     * @throws Throwable
     */
    private void bulkTransferTests(@NonNull UsbDeviceConnection connection,
            @NonNull UsbInterface iface) throws Throwable {
        // Find bulk in and out endpoints
        assertTrue(iface.getEndpointCount() == 2);
        final UsbEndpoint in = getEndpoint(iface, UsbConstants.USB_DIR_IN);
        final UsbEndpoint out = getEndpoint(iface, UsbConstants.USB_DIR_OUT);
        assertNotNull(in);
        assertNotNull(out);

        // Transmission tests
        nextTest(connection, in, out, ""Echo 1 byte"");
        echoBulkTransfer(connection, in, out, 1);

        nextTest(connection, in, out, ""Echo 42 bytes"");
        echoBulkTransferOffset(connection, in, out, 23, 42);

        nextTest(connection, in, out, ""Echo 16384 bytes"");
        echoBulkTransfer(connection, in, out, 16384);

        nextTest(connection, in, out, ""Echo large buffer"");
        echoLargeBulkTransfer(connection, in, out);

        // Illegal arguments
        runAndAssertException(() -> connection.bulkTransfer(out, new byte[1], 2, 0),
                IllegalArgumentException.class);
        runAndAssertException(() -> connection.bulkTransfer(in, new byte[1], 2, 0),
                IllegalArgumentException.class);
        runAndAssertException(() -> connection.bulkTransfer(out, new byte[2], 1, 2, 0),
                IllegalArgumentException.class);
        runAndAssertException(() -> connection.bulkTransfer(in, new byte[2], 1, 2, 0),
                IllegalArgumentException.class);
        runAndAssertException(() -> connection.bulkTransfer(out, new byte[1], -1, 0),
                IllegalArgumentException.class);
        runAndAssertException(() -> connection.bulkTransfer(in, new byte[1], -1, 0),
                IllegalArgumentException.class);
        runAndAssertException(() -> connection.bulkTransfer(out, new byte[1], 1, -1, 0),
                IllegalArgumentException.class);
        runAndAssertException(() -> connection.bulkTransfer(in, new byte[1], 1, -1, 0),
                IllegalArgumentException.class);
        runAndAssertException(() -> connection.bulkTransfer(out, new byte[1], -1, -1, 0),
                IllegalArgumentException.class);
        runAndAssertException(() -> connection.bulkTransfer(in, new byte[1], -1, -1, 0),
                IllegalArgumentException.class);
        runAndAssertException(() -> connection.bulkTransfer(null, new byte[1], 1, 0),
                NullPointerException.class);

        // Transmissions that do nothing
        int numSent = connection.bulkTransfer(out, null, 0, 0);
        assertEquals(0, numSent);

        numSent = connection.bulkTransfer(out, null, 0, 0, 0);
        assertEquals(0, numSent);

        numSent = connection.bulkTransfer(out, new byte[0], 0, 0);
        assertEquals(0, numSent);

        numSent = connection.bulkTransfer(out, new byte[0], 0, 0, 0);
        assertEquals(0, numSent);

        numSent = connection.bulkTransfer(out, new byte[2], 2, 0, 0);
        assertEquals(0, numSent);

        /* TODO: These tests are flaky as they appear to be affected by previous tests

        // Transmissions that do not transfer data:
        // - first transfer blocks until data is received, but does not return the data.
        // - The data is read in the second transfer
        nextTest(connection, in, out, ""Receive byte after some time"");
        receiveWithEmptyBuffer(connection, in, null, 0, 0);

        nextTest(connection, in, out, ""Receive byte after some time"");
        receiveWithEmptyBuffer(connection, in, new byte[0], 0, 0);

        nextTest(connection, in, out, ""Receive byte after some time"");
        receiveWithEmptyBuffer(connection, in, new byte[2], 2, 0);

        */

        // Timeouts
        int numReceived = connection.bulkTransfer(in, new byte[1], 1, 100);
        assertEquals(-1, numReceived);

        nextTest(connection, in, out, ""Receive byte after some time"");
        numReceived = connection.bulkTransfer(in, new byte[1], 1, 10000);
        assertEquals(1, numReceived);

        nextTest(connection, in, out, ""Receive byte after some time"");
        numReceived = connection.bulkTransfer(in, new byte[1], 1, 0);
        assertEquals(1, numReceived);

        nextTest(connection, in, out, ""Receive byte after some time"");
        numReceived = connection.bulkTransfer(in, new byte[1], 1, -1);
        assertEquals(1, numReceived);

        numReceived = connection.bulkTransfer(in, new byte[2], 1, 1, 100);
        assertEquals(-1, numReceived);

        nextTest(connection, in, out, ""Receive byte after some time"");
        numReceived = connection.bulkTransfer(in, new byte[2], 1, 1, 0);
        assertEquals(1, numReceived);

        nextTest(connection, in, out, ""Receive byte after some time"");
        numReceived = connection.bulkTransfer(in, new byte[2], 1, 1, -1);
        assertEquals(1, numReceived);
    }

    /**
     * Test if the companion device zero-terminates their requests that are multiples of the
     * maximum package size. Then sets {@link #mDoesCompanionZeroTerminate} if the companion
     * zero terminates
     *
     * @param connection Connection to the USB device
     * @param iface      The interface to use
     */
    private void testIfCompanionZeroTerminates(@NonNull UsbDeviceConnection connection,
            @NonNull UsbInterface iface) {
        assertTrue(iface.getEndpointCount() == 2);
        final UsbEndpoint in = getEndpoint(iface, UsbConstants.USB_DIR_IN);
        final UsbEndpoint out = getEndpoint(iface, UsbConstants.USB_DIR_OUT);
        assertNotNull(in);
        assertNotNull(out);

        nextTest(connection, in, out, ""does companion zero terminate"");

        // The other size sends:
        // - 1024 bytes
        // - maybe a zero sized package
        // - 1 byte

        byte[] buffer = new byte[1024];
        int numTransferred = connection.bulkTransfer(in, buffer, 1024, 0);
        assertEquals(1024, numTransferred);

        numTransferred = connection.bulkTransfer(in, buffer, 1, 0);
        if (numTransferred == 0) {
            assertEquals(0, numTransferred);

            numTransferred = connection.bulkTransfer(in, buffer, 1, 0);
            assertEquals(1, numTransferred);

            mDoesCompanionZeroTerminate = true;
            Log.i(LOG_TAG, ""Companion zero terminates"");
        } else {
            assertEquals(1, numTransferred);
            Log.i(LOG_TAG, ""Companion does not zero terminate - an older device"");
        }
    }

    /**
     * Send signal to the remove device that testing is finished.
     *
     * @param connection The connection to use for testing
     * @param iface      The interface of the android accessory interface of the device
     */
    private void endTesting(@NonNull UsbDeviceConnection connection, @NonNull UsbInterface iface) {
        // ""done"" signals that testing is over
        nextTest(connection, getEndpoint(iface, UsbConstants.USB_DIR_IN),
                getEndpoint(iface, UsbConstants.USB_DIR_OUT), ""done"");
    }

    /**
     * Test the behavior of {@link UsbDeviceConnection#claimInterface} and
     * {@link UsbDeviceConnection#releaseInterface}.
     *
     * <p>Note: The interface under test is <u>not</u> claimed by a kernel driver, hence there is
     * no difference in behavior between force and non-force versions of
     * {@link UsbDeviceConnection#claimInterface}</p>
     *
     * @param connection The connection to use
     * @param iface The interface to claim and release
     *
     * @throws Throwable
     */
    private void claimInterfaceTests(@NonNull UsbDeviceConnection connection,
            @NonNull UsbInterface iface) throws Throwable {
        // The interface is not claimed by the kernel driver, so not forcing it should work
        boolean claimed = connection.claimInterface(iface, false);
        assertTrue(claimed);
        boolean released = connection.releaseInterface(iface);
        assertTrue(released);

        // Forcing if it is not necessary does no harm
        claimed = connection.claimInterface(iface, true);
        assertTrue(claimed);

        // Re-claiming does nothing
        claimed = connection.claimInterface(iface, true);
        assertTrue(claimed);

        released = connection.releaseInterface(iface);
        assertTrue(released);

        // Re-releasing is not allowed
        released = connection.releaseInterface(iface);
        assertFalse(released);

        // Using an unclaimed interface claims it automatically
        int numSent = connection.bulkTransfer(getEndpoint(iface, UsbConstants.USB_DIR_OUT), null, 0,
                0);
        assertEquals(0, numSent);

        released = connection.releaseInterface(iface);
        assertTrue(released);

        runAndAssertException(() -> connection.claimInterface(null, true),
                NullPointerException.class);
        runAndAssertException(() -> connection.claimInterface(null, false),
                NullPointerException.class);
        runAndAssertException(() -> connection.releaseInterface(null), NullPointerException.class);
    }

    /**
     * Test all input parameters to {@link UsbDeviceConnection#setConfiguration} .
     *
     * <p>Note:
     * <ul>
     *     <li>The device under test only supports one configuration, hence changing configuration
     * is not tested.</li>
     *     <li>This test sets the current configuration again. This resets the device.</li>
     * </ul></p>
     *
     * @param device the device under test
     *
     * @throws Throwable
     */
    private void setConfigurationTests(@NonNull UsbDevice device) throws Throwable {
        // Find the AOAP interface
        ArrayList<String> allInterfaces = new ArrayList<>();

        // After getConfiguration the original device already disconnect, after
        // test check should use new device and connection
        UsbDeviceConnection connection = mUsbManager.openDevice(device);
        assertNotNull(connection);

        UsbInterface iface = null;
        for (int i = 0; i < device.getConfigurationCount(); i++) {
            allInterfaces.add(device.getInterface(i).toString());

            if (device.getInterface(i).getName().equals(""Android Accessory Interface"")) {
                iface = device.getInterface(i);
                break;
            }
        }

        // Cannot set configuration for a device with a claimed interface
        boolean claimed = connection.claimInterface(iface, false);
        assertTrue(claimed);
        boolean wasSet = connection.setConfiguration(device.getConfiguration(0));
        assertFalse(wasSet);
        boolean released = connection.releaseInterface(iface);
        assertTrue(released);

        runAndAssertException(() -> connection.setConfiguration(null), NullPointerException.class);
    }

    /**
     * Test all input parameters to {@link UsbDeviceConnection#setConfiguration} .
     *
     * <p>Note: The interface under test only supports one settings, hence changing the setting can
     * not be tested.</p>
     *
     * @param connection The connection to use
     * @param iface The interface to test
     *
     * @throws Throwable
     */
    private void setInterfaceTests(@NonNull UsbDeviceConnection connection,
            @NonNull UsbInterface iface) throws Throwable {
        boolean claimed = connection.claimInterface(iface, false);
        assertTrue(claimed);
        boolean wasSet = connection.setInterface(iface);
        assertTrue(wasSet);
        boolean released = connection.releaseInterface(iface);
        assertTrue(released);

        // Setting the interface for an unclaimed interface automatically claims it
        wasSet = connection.setInterface(iface);
        assertTrue(wasSet);
        released = connection.releaseInterface(iface);
        assertTrue(released);

        runAndAssertException(() -> connection.setInterface(null), NullPointerException.class);
    }

    /**
     * Enumerate all known devices and check basic relationship between the properties.
     */
    private void enumerateDevices(@NonNull UsbDevice companionDevice) throws Exception {
        Set<Integer> knownDeviceIds = new ArraySet<>();

        for (Map.Entry<String, UsbDevice> entry : mUsbManager.getDeviceList().entrySet()) {
            UsbDevice device = entry.getValue();

            assertEquals(entry.getKey(), device.getDeviceName());
            assertNotNull(device.getDeviceName());

            // Device ID should be unique
            assertFalse(knownDeviceIds.contains(device.getDeviceId()));
            knownDeviceIds.add(device.getDeviceId());

            assertEquals(device.getDeviceName(), UsbDevice.getDeviceName(device.getDeviceId()));

            // Properties without constraints
            device.getManufacturerName();
            device.getProductName();
            device.getVersion();

            // We are only guaranteed to have permission to the companion device.
            if (device.equals(companionDevice)) {
                device.getSerialNumber();
            }

            device.getVendorId();
            device.getProductId();
            device.getDeviceClass();
            device.getDeviceSubclass();
            device.getDeviceProtocol();

            Set<UsbInterface> interfacesFromAllConfigs = new ArraySet<>();
            Set<Integer> knownConfigurationIds = new ArraySet<>();
            int numConfigurations = device.getConfigurationCount();
            for (int configNum = 0; configNum < numConfigurations; configNum++) {
                UsbConfiguration config = device.getConfiguration(configNum);
                Set<Pair<Integer, Integer>> knownInterfaceIds = new ArraySet<>();

                // Configuration ID should be unique
                assertFalse(knownConfigurationIds.contains(config.getId()));
                knownConfigurationIds.add(config.getId());

                assertTrue(config.getMaxPower() >= 0);

                // Properties without constraints
                config.getName();
                config.isSelfPowered();
                config.isRemoteWakeup();

                int numInterfaces = config.getInterfaceCount();
                for (int interfaceNum = 0; interfaceNum < numInterfaces; interfaceNum++) {
                    UsbInterface iface = config.getInterface(interfaceNum);
                    interfacesFromAllConfigs.add(iface);

                    Pair<Integer, Integer> ifaceId = new Pair<>(iface.getId(),
                            iface.getAlternateSetting());
                    assertFalse(knownInterfaceIds.contains(ifaceId));
                    knownInterfaceIds.add(ifaceId);

                    // Properties without constraints
                    iface.getName();
                    iface.getInterfaceClass();
                    iface.getInterfaceSubclass();
                    iface.getInterfaceProtocol();

                    int numEndpoints = iface.getEndpointCount();
                    for (int endpointNum = 0; endpointNum < numEndpoints; endpointNum++) {
                        UsbEndpoint endpoint = iface.getEndpoint(endpointNum);

                        assertEquals(endpoint.getAddress(),
                                endpoint.getEndpointNumber() | endpoint.getDirection());

                        assertTrue(endpoint.getDirection() == UsbConstants.USB_DIR_OUT ||
                                endpoint.getDirection() == UsbConstants.USB_DIR_IN);

                        assertTrue(endpoint.getType() == UsbConstants.USB_ENDPOINT_XFER_CONTROL ||
                                endpoint.getType() == UsbConstants.USB_ENDPOINT_XFER_ISOC ||
                                endpoint.getType() == UsbConstants.USB_ENDPOINT_XFER_BULK ||
                                endpoint.getType() == UsbConstants.USB_ENDPOINT_XFER_INT);

                        assertTrue(endpoint.getMaxPacketSize() >= 0);
                        assertTrue(endpoint.getInterval() >= 0);

                        // Properties without constraints
                        endpoint.getAttributes();
                    }
                }
            }

            int numInterfaces = device.getInterfaceCount();
            for (int interfaceNum = 0; interfaceNum < numInterfaces; interfaceNum++) {
                assertTrue(interfacesFromAllConfigs.contains(device.getInterface(interfaceNum)));
            }
        }
    }

    /**
     * Run tests.
     *
     * @param device The device to run the test against. This device is running
     *               com.android.cts.verifierusbcompanion.DeviceTestCompanion
     */
    private void runTests(@NonNull UsbDevice device) {
        try {
            // Find the AOAP interface
            ArrayList<String> allInterfaces = new ArrayList<>();

            // Errors created in the threads
            ArrayList<Throwable> errors = new ArrayList<>();

            // Reconnect should get attached intent and pass test in 10 seconds
            long attachedTime = 10 * 1000;

            UsbInterface iface = null;
            for (int i = 0; i < device.getConfigurationCount(); i++) {
                allInterfaces.add(device.getInterface(i).toString());

                if (device.getInterface(i).getName().equals(""Android Accessory Interface"")) {
                    iface = device.getInterface(i);
                    break;
                }
            }
            assertNotNull(""No \""Android Accessory Interface\"" interface found in "" + allInterfaces,
                    iface);

            enumerateDevices(device);

            UsbDeviceConnection connection = mUsbManager.openDevice(device);
            assertNotNull(connection);

            claimInterfaceTests(connection, iface);

            boolean claimed = connection.claimInterface(iface, false);
            assertTrue(claimed);

            testIfCompanionZeroTerminates(connection, iface);

            usbRequestLegacyTests(connection, iface);
            usbRequestTests(connection, iface);
            parallelUsbRequestsTests(connection, iface);
            ctrlTransferTests(connection);
            bulkTransferTests(connection, iface);

            // Signal to the DeviceTestCompanion that there are no more transfer test
            endTesting(connection, iface);
            boolean released = connection.releaseInterface(iface);
            assertTrue(released);

            CompletableFuture<ArrayList<Throwable>> attached =
                    CompletableFuture.supplyAsync(() -> {
                        return attachedTask();
                    });

            setInterfaceTests(connection, iface);

            assertTrue(device.getConfigurationCount() == 1);
            assertTrue(connection.setConfiguration(device.getConfiguration(0)));

            errors = attached.get(attachedTime, TimeUnit.MILLISECONDS);

            // If reconnect timeout make the test fail
            assertEquals(0, errors.size());

            connection.close();

            // We should not be able to communicate with the device anymore
            assertFalse(connection.claimInterface(iface, true));
            assertFalse(connection.releaseInterface(iface));
            assertFalse(connection.setConfiguration(device.getConfiguration(0)));
            assertFalse(connection.setInterface(iface));
            assertTrue(connection.getFileDescriptor() == -1);
            assertNull(connection.getRawDescriptors());
            assertNull(connection.getSerial());
            assertEquals(-1, connection.bulkTransfer(getEndpoint(iface, UsbConstants.USB_DIR_OUT),
                    new byte[1], 1, 0));
            assertEquals(-1, connection.bulkTransfer(getEndpoint(iface, UsbConstants.USB_DIR_OUT),
                    null, 0, 0));
            assertEquals(-1, connection.bulkTransfer(getEndpoint(iface, UsbConstants.USB_DIR_IN),
                    null, 0, 0));
            assertFalse((new UsbRequest()).initialize(connection, getEndpoint(iface,
                    UsbConstants.USB_DIR_IN)));

            // Double close should do no harm
            connection.close();

            setTestResultAndFinish(true);
        } catch (Throwable e) {
            fail(null, e);
        }
    }

    @Override
    protected void onDestroy() {
        if (mUsbDeviceConnectionReceiver != null) {
            unregisterReceiver(mUsbDeviceConnectionReceiver);
        }
        if (mUsbDeviceAttachedReceiver != null) {
            unregisterReceiver(mUsbDeviceAttachedReceiver);
        }
        if (mUsbDevicePermissionReceiver != null) {
            unregisterReceiver(mUsbDevicePermissionReceiver);
        }

        super.onDestroy();
    }
}"	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/usb/device/UsbDeviceTestActivity.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.google.android.cts.settings.PrivacyDeviceOwnerTest"	"testNonDeviceOwnerWithoutInfo"	"CtsSettingsHostTestCases"	"4: apps ui system user"	"public void testNonDeviceOwnerWithoutInfo() throws Exception {
        if (!mHasFeature) {
            return;
        }
        executeDeviceOwnerTest(""testNonDeviceOwnerWithoutInfo"");
    }

    private void executeDeviceOwnerTest(String testMethodName) throws Exception {
        String testClass = DEVICE_OWNER_PKG + "".DeviceOwnerTest"";
        assertTrue(
                testClass + "" failed."",
                runDeviceTests(DEVICE_OWNER_PKG, testClass, testMethodName));
    }

    protected void installPackage(int userId, String appFileName)
            throws FileNotFoundException, DeviceNotAvailableException {
        CLog.d(""Installing app %s on user %d"", appFileName, userId);
        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);
        List<String> extraArgs = new LinkedList<>();
        extraArgs.add(""-t"");
        String result =
                getDevice()
                        .installPackageForUser(
                                buildHelper.getTestFile(appFileName),
                                true,
                                true,
                                userId,
                                extraArgs.toArray(new String[extraArgs.size()]));
        assertNull(""Failed to install "" + appFileName + "" on user "" + userId + "": "" + result,
                result);
    }

    protected boolean runDeviceTests(
            String pkgName, @Nullable String testClassName, @Nullable String testMethodName)
            throws DeviceNotAvailableException {
        if (testClassName != null && testClassName.startsWith(""."")) {
            testClassName = pkgName + testClassName;
        }
        RemoteAndroidTestRunner testRunner =
                new RemoteAndroidTestRunner(pkgName, RUNNER, getDevice().getIDevice());
        testRunner.setMaxTimeToOutputResponse(DEFAULT_SHELL_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
        testRunner.addInstrumentationArg(
                TEST_TIMEOUT_INST_ARGS_KEY, Long.toString(DEFAULT_TEST_TIMEOUT_MILLIS));

        if (testClassName != null && testMethodName != null) {
            testRunner.setMethodName(testClassName, testMethodName);
        } else if (testClassName != null) {
            testRunner.setClassName(testClassName);
        }

        CollectingTestListener listener = new CollectingTestListener();
        CLog.i(""Running %s.%s on user %d"", testClassName, testMethodName, mTestUserId);
        boolean runResult = getDevice().runInstrumentationTestsAsUser(testRunner, mTestUserId,
                listener);

        final TestRunResult result = listener.getCurrentRunResults();
        if (result.isRunFailure()) {
            throw new AssertionError(
                    ""Failed to successfully run device tests for ""
                            + result.getName()
                            + "": ""
                            + result.getRunFailureMessage());
        }
        if (result.getNumTests() == 0) {
            throw new AssertionError(""No tests were run on the device"");
        }

        if (result.hasFailedTests()) {
            // build a meaningful error message
            StringBuilder errorBuilder = new StringBuilder(""On-device tests failed:\n"");
            for (Map.Entry<TestDescription, TestResult> resultEntry :
                    result.getTestResults().entrySet()) {
                if (!resultEntry.getValue().getStatus().equals(TestStatus.PASSED)) {
                    errorBuilder.append(resultEntry.getKey().toString());
                    errorBuilder.append("":\n"");
                    errorBuilder.append(resultEntry.getValue().getStackTrace());
                }
            }
            throw new AssertionError(errorBuilder.toString());
        }

        return runResult;
    }

    private void setDeviceOwner() throws DeviceNotAvailableException {
        String componentName = DEVICE_OWNER_PKG + ""/"" + ADMIN_RECEIVER_TEST_CLASS;
        String command = ""dpm set-device-owner '"" + componentName + ""'"";
        String commandOutput = getDevice().executeShellCommand(command);
        CLog.logAndDisplay(LogLevel.INFO, ""Output for command "" + command + "": "" + commandOutput);
        assertTrue(
                commandOutput + "" expected to start with \""Success:\"" "" + commandOutput,
                commandOutput.startsWith(""Success:""));
    }

    protected boolean hasDeviceFeature(String requiredFeature) throws DeviceNotAvailableException {
        String command = ""pm list features"";
        String commandOutput = getDevice().executeShellCommand(command);
        CLog.i(""Output for command "" + command + "": "" + commandOutput);

        Set<String> availableFeatures = new HashSet<>();
        for (String feature : commandOutput.split(""\\s+"")) {
            // Each line in the output of the command has the format ""feature:{FEATURE_VALUE}"".
            String[] tokens = feature.split("":"");
            assertTrue(
                    ""\"""" + feature + ""\"" expected to have format feature:{FEATURE_VALUE}"",
                    tokens.length > 1);
            assertEquals(feature, ""feature"", tokens[0]);
            availableFeatures.add(tokens[1]);
        }
        boolean result = availableFeatures.contains(requiredFeature);
        if (!result) {
            CLog.d(""Device doesn't have required feature "" + requiredFeature + "". Test won't run."");
        }
        return result;
    }

    protected void grantDpmWrapperPermissions(int userId) throws Exception {
        // TODO(b/176993670): INTERACT_ACROSS_USERS is needed by DevicePolicyManagerWrapper to
        // get the current user; the permission is available on mDeviceOwnerUserId because it
        // was installed with -g, but not on mPrimaryUserId as the app is intalled by code
        // (DPMS.manageUserUnchecked(), which don't grant it (as this is a privileged permission
        // that's not available to 3rd party apps). If we get rid of DevicePolicyManagerWrapper,
        // we won't need to grant it anymore.
        CLog.i(""Granting INTERACT_ACROSS_USERS to DO %s on user %d as it will need to send ordered ""
                + ""broadcasts to user 0"", DEVICE_OWNER_PKG, userId);
        getDevice().executeShellCommand(""pm grant --user "" + userId + "" "" + DEVICE_OWNER_PKG
                + "" android.permission.INTERACT_ACROSS_USERS"");
    }

    // TODO (b/174775905) remove after exposing the check from ITestDevice.
    boolean isHeadlessSystemUserMode() throws DeviceNotAvailableException {
        return isHeadlessSystemUserMode(getDevice());
    }

    // TODO (b/174775905) remove after exposing the check from ITestDevice.
    public static boolean isHeadlessSystemUserMode(ITestDevice device)
            throws DeviceNotAvailableException {
        final String result = device
                .executeShellCommand(""getprop ro.fw.mu.headless_system_user"").trim();
        return ""true"".equalsIgnoreCase(result);
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/settings/src/com/google/android/cts/settings/PrivacyDeviceOwnerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.google.android.cts.settings.PrivacyDeviceOwnerTest"	"isHeadlessSystemUserMode"	"CtsSettingsHostTestCases"	"3: ui system user"	"public void test/*
 *.
 */
package com.google.android.cts.settings;

import com.android.compatibility.common.tradefed.build.CompatibilityBuildHelper;
import com.android.ddmlib.Log.LogLevel;
import com.android.ddmlib.testrunner.RemoteAndroidTestRunner;
import com.android.ddmlib.testrunner.TestResult.TestStatus;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.log.LogUtil.CLog;
import com.android.tradefed.result.CollectingTestListener;
import com.android.tradefed.result.TestDescription;
import com.android.tradefed.result.TestResult;
import com.android.tradefed.result.TestRunResult;
import com.android.tradefed.testtype.DeviceTestCase;
import com.android.tradefed.testtype.IBuildReceiver;
import java.io.FileNotFoundException;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import javax.annotation.Nullable;

/** Set of tests for Device Owner use cases. */
public class PrivacyDeviceOwnerTest extends DeviceTestCase implements IBuildReceiver {
    private static final String RUNNER = ""androidx.test.runner.AndroidJUnitRunner"";

    private static final String DEVICE_OWNER_APK = ""CtsSettingsDeviceOwnerApp.apk"";
    private static final String DEVICE_OWNER_PKG = ""com.google.android.cts.deviceowner"";

    private static final String ADMIN_RECEIVER_TEST_CLASS = "".DeviceOwnerTest$BasicAdminReceiver"";
    private static final String CLEAR_DEVICE_OWNER_TEST_CLASS = "".ClearDeviceOwnerTest"";

    // TODO (b/174775905) move to ITestDevice.
    private static final int USER_SYSTEM = 0;

    /**
     * The defined timeout (in milliseconds) is used as a maximum waiting time when expecting the
     * command output from the device. At any time, if the shell command does not output anything
     * for a period longer than defined timeout the Tradefed run terminates.
     */
    private static final long DEFAULT_SHELL_TIMEOUT_MILLIS = TimeUnit.MINUTES.toMillis(20);

    /** instrumentation test runner argument key used for individual test timeout */
    protected static final String TEST_TIMEOUT_INST_ARGS_KEY = ""timeout_msec"";

    /**
     * Sets timeout (in milliseconds) that will be applied to each test. In the event of a test
     * timeout it will log the results and proceed with executing the next test.
     */
    private static final long DEFAULT_TEST_TIMEOUT_MILLIS = TimeUnit.MINUTES.toMillis(10);

    protected boolean mHasFeature;
    protected IBuildInfo mCtsBuild;

    private int mDeviceOwnerUserId;
    private int mTestUserId;

    @Override
    public void setBuild(IBuildInfo buildInfo) {
        mCtsBuild = buildInfo;
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        mHasFeature = hasDeviceFeature(""android.software.device_admin"");
        if (!mHasFeature) return;

        mTestUserId = getDevice().getCurrentUser();
        if (isHeadlessSystemUserMode()) {
            mDeviceOwnerUserId = USER_SYSTEM;
        } else {
            mDeviceOwnerUserId = mTestUserId;
        }

        installPackage(mDeviceOwnerUserId, DEVICE_OWNER_APK);

        if (isHeadlessSystemUserMode()) {
            grantDpmWrapperPermissions(mTestUserId);
        }
    }

    @Override
    protected void tearDown() throws Exception {
        if (mHasFeature) {
            assertTrue(
                    ""Failed to remove device owner."",
                    runDeviceTests(
                            DEVICE_OWNER_PKG,
                            DEVICE_OWNER_PKG + CLEAR_DEVICE_OWNER_TEST_CLASS,
                            null));
            getDevice().uninstallPackage(DEVICE_OWNER_PKG);
        }

        super.tearDown();
    }

    /** The case: app is the device owner, has work policy info. */"	"/home/gpoor/cts-12-source/cts/hostsidetests/settings/src/com/google/android/cts/settings/PrivacyDeviceOwnerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.view.inputmethod.cts.SearchViewTest"	"testTapThenSetQuery"	"CtsInputMethodTestCases"	"2: hide ui"	"public void testTapThenSetQuery() throws Exception {
        try (MockImeSession imeSession = MockImeSession.create(
                InstrumentationRegistry.getInstrumentation().getContext(),
                InstrumentationRegistry.getInstrumentation().getUiAutomation(),
                new ImeSettings.Builder())) {
            final ImeEventStream stream = imeSession.openEventStream();

            final SearchView searchView = launchTestActivity(false /* requestFocus */);

            // Emulate tap event on SearchView
            CtsTouchUtils.emulateTapOnViewCenter(
                    InstrumentationRegistry.getInstrumentation(), null, searchView);

            // Expect input to bind since EditText is focused.
            expectBindInput(stream, Process.myPid(), TIMEOUT);

            // Wait until ""showSoftInput"" gets called with a real InputConnection
            expectEvent(stream, event ->
                    ""showSoftInput"".equals(event.getEventName())
                            && !event.getExitState().hasFallbackInputConnection(),
                    CHECK_EXIT_EVENT_ONLY, TIMEOUT);

            expectImeVisible(TIMEOUT);

            // Make sure that ""setQuery"" triggers ""hideSoftInput"" in the IME side.
            runOnMainSync(() -> searchView.setQuery(""test"", true /* submit */));
            expectEvent(stream, event -> ""hideSoftInput"".equals(event.getEventName()), TIMEOUT);

            expectImeInvisible(TIMEOUT);
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/SearchViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.view.inputmethod.cts.SearchViewTest"	"testShowImeWhenSearchViewFocusInListView"	"CtsInputMethodTestCases"	"2: hide ui"	"public void testShowImeWhenSearchViewFocusInListView() throws Exception {
        try (MockImeSession imeSession = MockImeSession.create(
                InstrumentationRegistry.getInstrumentation().getContext(),
                InstrumentationRegistry.getInstrumentation().getUiAutomation(),
                new ImeSettings.Builder())) {
            final ImeEventStream stream = imeSession.openEventStream();

            final SearchView searchView = launchTestActivityWithListView(true /* requestFocus */);

            // Emulate tap event on SearchView
            CtsTouchUtils.emulateTapOnViewCenter(
                    InstrumentationRegistry.getInstrumentation(), null, searchView);

            // Expect input to bind since EditText is focused.
            expectBindInput(stream, Process.myPid(), TIMEOUT);

            // Wait until ""showSoftInput"" gets called with a real InputConnection
            expectEvent(stream, event ->
                            ""showSoftInput"".equals(event.getEventName())
                                    && !event.getExitState().hasFallbackInputConnection(),
                    CHECK_EXIT_EVENT_ONLY, TIMEOUT);

            expectImeVisible(TIMEOUT);

            notExpectEvent(stream, event -> ""hideSoftInput"".equals(event.getEventName()),
                    NOT_EXPECT_TIMEOUT);
        }
    }

    static final class SingleItemAdapter extends BaseAdapter {
        private final SearchView mSearchView;

        SingleItemAdapter(SearchView searchView) {
            mSearchView = searchView;
        }

        @Override
        public int getCount() {
            return 1;
        }

        @Override
        public Object getItem(int i) {
            return mSearchView;
        }

        @Override
        public long getItemId(int i) {
            return 0;
        }

        @Override
        public View getView(int i, View view, ViewGroup viewGroup) {
            return mSearchView;
        }
    }
}"	"/home/gpoor/cts-12-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/SearchViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.view.inputmethod.cts.SearchViewTest"	"testShowImeWithSearchViewFocus"	"CtsInputMethodTestCases"	"2: ui system"	"public void testShowImeWithSearchViewFocus() throws Exception {
        try (MockImeSession imeSession = MockImeSession.create(
                InstrumentationRegistry.getInstrumentation().getContext(),
                InstrumentationRegistry.getInstrumentation().getUiAutomation(),
                new ImeSettings.Builder())) {
            final ImeEventStream stream = imeSession.openEventStream();

            final SearchView searchView = launchTestActivity(true /* requestFocus */);

            // Expect input to bind since checkInputConnectionProxy() returns true.
            expectBindInput(stream, Process.myPid(), TIMEOUT);

            runOnMainSync(() -> searchView.getContext().getSystemService(InputMethodManager.class)
                    .showSoftInput(searchView, 0));

            // Wait until ""showSoftInput"" gets called on searchView's inner editor
            // (SearchAutoComplete) with real InputConnection.
            expectEvent(stream, event ->
                    ""showSoftInput"".equals(event.getEventName())
                            && !event.getExitState().hasFallbackInputConnection(),
                    CHECK_EXIT_EVENT_ONLY, TIMEOUT);

            expectImeVisible(TIMEOUT);
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/inputmethod/src/android/view/inputmethod/cts/SearchViewTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.devicepolicy.LauncherAppsMultiUserTest"	"assumeTestEnabled"	"CtsDevicePolicyManagerTestCases"	"2: apps user"	"/*
 *.
 */

package com.android.cts.devicepolicy;

import org.junit.Test;

import java.util.Collections;

/**
 * Set of tests for LauncherApps attempting to access a non-profiles
 * apps.
 */
public class LauncherAppsMultiUserTest extends BaseLauncherAppsTest {

    private int mSecondaryUserId;
    private String mSecondaryUserSerialNumber;

    @Override
    protected void assumeTestEnabled() throws Exception {
        // We need multi user to be supported in order to create a secondary user
        // and api level 21 to support LauncherApps
        assumeSupportsMultiUser();
        assumeApiLevel(21);
    }

    @Override
    public void setUp() throws Exception {
        super.setUp();

        removeTestUsers();
        uninstallTestApps();
        installTestApps(mPrimaryUserId);
        // Create a secondary user.
        mSecondaryUserId = createUser();
        mSecondaryUserSerialNumber = Integer.toString(getUserSerialNumber(mSecondaryUserId));
        startUser(mSecondaryUserId);
    }

    @Override
    public void tearDown() throws Exception {
        removeUser(mSecondaryUserId);
        uninstallTestApps();

        super.tearDown();
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/LauncherAppsMultiUserTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.devicepolicy.LauncherAppsMultiUserTest"	"testGetActivitiesForNonProfileFails"	"CtsDevicePolicyManagerTestCases"	"1: user"	"public void testGetActivitiesForNonProfileFails() throws Exception {
        installAppAsUser(SIMPLE_APP_APK, mPrimaryUserId);
        runDeviceTestsAsUser(LAUNCHER_TESTS_PKG,
                LAUNCHER_TESTS_CLASS,
                ""testGetActivitiesForUserFails"",
                mPrimaryUserId,
                Collections.singletonMap(PARAM_TEST_USER, mSecondaryUserSerialNumber));
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/LauncherAppsMultiUserTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.devicepolicy.LauncherAppsMultiUserTest"	"testNoLauncherCallbackPackageAddedSecondaryUser"	"CtsDevicePolicyManagerTestCases"	"1: user"	"public void testNoLauncherCallbackPackageAddedSecondaryUser() throws Exception {
        startCallbackService(mPrimaryUserId);
        installAppAsUser(SIMPLE_APP_APK, mPrimaryUserId);
        runDeviceTestsAsUser(LAUNCHER_TESTS_PKG,
                LAUNCHER_TESTS_CLASS,
                ""testNoPackageAddedCallbackForUser"",
                mPrimaryUserId,
                Collections.singletonMap(PARAM_TEST_USER, mSecondaryUserSerialNumber));
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/src/com/android/cts/devicepolicy/LauncherAppsMultiUserTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.server.wm.DumpOnFailure"	"exists"	"CtsWindowManagerDeviceTestCases"	"1: direct"	"public void test/*
 *.
 */

package android.server.wm;

import android.graphics.Bitmap;
import android.util.Log;

import com.android.compatibility.common.util.BitmapUtils;

import org.junit.rules.TestRule;
import org.junit.runner.Description;
import org.junit.runners.model.Statement;

import java.io.File;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.Map;

/**
 * A {@code TestRule} that allows dumping data on test failure.
 *
 * <p>Note: when using other {@code TestRule}s, make sure to use a {@code RuleChain} to ensure it
 * is applied outside of other rules that can fail a test (otherwise this rule may not know that the
 * test failed).
 *
 * <p>To capture the output of this rule, add the following to AndroidTest.xml:
 * <pre>
 *  <!-- Collect output of DumpOnFailure. -->
 *  <metrics_collector class=""com.android.tradefed.device.metric.FilePullerLogCollector"">
 *    <option name=""directory-keys"" value=""/sdcard/DumpOnFailure"" />
 *    <option name=""collect-on-run-ended-only"" value=""true"" />
 *  </metrics_collector>
 * </pre>
 * <p>And disable external storage isolation:
 * <pre>
 *  <uses-permission android:name=""android.permission.MANAGE_EXTERNAL_STORAGE"" />
 *  <application ... android:requestLegacyExternalStorage=""true"" ... >
 * </pre>
 */
public class DumpOnFailure implements TestRule {

    private static final String TAG = ""DumpOnFailure"";

    private final Map<String, Bitmap> mDumpOnFailureBitmaps = new HashMap<>();

    @Override
    public Statement apply(Statement base, Description description) {
        return new Statement() {
            @Override
            public void evaluate() throws Throwable {
                onTestSetup(description);
                try {
                    base.evaluate();
                } catch (Throwable t) {
                    onTestFailure(description, t);
                    throw t;
                } finally {
                    onTestTeardown(description);
                }
            }
        };
    }

    private void onTestSetup(Description description) {
        cleanDir(getDumpRoot(description).toFile());
        mDumpOnFailureBitmaps.clear();
    }

    private void onTestTeardown(Description description) {
        mDumpOnFailureBitmaps.clear();
    }

    private void onTestFailure(Description description, Throwable t) {
        Path root = getDumpRoot(description);
        File rootFile = root.toFile();
        if (!rootFile.exists() && !rootFile.mkdirs()) {
            throw new RuntimeException(""Unable to create "" + root);
        }

        for (Map.Entry<String, Bitmap> entry : mDumpOnFailureBitmaps.entrySet()) {
            String fileName = getFilename(description, entry.getKey(), ""png"");
            Log.i(TAG, ""Dumping "" + root + ""/"" + fileName);
            BitmapUtils.saveBitmap(entry.getValue(), root.toString(), fileName);
        }
    }

    private String getFilename(Description description, String name, String extension) {
        return description.getTestClass().getSimpleName() + ""_"" + description.getMethodName()
                + ""__"" + name + ""."" + extension;
    }

    private Path getDumpRoot(Description description) {
        return Paths.get(""/sdcard/DumpOnFailure/"", description.getClassName()
                + ""_"" + description.getMethodName());
    }

    private void cleanDir(File dir) {
        final File[] files = dir.listFiles();
        if (files == null) {
            return;
        }
        for (File file : files) {
            if (!file.isDirectory()) {
                if (!file.delete()) {
                    throw new RuntimeException(""Unable to delete "" + file);
                }
            }
        }
    }

    /**
     * Dumps the Bitmap if the test fails.
     */
    public void dumpOnFailure(String name, Bitmap bitmap) {
        if (mDumpOnFailureBitmaps.containsKey(name)) {
            int i = 1;
            while (mDumpOnFailureBitmaps.containsKey(name + ""_"" + i)) {
                ++i;
            }
            name += ""_"" + i;
        }
        mDumpOnFailureBitmaps.put(name, bitmap);
    }
}"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/DumpOnFailure.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.hardware.camera2.cts.CameraTestUtils"	"ImageDropperListener"	""	"6: mic direct ui system interaction user"	"public void test/*
 *.
 */

package android.hardware.camera2.cts;

import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.ImageFormat;
import android.graphics.PointF;
import android.graphics.Rect;
import android.graphics.SurfaceTexture;
import android.hardware.camera2.CameraAccessException;
import android.hardware.camera2.CameraCaptureSession;
import android.hardware.camera2.CameraConstrainedHighSpeedCaptureSession;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CameraManager;
import android.hardware.camera2.CameraMetadata;
import android.hardware.camera2.CameraCharacteristics;
import android.hardware.camera2.CaptureFailure;
import android.hardware.camera2.CaptureRequest;
import android.hardware.camera2.CaptureResult;
import android.hardware.camera2.MultiResolutionImageReader;
import android.hardware.camera2.cts.helpers.CameraErrorCollector;
import android.hardware.camera2.cts.helpers.StaticMetadata;
import android.hardware.camera2.params.InputConfiguration;
import android.hardware.camera2.TotalCaptureResult;
import android.hardware.cts.helpers.CameraUtils;
import android.hardware.camera2.params.MeteringRectangle;
import android.hardware.camera2.params.MandatoryStreamCombination;
import android.hardware.camera2.params.MandatoryStreamCombination.MandatoryStreamInformation;
import android.hardware.camera2.params.MultiResolutionStreamConfigurationMap;
import android.hardware.camera2.params.MultiResolutionStreamInfo;
import android.hardware.camera2.params.OutputConfiguration;
import android.hardware.camera2.params.SessionConfiguration;
import android.hardware.camera2.params.StreamConfigurationMap;
import android.location.Location;
import android.location.LocationManager;
import android.media.ExifInterface;
import android.media.Image;
import android.media.ImageReader;
import android.media.ImageWriter;
import android.media.Image.Plane;
import android.os.Build;
import android.os.ConditionVariable;
import android.os.Handler;
import android.util.Log;
import android.util.Pair;
import android.util.Size;
import android.util.Range;
import android.view.Display;
import android.view.Surface;
import android.view.WindowManager;

import com.android.ex.camera2.blocking.BlockingCameraManager;
import com.android.ex.camera2.blocking.BlockingCameraManager.BlockingOpenException;
import com.android.ex.camera2.blocking.BlockingSessionCallback;
import com.android.ex.camera2.blocking.BlockingStateCallback;
import com.android.ex.camera2.exceptions.TimeoutRuntimeException;

import junit.framework.Assert;

import org.mockito.Mockito;

import java.io.FileOutputStream;
import java.io.IOException;
import java.lang.reflect.Array;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.Executor;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import java.text.ParseException;
import java.text.SimpleDateFormat;

/**
 * A package private utility class for wrapping up the camera2 cts test common utility functions
 */
public class CameraTestUtils extends Assert {
    private static final String TAG = ""CameraTestUtils"";
    private static final boolean VERBOSE = Log.isLoggable(TAG, Log.VERBOSE);
    private static final boolean DEBUG = Log.isLoggable(TAG, Log.DEBUG);
    public static final Size SIZE_BOUND_720P = new Size(1280, 720);
    public static final Size SIZE_BOUND_1080P = new Size(1920, 1088);
    public static final Size SIZE_BOUND_2K = new Size(2048, 1088);
    public static final Size SIZE_BOUND_QHD = new Size(2560, 1440);
    public static final Size SIZE_BOUND_2160P = new Size(3840, 2160);
    // Only test the preview size that is no larger than 1080p.
    public static final Size PREVIEW_SIZE_BOUND = SIZE_BOUND_1080P;
    // Default timeouts for reaching various states
    public static final int CAMERA_OPEN_TIMEOUT_MS = 3000;
    public static final int CAMERA_CLOSE_TIMEOUT_MS = 3000;
    public static final int CAMERA_IDLE_TIMEOUT_MS = 3000;
    public static final int CAMERA_ACTIVE_TIMEOUT_MS = 1000;
    public static final int CAMERA_BUSY_TIMEOUT_MS = 1000;
    public static final int CAMERA_UNCONFIGURED_TIMEOUT_MS = 1000;
    public static final int CAMERA_CONFIGURE_TIMEOUT_MS = 3000;
    public static final int CAPTURE_RESULT_TIMEOUT_MS = 3000;
    public static final int CAPTURE_IMAGE_TIMEOUT_MS = 3000;

    public static final int SESSION_CONFIGURE_TIMEOUT_MS = 3000;
    public static final int SESSION_CLOSE_TIMEOUT_MS = 3000;
    public static final int SESSION_READY_TIMEOUT_MS = 5000;
    public static final int SESSION_ACTIVE_TIMEOUT_MS = 1000;

    public static final int MAX_READER_IMAGES = 5;

    // Compensate for the loss of ""sensitivity"" and ""sensitivityBoost""
    public static final int MAX_ISO_MISMATCH = 3;

    public static final String OFFLINE_CAMERA_ID = ""offline_camera_id"";
    public static final String REPORT_LOG_NAME = ""CtsCameraTestCases"";

    private static final int EXIF_DATETIME_LENGTH = 19;
    private static final int EXIF_DATETIME_ERROR_MARGIN_SEC = 60;
    private static final float EXIF_FOCAL_LENGTH_ERROR_MARGIN = 0.001f;
    private static final float EXIF_EXPOSURE_TIME_ERROR_MARGIN_RATIO = 0.05f;
    private static final float EXIF_EXPOSURE_TIME_MIN_ERROR_MARGIN_SEC = 0.002f;
    private static final float EXIF_APERTURE_ERROR_MARGIN = 0.001f;

    private static final float ZOOM_RATIO_THRESHOLD = 0.01f;

    private static final Location sTestLocation0 = new Location(LocationManager.GPS_PROVIDER);
    private static final Location sTestLocation1 = new Location(LocationManager.GPS_PROVIDER);
    private static final Location sTestLocation2 = new Location(LocationManager.NETWORK_PROVIDER);

    static {
        sTestLocation0.setTime(1199145600000L);
        sTestLocation0.setLatitude(37.736071);
        sTestLocation0.setLongitude(-122.441983);
        sTestLocation0.setAltitude(21.0);

        sTestLocation1.setTime(1199145601000L);
        sTestLocation1.setLatitude(0.736071);
        sTestLocation1.setLongitude(0.441983);
        sTestLocation1.setAltitude(1.0);

        sTestLocation2.setTime(1199145602000L);
        sTestLocation2.setLatitude(-89.736071);
        sTestLocation2.setLongitude(-179.441983);
        sTestLocation2.setAltitude(100000.0);
    }

    // Exif test data vectors.
    public static final ExifTestData[] EXIF_TEST_DATA = {
            new ExifTestData(
                    /*gpsLocation*/ sTestLocation0,
                    /* orientation */90,
                    /* jpgQuality */(byte) 80,
                    /* thumbQuality */(byte) 75),
            new ExifTestData(
                    /*gpsLocation*/ sTestLocation1,
                    /* orientation */180,
                    /* jpgQuality */(byte) 90,
                    /* thumbQuality */(byte) 85),
            new ExifTestData(
                    /*gpsLocation*/ sTestLocation2,
                    /* orientation */270,
                    /* jpgQuality */(byte) 100,
                    /* thumbQuality */(byte) 100)
    };

    /**
     * Create an {@link android.media.ImageReader} object and get the surface.
     *
     * @param size The size of this ImageReader to be created.
     * @param format The format of this ImageReader to be created
     * @param maxNumImages The max number of images that can be acquired simultaneously.
     * @param listener The listener used by this ImageReader to notify callbacks.
     * @param handler The handler to use for any listener callbacks.
     */
    public static ImageReader makeImageReader(Size size, int format, int maxNumImages,
            ImageReader.OnImageAvailableListener listener, Handler handler) {
        ImageReader reader;
        reader = ImageReader.newInstance(size.getWidth(), size.getHeight(), format,
                maxNumImages);
        reader.setOnImageAvailableListener(listener, handler);
        if (VERBOSE) Log.v(TAG, ""Created ImageReader size "" + size);
        return reader;
    }

    /**
     * Create an ImageWriter and hook up the ImageListener.
     *
     * @param inputSurface The input surface of the ImageWriter.
     * @param maxImages The max number of Images that can be dequeued simultaneously.
     * @param listener The listener used by this ImageWriter to notify callbacks
     * @param handler The handler to post listener callbacks.
     * @return ImageWriter object created.
     */
    public static ImageWriter makeImageWriter(
            Surface inputSurface, int maxImages,
            ImageWriter.OnImageReleasedListener listener, Handler handler) {
        ImageWriter writer = ImageWriter.newInstance(inputSurface, maxImages);
        writer.setOnImageReleasedListener(listener, handler);
        return writer;
    }

    /**
     * Utility class to store the targets for mandatory stream combination test.
     */
    public static class StreamCombinationTargets {
        public List<SurfaceTexture> mPrivTargets = new ArrayList<>();
        public List<ImageReader> mJpegTargets = new ArrayList<>();
        public List<ImageReader> mYuvTargets = new ArrayList<>();
        public List<ImageReader> mY8Targets = new ArrayList<>();
        public List<ImageReader> mRawTargets = new ArrayList<>();
        public List<ImageReader> mHeicTargets = new ArrayList<>();
        public List<ImageReader> mDepth16Targets = new ArrayList<>();

        public List<MultiResolutionImageReader> mPrivMultiResTargets = new ArrayList<>();
        public List<MultiResolutionImageReader> mJpegMultiResTargets = new ArrayList<>();
        public List<MultiResolutionImageReader> mYuvMultiResTargets = new ArrayList<>();
        public List<MultiResolutionImageReader> mRawMultiResTargets = new ArrayList<>();

        public void close() {
            for (SurfaceTexture target : mPrivTargets) {
                target.release();
            }
            for (ImageReader target : mJpegTargets) {
                target.close();
            }
            for (ImageReader target : mYuvTargets) {
                target.close();
            }
            for (ImageReader target : mY8Targets) {
                target.close();
            }
            for (ImageReader target : mRawTargets) {
                target.close();
            }
            for (ImageReader target : mHeicTargets) {
                target.close();
            }
            for (ImageReader target : mDepth16Targets) {
                target.close();
            }

            for (MultiResolutionImageReader target : mPrivMultiResTargets) {
                target.close();
            }
            for (MultiResolutionImageReader target : mJpegMultiResTargets) {
                target.close();
            }
            for (MultiResolutionImageReader target : mYuvMultiResTargets) {
                target.close();
            }
            for (MultiResolutionImageReader target : mRawMultiResTargets) {
                target.close();
            }
        }
    }

    private static void configureTarget(StreamCombinationTargets targets,
            List<OutputConfiguration> outputConfigs, List<Surface> outputSurfaces,
            int format, Size targetSize, int numBuffers, String overridePhysicalCameraId,
            MultiResolutionStreamConfigurationMap multiResStreamConfig,
            boolean createMultiResiStreamConfig, ImageDropperListener listener, Handler handler) {
        if (createMultiResiStreamConfig) {
            Collection<MultiResolutionStreamInfo> multiResolutionStreams =
                    multiResStreamConfig.getOutputInfo(format);
            MultiResolutionImageReader multiResReader = new MultiResolutionImageReader(
                    multiResolutionStreams, format, numBuffers);
            multiResReader.setOnImageAvailableListener(listener, new HandlerExecutor(handler));
            Collection<OutputConfiguration> configs =
                    OutputConfiguration.createInstancesForMultiResolutionOutput(multiResReader);
            outputConfigs.addAll(configs);
            outputSurfaces.add(multiResReader.getSurface());
            switch (format) {
                case ImageFormat.PRIVATE:
                    targets.mPrivMultiResTargets.add(multiResReader);
                    break;
                case ImageFormat.JPEG:
                    targets.mJpegMultiResTargets.add(multiResReader);
                    break;
                case ImageFormat.YUV_420_888:
                    targets.mYuvMultiResTargets.add(multiResReader);
                    break;
                case ImageFormat.RAW_SENSOR:
                    targets.mRawMultiResTargets.add(multiResReader);
                    break;
                default:
                    fail(""Unknown/Unsupported output format "" + format);
            }
        } else {
            if (format == ImageFormat.PRIVATE) {
                SurfaceTexture target = new SurfaceTexture(/*random int*/1);
                target.setDefaultBufferSize(targetSize.getWidth(), targetSize.getHeight());
                OutputConfiguration config = new OutputConfiguration(new Surface(target));
                if (overridePhysicalCameraId != null) {
                    config.setPhysicalCameraId(overridePhysicalCameraId);
                }
                outputConfigs.add(config);
                outputSurfaces.add(config.getSurface());
                targets.mPrivTargets.add(target);
            } else {
                ImageReader target = ImageReader.newInstance(targetSize.getWidth(),
                        targetSize.getHeight(), format, numBuffers);
                target.setOnImageAvailableListener(listener, handler);
                OutputConfiguration config = new OutputConfiguration(target.getSurface());
                if (overridePhysicalCameraId != null) {
                    config.setPhysicalCameraId(overridePhysicalCameraId);
                }
                outputConfigs.add(config);
                outputSurfaces.add(config.getSurface());

                switch (format) {
                    case ImageFormat.JPEG:
                      targets.mJpegTargets.add(target);
                      break;
                    case ImageFormat.YUV_420_888:
                      targets.mYuvTargets.add(target);
                      break;
                    case ImageFormat.Y8:
                      targets.mY8Targets.add(target);
                      break;
                    case ImageFormat.RAW_SENSOR:
                      targets.mRawTargets.add(target);
                      break;
                    case ImageFormat.HEIC:
                      targets.mHeicTargets.add(target);
                      break;
                    case ImageFormat.DEPTH16:
                      targets.mDepth16Targets.add(target);
                      break;
                    default:
                      fail(""Unknown/Unsupported output format "" + format);
                }
            }
        }
    }

    public static void setupConfigurationTargets(List<MandatoryStreamInformation> streamsInfo,
            StreamCombinationTargets targets,
            List<OutputConfiguration> outputConfigs,
            List<Surface> outputSurfaces, int numBuffers,
            boolean substituteY8, boolean substituteHeic, String overridenPhysicalCameraId,
            MultiResolutionStreamConfigurationMap multiResStreamConfig, Handler handler) {
            List<Surface> uhSurfaces = new ArrayList<Surface>();
        setupConfigurationTargets(streamsInfo, targets, outputConfigs, outputSurfaces, uhSurfaces,
            numBuffers, substituteY8, substituteHeic, overridenPhysicalCameraId,
            multiResStreamConfig, handler);
    }

    public static void setupConfigurationTargets(List<MandatoryStreamInformation> streamsInfo,
            StreamCombinationTargets targets,
            List<OutputConfiguration> outputConfigs,
            List<Surface> outputSurfaces, List<Surface> uhSurfaces, int numBuffers,
            boolean substituteY8, boolean substituteHeic, String overridePhysicalCameraId,
            MultiResolutionStreamConfigurationMap multiResStreamConfig, Handler handler) {

        ImageDropperListener imageDropperListener = new ImageDropperListener();
        List<Surface> chosenSurfaces;
        for (MandatoryStreamInformation streamInfo : streamsInfo) {
            if (streamInfo.isInput()) {
                continue;
            }
            chosenSurfaces = outputSurfaces;
            if (streamInfo.isUltraHighResolution()) {
                chosenSurfaces = uhSurfaces;
            }
            int format = streamInfo.getFormat();
            if (substituteY8 && (format == ImageFormat.YUV_420_888)) {
                format = ImageFormat.Y8;
            } else if (substituteHeic && (format == ImageFormat.JPEG)) {
                format = ImageFormat.HEIC;
            }
            Size[] availableSizes = new Size[streamInfo.getAvailableSizes().size()];
            availableSizes = streamInfo.getAvailableSizes().toArray(availableSizes);
            Size targetSize = CameraTestUtils.getMaxSize(availableSizes);
            boolean createMultiResReader =
                    (multiResStreamConfig != null &&
                     !multiResStreamConfig.getOutputInfo(format).isEmpty() &&
                     streamInfo.isMaximumSize());
            switch (format) {
                case ImageFormat.PRIVATE:
                case ImageFormat.JPEG:
                case ImageFormat.YUV_420_888:
                case ImageFormat.Y8:
                case ImageFormat.HEIC:
                case ImageFormat.DEPTH16:
                {
                    configureTarget(targets, outputConfigs, chosenSurfaces, format,
                            targetSize, numBuffers, overridePhysicalCameraId, multiResStreamConfig,
                            createMultiResReader, imageDropperListener, handler);
                    break;
                }
                case ImageFormat.RAW_SENSOR: {
                    // targetSize could be null in the logical camera case where only
                    // physical camera supports RAW stream.
                    if (targetSize != null) {
                        configureTarget(targets, outputConfigs, chosenSurfaces, format,
                                targetSize, numBuffers, overridePhysicalCameraId,
                                multiResStreamConfig, createMultiResReader, imageDropperListener,
                                handler);
                    }
                    break;
                }
                default:
                    fail(""Unknown output format "" + format);
            }
        }
    }

    /**
     * Close pending images and clean up an {@link android.media.ImageReader} object.
     * @param reader an {@link android.media.ImageReader} to close.
     */
    public static void closeImageReader(ImageReader reader) {
        if (reader != null) {
            reader.close();
        }
    }

    /**
     * Close the pending images then close current active {@link ImageReader} objects.
     */
    public static void closeImageReaders(ImageReader[] readers) {
        if ((readers != null) && (readers.length > 0)) {
            for (ImageReader reader : readers) {
                CameraTestUtils.closeImageReader(reader);
            }
        }
    }

    /**
     * Close pending images and clean up an {@link android.media.ImageWriter} object.
     * @param writer an {@link android.media.ImageWriter} to close.
     */
    public static void closeImageWriter(ImageWriter writer) {
        if (writer != null) {
            writer.close();
        }
    }

    /**
     * Dummy listener that release the image immediately once it is available.
     *
     * <p>
     * It can be used for the case where we don't care the image data at all.
     * </p>
     */
    public static class ImageDropperListener implements ImageReader.OnImageAvailableListener {
        @Override
        public synchronized void onImageAvailable(ImageReader reader) {
            Image image = null;
            try {
                image = reader.acquireNextImage();
            } finally {
                if (image != null) {
                    image.close();
                    mImagesDropped++;
                }
            }
        }

        public synchronized int getImageCount() {
            return mImagesDropped;
        }

        public synchronized void resetImageCount() {
            mImagesDropped = 0;
        }

        private int mImagesDropped = 0;
    }

    /**
     * Image listener that release the image immediately after validating the image
     */
    public static class ImageVerifierListener implements ImageReader.OnImageAvailableListener {
        private Size mSize;
        private int mFormat;
        // Whether the parent ImageReader is valid or not. If the parent ImageReader
        // is destroyed, the acquired Image may become invalid.
        private boolean mReaderIsValid;

        public ImageVerifierListener(Size sz, int format) {
            mSize = sz;
            mFormat = format;
            mReaderIsValid = true;
        }

        public synchronized void onReaderDestroyed() {
            mReaderIsValid = false;
        }

        @Override
        public synchronized void onImageAvailable(ImageReader reader) {
            Image image = null;
            try {
                image = reader.acquireNextImage();
            } finally {
                if (image != null) {
                    // Should only do some quick validity checks in callback, as the ImageReader
                    // could be closed asynchronously, which will close all images acquired from
                    // this ImageReader.
                    checkImage(image, mSize.getWidth(), mSize.getHeight(), mFormat);
                    // checkAndroidImageFormat calls into underlying Image object, which could
                    // become invalid if the ImageReader is destroyed.
                    if (mReaderIsValid) {
                        checkAndroidImageFormat(image);
                    }
                    image.close();
                }
            }
        }
    }

    public static class SimpleImageReaderListener
            implements ImageReader.OnImageAvailableListener {
        private final LinkedBlockingQueue<Image> mQueue =
                new LinkedBlockingQueue<Image>();
        // Indicate whether this listener will drop images or not,
        // when the queued images reaches the reader maxImages
        private final boolean mAsyncMode;
        // maxImages held by the queue in async mode.
        private final int mMaxImages;

        /**
         * Create a synchronous SimpleImageReaderListener that queues the images
         * automatically when they are available, no image will be dropped. If
         * the caller doesn't call getImage(), the producer will eventually run
         * into buffer starvation.
         */
        public SimpleImageReaderListener() {
            mAsyncMode = false;
            mMaxImages = 0;
        }

        /**
         * Create a synchronous/asynchronous SimpleImageReaderListener that
         * queues the images automatically when they are available. For
         * asynchronous listener, image will be dropped if the queued images
         * reach to maxImages queued. If the caller doesn't call getImage(), the
         * producer will not be blocked. For synchronous listener, no image will
         * be dropped. If the caller doesn't call getImage(), the producer will
         * eventually run into buffer starvation.
         *
         * @param asyncMode If the listener is operating at asynchronous mode.
         * @param maxImages The max number of images held by this listener.
         */
        /**
         *
         * @param asyncMode
         */
        public SimpleImageReaderListener(boolean asyncMode, int maxImages) {
            mAsyncMode = asyncMode;
            mMaxImages = maxImages;
        }

        @Override
        public void onImageAvailable(ImageReader reader) {
            try {
                Image imge = reader.acquireNextImage();
                if (imge == null) {
                    return;
                }
                mQueue.put(imge);
                if (mAsyncMode && mQueue.size() >= mMaxImages) {
                    Image img = mQueue.poll();
                    img.close();
                }
            } catch (InterruptedException e) {
                throw new UnsupportedOperationException(
                        ""Can't handle InterruptedException in onImageAvailable"");
            }
        }

        /**
         * Get an image from the image reader.
         *
         * @param timeout Timeout value for the wait.
         * @return The image from the image reader.
         */
        public Image getImage(long timeout) throws InterruptedException {
            Image image = mQueue.poll(timeout, TimeUnit.MILLISECONDS);
            assertNotNull(""Wait for an image timed out in "" + timeout + ""ms"", image);
            return image;
        }

        /**
         * Drain the pending images held by this listener currently.
         *
         */
        public void drain() {
            while (!mQueue.isEmpty()) {
                Image image = mQueue.poll();
                assertNotNull(""Unable to get an image"", image);
                image.close();
            }
        }
    }

    public static class SimpleImageWriterListener implements ImageWriter.OnImageReleasedListener {
        private final Semaphore mImageReleasedSema = new Semaphore(0);
        private final ImageWriter mWriter;
        @Override
        public void onImageReleased(ImageWriter writer) {
            if (writer != mWriter) {
                return;
            }

            if (VERBOSE) {
                Log.v(TAG, ""Input image is released"");
            }
            mImageReleasedSema.release();
        }

        public SimpleImageWriterListener(ImageWriter writer) {
            if (writer == null) {
                throw new IllegalArgumentException(""writer cannot be null"");
            }
            mWriter = writer;
        }

        public void waitForImageReleased(long timeoutMs) throws InterruptedException {
            if (!mImageReleasedSema.tryAcquire(timeoutMs, TimeUnit.MILLISECONDS)) {
                fail(""wait for image available timed out after "" + timeoutMs + ""ms"");
            }
        }
    }

    public static class ImageAndMultiResStreamInfo {
        public final Image image;
        public final MultiResolutionStreamInfo streamInfo;

        public ImageAndMultiResStreamInfo(Image image, MultiResolutionStreamInfo streamInfo) {
            this.image = image;
            this.streamInfo = streamInfo;
        }
    }

    public static class SimpleMultiResolutionImageReaderListener
            implements ImageReader.OnImageAvailableListener {
        public SimpleMultiResolutionImageReaderListener(MultiResolutionImageReader owner,
                int maxBuffers, boolean acquireLatest) {
            mOwner = owner;
            mMaxBuffers = maxBuffers;
            mAcquireLatest = acquireLatest;
        }

        @Override
        public void onImageAvailable(ImageReader reader) {
            if (VERBOSE) Log.v(TAG, ""new image available"");

            if (mAcquireLatest) {
                mLastReader = reader;
                mImageAvailable.open();
            } else {
                if (mQueue.size() < mMaxBuffers) {
                    Image image = reader.acquireNextImage();
                    MultiResolutionStreamInfo multiResStreamInfo =
                            mOwner.getStreamInfoForImageReader(reader);
                    mQueue.offer(new ImageAndMultiResStreamInfo(image, multiResStreamInfo));
                }
            }
        }

        public ImageAndMultiResStreamInfo getAnyImageAndInfoAvailable(long timeoutMs)
                throws Exception {
            if (mAcquireLatest) {
                Image image = null;
                if (mImageAvailable.block(timeoutMs)) {
                    if (mLastReader != null) {
                        image = mLastReader.acquireLatestImage();
                        if (VERBOSE) Log.v(TAG, ""acquireLatestImage"");
                    } else {
                        fail(""invalid image reader"");
                    }
                    mImageAvailable.close();
                } else {
                    fail(""wait for image available time out after "" + timeoutMs + ""ms"");
                }
                return new ImageAndMultiResStreamInfo(image,
                        mOwner.getStreamInfoForImageReader(mLastReader));
            } else {
                ImageAndMultiResStreamInfo imageAndInfo = mQueue.poll(timeoutMs,
                        java.util.concurrent.TimeUnit.MILLISECONDS);
                if (imageAndInfo == null) {
                    fail(""wait for image available timed out after "" + timeoutMs + ""ms"");
                }
                return imageAndInfo;
            }
        }

        public void reset() {
            while (!mQueue.isEmpty()) {
                ImageAndMultiResStreamInfo imageAndInfo = mQueue.poll();
                assertNotNull(""Acquired image is not valid"", imageAndInfo.image);
                imageAndInfo.image.close();
            }
            mImageAvailable.close();
            mLastReader = null;
        }

        private LinkedBlockingQueue<ImageAndMultiResStreamInfo> mQueue =
                new LinkedBlockingQueue<ImageAndMultiResStreamInfo>();
        private final MultiResolutionImageReader mOwner;
        private final int mMaxBuffers;
        private final boolean mAcquireLatest;
        private ConditionVariable mImageAvailable = new ConditionVariable();
        private ImageReader mLastReader = null;
    }

    public static class SimpleCaptureCallback extends CameraCaptureSession.CaptureCallback {
        private final LinkedBlockingQueue<TotalCaptureResult> mQueue =
                new LinkedBlockingQueue<TotalCaptureResult>();
        private final LinkedBlockingQueue<CaptureFailure> mFailureQueue =
                new LinkedBlockingQueue<>();
        // (Surface, framenumber) pair for lost buffers
        private final LinkedBlockingQueue<Pair<Surface, Long>> mBufferLostQueue =
                new LinkedBlockingQueue<>();
        private final LinkedBlockingQueue<Integer> mAbortQueue =
                new LinkedBlockingQueue<>();
        // Pair<CaptureRequest, Long> is a pair of capture request and timestamp.
        private final LinkedBlockingQueue<Pair<CaptureRequest, Long>> mCaptureStartQueue =
                new LinkedBlockingQueue<>();
        // Pair<Int, Long> is a pair of sequence id and frame number
        private final LinkedBlockingQueue<Pair<Integer, Long>> mCaptureSequenceCompletedQueue =
                new LinkedBlockingQueue<>();

        private AtomicLong mNumFramesArrived = new AtomicLong(0);

        @Override
        public void onCaptureStarted(CameraCaptureSession session, CaptureRequest request,
                long timestamp, long frameNumber) {
            try {
                mCaptureStartQueue.put(new Pair(request, timestamp));
            } catch (InterruptedException e) {
                throw new UnsupportedOperationException(
                        ""Can't handle InterruptedException in onCaptureStarted"");
            }
        }

        @Override
        public void onCaptureCompleted(CameraCaptureSession session, CaptureRequest request,
                TotalCaptureResult result) {
            try {
                mNumFramesArrived.incrementAndGet();
                mQueue.put(result);
            } catch (InterruptedException e) {
                throw new UnsupportedOperationException(
                        ""Can't handle InterruptedException in onCaptureCompleted"");
            }
        }

        @Override
        public void onCaptureFailed(CameraCaptureSession session, CaptureRequest request,
                CaptureFailure failure) {
            try {
                mFailureQueue.put(failure);
            } catch (InterruptedException e) {
                throw new UnsupportedOperationException(
                        ""Can't handle InterruptedException in onCaptureFailed"");
            }
        }

        @Override
        public void onCaptureSequenceAborted(CameraCaptureSession session, int sequenceId) {
            try {
                mAbortQueue.put(sequenceId);
            } catch (InterruptedException e) {
                throw new UnsupportedOperationException(
                        ""Can't handle InterruptedException in onCaptureAborted"");
            }
        }

        @Override
        public void onCaptureSequenceCompleted(CameraCaptureSession session, int sequenceId,
                long frameNumber) {
            try {
                mCaptureSequenceCompletedQueue.put(new Pair(sequenceId, frameNumber));
            } catch (InterruptedException e) {
                throw new UnsupportedOperationException(
                        ""Can't handle InterruptedException in onCaptureSequenceCompleted"");
            }
        }

        @Override
        public void onCaptureBufferLost(CameraCaptureSession session,
                CaptureRequest request, Surface target, long frameNumber) {
            try {
                mBufferLostQueue.put(new Pair<>(target, frameNumber));
            } catch (InterruptedException e) {
                throw new UnsupportedOperationException(
                        ""Can't handle InterruptedException in onCaptureBufferLost"");
            }
        }

        public long getTotalNumFrames() {
            return mNumFramesArrived.get();
        }

        public CaptureResult getCaptureResult(long timeout) {
            return getTotalCaptureResult(timeout);
        }

        public TotalCaptureResult getCaptureResult(long timeout, long timestamp) {
            try {
                long currentTs = -1L;
                TotalCaptureResult result;
                while (true) {
                    result = mQueue.poll(timeout, TimeUnit.MILLISECONDS);
                    if (result == null) {
                        throw new RuntimeException(
                                ""Wait for a capture result timed out in "" + timeout + ""ms"");
                    }
                    currentTs = result.get(CaptureResult.SENSOR_TIMESTAMP);
                    if (currentTs == timestamp) {
                        return result;
                    }
                }

            } catch (InterruptedException e) {
                throw new UnsupportedOperationException(""Unhandled interrupted exception"", e);
            }
        }

        public TotalCaptureResult getTotalCaptureResult(long timeout) {
            try {
                TotalCaptureResult result = mQueue.poll(timeout, TimeUnit.MILLISECONDS);
                assertNotNull(""Wait for a capture result timed out in "" + timeout + ""ms"", result);
                return result;
            } catch (InterruptedException e) {
                throw new UnsupportedOperationException(""Unhandled interrupted exception"", e);
            }
        }

        /**
         * Get the {@link #CaptureResult capture result} for a given
         * {@link #CaptureRequest capture request}.
         *
         * @param myRequest The {@link #CaptureRequest capture request} whose
         *            corresponding {@link #CaptureResult capture result} was
         *            being waited for
         * @param numResultsWait Number of frames to wait for the capture result
         *            before timeout.
         * @throws TimeoutRuntimeException If more than numResultsWait results are
         *            seen before the result matching myRequest arrives, or each
         *            individual wait for result times out after
         *            {@value #CAPTURE_RESULT_TIMEOUT_MS}ms.
         */
        public CaptureResult getCaptureResultForRequest(CaptureRequest myRequest,
                int numResultsWait) {
            return getTotalCaptureResultForRequest(myRequest, numResultsWait);
        }

        /**
         * Get the {@link #TotalCaptureResult total capture result} for a given
         * {@link #CaptureRequest capture request}.
         *
         * @param myRequest The {@link #CaptureRequest capture request} whose
         *            corresponding {@link #TotalCaptureResult capture result} was
         *            being waited for
         * @param numResultsWait Number of frames to wait for the capture result
         *            before timeout.
         * @throws TimeoutRuntimeException If more than numResultsWait results are
         *            seen before the result matching myRequest arrives, or each
         *            individual wait for result times out after
         *            {@value #CAPTURE_RESULT_TIMEOUT_MS}ms.
         */
        public TotalCaptureResult getTotalCaptureResultForRequest(CaptureRequest myRequest,
                int numResultsWait) {
            ArrayList<CaptureRequest> captureRequests = new ArrayList<>(1);
            captureRequests.add(myRequest);
            return getTotalCaptureResultsForRequests(captureRequests, numResultsWait)[0];
        }

        /**
         * Get an array of {@link #TotalCaptureResult total capture results} for a given list of
         * {@link #CaptureRequest capture requests}. This can be used when the order of results
         * may not the same as the order of requests.
         *
         * @param captureRequests The list of {@link #CaptureRequest capture requests} whose
         *            corresponding {@link #TotalCaptureResult capture results} are
         *            being waited for.
         * @param numResultsWait Number of frames to wait for the capture results
         *            before timeout.
         * @throws TimeoutRuntimeException If more than numResultsWait results are
         *            seen before all the results matching captureRequests arrives.
         */
        public TotalCaptureResult[] getTotalCaptureResultsForRequests(
                List<CaptureRequest> captureRequests, int numResultsWait) {
            if (numResultsWait < 0) {
                throw new IllegalArgumentException(""numResultsWait must be no less than 0"");
            }
            if (captureRequests == null || captureRequests.size() == 0) {
                throw new IllegalArgumentException(""captureRequests must have at least 1 request."");
            }

            // Create a request -> a list of result indices map that it will wait for.
            HashMap<CaptureRequest, ArrayList<Integer>> remainingResultIndicesMap = new HashMap<>();
            for (int i = 0; i < captureRequests.size(); i++) {
                CaptureRequest request = captureRequests.get(i);
                ArrayList<Integer> indices = remainingResultIndicesMap.get(request);
                if (indices == null) {
                    indices = new ArrayList<>();
                    remainingResultIndicesMap.put(request, indices);
                }
                indices.add(i);
            }

            TotalCaptureResult[] results = new TotalCaptureResult[captureRequests.size()];
            int i = 0;
            do {
                TotalCaptureResult result = getTotalCaptureResult(CAPTURE_RESULT_TIMEOUT_MS);
                CaptureRequest request = result.getRequest();
                ArrayList<Integer> indices = remainingResultIndicesMap.get(request);
                if (indices != null) {
                    results[indices.get(0)] = result;
                    indices.remove(0);

                    // Remove the entry if all results for this request has been fulfilled.
                    if (indices.isEmpty()) {
                        remainingResultIndicesMap.remove(request);
                    }
                }

                if (remainingResultIndicesMap.isEmpty()) {
                    return results;
                }
            } while (i++ < numResultsWait);

            throw new TimeoutRuntimeException(""Unable to get the expected capture result after ""
                    + ""waiting for "" + numResultsWait + "" results"");
        }

        /**
         * Get an array list of {@link #CaptureFailure capture failure} with maxNumFailures entries
         * at most. If it times out before maxNumFailures failures are received, return the failures
         * received so far.
         *
         * @param maxNumFailures The maximal number of failures to return. If it times out before
         *                       the maximal number of failures are received, return the received
         *                       failures so far.
         * @throws UnsupportedOperationException If an error happens while waiting on the failure.
         */
        public ArrayList<CaptureFailure> getCaptureFailures(long maxNumFailures) {
            ArrayList<CaptureFailure> failures = new ArrayList<>();
            try {
                for (int i = 0; i < maxNumFailures; i++) {
                    CaptureFailure failure = mFailureQueue.poll(CAPTURE_RESULT_TIMEOUT_MS,
                            TimeUnit.MILLISECONDS);
                    if (failure == null) {
                        // If waiting on a failure times out, return the failures so far.
                        break;
                    }
                    failures.add(failure);
                }
            }  catch (InterruptedException e) {
                throw new UnsupportedOperationException(""Unhandled interrupted exception"", e);
            }

            return failures;
        }

        /**
         * Get an array list of lost buffers with maxNumLost entries at most.
         * If it times out before maxNumLost buffer lost callbacks are received, return the
         * lost callbacks received so far.
         *
         * @param maxNumLost The maximal number of buffer lost failures to return. If it times out
         *                   before the maximal number of failures are received, return the received
         *                   buffer lost failures so far.
         * @throws UnsupportedOperationException If an error happens while waiting on the failure.
         */
        public ArrayList<Pair<Surface, Long>> getLostBuffers(long maxNumLost) {
            ArrayList<Pair<Surface, Long>> failures = new ArrayList<>();
            try {
                for (int i = 0; i < maxNumLost; i++) {
                    Pair<Surface, Long> failure = mBufferLostQueue.poll(CAPTURE_RESULT_TIMEOUT_MS,
                            TimeUnit.MILLISECONDS);
                    if (failure == null) {
                        // If waiting on a failure times out, return the failures so far.
                        break;
                    }
                    failures.add(failure);
                }
            }  catch (InterruptedException e) {
                throw new UnsupportedOperationException(""Unhandled interrupted exception"", e);
            }

            return failures;
        }

        /**
         * Get an array list of aborted capture sequence ids with maxNumAborts entries
         * at most. If it times out before maxNumAborts are received, return the aborted sequences
         * received so far.
         *
         * @param maxNumAborts The maximal number of aborted sequences to return. If it times out
         *                     before the maximal number of aborts are received, return the received
         *                     failed sequences so far.
         * @throws UnsupportedOperationException If an error happens while waiting on the failed
         *                                       sequences.
         */
        public ArrayList<Integer> geAbortedSequences(long maxNumAborts) {
            ArrayList<Integer> abortList = new ArrayList<>();
            try {
                for (int i = 0; i < maxNumAborts; i++) {
                    Integer abortSequence = mAbortQueue.poll(CAPTURE_RESULT_TIMEOUT_MS,
                            TimeUnit.MILLISECONDS);
                    if (abortSequence == null) {
                        break;
                    }
                    abortList.add(abortSequence);
                }
            }  catch (InterruptedException e) {
                throw new UnsupportedOperationException(""Unhandled interrupted exception"", e);
            }

            return abortList;
        }

        /**
         * Wait until the capture start of a request and expected timestamp arrives or it times
         * out after a number of capture starts.
         *
         * @param request The request for the capture start to wait for.
         * @param timestamp The timestamp for the capture start to wait for.
         * @param numCaptureStartsWait The number of capture start events to wait for before timing
         *                             out.
         */
        public void waitForCaptureStart(CaptureRequest request, Long timestamp,
                int numCaptureStartsWait) throws Exception {
            Pair<CaptureRequest, Long> expectedShutter = new Pair<>(request, timestamp);

            int i = 0;
            do {
                Pair<CaptureRequest, Long> shutter = mCaptureStartQueue.poll(
                        CAPTURE_RESULT_TIMEOUT_MS, TimeUnit.MILLISECONDS);

                if (shutter == null) {
                    throw new TimeoutRuntimeException(""Unable to get any more capture start "" +
                            ""event after waiting for "" + CAPTURE_RESULT_TIMEOUT_MS + "" ms."");
                } else if (expectedShutter.equals(shutter)) {
                    return;
                }

            } while (i++ < numCaptureStartsWait);

            throw new TimeoutRuntimeException(""Unable to get the expected capture start "" +
                    ""event after waiting for "" + numCaptureStartsWait + "" capture starts"");
        }

        /**
         * Wait until it receives capture sequence completed callback for a given squence ID.
         *
         * @param sequenceId The sequence ID of the capture sequence completed callback to wait for.
         * @param timeoutMs Time to wait for each capture sequence complete callback before
         *                  timing out.
         */
        public long getCaptureSequenceLastFrameNumber(int sequenceId, long timeoutMs) {
            try {
                while (true) {
                    Pair<Integer, Long> completedSequence =
                            mCaptureSequenceCompletedQueue.poll(timeoutMs, TimeUnit.MILLISECONDS);
                    assertNotNull(""Wait for a capture sequence completed timed out in "" +
                            timeoutMs + ""ms"", completedSequence);

                    if (completedSequence.first.equals(sequenceId)) {
                        return completedSequence.second.longValue();
                    }
                }
            } catch (InterruptedException e) {
                throw new UnsupportedOperationException(""Unhandled interrupted exception"", e);
            }
        }

        public boolean hasMoreResults()
        {
            return !mQueue.isEmpty();
        }

        public boolean hasMoreFailures()
        {
            return !mFailureQueue.isEmpty();
        }

        public int getNumLostBuffers()
        {
            return mBufferLostQueue.size();
        }

        public boolean hasMoreAbortedSequences()
        {
            return !mAbortQueue.isEmpty();
        }

        public void drain() {
            mQueue.clear();
            mNumFramesArrived.getAndSet(0);
            mFailureQueue.clear();
            mBufferLostQueue.clear();
            mCaptureStartQueue.clear();
            mAbortQueue.clear();
        }
    }

    public static boolean hasCapability(CameraCharacteristics characteristics, int capability) {
        int [] capabilities =
                characteristics.get(CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES);
        for (int c : capabilities) {
            if (c == capability) {
                return true;
            }
        }
        return false;
    }

    public static boolean isSystemCamera(CameraManager manager, String cameraId)
            throws CameraAccessException {
        CameraCharacteristics characteristics = manager.getCameraCharacteristics(cameraId);
        return hasCapability(characteristics,
                CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_SYSTEM_CAMERA);
    }

    public static String[] getCameraIdListForTesting(CameraManager manager,
            boolean getSystemCameras)
            throws CameraAccessException {
        String [] ids = manager.getCameraIdListNoLazy();
        List<String> idsForTesting = new ArrayList<String>();
        for (String id : ids) {
            boolean isSystemCamera = isSystemCamera(manager, id);
            if (getSystemCameras == isSystemCamera) {
                idsForTesting.add(id);
            }
        }
        return idsForTesting.toArray(new String[idsForTesting.size()]);
    }

    public static Set<Set<String>> getConcurrentCameraIds(CameraManager manager,
            boolean getSystemCameras)
            throws CameraAccessException {
        Set<String> cameraIds = new HashSet<String>(Arrays.asList(getCameraIdListForTesting(manager, getSystemCameras)));
        Set<Set<String>> combinations =  manager.getConcurrentCameraIds();
        Set<Set<String>> correctComb = new HashSet<Set<String>>();
        for (Set<String> comb : combinations) {
            Set<String> filteredIds = new HashSet<String>();
            for (String id : comb) {
                if (cameraIds.contains(id)) {
                    filteredIds.add(id);
                }
            }
            if (filteredIds.isEmpty()) {
                continue;
            }
            correctComb.add(filteredIds);
        }
        return correctComb;
    }

    /**
     * Block until the camera is opened.
     *
     * <p>Don't use this to test #onDisconnected/#onError since this will throw
     * an AssertionError if it fails to open the camera device.</p>
     *
     * @return CameraDevice opened camera device
     *
     * @throws IllegalArgumentException
     *            If the handler is null, or if the handler's looper is current.
     * @throws CameraAccessException
     *            If open fails immediately.
     * @throws BlockingOpenException
     *            If open fails after blocking for some amount of time.
     * @throws TimeoutRuntimeException
     *            If opening times out. Typically unrecoverable.
     */
    public static CameraDevice openCamera(CameraManager manager, String cameraId,
            CameraDevice.StateCallback listener, Handler handler) throws CameraAccessException,
            BlockingOpenException {

        /**
         * Although camera2 API allows 'null' Handler (it will just use the current
         * thread's Looper), this is not what we want for CTS.
         *
         * In CTS the default looper is used only to process events in between test runs,
         * so anything sent there would not be executed inside a test and the test would fail.
         *
         * In this case, BlockingCameraManager#openCamera performs the check for us.
         */
        return (new BlockingCameraManager(manager)).openCamera(cameraId, listener, handler);
    }


    /**
     * Block until the camera is opened.
     *
     * <p>Don't use this to test #onDisconnected/#onError since this will throw
     * an AssertionError if it fails to open the camera device.</p>
     *
     * @throws IllegalArgumentException
     *            If the handler is null, or if the handler's looper is current.
     * @throws CameraAccessException
     *            If open fails immediately.
     * @throws BlockingOpenException
     *            If open fails after blocking for some amount of time.
     * @throws TimeoutRuntimeException
     *            If opening times out. Typically unrecoverable.
     */
    public static CameraDevice openCamera(CameraManager manager, String cameraId, Handler handler)
            throws CameraAccessException,
            BlockingOpenException {
        return openCamera(manager, cameraId, /*listener*/null, handler);
    }

    /**
     * Configure a new camera session with output surfaces and type.
     *
     * @param camera The CameraDevice to be configured.
     * @param outputSurfaces The surface list that used for camera output.
     * @param listener The callback CameraDevice will notify when capture results are available.
     */
    public static CameraCaptureSession configureCameraSession(CameraDevice camera,
            List<Surface> outputSurfaces, boolean isHighSpeed,
            CameraCaptureSession.StateCallback listener, Handler handler)
            throws CameraAccessException {
        BlockingSessionCallback sessionListener = new BlockingSessionCallback(listener);
        if (isHighSpeed) {
            camera.createConstrainedHighSpeedCaptureSession(outputSurfaces,
                    sessionListener, handler);
        } else {
            camera.createCaptureSession(outputSurfaces, sessionListener, handler);
        }
        CameraCaptureSession session =
                sessionListener.waitAndGetSession(SESSION_CONFIGURE_TIMEOUT_MS);
        assertFalse(""Camera session should not be a reprocessable session"",
                session.isReprocessable());
        String sessionType = isHighSpeed ? ""High Speed"" : ""Normal"";
        assertTrue(""Capture session type must be "" + sessionType,
                isHighSpeed ==
                CameraConstrainedHighSpeedCaptureSession.class.isAssignableFrom(session.getClass()));

        return session;
    }

    /**
     * Build a new constrained camera session with output surfaces, type and recording session
     * parameters.
     *
     * @param camera The CameraDevice to be configured.
     * @param outputSurfaces The surface list that used for camera output.
     * @param listener The callback CameraDevice will notify when capture results are available.
     * @param initialRequest Initial request settings to use as session parameters.
     */
    public static CameraCaptureSession buildConstrainedCameraSession(CameraDevice camera,
            List<Surface> outputSurfaces, CameraCaptureSession.StateCallback listener,
            Handler handler, CaptureRequest initialRequest) throws CameraAccessException {
        BlockingSessionCallback sessionListener = new BlockingSessionCallback(listener);

        List<OutputConfiguration> outConfigurations = new ArrayList<>(outputSurfaces.size());
        for (Surface surface : outputSurfaces) {
            outConfigurations.add(new OutputConfiguration(surface));
        }
        SessionConfiguration sessionConfig = new SessionConfiguration(
                SessionConfiguration.SESSION_HIGH_SPEED, outConfigurations,
                new HandlerExecutor(handler), sessionListener);
        sessionConfig.setSessionParameters(initialRequest);
        camera.createCaptureSession(sessionConfig);

        CameraCaptureSession session =
                sessionListener.waitAndGetSession(SESSION_CONFIGURE_TIMEOUT_MS);
        assertFalse(""Camera session should not be a reprocessable session"",
                session.isReprocessable());
        assertTrue(""Capture session type must be High Speed"",
                CameraConstrainedHighSpeedCaptureSession.class.isAssignableFrom(
                        session.getClass()));

        return session;
    }

    /**
     * Configure a new camera session with output configurations.
     *
     * @param camera The CameraDevice to be configured.
     * @param outputs The OutputConfiguration list that is used for camera output.
     * @param listener The callback CameraDevice will notify when capture results are available.
     */
    public static CameraCaptureSession configureCameraSessionWithConfig(CameraDevice camera,
            List<OutputConfiguration> outputs,
            CameraCaptureSession.StateCallback listener, Handler handler)
            throws CameraAccessException {
        BlockingSessionCallback sessionListener = new BlockingSessionCallback(listener);
        camera.createCaptureSessionByOutputConfigurations(outputs, sessionListener, handler);
        CameraCaptureSession session =
                sessionListener.waitAndGetSession(SESSION_CONFIGURE_TIMEOUT_MS);
        assertFalse(""Camera session should not be a reprocessable session"",
                session.isReprocessable());
        return session;
    }

    /**
     * Try configure a new camera session with output configurations.
     *
     * @param camera The CameraDevice to be configured.
     * @param outputs The OutputConfiguration list that is used for camera output.
     * @param initialRequest The session parameters passed in during stream configuration
     * @param listener The callback CameraDevice will notify when capture results are available.
     */
    public static CameraCaptureSession tryConfigureCameraSessionWithConfig(CameraDevice camera,
            List<OutputConfiguration> outputs, CaptureRequest initialRequest,
            CameraCaptureSession.StateCallback listener, Handler handler)
            throws CameraAccessException {
        BlockingSessionCallback sessionListener = new BlockingSessionCallback(listener);
        SessionConfiguration sessionConfig = new SessionConfiguration(
                SessionConfiguration.SESSION_REGULAR, outputs, new HandlerExecutor(handler),
                sessionListener);
        sessionConfig.setSessionParameters(initialRequest);
        camera.createCaptureSession(sessionConfig);

        Integer[] sessionStates = {BlockingSessionCallback.SESSION_READY,
                                   BlockingSessionCallback.SESSION_CONFIGURE_FAILED};
        int state = sessionListener.getStateWaiter().waitForAnyOfStates(
                Arrays.asList(sessionStates), SESSION_CONFIGURE_TIMEOUT_MS);

        CameraCaptureSession session = null;
        if (state == BlockingSessionCallback.SESSION_READY) {
            session = sessionListener.waitAndGetSession(SESSION_CONFIGURE_TIMEOUT_MS);
            assertFalse(""Camera session should not be a reprocessable session"",
                    session.isReprocessable());
        }
        return session;
    }

    /**
     * Configure a new camera session with output surfaces and initial session parameters.
     *
     * @param camera The CameraDevice to be configured.
     * @param outputSurfaces The surface list that used for camera output.
     * @param listener The callback CameraDevice will notify when session is available.
     * @param handler The handler used to notify callbacks.
     * @param initialRequest Initial request settings to use as session parameters.
     */
    public static CameraCaptureSession configureCameraSessionWithParameters(CameraDevice camera,
            List<Surface> outputSurfaces, BlockingSessionCallback listener,
            Handler handler, CaptureRequest initialRequest) throws CameraAccessException {
        List<OutputConfiguration> outConfigurations = new ArrayList<>(outputSurfaces.size());
        for (Surface surface : outputSurfaces) {
            outConfigurations.add(new OutputConfiguration(surface));
        }
        SessionConfiguration sessionConfig = new SessionConfiguration(
                SessionConfiguration.SESSION_REGULAR, outConfigurations,
                new HandlerExecutor(handler), listener);
        sessionConfig.setSessionParameters(initialRequest);
        camera.createCaptureSession(sessionConfig);

        CameraCaptureSession session = listener.waitAndGetSession(SESSION_CONFIGURE_TIMEOUT_MS);
        assertFalse(""Camera session should not be a reprocessable session"",
                session.isReprocessable());
        assertFalse(""Capture session type must be regular"",
                CameraConstrainedHighSpeedCaptureSession.class.isAssignableFrom(
                        session.getClass()));

        return session;
    }

    /**
     * Configure a new camera session with output surfaces.
     *
     * @param camera The CameraDevice to be configured.
     * @param outputSurfaces The surface list that used for camera output.
     * @param listener The callback CameraDevice will notify when capture results are available.
     */
    public static CameraCaptureSession configureCameraSession(CameraDevice camera,
            List<Surface> outputSurfaces,
            CameraCaptureSession.StateCallback listener, Handler handler)
            throws CameraAccessException {

        return configureCameraSession(camera, outputSurfaces, /*isHighSpeed*/false,
                listener, handler);
    }

    public static CameraCaptureSession configureReprocessableCameraSession(CameraDevice camera,
            InputConfiguration inputConfiguration, List<Surface> outputSurfaces,
            CameraCaptureSession.StateCallback listener, Handler handler)
            throws CameraAccessException {
        List<OutputConfiguration> outputConfigs = new ArrayList<OutputConfiguration>();
        for (Surface surface : outputSurfaces) {
            outputConfigs.add(new OutputConfiguration(surface));
        }
        CameraCaptureSession session = configureReprocessableCameraSessionWithConfigurations(
                camera, inputConfiguration, outputConfigs, listener, handler);

        return session;
    }

    public static CameraCaptureSession configureReprocessableCameraSessionWithConfigurations(
            CameraDevice camera, InputConfiguration inputConfiguration,
            List<OutputConfiguration> outputConfigs, CameraCaptureSession.StateCallback listener,
            Handler handler) throws CameraAccessException {
        BlockingSessionCallback sessionListener = new BlockingSessionCallback(listener);
        SessionConfiguration sessionConfig = new SessionConfiguration(
                SessionConfiguration.SESSION_REGULAR, outputConfigs, new HandlerExecutor(handler),
                sessionListener);
        sessionConfig.setInputConfiguration(inputConfiguration);
        camera.createCaptureSession(sessionConfig);

        Integer[] sessionStates = {BlockingSessionCallback.SESSION_READY,
                                   BlockingSessionCallback.SESSION_CONFIGURE_FAILED};
        int state = sessionListener.getStateWaiter().waitForAnyOfStates(
                Arrays.asList(sessionStates), SESSION_CONFIGURE_TIMEOUT_MS);

        assertTrue(""Creating a reprocessable session failed."",
                state == BlockingSessionCallback.SESSION_READY);
        CameraCaptureSession session =
                sessionListener.waitAndGetSession(SESSION_CONFIGURE_TIMEOUT_MS);
        assertTrue(""Camera session should be a reprocessable session"", session.isReprocessable());

        return session;
    }

    /**
     * Create a reprocessable camera session with input and output configurations.
     *
     * @param camera The CameraDevice to be configured.
     * @param inputConfiguration The input configuration used to create this session.
     * @param outputs The output configurations used to create this session.
     * @param listener The callback CameraDevice will notify when capture results are available.
     * @param handler The handler used to notify callbacks.
     * @return The session ready to use.
     * @throws CameraAccessException
     */
    public static CameraCaptureSession configureReprocCameraSessionWithConfig(CameraDevice camera,
            InputConfiguration inputConfiguration, List<OutputConfiguration> outputs,
            CameraCaptureSession.StateCallback listener, Handler handler)
            throws CameraAccessException {
        BlockingSessionCallback sessionListener = new BlockingSessionCallback(listener);
        camera.createReprocessableCaptureSessionByConfigurations(inputConfiguration, outputs,
                sessionListener, handler);

        Integer[] sessionStates = {BlockingSessionCallback.SESSION_READY,
                                   BlockingSessionCallback.SESSION_CONFIGURE_FAILED};
        int state = sessionListener.getStateWaiter().waitForAnyOfStates(
                Arrays.asList(sessionStates), SESSION_CONFIGURE_TIMEOUT_MS);

        assertTrue(""Creating a reprocessable session failed."",
                state == BlockingSessionCallback.SESSION_READY);

        CameraCaptureSession session =
                sessionListener.waitAndGetSession(SESSION_CONFIGURE_TIMEOUT_MS);
        assertTrue(""Camera session should be a reprocessable session"", session.isReprocessable());

        return session;
    }

    public static <T> void assertArrayNotEmpty(T arr, String message) {
        assertTrue(message, arr != null && Array.getLength(arr) > 0);
    }

    /**
     * Check if the format is a legal YUV format camera supported.
     */
    public static void checkYuvFormat(int format) {
        if ((format != ImageFormat.YUV_420_888) &&
                (format != ImageFormat.NV21) &&
                (format != ImageFormat.YV12)) {
            fail(""Wrong formats: "" + format);
        }
    }

    /**
     * Check if image size and format match given size and format.
     */
    public static void checkImage(Image image, int width, int height, int format) {
        // Image reader will wrap YV12/NV21 image by YUV_420_888
        if (format == ImageFormat.NV21 || format == ImageFormat.YV12) {
            format = ImageFormat.YUV_420_888;
        }
        assertNotNull(""Input image is invalid"", image);
        assertEquals(""Format doesn't match"", format, image.getFormat());
        assertEquals(""Width doesn't match"", width, image.getWidth());
        assertEquals(""Height doesn't match"", height, image.getHeight());
    }

    /**
     * <p>Read data from all planes of an Image into a contiguous unpadded, unpacked
     * 1-D linear byte array, such that it can be write into disk, or accessed by
     * software conveniently. It supports YUV_420_888/NV21/YV12 and JPEG input
     * Image format.</p>
     *
     * <p>For YUV_420_888/NV21/YV12/Y8/Y16, it returns a byte array that contains
     * the Y plane data first, followed by U(Cb), V(Cr) planes if there is any
     * (xstride = width, ystride = height for chroma and luma components).</p>
     *
     * <p>For JPEG, it returns a 1-D byte array contains a complete JPEG image.</p>
     *
     * <p>For YUV P010, it returns a byte array that contains Y plane first, followed
     * by the interleaved U(Cb)/V(Cr) plane.</p>
     */
    public static byte[] getDataFromImage(Image image) {
        assertNotNull(""Invalid image:"", image);
        int format = image.getFormat();
        int width = image.getWidth();
        int height = image.getHeight();
        int rowStride, pixelStride;
        byte[] data = null;

        // Read image data
        Plane[] planes = image.getPlanes();
        assertTrue(""Fail to get image planes"", planes != null && planes.length > 0);

        // Check image validity
        checkAndroidImageFormat(image);

        ByteBuffer buffer = null;
        // JPEG doesn't have pixelstride and rowstride, treat it as 1D buffer.
        // Same goes for DEPTH_POINT_CLOUD, RAW_PRIVATE, DEPTH_JPEG, and HEIC
        if (format == ImageFormat.JPEG || format == ImageFormat.DEPTH_POINT_CLOUD ||
                format == ImageFormat.RAW_PRIVATE || format == ImageFormat.DEPTH_JPEG ||
                format == ImageFormat.HEIC) {
            buffer = planes[0].getBuffer();
            assertNotNull(""Fail to get jpeg/depth/heic ByteBuffer"", buffer);
            data = new byte[buffer.remaining()];
            buffer.get(data);
            buffer.rewind();
            return data;
        } else if (format == ImageFormat.YCBCR_P010) {
            // P010 samples are stored within 16 bit values
            int offset = 0;
            int bytesPerPixelRounded = (ImageFormat.getBitsPerPixel(format) + 7) / 8;
            data = new byte[width * height * bytesPerPixelRounded];
            assertTrue(""Unexpected number of planes, expected "" + 3 + "" actual "" + planes.length,
                    planes.length == 3);
            for (int i = 0; i < 2; i++) {
                buffer = planes[i].getBuffer();
                assertNotNull(""Fail to get bytebuffer from plane"", buffer);
                buffer.rewind();
                rowStride = planes[i].getRowStride();
                if (VERBOSE) {
                    Log.v(TAG, ""rowStride "" + rowStride);
                    Log.v(TAG, ""width "" + width);
                    Log.v(TAG, ""height "" + height);
                }
                int h = (i == 0) ? height : height / 2;
                for (int row = 0; row < h; row++) {
                    int length = rowStride;
                    buffer.get(data, offset, length);
                    offset += length;
                }
                if (VERBOSE) Log.v(TAG, ""Finished reading data from plane "" + i);
                buffer.rewind();
            }
            return data;
        }

        int offset = 0;
        data = new byte[width * height * ImageFormat.getBitsPerPixel(format) / 8];
        int maxRowSize = planes[0].getRowStride();
        for (int i = 0; i < planes.length; i++) {
            if (maxRowSize < planes[i].getRowStride()) {
                maxRowSize = planes[i].getRowStride();
            }
        }
        byte[] rowData = new byte[maxRowSize];
        if(VERBOSE) Log.v(TAG, ""get data from "" + planes.length + "" planes"");
        for (int i = 0; i < planes.length; i++) {
            buffer = planes[i].getBuffer();
            assertNotNull(""Fail to get bytebuffer from plane"", buffer);
            buffer.rewind();
            rowStride = planes[i].getRowStride();
            pixelStride = planes[i].getPixelStride();
            assertTrue(""pixel stride "" + pixelStride + "" is invalid"", pixelStride > 0);
            if (VERBOSE) {
                Log.v(TAG, ""pixelStride "" + pixelStride);
                Log.v(TAG, ""rowStride "" + rowStride);
                Log.v(TAG, ""width "" + width);
                Log.v(TAG, ""height "" + height);
            }
            // For multi-planar yuv images, assuming yuv420 with 2x2 chroma subsampling.
            int w = (i == 0) ? width : width / 2;
            int h = (i == 0) ? height : height / 2;
            assertTrue(""rowStride "" + rowStride + "" should be >= width "" + w , rowStride >= w);
            for (int row = 0; row < h; row++) {
                int bytesPerPixel = ImageFormat.getBitsPerPixel(format) / 8;
                int length;
                if (pixelStride == bytesPerPixel) {
                    // Special case: optimized read of the entire row
                    length = w * bytesPerPixel;
                    buffer.get(data, offset, length);
                    offset += length;
                } else {
                    // Generic case: should work for any pixelStride but slower.
                    // Use intermediate buffer to avoid read byte-by-byte from
                    // DirectByteBuffer, which is very bad for performance
                    length = (w - 1) * pixelStride + bytesPerPixel;
                    buffer.get(rowData, 0, length);
                    for (int col = 0; col < w; col++) {
                        data[offset++] = rowData[col * pixelStride];
                    }
                }
                // Advance buffer the remainder of the row stride
                if (row < h - 1) {
                    buffer.position(buffer.position() + rowStride - length);
                }
            }
            if (VERBOSE) Log.v(TAG, ""Finished reading data from plane "" + i);
            buffer.rewind();
        }
        return data;
    }

    /**
     * <p>Check android image format validity for an image, only support below formats:</p>
     *
     * <p>YUV_420_888/NV21/YV12, can add more for future</p>
     */
    public static void checkAndroidImageFormat(Image image) {
        int format = image.getFormat();
        Plane[] planes = image.getPlanes();
        switch (format) {
            case ImageFormat.YUV_420_888:
            case ImageFormat.NV21:
            case ImageFormat.YV12:
            case ImageFormat.YCBCR_P010:
                assertEquals(""YUV420 format Images should have 3 planes"", 3, planes.length);
                break;
            case ImageFormat.JPEG:
            case ImageFormat.RAW_SENSOR:
            case ImageFormat.RAW_PRIVATE:
            case ImageFormat.DEPTH16:
            case ImageFormat.DEPTH_POINT_CLOUD:
            case ImageFormat.DEPTH_JPEG:
            case ImageFormat.Y8:
            case ImageFormat.HEIC:
                assertEquals(""JPEG/RAW/depth/Y8 Images should have one plane"", 1, planes.length);
                break;
            default:
                fail(""Unsupported Image Format: "" + format);
        }
    }

    public static void dumpFile(String fileName, Bitmap data) {
        FileOutputStream outStream;
        try {
            Log.v(TAG, ""output will be saved as "" + fileName);
            outStream = new FileOutputStream(fileName);
        } catch (IOException ioe) {
            throw new RuntimeException(""Unable to create debug output file "" + fileName, ioe);
        }

        try {
            data.compress(Bitmap.CompressFormat.JPEG, /*quality*/90, outStream);
            outStream.close();
        } catch (IOException ioe) {
            throw new RuntimeException(""failed writing data to file "" + fileName, ioe);
        }
    }

    public static void dumpFile(String fileName, byte[] data) {
        FileOutputStream outStream;
        try {
            Log.v(TAG, ""output will be saved as "" + fileName);
            outStream = new FileOutputStream(fileName);
        } catch (IOException ioe) {
            throw new RuntimeException(""Unable to create debug output file "" + fileName, ioe);
        }

        try {
            outStream.write(data);
            outStream.close();
        } catch (IOException ioe) {
            throw new RuntimeException(""failed writing data to file "" + fileName, ioe);
        }
    }

    /**
     * Get the available output sizes for the user-defined {@code format}.
     *
     * <p>Note that implementation-defined/hidden formats are not supported.</p>
     */
    public static Size[] getSupportedSizeForFormat(int format, String cameraId,
            CameraManager cameraManager) throws CameraAccessException {
        CameraCharacteristics properties = cameraManager.getCameraCharacteristics(cameraId);
        assertNotNull(""Can't get camera characteristics!"", properties);
        if (VERBOSE) {
            Log.v(TAG, ""get camera characteristics for camera: "" + cameraId);
        }
        StreamConfigurationMap configMap =
                properties.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
        Size[] availableSizes = configMap.getOutputSizes(format);
        assertArrayNotEmpty(availableSizes, ""availableSizes should not be empty for format: ""
                + format);
        Size[] highResAvailableSizes = configMap.getHighResolutionOutputSizes(format);
        if (highResAvailableSizes != null && highResAvailableSizes.length > 0) {
            Size[] allSizes = new Size[availableSizes.length + highResAvailableSizes.length];
            System.arraycopy(availableSizes, 0, allSizes, 0,
                    availableSizes.length);
            System.arraycopy(highResAvailableSizes, 0, allSizes, availableSizes.length,
                    highResAvailableSizes.length);
            availableSizes = allSizes;
        }
        if (VERBOSE) Log.v(TAG, ""Supported sizes are: "" + Arrays.deepToString(availableSizes));
        return availableSizes;
    }

    /**
     * Get the available output sizes for the given class.
     *
     */
    public static Size[] getSupportedSizeForClass(Class klass, String cameraId,
            CameraManager cameraManager) throws CameraAccessException {
        CameraCharacteristics properties = cameraManager.getCameraCharacteristics(cameraId);
        assertNotNull(""Can't get camera characteristics!"", properties);
        if (VERBOSE) {
            Log.v(TAG, ""get camera characteristics for camera: "" + cameraId);
        }
        StreamConfigurationMap configMap =
                properties.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
        Size[] availableSizes = configMap.getOutputSizes(klass);
        assertArrayNotEmpty(availableSizes, ""availableSizes should not be empty for class: ""
                + klass);
        Size[] highResAvailableSizes = configMap.getHighResolutionOutputSizes(ImageFormat.PRIVATE);
        if (highResAvailableSizes != null && highResAvailableSizes.length > 0) {
            Size[] allSizes = new Size[availableSizes.length + highResAvailableSizes.length];
            System.arraycopy(availableSizes, 0, allSizes, 0,
                    availableSizes.length);
            System.arraycopy(highResAvailableSizes, 0, allSizes, availableSizes.length,
                    highResAvailableSizes.length);
            availableSizes = allSizes;
        }
        if (VERBOSE) Log.v(TAG, ""Supported sizes are: "" + Arrays.deepToString(availableSizes));
        return availableSizes;
    }

    /**
     * Size comparator that compares the number of pixels it covers.
     *
     * <p>If two the areas of two sizes are same, compare the widths.</p>
     */
    public static class SizeComparator implements Comparator<Size> {
        @Override
        public int compare(Size lhs, Size rhs) {
            return CameraUtils
                    .compareSizes(lhs.getWidth(), lhs.getHeight(), rhs.getWidth(), rhs.getHeight());
        }
    }

    /**
     * Get sorted size list in descending order. Remove the sizes larger than
     * the bound. If the bound is null, don't do the size bound filtering.
     */
    static public List<Size> getSupportedPreviewSizes(String cameraId,
            CameraManager cameraManager, Size bound) throws CameraAccessException {

        Size[] rawSizes = getSupportedSizeForClass(android.view.SurfaceHolder.class, cameraId,
                cameraManager);
        assertArrayNotEmpty(rawSizes,
                ""Available sizes for SurfaceHolder class should not be empty"");
        if (VERBOSE) {
            Log.v(TAG, ""Supported sizes are: "" + Arrays.deepToString(rawSizes));
        }

        if (bound == null) {
            return getAscendingOrderSizes(Arrays.asList(rawSizes), /*ascending*/false);
        }

        List<Size> sizes = new ArrayList<Size>();
        for (Size sz: rawSizes) {
            if (sz.getWidth() <= bound.getWidth() && sz.getHeight() <= bound.getHeight()) {
                sizes.add(sz);
            }
        }
        return getAscendingOrderSizes(sizes, /*ascending*/false);
    }

    /**
     * Get a sorted list of sizes from a given size list.
     *
     * <p>
     * The size is compare by area it covers, if the areas are same, then
     * compare the widths.
     * </p>
     *
     * @param sizeList The input size list to be sorted
     * @param ascending True if the order is ascending, otherwise descending order
     * @return The ordered list of sizes
     */
    static public List<Size> getAscendingOrderSizes(final List<Size> sizeList, boolean ascending) {
        if (sizeList == null) {
            throw new IllegalArgumentException(""sizeList shouldn't be null"");
        }

        Comparator<Size> comparator = new SizeComparator();
        List<Size> sortedSizes = new ArrayList<Size>();
        sortedSizes.addAll(sizeList);
        Collections.sort(sortedSizes, comparator);
        if (!ascending) {
            Collections.reverse(sortedSizes);
        }

        return sortedSizes;
    }

    /**
     * Get sorted (descending order) size list for given format. Remove the sizes larger than
     * the bound. If the bound is null, don't do the size bound filtering.
     */
    static public List<Size> getSortedSizesForFormat(String cameraId,
            CameraManager cameraManager, int format, Size bound) throws CameraAccessException {
        Comparator<Size> comparator = new SizeComparator();
        Size[] sizes = getSupportedSizeForFormat(format, cameraId, cameraManager);
        List<Size> sortedSizes = null;
        if (bound != null) {
            sortedSizes = new ArrayList<Size>(/*capacity*/1);
            for (Size sz : sizes) {
                if (comparator.compare(sz, bound) <= 0) {
                    sortedSizes.add(sz);
                }
            }
        } else {
            sortedSizes = Arrays.asList(sizes);
        }
        assertTrue(""Supported size list should have at least one element"",
                sortedSizes.size() > 0);

        Collections.sort(sortedSizes, comparator);
        // Make it in descending order.
        Collections.reverse(sortedSizes);
        return sortedSizes;
    }

    /**
     * Get supported video size list for a given camera device.
     *
     * <p>
     * Filter out the sizes that are larger than the bound. If the bound is
     * null, don't do the size bound filtering.
     * </p>
     */
    static public List<Size> getSupportedVideoSizes(String cameraId,
            CameraManager cameraManager, Size bound) throws CameraAccessException {

        Size[] rawSizes = getSupportedSizeForClass(android.media.MediaRecorder.class,
                cameraId, cameraManager);
        assertArrayNotEmpty(rawSizes,
                ""Available sizes for MediaRecorder class should not be empty"");
        if (VERBOSE) {
            Log.v(TAG, ""Supported sizes are: "" + Arrays.deepToString(rawSizes));
        }

        if (bound == null) {
            return getAscendingOrderSizes(Arrays.asList(rawSizes), /*ascending*/false);
        }

        List<Size> sizes = new ArrayList<Size>();
        for (Size sz: rawSizes) {
            if (sz.getWidth() <= bound.getWidth() && sz.getHeight() <= bound.getHeight()) {
                sizes.add(sz);
            }
        }
        return getAscendingOrderSizes(sizes, /*ascending*/false);
    }

    /**
     * Get supported video size list (descending order) for a given camera device.
     *
     * <p>
     * Filter out the sizes that are larger than the bound. If the bound is
     * null, don't do the size bound filtering.
     * </p>
     */
    static public List<Size> getSupportedStillSizes(String cameraId,
            CameraManager cameraManager, Size bound) throws CameraAccessException {
        return getSortedSizesForFormat(cameraId, cameraManager, ImageFormat.JPEG, bound);
    }

    static public List<Size> getSupportedHeicSizes(String cameraId,
            CameraManager cameraManager, Size bound) throws CameraAccessException {
        return getSortedSizesForFormat(cameraId, cameraManager, ImageFormat.HEIC, bound);
    }

    static public Size getMinPreviewSize(String cameraId, CameraManager cameraManager)
            throws CameraAccessException {
        List<Size> sizes = getSupportedPreviewSizes(cameraId, cameraManager, null);
        return sizes.get(sizes.size() - 1);
    }

    /**
     * Get max supported preview size for a camera device.
     */
    static public Size getMaxPreviewSize(String cameraId, CameraManager cameraManager)
            throws CameraAccessException {
        return getMaxPreviewSize(cameraId, cameraManager, /*bound*/null);
    }

    /**
     * Get max preview size for a camera device in the supported sizes that are no larger
     * than the bound.
     */
    static public Size getMaxPreviewSize(String cameraId, CameraManager cameraManager, Size bound)
            throws CameraAccessException {
        List<Size> sizes = getSupportedPreviewSizes(cameraId, cameraManager, bound);
        return sizes.get(0);
    }

    /**
     * Get max depth size for a camera device.
     */
    static public Size getMaxDepthSize(String cameraId, CameraManager cameraManager)
            throws CameraAccessException {
        List<Size> sizes = getSortedSizesForFormat(cameraId, cameraManager, ImageFormat.DEPTH16,
                /*bound*/ null);
        return sizes.get(0);
    }

    /**
     * Get the largest size by area.
     *
     * @param sizes an array of sizes, must have at least 1 element
     *
     * @return Largest Size
     *
     * @throws IllegalArgumentException if sizes was null or had 0 elements
     */
    public static Size getMaxSize(Size... sizes) {
        if (sizes == null || sizes.length == 0) {
            throw new IllegalArgumentException(""sizes was empty"");
        }

        Size sz = sizes[0];
        for (Size size : sizes) {
            if (size.getWidth() * size.getHeight() > sz.getWidth() * sz.getHeight()) {
                sz = size;
            }
        }

        return sz;
    }

    /**
     * Get the largest size by area within (less than) bound
     *
     * @param sizes an array of sizes, must have at least 1 element
     *
     * @return Largest Size. Null if no such size exists within bound.
     *
     * @throws IllegalArgumentException if sizes was null or had 0 elements, or bound is invalid.
     */
    public static Size getMaxSizeWithBound(Size[] sizes, int bound) {
        if (sizes == null || sizes.length == 0) {
            throw new IllegalArgumentException(""sizes was empty"");
        }
        if (bound <= 0) {
            throw new IllegalArgumentException(""bound is invalid"");
        }

        Size sz = null;
        for (Size size : sizes) {
            if (size.getWidth() * size.getHeight() >= bound) {
                continue;
            }

            if (sz == null ||
                    size.getWidth() * size.getHeight() > sz.getWidth() * sz.getHeight()) {
                sz = size;
            }
        }

        return sz;
    }

    /**
     * Returns true if the given {@code array} contains the given element.
     *
     * @param array {@code array} to check for {@code elem}
     * @param elem {@code elem} to test for
     * @return {@code true} if the given element is contained
     */
    public static boolean contains(int[] array, int elem) {
        if (array == null) return false;
        for (int i = 0; i < array.length; i++) {
            if (elem == array[i]) return true;
        }
        return false;
    }

    /**
     * Get object array from byte array.
     *
     * @param array Input byte array to be converted
     * @return Byte object array converted from input byte array
     */
    public static Byte[] toObject(byte[] array) {
        return convertPrimitiveArrayToObjectArray(array, Byte.class);
    }

    /**
     * Get object array from int array.
     *
     * @param array Input int array to be converted
     * @return Integer object array converted from input int array
     */
    public static Integer[] toObject(int[] array) {
        return convertPrimitiveArrayToObjectArray(array, Integer.class);
    }

    /**
     * Get object array from float array.
     *
     * @param array Input float array to be converted
     * @return Float object array converted from input float array
     */
    public static Float[] toObject(float[] array) {
        return convertPrimitiveArrayToObjectArray(array, Float.class);
    }

    /**
     * Get object array from double array.
     *
     * @param array Input double array to be converted
     * @return Double object array converted from input double array
     */
    public static Double[] toObject(double[] array) {
        return convertPrimitiveArrayToObjectArray(array, Double.class);
    }

    /**
     * Convert a primitive input array into its object array version (e.g. from int[] to Integer[]).
     *
     * @param array Input array object
     * @param wrapperClass The boxed class it converts to
     * @return Boxed version of primitive array
     */
    private static <T> T[] convertPrimitiveArrayToObjectArray(final Object array,
            final Class<T> wrapperClass) {
        // getLength does the null check and isArray check already.
        int arrayLength = Array.getLength(array);
        if (arrayLength == 0) {
            throw new IllegalArgumentException(""Input array shouldn't be empty"");
        }

        @SuppressWarnings(""unchecked"")
        final T[] result = (T[]) Array.newInstance(wrapperClass, arrayLength);
        for (int i = 0; i < arrayLength; i++) {
            Array.set(result, i, Array.get(array, i));
        }
        return result;
    }

    /**
     * Validate image based on format and size.
     *
     * @param image The image to be validated.
     * @param width The image width.
     * @param height The image height.
     * @param format The image format.
     * @param filePath The debug dump file path, null if don't want to dump to
     *            file.
     * @throws UnsupportedOperationException if calling with an unknown format
     */
    public static void validateImage(Image image, int width, int height, int format,
            String filePath) {
        checkImage(image, width, height, format);

        /**
         * TODO: validate timestamp:
         * 1. capture result timestamp against the image timestamp (need
         * consider frame drops)
         * 2. timestamps should be monotonically increasing for different requests
         */
        if(VERBOSE) Log.v(TAG, ""validating Image"");
        byte[] data = getDataFromImage(image);
        assertTrue(""Invalid image data"", data != null && data.length > 0);

        switch (format) {
            // Clients must be able to process and handle depth jpeg images like any other
            // regular jpeg.
            case ImageFormat.DEPTH_JPEG:
            case ImageFormat.JPEG:
                validateJpegData(data, width, height, filePath);
                break;
            case ImageFormat.YCBCR_P010:
                validateP010Data(data, width, height, format, image.getTimestamp(), filePath);
                break;
            case ImageFormat.YUV_420_888:
            case ImageFormat.YV12:
                validateYuvData(data, width, height, format, image.getTimestamp(), filePath);
                break;
            case ImageFormat.RAW_SENSOR:
                validateRaw16Data(data, width, height, format, image.getTimestamp(), filePath);
                break;
            case ImageFormat.DEPTH16:
                validateDepth16Data(data, width, height, format, image.getTimestamp(), filePath);
                break;
            case ImageFormat.DEPTH_POINT_CLOUD:
                validateDepthPointCloudData(data, width, height, format, image.getTimestamp(), filePath);
                break;
            case ImageFormat.RAW_PRIVATE:
                validateRawPrivateData(data, width, height, image.getTimestamp(), filePath);
                break;
            case ImageFormat.Y8:
                validateY8Data(data, width, height, format, image.getTimestamp(), filePath);
                break;
            case ImageFormat.HEIC:
                validateHeicData(data, width, height, filePath);
                break;
            default:
                throw new UnsupportedOperationException(""Unsupported format for validation: ""
                        + format);
        }
    }

    public static class HandlerExecutor implements Executor {
        private final Handler mHandler;

        public HandlerExecutor(Handler handler) {
            assertNotNull(""handler must be valid"", handler);
            mHandler = handler;
        }

        @Override
        public void execute(Runnable runCmd) {
            mHandler.post(runCmd);
        }
    }

    /**
     * Provide a mock for {@link CameraDevice.StateCallback}.
     *
     * <p>Only useful because mockito can't mock {@link CameraDevice.StateCallback} which is an
     * abstract class.</p>
     *
     * <p>
     * Use this instead of other classes when needing to verify interactions, since
     * trying to spy on {@link BlockingStateCallback} (or others) will cause unnecessary extra
     * interactions which will cause false test failures.
     * </p>
     *
     */
    public static class MockStateCallback extends CameraDevice.StateCallback {

        @Override
        public void onOpened(CameraDevice camera) {
        }

        @Override
        public void onDisconnected(CameraDevice camera) {
        }

        @Override
        public void onError(CameraDevice camera, int error) {
        }

        private MockStateCallback() {}

        /**
         * Create a Mockito-ready mocked StateCallback.
         */
        public static MockStateCallback mock() {
            return Mockito.spy(new MockStateCallback());
        }
    }

    public static void validateJpegData(byte[] jpegData, int width, int height, String filePath) {
        BitmapFactory.Options bmpOptions = new BitmapFactory.Options();
        // DecodeBound mode: only parse the frame header to get width/height.
        // it doesn't decode the pixel.
        bmpOptions.inJustDecodeBounds = true;
        BitmapFactory.decodeByteArray(jpegData, 0, jpegData.length, bmpOptions);
        assertEquals(width, bmpOptions.outWidth);
        assertEquals(height, bmpOptions.outHeight);

        // Pixel decoding mode: decode whole image. check if the image data
        // is decodable here.
        assertNotNull(""Decoding jpeg failed"",
                BitmapFactory.decodeByteArray(jpegData, 0, jpegData.length));
        if (DEBUG && filePath != null) {
            String fileName =
                    filePath + ""/"" + width + ""x"" + height + "".jpeg"";
            dumpFile(fileName, jpegData);
        }
    }

    private static void validateYuvData(byte[] yuvData, int width, int height, int format,
            long ts, String filePath) {
        checkYuvFormat(format);
        if (VERBOSE) Log.v(TAG, ""Validating YUV data"");
        int expectedSize = width * height * ImageFormat.getBitsPerPixel(format) / 8;
        assertEquals(""Yuv data doesn't match"", expectedSize, yuvData.length);

        // TODO: Can add data validation for test pattern.

        if (DEBUG && filePath != null) {
            String fileName =
                    filePath + ""/"" + width + ""x"" + height + ""_"" + ts / 1e6 + "".yuv"";
            dumpFile(fileName, yuvData);
        }
    }

    private static void validateP010Data(byte[] p010Data, int width, int height, int format,
            long ts, String filePath) {
        if (VERBOSE) Log.v(TAG, ""Validating P010 data"");
        // The P010 10 bit samples are stored in two bytes so the size needs to be adjusted
        // accordingly.
        int bytesPerPixelRounded = (ImageFormat.getBitsPerPixel(format) + 7) / 8;
        int expectedSize = width * height * bytesPerPixelRounded;
        assertEquals(""P010 data doesn't match"", expectedSize, p010Data.length);

        if (DEBUG && filePath != null) {
            String fileName =
                    filePath + ""/"" + width + ""x"" + height + ""_"" + ts / 1e6 + "".p010"";
            dumpFile(fileName, p010Data);
        }
    }
    private static void validateRaw16Data(byte[] rawData, int width, int height, int format,
            long ts, String filePath) {
        if (VERBOSE) Log.v(TAG, ""Validating raw data"");
        int expectedSize = width * height * ImageFormat.getBitsPerPixel(format) / 8;
        assertEquals(""Raw data doesn't match"", expectedSize, rawData.length);

        // TODO: Can add data validation for test pattern.

        if (DEBUG && filePath != null) {
            String fileName =
                    filePath + ""/"" + width + ""x"" + height + ""_"" + ts / 1e6 + "".raw16"";
            dumpFile(fileName, rawData);
        }

        return;
    }

    private static void validateY8Data(byte[] rawData, int width, int height, int format,
            long ts, String filePath) {
        if (VERBOSE) Log.v(TAG, ""Validating Y8 data"");
        int expectedSize = width * height * ImageFormat.getBitsPerPixel(format) / 8;
        assertEquals(""Y8 data doesn't match"", expectedSize, rawData.length);

        // TODO: Can add data validation for test pattern.

        if (DEBUG && filePath != null) {
            String fileName =
                    filePath + ""/"" + width + ""x"" + height + ""_"" + ts / 1e6 + "".y8"";
            dumpFile(fileName, rawData);
        }

        return;
    }

    private static void validateRawPrivateData(byte[] rawData, int width, int height,
            long ts, String filePath) {
        if (VERBOSE) Log.v(TAG, ""Validating private raw data"");
        // Expect each RAW pixel should occupy at least one byte and no more than 30 bytes
        int expectedSizeMin = width * height;
        int expectedSizeMax = width * height * 30;

        assertTrue(""Opaque RAW size "" + rawData.length + ""out of normal bound ["" +
                expectedSizeMin + "","" + expectedSizeMax + ""]"",
                expectedSizeMin <= rawData.length && rawData.length <= expectedSizeMax);

        if (DEBUG && filePath != null) {
            String fileName =
                    filePath + ""/"" + width + ""x"" + height + ""_"" + ts / 1e6 + "".rawPriv"";
            dumpFile(fileName, rawData);
        }

        return;
    }

    private static void validateDepth16Data(byte[] depthData, int width, int height, int format,
            long ts, String filePath) {

        if (VERBOSE) Log.v(TAG, ""Validating depth16 data"");
        int expectedSize = width * height * ImageFormat.getBitsPerPixel(format) / 8;
        assertEquals(""Depth data doesn't match"", expectedSize, depthData.length);


        if (DEBUG && filePath != null) {
            String fileName =
                    filePath + ""/"" + width + ""x"" + height + ""_"" + ts / 1e6 + "".depth16"";
            dumpFile(fileName, depthData);
        }

        return;

    }

    private static void validateDepthPointCloudData(byte[] depthData, int width, int height, int format,
            long ts, String filePath) {

        if (VERBOSE) Log.v(TAG, ""Validating depth point cloud data"");

        // Can't validate size since it is variable

        if (DEBUG && filePath != null) {
            String fileName =
                    filePath + ""/"" + width + ""x"" + height + ""_"" + ts / 1e6 + "".depth_point_cloud"";
            dumpFile(fileName, depthData);
        }

        return;

    }

    private static void validateHeicData(byte[] heicData, int width, int height, String filePath) {
        BitmapFactory.Options bmpOptions = new BitmapFactory.Options();
        // DecodeBound mode: only parse the frame header to get width/height.
        // it doesn't decode the pixel.
        bmpOptions.inJustDecodeBounds = true;
        BitmapFactory.decodeByteArray(heicData, 0, heicData.length, bmpOptions);
        assertEquals(width, bmpOptions.outWidth);
        assertEquals(height, bmpOptions.outHeight);

        // Pixel decoding mode: decode whole image. check if the image data
        // is decodable here.
        assertNotNull(""Decoding heic failed"",
                BitmapFactory.decodeByteArray(heicData, 0, heicData.length));
        if (DEBUG && filePath != null) {
            String fileName =
                    filePath + ""/"" + width + ""x"" + height + "".heic"";
            dumpFile(fileName, heicData);
        }
    }

    public static <T> T getValueNotNull(CaptureResult result, CaptureResult.Key<T> key) {
        if (result == null) {
            throw new IllegalArgumentException(""Result must not be null"");
        }

        T value = result.get(key);
        assertNotNull(""Value of Key "" + key.getName() + ""shouldn't be null"", value);
        return value;
    }

    public static <T> T getValueNotNull(CameraCharacteristics characteristics,
            CameraCharacteristics.Key<T> key) {
        if (characteristics == null) {
            throw new IllegalArgumentException(""Camera characteristics must not be null"");
        }

        T value = characteristics.get(key);
        assertNotNull(""Value of Key "" + key.getName() + ""shouldn't be null"", value);
        return value;
    }

    /**
     * Get a crop region for a given zoom factor and center position.
     * <p>
     * The center position is normalized position in range of [0, 1.0], where
     * (0, 0) represents top left corner, (1.0. 1.0) represents bottom right
     * corner. The center position could limit the effective minimal zoom
     * factor, for example, if the center position is (0.75, 0.75), the
     * effective minimal zoom position becomes 2.0. If the requested zoom factor
     * is smaller than 2.0, a crop region with 2.0 zoom factor will be returned.
     * </p>
     * <p>
     * The aspect ratio of the crop region is maintained the same as the aspect
     * ratio of active array.
     * </p>
     *
     * @param zoomFactor The zoom factor to generate the crop region, it must be
     *            >= 1.0
     * @param center The normalized zoom center point that is in the range of [0, 1].
     * @param maxZoom The max zoom factor supported by this device.
     * @param activeArray The active array size of this device.
     * @return crop region for the given normalized center and zoom factor.
     */
    public static Rect getCropRegionForZoom(float zoomFactor, final PointF center,
            final float maxZoom, final Rect activeArray) {
        if (zoomFactor < 1.0) {
            throw new IllegalArgumentException(""zoom factor "" + zoomFactor + "" should be >= 1.0"");
        }
        if (center.x > 1.0 || center.x < 0) {
            throw new IllegalArgumentException(""center.x "" + center.x
                    + "" should be in range of [0, 1.0]"");
        }
        if (center.y > 1.0 || center.y < 0) {
            throw new IllegalArgumentException(""center.y "" + center.y
                    + "" should be in range of [0, 1.0]"");
        }
        if (maxZoom < 1.0) {
            throw new IllegalArgumentException(""max zoom factor "" + maxZoom + "" should be >= 1.0"");
        }
        if (activeArray == null) {
            throw new IllegalArgumentException(""activeArray must not be null"");
        }

        float minCenterLength = Math.min(Math.min(center.x, 1.0f - center.x),
                Math.min(center.y, 1.0f - center.y));
        float minEffectiveZoom =  0.5f / minCenterLength;
        if (minEffectiveZoom > maxZoom) {
            throw new IllegalArgumentException(""Requested center "" + center.toString() +
                    "" has minimal zoomable factor "" + minEffectiveZoom + "", which exceeds max""
                            + "" zoom factor "" + maxZoom);
        }

        if (zoomFactor < minEffectiveZoom) {
            Log.w(TAG, ""Requested zoomFactor "" + zoomFactor + "" < minimal zoomable factor ""
                    + minEffectiveZoom + "". It will be overwritten by "" + minEffectiveZoom);
            zoomFactor = minEffectiveZoom;
        }

        int cropCenterX = (int)(activeArray.width() * center.x);
        int cropCenterY = (int)(activeArray.height() * center.y);
        int cropWidth = (int) (activeArray.width() / zoomFactor);
        int cropHeight = (int) (activeArray.height() / zoomFactor);

        return new Rect(
                /*left*/cropCenterX - cropWidth / 2,
                /*top*/cropCenterY - cropHeight / 2,
                /*right*/ cropCenterX + cropWidth / 2,
                /*bottom*/cropCenterY + cropHeight / 2);
    }

    /**
     * Get AeAvailableTargetFpsRanges and sort them in descending order by max fps
     *
     * @param staticInfo camera static metadata
     * @return AeAvailableTargetFpsRanges in descending order by max fps
     */
    public static Range<Integer>[] getDescendingTargetFpsRanges(StaticMetadata staticInfo) {
        Range<Integer>[] fpsRanges = staticInfo.getAeAvailableTargetFpsRangesChecked();
        Arrays.sort(fpsRanges, new Comparator<Range<Integer>>() {
            public int compare(Range<Integer> r1, Range<Integer> r2) {
                return r2.getUpper() - r1.getUpper();
            }
        });
        return fpsRanges;
    }

    /**
     * Get AeAvailableTargetFpsRanges with max fps not exceeding 30
     *
     * @param staticInfo camera static metadata
     * @return AeAvailableTargetFpsRanges with max fps not exceeding 30
     */
    public static List<Range<Integer>> getTargetFpsRangesUpTo30(StaticMetadata staticInfo) {
        Range<Integer>[] fpsRanges = staticInfo.getAeAvailableTargetFpsRangesChecked();
        ArrayList<Range<Integer>> fpsRangesUpTo30 = new ArrayList<Range<Integer>>();
        for (Range<Integer> fpsRange : fpsRanges) {
            if (fpsRange.getUpper() <= 30) {
                fpsRangesUpTo30.add(fpsRange);
            }
        }
        return fpsRangesUpTo30;
    }

    /**
     * Get AeAvailableTargetFpsRanges with max fps greater than 30
     *
     * @param staticInfo camera static metadata
     * @return AeAvailableTargetFpsRanges with max fps greater than 30
     */
    public static List<Range<Integer>> getTargetFpsRangesGreaterThan30(StaticMetadata staticInfo) {
        Range<Integer>[] fpsRanges = staticInfo.getAeAvailableTargetFpsRangesChecked();
        ArrayList<Range<Integer>> fpsRangesGreaterThan30 = new ArrayList<Range<Integer>>();
        for (Range<Integer> fpsRange : fpsRanges) {
            if (fpsRange.getUpper() > 30) {
                fpsRangesGreaterThan30.add(fpsRange);
            }
        }
        return fpsRangesGreaterThan30;
    }

    /**
     * Calculate output 3A region from the intersection of input 3A region and cropped region.
     *
     * @param requestRegions The input 3A regions
     * @param cropRect The cropped region
     * @return expected 3A regions output in capture result
     */
    public static MeteringRectangle[] getExpectedOutputRegion(
            MeteringRectangle[] requestRegions, Rect cropRect){
        MeteringRectangle[] resultRegions = new MeteringRectangle[requestRegions.length];
        for (int i = 0; i < requestRegions.length; i++) {
            Rect requestRect = requestRegions[i].getRect();
            Rect resultRect = new Rect();
            boolean intersect = resultRect.setIntersect(requestRect, cropRect);
            resultRegions[i] = new MeteringRectangle(
                    resultRect,
                    intersect ? requestRegions[i].getMeteringWeight() : 0);
        }
        return resultRegions;
    }

    /**
     * Copy source image data to destination image.
     *
     * @param src The source image to be copied from.
     * @param dst The destination image to be copied to.
     * @throws IllegalArgumentException If the source and destination images have
     *             different format, size, or one of the images is not copyable.
     */
    public static void imageCopy(Image src, Image dst) {
        if (src == null || dst == null) {
            throw new IllegalArgumentException(""Images should be non-null"");
        }
        if (src.getFormat() != dst.getFormat()) {
            throw new IllegalArgumentException(""Src and dst images should have the same format"");
        }
        if (src.getFormat() == ImageFormat.PRIVATE ||
                dst.getFormat() == ImageFormat.PRIVATE) {
            throw new IllegalArgumentException(""PRIVATE format images are not copyable"");
        }

        Size srcSize = new Size(src.getWidth(), src.getHeight());
        Size dstSize = new Size(dst.getWidth(), dst.getHeight());
        if (!srcSize.equals(dstSize)) {
            throw new IllegalArgumentException(""source image size "" + srcSize + "" is different""
                    + "" with "" + ""destination image size "" + dstSize);
        }

        // TODO: check the owner of the dst image, it must be from ImageWriter, other source may
        // not be writable. Maybe we should add an isWritable() method in image class.

        Plane[] srcPlanes = src.getPlanes();
        Plane[] dstPlanes = dst.getPlanes();
        ByteBuffer srcBuffer = null;
        ByteBuffer dstBuffer = null;
        for (int i = 0; i < srcPlanes.length; i++) {
            srcBuffer = srcPlanes[i].getBuffer();
            dstBuffer = dstPlanes[i].getBuffer();
            int srcPos = srcBuffer.position();
            srcBuffer.rewind();
            dstBuffer.rewind();
            int srcRowStride = srcPlanes[i].getRowStride();
            int dstRowStride = dstPlanes[i].getRowStride();
            int srcPixStride = srcPlanes[i].getPixelStride();
            int dstPixStride = dstPlanes[i].getPixelStride();

            if (srcPixStride > 2 || dstPixStride > 2) {
                throw new IllegalArgumentException(""source pixel stride "" + srcPixStride +
                        "" with destination pixel stride "" + dstPixStride +
                        "" is not supported"");
            }

            if (srcRowStride == dstRowStride && srcPixStride == dstPixStride &&
                    srcPixStride == 1) {
                // Fast path, just copy the content in the byteBuffer all together.
                dstBuffer.put(srcBuffer);
            } else {
                Size effectivePlaneSize = getEffectivePlaneSizeForImage(src, i);
                int srcRowByteCount = srcRowStride;
                int dstRowByteCount = dstRowStride;
                byte[] srcDataRow = new byte[Math.max(srcRowStride, dstRowStride)];

                if (srcPixStride == dstPixStride && srcPixStride == 1) {
                    // Row by row copy case
                    for (int row = 0; row < effectivePlaneSize.getHeight(); row++) {
                        if (row == effectivePlaneSize.getHeight() - 1) {
                            // Special case for interleaved planes: need handle the last row
                            // carefully to avoid memory corruption. Check if we have enough bytes
                            // to copy.
                            srcRowByteCount = Math.min(srcRowByteCount, srcBuffer.remaining());
                            dstRowByteCount = Math.min(dstRowByteCount, dstBuffer.remaining());
                        }
                        srcBuffer.get(srcDataRow, /*offset*/0, srcRowByteCount);
                        dstBuffer.put(srcDataRow, /*offset*/0, dstRowByteCount);
                    }
                } else {
                    // Row by row per pixel copy case
                    byte[] dstDataRow = new byte[dstRowByteCount];
                    for (int row = 0; row < effectivePlaneSize.getHeight(); row++) {
                        if (row == effectivePlaneSize.getHeight() - 1) {
                            // Special case for interleaved planes: need handle the last row
                            // carefully to avoid memory corruption. Check if we have enough bytes
                            // to copy.
                            int remainingBytes = srcBuffer.remaining();
                            if (srcRowByteCount > remainingBytes) {
                                srcRowByteCount = remainingBytes;
                            }
                            remainingBytes = dstBuffer.remaining();
                            if (dstRowByteCount > remainingBytes) {
                                dstRowByteCount = remainingBytes;
                            }
                        }
                        srcBuffer.get(srcDataRow, /*offset*/0, srcRowByteCount);
                        int pos = dstBuffer.position();
                        dstBuffer.get(dstDataRow, /*offset*/0, dstRowByteCount);
                        dstBuffer.position(pos);
                        for (int x = 0; x < effectivePlaneSize.getWidth(); x++) {
                            dstDataRow[x * dstPixStride] = srcDataRow[x * srcPixStride];
                        }
                        dstBuffer.put(dstDataRow, /*offset*/0, dstRowByteCount);
                    }
                }
            }
            srcBuffer.position(srcPos);
            dstBuffer.rewind();
        }
    }

    private static Size getEffectivePlaneSizeForImage(Image image, int planeIdx) {
        switch (image.getFormat()) {
            case ImageFormat.YUV_420_888:
                if (planeIdx == 0) {
                    return new Size(image.getWidth(), image.getHeight());
                } else {
                    return new Size(image.getWidth() / 2, image.getHeight() / 2);
                }
            case ImageFormat.JPEG:
            case ImageFormat.RAW_SENSOR:
            case ImageFormat.RAW10:
            case ImageFormat.RAW12:
            case ImageFormat.DEPTH16:
                return new Size(image.getWidth(), image.getHeight());
            case ImageFormat.PRIVATE:
                return new Size(0, 0);
            default:
                throw new UnsupportedOperationException(
                        String.format(""Invalid image format %d"", image.getFormat()));
        }
    }

    /**
     * <p>
     * Checks whether the two images are strongly equal.
     * </p>
     * <p>
     * Two images are strongly equal if and only if the data, formats, sizes,
     * and timestamps are same. For {@link ImageFormat#PRIVATE PRIVATE} format
     * images, the image data is not not accessible thus the data comparison is
     * effectively skipped as the number of planes is zero.
     * </p>
     * <p>
     * Note that this method compares the pixel data even outside of the crop
     * region, which may not be necessary for general use case.
     * </p>
     *
     * @param lhsImg First image to be compared with.
     * @param rhsImg Second image to be compared with.
     * @return true if the two images are equal, false otherwise.
     * @throws IllegalArgumentException If either of image is null.
     */
    public static boolean isImageStronglyEqual(Image lhsImg, Image rhsImg) {
        if (lhsImg == null || rhsImg == null) {
            throw new IllegalArgumentException(""Images should be non-null"");
        }

        if (lhsImg.getFormat() != rhsImg.getFormat()) {
            Log.i(TAG, ""lhsImg format "" + lhsImg.getFormat() + "" is different with rhsImg format ""
                    + rhsImg.getFormat());
            return false;
        }

        if (lhsImg.getWidth() != rhsImg.getWidth()) {
            Log.i(TAG, ""lhsImg width "" + lhsImg.getWidth() + "" is different with rhsImg width ""
                    + rhsImg.getWidth());
            return false;
        }

        if (lhsImg.getHeight() != rhsImg.getHeight()) {
            Log.i(TAG, ""lhsImg height "" + lhsImg.getHeight() + "" is different with rhsImg height ""
                    + rhsImg.getHeight());
            return false;
        }

        if (lhsImg.getTimestamp() != rhsImg.getTimestamp()) {
            Log.i(TAG, ""lhsImg timestamp "" + lhsImg.getTimestamp()
                    + "" is different with rhsImg timestamp "" + rhsImg.getTimestamp());
            return false;
        }

        if (!lhsImg.getCropRect().equals(rhsImg.getCropRect())) {
            Log.i(TAG, ""lhsImg crop rect "" + lhsImg.getCropRect()
                    + "" is different with rhsImg crop rect "" + rhsImg.getCropRect());
            return false;
        }

        // Compare data inside of the image.
        Plane[] lhsPlanes = lhsImg.getPlanes();
        Plane[] rhsPlanes = rhsImg.getPlanes();
        ByteBuffer lhsBuffer = null;
        ByteBuffer rhsBuffer = null;
        for (int i = 0; i < lhsPlanes.length; i++) {
            lhsBuffer = lhsPlanes[i].getBuffer();
            rhsBuffer = rhsPlanes[i].getBuffer();
            lhsBuffer.rewind();
            rhsBuffer.rewind();
            // Special case for YUV420_888 buffer with different layout or
            // potentially differently interleaved U/V planes.
            if (lhsImg.getFormat() == ImageFormat.YUV_420_888 &&
                    (lhsPlanes[i].getPixelStride() != rhsPlanes[i].getPixelStride() ||
                     lhsPlanes[i].getRowStride() != rhsPlanes[i].getRowStride() ||
                     (lhsPlanes[i].getPixelStride() != 1))) {
                int width = getEffectivePlaneSizeForImage(lhsImg, i).getWidth();
                int height = getEffectivePlaneSizeForImage(lhsImg, i).getHeight();
                int rowSizeL = lhsPlanes[i].getRowStride();
                int rowSizeR = rhsPlanes[i].getRowStride();
                byte[] lhsRow = new byte[rowSizeL];
                byte[] rhsRow = new byte[rowSizeR];
                int pixStrideL = lhsPlanes[i].getPixelStride();
                int pixStrideR = rhsPlanes[i].getPixelStride();
                for (int r = 0; r < height; r++) {
                    if (r == height -1) {
                        rowSizeL = lhsBuffer.remaining();
                        rowSizeR = rhsBuffer.remaining();
                    }
                    lhsBuffer.get(lhsRow, /*offset*/0, rowSizeL);
                    rhsBuffer.get(rhsRow, /*offset*/0, rowSizeR);
                    for (int c = 0; c < width; c++) {
                        if (lhsRow[c * pixStrideL] != rhsRow[c * pixStrideR]) {
                            Log.i(TAG, String.format(
                                    ""byte buffers for plane %d row %d col %d don't match."",
                                    i, r, c));
                            return false;
                        }
                    }
                }
            } else {
                // Compare entire buffer directly
                if (!lhsBuffer.equals(rhsBuffer)) {
                    Log.i(TAG, ""byte buffers for plane "" +  i + "" don't match."");
                    return false;
                }
            }
        }

        return true;
    }

    /**
     * Set jpeg related keys in a capture request builder.
     *
     * @param builder The capture request builder to set the keys inl
     * @param exifData The exif data to set.
     * @param thumbnailSize The thumbnail size to set.
     * @param collector The camera error collector to collect errors.
     */
    public static void setJpegKeys(CaptureRequest.Builder builder, ExifTestData exifData,
            Size thumbnailSize, CameraErrorCollector collector) {
        builder.set(CaptureRequest.JPEG_THUMBNAIL_SIZE, thumbnailSize);
        builder.set(CaptureRequest.JPEG_GPS_LOCATION, exifData.gpsLocation);
        builder.set(CaptureRequest.JPEG_ORIENTATION, exifData.jpegOrientation);
        builder.set(CaptureRequest.JPEG_QUALITY, exifData.jpegQuality);
        builder.set(CaptureRequest.JPEG_THUMBNAIL_QUALITY,
                exifData.thumbnailQuality);

        // Validate request set and get.
        collector.expectEquals(""JPEG thumbnail size request set and get should match"",
                thumbnailSize, builder.get(CaptureRequest.JPEG_THUMBNAIL_SIZE));
        collector.expectTrue(""GPS locations request set and get should match."",
                areGpsFieldsEqual(exifData.gpsLocation,
                builder.get(CaptureRequest.JPEG_GPS_LOCATION)));
        collector.expectEquals(""JPEG orientation request set and get should match"",
                exifData.jpegOrientation,
                builder.get(CaptureRequest.JPEG_ORIENTATION));
        collector.expectEquals(""JPEG quality request set and get should match"",
                exifData.jpegQuality, builder.get(CaptureRequest.JPEG_QUALITY));
        collector.expectEquals(""JPEG thumbnail quality request set and get should match"",
                exifData.thumbnailQuality,
                builder.get(CaptureRequest.JPEG_THUMBNAIL_QUALITY));
    }

    /**
     * Simple validation of JPEG"	"/home/gpoor/cts-12-source/cts/tests/camera/utils/src/android/hardware/camera2/cts/CameraTestUtils.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.graphics.fonts.SystemEmojiTest"	"isNotNull"	"CtsGraphicsTestCases"	"1: system"	"public void uniquePostScript() throws IOException {
        File emojiFont = null;
        for (Font font : SystemFonts.getAvailableFonts()) {
            if (font.getFile().getName().equals(""NotoColorEmoji.ttf"")) {
                emojiFont = font.getFile();
            }
        }

        // NotoColorEmoji.ttf should be always available as a fallback font even if another emoji
        // font files are installed in the system.
        assertThat(emojiFont).isNotNull();

        assertThat(FontFileTestUtil.containsEmojiCompatMetadata(emojiFont)).isTrue();
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/graphics/src/android/graphics/fonts/SystemEmojiTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.location.cts.gnss.asn1.supl2.rrlp_components.GPSDeltaElementList"	"GPSDeltaElementList"	"CtsLocationGnssTestCases"	"1: ui"	"public void test/*
 *.
 */

package android.location.cts.asn1.supl2.rrlp_components;

/*
 */


//
//
import android.location.cts.asn1.base.Asn1Null;
import android.location.cts.asn1.base.Asn1OctetString;
import android.location.cts.asn1.base.Asn1SequenceOf;
import android.location.cts.asn1.base.Asn1Tag;
import android.location.cts.asn1.base.BitStream;
import android.location.cts.asn1.base.BitStreamReader;
import com.google.common.collect.ImmutableList;
import java.util.Collection;
import javax.annotation.Nullable;


/**
 */
public  class GPSDeltaElementList
    extends Asn1SequenceOf<GPSDeltaElementList.GPSDeltaElementListComponentType> {
  //

  private static final Asn1Tag TAG_GPSDeltaElementList
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public GPSDeltaElementList() {
    super();
    setMinSize(1);
setMaxSize(32);

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_GPSDeltaElementList;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_GPSDeltaElementList != null) {
      return ImmutableList.of(TAG_GPSDeltaElementList);
    } else {
      return Asn1SequenceOf.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new GPSDeltaElementList from encoded stream.
   */
  public static GPSDeltaElementList fromPerUnaligned(byte[] encodedBytes) {
    GPSDeltaElementList result = new GPSDeltaElementList();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new GPSDeltaElementList from encoded stream.
   */
  public static GPSDeltaElementList fromPerAligned(byte[] encodedBytes) {
    GPSDeltaElementList result = new GPSDeltaElementList();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  
  @Override public GPSDeltaElementList.GPSDeltaElementListComponentType createAndAddValue() {
    GPSDeltaElementList.GPSDeltaElementListComponentType value = new GPSDeltaElementList.GPSDeltaElementListComponentType();
    add(value);
    return value;
  }

/*
 */


//

/**
 */
public static class GPSDeltaElementListComponentType extends Asn1OctetString {
  //

  private static final Asn1Tag TAG_GPSDeltaElementListComponentType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public GPSDeltaElementListComponentType() {
    super();
    setMinSize(1);
setMaxSize(47);

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_GPSDeltaElementListComponentType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_GPSDeltaElementListComponentType != null) {
      return ImmutableList.of(TAG_GPSDeltaElementListComponentType);
    } else {
      return Asn1OctetString.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new GPSDeltaElementListComponentType from encoded stream.
   */
  public static GPSDeltaElementListComponentType fromPerUnaligned(byte[] encodedBytes) {
    GPSDeltaElementListComponentType result = new GPSDeltaElementListComponentType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new GPSDeltaElementListComponentType from encoded stream.
   */
  public static GPSDeltaElementListComponentType fromPerAligned(byte[] encodedBytes) {
    GPSDeltaElementListComponentType result = new GPSDeltaElementListComponentType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override protected String getTypeName() {
    return ""GPSDeltaElementListComponentType"";
  }
}
 

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    StringBuilder builder = new StringBuilder();
    builder.append(""GPSDeltaElementList = [\n"");
    final String internalIndent = indent + ""  "";
    for (GPSDeltaElementList.GPSDeltaElementListComponentType value : getValues()) {
      builder.append(internalIndent)
          .append(value.toIndentedString(internalIndent));
    }
    builder.append(indent).append(""];\n"");
    return builder.toString();
  }
}"	"/home/gpoor/cts-12-source/cts/tests/location/location_gnss/src/android/location/cts/gnss/asn1/supl2/rrlp_components/GPSDeltaElementList.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.helpers.aosp.DefaultCtsPrintHelper"	"uptimeMillis"	""	"3: hide ui system"	"public void test/*
 *.
 */

package com.android.cts.helpers.aosp;

import android.app.Instrumentation;
import android.app.UiAutomation;
import android.os.RemoteException;

import android.os.SystemClock;
import android.platform.helpers.exceptions.TestHelperException;
import android.support.test.uiautomator.By;
import android.support.test.uiautomator.UiDevice;
import android.support.test.uiautomator.UiObject;
import android.support.test.uiautomator.UiObject2;
import android.support.test.uiautomator.UiObjectNotFoundException;
import android.support.test.uiautomator.UiSelector;
import android.support.test.uiautomator.Until;
import android.util.Log;

import com.android.cts.helpers.ICtsPrintHelper;

import java.io.ByteArrayOutputStream;
import java.io.IOException;

public class DefaultCtsPrintHelper implements ICtsPrintHelper {
    private static final String LOG_TAG = DefaultCtsPrintHelper.class.getSimpleName();

    protected static final long OPERATION_TIMEOUT_MILLIS = 60000;
    private static final long GET_UIAUTOMATION_TIMEOUT_MS = 60000;

    protected Instrumentation mInstrumentation;
    protected UiDevice mDevice;
    protected UiAutomation mAutomation;

    public DefaultCtsPrintHelper(Instrumentation instrumentation) {
        mInstrumentation = instrumentation;
        mDevice = UiDevice.getInstance(mInstrumentation);

        long start = SystemClock.uptimeMillis();
        while (SystemClock.uptimeMillis() - start < GET_UIAUTOMATION_TIMEOUT_MS) {
            UiAutomation ui = mInstrumentation.getUiAutomation();
            if (ui != null) {
                mAutomation = ui;
                break;
            }
        }
        if (mAutomation == null) {
            throw new AssertionError(""Failed to get UiAutomation"");
        }
    }

    protected void dumpWindowHierarchy() throws TestHelperException {
        try {
            ByteArrayOutputStream os = new ByteArrayOutputStream();
            mDevice.dumpWindowHierarchy(os);

            Log.w(LOG_TAG, ""Window hierarchy:"");
            for (String line : os.toString(""UTF-8"").split(""\n"")) {
                Log.w(LOG_TAG, line);
            }
        } catch (IOException e) {
            throw new TestHelperException(e);
        }
    }

    @Override
    public void setUp() throws TestHelperException {
        try {
            // Prevent rotation
            mDevice.freezeRotation();
            while (!mDevice.isNaturalOrientation()) {
                mDevice.setOrientationNatural();
                mDevice.waitForIdle();
            }
        } catch (RemoteException e) {
            throw new TestHelperException(""Failed to freeze device rotation"", e);
        }
    }

    @Override
    public void tearDown() throws TestHelperException {
        try {
            // Allow rotation
            mDevice.unfreezeRotation();
        } catch (RemoteException e) {
            throw new TestHelperException(""Failed to unfreeze device rotation"", e);
        }
    }

    @Override
    public void submitPrintJob() throws TestHelperException {
        Log.d(LOG_TAG, ""Clicking print button"");

        mDevice.waitForIdle();

        UiObject2 printButton =
                mDevice.wait(
                        Until.findObject(By.res(""com.android.printspooler:id/print_button"")),
                        OPERATION_TIMEOUT_MILLIS);
        if (printButton == null) {
            dumpWindowHierarchy();
            throw new TestHelperException(""print button not found"");
        }

        printButton.click();
    }

    @Override
    public void retryPrintJob() throws TestHelperException {
        try {
            UiObject retryButton = mDevice.findObject(new UiSelector().resourceId(
                    ""com.android.printspooler:id/action_button""));
            retryButton.click();
        } catch (UiObjectNotFoundException e) {
            dumpWindowHierarchy();
            throw new TestHelperException(""Retry button not found"", e);
        }
    }

    @Override
    public boolean canSubmitJob() {
        return mDevice.hasObject(By.res(""com.android.printspooler:id/print_button""));
    }

    @Override
    public void answerPrintServicesWarning(boolean confirm) throws TestHelperException {
        try {
            mDevice.waitForIdle();
            UiObject button;
            if (confirm) {
                button = mDevice.findObject(new UiSelector().resourceId(""android:id/button1""));
            } else {
                button = mDevice.findObject(new UiSelector().resourceId(""android:id/button2""));
            }
            button.click();
        } catch (UiObjectNotFoundException e) {
            dumpWindowHierarchy();
            throw new TestHelperException(""Unable to find print service dialog button"", e);
        }
    }

    @Override
    public void selectPrinter(String printerName, long timeout) throws TestHelperException {
        Log.d(LOG_TAG, ""Selecting printer "" + printerName);
        try {
            UiObject2 destinationSpinner =
                    mDevice.wait(
                            Until.findObject(
                                    By.res(""com.android.printspooler:id/destination_spinner"")),
                            timeout);

            if (destinationSpinner != null) {
                destinationSpinner.click();
                mDevice.waitForIdle();
            }

            UiObject2 printerOption = mDevice.wait(Until.findObject(By.text(printerName)), timeout);
            if (printerOption == null) {
                throw new UiObjectNotFoundException(printerName + "" not found"");
            }

            printerOption.click();
            mDevice.waitForIdle();
        } catch (Exception e) {
            dumpWindowHierarchy();
            throw new TestHelperException(""Failed to select printer"", e);
        }
    }

    @Override
    public void selectPrinterWhenAvailable(String printerName) throws TestHelperException {
        try {
            while (true) {
                UiObject printerItem = mDevice.findObject(
                        new UiSelector().text(printerName));

                if (printerItem.isEnabled()) {
                    printerItem.click();
                    break;
                } else {
                    Thread.sleep(100);
                }
            }
        } catch (UiObjectNotFoundException e) {
            throw new TestHelperException(""Failed to find printer label"", e);
        } catch (InterruptedException e) {
            throw new TestHelperException(""Interruped while waiting for printer"", e);
        }
    }

    @Override
    public void setPageOrientation(String orientation) throws TestHelperException {
        try {
            UiObject orientationSpinner = mDevice.findObject(new UiSelector().resourceId(
                    ""com.android.printspooler:id/orientation_spinner""));
            orientationSpinner.click();
            UiObject orientationOption = mDevice.findObject(new UiSelector().text(orientation));
            orientationOption.click();
        } catch (UiObjectNotFoundException e) {
            dumpWindowHierarchy();
            throw new TestHelperException(""Failed to set page orientation to "" + orientation, e);
        }
    }

    @Override
    public String getPageOrientation() throws TestHelperException {
        try {
            UiObject orientationSpinner = mDevice.findObject(new UiSelector().resourceId(
                    ""com.android.printspooler:id/orientation_spinner""));
            return orientationSpinner.getText();
        } catch (UiObjectNotFoundException e) {
            dumpWindowHierarchy();
            throw new TestHelperException(""Failed to get page orientation"", e);
        }
    }

    @Override
    public void setMediaSize(String mediaSize) throws TestHelperException {
        try {
            UiObject mediaSizeSpinner = mDevice.findObject(new UiSelector().resourceId(
                    ""com.android.printspooler:id/paper_size_spinner""));
            mediaSizeSpinner.click();
            UiObject mediaSizeOption = mDevice.findObject(new UiSelector().text(mediaSize));
            mediaSizeOption.click();
        } catch (UiObjectNotFoundException e) {
            dumpWindowHierarchy();
            throw new TestHelperException(""Unable to set media size to "" + mediaSize, e);
        }
    }

    @Override
    public void setColorMode(String color) throws TestHelperException {
        try {
            UiObject colorSpinner = mDevice.findObject(new UiSelector().resourceId(
                    ""com.android.printspooler:id/color_spinner""));
            colorSpinner.click();
            UiObject colorOption = mDevice.findObject(new UiSelector().text(color));
            colorOption.click();
        } catch (UiObjectNotFoundException e) {
            dumpWindowHierarchy();
            throw new TestHelperException(""Unable to set color mode to "" + color, e);
        }
    }

    @Override
    public String getColorMode() throws TestHelperException {
        try {
            UiObject colorSpinner = mDevice.findObject(new UiSelector().resourceId(
                    ""com.android.printspooler:id/color_spinner""));
            return colorSpinner.getText();
        } catch (UiObjectNotFoundException e) {
            dumpWindowHierarchy();
            throw new TestHelperException(""Unable to get color mode"", e);
        }
    }

    @Override
    public void setDuplexMode(String duplex) throws TestHelperException {
        try {
            UiObject duplexSpinner = mDevice.findObject(new UiSelector().resourceId(
                    ""com.android.printspooler:id/duplex_spinner""));
            duplexSpinner.click();
            UiObject duplexOption = mDevice.findObject(new UiSelector().text(duplex));
            duplexOption.click();
        } catch (UiObjectNotFoundException e) {
            dumpWindowHierarchy();
            throw new TestHelperException(""Unable to set duplex mode to "" + duplex, e);
        }
    }

    @Override
    public void setCopies(int newCopies) throws TestHelperException {
        try {
            UiObject copies = mDevice.findObject(new UiSelector().resourceId(
                    ""com.android.printspooler:id/copies_edittext""));
            copies.setText(Integer.valueOf(newCopies).toString());
        } catch (UiObjectNotFoundException e) {
            dumpWindowHierarchy();
            throw new TestHelperException(""Unable to set copies to "" + newCopies, e);
        }
    }

    @Override
    public int getCopies() throws TestHelperException {
        try {
            UiObject copies = mDevice.findObject(new UiSelector().resourceId(
                    ""com.android.printspooler:id/copies_edittext""));
            return Integer.parseInt(copies.getText());
        } catch (UiObjectNotFoundException e) {
            dumpWindowHierarchy();
            throw new TestHelperException(""Unable to get number of copies"", e);
        }
    }

    @Override
    public void setPageRange(String pages, int expectedPages) throws TestHelperException {
        try {
            mDevice.waitForIdle();
            UiObject pagesSpinner = mDevice.findObject(new UiSelector().resourceId(
                    ""com.android.printspooler:id/range_options_spinner""));
            pagesSpinner.click();

            mDevice.waitForIdle();
            UiObject rangeOption = mDevice.findObject(new UiSelector().textContains(""Range of ""
                    + expectedPages));
            rangeOption.click();

            mDevice.waitForIdle();
            UiObject pagesEditText = mDevice.findObject(new UiSelector().resourceId(
                    ""com.android.printspooler:id/page_range_edittext""));
            pagesEditText.setText(pages);

            mDevice.waitForIdle();
            // Hide the keyboard.
            mDevice.pressBack();
        } catch (UiObjectNotFoundException e) {
            dumpWindowHierarchy();
            throw new TestHelperException(""Unable to set page range"", e);
        }
    }

    @Override
    public String getPageRange(int docPages) throws TestHelperException {
        final String fullRange = ""All "" + docPages;

        try {
            if (mDevice.hasObject(By.text(fullRange))) {
                return fullRange;
            }

            UiObject pagesEditText = mDevice.findObject(new UiSelector().resourceId(
                    ""com.android.printspooler:id/page_range_edittext""));

            return pagesEditText.getText();
        } catch (UiObjectNotFoundException e) {
            dumpWindowHierarchy();
            throw new TestHelperException(""Unable to get page range"", e);
        }
    }

    @Override
    public String getStatusMessage() throws TestHelperException {
        UiObject2 message = mDevice.wait(Until.findObject(
                By.res(""com.android.printspooler:id/message"")), OPERATION_TIMEOUT_MILLIS);

        if (message == null) {
            dumpWindowHierarchy();
            throw new TestHelperException(""Cannot find status message"");
        }

        return message.getText();
    }

    @Override
    public void openPrintOptions() throws TestHelperException {
        try {
            UiObject expandHandle = mDevice.findObject(new UiSelector().resourceId(
                    ""com.android.printspooler:id/expand_collapse_handle""));
            expandHandle.click();
        } catch (UiObjectNotFoundException e) {
            dumpWindowHierarchy();
            throw new TestHelperException(""Unable to find print options handle"", e);
        }
    }

    @Override
    public void openCustomPrintOptions() throws TestHelperException {
        try {
            UiObject expandHandle = mDevice.findObject(new UiSelector().resourceId(
                    ""com.android.printspooler:id/more_options_button""));
            expandHandle.click();
        } catch (UiObjectNotFoundException e) {
            dumpWindowHierarchy();
            throw new TestHelperException(""Unable to find print options handle"", e);
        }
    }

    @Override
    public void displayPrinterList() throws TestHelperException {
        try {
            // Open destination spinner
            UiObject destinationSpinner = mDevice.findObject(new UiSelector().resourceId(
                    ""com.android.printspooler:id/destination_spinner""));
            destinationSpinner.click();

            // Wait until spinner is opened
            mDevice.waitForIdle();
        } catch (UiObjectNotFoundException e) {
            throw new TestHelperException(""Unable to find destination spinner"", e);
        }
    }

    @Override
    public void displayMoreInfo() throws TestHelperException {
        mDevice.waitForIdle();
        mDevice.wait(
                Until.findObject(By.res(""com.android.printspooler:id/more_info"")),
                OPERATION_TIMEOUT_MILLIS).click();
    }

    @Override
    public void closePrinterList() {
        mDevice.pressBack();
    }

    @Override
    public void closeCustomPrintOptions() {
        mDevice.pressBack();
    }

    @Override
    public void closePrintOptions() {
        mDevice.pressBack();
    }

    @Override
    public void cancelPrinting() throws TestHelperException {
        try {
            mDevice.wakeUp();
            mDevice.pressBack();
            mDevice.waitForIdle();
        } catch (RemoteException e) {
            throw new TestHelperException(""Failed to cancel printing"", e);
        }
    }
}"	"/home/gpoor/cts-12-source/cts/helpers/default/src/com/android/cts/helpers/aosp/DefaultCtsPrintHelper.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telephony.sdk28.cts.CellInfoTest"	"testCellInfoSdk28"	"CtsTelephonySdk28TestCases"	"2: ui system"	"public void testCellInfoSdk28() {
        if (!mPm.hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            Log.d(TAG, ""Skipping test that requires FEATURE_TELEPHONY"");
            return;
        }

        if (!isCamped()) fail(""Device is not camped to a cell"");

        List<CellInfo> cellInfo = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTm, TelephonyManager::getAllCellInfo);

        // getAllCellInfo should never return null, and there should be at least one entry.
        assertNotNull(""TelephonyManager.getAllCellInfo() returned NULL CellInfo"", cellInfo);
        assertFalse(""TelephonyManager.getAllCellInfo() returned an empty list"", cellInfo.isEmpty());

        final long initialTime = cellInfo.get(0).getTimeStamp();

        for(int i = 0; i < MAX_WAIT_SECONDS; i++) {
            try {
                Thread.sleep(POLL_INTERVAL_MILLIS); // 1 second
            } catch (InterruptedException ie) {
                fail(""Thread was interrupted"");
            }
            List<CellInfo> newCellInfo = ShellIdentityUtils.invokeMethodWithShellPermissions(
                    mTm, TelephonyManager::getAllCellInfo);
            assertNotNull(""TelephonyManager.getAllCellInfo() returned NULL CellInfo"", newCellInfo);
            assertFalse(""TelephonyManager.getAllCellInfo() returned an empty list"",
                    newCellInfo.isEmpty());
            // Test that new CellInfo has been retrieved from the modem
            if (newCellInfo.get(0).getTimeStamp() != initialTime) return;
        }
        fail(""CellInfo failed to update after "" + MAX_WAIT_SECONDS + "" seconds."");
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/sdk28/src/android/telephony/sdk28/cts/CellInfoTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telephony.sdk28.cts.CellInfoTest"	"isCamped"	"CtsTelephonySdk28TestCases"	"1: system"	"/*
 *.
 */

package android.telephony.sdk28.cts;

import static androidx.test.InstrumentationRegistry.getContext;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import android.content.Context;
import android.content.pm.PackageManager;
import android.telephony.AccessNetworkConstants;
import android.telephony.CellInfo;
import android.telephony.NetworkRegistrationInfo;
import android.telephony.ServiceState;
import android.telephony.TelephonyManager;
import android.util.Log;

import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.Before;
import org.junit.Test;

import java.util.List;

public class CellInfoTest {
    private static final String TAG = ""CellInfoTest"";

    private static final int MAX_WAIT_SECONDS = 15;
    private static final int POLL_INTERVAL_MILLIS = 1000;

    private static final String[] sPermissions = new String[] {
            android.Manifest.permission.READ_PHONE_STATE,
            android.Manifest.permission.ACCESS_COARSE_LOCATION};

    private TelephonyManager mTm;
    private PackageManager mPm;

    private boolean isCamped() {
        ServiceState ss = ShellIdentityUtils.invokeMethodWithShellPermissions(
                mTm, TelephonyManager::getServiceState);

        if (ss == null) return false;
        if (ss.getState() == ServiceState.STATE_EMERGENCY_ONLY) return true;
        List<NetworkRegistrationInfo> nris = ss.getNetworkRegistrationInfoList();
        for (NetworkRegistrationInfo nri : nris) {
            if (nri.getTransportType() != AccessNetworkConstants.TRANSPORT_TYPE_WWAN) continue;
            if (nri.isRegistered()) return true;
        }
        return false;
    }

    @Before
    public void setUp() throws Exception {
        mTm = (TelephonyManager) getContext().getSystemService(Context.TELEPHONY_SERVICE);
        mPm = getContext().getPackageManager();

        for (String permission : sPermissions) {
            assertTrue(""Something (not this test) has denied needed permission="" + permission,
                    getContext().checkSelfPermission(permission)
                            == android.content.pm.PackageManager.PERMISSION_GRANTED);
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/sdk28/src/android/telephony/sdk28/cts/CellInfoTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"dot.junit.AllTests"	"TestSuite"	""	"1: ui"	"public void test/*
 * Copyright (C) 2008 The Android Open Source Project
 * 
 * Licensed under the Apache License, Version 2.0 (the ""License""); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

package dot.junit;

import junit.framework.Test;
import junit.framework.TestSuite;
import junit.textui.TestRunner;

/**
 * Listing of all the tests that are to be run.
 */
public class AllTests {
    public static void run() {
        TestRunner.main(new String[] {AllTests.class.getName()});
    }

    public static final Test suite() {
        TestSuite suite = new TestSuite();
        // tests all opcodes
        suite.addTest(dot.junit.opcodes.AllTests.suite());
        suite.addTest(dot.junit.verify.AllTests.suite());
        suite.addTest(dot.junit.format.AllTests.suite());
        return suite;
    }
}"	"/home/gpoor/cts-12-source/cts/tools/vm-tests-tf/src/dot/junit/AllTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.quickaccesswallet.cts.TestUtils"	"isNotNull"	"CtsQuickAccessWalletTestCases"	"1: ui"	"public void test/*
 *.
 */

package android.quickaccesswallet.cts;

import static com.google.common.truth.Truth.assertThat;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.graphics.drawable.Icon;

import com.android.compatibility.common.util.BitmapUtils;

class TestUtils {

    static void compareIcons(Context context, Icon icon1, Icon icon2) {
        if (icon1 == null && icon2 == null) {
            return;
        }
        assertThat(icon1).isNotNull();
        assertThat(icon2).isNotNull();
        Drawable drawable1 = icon1.loadDrawable(context);
        Drawable drawable2 = icon2.loadDrawable(context);
        if (drawable1 instanceof BitmapDrawable) {
            assertThat(drawable2).isInstanceOf(BitmapDrawable.class);
            Bitmap bitmap1 = ((BitmapDrawable) drawable1).getBitmap();
            Bitmap bitmap2 = ((BitmapDrawable) drawable2).getBitmap();
            assertThat(BitmapUtils.compareBitmaps(bitmap1, bitmap2)).isTrue();
        } else {
            assertThat(icon1.getResId()).isEqualTo(icon2.getResId());
        }
    }
}"	"/home/gpoor/cts-12-source/cts/tests/quickaccesswallet/src/android/quickaccesswallet/cts/TestUtils.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.security.identity.cts.UserAuthTest"	"testUserAuth"	"CtsIdentityTestCases"	"4: mic ui system user"	"public void testUserAuth() throws Exception {
        String alias = ""authbound"";

        try (DeviceLockSession dl = new DeviceLockSession()) {
            Context appContext = InstrumentationRegistry.getTargetContext();
            KeyguardManager keyguardManager = (KeyguardManager)appContext
                                              .getSystemService(Context.KEYGUARD_SERVICE);

            doTestUserAuth(dl, keyguardManager);
        } catch (org.junit.AssumptionViolatedException e) {
            /* do nothing */
        }
    }

    void doTestUserAuth(DeviceLockSession dl, KeyguardManager keyguardManager) throws Exception {
        assumeTrue(""IC HAL is not implemented"", TestUtil.isHalImplemented());

        // This test creates two different access control profiles:
        //
        // - free for all
        // - user authentication with 10 second timeout
        //
        // and for each ACP, a single entry which is protected by only that ACP.
        //
        // Note that we cannot test authentication on every reader session (e.g. timeout set to 0)
        // due to limitations of testing harness (only BiometricPrompt takes a CryptoObject).
        //

        // Provision the credential.
        Context appContext = InstrumentationRegistry.getTargetContext();
        IdentityCredentialStore store = IdentityCredentialStore.getInstance(appContext);

        store.deleteCredentialByName(""test"");
        WritableIdentityCredential wc = store.createCredential(""test"",
                ""org.iso.18013-5.2019.mdl"");
        // Profile 1 (user auth with 10000 msec timeout)
        AccessControlProfile authTenSecTimeoutProfile =
                new AccessControlProfile.Builder(new AccessControlProfileId(1))
                        .setUserAuthenticationRequired(true)
                        .setUserAuthenticationTimeout(10000)
                        .build();
        // Profile 0 (free for all)
        AccessControlProfile freeForAllProfile =
                new AccessControlProfile.Builder(new AccessControlProfileId(0))
                        .setUserAuthenticationRequired(false)
                        .build();
        // (We add the profiles in this weird order - 1, 0 - to check below that the
        // provisioning receipt lists them in the same order.)
        Collection<AccessControlProfileId> idsProfile0 = new ArrayList<AccessControlProfileId>();
        idsProfile0.add(new AccessControlProfileId(0));
        Collection<AccessControlProfileId> idsProfile1 = new ArrayList<AccessControlProfileId>();
        idsProfile1.add(new AccessControlProfileId(1));

        String mdlNs = ""org.iso.18013-5.2019"";
        PersonalizationData personalizationData =
                new PersonalizationData.Builder()
                        .addAccessControlProfile(authTenSecTimeoutProfile)
                        .addAccessControlProfile(freeForAllProfile)
                        .putEntry(mdlNs, ""Accessible to all (0)"", idsProfile0,
                                Util.cborEncodeString(""foo0""))
                        .putEntry(mdlNs, ""Accessible to auth-with-10-sec-timeout (1)"", idsProfile1,
                                Util.cborEncodeString(""foo1""))
                        .build();
        byte[] proofOfProvisioningSignature = wc.personalize(personalizationData);
        byte[] proofOfProvisioning = Util.coseSign1GetData(proofOfProvisioningSignature);

        String pretty = Util.cborPrettyPrint(proofOfProvisioning);
        Log.d(TAG, ""pretty: "" + pretty);
        assertEquals(""[\n""
                + ""  'ProofOfProvisioning',\n""
                + ""  'org.iso.18013-5.2019.mdl',\n""
                + ""  [\n""
                + ""    {\n""
                + ""      'id' : 1,\n""
                + ""      'userAuthenticationRequired' : true,\n""
                + ""      'timeoutMillis' : 10000\n""
                + ""    },\n""
                + ""    {\n""
                + ""      'id' : 0\n""
                + ""    }\n""
                + ""  ],\n""
                + ""  {\n""
                + ""    'org.iso.18013-5.2019' : [\n""
                + ""      {\n""
                + ""        'name' : 'Accessible to all (0)',\n""
                + ""        'value' : 'foo0',\n""
                + ""        'accessControlProfiles' : [0]\n""
                + ""      },\n""
                + ""      {\n""
                + ""        'name' : 'Accessible to auth-with-10-sec-timeout (1)',\n""
                + ""        'value' : 'foo1',\n""
                + ""        'accessControlProfiles' : [1]\n""
                + ""      }\n""
                + ""    ]\n""
                + ""  },\n""
                + ""  false\n""
                + ""]"", pretty);

        // Get the credential we'll be reading from and provision it with a sufficient number
        // of dynamic auth keys
        IdentityCredential credential = store.getCredentialByName(""test"",
                CIPHERSUITE_ECDHE_HKDF_ECDSA_WITH_AES_256_GCM_SHA256);
        assertNotNull(credential);
        credential.setAvailableAuthenticationKeys(1, 10);
        Collection<X509Certificate> dynAuthKeyCerts = credential.getAuthKeysNeedingCertification();
        credential.storeStaticAuthenticationData(dynAuthKeyCerts.iterator().next(), new byte[0]);

        // Sleep at least the timeout to ensure that the deadline has been reached.
        //
        // Then we test that
        //
        //  ""Accessible to auth-with-10-sec-timeout (1)""
        //
        // is not available.
        SystemClock.sleep(11 * 1000);

        Collection<String> entryNames;
        Collection<String> resultNamespaces;
        ResultData rd;

        Map<String, Collection<String>> entriesToRequest = new LinkedHashMap<>();
        entriesToRequest.put(""org.iso.18013-5.2019"",
                Arrays.asList(""Accessible to all (0)"",
                        ""Accessible to auth-with-10-sec-timeout (1)""));

        rd = credential.getEntries(
            Util.createItemsRequest(entriesToRequest, null),
            entriesToRequest,
            null,  // sessionTranscript
            null); // readerSignature
        resultNamespaces = rd.getNamespaces();
        assertEquals(1, resultNamespaces.size());
        assertEquals(""org.iso.18013-5.2019"", resultNamespaces.iterator().next());
        entryNames = rd.getEntryNames(""org.iso.18013-5.2019"");
        assertEquals(2, entryNames.size());
        assertTrue(entryNames.contains(""Accessible to all (0)""));
        assertTrue(entryNames.contains(""Accessible to auth-with-10-sec-timeout (1)""));
        assertEquals(ResultData.STATUS_OK,
                rd.getStatus(""org.iso.18013-5.2019"", ""Accessible to all (0)""));
        assertEquals(ResultData.STATUS_USER_AUTHENTICATION_FAILED,
                rd.getStatus(""org.iso.18013-5.2019"", ""Accessible to auth-with-10-sec-timeout (1)""));
        assertEquals(""foo0"",
                Util.getStringEntry(rd, ""org.iso.18013-5.2019"", ""Accessible to all (0)""));
        assertEquals(null,
                rd.getEntry(""org.iso.18013-5.2019"", ""Accessible to auth-with-10-sec-timeout (1)""));

        // Now we lock and unlock the screen... this should make
        //
        //  Accessible to auth-with-10-sec-timeout (1)
        //
        // available. We check that.
        dl.performDeviceLock();
        assertTrue(keyguardManager.isDeviceLocked());
        dl.performDeviceUnlock();
        assertTrue(!keyguardManager.isDeviceLocked());

        credential = store.getCredentialByName(""test"",
                CIPHERSUITE_ECDHE_HKDF_ECDSA_WITH_AES_256_GCM_SHA256);
        assertNotNull(credential);
        rd = credential.getEntries(Util.createItemsRequest(entriesToRequest, null),
                entriesToRequest,
                null,  // sessionTranscript
                null); // readerSignature
        resultNamespaces = rd.getNamespaces();
        assertEquals(1, resultNamespaces.size());
        assertEquals(""org.iso.18013-5.2019"", resultNamespaces.iterator().next());
        entryNames = rd.getEntryNames(""org.iso.18013-5.2019"");
        assertEquals(2, entryNames.size());
        assertTrue(entryNames.contains(""Accessible to all (0)""));
        assertTrue(entryNames.contains(""Accessible to auth-with-10-sec-timeout (1)""));
        assertEquals(ResultData.STATUS_OK,
                rd.getStatus(""org.iso.18013-5.2019"", ""Accessible to all (0)""));
        assertEquals(ResultData.STATUS_OK,
                rd.getStatus(""org.iso.18013-5.2019"", ""Accessible to auth-with-10-sec-timeout (1)""));
        assertEquals(""foo0"",
                Util.getStringEntry(rd, ""org.iso.18013-5.2019"", ""Accessible to all (0)""));
        assertEquals(""foo1"",
                Util.getStringEntry(rd, ""org.iso.18013-5.2019"",
                        ""Accessible to auth-with-10-sec-timeout (1)""));

        // Now we again sleep at least the timeout to ensure that the deadline has been reached.
        //
        // Then we test that
        //
        //  ""Accessible to auth-with-10-sec-timeout (1)""
        //
        // is not available.
        SystemClock.sleep(11 * 1000);

        credential = store.getCredentialByName(""test"",
                CIPHERSUITE_ECDHE_HKDF_ECDSA_WITH_AES_256_GCM_SHA256);
        assertNotNull(credential);
        rd = credential.getEntries(
            Util.createItemsRequest(entriesToRequest, null),
            entriesToRequest,
            null,  // sessionTranscript
            null); // readerSignature
        resultNamespaces = rd.getNamespaces();
        assertEquals(1, resultNamespaces.size());
        assertEquals(""org.iso.18013-5.2019"", resultNamespaces.iterator().next());
        entryNames = rd.getEntryNames(""org.iso.18013-5.2019"");
        assertEquals(2, entryNames.size());
        assertTrue(entryNames.contains(""Accessible to all (0)""));
        assertTrue(entryNames.contains(""Accessible to auth-with-10-sec-timeout (1)""));
        assertEquals(ResultData.STATUS_OK,
                rd.getStatus(""org.iso.18013-5.2019"", ""Accessible to all (0)""));
        assertEquals(ResultData.STATUS_USER_AUTHENTICATION_FAILED,
                rd.getStatus(""org.iso.18013-5.2019"", ""Accessible to auth-with-10-sec-timeout (1)""));
        assertEquals(""foo0"",
                Util.getStringEntry(rd, ""org.iso.18013-5.2019"", ""Accessible to all (0)""));
        assertEquals(null,
                rd.getEntry(""org.iso.18013-5.2019"", ""Accessible to auth-with-10-sec-timeout (1)""));
    }

}"	"/home/gpoor/cts-12-source/cts/tests/tests/identity/src/android/security/identity/cts/UserAuthTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.security.identity.cts.UserAuthTest"	"isDeviceLocked"	"CtsIdentityTestCases"	"3: ui system user"	"/*
 *.
 */

package android.security.identity.cts;

import static android.security.identity.IdentityCredentialStore.CIPHERSUITE_ECDHE_HKDF_ECDSA_WITH_AES_256_GCM_SHA256;

import android.security.identity.AccessControlProfile;
import android.security.identity.AccessControlProfileId;
import android.security.identity.AlreadyPersonalizedException;
import android.security.identity.PersonalizationData;
import android.security.identity.IdentityCredential;
import android.security.identity.IdentityCredentialException;
import android.security.identity.IdentityCredentialStore;
import android.security.identity.WritableIdentityCredential;
import android.security.identity.ResultData;
import com.android.security.identity.internal.Util;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assume.assumeTrue;

import android.content.Context;
import android.os.SystemClock;
import android.util.Log;

import androidx.test.InstrumentationRegistry;

import android.app.KeyguardManager;
import android.server.wm.ActivityManagerTestBase;

import org.junit.Test;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyPair;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.Signature;
import java.security.SignatureException;
import java.security.cert.CertificateException;
import java.security.cert.X509Certificate;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.Map;

import co.nstant.in.cbor.CborBuilder;
import co.nstant.in.cbor.CborEncoder;
import co.nstant.in.cbor.CborException;

import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.UnrecoverableEntryException;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.KeyGenerator;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.SecretKey;
import javax.crypto.spec.GCMParameterSpec;

import android.security.keystore.KeyGenParameterSpec;
import android.security.keystore.KeyProperties;
import android.security.keystore.UserNotAuthenticatedException;


public class UserAuthTest {
    private static final String TAG = ""UserAuthTest"";

    private class DeviceLockSession extends ActivityManagerTestBase implements AutoCloseable {

        private LockScreenSession mLockCredential;

        public DeviceLockSession() throws Exception {
            mLockCredential = new LockScreenSession();
            mLockCredential.setLockCredential();
        }

        public void performDeviceLock() {
            mLockCredential.sleepDevice();
            Context appContext = InstrumentationRegistry.getTargetContext();
            KeyguardManager keyguardManager = (KeyguardManager)appContext.
                                              getSystemService(Context.KEYGUARD_SERVICE);
            for (int i = 0; i < 25 && !keyguardManager.isDeviceLocked(); i++) {
                SystemClock.sleep(200);
            }
        }

        public void performDeviceUnlock() throws Exception {
            mLockCredential.gotoKeyguard();
            mLockCredential.enterAndConfirmLockCredential();
            launchHomeActivity();
            Context appContext = InstrumentationRegistry.getTargetContext();
            KeyguardManager keyguardManager = (KeyguardManager)appContext.
                                              getSystemService(Context.KEYGUARD_SERVICE);
            int waitCount = 5;
            do {
                SystemClock.sleep(1000);
                if (!keyguardManager.isDeviceLocked()) {
                    break;
                }
                Log.w(TAG, ""Device was still locked, sleeping and retrying..."");
                mLockCredential.enterAndConfirmLockCredential();
            } while (waitCount-- >= 0);
        }

        @Override
        public void close() throws Exception {
            mLockCredential.close();
        }
    }

    private boolean checkAuthBoundKey(String alias) {
        // Unfortunately there are no APIs to tell if a key needs user authentication to work so
        // we check if the key is available by simply trying to encrypt some data.
        try {
            KeyStore ks = KeyStore.getInstance(""AndroidKeyStore"");
            ks.load(null);
            KeyStore.Entry entry = ks.getEntry(alias, null);
            SecretKey secretKey = ((KeyStore.SecretKeyEntry) entry).getSecretKey();

            Cipher cipher = Cipher.getInstance(""AES/GCM/NoPadding"");
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
            byte[] clearText = {0x01, 0x02};
            byte[] cipherText = cipher.doFinal(clearText);
            return true;
        } catch (UserNotAuthenticatedException e) {
            return false;
        } catch (Exception e) {
            throw new RuntimeException(""Failed!"", e);
        }
    }

    void createAuthBoundKey(String alias, int timeoutSeconds) {
        try {
            KeyGenerator kg = KeyGenerator.getInstance(
                KeyProperties.KEY_ALGORITHM_AES, ""AndroidKeyStore"");
            KeyGenParameterSpec.Builder builder =
                    new KeyGenParameterSpec.Builder(
                        alias,
                        KeyProperties.PURPOSE_ENCRYPT| KeyProperties.PURPOSE_DECRYPT)
                            .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
                            .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
                            .setUserAuthenticationRequired(true)
                            .setUserAuthenticationValidityDurationSeconds(timeoutSeconds)
                            .setKeySize(128);
            kg.init(builder.build());
            kg.generateKey();
        } catch (InvalidAlgorithmParameterException
                | NoSuchAlgorithmException
                | NoSuchProviderException e) {
            throw new RuntimeException(""Error creating auth-bound key"", e);
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/identity/src/android/security/identity/cts/UserAuthTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.server.wm.BackgroundActivityLaunchTest"	"testActivityNotBlockedFromBgActivityInFgTask"	"CtsActivityManagerBackgroundActivityTestCases"	"1: apps"	"public void testActivityNotBlockedFromBgActivityInFgTask() {
        // Launch Activity A, B in the same task with different processes.
        final Intent intent = new Intent()
                .setComponent(APP_A_FOREGROUND_ACTIVITY)
                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(intent);
        mWmState.waitForValidState(APP_A_FOREGROUND_ACTIVITY);
        mContext.sendBroadcast(getLaunchActivitiesBroadcast(APP_B_FOREGROUND_ACTIVITY));
        mWmState.waitForValidState(APP_B_FOREGROUND_ACTIVITY);
        assertTaskStack(new ComponentName[]{APP_B_FOREGROUND_ACTIVITY, APP_A_FOREGROUND_ACTIVITY},
                APP_A_FOREGROUND_ACTIVITY);

        // Refresh last-stop-app-switch-time by returning to home and then make the task foreground.
        pressHomeAndResumeAppSwitch();
        mContext.startActivity(intent);
        mWmState.waitForValidState(APP_B_FOREGROUND_ACTIVITY);
        // Though process A is in background, it is in a visible Task (top is B) so it should be
        // able to start activity successfully.
        mContext.sendBroadcast(new Intent(ACTION_LAUNCH_BACKGROUND_ACTIVITIES)
                .putExtra(LAUNCH_INTENTS_EXTRA, new Intent[]{ new Intent()
                        .setComponent(APP_A_BACKGROUND_ACTIVITY)
                        .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) }));
        mWmState.waitForValidState(APP_A_BACKGROUND_ACTIVITY);
        mWmState.assertFocusedActivity(
                ""The background activity must be able to launch from a visible task"",
                APP_A_BACKGROUND_ACTIVITY);
    }"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/backgroundactivity/src/android/server/wm/BackgroundActivityLaunchTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.server.wm.BackgroundActivityLaunchTest"	"testActivityBlockedWhenForegroundActivityRestartsItself"	"CtsActivityManagerBackgroundActivityTestCases"	"1: apps"	"@FlakyTest(bugId = 130800326)
    @Ignore  // TODO(b/145981637): Make this test work
    public void testActivityBlockedWhenForegroundActivityRestartsItself() throws Exception {
        // Start AppA foreground activity
        Intent intent = new Intent();
        intent.setComponent(APP_A_FOREGROUND_ACTIVITY);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        intent.putExtra(RELAUNCH_FOREGROUND_ACTIVITY_EXTRA, true);
        mContext.startActivity(intent);
        boolean result = waitForActivityFocused(APP_A_FOREGROUND_ACTIVITY);
        assertTrue(""Not able to start foreground activity"", result);
        assertTaskStack(new ComponentName[]{APP_A_FOREGROUND_ACTIVITY}, APP_A_FOREGROUND_ACTIVITY);

        // The foreground activity will be paused but will attempt to restart itself in onPause()
        pressHomeAndResumeAppSwitch();

        result = waitForActivityFocused(APP_A_FOREGROUND_ACTIVITY);
        assertFalse(""Previously foreground Activity should not be able to relaunch itself"", result);
        assertTaskStack(new ComponentName[]{APP_A_FOREGROUND_ACTIVITY}, APP_A_FOREGROUND_ACTIVITY);
    }"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/backgroundactivity/src/android/server/wm/BackgroundActivityLaunchTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.server.wm.BackgroundActivityLaunchTest"	"testPipCannotStartAfterHomeButton"	"CtsActivityManagerBackgroundActivityTestCases"	"2: apps system"	"public void testPipCannotStartAfterHomeButton() throws Exception {

        Intent intent = new Intent();
        intent.setComponent(APP_A_PIP_ACTIVITY);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(intent);

        assertTrue(""Pip activity not started"", waitUntilForegroundChanged(
                TEST_PACKAGE_APP_A, true, ACTIVITY_START_TIMEOUT_MS));

        // Click home button, and test app activity onPause() will trigger pip window,
        // test will will try to start background activity, but we expect the background activity
        // will be blocked even the app has a visible pip window, as we do not allow background
        // activity to be started after pressing home button.
        pressHomeAndWaitHomeResumed();

        assertActivityNotResumed();
    }

    private void pressHomeAndWaitHomeResumed() {
        pressHomeButton();
        mWmState.waitForHomeActivityVisible();
    }

    private boolean checkPackageResumed(String pkg) {
        WindowManagerStateHelper helper = new WindowManagerStateHelper();
        helper.computeState();
        return ComponentName.unflattenFromString(
                helper.getFocusedActivity()).getPackageName().equals(pkg);
    }

    // Return true if the state of the package is changed to target state.
    private boolean waitUntilForegroundChanged(String targetPkg, boolean toBeResumed, int timeout)
            throws Exception {
        long startTime = System.currentTimeMillis();
        while (checkPackageResumed(targetPkg) != toBeResumed) {
            if (System.currentTimeMillis() - startTime < timeout) {
                Thread.sleep(100);
            } else {
                return false;
            }
        }
        return true;
    }

    private void assertActivityNotResumed() throws Exception {
        assertFalse(""Test activity is resumed"",
                waitUntilForegroundChanged(TEST_PACKAGE_APP_A, true,
                        ACTIVITY_NOT_RESUMED_TIMEOUT_MS));
    }

    private Intent getLaunchActivitiesBroadcast(ComponentName... componentNames) {
        Intent broadcastIntent = new Intent(ACTION_LAUNCH_BACKGROUND_ACTIVITIES);
        Intent[] intents = Stream.of(componentNames)
                .map(c -> {
                    Intent intent = new Intent();
                    intent.setComponent(c);
                    return intent;
                })
                .toArray(Intent[]::new);
        broadcastIntent.putExtra(LAUNCH_INTENTS_EXTRA, intents);
        return broadcastIntent;
    }

    private void pressHomeAndResumeAppSwitch() {
        // Press home key to ensure stopAppSwitches is called because the last-stop-app-switch-time
        // is a criteria of allowing background start.
        pressHomeButton();
        // Resume the stopped state (it won't affect last-stop-app-switch-time) so we don't need to
        // wait extra time to prevent the next launch from being delayed.
        resumeAppSwitches();
        mWmState.waitForHomeActivityVisible();
        // Resuming app switches again after home became visible because the previous call might
        // have raced with pressHomeButton().
        // TODO(b/155454710): Remove previous call after making sure all the tests don't depend on
        // the timing here.
        resumeAppSwitches();
    }

    private void assertTaskStack(ComponentName[] expectedComponents,
            ComponentName sourceComponent) {
        if (expectedComponents == null) {
            assertNull(mWmState.getTaskByActivity(sourceComponent));
            return;
        }
        List<WindowManagerState.Activity> actual = mWmState.getTaskByActivity(
                sourceComponent).mActivities;
        assertEquals(expectedComponents.length, actual.size());
        int size = expectedComponents.length;
        for (int i = 0; i < size; i++) {
            assertEquals(expectedComponents[i].flattenToShortString(), actual.get(i).getName());
        }
    }

    private void assertPendingIntentBroadcastTimeoutTest(int delayMs, boolean expectedResult)
            throws TimeoutException {
        // Start AppB foreground activity
        Intent intent = new Intent();
        intent.setComponent(APP_B_FOREGROUND_ACTIVITY);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(intent);
        boolean result = waitForActivityFocused(APP_B_FOREGROUND_ACTIVITY);
        assertTrue(""Not able to start foreground Activity"", result);
        assertTaskStack(new ComponentName[]{APP_B_FOREGROUND_ACTIVITY}, APP_B_FOREGROUND_ACTIVITY);
        EventReceiver receiver = new EventReceiver(
                Event.APP_A_START_BACKGROUND_ACTIVITY_BROADCAST_RECEIVED);

        // Send pendingIntent from AppA to AppB, and the AppB launch the pending intent to start
        // activity in App A
        sendPendingIntentBroadcast(delayMs, receiver.getNotifier());

        // Waits for final hoop in AppA to start looking for activity
        receiver.waitForEventOrThrow(BROADCAST_DELIVERY_TIMEOUT_MS);
        result = waitForActivityFocused(ACTIVITY_FOCUS_TIMEOUT_MS + delayMs,
                APP_A_BACKGROUND_ACTIVITY);
        assertEquals(expectedResult, result);
        if (expectedResult) {
            assertTaskStack(new ComponentName[]{APP_A_BACKGROUND_ACTIVITY},
                    APP_A_BACKGROUND_ACTIVITY);
        } else {
            assertTaskStack(null, APP_A_BACKGROUND_ACTIVITY);
        }
    }

    private boolean waitForActivityFocused(ComponentName componentName) {
        return waitForActivityFocused(ACTIVITY_FOCUS_TIMEOUT_MS, componentName);
    }

    private void sendPendingIntentActivity() {
        Intent intent = new Intent();
        intent.setComponent(APP_A_SEND_PENDING_INTENT_RECEIVER);
        intent.putExtra(IS_BROADCAST_EXTRA, false);
        mContext.sendBroadcast(intent);
    }

    private void sendPendingIntentBroadcast(int delayMs, @Nullable ResultReceiver eventNotifier) {
        Intent intent = new Intent();
        intent.setComponent(APP_A_SEND_PENDING_INTENT_RECEIVER);
        intent.putExtra(IS_BROADCAST_EXTRA, true);
        if (delayMs > 0) {
            intent.putExtra(START_ACTIVITY_DELAY_MS_EXTRA, delayMs);
        }
        intent.putExtra(EVENT_NOTIFIER_EXTRA, eventNotifier);
        mContext.sendBroadcast(intent);
    }
}"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/backgroundactivity/src/android/server/wm/BackgroundActivityLaunchTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.server.wm.BackgroundActivityLaunchTest"	"testSecondActivityBlockedWhenBackgroundActivityLaunch"	"CtsActivityManagerBackgroundActivityTestCases"	"1: ui"	"@FlakyTest(bugId = 143522449)
    public void testSecondActivityBlockedWhenBackgroundActivityLaunch() throws Exception {
        Intent baseActivityIntent = new Intent();
        baseActivityIntent.setComponent(APP_A_FOREGROUND_ACTIVITY);
        baseActivityIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(baseActivityIntent);
        boolean result = waitForActivityFocused(APP_A_FOREGROUND_ACTIVITY);
        assertTrue(""Not able to start foreground activity"", result);
        assertTaskStack(new ComponentName[]{APP_A_FOREGROUND_ACTIVITY}, APP_A_FOREGROUND_ACTIVITY);
        // We can't resume app switching after pressing home button, otherwise the grace period
        // will allow the starts.
        pressHomeAndWaitHomeResumed();

        // The activity, now in the background, will attempt to start 2 activities in quick
        // succession
        mContext.sendBroadcast(getLaunchActivitiesBroadcast(APP_A_BACKGROUND_ACTIVITY,
                APP_A_SECOND_BACKGROUND_ACTIVITY));

        // There should be 2 activities in the background (not focused) INITIALIZING
        result = waitForActivityFocused(APP_A_BACKGROUND_ACTIVITY);
        assertFalse(""Activity should not have been launched in the foreground"", result);
        result = waitForActivityFocused(APP_A_SECOND_BACKGROUND_ACTIVITY);
        assertFalse(""Second activity should not have been launched in the foreground"", result);
        assertTaskStack(
                new ComponentName[]{APP_A_SECOND_BACKGROUND_ACTIVITY, APP_A_BACKGROUND_ACTIVITY,
                        APP_A_FOREGROUND_ACTIVITY}, APP_A_FOREGROUND_ACTIVITY);
    }"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/backgroundactivity/src/android/server/wm/BackgroundActivityLaunchTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.server.wm.BackgroundActivityLaunchTest"	"testPendingIntentBroadcast_appBIsBackground"	"CtsActivityManagerBackgroundActivityTestCases"	"3: ui system user"	"public void testPendingIntentBroadcast_appBIsBackground() throws Exception {
        EventReceiver receiver = new EventReceiver(
                Event.APP_A_START_BACKGROUND_ACTIVITY_BROADCAST_RECEIVED);

        // Send pendingIntent from AppA to AppB, and the AppB launch the pending intent to start
        // activity in App A
        sendPendingIntentBroadcast(0, receiver.getNotifier());

        // Waits for final hoop in AppA to start looking for activity, otherwise it could succeed
        // if the broadcast took long time to get executed (which may happen after boot).
        receiver.waitForEventOrThrow(BROADCAST_DELIVERY_TIMEOUT_MS);
        boolean result = waitForActivityFocused(APP_A_BACKGROUND_ACTIVITY);
        assertFalse(""Should not able to launch background activity"", result);
        assertTaskStack(null, APP_A_BACKGROUND_ACTIVITY);
    }

    /**
     * Returns a list of alive users on the device
     */
    private List<UserInfo> getAliveUsers() {
        // Setting the CREATE_USERS permission in AndroidManifest.xml has no effect when the test
        // is run through the CTS harness, so instead adopt it as a shell permission. We use
        // the CREATE_USERS permission instead of MANAGE_USERS because the shell can never use
        // MANAGE_USERS.
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        uiAutomation.adoptShellPermissionIdentity(Manifest.permission.CREATE_USERS);
        List<UserInfo> userList = mContext.getSystemService(UserManager.class)
                .getUsers(/* excludePartial= */ true,
                        /* excludeDying= */ true,
                        /* excludePreCreated= */ true);
        uiAutomation.dropShellPermissionIdentity();
        return userList;
    }

    /**
     * Removes the guest user from the device if present
     */
    private void removeGuestUser() {
        List<UserInfo> userList = getAliveUsers();
        for (UserInfo info : userList) {
            if (info.isGuest()) {
                removeUser(info.id);
                // Device is only allowed to have one alive guest user, so stop if it's found
                break;
            }
        }
    }

    /**
     * Removes a user from the device given their ID
     */
    private void removeUser(int userId) {
        executeShellCommand(String.format(""pm remove-user %d"", userId));
    }"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/backgroundactivity/src/android/server/wm/BackgroundActivityLaunchTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.server.wm.BackgroundActivityLaunchTest"	"testStartBgActivity_usingStartActivitiesFromBackgroundPermission"	"CtsActivityManagerBackgroundActivityTestCases"	"1: system"	"public void testStartBgActivity_usingStartActivitiesFromBackgroundPermission()
            throws Exception {
        // Disable SAW app op for shell, since that can also allow starting activities from bg.
        AppOpsUtils.setOpMode(SHELL_PACKAGE, ""android:system_alert_window"", MODE_ERRORED);

        // Launch the activity via a shell command, this way the system doesn't have info on which
        // app launched the activity and thus won't use instrumentation privileges to launch it. But
        // the shell has the START_ACTIVITIES_FROM_BACKGROUND permission, so we expect it to
        // succeed.
        // See testBackgroundActivityBlocked() for a case where an app without the
        // START_ACTIVITIES_FROM_BACKGROUND permission is blocked from launching the activity from
        // the background.
        launchActivity(APP_A_BACKGROUND_ACTIVITY);

        // If the activity launches, it means the START_ACTIVITIES_FROM_BACKGROUND permission works.
        assertEquals(""Launched activity should be at the top"",
                ComponentNameUtils.getActivityName(APP_A_BACKGROUND_ACTIVITY),
                mWmState.getTopActivityName(0));
    }"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/backgroundactivity/src/android/server/wm/BackgroundActivityLaunchTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.server.wm.BackgroundActivityLaunchTest"	"testBackgroundActivityNotBlockedWhenSystemAlertWindowGranted"	"CtsActivityManagerBackgroundActivityTestCases"	"1: system"	"public void testBackgroundActivityNotBlockedWhenSystemAlertWindowGranted() throws Exception {
        // enable appopp for SAW for this test
        AppOpsUtils.setOpMode(APP_A_PACKAGE_NAME, ""android:system_alert_window"", MODE_ALLOWED);
        assertEquals(AppOpsUtils.getOpMode(APP_A_PACKAGE_NAME, ""android:system_alert_window""),
                MODE_ALLOWED);

        // Start AppA background activity successfully as the package has SAW
        Intent intent = new Intent();
        intent.setComponent(APP_A_START_ACTIVITY_RECEIVER);
        mContext.sendBroadcast(intent);
        boolean result = waitForActivityFocused(APP_A_BACKGROUND_ACTIVITY);
        assertTrue(""Not able to start foreground activity"", result);
    }"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/backgroundactivity/src/android/server/wm/BackgroundActivityLaunchTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.server.wm.BackgroundActivityLaunchTest"	"testDeviceOwner"	"CtsActivityManagerBackgroundActivityTestCases"	"2: system user"	"@SystemUserOnly(reason = ""Device owner must be SYSTEM user"")
    public void testDeviceOwner() throws Exception {
        // Send pendingIntent from AppA to AppB, and the AppB launch the pending intent to start
        // activity in App A
        if (!mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_DEVICE_ADMIN)) {
            return;
        }

        // Remove existing guest user. The device may already have a guest present if it is
        // configured with config_guestUserAutoCreated.
        //
        // In production flow the DO can only be created before device provisioning finishes
        // (e.g. during SUW), and we make sure the guest user in only created after the device
        // provision is finished. Ideally this test would use the provisioning flow and Device
        // Owner (DO) creation in a similar manner as that of production flow.
        removeGuestUser();

        String cmdResult = runShellCommand(""dpm set-device-owner --user 0 ""
                + APP_A_SIMPLE_ADMIN_RECEIVER.flattenToString());
        assertThat(cmdResult).contains(""Success"");
        EventReceiver receiver = new EventReceiver(
                Event.APP_A_START_BACKGROUND_ACTIVITY_BROADCAST_RECEIVED);
        Intent intent = new Intent();
        intent.setComponent(APP_A_START_ACTIVITY_RECEIVER);
        intent.putExtra(EVENT_NOTIFIER_EXTRA, receiver.getNotifier());

        mContext.sendBroadcast(intent);

        // Waits for final hoop in AppA to start looking for activity
        receiver.waitForEventOrThrow(BROADCAST_DELIVERY_TIMEOUT_MS);
        boolean result = waitForActivityFocused(APP_A_BACKGROUND_ACTIVITY);
        assertTrue(""Not able to launch background activity"", result);
        assertTaskStack(new ComponentName[]{APP_A_BACKGROUND_ACTIVITY}, APP_A_BACKGROUND_ACTIVITY);
    }"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/backgroundactivity/src/android/server/wm/BackgroundActivityLaunchTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.server.wm.BackgroundActivityLaunchTest"	"testAppCannotStartBgActivityAfterHomeButton"	"CtsActivityManagerBackgroundActivityTestCases"	"1: system"	"public void testAppCannotStartBgActivityAfterHomeButton() throws Exception {

        Intent intent = new Intent();
        intent.setComponent(APP_A_RELAUNCHING_ACTIVITY);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(intent);

        assertTrue(""Main activity not started"", waitUntilForegroundChanged(
                TEST_PACKAGE_APP_A, true, ACTIVITY_START_TIMEOUT_MS));

        // Click home button, and test app activity onPause() will try to start a background
        // activity, but we expect this will be blocked BAL logic in system, as app cannot start
        // any background activity even within grace period after pressing home button.
        pressHomeAndWaitHomeResumed();

        assertActivityNotResumed();
    }

    // Check picture-in-picture(PIP) won't allow to start BAL after pressing home."	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/backgroundactivity/src/android/server/wm/BackgroundActivityLaunchTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.keystore.cts.KeyFactoryTest"	"testGetKeySpecWithKeystorePrivateKeyAndKeyInfoReflectsAllAuthorizations"	"CtsKeystoreTestCases"	"3: ui system user"	"public void testGetKeySpecWithKeystorePrivateKeyAndKeyInfoReflectsAllAuthorizations()
            throws Exception {
        Date keyValidityStart = new Date(System.currentTimeMillis() - TestUtils.DAY_IN_MILLIS);
        Date keyValidityForOriginationEnd =
                new Date(System.currentTimeMillis() + TestUtils.DAY_IN_MILLIS);
        Date keyValidityForConsumptionEnd =
                new Date(System.currentTimeMillis() + 3 * TestUtils.DAY_IN_MILLIS);
        for (String algorithm : EXPECTED_ALGORITHMS) {
            try {
                String[] blockModes = new String[] {KeyProperties.BLOCK_MODE_ECB};
                String[] encryptionPaddings =
                        new String[] {KeyProperties.ENCRYPTION_PADDING_RSA_PKCS1,
                                KeyProperties.ENCRYPTION_PADDING_RSA_OAEP};
                String[] digests = new String[] {KeyProperties.DIGEST_SHA1,
                        KeyProperties.DIGEST_SHA224,
                        KeyProperties.DIGEST_SHA384,
                        KeyProperties.DIGEST_SHA512};
                int purposes = KeyProperties.PURPOSE_DECRYPT | KeyProperties.PURPOSE_SIGN;
                KeyPairGenerator keyGenerator =
                        KeyPairGenerator.getInstance(algorithm, EXPECTED_PROVIDER_NAME);
                keyGenerator.initialize(new KeyGenParameterSpec.Builder(""test1"", purposes)
                        .setBlockModes(blockModes)
                        .setEncryptionPaddings(encryptionPaddings)
                        .setDigests(digests)
                        .setKeyValidityStart(keyValidityStart)
                        .setKeyValidityForOriginationEnd(keyValidityForOriginationEnd)
                        .setKeyValidityForConsumptionEnd(keyValidityForConsumptionEnd)
                        .build());
                KeyPair keyPair = keyGenerator.generateKeyPair();
                KeyFactory keyFactory = getKeyFactory(algorithm);
                KeyInfo keyInfo = keyFactory.getKeySpec(keyPair.getPrivate(), KeyInfo.class);
                assertEquals(""test1"", keyInfo.getKeystoreAlias());
                assertEquals(purposes, keyInfo.getPurposes());
                TestUtils.assertContentsInAnyOrder(
                        Arrays.asList(keyInfo.getBlockModes()), blockModes);

                List<String> actualEncryptionPaddings =
                        new ArrayList<String>(Arrays.asList(keyInfo.getEncryptionPaddings()));
                // Keystore may have added ENCRYPTION_PADDING_NONE to allow software padding.
                actualEncryptionPaddings.remove(KeyProperties.ENCRYPTION_PADDING_NONE);
                TestUtils.assertContentsInAnyOrder(
                        actualEncryptionPaddings, encryptionPaddings);

                List<String> actualDigests =
                        new ArrayList<String>(Arrays.asList(keyInfo.getDigests()));
                // Keystore may have added DIGEST_NONE to allow software digesting.
                actualDigests.remove(KeyProperties.DIGEST_NONE);
                TestUtils.assertContentsInAnyOrder(actualDigests, digests);

                MoreAsserts.assertEmpty(Arrays.asList(keyInfo.getSignaturePaddings()));
                assertEquals(keyValidityStart, keyInfo.getKeyValidityStart());
                assertEquals(keyValidityForOriginationEnd,
                        keyInfo.getKeyValidityForOriginationEnd());
                assertEquals(keyValidityForConsumptionEnd,
                        keyInfo.getKeyValidityForConsumptionEnd());
                assertFalse(keyInfo.isUserAuthenticationRequired());
                assertFalse(keyInfo.isUserAuthenticationRequirementEnforcedBySecureHardware());
            } catch (Throwable e) {
                throw new RuntimeException(""Failed for "" + algorithm, e);
            }
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/KeyFactoryTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.keystore.cts.KeyFactoryTest"	"testGetKeySpecWithKeystorePublicKeyRejectsKeyInfo"	"CtsKeystoreTestCases"	"1: ui"	"public void testGetKeySpecWithKeystorePublicKeyRejectsKeyInfo()
            throws Exception {
        for (String algorithm : EXPECTED_ALGORITHMS) {
            try {
                KeyPairGenerator keyGenerator =
                        KeyPairGenerator.getInstance(algorithm, EXPECTED_PROVIDER_NAME);
                keyGenerator.initialize(new KeyGenParameterSpec.Builder(""test1"", 0).build());
                KeyPair keyPair = keyGenerator.generateKeyPair();
                KeyFactory keyFactory = getKeyFactory(algorithm);
                try {
                    keyFactory.getKeySpec(keyPair.getPublic(), KeyInfo.class);
                    fail();
                } catch (InvalidKeySpecException expected) {}
            } catch (Throwable e) {
                throw new RuntimeException(""Failed for "" + algorithm, e);
            }
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/KeyFactoryTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.keystore.cts.KeyFactoryTest"	"testGetKeySpecWithKeystorePrivateKeyRejectsTransparentKeySpecAndEncodedKeySpec"	"CtsKeystoreTestCases"	"1: ui"	"public void testGetKeySpecWithKeystorePrivateKeyRejectsTransparentKeySpecAndEncodedKeySpec()
            throws Exception {
        for (String algorithm : EXPECTED_ALGORITHMS) {
            try {
                Class<? extends KeySpec> transparentKeySpecClass;
                if (""EC"".equalsIgnoreCase(algorithm)) {
                    transparentKeySpecClass = ECPrivateKeySpec.class;
                } else if (""RSA"".equalsIgnoreCase(algorithm)) {
                    transparentKeySpecClass = RSAPrivateKeySpec.class;
                } else {
                    throw new RuntimeException(""Unsupported key algorithm: "" + algorithm);
                }

                KeyPairGenerator keyGenerator =
                        KeyPairGenerator.getInstance(algorithm, EXPECTED_PROVIDER_NAME);
                keyGenerator.initialize(new KeyGenParameterSpec.Builder(""test1"", 0).build());
                KeyPair keyPair = keyGenerator.generateKeyPair();

                KeyFactory keyFactory = getKeyFactory(algorithm);
                try {
                    keyFactory.getKeySpec(keyPair.getPrivate(), transparentKeySpecClass);
                    fail();
                } catch (InvalidKeySpecException expected) {}

                try {
                    keyFactory.getKeySpec(keyPair.getPrivate(), PKCS8EncodedKeySpec.class);
                    fail();
                } catch (InvalidKeySpecException expected) {}
            } catch (Throwable e) {
                throw new RuntimeException(""Failed for "" + algorithm, e);
            }
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/KeyFactoryTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.keystore.cts.KeyFactoryTest"	"testGetKeySpecWithKeystorePublicKeyAcceptsX509EncodedKeySpec"	"CtsKeystoreTestCases"	"1: ui"	"public void testGetKeySpecWithKeystorePublicKeyAcceptsX509EncodedKeySpec()
            throws Exception {
        for (String algorithm : EXPECTED_ALGORITHMS) {
            try {
                KeyPairGenerator keyGenerator =
                        KeyPairGenerator.getInstance(algorithm, EXPECTED_PROVIDER_NAME);
                keyGenerator.initialize(new KeyGenParameterSpec.Builder(""test1"", 0).build());
                KeyPair keyPair = keyGenerator.generateKeyPair();
                PublicKey publicKey = keyPair.getPublic();

                KeyFactory keyFactory = getKeyFactory(algorithm);
                X509EncodedKeySpec x509EncodedSpec =
                        keyFactory.getKeySpec(publicKey, X509EncodedKeySpec.class);
                MoreAsserts.assertEquals(publicKey.getEncoded(), x509EncodedSpec.getEncoded());
            } catch (Throwable e) {
                throw new RuntimeException(""Failed for "" + algorithm, e);
            }
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/KeyFactoryTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.keystore.cts.KeyFactoryTest"	"testGetKeySpecWithKeystorePublicKeyAcceptsTransparentKeySpec"	"CtsKeystoreTestCases"	"1: ui"	"public void testGetKeySpecWithKeystorePublicKeyAcceptsTransparentKeySpec()
            throws Exception {
        for (String algorithm : EXPECTED_ALGORITHMS) {
            try {
                KeyPairGenerator keyGenerator =
                        KeyPairGenerator.getInstance(algorithm, EXPECTED_PROVIDER_NAME);
                keyGenerator.initialize(new KeyGenParameterSpec.Builder(""test1"", 0).build());
                KeyPair keyPair = keyGenerator.generateKeyPair();
                PublicKey publicKey = keyPair.getPublic();

                KeyFactory keyFactory = getKeyFactory(algorithm);
                if (""EC"".equalsIgnoreCase(algorithm)) {
                    ECPublicKey ecPublicKey = (ECPublicKey) publicKey;
                    ECPublicKeySpec spec =
                            keyFactory.getKeySpec(publicKey, ECPublicKeySpec.class);
                    assertEquals(ecPublicKey.getW(), spec.getW());
                    TestUtils.assertECParameterSpecEqualsIgnoreSeedIfNotPresent(
                            ecPublicKey.getParams(), spec.getParams());
                } else if (""RSA"".equalsIgnoreCase(algorithm)) {
                    RSAPublicKey rsaPublicKey = (RSAPublicKey) publicKey;
                    RSAPublicKeySpec spec =
                            keyFactory.getKeySpec(publicKey, RSAPublicKeySpec.class);
                    assertEquals(rsaPublicKey.getModulus(), spec.getModulus());
                    assertEquals(rsaPublicKey.getPublicExponent(), spec.getPublicExponent());
                } else {
                    throw new RuntimeException(""Unsupported key algorithm: "" + algorithm);
                }
            } catch (Throwable e) {
                throw new RuntimeException(""Failed for "" + algorithm, e);
            }
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/KeyFactoryTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.keystore.cts.KeyFactoryTest"	"testTranslateKeyAcceptsAndroidKeystoreKeys"	"CtsKeystoreTestCases"	"1: ui"	"public void testTranslateKeyAcceptsAndroidKeystoreKeys() throws Exception {
        for (String algorithm : EXPECTED_ALGORITHMS) {
            try {
                KeyPairGenerator keyGenerator =
                        KeyPairGenerator.getInstance(algorithm, EXPECTED_PROVIDER_NAME);
                keyGenerator.initialize(new KeyGenParameterSpec.Builder(""test1"", 0).build());
                KeyPair keyPair = keyGenerator.generateKeyPair();

                KeyFactory keyFactory = getKeyFactory(algorithm);
                assertSame(keyPair.getPrivate(), keyFactory.translateKey(keyPair.getPrivate()));
                assertSame(keyPair.getPublic(), keyFactory.translateKey(keyPair.getPublic()));
            } catch (Throwable e) {
                throw new RuntimeException(""Failed for "" + algorithm, e);
            }
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/KeyFactoryTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.keystore.cts.KeyFactoryTest"	"testGeneratePrivateAndPublicRejectKeyInfo"	"CtsKeystoreTestCases"	"1: ui"	"public void testGeneratePrivateAndPublicRejectKeyInfo() throws Exception {
        for (String algorithm : EXPECTED_ALGORITHMS) {
            try {
                KeyPairGenerator keyGenerator =
                        KeyPairGenerator.getInstance(algorithm, EXPECTED_PROVIDER_NAME);
                keyGenerator.initialize(new KeyGenParameterSpec.Builder(""test1"", 0).build());
                KeyPair keyPair = keyGenerator.generateKeyPair();
                KeyInfo keyInfo = TestUtils.getKeyInfo(keyPair.getPrivate());

                KeyFactory keyFactory = getKeyFactory(algorithm);
                try {
                    keyFactory.generatePrivate(keyInfo);
                    fail();
                } catch (InvalidKeySpecException expected) {}

                try {
                    keyFactory.generatePublic(keyInfo);
                    fail();
                } catch (InvalidKeySpecException expected) {}
            } catch (Throwable e) {
                throw new RuntimeException(""Failed for "" + algorithm, e);
            }
        }
    }

    private KeyFactory getKeyFactory(String algorithm) throws NoSuchAlgorithmException,
            NoSuchProviderException {
        return KeyFactory.getInstance(algorithm, EXPECTED_PROVIDER_NAME);
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/KeyFactoryTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.os.cts.ActivityTestsBase"	"isPerformanceOnly"	""	"1: system"	"public void test/*
 *.
 */

package android.os.cts;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.test.AndroidTestCase;
import android.test.PerformanceTestCase;

public class ActivityTestsBase extends AndroidTestCase implements PerformanceTestCase,
        LaunchpadActivity.CallingTest {
    public static final String PERMISSION_GRANTED = ""android.os.cts.permission.TEST_GRANTED"";
    public static final String PERMISSION_DENIED = ""android.os.cts.permission.TEST_DENIED"";

    private static final int TIMEOUT_MS = 60 * 1000;

    protected Intent mIntent;

    private PerformanceTestCase.Intermediates mIntermediates;
    private String mExpecting;

    // Synchronization of activity result.
    private boolean mFinished;
    private int mResultCode = 0;
    private Intent mData;
    private RuntimeException mResultStack = null;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        mIntent = new Intent(mContext, LaunchpadActivity.class);
        mIntermediates = null;
    }

    @Override
    protected void tearDown() throws Exception {
        mIntermediates = null;
        super.tearDown();
    }

    public boolean isPerformanceOnly() {
        return false;
    }

    public void setInternalIterations(int count) {
    }

    public void startTiming(boolean realTime) {
        if (mIntermediates != null) {
            mIntermediates.startTiming(realTime);
        }
    }

    public void addIntermediate(String name) {
        if (mIntermediates != null) {
            mIntermediates.addIntermediate(name);
        }
    }

    public void addIntermediate(String name, long timeInNS) {
        if (mIntermediates != null) {
            mIntermediates.addIntermediate(name, timeInNS);
        }
    }

    public void finishTiming(boolean realTime) {
        if (mIntermediates != null) {
            mIntermediates.finishTiming(realTime);
        }
    }

    public void activityFinished(int resultCode, Intent data, RuntimeException where) {
        finishWithResult(resultCode, data, where);
    }

    public Intent editIntent() {
        return mIntent;
    }

    @Override
    public Context getContext() {
        return mContext;
    }

    public int startPerformance(Intermediates intermediates) {
        mIntermediates = intermediates;
        return 1;
    }

    public void finishGood() {
        finishWithResult(Activity.RESULT_OK, null);
    }

    public void finishBad(String error) {
        finishWithResult(Activity.RESULT_CANCELED, new Intent().setAction(error));
    }

    public void finishWithResult(int resultCode, Intent data) {
        final RuntimeException where = new RuntimeException(""Original error was here"");
        where.fillInStackTrace();
        finishWithResult(resultCode, data, where);
    }

    public void finishWithResult(int resultCode, Intent data, RuntimeException where) {
        synchronized (this) {
            mResultCode = resultCode;
            mData = data;
            mResultStack = where;
            mFinished = true;
            notifyAll();
        }
    }

    public int runLaunchpad(String action) {
        startLaunchpadActivity(action);
        return waitForResultOrThrow(TIMEOUT_MS);
    }

    private void startLaunchpadActivity(String action) {
        LaunchpadActivity.setCallingTest(this);

        synchronized (this) {
            mIntent.setAction(action);
            mFinished = false;
            mIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            mContext.startActivity(mIntent);
        }
    }

    public int waitForResultOrThrow(int timeoutMs) {
        return waitForResultOrThrow(timeoutMs, null);
    }

    public int waitForResultOrThrow(int timeoutMs, String expected) {
        final int res = waitForResult(timeoutMs, expected);

        if (res == Activity.RESULT_CANCELED) {
            if (mResultStack != null) {
                throw new RuntimeException(mData != null ? mData.toString() : ""Unable to launch"",
                        mResultStack);
            } else {
                throw new RuntimeException(mData != null ? mData.toString() : ""Unable to launch"");
            }
        }
        return res;
    }

    public int waitForResult(int timeoutMs, String expected) {
        mExpecting = expected;

        final long endTime = System.currentTimeMillis() + timeoutMs;

        boolean timeout = false;
        synchronized (this) {
            while (!mFinished) {
                final long delay = endTime - System.currentTimeMillis();
                if (delay < 0) {
                    timeout = true;
                    break;
                }

                try {
                    wait(delay);
                } catch (final java.lang.InterruptedException e) {
                    // do nothing
                }
            }
        }

        mFinished = false;

        if (timeout) {
            mResultCode = Activity.RESULT_CANCELED;
            onTimeout();
        }
        return mResultCode;
    }


    public int getResultCode() {
        return mResultCode;
    }

    public Intent getResultData() {
        return mData;
    }

    public RuntimeException getResultStack() {
        return mResultStack;
    }

    public void onTimeout() {
        final String msg = mExpecting == null ? ""Timeout"" : ""Timeout while expecting "" + mExpecting;
        finishWithResult(Activity.RESULT_CANCELED, new Intent().setAction(msg));
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/os/src/android/os/cts/ActivityTestsBase.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.location.cts.gnss.asn1.supl2.ver2_ulp_components.SupportedNetworkInformation"	"isTagImplicit"	"CtsLocationGnssTestCases"	"1: ui"	"public void test/*
 *.
 */

package android.location.cts.asn1.supl2.ver2_ulp_components;

/*
 */


//
//
import android.location.cts.asn1.base.Asn1Boolean;
import android.location.cts.asn1.base.Asn1Null;
import android.location.cts.asn1.base.Asn1Object;
import android.location.cts.asn1.base.Asn1Sequence;
import android.location.cts.asn1.base.Asn1Tag;
import android.location.cts.asn1.base.BitStream;
import android.location.cts.asn1.base.BitStreamReader;
import android.location.cts.asn1.base.SequenceComponent;
import com.google.common.collect.ImmutableList;
import java.util.Collection;
import javax.annotation.Nullable;


/**
*/
public  class SupportedNetworkInformation extends Asn1Sequence {
  //

  private static final Asn1Tag TAG_SupportedNetworkInformation
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public SupportedNetworkInformation() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_SupportedNetworkInformation;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_SupportedNetworkInformation != null) {
      return ImmutableList.of(TAG_SupportedNetworkInformation);
    } else {
      return Asn1Sequence.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new SupportedNetworkInformation from encoded stream.
   */
  public static SupportedNetworkInformation fromPerUnaligned(byte[] encodedBytes) {
    SupportedNetworkInformation result = new SupportedNetworkInformation();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new SupportedNetworkInformation from encoded stream.
   */
  public static SupportedNetworkInformation fromPerAligned(byte[] encodedBytes) {
    SupportedNetworkInformation result = new SupportedNetworkInformation();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }



  @Override protected boolean isExtensible() {
    return true;
  }

  @Override public boolean containsExtensionValues() {
    for (SequenceComponent extensionComponent : getExtensionComponents()) {
      if (extensionComponent.isExplicitlySet()) return true;
    }
    return false;
  }

  
  private SupportedNetworkInformation.wLANType wLAN_;
  public SupportedNetworkInformation.wLANType getWLAN() {
    return wLAN_;
  }
  /**
   * @throws ClassCastException if value is not a SupportedNetworkInformation.wLANType
   */
  public void setWLAN(Asn1Object value) {
    this.wLAN_ = (SupportedNetworkInformation.wLANType) value;
  }
  public SupportedNetworkInformation.wLANType setWLANToNewInstance() {
    wLAN_ = new SupportedNetworkInformation.wLANType();
    return wLAN_;
  }
  
  private SupportedWLANInfo supportedWLANInfo_;
  public SupportedWLANInfo getSupportedWLANInfo() {
    return supportedWLANInfo_;
  }
  /**
   * @throws ClassCastException if value is not a SupportedWLANInfo
   */
  public void setSupportedWLANInfo(Asn1Object value) {
    this.supportedWLANInfo_ = (SupportedWLANInfo) value;
  }
  public SupportedWLANInfo setSupportedWLANInfoToNewInstance() {
    supportedWLANInfo_ = new SupportedWLANInfo();
    return supportedWLANInfo_;
  }
  
  private SupportedWLANApsList supportedWLANApsList_;
  public SupportedWLANApsList getSupportedWLANApsList() {
    return supportedWLANApsList_;
  }
  /**
   * @throws ClassCastException if value is not a SupportedWLANApsList
   */
  public void setSupportedWLANApsList(Asn1Object value) {
    this.supportedWLANApsList_ = (SupportedWLANApsList) value;
  }
  public SupportedWLANApsList setSupportedWLANApsListToNewInstance() {
    supportedWLANApsList_ = new SupportedWLANApsList();
    return supportedWLANApsList_;
  }
  
  private SupportedNetworkInformation.gSMType gSM_;
  public SupportedNetworkInformation.gSMType getGSM() {
    return gSM_;
  }
  /**
   * @throws ClassCastException if value is not a SupportedNetworkInformation.gSMType
   */
  public void setGSM(Asn1Object value) {
    this.gSM_ = (SupportedNetworkInformation.gSMType) value;
  }
  public SupportedNetworkInformation.gSMType setGSMToNewInstance() {
    gSM_ = new SupportedNetworkInformation.gSMType();
    return gSM_;
  }
  
  private SupportedNetworkInformation.wCDMAType wCDMA_;
  public SupportedNetworkInformation.wCDMAType getWCDMA() {
    return wCDMA_;
  }
  /**
   * @throws ClassCastException if value is not a SupportedNetworkInformation.wCDMAType
   */
  public void setWCDMA(Asn1Object value) {
    this.wCDMA_ = (SupportedNetworkInformation.wCDMAType) value;
  }
  public SupportedNetworkInformation.wCDMAType setWCDMAToNewInstance() {
    wCDMA_ = new SupportedNetworkInformation.wCDMAType();
    return wCDMA_;
  }
  
  private SupportedWCDMAInfo supportedWCDMAInfo_;
  public SupportedWCDMAInfo getSupportedWCDMAInfo() {
    return supportedWCDMAInfo_;
  }
  /**
   * @throws ClassCastException if value is not a SupportedWCDMAInfo
   */
  public void setSupportedWCDMAInfo(Asn1Object value) {
    this.supportedWCDMAInfo_ = (SupportedWCDMAInfo) value;
  }
  public SupportedWCDMAInfo setSupportedWCDMAInfoToNewInstance() {
    supportedWCDMAInfo_ = new SupportedWCDMAInfo();
    return supportedWCDMAInfo_;
  }
  
  private SupportedNetworkInformation.cDMAType cDMA_;
  public SupportedNetworkInformation.cDMAType getCDMA() {
    return cDMA_;
  }
  /**
   * @throws ClassCastException if value is not a SupportedNetworkInformation.cDMAType
   */
  public void setCDMA(Asn1Object value) {
    this.cDMA_ = (SupportedNetworkInformation.cDMAType) value;
  }
  public SupportedNetworkInformation.cDMAType setCDMAToNewInstance() {
    cDMA_ = new SupportedNetworkInformation.cDMAType();
    return cDMA_;
  }
  
  private SupportedNetworkInformation.hRDPType hRDP_;
  public SupportedNetworkInformation.hRDPType getHRDP() {
    return hRDP_;
  }
  /**
   * @throws ClassCastException if value is not a SupportedNetworkInformation.hRDPType
   */
  public void setHRDP(Asn1Object value) {
    this.hRDP_ = (SupportedNetworkInformation.hRDPType) value;
  }
  public SupportedNetworkInformation.hRDPType setHRDPToNewInstance() {
    hRDP_ = new SupportedNetworkInformation.hRDPType();
    return hRDP_;
  }
  
  private SupportedNetworkInformation.uMBType uMB_;
  public SupportedNetworkInformation.uMBType getUMB() {
    return uMB_;
  }
  /**
   * @throws ClassCastException if value is not a SupportedNetworkInformation.uMBType
   */
  public void setUMB(Asn1Object value) {
    this.uMB_ = (SupportedNetworkInformation.uMBType) value;
  }
  public SupportedNetworkInformation.uMBType setUMBToNewInstance() {
    uMB_ = new SupportedNetworkInformation.uMBType();
    return uMB_;
  }
  
  private SupportedNetworkInformation.lTEType lTE_;
  public SupportedNetworkInformation.lTEType getLTE() {
    return lTE_;
  }
  /**
   * @throws ClassCastException if value is not a SupportedNetworkInformation.lTEType
   */
  public void setLTE(Asn1Object value) {
    this.lTE_ = (SupportedNetworkInformation.lTEType) value;
  }
  public SupportedNetworkInformation.lTEType setLTEToNewInstance() {
    lTE_ = new SupportedNetworkInformation.lTEType();
    return lTE_;
  }
  
  private SupportedNetworkInformation.wIMAXType wIMAX_;
  public SupportedNetworkInformation.wIMAXType getWIMAX() {
    return wIMAX_;
  }
  /**
   * @throws ClassCastException if value is not a SupportedNetworkInformation.wIMAXType
   */
  public void setWIMAX(Asn1Object value) {
    this.wIMAX_ = (SupportedNetworkInformation.wIMAXType) value;
  }
  public SupportedNetworkInformation.wIMAXType setWIMAXToNewInstance() {
    wIMAX_ = new SupportedNetworkInformation.wIMAXType();
    return wIMAX_;
  }
  
  private SupportedNetworkInformation.historicType historic_;
  public SupportedNetworkInformation.historicType getHistoric() {
    return historic_;
  }
  /**
   * @throws ClassCastException if value is not a SupportedNetworkInformation.historicType
   */
  public void setHistoric(Asn1Object value) {
    this.historic_ = (SupportedNetworkInformation.historicType) value;
  }
  public SupportedNetworkInformation.historicType setHistoricToNewInstance() {
    historic_ = new SupportedNetworkInformation.historicType();
    return historic_;
  }
  
  private SupportedNetworkInformation.nonServingType nonServing_;
  public SupportedNetworkInformation.nonServingType getNonServing() {
    return nonServing_;
  }
  /**
   * @throws ClassCastException if value is not a SupportedNetworkInformation.nonServingType
   */
  public void setNonServing(Asn1Object value) {
    this.nonServing_ = (SupportedNetworkInformation.nonServingType) value;
  }
  public SupportedNetworkInformation.nonServingType setNonServingToNewInstance() {
    nonServing_ = new SupportedNetworkInformation.nonServingType();
    return nonServing_;
  }
  
  private SupportedNetworkInformation.uTRANGPSReferenceTimeType uTRANGPSReferenceTime_;
  public SupportedNetworkInformation.uTRANGPSReferenceTimeType getUTRANGPSReferenceTime() {
    return uTRANGPSReferenceTime_;
  }
  /**
   * @throws ClassCastException if value is not a SupportedNetworkInformation.uTRANGPSReferenceTimeType
   */
  public void setUTRANGPSReferenceTime(Asn1Object value) {
    this.uTRANGPSReferenceTime_ = (SupportedNetworkInformation.uTRANGPSReferenceTimeType) value;
  }
  public SupportedNetworkInformation.uTRANGPSReferenceTimeType setUTRANGPSReferenceTimeToNewInstance() {
    uTRANGPSReferenceTime_ = new SupportedNetworkInformation.uTRANGPSReferenceTimeType();
    return uTRANGPSReferenceTime_;
  }
  
  private SupportedNetworkInformation.uTRANGANSSReferenceTimeType uTRANGANSSReferenceTime_;
  public SupportedNetworkInformation.uTRANGANSSReferenceTimeType getUTRANGANSSReferenceTime() {
    return uTRANGANSSReferenceTime_;
  }
  /**
   * @throws ClassCastException if value is not a SupportedNetworkInformation.uTRANGANSSReferenceTimeType
   */
  public void setUTRANGANSSReferenceTime(Asn1Object value) {
    this.uTRANGANSSReferenceTime_ = (SupportedNetworkInformation.uTRANGANSSReferenceTimeType) value;
  }
  public SupportedNetworkInformation.uTRANGANSSReferenceTimeType setUTRANGANSSReferenceTimeToNewInstance() {
    uTRANGANSSReferenceTime_ = new SupportedNetworkInformation.uTRANGANSSReferenceTimeType();
    return uTRANGANSSReferenceTime_;
  }
  

  

  

  @Override public Iterable<? extends SequenceComponent> getComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 0);

          @Override public boolean isExplicitlySet() {
            return getWLAN() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getWLAN();
          }

          @Override public void setToNewInstance() {
            setWLANToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SupportedNetworkInformation.wLANType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""wLAN : ""
                    + getWLAN().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 1);

          @Override public boolean isExplicitlySet() {
            return getSupportedWLANInfo() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return true;
          }

          @Override public Asn1Object getComponentValue() {
            return getSupportedWLANInfo();
          }

          @Override public void setToNewInstance() {
            setSupportedWLANInfoToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SupportedWLANInfo.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""supportedWLANInfo : ""
                    + getSupportedWLANInfo().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 2);

          @Override public boolean isExplicitlySet() {
            return getSupportedWLANApsList() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return true;
          }

          @Override public Asn1Object getComponentValue() {
            return getSupportedWLANApsList();
          }

          @Override public void setToNewInstance() {
            setSupportedWLANApsListToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SupportedWLANApsList.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""supportedWLANApsList : ""
                    + getSupportedWLANApsList().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 3);

          @Override public boolean isExplicitlySet() {
            return getGSM() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getGSM();
          }

          @Override public void setToNewInstance() {
            setGSMToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SupportedNetworkInformation.gSMType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""gSM : ""
                    + getGSM().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 4);

          @Override public boolean isExplicitlySet() {
            return getWCDMA() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getWCDMA();
          }

          @Override public void setToNewInstance() {
            setWCDMAToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SupportedNetworkInformation.wCDMAType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""wCDMA : ""
                    + getWCDMA().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 5);

          @Override public boolean isExplicitlySet() {
            return getSupportedWCDMAInfo() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return true;
          }

          @Override public Asn1Object getComponentValue() {
            return getSupportedWCDMAInfo();
          }

          @Override public void setToNewInstance() {
            setSupportedWCDMAInfoToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SupportedWCDMAInfo.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""supportedWCDMAInfo : ""
                    + getSupportedWCDMAInfo().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 6);

          @Override public boolean isExplicitlySet() {
            return getCDMA() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getCDMA();
          }

          @Override public void setToNewInstance() {
            setCDMAToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SupportedNetworkInformation.cDMAType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""cDMA : ""
                    + getCDMA().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 7);

          @Override public boolean isExplicitlySet() {
            return getHRDP() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getHRDP();
          }

          @Override public void setToNewInstance() {
            setHRDPToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SupportedNetworkInformation.hRDPType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""hRDP : ""
                    + getHRDP().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 8);

          @Override public boolean isExplicitlySet() {
            return getUMB() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getUMB();
          }

          @Override public void setToNewInstance() {
            setUMBToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SupportedNetworkInformation.uMBType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""uMB : ""
                    + getUMB().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 9);

          @Override public boolean isExplicitlySet() {
            return getLTE() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getLTE();
          }

          @Override public void setToNewInstance() {
            setLTEToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SupportedNetworkInformation.lTEType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""lTE : ""
                    + getLTE().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 10);

          @Override public boolean isExplicitlySet() {
            return getWIMAX() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getWIMAX();
          }

          @Override public void setToNewInstance() {
            setWIMAXToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SupportedNetworkInformation.wIMAXType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""wIMAX : ""
                    + getWIMAX().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 11);

          @Override public boolean isExplicitlySet() {
            return getHistoric() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getHistoric();
          }

          @Override public void setToNewInstance() {
            setHistoricToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SupportedNetworkInformation.historicType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""historic : ""
                    + getHistoric().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 12);

          @Override public boolean isExplicitlySet() {
            return getNonServing() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getNonServing();
          }

          @Override public void setToNewInstance() {
            setNonServingToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SupportedNetworkInformation.nonServingType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""nonServing : ""
                    + getNonServing().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 13);

          @Override public boolean isExplicitlySet() {
            return getUTRANGPSReferenceTime() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getUTRANGPSReferenceTime();
          }

          @Override public void setToNewInstance() {
            setUTRANGPSReferenceTimeToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SupportedNetworkInformation.uTRANGPSReferenceTimeType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""uTRANGPSReferenceTime : ""
                    + getUTRANGPSReferenceTime().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 14);

          @Override public boolean isExplicitlySet() {
            return getUTRANGANSSReferenceTime() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getUTRANGANSSReferenceTime();
          }

          @Override public void setToNewInstance() {
            setUTRANGANSSReferenceTimeToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SupportedNetworkInformation.uTRANGANSSReferenceTimeType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""uTRANGANSSReferenceTime : ""
                    + getUTRANGANSSReferenceTime().toIndentedString(indent);
              }
        });
    
    return builder.build();
  }

  @Override public Iterable<? extends SequenceComponent>
                                                    getExtensionComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
      
      return builder.build();
    }

  
/*
 */


//

/**
 */
public static class wLANType extends Asn1Boolean {
  //

  private static final Asn1Tag TAG_wLANType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public wLANType() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_wLANType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_wLANType != null) {
      return ImmutableList.of(TAG_wLANType);
    } else {
      return Asn1Boolean.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new wLANType from encoded stream.
   */
  public static wLANType fromPerUnaligned(byte[] encodedBytes) {
    wLANType result = new wLANType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new wLANType from encoded stream.
   */
  public static wLANType fromPerAligned(byte[] encodedBytes) {
    wLANType result = new wLANType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""wLANType = "" + getValue() + "";\n"";
  }
}

  
  
  
  
  
/*
 */


//

/**
 */
public static class gSMType extends Asn1Boolean {
  //

  private static final Asn1Tag TAG_gSMType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public gSMType() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_gSMType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_gSMType != null) {
      return ImmutableList.of(TAG_gSMType);
    } else {
      return Asn1Boolean.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new gSMType from encoded stream.
   */
  public static gSMType fromPerUnaligned(byte[] encodedBytes) {
    gSMType result = new gSMType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new gSMType from encoded stream.
   */
  public static gSMType fromPerAligned(byte[] encodedBytes) {
    gSMType result = new gSMType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""gSMType = "" + getValue() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class wCDMAType extends Asn1Boolean {
  //

  private static final Asn1Tag TAG_wCDMAType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public wCDMAType() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_wCDMAType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_wCDMAType != null) {
      return ImmutableList.of(TAG_wCDMAType);
    } else {
      return Asn1Boolean.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new wCDMAType from encoded stream.
   */
  public static wCDMAType fromPerUnaligned(byte[] encodedBytes) {
    wCDMAType result = new wCDMAType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new wCDMAType from encoded stream.
   */
  public static wCDMAType fromPerAligned(byte[] encodedBytes) {
    wCDMAType result = new wCDMAType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""wCDMAType = "" + getValue() + "";\n"";
  }
}

  
  
  
/*
 */


//

/**
 */
public static class cDMAType extends Asn1Boolean {
  //

  private static final Asn1Tag TAG_cDMAType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public cDMAType() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_cDMAType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_cDMAType != null) {
      return ImmutableList.of(TAG_cDMAType);
    } else {
      return Asn1Boolean.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new cDMAType from encoded stream.
   */
  public static cDMAType fromPerUnaligned(byte[] encodedBytes) {
    cDMAType result = new cDMAType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new cDMAType from encoded stream.
   */
  public static cDMAType fromPerAligned(byte[] encodedBytes) {
    cDMAType result = new cDMAType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""cDMAType = "" + getValue() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class hRDPType extends Asn1Boolean {
  //

  private static final Asn1Tag TAG_hRDPType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public hRDPType() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_hRDPType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_hRDPType != null) {
      return ImmutableList.of(TAG_hRDPType);
    } else {
      return Asn1Boolean.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new hRDPType from encoded stream.
   */
  public static hRDPType fromPerUnaligned(byte[] encodedBytes) {
    hRDPType result = new hRDPType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new hRDPType from encoded stream.
   */
  public static hRDPType fromPerAligned(byte[] encodedBytes) {
    hRDPType result = new hRDPType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""hRDPType = "" + getValue() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class uMBType extends Asn1Boolean {
  //

  private static final Asn1Tag TAG_uMBType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public uMBType() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_uMBType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_uMBType != null) {
      return ImmutableList.of(TAG_uMBType);
    } else {
      return Asn1Boolean.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new uMBType from encoded stream.
   */
  public static uMBType fromPerUnaligned(byte[] encodedBytes) {
    uMBType result = new uMBType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new uMBType from encoded stream.
   */
  public static uMBType fromPerAligned(byte[] encodedBytes) {
    uMBType result = new uMBType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""uMBType = "" + getValue() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class lTEType extends Asn1Boolean {
  //

  private static final Asn1Tag TAG_lTEType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public lTEType() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_lTEType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_lTEType != null) {
      return ImmutableList.of(TAG_lTEType);
    } else {
      return Asn1Boolean.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new lTEType from encoded stream.
   */
  public static lTEType fromPerUnaligned(byte[] encodedBytes) {
    lTEType result = new lTEType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new lTEType from encoded stream.
   */
  public static lTEType fromPerAligned(byte[] encodedBytes) {
    lTEType result = new lTEType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""lTEType = "" + getValue() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class wIMAXType extends Asn1Boolean {
  //

  private static final Asn1Tag TAG_wIMAXType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public wIMAXType() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_wIMAXType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_wIMAXType != null) {
      return ImmutableList.of(TAG_wIMAXType);
    } else {
      return Asn1Boolean.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new wIMAXType from encoded stream.
   */
  public static wIMAXType fromPerUnaligned(byte[] encodedBytes) {
    wIMAXType result = new wIMAXType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new wIMAXType from encoded stream.
   */
  public static wIMAXType fromPerAligned(byte[] encodedBytes) {
    wIMAXType result = new wIMAXType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""wIMAXType = "" + getValue() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class historicType extends Asn1Boolean {
  //

  private static final Asn1Tag TAG_historicType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public historicType() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_historicType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_historicType != null) {
      return ImmutableList.of(TAG_historicType);
    } else {
      return Asn1Boolean.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new historicType from encoded stream.
   */
  public static historicType fromPerUnaligned(byte[] encodedBytes) {
    historicType result = new historicType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new historicType from encoded stream.
   */
  public static historicType fromPerAligned(byte[] encodedBytes) {
    historicType result = new historicType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""historicType = "" + getValue() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class nonServingType extends Asn1Boolean {
  //

  private static final Asn1Tag TAG_nonServingType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public nonServingType() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_nonServingType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_nonServingType != null) {
      return ImmutableList.of(TAG_nonServingType);
    } else {
      return Asn1Boolean.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new nonServingType from encoded stream.
   */
  public static nonServingType fromPerUnaligned(byte[] encodedBytes) {
    nonServingType result = new nonServingType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new nonServingType from encoded stream.
   */
  public static nonServingType fromPerAligned(byte[] encodedBytes) {
    nonServingType result = new nonServingType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""nonServingType = "" + getValue() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class uTRANGPSReferenceTimeType extends Asn1Boolean {
  //

  private static final Asn1Tag TAG_uTRANGPSReferenceTimeType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public uTRANGPSReferenceTimeType() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_uTRANGPSReferenceTimeType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_uTRANGPSReferenceTimeType != null) {
      return ImmutableList.of(TAG_uTRANGPSReferenceTimeType);
    } else {
      return Asn1Boolean.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new uTRANGPSReferenceTimeType from encoded stream.
   */
  public static uTRANGPSReferenceTimeType fromPerUnaligned(byte[] encodedBytes) {
    uTRANGPSReferenceTimeType result = new uTRANGPSReferenceTimeType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new uTRANGPSReferenceTimeType from encoded stream.
   */
  public static uTRANGPSReferenceTimeType fromPerAligned(byte[] encodedBytes) {
    uTRANGPSReferenceTimeType result = new uTRANGPSReferenceTimeType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""uTRANGPSReferenceTimeType = "" + getValue() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class uTRANGANSSReferenceTimeType extends Asn1Boolean {
  //

  private static final Asn1Tag TAG_uTRANGANSSReferenceTimeType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public uTRANGANSSReferenceTimeType() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_uTRANGANSSReferenceTimeType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_uTRANGANSSReferenceTimeType != null) {
      return ImmutableList.of(TAG_uTRANGANSSReferenceTimeType);
    } else {
      return Asn1Boolean.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new uTRANGANSSReferenceTimeType from encoded stream.
   */
  public static uTRANGANSSReferenceTimeType fromPerUnaligned(byte[] encodedBytes) {
    uTRANGANSSReferenceTimeType result = new uTRANGANSSReferenceTimeType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new uTRANGANSSReferenceTimeType from encoded stream.
   */
  public static uTRANGANSSReferenceTimeType fromPerAligned(byte[] encodedBytes) {
    uTRANGANSSReferenceTimeType result = new uTRANGANSSReferenceTimeType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""uTRANGANSSReferenceTimeType = "" + getValue() + "";\n"";
  }
}

  

    

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    StringBuilder builder = new StringBuilder();
    builder.append(""SupportedNetworkInformation = {\n"");
    final String internalIndent = indent + ""  "";
    for (SequenceComponent component : getComponents()) {
      if (component.isExplicitlySet()) {
        builder.append(internalIndent)
            .append(component.toIndentedString(internalIndent));
      }
    }
    if (isExtensible()) {
      builder.append(internalIndent).append(""...\n"");
      for (SequenceComponent component : getExtensionComponents()) {
        if (component.isExplicitlySet()) {
          builder.append(internalIndent)
              .append(component.toIndentedString(internalIndent));
        }
      }
    }
    builder.append(indent).append(""};\n"");
    return builder.toString();
  }
}"	"/home/gpoor/cts-12-source/cts/tests/location/location_gnss/src/android/location/cts/gnss/asn1/supl2/ver2_ulp_components/SupportedNetworkInformation.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.appsecurity.cts.UseProcessTest"	"testInstallUsePackageSuccess_instant"	"CtsAppSecurityHostTestCases"	"1: user"	"@AppModeInstant(reason = ""'instant' portion of the hostside test"")
    public void testInstallUsePackageSuccess_instant() throws Exception {
        testInstallUsePackageSuccess(true);
    }
    private void testInstallUsePackageSuccess(boolean instant) throws Exception {
        new InstallMultiple(instant).addFile(APK_SUCCESS).run();
        assertTrue(getDevice().getInstalledPackageNames().contains(PKG));

        Utils.runDeviceTestsAsCurrentUser(getDevice(), PKG, SUCCESS_UNIT_TEST_CLASS, null);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/UseProcessTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.MediaControllerTest"	"testShow"	"CtsWidgetTestCases"	"1: hide"	"public void testShow() throws Throwable {
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mActivity.getWindow().getDecorView(),
                () -> mMediaController = new MediaController(mActivity, true));
        assertFalse(mMediaController.isShowing());

        final MockMediaPlayerControl mediaPlayerControl = new MockMediaPlayerControl();
        mMediaController.setMediaPlayer(mediaPlayerControl);

        final VideoView videoView =
                (VideoView) mActivity.findViewById(R.id.mediacontroller_videoview);
        mMediaController.setAnchorView(videoView);

        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mActivity.getWindow().getDecorView(),
                mMediaController::show);
        assertTrue(mMediaController.isShowing());

        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mActivity.getWindow().getDecorView(),
                mMediaController::hide);
        assertFalse(mMediaController.isShowing());

        final int timeout = 2000;
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mActivity.getWindow().getDecorView(),
                () -> mMediaController.show(timeout));
        assertTrue(mMediaController.isShowing());

        // isShowing() should return false, but MediaController still shows, this may be a bug.
        PollingCheck.waitFor(500, mMediaController::isShowing);
    }

    private String prepareSampleVideo() {
        final String VIDEO_NAME   = ""testvideo.3gp"";

        try (InputStream source = mActivity.getResources().openRawResource(R.raw.testvideo);
             OutputStream target = mActivity.openFileOutput(VIDEO_NAME, Context.MODE_PRIVATE)) {

            final byte[] buffer = new byte[1024];
            for (int len = source.read(buffer); len > 0; len = source.read(buffer)) {
                target.write(buffer, 0, len);
            }
        } catch (final IOException e) {
            fail(e.getMessage());
        }

        return mActivity.getFileStreamPath(VIDEO_NAME).getAbsolutePath();
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/MediaControllerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.MediaControllerTest"	"testConstructor"	"CtsWidgetTestCases"	"1: ui"	"public void testConstructor() {
        new MediaController(mActivity, null);

        new MediaController(mActivity, true);

        new MediaController(mActivity);

        final XmlPullParser parser =
                mActivity.getResources().getXml(R.layout.mediacontroller_layout);
        final AttributeSet attrs = Xml.asAttributeSet(parser);
        new MediaController(mActivity, attrs);
    }

    /**
     * scenario description:
     * 1. Show the MediaController.
     *
     */
    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/MediaControllerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.MediaControllerTest"	"testOnTrackballEvent"	"CtsWidgetTestCases"	"2: ui system"	"public void testOnTrackballEvent() throws Throwable {
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mActivity.getWindow().getDecorView(),
                () -> mMediaController = new MediaController(mActivity));
        final MockMediaPlayerControl mediaPlayerControl = new MockMediaPlayerControl();
        mMediaController.setMediaPlayer(mediaPlayerControl);

        final VideoView videoView =
                (VideoView) mActivity.findViewById(R.id.mediacontroller_videoview);
        videoView.setMediaController(mMediaController);
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mActivity.getWindow().getDecorView(),
                () -> {
                    videoView.setVideoPath(prepareSampleVideo());
                    videoView.requestFocus();
                });

        final long curTime = System.currentTimeMillis();
        // get the center of the VideoView.
        final int[] xy = new int[2];
        videoView.getLocationOnScreen(xy);

        final int viewWidth = videoView.getWidth();
        final int viewHeight = videoView.getHeight();

        final float x = xy[0] + viewWidth / 2.0f;
        final float y = xy[1] + viewHeight / 2.0f;
        final MotionEvent event = MotionEvent.obtain(curTime, 100,
                MotionEvent.ACTION_DOWN, x, y, 0);
        mInstrumentation.sendTrackballEventSync(event);
        WidgetTestUtils.runOnMainAndDrawSync(mActivityRule, mActivity.getWindow().getDecorView(),
                null);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/MediaControllerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.MediaControllerTest"	"testSetEnabled"	"CtsWidgetTestCases"	"1: ui"	"public void testSetEnabled() {
        final View videoView = mActivity.findViewById(R.id.mediacontroller_videoview);
        final MockMediaPlayerControl mediaPlayerControl = new MockMediaPlayerControl();

        mMediaController = new MediaController(mActivity);
        mMediaController.setAnchorView(videoView);
        mMediaController.setMediaPlayer(mediaPlayerControl);

        final View.OnClickListener mockNextClickListener = mock(View.OnClickListener.class);
        final View.OnClickListener mockPrevClickListener = mock(View.OnClickListener.class);
        mMediaController.setPrevNextListeners(mockNextClickListener, mockPrevClickListener);

        mMediaController.show();

        mMediaController.setEnabled(true);
        assertTrue(mMediaController.isEnabled());

        mMediaController.setEnabled(false);
        assertFalse(mMediaController.isEnabled());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/MediaControllerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.location.cts.gnss.asn1.supl2.rrlp_components.CalcAssistanceBTS"	"CalcAssistanceBTS"	"CtsLocationGnssTestCases"	"1: ui"	"public void test/*
 *.
 */

package android.location.cts.asn1.supl2.rrlp_components;

/*
 */


//
//
import android.location.cts.asn1.base.Asn1Null;
import android.location.cts.asn1.base.Asn1Object;
import android.location.cts.asn1.base.Asn1Sequence;
import android.location.cts.asn1.base.Asn1Tag;
import android.location.cts.asn1.base.BitStream;
import android.location.cts.asn1.base.BitStreamReader;
import android.location.cts.asn1.base.SequenceComponent;
import com.google.common.collect.ImmutableList;
import java.util.Collection;
import javax.annotation.Nullable;


/**
*/
public  class CalcAssistanceBTS extends Asn1Sequence {
  //

  private static final Asn1Tag TAG_CalcAssistanceBTS
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public CalcAssistanceBTS() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_CalcAssistanceBTS;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_CalcAssistanceBTS != null) {
      return ImmutableList.of(TAG_CalcAssistanceBTS);
    } else {
      return Asn1Sequence.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new CalcAssistanceBTS from encoded stream.
   */
  public static CalcAssistanceBTS fromPerUnaligned(byte[] encodedBytes) {
    CalcAssistanceBTS result = new CalcAssistanceBTS();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new CalcAssistanceBTS from encoded stream.
   */
  public static CalcAssistanceBTS fromPerAligned(byte[] encodedBytes) {
    CalcAssistanceBTS result = new CalcAssistanceBTS();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }



  @Override protected boolean isExtensible() {
    return false;
  }

  @Override public boolean containsExtensionValues() {
    for (SequenceComponent extensionComponent : getExtensionComponents()) {
      if (extensionComponent.isExplicitlySet()) return true;
    }
    return false;
  }

  
  private FineRTD fineRTD_;
  public FineRTD getFineRTD() {
    return fineRTD_;
  }
  /**
   * @throws ClassCastException if value is not a FineRTD
   */
  public void setFineRTD(Asn1Object value) {
    this.fineRTD_ = (FineRTD) value;
  }
  public FineRTD setFineRTDToNewInstance() {
    fineRTD_ = new FineRTD();
    return fineRTD_;
  }
  
  private ReferenceWGS84 referenceWGS84_;
  public ReferenceWGS84 getReferenceWGS84() {
    return referenceWGS84_;
  }
  /**
   * @throws ClassCastException if value is not a ReferenceWGS84
   */
  public void setReferenceWGS84(Asn1Object value) {
    this.referenceWGS84_ = (ReferenceWGS84) value;
  }
  public ReferenceWGS84 setReferenceWGS84ToNewInstance() {
    referenceWGS84_ = new ReferenceWGS84();
    return referenceWGS84_;
  }
  

  

  

  @Override public Iterable<? extends SequenceComponent> getComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 0);

          @Override public boolean isExplicitlySet() {
            return getFineRTD() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getFineRTD();
          }

          @Override public void setToNewInstance() {
            setFineRTDToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? FineRTD.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""fineRTD : ""
                    + getFineRTD().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 1);

          @Override public boolean isExplicitlySet() {
            return getReferenceWGS84() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getReferenceWGS84();
          }

          @Override public void setToNewInstance() {
            setReferenceWGS84ToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? ReferenceWGS84.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""referenceWGS84 : ""
                    + getReferenceWGS84().toIndentedString(indent);
              }
        });
    
    return builder.build();
  }

  @Override public Iterable<? extends SequenceComponent>
                                                    getExtensionComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
      
      return builder.build();
    }

  
  
  
  
  

    

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    StringBuilder builder = new StringBuilder();
    builder.append(""CalcAssistanceBTS = {\n"");
    final String internalIndent = indent + ""  "";
    for (SequenceComponent component : getComponents()) {
      if (component.isExplicitlySet()) {
        builder.append(internalIndent)
            .append(component.toIndentedString(internalIndent));
      }
    }
    if (isExtensible()) {
      builder.append(internalIndent).append(""...\n"");
      for (SequenceComponent component : getExtensionComponents()) {
        if (component.isExplicitlySet()) {
          builder.append(internalIndent)
              .append(component.toIndentedString(internalIndent));
        }
      }
    }
    builder.append(indent).append(""};\n"");
    return builder.toString();
  }
}"	"/home/gpoor/cts-12-source/cts/tests/location/location_gnss/src/android/location/cts/gnss/asn1/supl2/rrlp_components/CalcAssistanceBTS.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.view.cts.VelocityTrackerTest"	"testLinearSharpDirectionChange"	"CtsViewTestCases"	"1: direct"	"public void testLinearSharpDirectionChange() {
        // After a sharp change of direction we expect the velocity to eventually
        // converge but it might take a moment to get there.
        mVx = 2.0f;
        mVy = -4.0f;
        move(100, 10);
        assertVelocity(TOLERANCE_TIGHT, ""Expect tight bound for linear motion."");
        mVx = -1.0f;
        mVy = -3.0f;
        move(100, 10);
        assertVelocity(TOLERANCE_WEAK, ""Expect weak bound after 100ms of new direction."");
        move(100, 10);
        assertVelocity(TOLERANCE_TIGHT, ""Expect tight bound after 200ms of new direction."");
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/VelocityTrackerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.view.cts.VelocityTrackerTest"	"testLinearSharpDirectionChangeAfterALongPause"	"CtsViewTestCases"	"1: direct"	"public void testLinearSharpDirectionChangeAfterALongPause() {
        // Should be able to get a tighter bound if there is a pause before the
        // change of direction.
        mVx = 2.0f;
        mVy = -4.0f;
        move(100, 10);
        assertVelocity(TOLERANCE_TIGHT, ""Expect tight bound for linear motion."");
        pause(100);
        mVx = -1.0f;
        mVy = -3.0f;
        move(100, 10);
        assertVelocity(TOLERANCE_TIGHT,
                ""Expect tight bound after a 100ms pause and 100ms of new direction."");
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/VelocityTrackerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.view.cts.VelocityTrackerTest"	"testUsesRawCoordinates"	"CtsViewTestCases"	"1: system"	"public void testUsesRawCoordinates() {
        VelocityTracker vt = VelocityTracker.obtain();
        final int numevents = 5;

        final long downTime = SystemClock.uptimeMillis();
        for (int i = 0; i < numevents; i++) {
            final long eventTime = downTime + i * 10;
            int action = i == 0 ? MotionEvent.ACTION_DOWN : MotionEvent.ACTION_MOVE;
            MotionEvent event = MotionEvent.obtain(downTime, eventTime, action, 0, 0, 0);
            event.offsetLocation(i * 10, i * 10);
            vt.addMovement(event);
        }
        vt.computeCurrentVelocity(1000);
        float xVelocity = vt.getXVelocity();
        float yVelocity = vt.getYVelocity();
        if (xVelocity == 0 || yVelocity == 0) {
            fail(""VelocityTracker is using raw coordinates,""
                    + "" but it should be using adjusted coordinates"");
        }
    }

    private void move(long duration, long step) {
        addMovement();
        while (duration > 0) {
            duration -= step;
            mTime += step;
            mPx += (mAx / 2 * step + mVx) * step;
            mPy += (mAy / 2 * step + mVy) * step;
            mVx += mAx * step;
            mVy += mAy * step;
            addMovement();
        }
    }

    private void pause(long duration) {
        mTime += duration;
    }

    private void addMovement() {
        if (mTime > mLastTime) {
            MotionEvent ev = MotionEvent.obtain(0L, mTime, MotionEvent.ACTION_MOVE, mPx, mPy, 0);
            mVelocityTracker.addMovement(ev);
            ev.recycle();
            mLastTime = mTime;

            mVelocityTracker.computeCurrentVelocity(1);
            final float estimatedVx = mVelocityTracker.getXVelocity();
            final float estimatedVy = mVelocityTracker.getYVelocity();
            Log.d(TAG, String.format(
                    ""[%d] x=%6.1f, y=%6.1f, vx=%6.1f, vy=%6.1f, ax=%6.1f, ay=%6.1f, ""
                    + ""evx=%6.1f (%6.1f%%), evy=%6.1f (%6.1f%%)"",
                    mTime, mPx, mPy, mVx, mVy, mAx, mAy,
                    estimatedVx, error(mVx, estimatedVx) * 100.0f,
                    estimatedVy, error(mVy, estimatedVy) * 100.0f));
        }
    }

    private void assertVelocity(float tolerance, String message) {
        mVelocityTracker.computeCurrentVelocity(1);
        final float estimatedVx = mVelocityTracker.getXVelocity();
        final float estimatedVy = mVelocityTracker.getYVelocity();
        float errorVx = error(mVx, estimatedVx);
        float errorVy = error(mVy, estimatedVy);
        if (errorVx > tolerance || errorVy > tolerance) {
            fail(String.format(""Velocity exceeds tolerance of %6.1f%%: ""
                    + ""expected vx=%6.1f, vy=%6.1f. ""
                    + ""actual vx=%6.1f (%6.1f%%), vy=%6.1f (%6.1f%%). %s"",
                    tolerance * 100.0f, mVx, mVy,
                    estimatedVx, errorVx * 100.0f, estimatedVy, errorVy * 100.0f, message));
        }
    }

    private static float error(float expected, float actual) {
        float absError = Math.abs(actual - expected);
        if (absError < 0.001f) {
            return 0;
        }
        if (Math.abs(expected) < 0.001f) {
            return 1;
        }
        return absError / Math.abs(expected);
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/VelocityTrackerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.hardware.camera2.cts.BurstCaptureTest"	"testYuvBurstWithStillBokeh"	"CtsCameraTestCases"	"2: ui user"	"public void testYuvBurstWithStillBokeh() throws Exception {
        final int YUV_BURST_SIZE = 100;
        testBurst(ImageFormat.YUV_420_888, YUV_BURST_SIZE, true/*checkFrameRate*/,
                true/*testStillBokeh*/);
    }

    private void testBurst(int fmt, int burstSize, boolean checkFrameRate, boolean testStillBokeh)
            throws Exception {
        for (int i = 0; i < mCameraIdsUnderTest.length; i++) {
            try {
                String id = mCameraIdsUnderTest[i];

                StaticMetadata staticInfo = mAllStaticInfo.get(id);
                if (!staticInfo.isColorOutputSupported()) {
                    Log.i(TAG, ""Camera "" + id + "" does not support color outputs, skipping"");
                }
                if (!staticInfo.isAeLockSupported() || !staticInfo.isAwbLockSupported()) {
                    Log.i(TAG, ""AE/AWB lock is not supported in camera "" + id +
                            "". Skip the test"");
                    continue;
                }

                if (staticInfo.isHardwareLevelLegacy()) {
                    Log.i(TAG, ""Legacy camera doesn't report min frame duration"" +
                            "". Skip the test"");
                    continue;
                }

                Capability[] extendedSceneModeCaps =
                        staticInfo.getAvailableExtendedSceneModeCapsChecked();
                boolean supportStillBokeh = false;
                for (Capability cap : extendedSceneModeCaps) {
                    if (cap.getMode() ==
                            CameraMetadata.CONTROL_EXTENDED_SCENE_MODE_BOKEH_STILL_CAPTURE) {
                        supportStillBokeh = true;
                        break;
                    }
                }
                if (testStillBokeh && !supportStillBokeh) {
                    Log.v(TAG, ""Device doesn't support STILL_CAPTURE bokeh. Skip the test"");
                    continue;
                }

                openDevice(id);
                burstTestByCamera(id, fmt, burstSize, checkFrameRate, testStillBokeh);
            } finally {
                closeDevice();
                closeImageReader();
            }
        }
    }

    private void burstTestByCamera(String cameraId, int fmt, int burstSize,
            boolean checkFrameRate, boolean testStillBokeh) throws Exception {
        // Parameters
        final int MAX_CONVERGENCE_FRAMES = 150; // 5 sec at 30fps
        final long MAX_PREVIEW_RESULT_TIMEOUT_MS = 2000;
        final float FRAME_DURATION_MARGIN_FRACTION = 0.1f;

        // Find a good preview size (bound to 1080p)
        final Size previewSize = mOrderedPreviewSizes.get(0);

        // Get maximum size for fmt
        final Size stillSize = getSortedSizesForFormat(
                cameraId, mCameraManager, fmt, /*bound*/null).get(0);

        // Find max pipeline depth and sync latency
        final int maxPipelineDepth = mStaticInfo.getCharacteristics().get(
            CameraCharacteristics.REQUEST_PIPELINE_MAX_DEPTH);
        final int maxSyncLatency = mStaticInfo.getCharacteristics().get(
            CameraCharacteristics.SYNC_MAX_LATENCY);

        // Find minimum frame duration for full-res resolution
        StreamConfigurationMap config = mStaticInfo.getCharacteristics().get(
            CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
        final long minStillFrameDuration =
                config.getOutputMinFrameDuration(fmt, stillSize);


        Range<Integer> targetRange = getSuitableFpsRangeForDuration(cameraId, minStillFrameDuration);

        Log.i(TAG, String.format(""Selected frame rate range %d - %d for YUV burst"",
                        targetRange.getLower(), targetRange.getUpper()));

        // Check if READ_SENSOR_SETTINGS is supported
        final boolean checkSensorSettings = mStaticInfo.isCapabilitySupported(
            CameraCharacteristics.REQUEST_AVAILABLE_CAPABILITIES_READ_SENSOR_SETTINGS);

        // Configure basic preview and burst settings

        CaptureRequest.Builder previewBuilder =
            mCamera.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
        int burstTemplate = (fmt == ImageFormat.JPEG) ?
                CameraDevice.TEMPLATE_STILL_CAPTURE : CameraDevice.TEMPLATE_PREVIEW;
        CaptureRequest.Builder burstBuilder = mCamera.createCaptureRequest(burstTemplate);
        Boolean enableZsl = burstBuilder.get(CaptureRequest.CONTROL_ENABLE_ZSL);
        boolean zslStillEnabled = enableZsl != null && enableZsl &&
                burstTemplate == CameraDevice.TEMPLATE_STILL_CAPTURE;

        previewBuilder.set(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE,
                targetRange);
        burstBuilder.set(CaptureRequest.CONTROL_AE_TARGET_FPS_RANGE,
                targetRange);
        burstBuilder.set(CaptureRequest.CONTROL_AE_LOCK, true);
        burstBuilder.set(CaptureRequest.CONTROL_AWB_LOCK, true);
        if (testStillBokeh) {
            previewBuilder.set(CaptureRequest.CONTROL_EXTENDED_SCENE_MODE,
                    CameraMetadata.CONTROL_EXTENDED_SCENE_MODE_BOKEH_STILL_CAPTURE);
            burstBuilder.set(CaptureRequest.CONTROL_EXTENDED_SCENE_MODE,
                    CameraMetadata.CONTROL_EXTENDED_SCENE_MODE_BOKEH_STILL_CAPTURE);
        }

        // Create session and start up preview

        SimpleCaptureCallback resultListener = new SimpleCaptureCallback();
        SimpleCaptureCallback burstResultListener = new SimpleCaptureCallback();
        ImageDropperListener imageDropper = new ImageDropperListener();

        prepareCaptureAndStartPreview(
            previewBuilder, burstBuilder,
            previewSize, stillSize,
            fmt, resultListener,
            /*maxNumImages*/ 3, imageDropper);

        // Create burst

        List<CaptureRequest> burst = new ArrayList<>();
        for (int i = 0; i < burstSize; i++) {
            burst.add(burstBuilder.build());
        }

        // Converge AE/AWB

        int frameCount = 0;
        while (true) {
            CaptureResult result = resultListener.getCaptureResult(MAX_PREVIEW_RESULT_TIMEOUT_MS);
            int aeState = result.get(CaptureResult.CONTROL_AE_STATE);
            int awbState = result.get(CaptureResult.CONTROL_AWB_STATE);

            if (DEBUG) {
                Log.d(TAG, ""aeState: "" + aeState + "". awbState: "" + awbState);
            }

            if ((aeState == CaptureResult.CONTROL_AE_STATE_CONVERGED ||
                    aeState == CaptureResult.CONTROL_AE_STATE_FLASH_REQUIRED) &&
                    awbState == CaptureResult.CONTROL_AWB_STATE_CONVERGED) {
                break;
            }
            frameCount++;
            assertTrue(String.format(""Cam %s: Can not converge AE and AWB within %d frames"",
                    cameraId, MAX_CONVERGENCE_FRAMES),
                frameCount < MAX_CONVERGENCE_FRAMES);
        }

        // Lock AF if there's a focuser

        if (mStaticInfo.hasFocuser()) {
            previewBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER,
                CaptureRequest.CONTROL_AF_TRIGGER_START);
            mSession.capture(previewBuilder.build(), resultListener, mHandler);
            previewBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER,
                CaptureRequest.CONTROL_AF_TRIGGER_IDLE);

            frameCount = 0;
            while (true) {
                CaptureResult result = resultListener.getCaptureResult(MAX_PREVIEW_RESULT_TIMEOUT_MS);
                int afState = result.get(CaptureResult.CONTROL_AF_STATE);

                if (DEBUG) {
                    Log.d(TAG, ""afState: "" + afState);
                }

                if (afState == CaptureResult.CONTROL_AF_STATE_FOCUSED_LOCKED ||
                    afState == CaptureResult.CONTROL_AF_STATE_NOT_FOCUSED_LOCKED) {
                    break;
                }
                frameCount++;
                assertTrue(String.format(""Cam %s: Cannot lock AF within %d frames"", cameraId,
                        MAX_CONVERGENCE_FRAMES),
                    frameCount < MAX_CONVERGENCE_FRAMES);
            }
        }

        // Lock AE/AWB

        previewBuilder.set(CaptureRequest.CONTROL_AE_LOCK, true);
        previewBuilder.set(CaptureRequest.CONTROL_AWB_LOCK, true);

        CaptureRequest lockedRequest = previewBuilder.build();
        mSession.setRepeatingRequest(lockedRequest, resultListener, mHandler);

        // Wait for first result with locking
        resultListener.drain();
        CaptureResult lockedResult =
                resultListener.getCaptureResultForRequest(lockedRequest, maxPipelineDepth);

        int pipelineDepth = lockedResult.get(CaptureResult.REQUEST_PIPELINE_DEPTH);

        // Then start waiting on results to get the first result that should be synced
        // up, and also fire the burst as soon as possible

        if (maxSyncLatency == CameraCharacteristics.SYNC_MAX_LATENCY_PER_FRAME_CONTROL) {
            // The locked result we have is already synchronized so start the burst
            mSession.captureBurst(burst, burstResultListener, mHandler);
        } else {
            // Need to get a synchronized result, and may need to start burst later to
            // be synchronized correctly

            boolean burstSent = false;

            // Calculate how many requests we need to still send down to camera before we
            // know the settings have settled for the burst

            int numFramesWaited = maxSyncLatency;
            if (numFramesWaited == CameraCharacteristics.SYNC_MAX_LATENCY_UNKNOWN) {
                numFramesWaited = NUM_FRAMES_WAITED_FOR_UNKNOWN_LATENCY;
            }

            int requestsNeededToSync = numFramesWaited - pipelineDepth;
            for (int i = 0; i < numFramesWaited; i++) {
                if (!burstSent && requestsNeededToSync <= 0) {
                    mSession.captureBurst(burst, burstResultListener, mHandler);
                    burstSent = true;
                }
                lockedResult = resultListener.getCaptureResult(MAX_PREVIEW_RESULT_TIMEOUT_MS);
                requestsNeededToSync--;
            }

            assertTrue(""Cam "" + cameraId + "": Burst failed to fire!"", burstSent);
        }

        // Read in locked settings if supported

        long burstExposure = 0;
        long burstFrameDuration = 0;
        int burstSensitivity = 0;
        if (checkSensorSettings) {
            burstExposure = lockedResult.get(CaptureResult.SENSOR_EXPOSURE_TIME);
            burstFrameDuration = lockedResult.get(CaptureResult.SENSOR_FRAME_DURATION);
            burstSensitivity = lockedResult.get(CaptureResult.SENSOR_SENSITIVITY);

            assertTrue(String.format(""Cam %s: Frame duration %d ns too short compared to "" +
                    ""exposure time %d ns"", cameraId, burstFrameDuration, burstExposure),
                burstFrameDuration >= burstExposure);

            assertTrue(String.format(""Cam %s: Exposure time is not valid: %d"",
                    cameraId, burstExposure),
                burstExposure > 0);
            assertTrue(String.format(""Cam %s: Frame duration is not valid: %d"",
                    cameraId, burstFrameDuration),
                burstFrameDuration > 0);
            assertTrue(String.format(""Cam %s: Sensitivity is not valid: %d"",
                    cameraId, burstSensitivity),
                burstSensitivity > 0);
        }

        // Process burst results
        int burstIndex = 0;
        CaptureResult burstResult =
                burstResultListener.getCaptureResult(MAX_PREVIEW_RESULT_TIMEOUT_MS);
        long prevTimestamp = -1;
        final long frameDurationBound = (long)
                (minStillFrameDuration * (1 + FRAME_DURATION_MARGIN_FRACTION) );

        long burstStartTimestamp = burstResult.get(CaptureResult.SENSOR_TIMESTAMP);
        long burstEndTimeStamp = 0;

        List<Long> frameDurations = new ArrayList<>();

        while(true) {
            // Verify the result
            assertTrue(""Cam "" + cameraId + "": Result doesn't match expected request"",
                    burstResult.getRequest() == burst.get(burstIndex));

            // Verify locked settings
            if (checkSensorSettings) {
                long exposure = burstResult.get(CaptureResult.SENSOR_EXPOSURE_TIME);
                int sensitivity = burstResult.get(CaptureResult.SENSOR_SENSITIVITY);
                assertTrue(""Cam "" + cameraId + "": Exposure not locked!"",
                    exposure == burstExposure);
                assertTrue(""Cam "" + cameraId + "": Sensitivity not locked!"",
                    sensitivity == burstSensitivity);
            }

            // Collect inter-frame durations
            long timestamp = burstResult.get(CaptureResult.SENSOR_TIMESTAMP);
            if (prevTimestamp != -1) {
                long frameDuration = timestamp - prevTimestamp;
                frameDurations.add(frameDuration);
                if (DEBUG) {
                    Log.i(TAG, String.format(""Frame %03d    Duration %.2f ms"", burstIndex,
                            frameDuration/1e6));
                }
            }
            prevTimestamp = timestamp;

            // Get next result
            burstIndex++;
            if (burstIndex == burstSize) {
                burstEndTimeStamp = burstResult.get(CaptureResult.SENSOR_TIMESTAMP);
                break;
            }
            burstResult = burstResultListener.getCaptureResult(MAX_PREVIEW_RESULT_TIMEOUT_MS);
        }

        // Verify no preview frames interleaved in burst results
        while (true) {
            CaptureResult previewResult =
                    resultListener.getCaptureResult(MAX_PREVIEW_RESULT_TIMEOUT_MS);
            long previewTimestamp = previewResult.get(CaptureResult.SENSOR_TIMESTAMP);
            if (!zslStillEnabled && previewTimestamp >= burstStartTimestamp
                    && previewTimestamp <= burstEndTimeStamp) {
                fail(""Preview frame is interleaved with burst frames! Preview timestamp:"" +
                        previewTimestamp + "", burst ["" + burstStartTimestamp + "", "" +
                        burstEndTimeStamp + ""]"");
            } else if (previewTimestamp > burstEndTimeStamp) {
                break;
            }
        }

        // Verify inter-frame durations
        if (checkFrameRate) {
            long meanFrameSum = 0;
            for (Long duration : frameDurations) {
                meanFrameSum += duration;
            }
            float meanFrameDuration = (float) meanFrameSum / frameDurations.size();

            float stddevSum = 0;
            for (Long duration : frameDurations) {
                stddevSum += (duration - meanFrameDuration) * (duration - meanFrameDuration);
            }
            float stddevFrameDuration = (float)
                    Math.sqrt(1.f / (frameDurations.size() - 1 ) * stddevSum);

            Log.i(TAG, String.format(""Cam %s: Burst frame duration mean: %.1f, stddev: %.1f"",
                    cameraId, meanFrameDuration, stddevFrameDuration));

            assertTrue(
                String.format(""Cam %s: Burst frame duration mean %.1f ns is larger than "" +
                    ""acceptable, expecting below %d ns, allowing below %d"", cameraId,
                    meanFrameDuration, minStillFrameDuration, frameDurationBound),
                meanFrameDuration <= frameDurationBound);

            // Calculate upper 97.5% bound (assuming durations are normally distributed...)
            float limit95FrameDuration = meanFrameDuration + 2 * stddevFrameDuration;

            // Don't enforce this yet, but warn
            if (limit95FrameDuration > frameDurationBound) {
                Log.w(TAG,
                    String.format(""Cam %s: Standard deviation is too large compared to limit: "" +
                        ""mean: %.1f ms, stddev: %.1f ms: 95%% bound: %f ms"", cameraId,
                        meanFrameDuration/1e6, stddevFrameDuration/1e6,
                        limit95FrameDuration/1e6));
            }
        }
    }
}"	"/home/gpoor/cts-12-source/cts/tests/camera/src/android/hardware/camera2/cts/BurstCaptureTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	Test Available	"android.systemui.cts.audiorecorder.mediarecorder.AudioRecorderService"	"isRecording"	""	"3: mic ui system"	"public void test/*
 *
 */

package android.systemui.cts.audiorecorder.mediarecorder;

import android.media.MediaRecorder;
import android.media.MediaRecorder.AudioSource;
import android.systemui.cts.audiorecorder.base.BaseAudioRecorderService;

import java.io.File;
import java.io.IOException;

public class AudioRecorderService extends BaseAudioRecorderService {
    private MediaRecorder mMediaRecorder = null;

    protected void startRecording() {
        mMediaRecorder = new MediaRecorder();
        mMediaRecorder.setAudioSource(AudioSource.MIC);
        mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);
        mMediaRecorder.setOutputFile(new File(getExternalCacheDir(), ""record.3gp""));
        mMediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);

        try {
            mMediaRecorder.prepare();
        } catch (IOException e) {
            mMediaRecorder.release();
            mMediaRecorder = null;
            return;
        }

        mMediaRecorder.start();
    }

    protected void stopRecording() {
        mMediaRecorder.stop();
        mMediaRecorder.release();
        mMediaRecorder = null;
    }

    protected boolean isRecording() {
        return mMediaRecorder != null;
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/systemui/AudioRecorderTestApp_MediaRecorder/src/android/systemui/cts/audiorecorder/mediarecorder/AudioRecorderService.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.location.cts.privileged.GnssLocationValuesTest"	"dropShellPermissionIdentity"	"CtsLocationPrivilegedTestCases"	"1: ui"	"public void test/*
 *.
 */

package android.location.cts.privileged;

import android.Manifest;
import android.location.Location;
import android.location.cts.common.GnssTestCase;
import android.location.cts.common.SoftAssert;
import android.location.cts.common.TestLocationListener;
import android.location.cts.common.TestLocationManager;
import android.location.cts.common.TestMeasurementUtil;
import android.os.Build;
import android.util.Log;

import androidx.test.InstrumentationRegistry;

import org.junit.Assert;

/**
 * Test the {@link Location} values.
 *
 * Test steps:
 * 1. Register for location updates.
 * 2. Wait for {@link #LOCATION_TO_COLLECT_COUNT} locations.
 *          3.1 Confirm locations have been found.
 * 3. Get LastKnownLocation, verified all fields are in the correct range.
 */
public class GnssLocationValuesTest extends GnssTestCase {

    private static final String TAG = ""GnssLocationValuesTest"";
    private static final int LOCATION_TO_COLLECT_COUNT = 5;
    private TestLocationListener mLocationListener;
    // TODO(b/65458848): Re-tighten the limit to 0.001 when sufficient devices in the market comply
    private static final double MINIMUM_SPEED_FOR_BEARING = 1.000;
    private static final int MIN_ANDROID_SDK_VERSION_REQUIRED = Build.VERSION_CODES.O;

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity(Manifest.permission.LOCATION_HARDWARE);
        mTestLocationManager = new TestLocationManager(getContext());
        mLocationListener = new TestLocationListener(LOCATION_TO_COLLECT_COUNT);
    }

    @Override
    protected void tearDown() throws Exception {
        // Unregister listeners
        if (mLocationListener != null) {
            mTestLocationManager.removeLocationUpdates(mLocationListener);
        }

        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .dropShellPermissionIdentity();
        super.tearDown();
    }

    /**
     * 1. Get regular GNSS locations to warm up the engine.
     * 2. Get low-power GNSS locations.
     * 3. Check whether all fields' value make sense.
     */"	"/home/gpoor/cts-12-source/cts/tests/location/location_privileged/src/android/location/cts/privileged/GnssLocationValuesTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telephony.cts.CarrierSignalTest"	"TestReceiver"	"CtsTelephonyTestCases"	"2: ui system"	"/*
 *.
 */

package android.telephony.cts;

import static org.junit.Assert.assertEquals;

import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.net.ConnectivityManager;
import android.os.PersistableBundle;
import android.telephony.CarrierConfigManager;
import android.telephony.SubscriptionManager;
import android.telephony.TelephonyManager;

import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.RequiredFeatureRule;
import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;

public class CarrierSignalTest {
    private class TestReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            mIntentFuture.complete(intent);
        }
    }

    @Rule
    public final RequiredFeatureRule mTelephonyRequiredRule =
            new RequiredFeatureRule(PackageManager.FEATURE_TELEPHONY);

    private static final int TEST_TIMEOUT_MILLIS = 5000;
    private Context mContext;
    private CarrierConfigManager mCarrierConfigManager;
    private int mTestSub;
    private CompletableFuture<Intent> mIntentFuture = new CompletableFuture<>();
    private final TestReceiver mReceiver = new TestReceiver();

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getContext();
        mCarrierConfigManager = mContext.getSystemService(CarrierConfigManager.class);
        mTestSub = SubscriptionManager.getDefaultSubscriptionId();

        String[] carrierConfigData = new String[] {
                new ComponentName(mContext.getPackageName(),
                        mReceiver.getClass().getName()).flattenToString()
                        + "":""
                        // add more actions here as tests increase.
                        + String.join("","", TelephonyManager.ACTION_CARRIER_SIGNAL_RESET)
        };
        PersistableBundle b = new PersistableBundle();
        b.putStringArray(CarrierConfigManager.KEY_CARRIER_APP_NO_WAKE_SIGNAL_CONFIG_STRING_ARRAY,
                carrierConfigData);
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mCarrierConfigManager,
                (cm) -> cm.overrideConfig(mTestSub, b));
        // We have no way of knowing when CarrierSignalAgent processes this broadcast, so sleep
        // and hope for the best.
        Thread.sleep(1000);
    }

    @After
    public void tearDown() {
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(mCarrierConfigManager,
                (cm) -> cm.overrideConfig(mTestSub, null));
        ConnectivityManager cm = mContext.getSystemService(ConnectivityManager.class);
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(cm,
                x -> x.setAirplaneMode(false));
        try {
            mContext.unregisterReceiver(mReceiver);
        } catch (Throwable t) { }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/CarrierSignalTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telephony.cts.CarrierSignalTest"	"testResetBroadcast"	"CtsTelephonyTestCases"	"1: system"	"public void testResetBroadcast() throws Exception {
        mIntentFuture = new CompletableFuture<>();
        mContext.registerReceiver(mReceiver,
                new IntentFilter(TelephonyManager.ACTION_CARRIER_SIGNAL_RESET));

        // Enable airplane mode to force the reset action
        ConnectivityManager cm = mContext.getSystemService(ConnectivityManager.class);
        ShellIdentityUtils.invokeMethodWithShellPermissionsNoReturn(cm,
                x -> x.setAirplaneMode(true));

        Intent receivedIntent = mIntentFuture.get(TEST_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
        assertEquals(mTestSub,
                receivedIntent.getIntExtra(SubscriptionManager.EXTRA_SUBSCRIPTION_INDEX, -1));
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/CarrierSignalTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.location.cts.gnss.asn1.supl2.rrlp_components.GLONASSclockModel"	"isTagImplicit"	"CtsLocationGnssTestCases"	"1: ui"	"public void test/*
 *.
 */

package android.location.cts.asn1.supl2.rrlp_components;

/*
 */


//
//
import android.location.cts.asn1.base.Asn1Integer;
import android.location.cts.asn1.base.Asn1Null;
import android.location.cts.asn1.base.Asn1Object;
import android.location.cts.asn1.base.Asn1Sequence;
import android.location.cts.asn1.base.Asn1Tag;
import android.location.cts.asn1.base.BitStream;
import android.location.cts.asn1.base.BitStreamReader;
import android.location.cts.asn1.base.SequenceComponent;
import com.google.common.collect.ImmutableList;
import java.util.Collection;
import javax.annotation.Nullable;


/**
*/
public  class GLONASSclockModel extends Asn1Sequence {
  //

  private static final Asn1Tag TAG_GLONASSclockModel
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public GLONASSclockModel() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_GLONASSclockModel;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_GLONASSclockModel != null) {
      return ImmutableList.of(TAG_GLONASSclockModel);
    } else {
      return Asn1Sequence.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new GLONASSclockModel from encoded stream.
   */
  public static GLONASSclockModel fromPerUnaligned(byte[] encodedBytes) {
    GLONASSclockModel result = new GLONASSclockModel();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new GLONASSclockModel from encoded stream.
   */
  public static GLONASSclockModel fromPerAligned(byte[] encodedBytes) {
    GLONASSclockModel result = new GLONASSclockModel();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }



  @Override protected boolean isExtensible() {
    return false;
  }

  @Override public boolean containsExtensionValues() {
    for (SequenceComponent extensionComponent : getExtensionComponents()) {
      if (extensionComponent.isExplicitlySet()) return true;
    }
    return false;
  }

  
  private GLONASSclockModel.gloTauType gloTau_;
  public GLONASSclockModel.gloTauType getGloTau() {
    return gloTau_;
  }
  /**
   * @throws ClassCastException if value is not a GLONASSclockModel.gloTauType
   */
  public void setGloTau(Asn1Object value) {
    this.gloTau_ = (GLONASSclockModel.gloTauType) value;
  }
  public GLONASSclockModel.gloTauType setGloTauToNewInstance() {
    gloTau_ = new GLONASSclockModel.gloTauType();
    return gloTau_;
  }
  
  private GLONASSclockModel.gloGammaType gloGamma_;
  public GLONASSclockModel.gloGammaType getGloGamma() {
    return gloGamma_;
  }
  /**
   * @throws ClassCastException if value is not a GLONASSclockModel.gloGammaType
   */
  public void setGloGamma(Asn1Object value) {
    this.gloGamma_ = (GLONASSclockModel.gloGammaType) value;
  }
  public GLONASSclockModel.gloGammaType setGloGammaToNewInstance() {
    gloGamma_ = new GLONASSclockModel.gloGammaType();
    return gloGamma_;
  }
  
  private GLONASSclockModel.gloDeltaTauType gloDeltaTau_;
  public GLONASSclockModel.gloDeltaTauType getGloDeltaTau() {
    return gloDeltaTau_;
  }
  /**
   * @throws ClassCastException if value is not a GLONASSclockModel.gloDeltaTauType
   */
  public void setGloDeltaTau(Asn1Object value) {
    this.gloDeltaTau_ = (GLONASSclockModel.gloDeltaTauType) value;
  }
  public GLONASSclockModel.gloDeltaTauType setGloDeltaTauToNewInstance() {
    gloDeltaTau_ = new GLONASSclockModel.gloDeltaTauType();
    return gloDeltaTau_;
  }
  

  

  

  @Override public Iterable<? extends SequenceComponent> getComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 0);

          @Override public boolean isExplicitlySet() {
            return getGloTau() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getGloTau();
          }

          @Override public void setToNewInstance() {
            setGloTauToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? GLONASSclockModel.gloTauType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""gloTau : ""
                    + getGloTau().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 1);

          @Override public boolean isExplicitlySet() {
            return getGloGamma() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getGloGamma();
          }

          @Override public void setToNewInstance() {
            setGloGammaToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? GLONASSclockModel.gloGammaType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""gloGamma : ""
                    + getGloGamma().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 2);

          @Override public boolean isExplicitlySet() {
            return getGloDeltaTau() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return true;
          }

          @Override public Asn1Object getComponentValue() {
            return getGloDeltaTau();
          }

          @Override public void setToNewInstance() {
            setGloDeltaTauToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? GLONASSclockModel.gloDeltaTauType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""gloDeltaTau : ""
                    + getGloDeltaTau().toIndentedString(indent);
              }
        });
    
    return builder.build();
  }

  @Override public Iterable<? extends SequenceComponent>
                                                    getExtensionComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
      
      return builder.build();
    }

  
/*
 */


//

/**
 */
public static class gloTauType extends Asn1Integer {
  //

  private static final Asn1Tag TAG_gloTauType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public gloTauType() {
    super();
    setValueRange(""-2097152"", ""2097151"");

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_gloTauType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_gloTauType != null) {
      return ImmutableList.of(TAG_gloTauType);
    } else {
      return Asn1Integer.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new gloTauType from encoded stream.
   */
  public static gloTauType fromPerUnaligned(byte[] encodedBytes) {
    gloTauType result = new gloTauType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new gloTauType from encoded stream.
   */
  public static gloTauType fromPerAligned(byte[] encodedBytes) {
    gloTauType result = new gloTauType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""gloTauType = "" + getInteger() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class gloGammaType extends Asn1Integer {
  //

  private static final Asn1Tag TAG_gloGammaType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public gloGammaType() {
    super();
    setValueRange(""-1024"", ""1023"");

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_gloGammaType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_gloGammaType != null) {
      return ImmutableList.of(TAG_gloGammaType);
    } else {
      return Asn1Integer.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new gloGammaType from encoded stream.
   */
  public static gloGammaType fromPerUnaligned(byte[] encodedBytes) {
    gloGammaType result = new gloGammaType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new gloGammaType from encoded stream.
   */
  public static gloGammaType fromPerAligned(byte[] encodedBytes) {
    gloGammaType result = new gloGammaType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""gloGammaType = "" + getInteger() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class gloDeltaTauType extends Asn1Integer {
  //

  private static final Asn1Tag TAG_gloDeltaTauType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public gloDeltaTauType() {
    super();
    setValueRange(""-16"", ""15"");

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_gloDeltaTauType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_gloDeltaTauType != null) {
      return ImmutableList.of(TAG_gloDeltaTauType);
    } else {
      return Asn1Integer.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new gloDeltaTauType from encoded stream.
   */
  public static gloDeltaTauType fromPerUnaligned(byte[] encodedBytes) {
    gloDeltaTauType result = new gloDeltaTauType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new gloDeltaTauType from encoded stream.
   */
  public static gloDeltaTauType fromPerAligned(byte[] encodedBytes) {
    gloDeltaTauType result = new gloDeltaTauType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""gloDeltaTauType = "" + getInteger() + "";\n"";
  }
}

  

    

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    StringBuilder builder = new StringBuilder();
    builder.append(""GLONASSclockModel = {\n"");
    final String internalIndent = indent + ""  "";
    for (SequenceComponent component : getComponents()) {
      if (component.isExplicitlySet()) {
        builder.append(internalIndent)
            .append(component.toIndentedString(internalIndent));
      }
    }
    if (isExtensible()) {
      builder.append(internalIndent).append(""...\n"");
      for (SequenceComponent component : getExtensionComponents()) {
        if (component.isExplicitlySet()) {
          builder.append(internalIndent)
              .append(component.toIndentedString(internalIndent));
        }
      }
    }
    builder.append(indent).append(""};\n"");
    return builder.toString();
  }
}"	"/home/gpoor/cts-12-source/cts/tests/location/location_gnss/src/android/location/cts/gnss/asn1/supl2/rrlp_components/GLONASSclockModel.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.hardware.input.cts.tests.GoogleAtvReferenceRemoteControlTest"	"testAllKeys"	"CtsHardwareTestCases"	"1: apps"	"public void testAllKeys() {
        testInputEvents(R.raw.google_atvreferenceremote_keyeventtests);
    }

    /**
     * We cannot test the home key using ""testAllKeys"" because the home key does not get forwarded
     * to apps, and therefore cannot be received in InputCtsActivity.
     * Instead, we rely on the home button behavior check using the wm utils.
     */"	"/home/gpoor/cts-12-source/cts/tests/tests/hardware/src/android/hardware/input/cts/tests/GoogleAtvReferenceRemoteControlTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextClockTest"	"testUpdate12_24"	"CtsWidgetTestCases"	"2: ui system"	"public void testUpdate12_24() throws Throwable {
        grantWriteSettingsPermission();

        mActivityRule.runOnUiThread(() -> {
            mTextClock.setFormat12Hour(""h"");
            mTextClock.setFormat24Hour(""H"");
            mTextClock.disableClockTick();
        });

        final ContentResolver resolver = mActivity.getContentResolver();
        Calendar mNow = Calendar.getInstance();
        mNow.setTimeInMillis(System.currentTimeMillis()); // just like TextClock uses

        // make sure the clock is showing some time > 12pm and not near midnight
        for (String id : TimeZone.getAvailableIDs()) {
            final TimeZone timeZone = TimeZone.getTimeZone(id);
            mNow.setTimeZone(timeZone);
            int hour = mNow.get(Calendar.HOUR_OF_DAY);
            if (hour < 22 && hour > 12) {
                mActivityRule.runOnUiThread(() -> {
                    mTextClock.setTimeZone(id);
                });
                break;
            }
        }

        // If the time was already set to 12, we want it to start at locale-specified
        if (mDefaultTime1224 != null) {
            final CountDownLatch changeDefault = registerForChanges(Settings.System.TIME_12_24);
            mActivityRule.runOnUiThread(() -> {
                Settings.System.putString(resolver, Settings.System.TIME_12_24, null);
            });
            assertTrue(changeDefault.await(1, TimeUnit.SECONDS));
        }

        // Change to 12-hour mode
        final CountDownLatch change12 = registerForChanges(Settings.System.TIME_12_24);
        mActivityRule.runOnUiThread(() -> {
            Settings.System.putInt(resolver, Settings.System.TIME_12_24, 12);
        });
        assertTrue(change12.await(1, TimeUnit.SECONDS));

        // Must poll here because there are no timing guarantees for ContentObserver notification
        PollingCheck.waitFor(() -> {
            final MutableBoolean ok = new MutableBoolean(false);
            try {
                mActivityRule.runOnUiThread(() -> {
                    int hour = Integer.parseInt(mTextClock.getText().toString());
                    ok.value = hour >= 1 && hour < 12;
                });
            } catch (Throwable t) {
                throw new RuntimeException(t.getMessage());
            }
            return ok.value;
        });

        // Change to 24-hour mode
        final CountDownLatch change24 = registerForChanges(Settings.System.TIME_12_24);
        mActivityRule.runOnUiThread(() -> {
            Settings.System.putInt(resolver, Settings.System.TIME_12_24, 24);
        });
        assertTrue(change24.await(1, TimeUnit.SECONDS));

        // Must poll here because there are no timing guarantees for ContentObserver notification
        PollingCheck.waitFor(() -> {
            final MutableBoolean ok = new MutableBoolean(false);
            try {
                mActivityRule.runOnUiThread(() -> {
                    int hour = Integer.parseInt(mTextClock.getText().toString());
                    ok.value = hour > 12 && hour < 24;
                });
                return ok.value;
            } catch (Throwable t) {
                throw new RuntimeException(t.getMessage());
            }
        });
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextClockTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.TextClockTest"	"testNoChange"	"CtsWidgetTestCases"	"2: ui system"	"public void testNoChange() throws Throwable {
        grantWriteSettingsPermission();
        mActivityRule.runOnUiThread(() -> mTextClock.disableClockTick());
        final ContentResolver resolver = mActivity.getContentResolver();

        // Now test that it isn't updated when a non-12/24 hour setting is set
        mActivityRule.runOnUiThread(() -> mTextClock.setText(""Nothing""));

        mActivityRule.runOnUiThread(() -> assertEquals(""Nothing"", mTextClock.getText().toString()));

        final CountDownLatch otherChange = registerForChanges(Settings.System.TEXT_AUTO_CAPS);
        mActivityRule.runOnUiThread(() -> {
            int oldAutoCaps = Settings.System.getInt(resolver, Settings.System.TEXT_AUTO_CAPS,
                    1);
            try {
                int newAutoCaps = oldAutoCaps == 0 ? 1 : 0;
                Settings.System.putInt(resolver, Settings.System.TEXT_AUTO_CAPS, newAutoCaps);
            } finally {
                Settings.System.putInt(resolver, Settings.System.TEXT_AUTO_CAPS, oldAutoCaps);
            }
        });

        assertTrue(otherChange.await(1, TimeUnit.SECONDS));

        mActivityRule.runOnUiThread(() -> assertEquals(""Nothing"", mTextClock.getText().toString()));
    }

    private CountDownLatch registerForChanges(String setting) throws Throwable {
        final CountDownLatch latch = new CountDownLatch(1);

        mActivityRule.runOnUiThread(() -> {
            final ContentResolver resolver = mActivity.getContentResolver();
            Uri uri = Settings.System.getUriFor(setting);
            resolver.registerContentObserver(uri, true,
                    new ContentObserver(new Handler()) {
                        @Override
                        public void onChange(boolean selfChange) {
                            countDownAndRemove();
                        }

                        private void countDownAndRemove() {
                            latch.countDown();
                            resolver.unregisterContentObserver(this);
                        }
                    });
        });
        return latch;
    }

    private void grantWriteSettingsPermission() throws IOException {
        SystemUtil.runShellCommand(InstrumentationRegistry.getInstrumentation(),
                ""appops set "" + mActivity.getPackageName() + "" ""
                        + AppOpsManager.OPSTR_WRITE_SETTINGS + "" allow"");
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/TextClockTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.accessibilityservice.cts.AccessibilityGestureDispatchTest"	"MyTouchListener"	"CtsAccessibilityServiceTestCases"	"3: mic ui system"	"/**
 *.
 */

package android.accessibilityservice.cts;

import static android.accessibility.cts.common.InstrumentedAccessibilityService.enableService;
import static android.accessibilityservice.cts.utils.ActivityLaunchUtils.launchActivityAndWaitForItToBeOnscreen;
import static android.accessibilityservice.cts.utils.AsyncUtils.await;
import static android.accessibilityservice.cts.utils.AsyncUtils.awaitCancellation;
import static android.accessibilityservice.cts.utils.GestureUtils.IS_ACTION_CANCEL;
import static android.accessibilityservice.cts.utils.GestureUtils.IS_ACTION_DOWN;
import static android.accessibilityservice.cts.utils.GestureUtils.IS_ACTION_MOVE;
import static android.accessibilityservice.cts.utils.GestureUtils.IS_ACTION_POINTER_DOWN;
import static android.accessibilityservice.cts.utils.GestureUtils.IS_ACTION_POINTER_UP;
import static android.accessibilityservice.cts.utils.GestureUtils.IS_ACTION_UP;
import static android.accessibilityservice.cts.utils.GestureUtils.add;
import static android.accessibilityservice.cts.utils.GestureUtils.ceil;
import static android.accessibilityservice.cts.utils.GestureUtils.click;
import static android.accessibilityservice.cts.utils.GestureUtils.diff;
import static android.accessibilityservice.cts.utils.GestureUtils.dispatchGesture;
import static android.accessibilityservice.cts.utils.GestureUtils.isAtPoint;
import static android.accessibilityservice.cts.utils.GestureUtils.longClick;
import static android.accessibilityservice.cts.utils.GestureUtils.path;
import static android.accessibilityservice.cts.utils.GestureUtils.times;
import static android.view.KeyCharacterMap.VIRTUAL_KEYBOARD;

import static androidx.test.InstrumentationRegistry.getInstrumentation;

import static org.hamcrest.CoreMatchers.allOf;
import static org.hamcrest.CoreMatchers.any;
import static org.hamcrest.CoreMatchers.both;
import static org.hamcrest.CoreMatchers.everyItem;
import static org.hamcrest.CoreMatchers.hasItem;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import static java.util.concurrent.TimeUnit.MILLISECONDS;

import android.accessibility.cts.common.AccessibilityDumpOnFailureRule;
import android.accessibility.cts.common.InstrumentedAccessibilityServiceTestRule;
import android.accessibilityservice.AccessibilityService;
import android.accessibilityservice.GestureDescription;
import android.accessibilityservice.GestureDescription.StrokeDescription;
import android.accessibilityservice.cts.activities.AccessibilityTestActivity;
import android.app.Instrumentation;
import android.app.UiAutomation;
import android.content.Context;
import android.content.pm.PackageManager;
import android.graphics.Matrix;
import android.graphics.Path;
import android.graphics.PointF;
import android.os.Bundle;
import android.os.SystemClock;
import android.platform.test.annotations.AppModeFull;
import android.util.Log;
import android.view.Display;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewConfiguration;
import android.view.WindowManager;
import android.widget.TextView;

import androidx.test.rule.ActivityTestRule;
import androidx.test.runner.AndroidJUnit4;

import org.hamcrest.Matcher;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.RuleChain;
import org.junit.runner.RunWith;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

import android.graphics.Rect;

/**
 * Verify that gestures dispatched from an accessibility service show up in the current UI
 */
@AppModeFull
@RunWith(AndroidJUnit4.class)
public class AccessibilityGestureDispatchTest {
    private static final String TAG = AccessibilityGestureDispatchTest.class.getSimpleName();

    private static final int GESTURE_COMPLETION_TIMEOUT = 5000; // millis
    private static final int MOTION_EVENT_TIMEOUT = 1000; // millis

    private static Instrumentation sInstrumentation;
    private static UiAutomation sUiAutomation;

    private ActivityTestRule<GestureDispatchActivity> mActivityRule =
            new ActivityTestRule<>(GestureDispatchActivity.class, false, false);

    private InstrumentedAccessibilityServiceTestRule<StubGestureAccessibilityService> mServiceRule =
            new InstrumentedAccessibilityServiceTestRule<>(
                    StubGestureAccessibilityService.class, false);

    private AccessibilityDumpOnFailureRule mDumpOnFailureRule =
            new AccessibilityDumpOnFailureRule();

    @Rule
    public final RuleChain mRuleChain = RuleChain
            .outerRule(mActivityRule)
            .around(mServiceRule)
            .around(mDumpOnFailureRule);

    final List<MotionEvent> mMotionEvents = new ArrayList<>();
    StubGestureAccessibilityService mService;
    MyTouchListener mMyTouchListener = new MyTouchListener();
    TextView mFullScreenTextView;
    int[] mViewLocation = new int[2];  // The location of TextView on the screen.
    PointF mStartPoint = new PointF(); // The relative location from mViewLocation.
    boolean mGotUpEvent;
    // Without a touch screen, there's no point in testing this feature
    boolean mHasTouchScreen;
    boolean mHasMultiTouch;

    private GestureDispatchActivity mActivity;

    @BeforeClass
    public static void oneTimeSetup() {
        sInstrumentation = getInstrumentation();
        sUiAutomation = sInstrumentation.getUiAutomation(
                UiAutomation.FLAG_DONT_SUPPRESS_ACCESSIBILITY_SERVICES);
    }

    @AfterClass
    public static void postTestTearDown() {
        sUiAutomation.destroy();
    }

    @Before
    public void setUp() throws Exception {
        PackageManager pm = sInstrumentation.getContext().getPackageManager();
        mHasTouchScreen = pm.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN)
                || pm.hasSystemFeature(PackageManager.FEATURE_FAKETOUCH);
        if (!mHasTouchScreen) {
            return;
        }

        mActivity = launchActivityAndWaitForItToBeOnscreen(sInstrumentation,
                sUiAutomation, mActivityRule);
        // Wait for window animation completed to ensure the input window is at the final position.
        sUiAutomation.syncInputTransactions();

        mHasMultiTouch = pm.hasSystemFeature(PackageManager.FEATURE_TOUCHSCREEN_MULTITOUCH)
                || pm.hasSystemFeature(PackageManager.FEATURE_FAKETOUCH_MULTITOUCH_DISTINCT);

        mFullScreenTextView = mActivity.findViewById(R.id.full_screen_text_view);
        sInstrumentation.runOnMainSync(() -> {
            final int midX = mFullScreenTextView.getWidth() / 2;
            final int midY = mFullScreenTextView.getHeight() / 2;
            mFullScreenTextView.getLocationOnScreen(mViewLocation);
            mFullScreenTextView.setOnTouchListener(mMyTouchListener);
            mStartPoint.set(midX, midY);
        });

        mService = mServiceRule.enableService();

        mMotionEvents.clear();
        mGotUpEvent = false;
    }"	"/home/gpoor/cts-12-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityGestureDispatchTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.accessibilityservice.cts.AccessibilityGestureDispatchTest"	"testClickWhenMagnified_matchesActualTouch"	"CtsAccessibilityServiceTestCases"	"3: mic ui system"	"public void testClickWhenMagnified_matchesActualTouch() throws InterruptedException {
        final float POINT_TOL = 2.0f;
        final float CLICK_OFFSET_X = 10;
        final float CLICK_OFFSET_Y = 20;
        final float MAGNIFICATION_FACTOR = 2;
        final int MAGNIFICATION_SPEC_WAIT_MILLIS = 200;

        if (!mHasTouchScreen) {
            return;
        }

        int displayId = mActivity.getWindow().getDecorView().getDisplay().getDisplayId();
        if (displayId != Display.DEFAULT_DISPLAY) {
            Log.i(TAG, ""Magnification is not supported on virtual displays."");
            return;
        }

        final StubMagnificationAccessibilityService magnificationService =
                enableService(StubMagnificationAccessibilityService.class);
        final AccessibilityService.MagnificationController
                magnificationController = magnificationService.getMagnificationController();

        final PointF magRegionCenterClickPoint = new PointF();
        // Determine the center of the test activity to center the magnification viewport.
        final Rect activityBounds = mActivity.getWindowManager()
                .getCurrentWindowMetrics().getBounds();
        final PointF activityCenterPoint = new PointF(activityBounds.centerX(),
                activityBounds.centerY());
        // Target points where the clicks are expected to land after magnification.
        final PointF viewPortCenter = new PointF();
        final PointF viewPortCenterWithOffset = new PointF();

        magnificationService.runOnServiceSync(() -> {
            magnificationController.reset(false);
            magRegionCenterClickPoint.set(magnificationController.getCenterX(),
                    magnificationController.getCenterY());
        });

        final PointF magRegionOffsetClickPoint =
                add(magRegionCenterClickPoint, CLICK_OFFSET_X * MAGNIFICATION_FACTOR,
                        CLICK_OFFSET_Y * MAGNIFICATION_FACTOR);

        try {
            // Zoom in
            final AtomicBoolean setScale = new AtomicBoolean();
            magnificationService.runOnServiceSync(() -> {
                setScale.set(magnificationController.setScale(MAGNIFICATION_FACTOR, false));
                magnificationController.setCenter(activityCenterPoint.x,
                        activityCenterPoint.y, false);
                // The magnification's viewport center can be different than the activity's center
                // (e.g. on foldable devices when the activity is on half of the screen).
                viewPortCenter.set(magnificationController.getCenterX(),
                        magnificationController.getCenterY());
                viewPortCenterWithOffset.set(viewPortCenter.x + CLICK_OFFSET_X,
                        viewPortCenter.y + CLICK_OFFSET_Y);
            });
            assertTrue(""Failed to set scale"", setScale.get());

            // DisplayContent#applyMagnificationSpec uses the pending transaction and there's no
            // signal to know when it gets executed. Wait for UI to get updated.
            Thread.sleep(MAGNIFICATION_SPEC_WAIT_MILLIS);

            // Click in the center of the magnification region
            dispatch(new GestureDescription.Builder()
                    .addStroke(click(magRegionCenterClickPoint))
                    .build(),
                    GESTURE_COMPLETION_TIMEOUT);

            // Click at a slightly offset point
            dispatch(new GestureDescription.Builder()
                    .addStroke(click(magRegionOffsetClickPoint))
                    .build(),
                    GESTURE_COMPLETION_TIMEOUT);
            waitForMotionEvents(any(MotionEvent.class), 4);
        } finally {
            // Reset magnification
            final AtomicBoolean result = new AtomicBoolean();
            magnificationService.runOnServiceSync(() ->
                    result.set(magnificationController.reset(false)));
            magnificationService.runOnServiceSync(() -> magnificationService.disableSelf());
            assertTrue(""Failed to reset"", result.get());
        }

        assertEquals(4, mMotionEvents.size());
        // Because the MotionEvents have been captures by the view, the coordinates will
        // be in the View's coordinate system.
        viewPortCenter.offset(-mViewLocation[0], -mViewLocation[1]);
        viewPortCenterWithOffset.offset(-mViewLocation[0], -mViewLocation[1]);

        // The first click should be at the magnification center, as that point is invariant
        // for zoom only
        assertThat(mMotionEvents.get(0),
                both(IS_ACTION_DOWN).and(isAtPoint(viewPortCenter, POINT_TOL)));
        assertThat(mMotionEvents.get(1),
                both(IS_ACTION_UP).and(isAtPoint(viewPortCenter, POINT_TOL)));

        // The second point should be at the offset point
        assertThat(mMotionEvents.get(2),
                both(IS_ACTION_DOWN).and(isAtPoint(viewPortCenterWithOffset, POINT_TOL)));
        assertThat(mMotionEvents.get(3),
                both(IS_ACTION_UP).and(isAtPoint(viewPortCenterWithOffset, POINT_TOL)));
    }"	"/home/gpoor/cts-12-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityGestureDispatchTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.accessibilityservice.cts.AccessibilityGestureDispatchTest"	"testContinuedGestures_motionEventsContinue"	"CtsAccessibilityServiceTestCases"	"1: ui"	"public void testContinuedGestures_motionEventsContinue() throws Exception {
        if (!mHasTouchScreen) {
            return;
        }

        PointF start = new PointF(mStartPoint.x, mStartPoint.y);
        PointF mid1 = new PointF(mStartPoint.x + 10, mStartPoint.y);
        PointF mid2 = new PointF(mStartPoint.x + 10, mStartPoint.y + 5);
        PointF end = new PointF(mStartPoint.x + 10, mStartPoint.y + 10);
        int gestureTime = 500;

        StrokeDescription s1 = new StrokeDescription(
                lineWithinView(start, mid1), 0, gestureTime, true);
        StrokeDescription s2 = s1.continueStroke(
                lineWithinView(mid1, mid2), 0, gestureTime, true);
        StrokeDescription s3 = s2.continueStroke(
                lineWithinView(mid2, end), 0, gestureTime, false);

        GestureDescription gesture1 = new GestureDescription.Builder().addStroke(s1).build();
        GestureDescription gesture2 = new GestureDescription.Builder().addStroke(s2).build();
        GestureDescription gesture3 = new GestureDescription.Builder().addStroke(s3).build();
        dispatch(gesture1, gestureTime + GESTURE_COMPLETION_TIMEOUT);
        dispatch(gesture2, gestureTime + GESTURE_COMPLETION_TIMEOUT);
        dispatch(gesture3, gestureTime + GESTURE_COMPLETION_TIMEOUT);
        waitForMotionEvents(IS_ACTION_UP, 1);

        assertThat(mMotionEvents.get(0), allOf(IS_ACTION_DOWN, isAtPoint(start)));
        assertThat(mMotionEvents.subList(1, mMotionEvents.size() - 1), everyItem(IS_ACTION_MOVE));
        assertThat(mMotionEvents, hasItem(isAtPoint(mid1)));
        assertThat(mMotionEvents, hasItem(isAtPoint(mid2)));
        assertThat(mMotionEvents.get(mMotionEvents.size() - 1),
                allOf(IS_ACTION_UP, isAtPoint(end)));
    }"	"/home/gpoor/cts-12-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityGestureDispatchTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.accessibilityservice.cts.AccessibilityGestureDispatchTest"	"testContinuedGesture_withLineDisconnect_isCancelled"	"CtsAccessibilityServiceTestCases"	"1: ui"	"public void testContinuedGesture_withLineDisconnect_isCancelled() throws Exception {
        if (!mHasTouchScreen) {
            return;
        }

        PointF startPoint = new PointF(mStartPoint.x, mStartPoint.y);
        PointF midPoint = new PointF(mStartPoint.x + 10, mStartPoint.y);
        PointF endPoint = new PointF(mStartPoint.x + 10, mStartPoint.y + 10);
        int gestureTime = 500;

        StrokeDescription stroke1 =
                new StrokeDescription(lineWithinView(startPoint, midPoint), 0, gestureTime, true);
        dispatch(new GestureDescription.Builder().addStroke(stroke1).build(),
                gestureTime + GESTURE_COMPLETION_TIMEOUT);
        waitForMotionEvents(both(IS_ACTION_MOVE).and(isAtPoint(midPoint)), 1);

        StrokeDescription stroke2 =
                stroke1.continueStroke(lineWithinView(endPoint, midPoint), 0, gestureTime, false);
        mMotionEvents.clear();
        awaitCancellation(
                dispatchGesture(mService,
                        new GestureDescription.Builder().addStroke(stroke2).build()),
                gestureTime + GESTURE_COMPLETION_TIMEOUT, MILLISECONDS);

        waitForMotionEvents(IS_ACTION_CANCEL, 1);
        assertEquals(1, mMotionEvents.size());
    }"	"/home/gpoor/cts-12-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityGestureDispatchTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.accessibilityservice.cts.AccessibilityGestureDispatchTest"	"testContinuedGesture_nextGestureDoesntContinue_isCancelled"	"CtsAccessibilityServiceTestCases"	"1: ui"	"public void testContinuedGesture_nextGestureDoesntContinue_isCancelled() throws Exception {
        if (!mHasTouchScreen) {
            return;
        }

        PointF startPoint = new PointF(mStartPoint.x, mStartPoint.y);
        PointF midPoint = new PointF(mStartPoint.x + 10, mStartPoint.y);
        PointF endPoint = new PointF(mStartPoint.x + 10, mStartPoint.y + 10);
        int gestureTime = 500;

        StrokeDescription stroke1 =
                new StrokeDescription(lineWithinView(startPoint, midPoint), 0, gestureTime, true);
        dispatch(new GestureDescription.Builder().addStroke(stroke1).build(),
                gestureTime + GESTURE_COMPLETION_TIMEOUT);

        StrokeDescription stroke2 =
                new StrokeDescription(lineWithinView(midPoint, endPoint), 0, gestureTime, false);
        dispatch(new GestureDescription.Builder().addStroke(stroke2).build(),
                gestureTime + GESTURE_COMPLETION_TIMEOUT);

        waitForMotionEvents(IS_ACTION_UP, 1);

        List<MotionEvent> cancelEvent = getEventsMatching(IS_ACTION_CANCEL);
        assertEquals(1, cancelEvent.size());
        // Confirm that a down follows the cancel
        assertThat(mMotionEvents.get(mMotionEvents.indexOf(cancelEvent.get(0)) + 1),
                both(IS_ACTION_DOWN).and(isAtPoint(midPoint)));
        // Confirm that the last point is an up
        assertThat(mMotionEvents.get(mMotionEvents.size() - 1),
                both(IS_ACTION_UP).and(isAtPoint(endPoint)));
    }"	"/home/gpoor/cts-12-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityGestureDispatchTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.accessibilityservice.cts.AccessibilityGestureDispatchTest"	"testContinuingGesture_withNothingToContinue_isCancelled"	"CtsAccessibilityServiceTestCases"	"2: ui system"	"public void testContinuingGesture_withNothingToContinue_isCancelled() {
        if (!mHasTouchScreen) {
            return;
        }

        PointF startPoint = new PointF(mStartPoint.x, mStartPoint.y);
        PointF midPoint = new PointF(mStartPoint.x + 10, mStartPoint.y);
        PointF endPoint = new PointF(mStartPoint.x + 10, mStartPoint.y + 10);
        int gestureTime = 500;

        StrokeDescription stroke1 =
                new StrokeDescription(lineWithinView(startPoint, midPoint), 0, gestureTime, true);

        StrokeDescription stroke2 =
                stroke1.continueStroke(lineWithinView(midPoint, endPoint), 0, gestureTime, false);
        awaitCancellation(
                dispatchGesture(mService,
                        new GestureDescription.Builder().addStroke(stroke2).build()),
                gestureTime + GESTURE_COMPLETION_TIMEOUT, MILLISECONDS);
    }

    public static class GestureDispatchActivity extends AccessibilityTestActivity {
        public GestureDispatchActivity() {
            super();
        }

        @Override
        public void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.full_screen_frame_layout);
        }
    }

    private void waitForMotionEvents(Matcher<MotionEvent> matcher, int numEventsExpected)
            throws InterruptedException {
        synchronized (mMotionEvents) {
            long endMillis = SystemClock.uptimeMillis() + MOTION_EVENT_TIMEOUT;
            boolean gotEvents = getEventsMatching(matcher).size() >= numEventsExpected;
            while (!gotEvents && (SystemClock.uptimeMillis() < endMillis)) {
                mMotionEvents.wait(endMillis - SystemClock.uptimeMillis());
                gotEvents = getEventsMatching(matcher).size() >= numEventsExpected;
            }
            assertTrue(""Did not receive required events. Got:\n"" + mMotionEvents + ""\n filtered:\n""
                    + getEventsMatching(matcher), gotEvents);
        }
    }

    private List<MotionEvent> getEventsMatching(Matcher<MotionEvent> matcher) {
        List<MotionEvent> events = new ArrayList<>();
        synchronized (mMotionEvents) {
            for (MotionEvent event : mMotionEvents) {
                if (matcher.matches(event)) {
                    events.add(event);
                }
            }
        }
        return events;
    }

    private float distance(MotionEvent.PointerCoords point1, MotionEvent.PointerCoords point2) {
        return (float) Math.hypot((double) (point1.x - point2.x), (double) (point1.y - point2.y));
    }

    private class MyTouchListener implements View.OnTouchListener {
        @Override
        public boolean onTouch(View view, MotionEvent motionEvent) {
            synchronized (mMotionEvents) {
                if (motionEvent.getActionMasked() == MotionEvent.ACTION_UP) {
                    mGotUpEvent = true;
                }
                mMotionEvents.add(MotionEvent.obtain(motionEvent));
                mMotionEvents.notifyAll();
                return true;
            }
        }
    }

    private GestureDescription clickWithinView(PointF clickPoint) {
        return new GestureDescription.Builder()
                .addStroke(click(withinView(clickPoint)))
                .build();
    }

    private GestureDescription longClickWithinView(PointF clickPoint) {
        return new GestureDescription.Builder()
                .addStroke(longClick(withinView(clickPoint)))
                .build();
    }

    private PointF withinView(PointF clickPoint) {
        return add(clickPoint, mViewLocation[0], mViewLocation[1]);
    }

    private GestureDescription swipeWithinView(PointF start, PointF end, long duration) {
        return new GestureDescription.Builder()
                .addStroke(new StrokeDescription(lineWithinView(start, end), 0, duration))
                .build();
    }

    private Path lineWithinView(PointF startPoint, PointF endPoint) {
        return path(withinView(startPoint), withinView(endPoint));
    }

    private GestureDescription pinchWithinView(PointF centerPoint, int startSpacing,
            int endSpacing, float orientation, long duration) {
        if ((startSpacing < 0) || (endSpacing < 0)) {
            throw new IllegalArgumentException(""Pinch spacing cannot be negative"");
        }
        PointF offsetCenter = withinView(centerPoint);
        float[] startPoint1 = new float[2];
        float[] endPoint1 = new float[2];
        float[] startPoint2 = new float[2];
        float[] endPoint2 = new float[2];

        /* Build points for a horizontal gesture centered at the origin */
        startPoint1[0] = startSpacing / 2;
        startPoint1[1] = 0;
        endPoint1[0] = endSpacing / 2;
        endPoint1[1] = 0;
        startPoint2[0] = -startSpacing / 2;
        startPoint2[1] = 0;
        endPoint2[0] = -endSpacing / 2;
        endPoint2[1] = 0;

        /* Rotate and translate the points */
        Matrix matrix = new Matrix();
        matrix.setRotate(orientation);
        matrix.postTranslate(offsetCenter.x, offsetCenter.y);
        matrix.mapPoints(startPoint1);
        matrix.mapPoints(endPoint1);
        matrix.mapPoints(startPoint2);
        matrix.mapPoints(endPoint2);

        Path path1 = new Path();
        path1.moveTo(startPoint1[0], startPoint1[1]);
        path1.lineTo(endPoint1[0], endPoint1[1]);
        Path path2 = new Path();
        path2.moveTo(startPoint2[0], startPoint2[1]);
        path2.lineTo(endPoint2[0], endPoint2[1]);

        return new GestureDescription.Builder()
                .addStroke(new StrokeDescription(path1, 0, duration))
                .addStroke(new StrokeDescription(path2, 0, duration))
                .build();
    }
}"	"/home/gpoor/cts-12-source/cts/tests/accessibilityservice/src/android/accessibilityservice/cts/AccessibilityGestureDispatchTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.content.syncmanager.cts.CtsSyncManagerTest"	"testInitialSync"	""	"1: ui"	"public void testInitialSync() throws Exception {
        removeAllAccounts();

        mRpc.invoke(APP1_PACKAGE, rb -> rb.setClearSyncInvocations(
                ClearSyncInvocations.newBuilder()));

        // Add the first account, which will trigger an initial sync.
        addAccountAndLetInitialSyncRun(ACCOUNT_1_A, APP1_AUTHORITY);

        // Check the sync request parameters.

        Response res = mRpc.invoke(APP1_PACKAGE,
                rb -> rb.setGetSyncInvocations(GetSyncInvocations.newBuilder()));
        assertEquals(1, res.getSyncInvocations().getSyncInvocationsCount());

        SyncInvocation si = res.getSyncInvocations().getSyncInvocations(0);

        assertEquals(ACCOUNT_1_A.name, si.getAccountName());
        assertEquals(ACCOUNT_1_A.type, si.getAccountType());
        assertEquals(APP1_AUTHORITY, si.getAuthority());

        Bundle extras = ParcelUtils.fromBytes(si.getExtras().toByteArray());
        assertTrue(extras.getBoolean(ContentResolver.SYNC_EXTRAS_INITIALIZE));
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/syncmanager/src/android/content/syncmanager/cts/CtsSyncManagerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.content.syncmanager.cts.CtsSyncManagerTest"	"testSoftErrorRetriesActiveApp"	""	"1: ui"	"@FlakyTest
    public void testSoftErrorRetriesActiveApp() throws Exception {
        removeAllAccounts();

        // Let the initial sync happen.
        addAccountAndLetInitialSyncRun(ACCOUNT_1_A, APP1_AUTHORITY);

        writeSyncConfig(2, 1, 2, 3);

        clearSyncInvocations(APP1_PACKAGE);

        AmUtils.setStandbyBucket(APP1_PACKAGE, UsageStatsManager.STANDBY_BUCKET_ACTIVE);

        // Set soft error.
        mRpc.invoke(APP1_PACKAGE, rb ->
                rb.setSetResult(SetResult.newBuilder().setResult(Result.SOFT_ERROR)));

        Bundle b = makeBundle(
                ""testSoftErrorRetriesActiveApp"", true,
                ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);

        ContentResolver.requestSync(ACCOUNT_1_A, APP1_AUTHORITY, b);

        // First sync + 3 retries == 4, so should be called more than 4 times.
        // But it's active, so it should retry more than that.
        waitUntil(""Should retry more than 3 times."", DEFAULT_TIMEOUT_SECONDS, () -> {
            final Response res = mRpc.invoke(APP1_PACKAGE,
                    rb -> rb.setGetSyncInvocations(GetSyncInvocations.newBuilder()));
            final int calls = res.getSyncInvocations().getSyncInvocationsCount();
            Log.i(TAG, ""NumSyncInvocations="" + calls);
            return calls > 4; // Arbitrarily bigger than 4.
        });
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/syncmanager/src/android/content/syncmanager/cts/CtsSyncManagerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.content.syncmanager.cts.CtsSyncManagerTest"	"testExpeditedJobSync"	""	"1: ui"	"public void testExpeditedJobSync() throws Exception {
        setDozeState(false);
        removeAllAccounts();

        // Let the initial sync happen.
        addAccountAndLetInitialSyncRun(ACCOUNT_1_A, APP1_AUTHORITY);

        writeSyncConfig(2, 1, 2, 3);

        clearSyncInvocations(APP1_PACKAGE);

        AmUtils.setStandbyBucket(APP1_PACKAGE, UsageStatsManager.STANDBY_BUCKET_RARE);

        Bundle b = makeBundle(ContentResolver.SYNC_EXTRAS_SCHEDULE_AS_EXPEDITED_JOB, true,
                ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);

        ContentResolver.requestSync(ACCOUNT_1_A, APP1_AUTHORITY, b);

        waitUntil(""Expedited job sync didn't run in Doze"", 30, () -> {
            final Response res = mRpc.invoke(APP1_PACKAGE,
                    rb -> rb.setGetSyncInvocations(GetSyncInvocations.newBuilder()));
            final int calls = res.getSyncInvocations().getSyncInvocationsCount();
            Log.i(TAG, ""NumSyncInvocations="" + calls);
            return calls == 1;
        });
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/syncmanager/src/android/content/syncmanager/cts/CtsSyncManagerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.content.syncmanager.cts.CtsSyncManagerTest"	"testExpeditedJobSync_InDoze"	""	"1: ui"	"public void testExpeditedJobSync_InDoze() throws Exception {
        assumeTrue(isDozeFeatureEnabled());

        setDozeState(false);
        removeAllAccounts();

        // Let the initial sync happen.
        addAccountAndLetInitialSyncRun(ACCOUNT_1_A, APP1_AUTHORITY);

        writeSyncConfig(2, 1, 2, 3);

        clearSyncInvocations(APP1_PACKAGE);

        AmUtils.setStandbyBucket(APP1_PACKAGE, UsageStatsManager.STANDBY_BUCKET_RARE);

        setDozeState(true);
        Bundle b = makeBundle(ContentResolver.SYNC_EXTRAS_SCHEDULE_AS_EXPEDITED_JOB, true,
                ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);

        ContentResolver.requestSync(ACCOUNT_1_A, APP1_AUTHORITY, b);

        waitUntil(""Expedited job sync should still run in Doze"", 30, () -> {
            final Response res = mRpc.invoke(APP1_PACKAGE,
                    rb -> rb.setGetSyncInvocations(GetSyncInvocations.newBuilder()));
            final int calls = res.getSyncInvocations().getSyncInvocationsCount();
            Log.i(TAG, ""NumSyncInvocations="" + calls);
            return calls == 1;
        });
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/syncmanager/src/android/content/syncmanager/cts/CtsSyncManagerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.content.syncmanager.cts.CtsSyncManagerTest"	"testInitialSyncInNeverBucket"	""	"2: ui system"	"public void testInitialSyncInNeverBucket() throws Exception {
        removeAllAccounts();

        AmUtils.setStandbyBucket(APP1_PACKAGE, STANDBY_BUCKET_NEVER);

        mRpc.invoke(APP1_PACKAGE, rb -> rb.setClearSyncInvocations(
                ClearSyncInvocations.newBuilder()));

        addAccountAndLetInitialSyncRun(ACCOUNT_1_A, APP1_AUTHORITY);

        // App should be brought out of the NEVER bucket to handle the sync
        assertTrue(""Standby bucket should be WORKING_SET or better"",
                AmUtils.getStandbyBucket(APP1_PACKAGE)
                        <= UsageStatsManager.STANDBY_BUCKET_WORKING_SET);

        // Check the sync request parameters.
        Response res = mRpc.invoke(APP1_PACKAGE,
                rb -> rb.setGetSyncInvocations(GetSyncInvocations.newBuilder()));
        assertEquals(1, res.getSyncInvocations().getSyncInvocationsCount());

        SyncInvocation si = res.getSyncInvocations().getSyncInvocations(0);

        assertEquals(ACCOUNT_1_A.name, si.getAccountName());
        assertEquals(ACCOUNT_1_A.type, si.getAccountType());
        assertEquals(APP1_AUTHORITY, si.getAuthority());

        Bundle extras = ParcelUtils.fromBytes(si.getExtras().toByteArray());
        assertTrue(extras.getBoolean(ContentResolver.SYNC_EXTRAS_INITIALIZE));
    }

    private static boolean isDozeFeatureEnabled() {
        final String output = ShellUtils.runShellCommand(""cmd deviceidle enabled deep"").trim();
        return Integer.parseInt(output) != 0;
    }

    private void setDozeState(final boolean on) throws Exception {
        ShellUtils.runShellCommand(""cmd deviceidle "" + (on ? ""force-idle"" : ""unforce""));
        if (!on) {
            // Make sure the device doesn't stay idle, even after unforcing.
            ShellUtils.runShellCommand(""cmd deviceidle motion"");
        }
        final PowerManager powerManager =
                InstrumentationRegistry.getContext().getSystemService(PowerManager.class);
        waitUntil(""Doze mode didn't change to "" + (on ? ""on"" : ""off""), 10,
                () -> powerManager.isDeviceIdleMode() == on);
    }

    // WIP This test doesn't work yet.
//"	"/home/gpoor/cts-12-source/cts/tests/tests/syncmanager/src/android/content/syncmanager/cts/CtsSyncManagerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.content.syncmanager.cts.CtsSyncManagerTest"	"testSoftErrorRetriesFrequentApp"	""	"1: ui"	"//    public void testSoftErrorRetriesFrequentApp() throws Exception {
//        runTest(() -> {
//            removeAllAccounts();
//
//            // Let the initial sync happen.
//            addAccountAndLetInitialSyncRun(ACCOUNT_1_A, APP1_AUTHORITY);
//
//            writeSyncConfig(2, 1, 2, 3);
//
//            clearSyncInvocations(APP1_PACKAGE);
//
//            AmUtils.setStandbyBucket(APP1_PACKAGE, UsageStatsManager.STANDBY_BUCKET_FREQUENT);
//
//            // Set soft error.
//            mRpc.invoke(APP1_PACKAGE, rb ->
//                    rb.setSetResult(SetResult.newBuilder().setResult(Result.SOFT_ERROR)));
//
//            Bundle b = makeBundle(
//                    ""testSoftErrorRetriesFrequentApp"", true,
//                    ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);
//
//            ContentResolver.requestSync(ACCOUNT_1_A, APP1_AUTHORITY, b);
//
//            waitUntil(""Should retry more than 3 times."", () -> {
//                final Response res = mRpc.invoke(APP1_PACKAGE,
//                        rb -> rb.setGetSyncInvocations(GetSyncInvocations.newBuilder()));
//                final int calls =  res.getSyncInvocations().getSyncInvocationsCount();
//                Log.i(TAG, ""NumSyncInvocations="" + calls);
//                return calls >= 4; // First sync + 3 retries == 4, so at least 4 times.
//            });
//
//            Thread.sleep(10_000);
//
//            // One more retry is okay because of how the job scheduler throttle jobs, but no further.
//            final Response res = mRpc.invoke(APP1_PACKAGE,
//                    rb -> rb.setGetSyncInvocations(GetSyncInvocations.newBuilder()));
//            final int calls =  res.getSyncInvocations().getSyncInvocationsCount();
//            assertTrue(""# of syncs must be equal or less than 5, but was "" + calls, calls <= 5);
//        });
//    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/syncmanager/src/android/content/syncmanager/cts/CtsSyncManagerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.keystore.cts.AESCipherNistCavpKatTest"	"testCBCKeySbox256"	"CtsKeystoreTestCases"	"1: ui"	"public void testCBCKeySbox256() throws Exception {
        runTestsForKatFile(""CBCKeySbox256.rsp"");
    }

    private void runTestsForKatFile(String fileName) throws Exception {
        try (ZipInputStream zipIn = new ZipInputStream(
                getContext().getResources().getAssets().open(""nist_cavp_aes_kat.zip""))) {
            ZipEntry zipEntry;
            byte[] entryContents = null;
            while ((zipEntry = zipIn.getNextEntry()) != null) {
                String entryName = zipEntry.getName();

                // We have to read the contents of all entries because there's no way to skip an
                // entry without reading its contents.
                entryContents = new byte[(int) zipEntry.getSize()];
                readFully(zipIn, entryContents);

                if (fileName.equals(entryName)) {
                    break;
                }
            }

            if (entryContents == null) {
                fail(fileName + "" not found"");
                return;
            }

            String blockMode = fileName.substring(0, 3);
            if (""CFB"".equals(blockMode)) {
                blockMode = fileName.substring(0, 4);
            }
            runTestsForKatFile(blockMode, entryContents);
        }
    }

    private void runTestsForKatFile(String blockMode, byte[] fileContents) throws Exception {
        BufferedReader in = null;
        int testNumber = 0;
        try {
            in = new BufferedReader(new InputStreamReader(
                    new ByteArrayInputStream(fileContents), ""ISO-8859-1""));
            String line;
            int lineNumber = 0;
            String section = null; // ENCRYPT or DECRYPT

            boolean insideTestDefinition = false;
            TestVector testVector = null;

            while ((line = in.readLine()) != null) {
                lineNumber++;
                line = line.trim();
                if (line.startsWith(""#"")) {
                    // Ignore comment lines
                    continue;
                }

                if (!insideTestDefinition) {
                    // Outside of a test definition
                    if (line.length() == 0) {
                        // Ignore empty lines
                        continue;
                    }
                    if ((line.startsWith(""["")) && (line.endsWith(""]""))) {
                        section = line.substring(1, line.length() - 1);
                        if ((!""DECRYPT"".equals(section)) && (!""ENCRYPT"".equals(section))) {
                            throw new IOException(lineNumber + "": Unexpected section: "" + section);
                        }
                        continue;
                    }

                    // Check whether this is a NAME = VALUE line
                    int delimiterIndex = line.indexOf('=');
                    if (delimiterIndex == -1) {
                        throw new IOException(lineNumber + "": Unexpected line outside of test""
                                + "" definition: "" + line);
                    }
                    String name = line.substring(0, delimiterIndex).trim();
                    String value = line.substring(delimiterIndex + 1).trim();

                    if (""COUNT"".equals(name)) {
                        testNumber = Integer.parseInt(value);
                        insideTestDefinition = true;
                        testVector = new TestVector();
                    } else {
                        throw new IOException(lineNumber + "": Unexpected line outside of test""
                                + "" definition: "" + line);
                    }
                } else {
                    // Inside of a test definition
                    if (line.length() == 0) {
                        // End of test definition
                        boolean encrypt;
                        if (""ENCRYPT"".equals(section)) {
                            encrypt = true;
                        } else if (""DECRYPT"".equals(section)) {
                            encrypt = false;
                        } else {
                            throw new IOException(""Unexpected test operation: "" + section);
                        }
                        runKatTest(blockMode, encrypt, testVector);
                        insideTestDefinition = false;
                        testVector = null;
                    } else {
                        // Check whether this is a NAME = VALUE line
                        int delimiterIndex = line.indexOf('=');
                        if (delimiterIndex == -1) {
                            throw new IOException(lineNumber + "": Unexpected line inside test""
                                    + "" definition: "" + line);
                        }
                        String name = line.substring(0, delimiterIndex).trim();
                        String value = line.substring(delimiterIndex + 1).trim();

                        if (""KEY"".equals(name)) {
                            testVector.key = HexEncoding.decode(value);
                        } else if (""IV"".equals(name)) {
                            testVector.iv = HexEncoding.decode(value);
                        } else if (""PLAINTEXT"".equals(name)) {
                            testVector.plaintext = HexEncoding.decode(value);
                        } else if (""CIPHERTEXT"".equals(name)) {
                            testVector.ciphertext = HexEncoding.decode(value);
                        } else {
                            throw new IOException(lineNumber + "": Unexpected line inside test""
                                    + "" definition: "" + line);
                        }
                    }
                }
            }
        } catch (Throwable e) {
            throw new RuntimeException(""Test #"" + testNumber + "" failed"", e);
        } finally {
            if (in != null) {
                try {
                    in.close();
                } catch (Exception ignored) {}
            }
        }
    }

    private void runKatTest(String mode, boolean encrypt, TestVector testVector) throws Exception {
        String keyAlias = AESCipherNistCavpKatTest.class.getName();
        KeyStore keyStore = KeyStore.getInstance(""AndroidKeyStore"");
        keyStore.load(null);
        keyStore.setEntry(keyAlias,
                new KeyStore.SecretKeyEntry(new SecretKeySpec(testVector.key, ""AES"")),
                new KeyProtection.Builder(
                        KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)
                        .setBlockModes(mode)
                        .setEncryptionPaddings(""NoPadding"")
                        .setRandomizedEncryptionRequired(false)
                        .build());
        try {
            SecretKey key = (SecretKey) keyStore.getKey(keyAlias, null);
            assertNotNull(key);
            Cipher cipher = Cipher.getInstance(""AES/"" + mode + ""/NoPadding"");

            int opmode = (encrypt) ? Cipher.ENCRYPT_MODE : Cipher.DECRYPT_MODE;
            if (testVector.iv != null) {
                cipher.init(opmode, key, new IvParameterSpec(testVector.iv));
            } else {
                cipher.init(opmode, key);
            }

            byte[] input = (encrypt) ? testVector.plaintext : testVector.ciphertext;
            byte[] actualOutput = cipher.doFinal(input);
            byte[] expectedOutput = (encrypt) ? testVector.ciphertext : testVector.plaintext;
            if (!Arrays.equals(expectedOutput, actualOutput)) {
                fail(""Expected: "" + HexEncoding.encode(expectedOutput)
                        + "", actual: "" + HexEncoding.encode(actualOutput));
            }
        } finally {
            keyStore.deleteEntry(keyAlias);
        }
    }

    private static void readFully(InputStream in, byte[] buf) throws IOException {
        int offset = 0;
        int remaining = buf.length;
        while (remaining > 0) {
            int chunkSize = in.read(buf, offset, remaining);
            if (chunkSize == -1) {
                throw new EOFException(""Premature EOF. Remaining: "" + remaining);
            }
            offset += chunkSize;
            remaining -= chunkSize;
        }
    }

    private static class TestVector {
        public byte[] key;
        public byte[] iv;
        public byte[] plaintext;
        public byte[] ciphertext;
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/keystore/src/android/keystore/cts/AESCipherNistCavpKatTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.location.cts.gnss.asn1.supl2.rrlp_components.GANSSPositionMethod"	"isTagImplicit"	"CtsLocationGnssTestCases"	"1: ui"	"public void test/*
 *.
 */

package android.location.cts.asn1.supl2.rrlp_components;

/*
 */


//
//
import android.location.cts.asn1.base.Asn1Integer;
import android.location.cts.asn1.base.Asn1Null;
import android.location.cts.asn1.base.Asn1Object;
import android.location.cts.asn1.base.Asn1Sequence;
import android.location.cts.asn1.base.Asn1Tag;
import android.location.cts.asn1.base.BitStream;
import android.location.cts.asn1.base.BitStreamReader;
import android.location.cts.asn1.base.SequenceComponent;
import com.google.common.collect.ImmutableList;
import java.util.Collection;
import javax.annotation.Nullable;


/**
*/
public  class GANSSPositionMethod extends Asn1Sequence {
  //

  private static final Asn1Tag TAG_GANSSPositionMethod
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public GANSSPositionMethod() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_GANSSPositionMethod;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_GANSSPositionMethod != null) {
      return ImmutableList.of(TAG_GANSSPositionMethod);
    } else {
      return Asn1Sequence.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new GANSSPositionMethod from encoded stream.
   */
  public static GANSSPositionMethod fromPerUnaligned(byte[] encodedBytes) {
    GANSSPositionMethod result = new GANSSPositionMethod();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new GANSSPositionMethod from encoded stream.
   */
  public static GANSSPositionMethod fromPerAligned(byte[] encodedBytes) {
    GANSSPositionMethod result = new GANSSPositionMethod();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }



  @Override protected boolean isExtensible() {
    return true;
  }

  @Override public boolean containsExtensionValues() {
    for (SequenceComponent extensionComponent : getExtensionComponents()) {
      if (extensionComponent.isExplicitlySet()) return true;
    }
    return false;
  }

  
  private GANSSPositionMethod.ganssIDType ganssID_;
  public GANSSPositionMethod.ganssIDType getGanssID() {
    return ganssID_;
  }
  /**
   * @throws ClassCastException if value is not a GANSSPositionMethod.ganssIDType
   */
  public void setGanssID(Asn1Object value) {
    this.ganssID_ = (GANSSPositionMethod.ganssIDType) value;
  }
  public GANSSPositionMethod.ganssIDType setGanssIDToNewInstance() {
    ganssID_ = new GANSSPositionMethod.ganssIDType();
    return ganssID_;
  }
  
  private GANSSPositioningMethodTypes gANSSPositioningMethodTypes_;
  public GANSSPositioningMethodTypes getGANSSPositioningMethodTypes() {
    return gANSSPositioningMethodTypes_;
  }
  /**
   * @throws ClassCastException if value is not a GANSSPositioningMethodTypes
   */
  public void setGANSSPositioningMethodTypes(Asn1Object value) {
    this.gANSSPositioningMethodTypes_ = (GANSSPositioningMethodTypes) value;
  }
  public GANSSPositioningMethodTypes setGANSSPositioningMethodTypesToNewInstance() {
    gANSSPositioningMethodTypes_ = new GANSSPositioningMethodTypes();
    return gANSSPositioningMethodTypes_;
  }
  
  private GANSSSignals gANSSSignals_;
  public GANSSSignals getGANSSSignals() {
    return gANSSSignals_;
  }
  /**
   * @throws ClassCastException if value is not a GANSSSignals
   */
  public void setGANSSSignals(Asn1Object value) {
    this.gANSSSignals_ = (GANSSSignals) value;
  }
  public GANSSSignals setGANSSSignalsToNewInstance() {
    gANSSSignals_ = new GANSSSignals();
    return gANSSSignals_;
  }
  

  
  private SBASID  extensionSbasID;
  public SBASID getExtensionSbasID() {
    return extensionSbasID;
  }
  /**
   * @throws ClassCastException if value is not a SBASID
   */
  public void setExtensionSbasID(Asn1Object value) {
    extensionSbasID = (SBASID) value;
  }
  public void setExtensionSbasIDToNewInstance() {
    extensionSbasID = new SBASID();
  }
    

  

  @Override public Iterable<? extends SequenceComponent> getComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 0);

          @Override public boolean isExplicitlySet() {
            return getGanssID() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return true;
          }

          @Override public Asn1Object getComponentValue() {
            return getGanssID();
          }

          @Override public void setToNewInstance() {
            setGanssIDToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? GANSSPositionMethod.ganssIDType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""ganssID : ""
                    + getGanssID().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 1);

          @Override public boolean isExplicitlySet() {
            return getGANSSPositioningMethodTypes() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return true;
          }

          @Override public Asn1Object getComponentValue() {
            return getGANSSPositioningMethodTypes();
          }

          @Override public void setToNewInstance() {
            setGANSSPositioningMethodTypesToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? GANSSPositioningMethodTypes.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""gANSSPositioningMethodTypes : ""
                    + getGANSSPositioningMethodTypes().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 2);

          @Override public boolean isExplicitlySet() {
            return getGANSSSignals() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getGANSSSignals();
          }

          @Override public void setToNewInstance() {
            setGANSSSignalsToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? GANSSSignals.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""gANSSSignals : ""
                    + getGANSSSignals().toIndentedString(indent);
              }
        });
    
    return builder.build();
  }

  @Override public Iterable<? extends SequenceComponent>
                                                    getExtensionComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
      
      builder.add(new SequenceComponent() {
            @Override public boolean isExplicitlySet() {
              return getExtensionSbasID() != null;
            }

            @Override public boolean hasDefaultValue() {
              return false;
            }

            @Override public boolean isOptional() {
              return true;
            }

            @Override public Asn1Object getComponentValue() {
              return getExtensionSbasID();
            }

            @Override public void setToNewInstance() {
              setExtensionSbasIDToNewInstance();
            }

            @Override public Collection<Asn1Tag> getPossibleFirstTags() {
              throw new UnsupportedOperationException(
                  ""BER decoding not supported for extension elements"");
            }

            @Override
            public Asn1Tag getTag() {
              throw new UnsupportedOperationException(
                  ""BER is not supported for extension elements"");
            }

            @Override
            public boolean isImplicitTagging() {
              throw new UnsupportedOperationException(
                  ""BER is not supported for extension elements"");
            }

            @Override public String toIndentedString(String indent) {
              return ""sbasID : ""
                  + getExtensionSbasID().toIndentedString(indent);
            }
      });
      
      return builder.build();
    }

  
/*
 */


//

/**
 */
public static class ganssIDType extends Asn1Integer {
  //

  private static final Asn1Tag TAG_ganssIDType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public ganssIDType() {
    super();
    setValueRange(""0"", ""7"");

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_ganssIDType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_ganssIDType != null) {
      return ImmutableList.of(TAG_ganssIDType);
    } else {
      return Asn1Integer.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new ganssIDType from encoded stream.
   */
  public static ganssIDType fromPerUnaligned(byte[] encodedBytes) {
    ganssIDType result = new ganssIDType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new ganssIDType from encoded stream.
   */
  public static ganssIDType fromPerAligned(byte[] encodedBytes) {
    ganssIDType result = new ganssIDType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""ganssIDType = "" + getInteger() + "";\n"";
  }
}

  
  
  
  
  

    
    
    

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    StringBuilder builder = new StringBuilder();
    builder.append(""GANSSPositionMethod = {\n"");
    final String internalIndent = indent + ""  "";
    for (SequenceComponent component : getComponents()) {
      if (component.isExplicitlySet()) {
        builder.append(internalIndent)
            .append(component.toIndentedString(internalIndent));
      }
    }
    if (isExtensible()) {
      builder.append(internalIndent).append(""...\n"");
      for (SequenceComponent component : getExtensionComponents()) {
        if (component.isExplicitlySet()) {
          builder.append(internalIndent)
              .append(component.toIndentedString(internalIndent));
        }
      }
    }
    builder.append(indent).append(""};\n"");
    return builder.toString();
  }
}"	"/home/gpoor/cts-12-source/cts/tests/location/location_gnss/src/android/location/cts/gnss/asn1/supl2/rrlp_components/GANSSPositionMethod.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.verifier.biometrics.BiometricWeakTests"	"setPassFailButtonClickListeners"	""	"2: ui user"	"public void test/*
 *.
 */

package com.android.cts.verifier.biometrics;

import static android.hardware.biometrics.BiometricManager.Authenticators;

import android.hardware.biometrics.BiometricManager;
import android.os.Bundle;
import android.provider.Settings;
import android.widget.Button;

import com.android.cts.verifier.R;

/**
 * On devices without a weak biometric, ensure that the
 * {@link BiometricManager#canAuthenticate(int)} returns
 * {@link BiometricManager#BIOMETRIC_ERROR_NO_HARDWARE}
 *
 * Ensure that this result is consistent with the configuration in core/res/res/values/config.xml
 *
 * Ensure that invoking {@link Settings.ACTION_BIOMETRIC_ENROLL} with its corresponding
 * {@link Settings.EXTRA_BIOMETRIC_AUTHENTICATORS_ALLOWED} enrolls a biometric that meets or
 * exceeds {@link BiometricManager.Authenticators.BIOMETRIC_WEAK}.
 *
 * Ensure that the BiometricPrompt UI displays all fields in the public API surface.
 */

public class BiometricWeakTests extends AbstractBaseTest {
    private static final String TAG = ""BiometricWeakTests"";

    private Button mEnrollButton;

    private boolean mEnrollFinished;

    @Override
    protected String getTag() {
        return TAG;
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.biometric_test_weak_tests);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);

        mEnrollButton = findViewById(R.id.biometric_test_weak_enroll_button);

        mEnrollButton.setOnClickListener((view) -> {
            checkAndEnroll(mEnrollButton, Authenticators.BIOMETRIC_WEAK);
        });
    }

    @Override
    protected boolean isOnPauseAllowed() {
        // Test hasn't started yet, user may need to go to Settings to remove enrollments
        if (mEnrollButton.isEnabled()) {
            return true;
        }

        if (mCurrentlyEnrolling) {
            return true;
        }

        return false;
    }

    private void updatePassButton() {
        if (mEnrollFinished) {
            showToastAndLog(""All tests passed"");
            getPassButton().setEnabled(true);
        }
    }

    @Override
    protected void onBiometricEnrollFinished() {
        final int biometricStatus =
                mBiometricManager.canAuthenticate(Authenticators.BIOMETRIC_WEAK);
        if (biometricStatus == BiometricManager.BIOMETRIC_SUCCESS) {
            showToastAndLog(""Successfully enrolled, please continue the test"");
            mEnrollButton.setEnabled(false);
            mEnrollFinished = true;
            updatePassButton();
        } else {
            showToastAndLog(""Unexpected result after enrollment: "" + biometricStatus);
        }
    }
}"	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/biometrics/BiometricWeakTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.location.cts.gnss.asn1.supl2.ver2_ulp_components.SPCTID"	"isTagImplicit"	"CtsLocationGnssTestCases"	"1: ui"	"public void test/*
 *.
 */

package android.location.cts.asn1.supl2.ver2_ulp_components;

/*
 */


//
//
import android.location.cts.asn1.base.Asn1BitString;
import android.location.cts.asn1.base.Asn1Null;
import android.location.cts.asn1.base.Asn1Object;
import android.location.cts.asn1.base.Asn1Sequence;
import android.location.cts.asn1.base.Asn1Tag;
import android.location.cts.asn1.base.BitStream;
import android.location.cts.asn1.base.BitStreamReader;
import android.location.cts.asn1.base.SequenceComponent;
import android.location.cts.asn1.supl2.ulp_components.FQDN;
import com.google.common.collect.ImmutableList;
import java.util.Collection;
import javax.annotation.Nullable;


/**
*/
public  class SPCTID extends Asn1Sequence {
  //

  private static final Asn1Tag TAG_SPCTID
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public SPCTID() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_SPCTID;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_SPCTID != null) {
      return ImmutableList.of(TAG_SPCTID);
    } else {
      return Asn1Sequence.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new SPCTID from encoded stream.
   */
  public static SPCTID fromPerUnaligned(byte[] encodedBytes) {
    SPCTID result = new SPCTID();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new SPCTID from encoded stream.
   */
  public static SPCTID fromPerAligned(byte[] encodedBytes) {
    SPCTID result = new SPCTID();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }



  @Override protected boolean isExtensible() {
    return true;
  }

  @Override public boolean containsExtensionValues() {
    for (SequenceComponent extensionComponent : getExtensionComponents()) {
      if (extensionComponent.isExplicitlySet()) return true;
    }
    return false;
  }

  
  private SPCTID.rANDType rAND_;
  public SPCTID.rANDType getRAND() {
    return rAND_;
  }
  /**
   * @throws ClassCastException if value is not a SPCTID.rANDType
   */
  public void setRAND(Asn1Object value) {
    this.rAND_ = (SPCTID.rANDType) value;
  }
  public SPCTID.rANDType setRANDToNewInstance() {
    rAND_ = new SPCTID.rANDType();
    return rAND_;
  }
  
  private FQDN slpFQDN_;
  public FQDN getSlpFQDN() {
    return slpFQDN_;
  }
  /**
   * @throws ClassCastException if value is not a FQDN
   */
  public void setSlpFQDN(Asn1Object value) {
    this.slpFQDN_ = (FQDN) value;
  }
  public FQDN setSlpFQDNToNewInstance() {
    slpFQDN_ = new FQDN();
    return slpFQDN_;
  }
  

  

  

  @Override public Iterable<? extends SequenceComponent> getComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 0);

          @Override public boolean isExplicitlySet() {
            return getRAND() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getRAND();
          }

          @Override public void setToNewInstance() {
            setRANDToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SPCTID.rANDType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""rAND : ""
                    + getRAND().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 1);

          @Override public boolean isExplicitlySet() {
            return getSlpFQDN() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getSlpFQDN();
          }

          @Override public void setToNewInstance() {
            setSlpFQDNToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? FQDN.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""slpFQDN : ""
                    + getSlpFQDN().toIndentedString(indent);
              }
        });
    
    return builder.build();
  }

  @Override public Iterable<? extends SequenceComponent>
                                                    getExtensionComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
      
      return builder.build();
    }

  
/*
 */


//

/**
 */
public static class rANDType extends Asn1BitString {
  //

  private static final Asn1Tag TAG_rANDType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public rANDType() {
    super();
    setMinSize(128);
setMaxSize(128);

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_rANDType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_rANDType != null) {
      return ImmutableList.of(TAG_rANDType);
    } else {
      return Asn1BitString.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new rANDType from encoded stream.
   */
  public static rANDType fromPerUnaligned(byte[] encodedBytes) {
    rANDType result = new rANDType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new rANDType from encoded stream.
   */
  public static rANDType fromPerAligned(byte[] encodedBytes) {
    rANDType result = new rANDType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""rANDType = "" + getValue() + "";\n"";
  }
}

  
  
  

    

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    StringBuilder builder = new StringBuilder();
    builder.append(""SPCTID = {\n"");
    final String internalIndent = indent + ""  "";
    for (SequenceComponent component : getComponents()) {
      if (component.isExplicitlySet()) {
        builder.append(internalIndent)
            .append(component.toIndentedString(internalIndent));
      }
    }
    if (isExtensible()) {
      builder.append(internalIndent).append(""...\n"");
      for (SequenceComponent component : getExtensionComponents()) {
        if (component.isExplicitlySet()) {
          builder.append(internalIndent)
              .append(component.toIndentedString(internalIndent));
        }
      }
    }
    builder.append(indent).append(""};\n"");
    return builder.toString();
  }
}"	"/home/gpoor/cts-12-source/cts/tests/location/location_gnss/src/android/location/cts/gnss/asn1/supl2/ver2_ulp_components/SPCTID.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.location.cts.gnss.asn1.supl2.ulp_version_2_parameter_extensions.Ver2_PosTechnology_extension"	"isTagImplicit"	"CtsLocationGnssTestCases"	"1: ui"	"public void test/*
 *.
 */

package android.location.cts.asn1.supl2.ulp_version_2_parameter_extensions;

/*
 */


//
//
import android.location.cts.asn1.base.Asn1Null;
import android.location.cts.asn1.base.Asn1Object;
import android.location.cts.asn1.base.Asn1Sequence;
import android.location.cts.asn1.base.Asn1Tag;
import android.location.cts.asn1.base.BitStream;
import android.location.cts.asn1.base.BitStreamReader;
import android.location.cts.asn1.base.SequenceComponent;
import com.google.common.collect.ImmutableList;
import java.util.Collection;
import javax.annotation.Nullable;


/**
*/
public  class Ver2_PosTechnology_extension extends Asn1Sequence {
  //

  private static final Asn1Tag TAG_Ver2_PosTechnology_extension
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public Ver2_PosTechnology_extension() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_Ver2_PosTechnology_extension;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_Ver2_PosTechnology_extension != null) {
      return ImmutableList.of(TAG_Ver2_PosTechnology_extension);
    } else {
      return Asn1Sequence.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new Ver2_PosTechnology_extension from encoded stream.
   */
  public static Ver2_PosTechnology_extension fromPerUnaligned(byte[] encodedBytes) {
    Ver2_PosTechnology_extension result = new Ver2_PosTechnology_extension();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new Ver2_PosTechnology_extension from encoded stream.
   */
  public static Ver2_PosTechnology_extension fromPerAligned(byte[] encodedBytes) {
    Ver2_PosTechnology_extension result = new Ver2_PosTechnology_extension();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }



  @Override protected boolean isExtensible() {
    return true;
  }

  @Override public boolean containsExtensionValues() {
    for (SequenceComponent extensionComponent : getExtensionComponents()) {
      if (extensionComponent.isExplicitlySet()) return true;
    }
    return false;
  }

  
  private GANSSPositionMethods gANSSPositionMethods_;
  public GANSSPositionMethods getGANSSPositionMethods() {
    return gANSSPositionMethods_;
  }
  /**
   * @throws ClassCastException if value is not a GANSSPositionMethods
   */
  public void setGANSSPositionMethods(Asn1Object value) {
    this.gANSSPositionMethods_ = (GANSSPositionMethods) value;
  }
  public GANSSPositionMethods setGANSSPositionMethodsToNewInstance() {
    gANSSPositionMethods_ = new GANSSPositionMethods();
    return gANSSPositionMethods_;
  }
  

  

  

  @Override public Iterable<? extends SequenceComponent> getComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 0);

          @Override public boolean isExplicitlySet() {
            return getGANSSPositionMethods() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return true;
          }

          @Override public Asn1Object getComponentValue() {
            return getGANSSPositionMethods();
          }

          @Override public void setToNewInstance() {
            setGANSSPositionMethodsToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? GANSSPositionMethods.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""gANSSPositionMethods : ""
                    + getGANSSPositionMethods().toIndentedString(indent);
              }
        });
    
    return builder.build();
  }

  @Override public Iterable<? extends SequenceComponent>
                                                    getExtensionComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
      
      return builder.build();
    }

  
  
  

    

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    StringBuilder builder = new StringBuilder();
    builder.append(""Ver2_PosTechnology_extension = {\n"");
    final String internalIndent = indent + ""  "";
    for (SequenceComponent component : getComponents()) {
      if (component.isExplicitlySet()) {
        builder.append(internalIndent)
            .append(component.toIndentedString(internalIndent));
      }
    }
    if (isExtensible()) {
      builder.append(internalIndent).append(""...\n"");
      for (SequenceComponent component : getExtensionComponents()) {
        if (component.isExplicitlySet()) {
          builder.append(internalIndent)
              .append(component.toIndentedString(internalIndent));
        }
      }
    }
    builder.append(indent).append(""};\n"");
    return builder.toString();
  }
}"	"/home/gpoor/cts-12-source/cts/tests/location/location_gnss/src/android/location/cts/gnss/asn1/supl2/ulp_version_2_parameter_extensions/Ver2_PosTechnology_extension.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.autofillservice.cts.inline.InlineAugmentedAuthTest"	"InlineAugmentedAuthTest"	"CtsAutoFillServiceTestCases"	"2: ui user"	"/*
 *.
 */

package android.autofillservice.cts.inline;

import static android.app.Activity.RESULT_CANCELED;
import static android.app.Activity.RESULT_OK;
import static android.autofillservice.cts.testcore.AugmentedHelper.assertBasicRequestInfo;
import static android.autofillservice.cts.testcore.CannedFillResponse.NO_RESPONSE;
import static android.autofillservice.cts.testcore.Helper.ID_USERNAME;

import static com.google.common.truth.Truth.assertThat;

import android.autofillservice.cts.activities.AugmentedAuthActivity;
import android.autofillservice.cts.activities.AugmentedLoginActivity;
import android.autofillservice.cts.commontests.AugmentedAutofillAutoActivityLaunchTestCase;
import android.autofillservice.cts.testcore.AutofillActivityTestRule;
import android.autofillservice.cts.testcore.CannedAugmentedFillResponse;
import android.autofillservice.cts.testcore.CtsAugmentedAutofillService;
import android.content.IntentSender;
import android.platform.test.annotations.Presubmit;
import android.service.autofill.Dataset;
import android.view.autofill.AutofillId;
import android.view.autofill.AutofillValue;
import android.widget.EditText;

import org.junit.Test;

@Presubmit
public class InlineAugmentedAuthTest
        extends AugmentedAutofillAutoActivityLaunchTestCase<AugmentedLoginActivity> {

    protected AugmentedLoginActivity mActivity;

    public InlineAugmentedAuthTest() {
        super(getInlineUiBot());
    }

    @Override
    protected AutofillActivityTestRule<AugmentedLoginActivity> getActivityRule() {
        return new AutofillActivityTestRule<AugmentedLoginActivity>(AugmentedLoginActivity.class) {
            @Override
            protected void afterActivityLaunched() {
                mActivity = getActivity();
            }
        };
    }"	"/home/gpoor/cts-12-source/cts/tests/autofillservice/src/android/autofillservice/cts/inline/InlineAugmentedAuthTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.autofillservice.cts.inline.InlineAugmentedAuthTest"	"testDatasetAuth_resultOk_validDataset"	"CtsAutoFillServiceTestCases"	"2: ui user"	"public void testDatasetAuth_resultOk_validDataset() throws Exception {
        // Set services
        enableService();
        enableAugmentedService();

        // Set expectations
        final EditText unField = mActivity.getUsername();
        final AutofillId unFieldId = unField.getAutofillId();
        final AutofillValue unValue = unField.getAutofillValue();
        sReplier.addResponse(NO_RESPONSE);
        Dataset authResult = new Dataset.Builder(createInlinePresentation(""auth""))
                .setId(""dummyId"")
                .setValue(unFieldId, AutofillValue.forText(""Auth Result""))
                .build();
        IntentSender authAction = AugmentedAuthActivity.createSender(mContext, 1,
                authResult, null, RESULT_OK);
        sAugmentedReplier.addResponse(new CannedAugmentedFillResponse.Builder()
                .setDataset(new CannedAugmentedFillResponse.Dataset.Builder(""bla"").build(),
                        unFieldId)
                .addInlineSuggestion(new CannedAugmentedFillResponse.Dataset.Builder(""inline"")
                        .setField(unFieldId, ""John Smith"", createInlinePresentation(""John""))
                        .setAuthentication(authAction)
                        .build())
                .build());

        // Trigger autofill request
        mUiBot.selectByRelativeId(ID_USERNAME);
        mUiBot.waitForIdle();
        sReplier.getNextFillRequest();
        CtsAugmentedAutofillService.AugmentedFillRequest request1 =
                sAugmentedReplier.getNextFillRequest();

        // Assert request
        assertBasicRequestInfo(request1, mActivity, unFieldId, unValue);

        // Confirm suggestions
        mUiBot.assertDatasets(""John"");

        // Tap on suggestion
        mUiBot.selectDataset(""John"");
        mUiBot.waitForIdle();

        // Tap on the auth activity button and assert that the dataset from the auth activity is
        // filled into the field.
        mActivity.expectAutoFill(""Auth Result"");
        mUiBot.selectByRelativeId(AugmentedAuthActivity.ID_AUTH_ACTIVITY_BUTTON);
        mUiBot.waitForIdle();
        mActivity.assertAutoFilled();
        assertThat(unField.getText().toString()).isEqualTo(""Auth Result"");
        mUiBot.assertNoDatasets();
    }"	"/home/gpoor/cts-12-source/cts/tests/autofillservice/src/android/autofillservice/cts/inline/InlineAugmentedAuthTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.autofillservice.cts.inline.InlineAugmentedAuthTest"	"testDatasetAuth_resultOk_nullDataset"	"CtsAutoFillServiceTestCases"	"2: ui user"	"public void testDatasetAuth_resultOk_nullDataset() throws Exception {
        // Set services
        enableService();
        enableAugmentedService();

        // Set expectations
        final EditText unField = mActivity.getUsername();
        final AutofillId unFieldId = unField.getAutofillId();
        final AutofillValue unValue = unField.getAutofillValue();
        sReplier.addResponse(NO_RESPONSE);
        IntentSender authAction = AugmentedAuthActivity.createSender(mContext, 1,
                null, null, RESULT_OK);
        sAugmentedReplier.addResponse(new CannedAugmentedFillResponse.Builder()
                .setDataset(new CannedAugmentedFillResponse.Dataset.Builder(""bla"").build(),
                        unFieldId)
                .addInlineSuggestion(new CannedAugmentedFillResponse.Dataset.Builder(""inline"")
                        .setField(unFieldId, ""John Smith"", createInlinePresentation(""John""))
                        .setAuthentication(authAction)
                        .build())
                .build());

        // Trigger autofill request
        mUiBot.selectByRelativeId(ID_USERNAME);
        mUiBot.waitForIdle();
        sReplier.getNextFillRequest();
        CtsAugmentedAutofillService.AugmentedFillRequest request1 =
                sAugmentedReplier.getNextFillRequest();

        // Assert request
        assertBasicRequestInfo(request1, mActivity, unFieldId, unValue);

        // Confirm suggestions
        mUiBot.assertDatasets(""John"");

        // Tap on suggestion
        mUiBot.selectDataset(""John"");
        mUiBot.waitForIdle();

        // Tap on the auth activity button and assert that the field is left unchanged (since the
        // dataset returned from the auth activity is null).
        mUiBot.selectByRelativeId(AugmentedAuthActivity.ID_AUTH_ACTIVITY_BUTTON);
        mUiBot.waitForIdle();
        assertThat(unField.getText().toString()).isEqualTo("""");
    }"	"/home/gpoor/cts-12-source/cts/tests/autofillservice/src/android/autofillservice/cts/inline/InlineAugmentedAuthTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.autofillservice.cts.inline.InlineAugmentedAuthTest"	"testDatasetAuth_resultCancel"	"CtsAutoFillServiceTestCases"	"2: ui user"	"public void testDatasetAuth_resultCancel() throws Exception {
        // Set services
        enableService();
        enableAugmentedService();

        // Set expectations
        final EditText unField = mActivity.getUsername();
        final AutofillId unFieldId = unField.getAutofillId();
        final AutofillValue unValue = unField.getAutofillValue();
        sReplier.addResponse(NO_RESPONSE);
        Dataset authResult = new Dataset.Builder(createInlinePresentation(""auth""))
                .setId(""dummyId"")
                .setValue(unFieldId, AutofillValue.forText(""Auth Result""))
                .build();
        IntentSender authAction = AugmentedAuthActivity.createSender(mContext, 1,
                authResult, null, RESULT_CANCELED);
        sAugmentedReplier.addResponse(new CannedAugmentedFillResponse.Builder()
                .setDataset(new CannedAugmentedFillResponse.Dataset.Builder(""bla"").build(),
                        unFieldId)
                .addInlineSuggestion(new CannedAugmentedFillResponse.Dataset.Builder(""inline"")
                        .setField(unFieldId, ""John Smith"", createInlinePresentation(""John""))
                        .setAuthentication(authAction)
                        .build())
                .build());

        // Trigger autofill request
        mUiBot.selectByRelativeId(ID_USERNAME);
        mUiBot.waitForIdle();
        sReplier.getNextFillRequest();
        CtsAugmentedAutofillService.AugmentedFillRequest request1 =
                sAugmentedReplier.getNextFillRequest();

        // Assert request
        assertBasicRequestInfo(request1, mActivity, unFieldId, unValue);

        // Confirm suggestions
        mUiBot.assertDatasets(""John"");

        // Tap on suggestion
        mUiBot.selectDataset(""John"");
        mUiBot.waitForIdle();

        // Tap on the auth activity button and assert that the field is left unchanged (since the
        // result code returned by the auth activity is RESULT_CANCELED).
        mUiBot.selectByRelativeId(AugmentedAuthActivity.ID_AUTH_ACTIVITY_BUTTON);
        mUiBot.waitForIdle();
        assertThat(unField.getText().toString()).isEqualTo("""");

        // Return from the auth activity to login activity, if the login onResume() is prior to
        // the test finished, there is another FillRequest() will be received. Because it may
        // notifyViewEntered() in onResume().
        mUiBot.assertShownByRelativeId(ID_USERNAME);
        sAugmentedReplier.getNextFillRequest();
    }
}"	"/home/gpoor/cts-12-source/cts/tests/autofillservice/src/android/autofillservice/cts/inline/InlineAugmentedAuthTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.mediastorageapp.MediaStorageTest"	"testLegacy"	""	"2: direct system"	"public void testLegacy() throws Exception {
        assertTrue(Environment.isExternalStorageLegacy());

        // We can always see mounted state
        assertEquals(Environment.MEDIA_MOUNTED, Environment.getExternalStorageState());

        // We might have top-level access
        final File probe = new File(Environment.getExternalStorageDirectory(),
                ""cts"" + System.nanoTime());
        assertTrue(probe.createNewFile());
        assertNotNull(Environment.getExternalStorageDirectory().list());

        // We always have our package directories
        final File probePackage = new File(mContext.getExternalFilesDir(null),
                ""cts"" + System.nanoTime());
        assertTrue(probePackage.createNewFile());

        assertTrue(TEST_JPG.exists());
        assertTrue(TEST_PDF.exists());

        final Uri jpgUri = MediaStore.scanFile(mContentResolver, TEST_JPG);
        final Uri pdfUri = MediaStore.scanFile(mContentResolver, TEST_PDF);

        final HashSet<Long> seen = new HashSet<>();
        try (Cursor c = mContentResolver.query(
                MediaStore.Files.getContentUri(MediaStore.VOLUME_EXTERNAL),
                new String[] { MediaColumns._ID }, null, null)) {
            while (c.moveToNext()) {
                seen.add(c.getLong(0));
            }
        }

        assertTrue(seen.contains(ContentUris.parseId(jpgUri)));
        assertTrue(seen.contains(ContentUris.parseId(pdfUri)));
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/MediaStorageApp/src/com/android/cts/mediastorageapp/MediaStorageTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.mediastorageapp.MediaStorageTest"	"testMediaEscalation_RequestWriteFilePathSupport"	""	"4: direct ui system user"	"public void testMediaEscalation_RequestWriteFilePathSupport() throws Exception {
        doMediaEscalation_RequestWrite_withFilePathSupport(MediaStorageTest::createAudio);
        doMediaEscalation_RequestWrite_withFilePathSupport(MediaStorageTest::createVideo);
        doMediaEscalation_RequestWrite_withFilePathSupport(MediaStorageTest::createImage);
        doMediaEscalation_RequestWrite_withFilePathSupport(MediaStorageTest::createPlaylist);
        doMediaEscalation_RequestWrite_withFilePathSupport(MediaStorageTest::createSubtitle);
    }

    private void doMediaEscalation_RequestWrite_withFilePathSupport(
            Callable<Uri> create) throws Exception {
        final Uri red = create.call();
        assertNotNull(red);
        String path = queryForSingleColumn(red, MediaColumns.DATA);
        File file = new File(path);
        assertThat(file.exists()).isTrue();
        assertThat(file.canRead()).isTrue();
        assertThat(file.canWrite()).isTrue();

        clearMediaOwner(red, mUserId);
        assertThat(file.canWrite()).isFalse();

        try (ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(red, ""w"")) {
            fail(""Expected write access to be blocked"");
        } catch (SecurityException expected) {
        }

        doEscalation(MediaStore.createWriteRequest(mContentResolver, Arrays.asList(red)));

        try (ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(red, ""w"")) {
        }
        // Wait for MediaStore to be idle to avoid flakiness due to race conditions between
        // MediaStore.scanFile (which is called above in #openFileDescriptor) and rename (which is
        // called below). This is a known issue: b/158982091
        MediaStore.waitForIdle(mContentResolver);

        // Check File API support
        assertAccessFileAPISupport(file);
        assertReadWriteFileAPISupport(file);
        assertRenameFileAPISupport(file);
        assertDeleteFileAPISupport(file);
    }

    private void assertAccessFileAPISupport(File file) throws Exception {
        assertThat(file.canRead()).isTrue();
        assertThat(file.canWrite()).isTrue();
    }

    private void assertReadWriteFileAPISupport(File file) throws Exception {
        final String str = ""Just some random text"";
        final byte[] bytes = str.getBytes();
        // Write to file
        try (FileOutputStream fos = new FileOutputStream(file)) {
            fos.write(bytes);
        }
        // Read the same data from file
        try (FileInputStream fis = new FileInputStream(file)) {
            assertThat(ByteStreams.toByteArray(fis)).isEqualTo(bytes);
        }
    }

    public void assertRenameFileAPISupport(File oldFile) throws Exception {
        final String oldName = oldFile.getAbsolutePath();
        final String extension = oldName.substring(oldName.lastIndexOf('.')).trim();
        // TODO(b/178816495): Changing the extension changes the media-type and hence the media-URI
        // corresponding to the new file is not accessible to the caller. Rename to the same
        // extension so that the test app does not lose access and is able to delete the file.
        final String newName = ""cts"" + System.nanoTime() + extension;
        final File newFile = Environment.buildPath(Environment.getExternalStorageDirectory(),
                Environment.DIRECTORY_DOWNLOADS, newName);
        assertThat(oldFile.renameTo(newFile)).isTrue();
        // Rename back to oldFile for other ops like delete
        assertThat(newFile.renameTo(oldFile)).isTrue();
    }

    private void assertDeleteFileAPISupport(File file) throws Exception {
        assertThat(file.delete()).isTrue();
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/MediaStorageApp/src/com/android/cts/mediastorageapp/MediaStorageTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.mediastorageapp.MediaStorageTest"	"testMediaEscalation_RequestDelete_notShowConfirmDialog"	""	"3: ui system user"	"public void testMediaEscalation_RequestDelete_notShowConfirmDialog() throws Exception {
        doMediaEscalation_RequestDelete(true /* allowAccess */,
                true /* shouldCheckDialogShownValue */, false /* isDialogShownExpected */);
    }

    private void doMediaEscalation_RequestDelete(boolean allowAccess,
            boolean shouldCheckDialogShownValue, boolean isDialogShownExpected) throws Exception {
        doMediaEscalation_RequestDelete(MediaStorageTest::createAudio, allowAccess,
                shouldCheckDialogShownValue, isDialogShownExpected);
        doMediaEscalation_RequestDelete(MediaStorageTest::createVideo, allowAccess,
                shouldCheckDialogShownValue, isDialogShownExpected);
        doMediaEscalation_RequestDelete(MediaStorageTest::createImage, allowAccess,
                shouldCheckDialogShownValue, isDialogShownExpected);
        doMediaEscalation_RequestDelete(MediaStorageTest::createPlaylist, allowAccess,
                shouldCheckDialogShownValue, isDialogShownExpected);
        doMediaEscalation_RequestDelete(MediaStorageTest::createSubtitle, allowAccess,
                shouldCheckDialogShownValue, isDialogShownExpected);
    }

    private void doMediaEscalation_RequestDelete(Callable<Uri> create, boolean allowAccess,
            boolean shouldCheckDialogShownValue, boolean isDialogShownExpected) throws Exception {
        final Uri red = create.call();
        clearMediaOwner(red, mUserId);

        try (Cursor c = mContentResolver.query(red, null, null, null)) {
            assertEquals(1, c.getCount());
        }

        if (allowAccess) {
            doEscalation(MediaStore.createDeleteRequest(mContentResolver, Arrays.asList(red)),
                    true /* allowAccess */, shouldCheckDialogShownValue, isDialogShownExpected);
            try (Cursor c = mContentResolver.query(red, null, null, null)) {
                assertEquals(0, c.getCount());
            }
        } else {
            doEscalation(MediaStore.createDeleteRequest(mContentResolver, Arrays.asList(red)),
                    false /* allowAccess */, shouldCheckDialogShownValue, isDialogShownExpected);
            try (Cursor c = mContentResolver.query(red, null, null, null)) {
                assertEquals(1, c.getCount());
            }
        }
    }

    private void doEscalation(RecoverableSecurityException exception) throws Exception {
        doEscalation(exception.getUserAction().getActionIntent());
    }

    private void doEscalation(PendingIntent pi) throws Exception {
        doEscalation(pi, true /* allowAccess */, false /* shouldCheckDialogShownValue */,
                false /* isDialogShownExpectedExpected */);
    }

    private void doEscalation(PendingIntent pi, boolean allowAccess,
            boolean shouldCheckDialogShownValue, boolean isDialogShownExpected) throws Exception {
        // Try launching the action to grant ourselves access
        final Instrumentation inst = InstrumentationRegistry.getInstrumentation();
        final Intent intent = new Intent(inst.getContext(), GetResultActivity.class);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);

        // Wake up the device and dismiss the keyguard before the test starts
        final UiDevice device = UiDevice.getInstance(inst);
        device.executeShellCommand(""input keyevent KEYCODE_WAKEUP"");
        device.executeShellCommand(""wm dismiss-keyguard"");

        final GetResultActivity activity = (GetResultActivity) inst.startActivitySync(intent);
        // Wait for the UI Thread to become idle.
        inst.waitForIdleSync();
        activity.clearResult();
        device.waitForIdle();
        activity.startIntentSenderForResult(pi.getIntentSender(), 42, null, 0, 0, 0);

        device.waitForIdle();
        final long timeout = 5_000;
        if (allowAccess) {
            // Some dialogs may have granted access automatically, so we're willing
            // to keep rolling forward if we can't find our grant button
            final UiSelector grant = new UiSelector().textMatches(""(?i)Allow"");
            if (isWatch()) {
                UiScrollable uiScrollable = new UiScrollable(new UiSelector().scrollable(true));
                try {
                    uiScrollable.scrollIntoView(grant);
                } catch (UiObjectNotFoundException e) {
                    // Scrolling can fail if the UI is not scrollable
                }
            }
            final boolean grantExists = new UiObject(grant).waitForExists(timeout);

            if (shouldCheckDialogShownValue) {
                assertThat(grantExists).isEqualTo(isDialogShownExpected);
            }

            if (grantExists) {
                device.findObject(grant).click();
            }
            final GetResultActivity.Result res = activity.getResult();
            // Verify that we now have access
            assertEquals(Activity.RESULT_OK, res.resultCode);
        } else {
            // fine the Deny button
            final UiSelector deny = new UiSelector().textMatches(""(?i)Deny"");
            final boolean denyExists = new UiObject(deny).waitForExists(timeout);

            assertThat(denyExists).isTrue();

            device.findObject(deny).click();

            final GetResultActivity.Result res = activity.getResult();
            // Verify that we don't have access
            assertEquals(Activity.RESULT_CANCELED, res.resultCode);
        }
    }

    private static Uri createAudio() throws IOException {
        final Context context = InstrumentationRegistry.getTargetContext();
        final String displayName = ""cts"" + System.nanoTime();
        final PendingParams params = new PendingParams(
                MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, displayName, ""audio/mpeg"");
        final Uri pendingUri = MediaStoreUtils.createPending(context, params);
        try (PendingSession session = MediaStoreUtils.openPending(context, pendingUri)) {
            try (InputStream in = context.getResources().getAssets().open(""testmp3.mp3"");
                    OutputStream out = session.openOutputStream()) {
                FileUtils.copy(in, out);
            }
            return session.publish();
        }
    }

    private static Uri createVideo() throws IOException {
        final Context context = InstrumentationRegistry.getTargetContext();
        final String displayName = ""cts"" + System.nanoTime();
        final PendingParams params = new PendingParams(
                MediaStore.Video.Media.EXTERNAL_CONTENT_URI, displayName, ""video/mpeg"");
        final Uri pendingUri = MediaStoreUtils.createPending(context, params);
        try (PendingSession session = MediaStoreUtils.openPending(context, pendingUri)) {
            try (InputStream in = context.getResources().getAssets().open(""testmp3.mp3"");
                    OutputStream out = session.openOutputStream()) {
                FileUtils.copy(in, out);
            }
            return session.publish();
        }
    }

    private static Uri createImage() throws IOException {
        final Context context = InstrumentationRegistry.getTargetContext();
        final String displayName = ""cts"" + System.nanoTime();
        final PendingParams params = new PendingParams(
                MediaStore.Images.Media.EXTERNAL_CONTENT_URI, displayName, ""image/png"");
        final Uri pendingUri = MediaStoreUtils.createPending(context, params);
        try (PendingSession session = MediaStoreUtils.openPending(context, pendingUri)) {
            try (OutputStream out = session.openOutputStream()) {
                final Bitmap bitmap = Bitmap.createBitmap(32, 32, Bitmap.Config.ARGB_8888);
                bitmap.compress(Bitmap.CompressFormat.PNG, 90, out);
            }
            return session.publish();
        }
    }

    private static Uri createPlaylist() throws IOException {
        final Context context = InstrumentationRegistry.getTargetContext();
        final String displayName = ""cts"" + System.nanoTime();
        final PendingParams params = new PendingParams(
                MediaStore.Audio.Playlists.EXTERNAL_CONTENT_URI, displayName, ""audio/mpegurl"");
        final Uri pendingUri = MediaStoreUtils.createPending(context, params);
        try (PendingSession session = MediaStoreUtils.openPending(context, pendingUri)) {
            return session.publish();
        }
    }

    private static Uri createSubtitle() throws IOException {
        final Context context = InstrumentationRegistry.getTargetContext();
        final String displayName = ""cts"" + System.nanoTime();
        final PendingParams params = new PendingParams(
                MediaStore.Files.getContentUri(MediaStore.VOLUME_EXTERNAL), displayName,
                ""application/x-subrip"");
        final Uri pendingUri = MediaStoreUtils.createPending(context, params);
        try (PendingSession session = MediaStoreUtils.openPending(context, pendingUri)) {
            try (InputStream in = context.getResources().getAssets().open(""testmp3.mp3"");
                 OutputStream out = session.openOutputStream()) {
                 FileUtils.copy(in, out);
            }
            return session.publish();
        }
    }

    private static String queryForSingleColumn(Uri uri, String column) throws Exception {
        final ContentResolver resolver = InstrumentationRegistry.getTargetContext()
                .getContentResolver();
        try (Cursor c = resolver.query(uri, new String[] { column }, null, null)) {
            assertEquals(1, c.getCount());
            assertTrue(c.moveToFirst());
            return c.getString(0);
        }
    }

    private static void clearMediaOwner(Uri uri, int userId) throws IOException {
        final String cmd = String.format(
                ""content update --uri %s --user %d --bind owner_package_name:n:"",
                uri, userId);
        runShellCommand(InstrumentationRegistry.getInstrumentation(), cmd);
    }

    static File stageFile(File file) throws Exception {
        // Sometimes file creation fails due to slow permission update, try more times
        while(currentAttempt < MAX_NUMBER_OF_ATTEMPT) {
            try {
                file.getParentFile().mkdirs();
                file.createNewFile();
                return file;
            } catch(IOException e) {
                currentAttempt++;
                // wait 500ms
                Thread.sleep(500);
            }
        }
        throw new TimeoutException(""File creation failed due to slow permission update"");
    }

    private boolean isWatch() {
        return hasFeature(PackageManager.FEATURE_WATCH);
    }

    private boolean hasFeature(String feature) {
        return mContext.getPackageManager().hasSystemFeature(feature);
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/MediaStorageApp/src/com/android/cts/mediastorageapp/MediaStorageTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.mediastorageapp.MediaStorageTest"	"testMediaEscalation_Update"	""	"2: system user"	"public void testMediaEscalation_Update() throws Exception {
        doMediaEscalation_Update(MediaStorageTest::createAudio);
        doMediaEscalation_Update(MediaStorageTest::createVideo);
        doMediaEscalation_Update(MediaStorageTest::createImage);
    }

    private void doMediaEscalation_Update(Callable<Uri> create) throws Exception {
        final Uri red = create.call();
        clearMediaOwner(red, mUserId);

        final ContentValues values = new ContentValues();
        values.put(MediaColumns.DISPLAY_NAME, ""cts"" + System.nanoTime());

        RecoverableSecurityException exception = null;
        try {
            mContentResolver.update(red, values, null, null);
            fail(""Expected update access to be blocked"");
        } catch (RecoverableSecurityException expected) {
            exception = expected;
        }

        doEscalation(exception);

        assertEquals(1, mContentResolver.update(red, values, null, null));
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/MediaStorageApp/src/com/android/cts/mediastorageapp/MediaStorageTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.mediastorageapp.MediaStorageTest"	"testMediaNone"	""	"1: user"	"public void testMediaNone() throws Exception {
        doMediaNone(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, MediaStorageTest::createAudio);
        doMediaNone(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, MediaStorageTest::createVideo);
        doMediaNone(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, MediaStorageTest::createImage);

        // But since we don't hold the Music permission, we can't read the
        // indexed metadata
        try (Cursor c = mContentResolver.query(MediaStore.Audio.Artists.EXTERNAL_CONTENT_URI,
                null, null, null)) {
            assertEquals(0, c.getCount());
        }
        try (Cursor c = mContentResolver.query(MediaStore.Audio.Albums.EXTERNAL_CONTENT_URI,
                null, null, null)) {
            assertEquals(0, c.getCount());
        }
        try (Cursor c = mContentResolver.query(MediaStore.Audio.Genres.EXTERNAL_CONTENT_URI,
                null, null, null)) {
            assertEquals(0, c.getCount());
        }
    }

    private void doMediaNone(Uri collection, Callable<Uri> create) throws Exception {
        final Uri red = create.call();
        final Uri blue = create.call();

        clearMediaOwner(blue, mUserId);

        // Since we have no permissions, we should only be able to see media
        // that we've contributed
        final HashSet<Long> seen = new HashSet<>();
        try (Cursor c = mContentResolver.query(collection,
                new String[] { MediaColumns._ID }, null, null)) {
            while (c.moveToNext()) {
                seen.add(c.getLong(0));
            }
        }

        assertTrue(seen.contains(ContentUris.parseId(red)));
        assertFalse(seen.contains(ContentUris.parseId(blue)));

        try (ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(red, ""rw"")) {
        }
        try (ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(blue, ""r"")) {
            fail(""Expected read access to be blocked"");
        } catch (SecurityException | FileNotFoundException expected) {
        }
        try (ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(blue, ""w"")) {
            fail(""Expected write access to be blocked"");
        } catch (SecurityException | FileNotFoundException expected) {
        }

        // Verify that we can't grant ourselves access
        for (int flag : new int[] {
                Intent.FLAG_GRANT_READ_URI_PERMISSION,
                Intent.FLAG_GRANT_WRITE_URI_PERMISSION
        }) {
            try {
                mContext.grantUriPermission(mContext.getPackageName(), blue, flag);
                fail(""Expected granting to be blocked for flag 0x"" + Integer.toHexString(flag));
            } catch (SecurityException expected) {
            }
        }
    }

    /**
     * Test prefix and non-prefix uri grant for all packages
     */"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/MediaStorageApp/src/com/android/cts/mediastorageapp/MediaStorageTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.mediastorageapp.MediaStorageTest"	"testMediaRead"	""	"1: user"	"public void testMediaRead() throws Exception {
        doMediaRead(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, MediaStorageTest::createAudio);
        doMediaRead(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, MediaStorageTest::createVideo);
        doMediaRead(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, MediaStorageTest::createImage);
    }

    private void doMediaRead(Uri collection, Callable<Uri> create) throws Exception {
        final Uri red = create.call();
        final Uri blue = create.call();

        clearMediaOwner(blue, mUserId);

        // Holding read permission we can see items we don't own
        final HashSet<Long> seen = new HashSet<>();
        try (Cursor c = mContentResolver.query(collection,
                new String[] { MediaColumns._ID }, null, null)) {
            while (c.moveToNext()) {
                seen.add(c.getLong(0));
            }
        }

        assertTrue(seen.contains(ContentUris.parseId(red)));
        assertTrue(seen.contains(ContentUris.parseId(blue)));

        try (ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(red, ""rw"")) {
        }
        try (ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(blue, ""r"")) {
        }
        try (ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(blue, ""w"")) {
            fail(""Expected write access to be blocked"");
        } catch (SecurityException | FileNotFoundException expected) {
        }
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/MediaStorageApp/src/com/android/cts/mediastorageapp/MediaStorageTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.mediastorageapp.MediaStorageTest"	"testMediaWrite"	""	"1: user"	"public void testMediaWrite() throws Exception {
        doMediaWrite(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, MediaStorageTest::createAudio);
        doMediaWrite(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, MediaStorageTest::createVideo);
        doMediaWrite(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, MediaStorageTest::createImage);
    }

    private void doMediaWrite(Uri collection, Callable<Uri> create) throws Exception {
        final Uri red = create.call();
        final Uri blue = create.call();

        clearMediaOwner(blue, mUserId);

        // Holding read permission we can see items we don't own
        final HashSet<Long> seen = new HashSet<>();
        try (Cursor c = mContentResolver.query(collection,
                new String[] { MediaColumns._ID }, null, null)) {
            while (c.moveToNext()) {
                seen.add(c.getLong(0));
            }
        }

        assertTrue(seen.contains(ContentUris.parseId(red)));
        assertTrue(seen.contains(ContentUris.parseId(blue)));

        try (ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(red, ""rw"")) {
        }
        try (ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(blue, ""r"")) {
        }
        if (Environment.isExternalStorageLegacy()) {
            try (ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(blue, ""w"")) {
            }
        } else {
            try (ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(blue, ""w"")) {
                fail(""Expected write access to be blocked"");
            } catch (SecurityException | FileNotFoundException expected) {
            }
        }
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/MediaStorageApp/src/com/android/cts/mediastorageapp/MediaStorageTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.mediastorageapp.MediaStorageTest"	"testMediaEscalation_Open"	""	"1: user"	"public void testMediaEscalation_Open() throws Exception {
        doMediaEscalation_Open(MediaStorageTest::createAudio);
        doMediaEscalation_Open(MediaStorageTest::createVideo);
        doMediaEscalation_Open(MediaStorageTest::createImage);
    }

    private void doMediaEscalation_Open(Callable<Uri> create) throws Exception {
        final Uri red = create.call();
        clearMediaOwner(red, mUserId);

        RecoverableSecurityException exception = null;
        try (ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(red, ""w"")) {
            fail(""Expected write access to be blocked"");
        } catch (RecoverableSecurityException expected) {
            exception = expected;
        }

        doEscalation(exception);

        try (ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(red, ""w"")) {
        }
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/MediaStorageApp/src/com/android/cts/mediastorageapp/MediaStorageTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.mediastorageapp.MediaStorageTest"	"testMediaEscalation_Delete"	""	"1: user"	"public void testMediaEscalation_Delete() throws Exception {
        doMediaEscalation_Delete(MediaStorageTest::createAudio);
        doMediaEscalation_Delete(MediaStorageTest::createVideo);
        doMediaEscalation_Delete(MediaStorageTest::createImage);
    }

    private void doMediaEscalation_Delete(Callable<Uri> create) throws Exception {
        final Uri red = create.call();
        clearMediaOwner(red, mUserId);

        RecoverableSecurityException exception = null;
        try {
            mContentResolver.delete(red, null, null);
            fail(""Expected update access to be blocked"");
        } catch (RecoverableSecurityException expected) {
            exception = expected;
        }

        doEscalation(exception);

        assertEquals(1, mContentResolver.delete(red, null, null));
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/MediaStorageApp/src/com/android/cts/mediastorageapp/MediaStorageTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.mediastorageapp.MediaStorageTest"	"testMediaEscalation_RequestWrite_notShowConfirmDialog"	""	"1: user"	"public void testMediaEscalation_RequestWrite_notShowConfirmDialog() throws Exception {
        doMediaEscalation_RequestWrite(true /* allowAccess */,
                true /* shouldCheckDialogShownValue */, false /* isDialogShownExpected */);
    }

    private void doMediaEscalation_RequestWrite(boolean allowAccess,
            boolean shouldCheckDialogShownValue, boolean isDialogShownExpected) throws Exception {
        doMediaEscalation_RequestWrite(MediaStorageTest::createAudio, allowAccess,
                shouldCheckDialogShownValue, isDialogShownExpected);
        doMediaEscalation_RequestWrite(MediaStorageTest::createVideo, allowAccess,
                shouldCheckDialogShownValue, isDialogShownExpected);
        doMediaEscalation_RequestWrite(MediaStorageTest::createImage, allowAccess,
                shouldCheckDialogShownValue, isDialogShownExpected);
        doMediaEscalation_RequestWrite(MediaStorageTest::createPlaylist, allowAccess,
                shouldCheckDialogShownValue, isDialogShownExpected);
        doMediaEscalation_RequestWrite(MediaStorageTest::createSubtitle, allowAccess,
                shouldCheckDialogShownValue, isDialogShownExpected);
    }

    private void doMediaEscalation_RequestWrite(Callable<Uri> create, boolean allowAccess,
            boolean shouldCheckDialogShownValue, boolean isDialogShownExpected) throws Exception {
        final Uri red = create.call();
        clearMediaOwner(red, mUserId);

        try (ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(red, ""w"")) {
            fail(""Expected write access to be blocked"");
        } catch (SecurityException expected) {
        }

        if (allowAccess) {
            doEscalation(MediaStore.createWriteRequest(mContentResolver, Arrays.asList(red)),
                    true /* allowAccess */, shouldCheckDialogShownValue, isDialogShownExpected);

            try (ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(red, ""w"")) {
            }
        } else {
            doEscalation(MediaStore.createWriteRequest(mContentResolver, Arrays.asList(red)),
                    false /* allowAccess */, shouldCheckDialogShownValue, isDialogShownExpected);
            try (ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(red, ""w"")) {
                fail(""Expected write access to be blocked"");
            } catch (SecurityException expected) {
            }
        }
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/MediaStorageApp/src/com/android/cts/mediastorageapp/MediaStorageTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.mediastorageapp.MediaStorageTest"	"testMediaEscalationWithDenied_RequestUnTrash"	""	"1: user"	"public void testMediaEscalationWithDenied_RequestUnTrash() throws Exception {
        doMediaEscalationWithDenied_RequestUnTrash(MediaStorageTest::createAudio);
        doMediaEscalationWithDenied_RequestUnTrash(MediaStorageTest::createVideo);
        doMediaEscalationWithDenied_RequestUnTrash(MediaStorageTest::createImage);
        doMediaEscalationWithDenied_RequestUnTrash(MediaStorageTest::createPlaylist);
        doMediaEscalationWithDenied_RequestUnTrash(MediaStorageTest::createSubtitle);
    }

    private void doMediaEscalationWithDenied_RequestUnTrash(Callable<Uri> create) throws Exception {
        final Uri red = create.call();
        clearMediaOwner(red, mUserId);

        assertEquals(""0"", queryForSingleColumn(red, MediaColumns.IS_TRASHED));
        doEscalation(
                MediaStore.createTrashRequest(mContentResolver, Arrays.asList(red), true));
        assertEquals(""1"", queryForSingleColumn(red, MediaColumns.IS_TRASHED));
        doEscalation(MediaStore.createTrashRequest(mContentResolver, Arrays.asList(red), false),
                false /* allowAccess */, false /* shouldCheckDialogShownValue */,
                false /* isDialogShownExpected */);
        assertEquals(""1"", queryForSingleColumn(red, MediaColumns.IS_TRASHED));
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/MediaStorageApp/src/com/android/cts/mediastorageapp/MediaStorageTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.mediastorageapp.MediaStorageTest"	"testMediaEscalation_RequestTrash_notShowConfirmDialog"	""	"1: user"	"public void testMediaEscalation_RequestTrash_notShowConfirmDialog() throws Exception {
        doMediaEscalation_RequestTrash(true /* allowAccess */,
                true /* shouldCheckDialogShownValue */, false /* isDialogShownExpected */);
    }

    private void doMediaEscalation_RequestTrash(boolean allowAccess,
            boolean shouldCheckDialogShownValue, boolean isDialogShownExpected) throws Exception {
        doMediaEscalation_RequestTrash(MediaStorageTest::createAudio, allowAccess,
                shouldCheckDialogShownValue, isDialogShownExpected);
        doMediaEscalation_RequestTrash(MediaStorageTest::createVideo, allowAccess,
                shouldCheckDialogShownValue, isDialogShownExpected);
        doMediaEscalation_RequestTrash(MediaStorageTest::createImage, allowAccess,
                shouldCheckDialogShownValue, isDialogShownExpected);
        doMediaEscalation_RequestTrash(MediaStorageTest::createPlaylist, allowAccess,
                shouldCheckDialogShownValue, isDialogShownExpected);
        doMediaEscalation_RequestTrash(MediaStorageTest::createSubtitle, allowAccess,
                shouldCheckDialogShownValue, isDialogShownExpected);
    }

    private void doMediaEscalation_RequestTrash(Callable<Uri> create, boolean allowAccess,
            boolean shouldCheckDialogShownValue, boolean isDialogShownExpected) throws Exception {
        final Uri red = create.call();
        clearMediaOwner(red, mUserId);

        assertEquals(""0"", queryForSingleColumn(red, MediaColumns.IS_TRASHED));

        if (allowAccess) {
            doEscalation(MediaStore.createTrashRequest(mContentResolver, Arrays.asList(red), true),
                    true /* allowAccess */, shouldCheckDialogShownValue, isDialogShownExpected);
            assertEquals(""1"", queryForSingleColumn(red, MediaColumns.IS_TRASHED));
            doEscalation(MediaStore.createTrashRequest(mContentResolver, Arrays.asList(red), false),
                    true /* allowAccess */, shouldCheckDialogShownValue, isDialogShownExpected);
            assertEquals(""0"", queryForSingleColumn(red, MediaColumns.IS_TRASHED));
        } else {
            doEscalation(MediaStore.createTrashRequest(mContentResolver, Arrays.asList(red), true),
                    false /* allowAccess */, shouldCheckDialogShownValue, isDialogShownExpected);
            assertEquals(""0"", queryForSingleColumn(red, MediaColumns.IS_TRASHED));
        }
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/MediaStorageApp/src/com/android/cts/mediastorageapp/MediaStorageTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.mediastorageapp.MediaStorageTest"	"testMediaEscalation_RequestFavorite"	""	"1: user"	"public void testMediaEscalation_RequestFavorite() throws Exception {
        doMediaEscalation_RequestFavorite(MediaStorageTest::createAudio);
        doMediaEscalation_RequestFavorite(MediaStorageTest::createVideo);
        doMediaEscalation_RequestFavorite(MediaStorageTest::createImage);
        doMediaEscalation_RequestFavorite(MediaStorageTest::createPlaylist);
        doMediaEscalation_RequestFavorite(MediaStorageTest::createSubtitle);
    }

    private void doMediaEscalation_RequestFavorite(Callable<Uri> create) throws Exception {
        final Uri red = create.call();
        clearMediaOwner(red, mUserId);

        assertEquals(""0"", queryForSingleColumn(red, MediaColumns.IS_FAVORITE));
        doEscalation(MediaStore.createFavoriteRequest(mContentResolver, Arrays.asList(red), true));
        assertEquals(""1"", queryForSingleColumn(red, MediaColumns.IS_FAVORITE));
        doEscalation(MediaStore.createFavoriteRequest(mContentResolver, Arrays.asList(red), false));
        assertEquals(""0"", queryForSingleColumn(red, MediaColumns.IS_FAVORITE));
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/MediaStorageApp/src/com/android/cts/mediastorageapp/MediaStorageTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.NumberPickerTest"	"testConstructor"	"CtsWidgetTestCases"	"1: ui"	"public void testConstructor() {
        new NumberPicker(mActivity);

        new NumberPicker(mActivity, null);

        new NumberPicker(mActivity, null, android.R.attr.numberPickerStyle);

        new NumberPicker(mActivity, null, 0, android.R.style.Widget_Material_NumberPicker);

        new NumberPicker(mActivity, null, 0, android.R.style.Widget_Material_Light_NumberPicker);
    }

    private void verifyDisplayedValues(String[] expected) {
        final String[] displayedValues = mNumberPicker.getDisplayedValues();
        assertEquals(expected.length, displayedValues.length);
        for (int i = 0; i < expected.length; i++) {
            assertEquals(expected[i], displayedValues[i]);
        }
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/NumberPickerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.NumberPickerTest"	"testSetDisplayedValuesRangeMatch"	"CtsWidgetTestCases"	"1: ui"	"public void testSetDisplayedValuesRangeMatch() {
        mNumberPicker.setMinValue(10);
        mNumberPicker.setMaxValue(12);
        mNumberPicker.setDisplayedValues(NUMBER_NAMES3);

        assertEquals(10, mNumberPicker.getMinValue());
        assertEquals(12, mNumberPicker.getMaxValue());
        verifyDisplayedValues(NUMBER_NAMES3);

        // Set a different displayed values array, but still matching the min/max range
        mNumberPicker.setDisplayedValues(NUMBER_NAMES_ALT3);

        assertEquals(10, mNumberPicker.getMinValue());
        assertEquals(12, mNumberPicker.getMaxValue());
        verifyDisplayedValues(NUMBER_NAMES_ALT3);

        mNumberPicker.setMinValue(24);
        mNumberPicker.setMaxValue(26);

        assertEquals(24, mNumberPicker.getMinValue());
        assertEquals(26, mNumberPicker.getMaxValue());
        verifyDisplayedValues(NUMBER_NAMES_ALT3);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/NumberPickerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.NumberPickerTest"	"testSetDisplayedValuesRangeMismatch"	"CtsWidgetTestCases"	"1: ui"	"public void testSetDisplayedValuesRangeMismatch() {
        mNumberPicker.setMinValue(10);
        mNumberPicker.setMaxValue(14);
        assertEquals(10, mNumberPicker.getMinValue());
        assertEquals(14, mNumberPicker.getMaxValue());

        // Try setting too few displayed entries
        try {
            // This is expected to fail since the displayed values only has three entries,
            // while the min/max range has five.
            mNumberPicker.setDisplayedValues(NUMBER_NAMES3);
            fail(""The size of the displayed values array must be equal to min/max range!"");
        } catch (Exception e) {
            // We are expecting to catch an exception. Set displayed values to an array that
            // matches the min/max range.
            mNumberPicker.setDisplayedValues(NUMBER_NAMES5);
        }
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/NumberPickerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.NumberPickerTest"	"testSelectionDisplayedValueFromDisplayedValues"	"CtsWidgetTestCases"	"1: ui"	"public void testSelectionDisplayedValueFromDisplayedValues() {
        mNumberPicker.setMinValue(1);
        mNumberPicker.setMaxValue(3);
        mNumberPicker.setDisplayedValues(NUMBER_NAMES3);

        mNumberPicker.setValue(1);
        assertTrue(TextUtils.equals(NUMBER_NAMES3[0],
                mNumberPicker.getDisplayedValueForCurrentSelection()));

        mNumberPicker.setValue(2);
        assertTrue(TextUtils.equals(NUMBER_NAMES3[1],
                mNumberPicker.getDisplayedValueForCurrentSelection()));

        mNumberPicker.setValue(3);
        assertTrue(TextUtils.equals(NUMBER_NAMES3[2],
                mNumberPicker.getDisplayedValueForCurrentSelection()));

        // Switch to a different displayed values array
        mNumberPicker.setDisplayedValues(NUMBER_NAMES_ALT3);
        assertTrue(TextUtils.equals(NUMBER_NAMES_ALT3[2],
                mNumberPicker.getDisplayedValueForCurrentSelection()));

        mNumberPicker.setValue(1);
        assertTrue(TextUtils.equals(NUMBER_NAMES_ALT3[0],
                mNumberPicker.getDisplayedValueForCurrentSelection()));

        mNumberPicker.setValue(2);
        assertTrue(TextUtils.equals(NUMBER_NAMES_ALT3[1],
                mNumberPicker.getDisplayedValueForCurrentSelection()));
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/NumberPickerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.NumberPickerTest"	"testSelectionDisplayedValueFromFormatter"	"CtsWidgetTestCases"	"1: ui"	"public void testSelectionDisplayedValueFromFormatter() {
        mNumberPicker.setMinValue(0);
        mNumberPicker.setMaxValue(4);
        mNumberPicker.setFormatter((int value) -> ""entry "" + value);

        mNumberPicker.setValue(0);
        assertTrue(TextUtils.equals(""entry 0"",
                mNumberPicker.getDisplayedValueForCurrentSelection()));

        mNumberPicker.setValue(1);
        assertTrue(TextUtils.equals(""entry 1"",
                mNumberPicker.getDisplayedValueForCurrentSelection()));

        mNumberPicker.setValue(2);
        assertTrue(TextUtils.equals(""entry 2"",
                mNumberPicker.getDisplayedValueForCurrentSelection()));

        mNumberPicker.setValue(3);
        assertTrue(TextUtils.equals(""entry 3"",
                mNumberPicker.getDisplayedValueForCurrentSelection()));

        mNumberPicker.setValue(4);
        assertTrue(TextUtils.equals(""entry 4"",
                mNumberPicker.getDisplayedValueForCurrentSelection()));

        // Switch to a different formatter
        mNumberPicker.setFormatter((int value) -> ""row "" + value);
        // Check that the currently selected value has new displayed value
        assertTrue(TextUtils.equals(""row 4"",
                mNumberPicker.getDisplayedValueForCurrentSelection()));

        // and check a couple more values for the new formatting
        mNumberPicker.setValue(0);
        assertTrue(TextUtils.equals(""row 0"",
                mNumberPicker.getDisplayedValueForCurrentSelection()));

        mNumberPicker.setValue(1);
        assertTrue(TextUtils.equals(""row 1"",
                mNumberPicker.getDisplayedValueForCurrentSelection()));
    }


    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/NumberPickerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.NumberPickerTest"	"testAccessValue"	"CtsWidgetTestCases"	"2: ui interaction"	"public void testAccessValue() throws Throwable {
        final NumberPicker.OnValueChangeListener mockValueChangeListener =
                mock(NumberPicker.OnValueChangeListener.class);

        mInstrumentation.runOnMainSync(() -> {
            mNumberPicker.setMinValue(20);
            mNumberPicker.setMaxValue(22);
            mNumberPicker.setDisplayedValues(NUMBER_NAMES3);

            mNumberPicker.setOnValueChangedListener(mockValueChangeListener);

            mNumberPicker.setValue(21);
            assertEquals(21, mNumberPicker.getValue());

            ((View) mNumberPicker.getParent()).setAccessibilityDelegate(mMockA11yDelegate);
            mNumberPicker.setValue(20);
            assertEquals(20, mNumberPicker.getValue());
            verify(mMockA11yDelegate, atLeastOnce()).onRequestSendAccessibilityEvent(
                    any(), eq(mNumberPicker), argThat(event -> event.getEventType()
                            == AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED));
            ((View) mNumberPicker.getParent()).setAccessibilityDelegate(null);

            mNumberPicker.setValue(22);
            assertEquals(22, mNumberPicker.getValue());

            // Check trying to set value out of min/max range
            mNumberPicker.setValue(10);
            assertEquals(20, mNumberPicker.getValue());

            mNumberPicker.setValue(100);
            assertEquals(22, mNumberPicker.getValue());
        });

        // Since all changes to value are via API calls, we should have no interactions /
        // callbacks on our listener.
        verifyZeroInteractions(mockValueChangeListener);
    }

    private boolean isWatch() {
        return (mActivity.getResources().getConfiguration().uiMode
                & Configuration.UI_MODE_TYPE_MASK) == Configuration.UI_MODE_TYPE_WATCH;
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/NumberPickerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.NumberPickerTest"	"testInteractionWithSwipeDown"	"CtsWidgetTestCases"	"3: ui system interaction"	"public void testInteractionWithSwipeDown() throws Throwable {
        mActivityRule.runOnUiThread(() -> {
            mNumberPicker.setMinValue(6);
            mNumberPicker.setMaxValue(8);
            mNumberPicker.setDisplayedValues(NUMBER_NAMES_ALT3);
        });

        final NumberPicker.OnValueChangeListener mockValueChangeListener =
                mock(NumberPicker.OnValueChangeListener.class);
        mNumberPicker.setOnValueChangedListener(mockValueChangeListener);

        final CountDownLatch latch = new CountDownLatch(1);
        final NumberPicker.OnScrollListener mockScrollListener =
                mock(NumberPicker.OnScrollListener.class);
        final NumberPicker.OnScrollListener waitForIdleListener =
                (NumberPicker numberPicker, int scrollState) -> {
                    mockScrollListener.onScrollStateChange(numberPicker, scrollState);
                    if (scrollState == NumberPicker.OnScrollListener.SCROLL_STATE_IDLE) {
                        mNumberPicker.post(latch::countDown);
                    }
                };
        mNumberPicker.setOnScrollListener(waitForIdleListener);

        mActivityRule.runOnUiThread(() -> mNumberPicker.setValue(7));
        assertEquals(7, mNumberPicker.getValue());

        // Swipe down across our number picker
        final int[] numberPickerLocationOnScreen = new int[2];
        mNumberPicker.getLocationOnScreen(numberPickerLocationOnScreen);

        try {
            int screenHeight = Resources.getSystem().getDisplayMetrics().heightPixels;
            int numberPickerMiddleX = numberPickerLocationOnScreen[0]
                    + mNumberPicker.getWidth() / 2;
            int numberPickerStartY = numberPickerLocationOnScreen[1] + 1;

            CtsTouchUtils.emulateDragGesture(mInstrumentation, mActivityRule,
                    numberPickerMiddleX,
                    numberPickerStartY,
                    0,
                    screenHeight - numberPickerStartY); // drag down to the bottom of the screen.

            Assert.assertTrue(""Expected to get to IDLE state within 5 seconds"",
                    latch.await(5, TimeUnit.SECONDS));
        } catch (Throwable t) {
            throw new RuntimeException(t);
        }

        // At this point we expect that the drag-down gesture has selected the value
        // that was ""above"" the previously selected one, and that our value change listener
        // has been notified of that change exactly once.
        assertEquals(6, mNumberPicker.getValue());
        verify(mockValueChangeListener, times(1)).onValueChange(mNumberPicker, 7, 6);
        verifyNoMoreInteractions(mockValueChangeListener);

        // We expect that our scroll listener will be called with specific state changes.
        InOrder inOrder = inOrder(mockScrollListener);
        inOrder.verify(mockScrollListener).onScrollStateChange(mNumberPicker,
                NumberPicker.OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
        if (!isWatch()) {
            inOrder.verify(mockScrollListener).onScrollStateChange(mNumberPicker,
                    NumberPicker.OnScrollListener.SCROLL_STATE_FLING);
        }
        inOrder.verify(mockScrollListener).onScrollStateChange(mNumberPicker,
                NumberPicker.OnScrollListener.SCROLL_STATE_IDLE);
        verifyNoMoreInteractions(mockScrollListener);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/NumberPickerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.NumberPickerTest"	"testInteractionWithSwipeUp"	"CtsWidgetTestCases"	"2: ui interaction"	"public void testInteractionWithSwipeUp() throws Throwable {
        mActivityRule.runOnUiThread(() -> {
            mNumberPicker.setMinValue(10);
            mNumberPicker.setMaxValue(12);
            mNumberPicker.setDisplayedValues(NUMBER_NAMES_ALT3);
        });

        final NumberPicker.OnValueChangeListener mockValueChangeListener =
                mock(NumberPicker.OnValueChangeListener.class);
        mNumberPicker.setOnValueChangedListener(mockValueChangeListener);

        final CountDownLatch latch = new CountDownLatch(1);
        final NumberPicker.OnScrollListener mockScrollListener =
                mock(NumberPicker.OnScrollListener.class);
        final NumberPicker.OnScrollListener waitForIdleListener =
                (NumberPicker numberPicker, int scrollState) -> {
                    mockScrollListener.onScrollStateChange(numberPicker, scrollState);
                    if (scrollState == NumberPicker.OnScrollListener.SCROLL_STATE_IDLE) {
                        mNumberPicker.post(latch::countDown);
                    }
                };
        mNumberPicker.setOnScrollListener(waitForIdleListener);

        mActivityRule.runOnUiThread(() -> mNumberPicker.setValue(11));
        assertEquals(11, mNumberPicker.getValue());

        // Swipe up across our number picker
        final int[] numberPickerLocationOnScreen = new int[2];
        mNumberPicker.getLocationOnScreen(numberPickerLocationOnScreen);

        ((View) mNumberPicker.getParent()).setAccessibilityDelegate(mMockA11yDelegate);
        try {
            int numberPickerMiddleX =
                    numberPickerLocationOnScreen[0] + mNumberPicker.getWidth() / 2;
            int numberPickerEndY = numberPickerLocationOnScreen[1] + mNumberPicker.getHeight() - 1;
            CtsTouchUtils.emulateDragGesture(mInstrumentation, mActivityRule,
                    numberPickerMiddleX,
                    numberPickerEndY,
                    0,
                    -(numberPickerEndY)); // drag up to the top of the screen.
            Assert.assertTrue(""Expected to get to IDLE state within 5 seconds"",
                    latch.await(5, TimeUnit.SECONDS));
        } catch (Throwable t) {
            throw new RuntimeException(t);
        }
        verify(mMockA11yDelegate, atLeastOnce()).onRequestSendAccessibilityEvent(
                any(), eq(mNumberPicker),
                argThat(event -> event.getEventType() == AccessibilityEvent.TYPE_VIEW_SCROLLED));
        ((View) mNumberPicker.getParent()).setAccessibilityDelegate(null);

        // At this point we expect that the drag-up gesture has selected the value
        // that was ""below"" the previously selected one, and that our value change listener
        // has been notified of that change exactly once.
        assertEquals(12, mNumberPicker.getValue());
        verify(mockValueChangeListener, times(1)).onValueChange(mNumberPicker, 11, 12);
        verifyNoMoreInteractions(mockValueChangeListener);

        // We expect that our scroll listener will be called with specific state changes.
        InOrder inOrder = inOrder(mockScrollListener);
        inOrder.verify(mockScrollListener).onScrollStateChange(mNumberPicker,
                NumberPicker.OnScrollListener.SCROLL_STATE_TOUCH_SCROLL);
        if (!isWatch()) {
            inOrder.verify(mockScrollListener).onScrollStateChange(mNumberPicker,
                    NumberPicker.OnScrollListener.SCROLL_STATE_FLING);
        }
        inOrder.verify(mockScrollListener).onScrollStateChange(mNumberPicker,
                NumberPicker.OnScrollListener.SCROLL_STATE_IDLE);
        verifyNoMoreInteractions(mockScrollListener);
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/NumberPickerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.NumberPickerTest"	"testAccessWrapSelectorValue"	"CtsWidgetTestCases"	"1: ui"	"public void testAccessWrapSelectorValue() {
        mNumberPicker.setMinValue(100);
        mNumberPicker.setMaxValue(200);
        // As specified in the Javadocs of NumberPicker.setWrapSelectorWheel, when min/max
        // range is larger than what the widget is showing, the selector wheel is enabled.
        assertTrue(mNumberPicker.getWrapSelectorWheel());

        mNumberPicker.setWrapSelectorWheel(false);
        assertFalse(mNumberPicker.getWrapSelectorWheel());

        mNumberPicker.setWrapSelectorWheel(true);
        assertTrue(mNumberPicker.getWrapSelectorWheel());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/NumberPickerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.NumberPickerTest"	"testSelectionDividerHeight"	"CtsWidgetTestCases"	"1: ui"	"public void testSelectionDividerHeight() {
        final NumberPicker numberPicker =
                (NumberPicker) mActivity.findViewById(R.id.number_picker_divider_height);
        final int initialValue = numberPicker.getSelectionDividerHeight();
        assertEquals(""Height set via XML"", 4, initialValue);
        final int newValue = 8;
        numberPicker.setSelectionDividerHeight(newValue);
        assertEquals(newValue, numberPicker.getSelectionDividerHeight());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/NumberPickerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.NumberPickerTest"	"testSetGetTextColor"	"CtsWidgetTestCases"	"1: ui"	"public void testSetGetTextColor() {
        EditText inputText = (EditText) mNumberPicker.getChildAt(0);

        mNumberPicker.setTextColor(Color.RED);
        assertEquals(Color.RED, mNumberPicker.getTextColor());
        assertEquals(ColorStateList.valueOf(Color.RED), inputText.getTextColors());
    }

    @UiThreadTest"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/NumberPickerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.widget.cts.NumberPickerTest"	"testEnterKey"	"CtsWidgetTestCases"	"3: ui system interaction"	"public void testEnterKey() throws Throwable {
        mActivityRule.runOnUiThread(() -> {
            mNumberPicker.setMinValue(10);
            mNumberPicker.setMaxValue(14);
            mNumberPicker.setDisplayedValues(NUMBER_NAMES5);
        });

        final NumberPicker.OnValueChangeListener mockValueChangeListener =
                mock(NumberPicker.OnValueChangeListener.class);
        mNumberPicker.setOnValueChangedListener(mockValueChangeListener);

        final int[] numberPickerLocationOnScreen = new int[2];
        mNumberPicker.getLocationOnScreen(numberPickerLocationOnScreen);
        int screenHeight = Resources.getSystem().getDisplayMetrics().heightPixels;
        int x = numberPickerLocationOnScreen[0] + mNumberPicker.getWidth() / 2;
        int y = numberPickerLocationOnScreen[1] + (int) mNumberPicker.getHeight() / 6;

        // Phase 1. Check enter key
        MotionEvent event = MotionEvent.obtain(System.currentTimeMillis(),
                System.currentTimeMillis(), MotionEvent.ACTION_DOWN, x, y, 0);
        mInstrumentation.sendPointerSync(event);

        // Send enter key to call removeAllCallbacks including longpressed
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mNumberPicker, KeyEvent.KEYCODE_ENTER);
        reset(mockValueChangeListener);

        // Wait a second to check if value is changed or not.
        SystemClock.sleep(1000);
        verifyZeroInteractions(mockValueChangeListener);

        event = MotionEvent.obtain(System.currentTimeMillis(), System.currentTimeMillis(),
                MotionEvent.ACTION_UP, x, y, 0);
        mInstrumentation.sendPointerSync(event);

        // Phase 2. Check numpad enter key
        event = MotionEvent.obtain(System.currentTimeMillis(), System.currentTimeMillis(),
                MotionEvent.ACTION_DOWN, x, y, 0);
        mInstrumentation.sendPointerSync(event);

        // Send numpad enter key. we expect it works like enter key.
        CtsKeyEventUtil.sendKeyDownUp(mInstrumentation, mNumberPicker,
                KeyEvent.KEYCODE_NUMPAD_ENTER);
        reset(mockValueChangeListener);

        // Wait a second to check if value is changed or not.
        SystemClock.sleep(1000);
        verifyZeroInteractions(mockValueChangeListener);

        event = MotionEvent.obtain(System.currentTimeMillis(), System.currentTimeMillis(),
                MotionEvent.ACTION_UP, x, y, 0);
        mInstrumentation.sendPointerSync(event);
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/widget/src/android/widget/cts/NumberPickerTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.compatibility.common.tradefed.presubmit.CtsConfigLoadingTest"	"testConfigurationLoad"	""	"4: direct ui system user"	"public void testConfigurationLoad() throws Exception {
        String ctsRoot = System.getProperty(""CTS_ROOT"");
        File testcases = new File(ctsRoot, ""/android-cts/testcases/"");
        if (!testcases.exists()) {
            fail(String.format(""%s does not exists"", testcases));
            return;
        }
        File[] listConfig = testcases.listFiles(new FilenameFilter() {
            @Override
            public boolean accept(File dir, String name) {
                if (name.endsWith("".config"")) {
                    return true;
                }
                return false;
            }
        });
        assertTrue(listConfig.length > 0);
        // Create a FolderBuildInfo to similate the CompatibilityBuildProvider
        FolderBuildInfo stubFolder = new FolderBuildInfo(""-1"", ""-1"");
        stubFolder.setRootDir(new File(ctsRoot));
        stubFolder.addBuildAttribute(CompatibilityBuildHelper.SUITE_NAME, ""CTS"");
        stubFolder.addBuildAttribute(""ROOT_DIR"", ctsRoot);
        TestInformation stubTestInfo = TestInformation.newBuilder().build();
        stubTestInfo.executionFiles().put(FilesKey.TESTS_DIRECTORY, new File(ctsRoot));

        List<String> missingMandatoryParameters = new ArrayList<>();
        // We expect to be able to load every single config in testcases/
        for (File config : listConfig) {
            IConfiguration c = ConfigurationFactory.getInstance()
                    .createConfigurationFromArgs(new String[] {config.getAbsolutePath()});
            if (c.getDeviceConfig().size() > 2) {
                throw new ConfigurationException(String.format(""%s declares more than 2 devices."", config));
            }
            for (IDeviceConfiguration dConfig : c.getDeviceConfig()) {
                // Ensure the deprecated ApkInstaller is not used anymore.
                for (ITargetPreparer prep : dConfig.getTargetPreparers()) {
                    if (prep.getClass().isAssignableFrom(ApkInstaller.class)) {
                        throw new ConfigurationException(
                                String.format(""%s: Use com.android.tradefed.targetprep.suite.""
                                        + ""SuiteApkInstaller instead of com.android.compatibility.""
                                        + ""common.tradefed.targetprep.ApkInstaller, options will be ""
                                        + ""the same."", config));
                    }
                    if (prep.getClass().isAssignableFrom(PreconditionPreparer.class)) {
                        throw new ConfigurationException(
                                String.format(
                                        ""%s: includes a PreconditionPreparer (%s) which is not ""
                                                + ""allowed in modules."",
                                        config.getName(), prep.getClass()));
                    }
                    if (prep.getClass().isAssignableFrom(DeviceSetup.class)) {
                       DeviceSetup deviceSetup = (DeviceSetup) prep;
                       if (!deviceSetup.isForceSkipSystemProps()) {
                           throw new ConfigurationException(
                                   String.format(""%s: %s needs to be configured with ""
                                           + ""<option name=\""force-skip-system-props\"" ""
                                           + ""value=\""true\"" /> in CTS."",
                                                 config.getName(), prep.getClass()));
                       }
                    }
                }
            }
            // We can ensure that Host side tests are not empty.
            for (IRemoteTest test : c.getTests()) {
                // Check that all the tests runners are well supported.
                if (!SUPPORTED_CTS_TEST_TYPE.contains(test.getClass().getCanonicalName())) {
                    throw new ConfigurationException(
                            String.format(
                                    ""testtype %s is not officially supported by CTS. ""
                                            + ""The supported ones are: %s"",
                                    test.getClass().getCanonicalName(), SUPPORTED_CTS_TEST_TYPE));
                }
                if (test instanceof HostTest) {
                    HostTest hostTest = (HostTest) test;
                    // We inject a made up folder so that it can find the tests.
                    hostTest.setBuild(stubFolder);
                    hostTest.setTestInformation(stubTestInfo);
                    int testCount = hostTest.countTestCases();
                    if (testCount == 0) {
                        throw new ConfigurationException(
                                String.format(""%s: %s reports 0 test cases."",
                                        config.getName(), test));
                    }
                }
                if (test instanceof GTest) {
                    if (((GTest) test).isRebootBeforeTestEnabled()) {
                        throw new ConfigurationException(String.format(
                                ""%s: instead of reboot-before-test use a RebootTargetPreparer ""
                                + ""which is more optimized during sharding."", config.getName()));
                    }
                }
                // Tests are expected to implement that interface.
                if (!(test instanceof ITestFilterReceiver)) {
                    throw new IllegalArgumentException(String.format(
                            ""Test in module %s must implement ITestFilterReceiver."",
                            config.getName()));
                }
                // Ensure that the device runner is the AJUR one if explicitly specified.
                if (test instanceof AndroidJUnitTest) {
                    AndroidJUnitTest instru = (AndroidJUnitTest) test;
                    if (instru.getRunnerName() != null &&
                            !ALLOWED_INSTRUMENTATION_RUNNER_NAME.contains(instru.getRunnerName())) {
                        // Some runner are exempt
                        if (!RUNNER_EXCEPTION.contains(instru.getRunnerName())) {
                            throw new ConfigurationException(
                                    String.format(""%s: uses '%s' instead of on of '%s' that are ""
                                            + ""expected"", config.getName(), instru.getRunnerName(),
                                            ALLOWED_INSTRUMENTATION_RUNNER_NAME));
                        }
                    }
                }
            }

            ConfigurationDescriptor cd = c.getConfigurationDescription();
            Assert.assertNotNull(config + "": configuration descriptor is null"", cd);
            List<String> component = cd.getMetaData(METADATA_COMPONENT);
            Assert.assertNotNull(String.format(""Missing module metadata field \""component\"", ""
                    + ""please add the following line to your AndroidTest.xml:\n""
                    + ""<option name=\""config-descriptor:metadata\"" key=\""component\"" ""
                    + ""value=\""...\"" />\nwhere \""value\"" must be one of: %s\n""
                    + ""config: %s"", KNOWN_COMPONENTS, config),
                    component);
            Assert.assertEquals(String.format(""Module config contains more than one \""component\"" ""
                    + ""metadata field: %s\nconfig: %s"", component, config),
                    1, component.size());
            String cmp = component.get(0);
            Assert.assertTrue(String.format(""Module config contains unknown \""component\"" metadata ""
                    + ""field \""%s\"", supported ones are: %s\nconfig: %s"",
                    cmp, KNOWN_COMPONENTS, config), KNOWN_COMPONENTS.contains(cmp));

            if (""misc"".equals(cmp)) {
                String configFileName = config.getName();
                Assert.assertTrue(
                        String.format(
                                ""Adding new module %s to \""misc\"" component is restricted, ""
                                        + ""please pick a component that your module fits in"",
                                configFileName),
                        KNOWN_MISC_MODULES.contains(configFileName));
            }

            // Check that specified parameters are expected
            boolean res =
                    checkModuleParameters(
                            config.getName(), cd.getMetaData(ITestSuite.PARAMETER_KEY));
            if (!res) {
                missingMandatoryParameters.add(config.getName());
            }
            // Check that specified tokens are expected
            checkTokens(config.getName(), cd.getMetaData(ITestSuite.TOKEN_KEY));

            // Ensure each CTS module is tagged with <option name=""test-suite-tag"" value=""cts"" />
            Assert.assertTrue(String.format(
                    ""Module config %s does not contains ""
                    + ""'<option name=\""test-suite-tag\"" value=\""cts\"" />'"", config.getName()),
                    cd.getSuiteTags().contains(""cts""));

            // Check not-shardable: JarHostTest cannot create empty shards so it should never need
            // to be not-shardable.
            if (cd.isNotShardable()) {
                for (IRemoteTest test : c.getTests()) {
                    if (test.getClass().isAssignableFrom(JarHostTest.class)) {
                        throw new ConfigurationException(
                                String.format(""config: %s. JarHostTest does not need the ""
                                    + ""not-shardable option."", config.getName()));
                    }
                }
            }
            // Ensure options have been set
            c.validateOptions();
        }

        // Exempt the allow list
        missingMandatoryParameters.removeAll(ALLOWLIST_MODULE_PARAMETERS);
        // Ensure the mandatory fields are filled
        if (!missingMandatoryParameters.isEmpty()) {
            String msg =
                    String.format(
                            ""The following %s modules are missing some of the mandatory ""
                                    + ""parameters [instant_app, not_instant_app, ""
                                    + ""multi_abi, not_multi_abi, ""
                                    + ""secondary_user, not_secondary_user]: '%s'"",
                            missingMandatoryParameters.size(), missingMandatoryParameters);
            throw new ConfigurationException(msg);
        }
    }

    /** Test that all parameter metadata can be resolved. */
    private boolean checkModuleParameters(String configName, List<String> parameters)
            throws ConfigurationException {
        if (parameters == null) {
            return false;
        }
        Map<String, Boolean> families = createFamilyCheckMap();
        for (String param : parameters) {
            try {
                ModuleParameters p = ModuleParameters.valueOf(param.toUpperCase());
                if (families.containsKey(p.getFamily())) {
                    families.put(p.getFamily(), true);
                }
            } catch (IllegalArgumentException e) {
                throw new ConfigurationException(
                        String.format(""Config: %s includes an unknown parameter '%s'."",
                                configName, param));
            }
        }
        if (families.containsValue(false)) {
            return false;
        }
        return true;
    }

    /** Test that all tokens can be resolved. */
    private void checkTokens(String configName, List<String> tokens) throws ConfigurationException {
        if (tokens == null) {
            return;
        }
        for (String token : tokens) {
            try {
                TokenProperty.valueOf(token.toUpperCase());
            } catch (IllegalArgumentException e) {
                throw new ConfigurationException(
                        String.format(
                                ""Config: %s includes an unknown token '%s'."", configName, token));
            }
        }
    }

    private Map<String, Boolean> createFamilyCheckMap() {
        Map<String, Boolean> families = new HashMap<>();
        for (String family : MANDATORY_PARAMETERS_FAMILY) {
            families.put(family, false);
        }
        return families;
    }
}"	"/home/gpoor/cts-12-source/cts/tools/cts-tradefed/tests/src/com/android/compatibility/common/tradefed/presubmit/CtsConfigLoadingTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.location.cts.gnss.asn1.supl2.supl_report.GANSSsignalsInfo"	"isTagImplicit"	"CtsLocationGnssTestCases"	"1: ui"	"public void test/*
 *.
 */

package android.location.cts.asn1.supl2.supl_report;

/*
 */


//
//
import android.location.cts.asn1.base.Asn1Null;
import android.location.cts.asn1.base.Asn1SequenceOf;
import android.location.cts.asn1.base.Asn1Tag;
import android.location.cts.asn1.base.BitStream;
import android.location.cts.asn1.base.BitStreamReader;
import com.google.common.collect.ImmutableList;
import java.util.Collection;
import javax.annotation.Nullable;


/**
 */
public  class GANSSsignalsInfo
    extends Asn1SequenceOf<GANSSSignalsDescription> {
  //

  private static final Asn1Tag TAG_GANSSsignalsInfo
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public GANSSsignalsInfo() {
    super();
    setMinSize(1);
setMaxSize(16);

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_GANSSsignalsInfo;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_GANSSsignalsInfo != null) {
      return ImmutableList.of(TAG_GANSSsignalsInfo);
    } else {
      return Asn1SequenceOf.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new GANSSsignalsInfo from encoded stream.
   */
  public static GANSSsignalsInfo fromPerUnaligned(byte[] encodedBytes) {
    GANSSsignalsInfo result = new GANSSsignalsInfo();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new GANSSsignalsInfo from encoded stream.
   */
  public static GANSSsignalsInfo fromPerAligned(byte[] encodedBytes) {
    GANSSsignalsInfo result = new GANSSsignalsInfo();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  
  @Override public GANSSSignalsDescription createAndAddValue() {
    GANSSSignalsDescription value = new GANSSSignalsDescription();
    add(value);
    return value;
  }

  

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    StringBuilder builder = new StringBuilder();
    builder.append(""GANSSsignalsInfo = [\n"");
    final String internalIndent = indent + ""  "";
    for (GANSSSignalsDescription value : getValues()) {
      builder.append(internalIndent)
          .append(value.toIndentedString(internalIndent));
    }
    builder.append(indent).append(""];\n"");
    return builder.toString();
  }
}"	"/home/gpoor/cts-12-source/cts/tests/location/location_gnss/src/android/location/cts/gnss/asn1/supl2/supl_report/GANSSsignalsInfo.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.hardware.cts.helpers.sensorverification.JitterVerification"	"isSensorSamplingRateOverloaded"	"CtsSensorTestCases"	"1: system"	"public void test/*
 *.
 */

package android.hardware.cts.helpers.sensorverification;

import android.content.Context;
import android.content.pm.PackageManager;

import android.util.Log;
import android.hardware.Sensor;
import android.hardware.cts.helpers.SensorCtsHelper;
import android.hardware.cts.helpers.SensorStats;
import android.hardware.cts.helpers.TestSensorEnvironment;
import android.hardware.cts.helpers.TestSensorEvent;
import android.util.SparseIntArray;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import junit.framework.Assert;

/**
 * A {@link ISensorVerification} which verifies that the sensor jitter is in an acceptable range.
 */
public class JitterVerification extends AbstractSensorVerification {
    public static final String PASSED_KEY = ""jitter_passed"";

    // sensorType: threshold (% of expected period)
    private static final SparseIntArray DEFAULTS = new SparseIntArray(12);
    // Max allowed jitter in +/- sense (in percentage).
    private static final int GRACE_FACTOR = 2;
    private static final int THRESHOLD_PERCENT_FOR_HIFI_SENSORS = 1 * GRACE_FACTOR;

    // Margin sample intervals that considered outliers, lower and higher margin is discarded
    // before verification
    private static final float OUTLIER_MARGIN = 0.025f; //2.5%

    static {
        // Use a method so that the @deprecation warning can be set for that method only
        setDefaults();
    }

    private final float     mOutlierMargin;
    private final long      mThresholdNs;
    private final long      mExpectedPeriodNs; // for error message only
    private final List<Long> mTimestamps = new LinkedList<Long>();

    /**
     * Construct a {@link JitterVerification}
     *
     * @param thresholdAsPercentage the acceptable margin of error as a percentage
     */
    public JitterVerification(float outlierMargin, long thresholdNs, long expectedPeriodNs) {
        mExpectedPeriodNs = expectedPeriodNs;
        mOutlierMargin = outlierMargin;
        mThresholdNs = thresholdNs;
    }

    /**
     * Get the default {@link JitterVerification} for a sensor.
     *
     * @param environment the test environment
     * @return the verification or null if the verification does not apply to the sensor.
     */
    public static JitterVerification getDefault(TestSensorEnvironment environment) {
        int sensorType = environment.getSensor().getType();

        int thresholdPercent = DEFAULTS.get(sensorType, -1);
        if (thresholdPercent == -1) {
            return null;
        }
        boolean hasHifiSensors = environment.getContext().getPackageManager().hasSystemFeature(
                PackageManager.FEATURE_HIFI_SENSORS);
        if (hasHifiSensors) {
           thresholdPercent = THRESHOLD_PERCENT_FOR_HIFI_SENSORS;
        }

        long expectedPeriodNs = (long) environment.getExpectedSamplingPeriodUs() * 1000;
        long jitterThresholdNs = expectedPeriodNs * thresholdPercent * 2 / 100; // *2 is for +/-
        return new JitterVerification(OUTLIER_MARGIN, jitterThresholdNs, expectedPeriodNs);
    }

    /**
     * Verify that the 95th percentile of the jitter is in the acceptable range. Add
     * {@value #PASSED_KEY} and {@value SensorStats#JITTER_95_PERCENTILE_PERCENT_KEY} keys to
     * {@link SensorStats}.
     *
     * @throws AssertionError if the verification failed.
     */
    @Override
    public void verify(TestSensorEnvironment environment, SensorStats stats) {
        int timestampsCount = mTimestamps.size();
        if (timestampsCount < 2 || environment.isSensorSamplingRateOverloaded()) {
            // the verification is not reliable in environments under load
            stats.addValue(PASSED_KEY, true);
            return;
        }

        List<Long> deltas = getDeltaValues();
        List<Long> percentileValues =
                SensorCtsHelper.getPercentileValue(deltas, mOutlierMargin, 1 - mOutlierMargin);

        double normalizedRange =
                (double)(percentileValues.get(1) - percentileValues.get(0)) / mThresholdNs;

        double percentageJitter =
                (double)(percentileValues.get(1) - percentileValues.get(0)) /
                        mExpectedPeriodNs / 2 * 100; //one side variation comparing to sample time

        stats.addValue(SensorStats.JITTER_95_PERCENTILE_PERCENT_KEY, percentageJitter);

        boolean success = normalizedRange <= 1.0;
        stats.addValue(PASSED_KEY, success);

        if (!success) {
            String message = String.format(
                    ""Jitter out of range: requested period = %dns, "" +
                    ""jitter min, max, range (95th percentile) = (%dns, %dns, %dns), "" +
                    ""jitter expected range <= %dns"",
                    mExpectedPeriodNs,
                    percentileValues.get(0), percentileValues.get(1),
                    percentileValues.get(1) - percentileValues.get(0),
                    mThresholdNs);
            Assert.fail(message);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JitterVerification clone() {
        return new JitterVerification(mOutlierMargin, mThresholdNs, mExpectedPeriodNs);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected void addSensorEventInternal(TestSensorEvent event) {
        mTimestamps.add(event.timestamp);
    }

    /**
     * Get the list of delta values. Exposed for unit testing.
     */
    List<Long> getDeltaValues() {
        List<Long> deltas = new ArrayList<Long>(mTimestamps.size() - 1);
        for (int i = 1; i < mTimestamps.size(); i++) {
            deltas.add(mTimestamps.get(i) - mTimestamps.get(i - 1));
        }
        return deltas;
    }

    @SuppressWarnings(""deprecation"")
    private static void setDefaults() {
        DEFAULTS.put(Sensor.TYPE_ACCELEROMETER, Integer.MAX_VALUE);
        DEFAULTS.put(Sensor.TYPE_MAGNETIC_FIELD, Integer.MAX_VALUE);
        DEFAULTS.put(Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED, Integer.MAX_VALUE);
        DEFAULTS.put(Sensor.TYPE_GYROSCOPE, Integer.MAX_VALUE);
        DEFAULTS.put(Sensor.TYPE_GYROSCOPE_UNCALIBRATED, Integer.MAX_VALUE);
        DEFAULTS.put(Sensor.TYPE_ORIENTATION, Integer.MAX_VALUE);
        DEFAULTS.put(Sensor.TYPE_PRESSURE, Integer.MAX_VALUE);
        DEFAULTS.put(Sensor.TYPE_GRAVITY, Integer.MAX_VALUE);
        DEFAULTS.put(Sensor.TYPE_LINEAR_ACCELERATION, Integer.MAX_VALUE);
        DEFAULTS.put(Sensor.TYPE_ROTATION_VECTOR, Integer.MAX_VALUE);
        DEFAULTS.put(Sensor.TYPE_GAME_ROTATION_VECTOR, Integer.MAX_VALUE);
        DEFAULTS.put(Sensor.TYPE_GEOMAGNETIC_ROTATION_VECTOR, Integer.MAX_VALUE);
    }
}"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/helpers/sensorverification/JitterVerification.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.verifier.forcestop.RecentTaskRemovalTestActivity"	"setPassFailButtonClickListeners"	""	"1: ui"	"public void test/*
 *.
 *
 */

package com.android.cts.verifier.forcestop;

import android.app.PendingIntent;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.net.Uri;
import android.os.Bundle;
import android.os.Handler;
import android.view.View;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.TextView;

import com.android.cts.forcestophelper.Constants;
import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;

/**
 * Tests that an app is not killed when it is swiped away from recents.
 * Requires CtsForceStopHelper.apk to be installed.
 */
public class RecentTaskRemovalTestActivity extends PassFailButtons.Activity implements
        View.OnClickListener {
    private static final String HELPER_APP_NAME = Constants.PACKAGE_NAME;
    private static final String HELPER_ACTIVITY_NAME = Constants.ACTIVITY_CLASS_NAME;

    private static final String HELPER_APP_INSTALLED_KEY = ""helper_installed"";

    private static final String ACTION_REPORT_TASK_REMOVED = ""report_task_removed"";
    private static final String ACTION_REPORT_ALARM = ""report_alarm"";

    private static final long EXTRA_WAIT_FOR_ALARM = 2_000;

    private ImageView mInstallStatus;
    private TextView mInstallTestAppText;

    private ImageView mLaunchStatus;
    private Button mLaunchTestAppButton;

    private ImageView mRemoveFromRecentsStatus;
    private TextView mRemoveFromRecentsInstructions;

    private ImageView mForceStopStatus;
    private TextView mForceStopVerificationResult;

    private volatile boolean mTestAppInstalled;
    private volatile boolean mTestTaskLaunched;
    private volatile boolean mTestTaskRemoved;
    private volatile boolean mTestAppForceStopped;
    private volatile boolean mTestAlarmReceived;
    private volatile boolean mWaitingForAlarm;

    private final PackageStateReceiver mPackageChangesListener = new PackageStateReceiver();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.force_stop_recents_main);
        setInfoResources(R.string.remove_from_recents_test, R.string.remove_from_recents_test_info,
                -1);
        setPassFailButtonClickListeners();

        if (savedInstanceState != null) {
            mTestAppInstalled = savedInstanceState.getBoolean(HELPER_APP_INSTALLED_KEY, false);
        } else {
            mTestAppInstalled = isPackageInstalled();
        }
        mInstallStatus = findViewById(R.id.fs_test_app_install_status);
        mInstallTestAppText = findViewById(R.id.fs_test_app_install_instructions);

        mRemoveFromRecentsStatus = findViewById(R.id.fs_test_app_recents_status);
        mRemoveFromRecentsInstructions = findViewById(R.id.fs_test_app_recents_instructions);

        mLaunchStatus = findViewById(R.id.fs_test_app_launch_status);
        mLaunchTestAppButton = findViewById(R.id.fs_launch_test_app_button);
        mLaunchTestAppButton.setOnClickListener(this);

        mForceStopStatus = findViewById(R.id.fs_force_stop_status);
        mForceStopVerificationResult = findViewById(R.id.fs_force_stop_verification);

        mPackageChangesListener.register(mForceStopStatus.getHandler());
    }

    private boolean isPackageInstalled() {
        PackageInfo packageInfo = null;
        try {
            packageInfo = getPackageManager().getPackageInfo(HELPER_APP_NAME, 0);
        } catch (PackageManager.NameNotFoundException exc) {
            // fall through
        }
        return packageInfo != null;
    }

    @Override
    public void onClick(View v) {
        if (v == mLaunchTestAppButton) {
            mTestTaskLaunched = true;

            final Intent reportTaskRemovedIntent = new Intent(ACTION_REPORT_TASK_REMOVED)
                    .setPackage(getPackageName())
                    .addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
            final PendingIntent onTaskRemoved = PendingIntent.getBroadcast(this, 0,
                    reportTaskRemovedIntent, PendingIntent.FLAG_MUTABLE_UNAUDITED);

            final Intent reportAlarmIntent = new Intent(ACTION_REPORT_ALARM)
                    .setPackage(getPackageName())
                    .addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
            final PendingIntent onAlarm = PendingIntent.getBroadcast(this, 0, reportAlarmIntent, PendingIntent.FLAG_MUTABLE_UNAUDITED);

            final Intent testActivity = new Intent()
                    .setClassName(HELPER_APP_NAME, HELPER_ACTIVITY_NAME)
                    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    .putExtra(Constants.EXTRA_ON_TASK_REMOVED, onTaskRemoved)
                    .putExtra(Constants.EXTRA_ON_ALARM, onAlarm);
            startActivity(testActivity);
        }
    }

    @Override
    public void onResume() {
        super.onResume();
        updateWidgets();
    }

    @Override
    public void onSaveInstanceState(Bundle icicle) {
        icicle.putBoolean(HELPER_APP_INSTALLED_KEY, mTestAppInstalled);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        mPackageChangesListener.unregister();
    }

    private void updateWidgets() {
        mInstallStatus.setImageResource(
                mTestAppInstalled ? R.drawable.fs_good : R.drawable.fs_indeterminate);
        mInstallTestAppText.setText(mTestAppInstalled ? R.string.fs_test_app_installed_text
                : R.string.fs_test_app_install_instructions);
        mInstallStatus.invalidate();

        mLaunchStatus.setImageResource(
                mTestTaskLaunched ? R.drawable.fs_good : R.drawable.fs_indeterminate);
        mLaunchTestAppButton.setEnabled(mTestAppInstalled && !mTestTaskLaunched);
        mLaunchStatus.invalidate();

        mRemoveFromRecentsStatus.setImageResource(
                mTestTaskRemoved ? R.drawable.fs_good : R.drawable.fs_indeterminate);
        mRemoveFromRecentsInstructions.setText(R.string.fs_test_app_recents_instructions);
        mRemoveFromRecentsStatus.invalidate();

        if (mTestTaskRemoved) {
            if (mWaitingForAlarm) {
                mForceStopStatus.setImageResource(R.drawable.fs_clock);
                mForceStopVerificationResult.setText(R.string.fs_force_stop_verification_pending);
            } else {
                mForceStopStatus.setImageResource(
                        (mTestAppForceStopped || !mTestAlarmReceived) ? R.drawable.fs_error
                                : R.drawable.fs_good);
                mForceStopVerificationResult.setText((mTestAppForceStopped || !mTestAlarmReceived)
                        ? R.string.result_failure
                        : R.string.result_success);
            }
            mForceStopStatus.invalidate();
            mForceStopStatus.setVisibility(View.VISIBLE);
            mForceStopVerificationResult.setVisibility(View.VISIBLE);
        } else {
            mForceStopStatus.setVisibility(View.GONE);
            mForceStopVerificationResult.setVisibility(View.GONE);
        }

        getPassButton().setEnabled(mTestAlarmReceived && !mTestAppForceStopped);
    }

    private final class PackageStateReceiver extends BroadcastReceiver {

        void register(Handler handler) {
            final IntentFilter packageFilter = new IntentFilter();
            packageFilter.addAction(Intent.ACTION_PACKAGE_RESTARTED);
            packageFilter.addAction(Intent.ACTION_PACKAGE_ADDED);
            packageFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);
            packageFilter.addDataScheme(""package"");
            registerReceiver(this, packageFilter);

            final IntentFilter commsFilter = new IntentFilter();
            commsFilter.addAction(ACTION_REPORT_TASK_REMOVED);
            commsFilter.addAction(ACTION_REPORT_ALARM);
            registerReceiver(this, commsFilter, null, handler);
        }

        void unregister() {
            unregisterReceiver(this);
        }

        @Override
        public void onReceive(Context context, Intent intent) {
            final Uri uri = intent.getData();
            boolean testPackageAffected = (uri != null && HELPER_APP_NAME.equals(
                    uri.getSchemeSpecificPart()));
            switch (intent.getAction()) {
                case Intent.ACTION_PACKAGE_ADDED:
                case Intent.ACTION_PACKAGE_REMOVED:
                    if (testPackageAffected) {
                        mTestAppInstalled = Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction());
                    }
                    break;
                case Intent.ACTION_PACKAGE_RESTARTED:
                    if (testPackageAffected) {
                        mTestAppForceStopped = true;
                    }
                    break;
                case ACTION_REPORT_TASK_REMOVED:
                    mTestTaskRemoved = true;
                    mWaitingForAlarm = true;
                    mForceStopStatus.postDelayed(() -> {
                        mWaitingForAlarm = false;
                        updateWidgets();
                    }, Constants.ALARM_DELAY + EXTRA_WAIT_FOR_ALARM);
                    break;
                case ACTION_REPORT_ALARM:
                    mTestAlarmReceived = true;
                    mWaitingForAlarm = false;
                    break;
            }
            updateWidgets();
        }
    }
}"	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/forcestop/RecentTaskRemovalTestActivity.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.verifier.nfc.hce.HceService"	"currentTimeMillis"	""	"3: ui system user"	"public void testpackage com.android.cts.verifier.nfc.hce;

import android.annotation.TargetApi;
import android.content.ComponentName;
import android.content.Intent;
import android.nfc.cardemulation.HostApduService;
import android.os.Bundle;
import android.util.Log;

import java.util.Arrays;

@TargetApi(19)
public abstract class HceService extends HostApduService {
    final static String TAG = ""HceService"";

    final static int STATE_IDLE = 0;
    final static int STATE_IN_PROGRESS = 1;
    final static int STATE_FAILED = 2;

    // Variables below only used on main thread
    CommandApdu[] mCommandApdus = null;
    String[] mResponseApdus = null;
    int mApduIndex = 0;
    int mState = STATE_IDLE;
    long mStartTime;

    public void initialize(CommandApdu[] commandApdus, String[] responseApdus) {
       mCommandApdus = commandApdus;
       mResponseApdus = responseApdus;
    }

    @Override
    public void onDeactivated(int arg0) {
        mApduIndex = 0;
        mState = STATE_IDLE;
    }

    public abstract ComponentName getComponent();

    public void onApduSequenceComplete() {
        Intent completionIntent = new Intent(HceUtils.ACTION_APDU_SEQUENCE_COMPLETE);
        completionIntent.putExtra(HceUtils.EXTRA_COMPONENT, getComponent());
        completionIntent.putExtra(HceUtils.EXTRA_DURATION,
                System.currentTimeMillis() - mStartTime);
        sendBroadcast(completionIntent);
    }

    public void onApduSequenceError() {
        Intent errorIntent = new Intent(HceUtils.ACTION_APDU_SEQUENCE_ERROR);
        sendBroadcast(errorIntent);
    }

    @Override
    public byte[] processCommandApdu(byte[] arg0, Bundle arg1) {
        if (mState == STATE_FAILED) {
            // Don't accept any more APDUs until deactivated
            return null;
        }

        if (mState == STATE_IDLE) {
            mState = STATE_IN_PROGRESS;
            mStartTime = System.currentTimeMillis();
        }


        if (mApduIndex >= mCommandApdus.length) {
         // Skip all APDUs which aren't supposed to reach us
            return null;
        }

        do {
            if (!mCommandApdus[mApduIndex].isReachable()) {
                mApduIndex++;
            } else {
                break;
            }
        } while (mApduIndex < mCommandApdus.length);

        if (mApduIndex >= mCommandApdus.length) {
            Log.d(TAG, ""Ignoring command APDU; protocol complete."");
            // Ignore new APDUs after completion
            return null;
        } else {

            if (!Arrays.equals(HceUtils.hexStringToBytes(mCommandApdus[mApduIndex].getApdu()), arg0)) {
                Log.d(TAG, ""Unexpected command APDU: "" + HceUtils.getHexBytes("""", arg0));
                onApduSequenceError();
                return null;
            } else {
                // Send corresponding response APDU
                byte[] responseApdu = HceUtils.hexStringToBytes(mResponseApdus[mApduIndex]);
                mApduIndex++;
                if (mApduIndex == mCommandApdus.length) {
                    // Test passed
                    onApduSequenceComplete();
                }
                return responseApdu;
            }
        }
    }
}"	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/nfc/hce/HceService.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.location.cts.gnss.asn1.supl2.rrlp_components.GANSSEphemerisExtensionTime"	"GANSSEphemerisExtensionTime"	"CtsLocationGnssTestCases"	"1: ui"	"public void test/*
 *.
 */

package android.location.cts.asn1.supl2.rrlp_components;

/*
 */


//
//
import android.location.cts.asn1.base.Asn1Integer;
import android.location.cts.asn1.base.Asn1Null;
import android.location.cts.asn1.base.Asn1Object;
import android.location.cts.asn1.base.Asn1Sequence;
import android.location.cts.asn1.base.Asn1Tag;
import android.location.cts.asn1.base.BitStream;
import android.location.cts.asn1.base.BitStreamReader;
import android.location.cts.asn1.base.SequenceComponent;
import com.google.common.collect.ImmutableList;
import java.util.Collection;
import javax.annotation.Nullable;


/**
*/
public  class GANSSEphemerisExtensionTime extends Asn1Sequence {
  //

  private static final Asn1Tag TAG_GANSSEphemerisExtensionTime
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public GANSSEphemerisExtensionTime() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_GANSSEphemerisExtensionTime;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_GANSSEphemerisExtensionTime != null) {
      return ImmutableList.of(TAG_GANSSEphemerisExtensionTime);
    } else {
      return Asn1Sequence.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new GANSSEphemerisExtensionTime from encoded stream.
   */
  public static GANSSEphemerisExtensionTime fromPerUnaligned(byte[] encodedBytes) {
    GANSSEphemerisExtensionTime result = new GANSSEphemerisExtensionTime();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new GANSSEphemerisExtensionTime from encoded stream.
   */
  public static GANSSEphemerisExtensionTime fromPerAligned(byte[] encodedBytes) {
    GANSSEphemerisExtensionTime result = new GANSSEphemerisExtensionTime();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }



  @Override protected boolean isExtensible() {
    return true;
  }

  @Override public boolean containsExtensionValues() {
    for (SequenceComponent extensionComponent : getExtensionComponents()) {
      if (extensionComponent.isExplicitlySet()) return true;
    }
    return false;
  }

  
  private GANSSEphemerisExtensionTime.ganssEphExtDayType ganssEphExtDay_;
  public GANSSEphemerisExtensionTime.ganssEphExtDayType getGanssEphExtDay() {
    return ganssEphExtDay_;
  }
  /**
   * @throws ClassCastException if value is not a GANSSEphemerisExtensionTime.ganssEphExtDayType
   */
  public void setGanssEphExtDay(Asn1Object value) {
    this.ganssEphExtDay_ = (GANSSEphemerisExtensionTime.ganssEphExtDayType) value;
  }
  public GANSSEphemerisExtensionTime.ganssEphExtDayType setGanssEphExtDayToNewInstance() {
    ganssEphExtDay_ = new GANSSEphemerisExtensionTime.ganssEphExtDayType();
    return ganssEphExtDay_;
  }
  
  private GANSSTOD ganssEphExtTOD_;
  public GANSSTOD getGanssEphExtTOD() {
    return ganssEphExtTOD_;
  }
  /**
   * @throws ClassCastException if value is not a GANSSTOD
   */
  public void setGanssEphExtTOD(Asn1Object value) {
    this.ganssEphExtTOD_ = (GANSSTOD) value;
  }
  public GANSSTOD setGanssEphExtTODToNewInstance() {
    ganssEphExtTOD_ = new GANSSTOD();
    return ganssEphExtTOD_;
  }
  

  

  

  @Override public Iterable<? extends SequenceComponent> getComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 0);

          @Override public boolean isExplicitlySet() {
            return getGanssEphExtDay() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getGanssEphExtDay();
          }

          @Override public void setToNewInstance() {
            setGanssEphExtDayToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? GANSSEphemerisExtensionTime.ganssEphExtDayType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""ganssEphExtDay : ""
                    + getGanssEphExtDay().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 1);

          @Override public boolean isExplicitlySet() {
            return getGanssEphExtTOD() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getGanssEphExtTOD();
          }

          @Override public void setToNewInstance() {
            setGanssEphExtTODToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? GANSSTOD.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""ganssEphExtTOD : ""
                    + getGanssEphExtTOD().toIndentedString(indent);
              }
        });
    
    return builder.build();
  }

  @Override public Iterable<? extends SequenceComponent>
                                                    getExtensionComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
      
      return builder.build();
    }

  
/*
 */


//

/**
 */
public static class ganssEphExtDayType extends Asn1Integer {
  //

  private static final Asn1Tag TAG_ganssEphExtDayType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public ganssEphExtDayType() {
    super();
    setValueRange(""0"", ""8191"");

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_ganssEphExtDayType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_ganssEphExtDayType != null) {
      return ImmutableList.of(TAG_ganssEphExtDayType);
    } else {
      return Asn1Integer.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new ganssEphExtDayType from encoded stream.
   */
  public static ganssEphExtDayType fromPerUnaligned(byte[] encodedBytes) {
    ganssEphExtDayType result = new ganssEphExtDayType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new ganssEphExtDayType from encoded stream.
   */
  public static ganssEphExtDayType fromPerAligned(byte[] encodedBytes) {
    ganssEphExtDayType result = new ganssEphExtDayType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""ganssEphExtDayType = "" + getInteger() + "";\n"";
  }
}

  
  
  

    

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    StringBuilder builder = new StringBuilder();
    builder.append(""GANSSEphemerisExtensionTime = {\n"");
    final String internalIndent = indent + ""  "";
    for (SequenceComponent component : getComponents()) {
      if (component.isExplicitlySet()) {
        builder.append(internalIndent)
            .append(component.toIndentedString(internalIndent));
      }
    }
    if (isExtensible()) {
      builder.append(internalIndent).append(""...\n"");
      for (SequenceComponent component : getExtensionComponents()) {
        if (component.isExplicitlySet()) {
          builder.append(internalIndent)
              .append(component.toIndentedString(internalIndent));
        }
      }
    }
    builder.append(indent).append(""};\n"");
    return builder.toString();
  }
}"	"/home/gpoor/cts-12-source/cts/tests/location/location_gnss/src/android/location/cts/gnss/asn1/supl2/rrlp_components/GANSSEphemerisExtensionTime.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.appsecurity.cts.AppSecurityTests"	"testCrossPackageDiffCertSetInstaller"	"CtsAppSecurityHostTestCases"	"1: apps"	"@AppModeFull(reason = ""Only full apps can hold INSTALL_PACKAGES"")
    @AsbSecurityTest(cveBugId = 150857253)
    public void testCrossPackageDiffCertSetInstaller() throws Exception {
        Log.i(LOG_TAG, ""installing app that attempts to use permission of another app"");
        try {
            // cleanup test app that might be installed from previous partial test run
            getDevice().uninstallPackage(DECLARE_PERMISSION_PKG);
            getDevice().uninstallPackage(DECLARE_PERMISSION_COMPAT_PKG);
            getDevice().uninstallPackage(PERMISSION_DIFF_CERT_PKG);

            new InstallMultiple().addFile(DECLARE_PERMISSION_APK).run();
            new InstallMultiple().addFile(DECLARE_PERMISSION_COMPAT_APK).run();
            new InstallMultiple().addFile(PERMISSION_DIFF_CERT_APK).run();

            // Enable alert window permission so it can start activity in background
            enableAlertWindowAppOp(DECLARE_PERMISSION_PKG);

            runCrossPackageInstallerDeviceTest(PERMISSION_DIFF_CERT_PKG, ""assertBefore"");
            runCrossPackageInstallerDeviceTest(DECLARE_PERMISSION_PKG, ""takeInstaller"");
            runCrossPackageInstallerDeviceTest(PERMISSION_DIFF_CERT_PKG, ""attemptTakeOver"");
            runCrossPackageInstallerDeviceTest(DECLARE_PERMISSION_PKG, ""clearInstaller"");
            runCrossPackageInstallerDeviceTest(PERMISSION_DIFF_CERT_PKG, ""assertAfter"");
        } finally {
            getDevice().uninstallPackage(DECLARE_PERMISSION_PKG);
            getDevice().uninstallPackage(DECLARE_PERMISSION_COMPAT_PKG);
            getDevice().uninstallPackage(PERMISSION_DIFF_CERT_PKG);
        }
    }

    /**
     * Utility method to make actual test method easier to read.
     */
    private void runCrossPackageInstallerDeviceTest(String pkgName, String testMethodName)
            throws DeviceNotAvailableException {
        Map<String, String> arguments = new HashMap<>();
        arguments.put(""runExplicit"", ""true"");
        runDeviceTests(getDevice(), null, pkgName, pkgName + "".ModifyInstallerCrossPackageTest"",
                testMethodName, null, 10 * 60 * 1000L, 10 * 60 * 1000L, 0L, true, false, arguments);
    }

    /**
     * Test what happens if an app tried to take a permission away from another
     */"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/AppSecurityTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.appsecurity.cts.AppSecurityTests"	"testUninstallRemovesData_instant"	"CtsAppSecurityHostTestCases"	"2: ui user"	"@AppModeInstant(reason = ""'instant' portion of the hostside test"")
    public void testUninstallRemovesData_instant() throws Exception {
        testUninstallRemovesData(true);
    }
    private void testUninstallRemovesData(boolean instant) throws Exception {
        Log.i(LOG_TAG, ""Uninstalling app, verifying data is removed."");
        try {
            getDevice().uninstallPackage(APP_WITH_DATA_PKG);

            new InstallMultiple(instant).addFile(APP_WITH_DATA_APK).run();
            runDeviceTests(
                    APP_WITH_DATA_PKG, APP_WITH_DATA_CLASS, APP_WITH_DATA_CREATE_METHOD);

            getDevice().uninstallPackage(APP_WITH_DATA_PKG);

            new InstallMultiple(instant).addFile(APP_WITH_DATA_APK).run();
            runDeviceTests(
                    APP_WITH_DATA_PKG, APP_WITH_DATA_CLASS, APP_WITH_DATA_CHECK_NOEXIST_METHOD);
        } finally {
            getDevice().uninstallPackage(APP_WITH_DATA_PKG);
        }
    }

    /**
     * Test that an app cannot instrument another app that is signed with different certificate.
     */
    // RestrictedBuildTest ensures the build only runs on user builds where the signature
    // verification will be performed, but JUnit4TestNotRun reports the test will not be run because
    // the method does not have the"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/AppSecurityTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.appsecurity.cts.AppSecurityTests"	"testInstrumentationDiffCert_full"	"CtsAppSecurityHostTestCases"	"1: ui"	"annotation.
    @SuppressWarnings(""JUnit4TestNotRun"")
    @RestrictedBuildTest
    @AppModeFull(reason = ""'full' portion of the hostside test"")
    public void testInstrumentationDiffCert_full() throws Exception {
        testInstrumentationDiffCert(false, false);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/AppSecurityTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.appsecurity.cts.AppSecurityTests"	"testAdbInstallFile_instant"	"CtsAppSecurityHostTestCases"	"1: system"	"@AppModeInstant(reason = ""'instant' portion of the hostside test"")
    public void testAdbInstallFile_instant() throws Exception {
        testAdbInstallFile(true);
    }
    private void testAdbInstallFile(boolean instant) throws Exception {
        String output = getDevice().executeShellCommand(
                ""cmd package install""
                        + (instant ? "" --instant"" : "" --full"")
                        + "" -S 1024 /data/local/tmp/foo.apk"");
        assertTrue(""Error text"", output.contains(""Error""));
    }

    private void enableAlertWindowAppOp(String pkgName) throws Exception {
        getDevice().executeShellCommand(
                ""appops set "" + pkgName + "" android:system_alert_window allow"");
        String result = ""No operations."";
        while (result.contains(""No operations"")) {
            result = getDevice().executeShellCommand(
                    ""appops get "" + pkgName + "" android:system_alert_window"");
        }
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/AppSecurityTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.omapi.accesscontrol3.cts.AccessControlTest"	"OnConnectedListener"	"CtsSecureElementAccessControlTestCases"	"2: ui system"	"/*
 *.
 */

/* Contributed by Orange */

package android.omapi.accesscontrol3.cts;

import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.*;
import static org.junit.Assume.assumeTrue;

import android.content.pm.PackageManager;
import android.os.Build;
import android.se.omapi.Channel;
import android.se.omapi.Reader;
import android.se.omapi.SEService;
import android.se.omapi.SEService.OnConnectedListener;
import android.se.omapi.Session;

import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.PropertyUtil;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeoutException;

public class AccessControlTest {
    private final static String UICC_READER_PREFIX = ""SIM"";
    private final static String ESE_READER_PREFIX = ""eSE"";
    private final static String SD_READER_PREFIX = ""SD"";

    private final static byte[] AID_40 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x40 };
    private final static byte[] AID_41 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x41 };
    private final static byte[] AID_42 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x42 };
    private final static byte[] AID_43 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x43 };
    private final static byte[] AID_44 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x44 };
    private final static byte[] AID_45 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x45 };
    private final static byte[] AID_46 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x46 };
    private final static byte[] AID_47 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x47 };
    private final static byte[] AID_48 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x48 };
    private final static byte[] AID_49 = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, 0x49 };
    private final static byte[] AID_4A = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4A };
    private final static byte[] AID_4B = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4B };
    private final static byte[] AID_4C = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4C };
    private final static byte[] AID_4D = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4D };
    private final static byte[] AID_4E = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4E };
    private final static byte[] AID_4F = new byte[] { (byte) 0xA0, 0x00, 0x00,
        0x04, 0x76, 0x41, 0x6E, 0x64, 0x72, 0x6F, 0x69, 0x64, 0x43, 0x54,
        0x53, (byte) 0x4F };

    private final static byte[][] AUTHORIZED_AID = new byte[][] { AID_40,
        AID_41, AID_45, AID_46 };
    private final static byte[][] UNAUTHORIZED_AID = new byte[][] { AID_42,
        AID_43, AID_44, AID_47, AID_48, AID_49, AID_4A, AID_4B, AID_4C, AID_4D, AID_4E,
        AID_4F };

    /* Authorized APDU for AID_40 */
    private final static byte[][] AUTHORIZED_APDU_AID_40 = new byte[][] {
        { 0x00, 0x06, 0x00, 0x00 }, { (byte) 0x80, 0x06, 0x00, 0x00 },
        { (byte) 0xA0, 0x06, 0x00, 0x00 },
        { (byte) 0x94, 0x06, 0x00, 0x00 },
        { 0x00, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { (byte) 0x80, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { (byte) 0xA0, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { (byte) 0x94, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { 0x00, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0x80, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0xA0, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0x94, 0x08, 0x00, 0x00, 0x00 },
        { 0x00, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
        { (byte) 0x80, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
        { (byte) 0xA0, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
        { (byte) 0x94, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 }};

    /* Authorized APDU for AID_41 */
    private final static byte[][] AUTHORIZED_APDU_AID_41 = new byte[][] {
        { (byte) 0x94, 0x06, 0x00, 0x00 },
        { (byte) 0x94, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0x94, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
        { (byte) 0x94, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA } };
    /* Unauthorized APDU for AID_41 */
    private final static byte[][] UNAUTHORIZED_APDU_AID_41 = new byte[][] {
        { 0x00, 0x06, 0x00, 0x00 }, { (byte) 0x80, 0x06, 0x00, 0x00 },
        { (byte) 0xA0, 0x06, 0x00, 0x00 },
        { 0x00, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0x00, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { (byte) 0x80, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { (byte) 0xA0, 0x0A, 0x00, 0x00, 0x01, (byte) 0xAA },
        { (byte) 0x80, 0x08, 0x00, 0x00, 0x00 },
        { (byte) 0xA0, 0x08, 0x00, 0x00, 0x00 },
        { 0x00, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
        { (byte) 0x80, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
        { (byte) 0xA0, (byte) 0x0C, 0x00, 0x00, 0x01, (byte) 0xAA, 0x00 },
    };

    private final long SERVICE_CONNECTION_TIME_OUT = 3000;
    private SEService seService;
    private Object serviceMutex = new Object();
    private Timer connectionTimer;
    private ServiceConnectionTimerTask mTimerTask = new ServiceConnectionTimerTask();
    private boolean connected = false;

    private final OnConnectedListener mListener = new OnConnectedListener() {
        @Override
        public void onConnected() {
            synchronized (serviceMutex) {
                connected = true;
                serviceMutex.notify();
            }
        }
    };

    class SynchronousExecutor implements Executor {
        public void execute(Runnable r) {
            r.run();
        }
    }

    private boolean supportsHardware() {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
        boolean lowRamDevice = PropertyUtil.propertyEquals(""ro.config.low_ram"", ""true"");
        return !lowRamDevice || pm.hasSystemFeature(""android.hardware.type.watch"")
                || hasSecureElementPackage(pm);
    }

    private boolean hasSecureElementPackage(PackageManager pm) {
        try {
            pm.getPackageInfo(""com.android.se"", 0 /* flags*/);
            return true;
        } catch (PackageManager.NameNotFoundException e) {
            return false;
        }
    }

    private boolean supportOMAPIReaders() {
        final PackageManager pm = InstrumentationRegistry.getContext().getPackageManager();
        return (pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_UICC)
            || pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_ESE)
            || pm.hasSystemFeature(PackageManager.FEATURE_SE_OMAPI_SD));
    }

    @Before
    public void setUp() throws Exception {
        assumeTrue(PropertyUtil.getFirstApiLevel() > Build.VERSION_CODES.O_MR1);
        assumeTrue(supportsHardware());
        assumeTrue(supportOMAPIReaders());
        seService = new SEService(InstrumentationRegistry.getContext(), new SynchronousExecutor(), mListener);
        connectionTimer = new Timer();
        connectionTimer.schedule(mTimerTask, SERVICE_CONNECTION_TIME_OUT);
    }

    @After
    public void tearDown() throws Exception {
        if (seService != null && seService.isConnected()) {
            seService.shutdown();
            connected = false;
        }
    }

    private void waitForConnection() throws TimeoutException {
        synchronized (serviceMutex) {
            if (!connected) {
                try {
                    serviceMutex.wait();
                 } catch (InterruptedException e) {
                    e.printStackTrace();
                 }
            }
            if (!connected) {
                throw new TimeoutException(
                    ""Service could not be connected after ""
                    + SERVICE_CONNECTION_TIME_OUT + "" ms"");
            }
            if (connectionTimer != null) {
                connectionTimer.cancel();
            }
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/secure_element/access_control/AccessControlApp3/src/android/omapi/accesscontrol3/cts/AccessControlTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.location.cts.gnss.asn1.supl2.rrlp_components.Extended_reference"	"isTagImplicit"	"CtsLocationGnssTestCases"	"1: ui"	"public void test/*
 *.
 */

package android.location.cts.asn1.supl2.rrlp_components;

/*
 */


//
//
import android.location.cts.asn1.base.Asn1Integer;
import android.location.cts.asn1.base.Asn1Null;
import android.location.cts.asn1.base.Asn1Object;
import android.location.cts.asn1.base.Asn1Sequence;
import android.location.cts.asn1.base.Asn1Tag;
import android.location.cts.asn1.base.BitStream;
import android.location.cts.asn1.base.BitStreamReader;
import android.location.cts.asn1.base.SequenceComponent;
import com.google.common.collect.ImmutableList;
import java.util.Collection;
import javax.annotation.Nullable;


/**
*/
public  class Extended_reference extends Asn1Sequence {
  //

  private static final Asn1Tag TAG_Extended_reference
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public Extended_reference() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_Extended_reference;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_Extended_reference != null) {
      return ImmutableList.of(TAG_Extended_reference);
    } else {
      return Asn1Sequence.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new Extended_reference from encoded stream.
   */
  public static Extended_reference fromPerUnaligned(byte[] encodedBytes) {
    Extended_reference result = new Extended_reference();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new Extended_reference from encoded stream.
   */
  public static Extended_reference fromPerAligned(byte[] encodedBytes) {
    Extended_reference result = new Extended_reference();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }



  @Override protected boolean isExtensible() {
    return false;
  }

  @Override public boolean containsExtensionValues() {
    for (SequenceComponent extensionComponent : getExtensionComponents()) {
      if (extensionComponent.isExplicitlySet()) return true;
    }
    return false;
  }

  
  private Extended_reference.smlc_codeType smlc_code_;
  public Extended_reference.smlc_codeType getSmlc_code() {
    return smlc_code_;
  }
  /**
   * @throws ClassCastException if value is not a Extended_reference.smlc_codeType
   */
  public void setSmlc_code(Asn1Object value) {
    this.smlc_code_ = (Extended_reference.smlc_codeType) value;
  }
  public Extended_reference.smlc_codeType setSmlc_codeToNewInstance() {
    smlc_code_ = new Extended_reference.smlc_codeType();
    return smlc_code_;
  }
  
  private Extended_reference.transaction_IDType transaction_ID_;
  public Extended_reference.transaction_IDType getTransaction_ID() {
    return transaction_ID_;
  }
  /**
   * @throws ClassCastException if value is not a Extended_reference.transaction_IDType
   */
  public void setTransaction_ID(Asn1Object value) {
    this.transaction_ID_ = (Extended_reference.transaction_IDType) value;
  }
  public Extended_reference.transaction_IDType setTransaction_IDToNewInstance() {
    transaction_ID_ = new Extended_reference.transaction_IDType();
    return transaction_ID_;
  }
  

  

  

  @Override public Iterable<? extends SequenceComponent> getComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 0);

          @Override public boolean isExplicitlySet() {
            return getSmlc_code() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getSmlc_code();
          }

          @Override public void setToNewInstance() {
            setSmlc_codeToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? Extended_reference.smlc_codeType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""smlc_code : ""
                    + getSmlc_code().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 1);

          @Override public boolean isExplicitlySet() {
            return getTransaction_ID() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getTransaction_ID();
          }

          @Override public void setToNewInstance() {
            setTransaction_IDToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? Extended_reference.transaction_IDType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""transaction_ID : ""
                    + getTransaction_ID().toIndentedString(indent);
              }
        });
    
    return builder.build();
  }

  @Override public Iterable<? extends SequenceComponent>
                                                    getExtensionComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
      
      return builder.build();
    }

  
/*
 */


//

/**
 */
public static class smlc_codeType extends Asn1Integer {
  //

  private static final Asn1Tag TAG_smlc_codeType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public smlc_codeType() {
    super();
    setValueRange(""0"", ""63"");

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_smlc_codeType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_smlc_codeType != null) {
      return ImmutableList.of(TAG_smlc_codeType);
    } else {
      return Asn1Integer.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new smlc_codeType from encoded stream.
   */
  public static smlc_codeType fromPerUnaligned(byte[] encodedBytes) {
    smlc_codeType result = new smlc_codeType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new smlc_codeType from encoded stream.
   */
  public static smlc_codeType fromPerAligned(byte[] encodedBytes) {
    smlc_codeType result = new smlc_codeType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""smlc_codeType = "" + getInteger() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class transaction_IDType extends Asn1Integer {
  //

  private static final Asn1Tag TAG_transaction_IDType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public transaction_IDType() {
    super();
    setValueRange(""0"", ""262143"");

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_transaction_IDType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_transaction_IDType != null) {
      return ImmutableList.of(TAG_transaction_IDType);
    } else {
      return Asn1Integer.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new transaction_IDType from encoded stream.
   */
  public static transaction_IDType fromPerUnaligned(byte[] encodedBytes) {
    transaction_IDType result = new transaction_IDType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new transaction_IDType from encoded stream.
   */
  public static transaction_IDType fromPerAligned(byte[] encodedBytes) {
    transaction_IDType result = new transaction_IDType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""transaction_IDType = "" + getInteger() + "";\n"";
  }
}

  

    

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    StringBuilder builder = new StringBuilder();
    builder.append(""Extended_reference = {\n"");
    final String internalIndent = indent + ""  "";
    for (SequenceComponent component : getComponents()) {
      if (component.isExplicitlySet()) {
        builder.append(internalIndent)
            .append(component.toIndentedString(internalIndent));
      }
    }
    if (isExtensible()) {
      builder.append(internalIndent).append(""...\n"");
      for (SequenceComponent component : getExtensionComponents()) {
        if (component.isExplicitlySet()) {
          builder.append(internalIndent)
              .append(component.toIndentedString(internalIndent));
        }
      }
    }
    builder.append(indent).append(""};\n"");
    return builder.toString();
  }
}"	"/home/gpoor/cts-12-source/cts/tests/location/location_gnss/src/android/location/cts/gnss/asn1/supl2/rrlp_components/Extended_reference.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.deviceandprofileowner.UnavailableSecureLockScreenTest"	"testResetWithTokenAndPasswordSufficiency"	""	"1: ui"	"public void testResetWithTokenAndPasswordSufficiency() throws Exception {
        // The password is always empty on devices which don't support the secure lock screen
        // feature.

        // Initially, when no password quality requirements are set, the empty password is
        // sufficient.
        assertPasswordSufficiency(true);
        try {

            // Resetting password should fail - it is not possible to set a password reset token or
            // a password on a device without the secure lock screen feature.
            assertFalse(mDevicePolicyManager.setResetPasswordToken(ADMIN_RECEIVER_COMPONENT, TOKEN));
            assertFalse(mDevicePolicyManager.resetPasswordWithToken(ADMIN_RECEIVER_COMPONENT,
                    COMPLEX_PASSWORD, TOKEN, 0));

            // As soon as some requirement for minimal password quality is set...
            mDevicePolicyManager.setPasswordQuality(
                    ADMIN_RECEIVER_COMPONENT, DevicePolicyManager.PASSWORD_QUALITY_SOMETHING);

            // ... the password is not sufficient any more.
            assertPasswordSufficiency(false);

            // If the requirement for minimal password quality is removed later...
            mDevicePolicyManager.setPasswordQuality(
                    ADMIN_RECEIVER_COMPONENT, DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED);

            // The empty password is sufficient again.
            assertPasswordSufficiency(true);
        } finally {
            mDevicePolicyManager.clearResetPasswordToken(ADMIN_RECEIVER_COMPONENT);
            mDevicePolicyManager.setPasswordQuality(
                    ADMIN_RECEIVER_COMPONENT, DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED);
        }
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/UnavailableSecureLockScreenTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.location.cts.gnss.asn1.supl2.ver2_ulp_components.WimaxRTD"	"isTagImplicit"	"CtsLocationGnssTestCases"	"1: ui"	"public void test/*
 *.
 */

package android.location.cts.asn1.supl2.ver2_ulp_components;

/*
 */


//
//
import android.location.cts.asn1.base.Asn1Integer;
import android.location.cts.asn1.base.Asn1Null;
import android.location.cts.asn1.base.Asn1Object;
import android.location.cts.asn1.base.Asn1Sequence;
import android.location.cts.asn1.base.Asn1Tag;
import android.location.cts.asn1.base.BitStream;
import android.location.cts.asn1.base.BitStreamReader;
import android.location.cts.asn1.base.SequenceComponent;
import com.google.common.collect.ImmutableList;
import java.util.Collection;
import javax.annotation.Nullable;


/**
*/
public  class WimaxRTD extends Asn1Sequence {
  //

  private static final Asn1Tag TAG_WimaxRTD
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public WimaxRTD() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_WimaxRTD;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_WimaxRTD != null) {
      return ImmutableList.of(TAG_WimaxRTD);
    } else {
      return Asn1Sequence.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new WimaxRTD from encoded stream.
   */
  public static WimaxRTD fromPerUnaligned(byte[] encodedBytes) {
    WimaxRTD result = new WimaxRTD();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new WimaxRTD from encoded stream.
   */
  public static WimaxRTD fromPerAligned(byte[] encodedBytes) {
    WimaxRTD result = new WimaxRTD();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }



  @Override protected boolean isExtensible() {
    return true;
  }

  @Override public boolean containsExtensionValues() {
    for (SequenceComponent extensionComponent : getExtensionComponents()) {
      if (extensionComponent.isExplicitlySet()) return true;
    }
    return false;
  }

  
  private WimaxRTD.rTDType rTD_;
  public WimaxRTD.rTDType getRTD() {
    return rTD_;
  }
  /**
   * @throws ClassCastException if value is not a WimaxRTD.rTDType
   */
  public void setRTD(Asn1Object value) {
    this.rTD_ = (WimaxRTD.rTDType) value;
  }
  public WimaxRTD.rTDType setRTDToNewInstance() {
    rTD_ = new WimaxRTD.rTDType();
    return rTD_;
  }
  
  private WimaxRTD.rTDstdType rTDstd_;
  public WimaxRTD.rTDstdType getRTDstd() {
    return rTDstd_;
  }
  /**
   * @throws ClassCastException if value is not a WimaxRTD.rTDstdType
   */
  public void setRTDstd(Asn1Object value) {
    this.rTDstd_ = (WimaxRTD.rTDstdType) value;
  }
  public WimaxRTD.rTDstdType setRTDstdToNewInstance() {
    rTDstd_ = new WimaxRTD.rTDstdType();
    return rTDstd_;
  }
  

  

  

  @Override public Iterable<? extends SequenceComponent> getComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 0);

          @Override public boolean isExplicitlySet() {
            return getRTD() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getRTD();
          }

          @Override public void setToNewInstance() {
            setRTDToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? WimaxRTD.rTDType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""rTD : ""
                    + getRTD().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 1);

          @Override public boolean isExplicitlySet() {
            return getRTDstd() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return true;
          }

          @Override public Asn1Object getComponentValue() {
            return getRTDstd();
          }

          @Override public void setToNewInstance() {
            setRTDstdToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? WimaxRTD.rTDstdType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""rTDstd : ""
                    + getRTDstd().toIndentedString(indent);
              }
        });
    
    return builder.build();
  }

  @Override public Iterable<? extends SequenceComponent>
                                                    getExtensionComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
      
      return builder.build();
    }

  
/*
 */


//

/**
 */
public static class rTDType extends Asn1Integer {
  //

  private static final Asn1Tag TAG_rTDType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public rTDType() {
    super();
    setValueRange(""0"", ""65535"");

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_rTDType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_rTDType != null) {
      return ImmutableList.of(TAG_rTDType);
    } else {
      return Asn1Integer.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new rTDType from encoded stream.
   */
  public static rTDType fromPerUnaligned(byte[] encodedBytes) {
    rTDType result = new rTDType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new rTDType from encoded stream.
   */
  public static rTDType fromPerAligned(byte[] encodedBytes) {
    rTDType result = new rTDType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""rTDType = "" + getInteger() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class rTDstdType extends Asn1Integer {
  //

  private static final Asn1Tag TAG_rTDstdType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public rTDstdType() {
    super();
    setValueRange(""0"", ""1023"");

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_rTDstdType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_rTDstdType != null) {
      return ImmutableList.of(TAG_rTDstdType);
    } else {
      return Asn1Integer.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new rTDstdType from encoded stream.
   */
  public static rTDstdType fromPerUnaligned(byte[] encodedBytes) {
    rTDstdType result = new rTDstdType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new rTDstdType from encoded stream.
   */
  public static rTDstdType fromPerAligned(byte[] encodedBytes) {
    rTDstdType result = new rTDstdType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""rTDstdType = "" + getInteger() + "";\n"";
  }
}

  

    

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    StringBuilder builder = new StringBuilder();
    builder.append(""WimaxRTD = {\n"");
    final String internalIndent = indent + ""  "";
    for (SequenceComponent component : getComponents()) {
      if (component.isExplicitlySet()) {
        builder.append(internalIndent)
            .append(component.toIndentedString(internalIndent));
      }
    }
    if (isExtensible()) {
      builder.append(internalIndent).append(""...\n"");
      for (SequenceComponent component : getExtensionComponents()) {
        if (component.isExplicitlySet()) {
          builder.append(internalIndent)
              .append(component.toIndentedString(internalIndent));
        }
      }
    }
    builder.append(indent).append(""};\n"");
    return builder.toString();
  }
}"	"/home/gpoor/cts-12-source/cts/tests/location/location_gnss/src/android/location/cts/gnss/asn1/supl2/ver2_ulp_components/WimaxRTD.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telephony.cts.TelephonyProtectedBroadcastsTest"	"testBroadcasts"	"CtsTelephonyTestCases"	"2: ui system"	"public void testBroadcasts() {
        StringBuilder errorMessage = new StringBuilder(); //Fail on all missing broadcasts
        for (String action : BACKGROUND_BROADCASTS) {
            try {
                Intent intent = new Intent(action);
                getContext().sendBroadcast(intent);

                //Add error message because no security exception was thrown.
                if (errorMessage.length() == 0) {
                    errorMessage.append(""--- Expected security exceptions when broadcasting on the ""
                            + ""following actions:"");
                    errorMessage.append(System.lineSeparator());
                }
                errorMessage.append(action);
                errorMessage.append(System.lineSeparator());

            } catch (SecurityException expected) {
            }
        }

        if (errorMessage.length() > 0) {
            errorMessage.append(""------------------------------------------------------------"");
            errorMessage.append(System.lineSeparator());
            fail(errorMessage.toString());
        }
    }

    private static Context getContext() {
        return InstrumentationRegistry.getContext();
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/telephony/current/src/android/telephony/cts/TelephonyProtectedBroadcastsTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.verifier.p2p.RequesterTestActivity"	"getTestCase"	""	"3: ui system user"	"public void test/*
 *.
 */
package com.android.cts.verifier.p2p;

import java.util.Collection;
import java.util.Timer;
import java.util.TimerTask;

import android.app.AlertDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.net.wifi.p2p.WifiP2pDevice;
import android.net.wifi.p2p.WifiP2pDeviceList;
import android.net.wifi.p2p.WifiP2pManager;
import android.net.wifi.p2p.WifiP2pManager.Channel;
import android.net.wifi.p2p.WifiP2pManager.PeerListListener;
import android.os.Bundle;
import android.os.Handler;
import android.view.WindowManager;
import android.widget.ProgressBar;
import android.widget.TextView;

import com.android.cts.verifier.PassFailButtons;
import com.android.cts.verifier.R;
import com.android.cts.verifier.R.id;
import com.android.cts.verifier.p2p.testcase.ReqTestCase;
import com.android.cts.verifier.p2p.testcase.TestCase;
import com.android.cts.verifier.p2p.testcase.TestCase.TestCaseListener;

/**
 * A base class for requester test activity.
 *
 * This class provides the feature to search target device and show test results.
 * A requester test activity just have to extend this class and implement getTestCase().
 */
public abstract class RequesterTestActivity  extends PassFailButtons.Activity
    implements TestCaseListener {

    /*
     * Timeout for searching devices. The unit is millisecond
     */
    private final static int SEARCH_TARGET_TIMEOUT = 8000;

    /*
     * The target device address.
     * The service discovery request test needs the responder address.
     * The target device address is reused until test failed.
     */
    private static String sTargetAddr;

    /*
     * The test case to be executed.
     */
    private ReqTestCase mTestCase;

    /*
     * The text view to print the test result
     */
    private TextView mTextView;

    /*
     * The progress bar.
     */
    private ProgressBar mProgress;

    /*
     * GUI thread handler.
     */
    private Handler mHandler = new Handler();

    /*
     * Timer object. It's used for searching devices.
     */
    private Timer mTimer;

    /*
     * p2p manager
     */
    private WifiP2pManager mP2pMgr;
    private Channel mChannel;

    /**
     * Return the specified requester test case.
     *
     * @param context
     * @param testId test id.
     * @return requester test case
     */
    protected abstract ReqTestCase getTestCase(Context context, String testId);

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.p2p_requester_main);
        setPassFailButtonClickListeners();
        getPassButton().setEnabled(false);

        mProgress = (ProgressBar) findViewById(R.id.p2p_progress);
        mProgress.setVisibility(ProgressBar.VISIBLE);
        mTextView = (TextView) findViewById(id.p2p_req_text);

        String testId = (String) getIntent().getSerializableExtra(
                TestCase.EXTRA_TEST_NAME);
        mTestCase = getTestCase(this, testId);
        setTitle(mTestCase.getTestName());

        // Initialize p2p manager.
        mP2pMgr = (WifiP2pManager) getSystemService(Context.WIFI_P2P_SERVICE);
        mChannel = mP2pMgr.initialize(this, getMainLooper(), null);

        // keep screen on while this activity is front view.
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
    }

    @Override
    protected void onDestroy() {
        if (mChannel != null) {
            mChannel.close();
        }

        super.onDestroy();
    }

    @Override
    protected void onResume() {
        super.onResume();
        /*
         * If the target device is NOT set, search targets and show
         * the target device list on the dialog.
         * After the user selection, the specified test will be executed.
         */
        if (sTargetAddr == null && !isNoPeerDiscoveryOnResume()) {
            searchTarget();
            return;
        }

        mTestCase.setTargetAddress(sTargetAddr);
        mTestCase.start(this);
    }

    @Override
    protected void onPause() {
        super.onPause();
        if (mTimer != null) {
            mTimer.cancel();
            mTimer = null;
        }
        mTestCase.stop();
    }

    @Override
    public String getTestId() {
        return mTestCase.getTestId();
    }

    @Override
    public void onTestStarted() {
        mHandler.post(new Runnable() {
            @Override
            public void run() {
                mProgress.setVisibility(ProgressBar.VISIBLE);
            }
        });
    }

    public void onTestMsgReceived(final String msg) {
        mHandler.post(new Runnable() {
            @Override
            public void run() {
                mTextView.setText(msg);
            }
        });
    }

    @Override
    public void onTestFailed(final String reason) {
        // if test failed, forget target device address.
        sTargetAddr = null;

        mHandler.post(new Runnable() {
            @Override
            public void run() {
                mProgress.setVisibility(ProgressBar.INVISIBLE);
                mTextView.setText(reason);
            }
        });
    }

    @Override
    public void onTestSuccess() {
        mHandler.post(new Runnable() {
            @Override
            public void run() {
                mProgress.setVisibility(ProgressBar.INVISIBLE);
                mTextView.setText(R.string.p2p_result_success);
                getPassButton().setEnabled(true);
            }
        });
    }

    /**
     * Do peer searching only, don't do peer selection.
     * For requester test which do not need to select a peer first.
     */
    protected boolean isSearchOnlyOnResume() {
        return false;
    }

    /** Do peer discovery or not
     *  For requester test which do not need to discover peer first.
     */
    protected boolean isNoPeerDiscoveryOnResume() {
        return false;
    }

    /**
     * Search devices and show the found devices on the dialog.
     * After user selection, the specified test will be executed.
     */
    private void searchTarget() {
        // Discover peers.
        mP2pMgr.discoverPeers(mChannel, null);
        mTextView.setText(R.string.p2p_searching_target);
        mProgress.setVisibility(ProgressBar.VISIBLE);

        /*
         * Show the peer list dialog after searching devices for 8 seconds.
         */
        if (mTimer == null) {
            mTimer = new Timer(true);
        }
        mTimer.schedule(new TimerTask() {
            @Override
            public void run() {
                mP2pMgr.requestPeers(mChannel, new PeerListListener() {
                    @Override
                    public void onPeersAvailable(WifiP2pDeviceList _peers) {
                        final WifiP2pDeviceList peers = _peers;
                        /*
                         * Need to show dialog in GUI thread.
                         */
                        mHandler.post(new Runnable() {
                            @Override
                            public void run() {
                                mProgress.setVisibility(ProgressBar.INVISIBLE);
                                if (peers.getDeviceList().size() == 0) {
                                    mTextView.setText(
                                            R.string.p2p_target_not_found_error);
                                } else {
                                    if (isSearchOnlyOnResume()) {
                                        mTestCase.start(getTestCaseListener());
                                    } else {
                                        showSelectTargetDialog(peers);
                                    }
                                }
                            }
                        });
                    }
                });
            }
        }, SEARCH_TARGET_TIMEOUT);
    }

    /**
     * Show the found device list on the dialog.
     * The target device address selected by user is stored in {@link #mTargetAddr}.
     * After user selection, the specified test will be executed.
     * @param peers
     * @param testIndex
     */
    private void showSelectTargetDialog(WifiP2pDeviceList peers) {
        final Collection<WifiP2pDevice> peerList = peers.getDeviceList();
        final CharSequence[] items = new CharSequence[peerList.size()];
        int i=0;
        for (WifiP2pDevice dev: peerList) {
            items[i++] = dev.deviceName;
        }

        new AlertDialog.Builder(this)
                .setIcon(android.R.drawable.ic_dialog_info)
                .setTitle(R.string.p2p_search_target)
                .setItems(items, new android.content.DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                int i=0;
                for (WifiP2pDevice dev: peerList) {
                    if (i == which) {
                        sTargetAddr = dev.deviceAddress;
                        mTestCase.setTargetAddress(sTargetAddr);
                        mTestCase.start(getTestCaseListener());
                        break;
                    }
                    i++;
                }
            }
        }).show();
    }

    private TestCaseListener getTestCaseListener() {
        return this;
    }
}"	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/p2p/RequesterTestActivity.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.location.cts.gnss.asn1.supl2.rrlp_components.GANSSSatelliteElement"	"isTagImplicit"	"CtsLocationGnssTestCases"	"1: ui"	"public void test/*
 *.
 */

package android.location.cts.asn1.supl2.rrlp_components;

/*
 */


//
//
import android.location.cts.asn1.base.Asn1BitString;
import android.location.cts.asn1.base.Asn1Integer;
import android.location.cts.asn1.base.Asn1Null;
import android.location.cts.asn1.base.Asn1Object;
import android.location.cts.asn1.base.Asn1Sequence;
import android.location.cts.asn1.base.Asn1Tag;
import android.location.cts.asn1.base.BitStream;
import android.location.cts.asn1.base.BitStreamReader;
import android.location.cts.asn1.base.SequenceComponent;
import com.google.common.collect.ImmutableList;
import java.util.Collection;
import javax.annotation.Nullable;


/**
*/
public  class GANSSSatelliteElement extends Asn1Sequence {
  //

  private static final Asn1Tag TAG_GANSSSatelliteElement
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public GANSSSatelliteElement() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_GANSSSatelliteElement;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_GANSSSatelliteElement != null) {
      return ImmutableList.of(TAG_GANSSSatelliteElement);
    } else {
      return Asn1Sequence.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new GANSSSatelliteElement from encoded stream.
   */
  public static GANSSSatelliteElement fromPerUnaligned(byte[] encodedBytes) {
    GANSSSatelliteElement result = new GANSSSatelliteElement();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new GANSSSatelliteElement from encoded stream.
   */
  public static GANSSSatelliteElement fromPerAligned(byte[] encodedBytes) {
    GANSSSatelliteElement result = new GANSSSatelliteElement();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }



  @Override protected boolean isExtensible() {
    return true;
  }

  @Override public boolean containsExtensionValues() {
    for (SequenceComponent extensionComponent : getExtensionComponents()) {
      if (extensionComponent.isExplicitlySet()) return true;
    }
    return false;
  }

  
  private SVID svID_;
  public SVID getSvID() {
    return svID_;
  }
  /**
   * @throws ClassCastException if value is not a SVID
   */
  public void setSvID(Asn1Object value) {
    this.svID_ = (SVID) value;
  }
  public SVID setSvIDToNewInstance() {
    svID_ = new SVID();
    return svID_;
  }
  
  private GANSSSatelliteElement.svHealthType svHealth_;
  public GANSSSatelliteElement.svHealthType getSvHealth() {
    return svHealth_;
  }
  /**
   * @throws ClassCastException if value is not a GANSSSatelliteElement.svHealthType
   */
  public void setSvHealth(Asn1Object value) {
    this.svHealth_ = (GANSSSatelliteElement.svHealthType) value;
  }
  public GANSSSatelliteElement.svHealthType setSvHealthToNewInstance() {
    svHealth_ = new GANSSSatelliteElement.svHealthType();
    return svHealth_;
  }
  
  private GANSSSatelliteElement.iodType iod_;
  public GANSSSatelliteElement.iodType getIod() {
    return iod_;
  }
  /**
   * @throws ClassCastException if value is not a GANSSSatelliteElement.iodType
   */
  public void setIod(Asn1Object value) {
    this.iod_ = (GANSSSatelliteElement.iodType) value;
  }
  public GANSSSatelliteElement.iodType setIodToNewInstance() {
    iod_ = new GANSSSatelliteElement.iodType();
    return iod_;
  }
  
  private GANSSClockModel ganssClockModel_;
  public GANSSClockModel getGanssClockModel() {
    return ganssClockModel_;
  }
  /**
   * @throws ClassCastException if value is not a GANSSClockModel
   */
  public void setGanssClockModel(Asn1Object value) {
    this.ganssClockModel_ = (GANSSClockModel) value;
  }
  public GANSSClockModel setGanssClockModelToNewInstance() {
    ganssClockModel_ = new GANSSClockModel();
    return ganssClockModel_;
  }
  
  private GANSSOrbitModel ganssOrbitModel_;
  public GANSSOrbitModel getGanssOrbitModel() {
    return ganssOrbitModel_;
  }
  /**
   * @throws ClassCastException if value is not a GANSSOrbitModel
   */
  public void setGanssOrbitModel(Asn1Object value) {
    this.ganssOrbitModel_ = (GANSSOrbitModel) value;
  }
  public GANSSOrbitModel setGanssOrbitModelToNewInstance() {
    ganssOrbitModel_ = new GANSSOrbitModel();
    return ganssOrbitModel_;
  }
  

  
  private GANSSSatelliteElement.svHealthMSBType  extensionSvHealthMSB;
  public GANSSSatelliteElement.svHealthMSBType getExtensionSvHealthMSB() {
    return extensionSvHealthMSB;
  }
  /**
   * @throws ClassCastException if value is not a GANSSSatelliteElement.svHealthMSBType
   */
  public void setExtensionSvHealthMSB(Asn1Object value) {
    extensionSvHealthMSB = (GANSSSatelliteElement.svHealthMSBType) value;
  }
  public void setExtensionSvHealthMSBToNewInstance() {
    extensionSvHealthMSB = new GANSSSatelliteElement.svHealthMSBType();
  }
    
  private GANSSSatelliteElement.iodMSBType  extensionIodMSB;
  public GANSSSatelliteElement.iodMSBType getExtensionIodMSB() {
    return extensionIodMSB;
  }
  /**
   * @throws ClassCastException if value is not a GANSSSatelliteElement.iodMSBType
   */
  public void setExtensionIodMSB(Asn1Object value) {
    extensionIodMSB = (GANSSSatelliteElement.iodMSBType) value;
  }
  public void setExtensionIodMSBToNewInstance() {
    extensionIodMSB = new GANSSSatelliteElement.iodMSBType();
  }
    

  

  @Override public Iterable<? extends SequenceComponent> getComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 0);

          @Override public boolean isExplicitlySet() {
            return getSvID() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getSvID();
          }

          @Override public void setToNewInstance() {
            setSvIDToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SVID.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""svID : ""
                    + getSvID().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 1);

          @Override public boolean isExplicitlySet() {
            return getSvHealth() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getSvHealth();
          }

          @Override public void setToNewInstance() {
            setSvHealthToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? GANSSSatelliteElement.svHealthType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""svHealth : ""
                    + getSvHealth().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 2);

          @Override public boolean isExplicitlySet() {
            return getIod() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getIod();
          }

          @Override public void setToNewInstance() {
            setIodToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? GANSSSatelliteElement.iodType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""iod : ""
                    + getIod().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 3);

          @Override public boolean isExplicitlySet() {
            return getGanssClockModel() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getGanssClockModel();
          }

          @Override public void setToNewInstance() {
            setGanssClockModelToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? GANSSClockModel.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""ganssClockModel : ""
                    + getGanssClockModel().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 4);

          @Override public boolean isExplicitlySet() {
            return getGanssOrbitModel() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getGanssOrbitModel();
          }

          @Override public void setToNewInstance() {
            setGanssOrbitModelToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? GANSSOrbitModel.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""ganssOrbitModel : ""
                    + getGanssOrbitModel().toIndentedString(indent);
              }
        });
    
    return builder.build();
  }

  @Override public Iterable<? extends SequenceComponent>
                                                    getExtensionComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
      
      builder.add(new SequenceComponent() {
            @Override public boolean isExplicitlySet() {
              return getExtensionSvHealthMSB() != null;
            }

            @Override public boolean hasDefaultValue() {
              return false;
            }

            @Override public boolean isOptional() {
              return true;
            }

            @Override public Asn1Object getComponentValue() {
              return getExtensionSvHealthMSB();
            }

            @Override public void setToNewInstance() {
              setExtensionSvHealthMSBToNewInstance();
            }

            @Override public Collection<Asn1Tag> getPossibleFirstTags() {
              throw new UnsupportedOperationException(
                  ""BER decoding not supported for extension elements"");
            }

            @Override
            public Asn1Tag getTag() {
              throw new UnsupportedOperationException(
                  ""BER is not supported for extension elements"");
            }

            @Override
            public boolean isImplicitTagging() {
              throw new UnsupportedOperationException(
                  ""BER is not supported for extension elements"");
            }

            @Override public String toIndentedString(String indent) {
              return ""svHealthMSB : ""
                  + getExtensionSvHealthMSB().toIndentedString(indent);
            }
      });
      
      builder.add(new SequenceComponent() {
            @Override public boolean isExplicitlySet() {
              return getExtensionIodMSB() != null;
            }

            @Override public boolean hasDefaultValue() {
              return false;
            }

            @Override public boolean isOptional() {
              return true;
            }

            @Override public Asn1Object getComponentValue() {
              return getExtensionIodMSB();
            }

            @Override public void setToNewInstance() {
              setExtensionIodMSBToNewInstance();
            }

            @Override public Collection<Asn1Tag> getPossibleFirstTags() {
              throw new UnsupportedOperationException(
                  ""BER decoding not supported for extension elements"");
            }

            @Override
            public Asn1Tag getTag() {
              throw new UnsupportedOperationException(
                  ""BER is not supported for extension elements"");
            }

            @Override
            public boolean isImplicitTagging() {
              throw new UnsupportedOperationException(
                  ""BER is not supported for extension elements"");
            }

            @Override public String toIndentedString(String indent) {
              return ""iodMSB : ""
                  + getExtensionIodMSB().toIndentedString(indent);
            }
      });
      
      return builder.build();
    }

  
  
  
/*
 */


//

/**
 */
public static class svHealthType extends Asn1BitString {
  //

  private static final Asn1Tag TAG_svHealthType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public svHealthType() {
    super();
    setMinSize(5);
setMaxSize(5);

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_svHealthType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_svHealthType != null) {
      return ImmutableList.of(TAG_svHealthType);
    } else {
      return Asn1BitString.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new svHealthType from encoded stream.
   */
  public static svHealthType fromPerUnaligned(byte[] encodedBytes) {
    svHealthType result = new svHealthType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new svHealthType from encoded stream.
   */
  public static svHealthType fromPerAligned(byte[] encodedBytes) {
    svHealthType result = new svHealthType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""svHealthType = "" + getValue() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class iodType extends Asn1Integer {
  //

  private static final Asn1Tag TAG_iodType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public iodType() {
    super();
    setValueRange(""0"", ""1023"");

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_iodType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_iodType != null) {
      return ImmutableList.of(TAG_iodType);
    } else {
      return Asn1Integer.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new iodType from encoded stream.
   */
  public static iodType fromPerUnaligned(byte[] encodedBytes) {
    iodType result = new iodType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new iodType from encoded stream.
   */
  public static iodType fromPerAligned(byte[] encodedBytes) {
    iodType result = new iodType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""iodType = "" + getInteger() + "";\n"";
  }
}

  
  
  
  
  

    
/*
 */


//

/**
 */
public static class svHealthMSBType extends Asn1BitString {
  //

  private static final Asn1Tag TAG_svHealthMSBType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public svHealthMSBType() {
    super();
    setMinSize(1);
setMaxSize(1);

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_svHealthMSBType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_svHealthMSBType != null) {
      return ImmutableList.of(TAG_svHealthMSBType);
    } else {
      return Asn1BitString.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new svHealthMSBType from encoded stream.
   */
  public static svHealthMSBType fromPerUnaligned(byte[] encodedBytes) {
    svHealthMSBType result = new svHealthMSBType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new svHealthMSBType from encoded stream.
   */
  public static svHealthMSBType fromPerAligned(byte[] encodedBytes) {
    svHealthMSBType result = new svHealthMSBType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""svHealthMSBType = "" + getValue() + "";\n"";
  }
}

    
/*
 */


//

/**
 */
public static class iodMSBType extends Asn1Integer {
  //

  private static final Asn1Tag TAG_iodMSBType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public iodMSBType() {
    super();
    setValueRange(""0"", ""1"");

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_iodMSBType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_iodMSBType != null) {
      return ImmutableList.of(TAG_iodMSBType);
    } else {
      return Asn1Integer.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new iodMSBType from encoded stream.
   */
  public static iodMSBType fromPerUnaligned(byte[] encodedBytes) {
    iodMSBType result = new iodMSBType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new iodMSBType from encoded stream.
   */
  public static iodMSBType fromPerAligned(byte[] encodedBytes) {
    iodMSBType result = new iodMSBType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""iodMSBType = "" + getInteger() + "";\n"";
  }
}

    

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    StringBuilder builder = new StringBuilder();
    builder.append(""GANSSSatelliteElement = {\n"");
    final String internalIndent = indent + ""  "";
    for (SequenceComponent component : getComponents()) {
      if (component.isExplicitlySet()) {
        builder.append(internalIndent)
            .append(component.toIndentedString(internalIndent));
      }
    }
    if (isExtensible()) {
      builder.append(internalIndent).append(""...\n"");
      for (SequenceComponent component : getExtensionComponents()) {
        if (component.isExplicitlySet()) {
          builder.append(internalIndent)
              .append(component.toIndentedString(internalIndent));
        }
      }
    }
    builder.append(indent).append(""};\n"");
    return builder.toString();
  }
}"	"/home/gpoor/cts-12-source/cts/tests/location/location_gnss/src/android/location/cts/gnss/asn1/supl2/rrlp_components/GANSSSatelliteElement.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.location.cts.gnss.asn1.supl2.rrlp_components.GANSSGenericAssistDataElement"	"GANSSGenericAssistDataElement"	"CtsLocationGnssTestCases"	"1: ui"	"public void test/*
 *.
 */

package android.location.cts.asn1.supl2.rrlp_components;

/*
 */


//
//
import android.location.cts.asn1.base.Asn1Integer;
import android.location.cts.asn1.base.Asn1Null;
import android.location.cts.asn1.base.Asn1Object;
import android.location.cts.asn1.base.Asn1Sequence;
import android.location.cts.asn1.base.Asn1Tag;
import android.location.cts.asn1.base.BitStream;
import android.location.cts.asn1.base.BitStreamReader;
import android.location.cts.asn1.base.SequenceComponent;
import com.google.common.collect.ImmutableList;
import java.util.Collection;
import javax.annotation.Nullable;


/**
*/
public  class GANSSGenericAssistDataElement extends Asn1Sequence {
  //

  private static final Asn1Tag TAG_GANSSGenericAssistDataElement
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public GANSSGenericAssistDataElement() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_GANSSGenericAssistDataElement;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_GANSSGenericAssistDataElement != null) {
      return ImmutableList.of(TAG_GANSSGenericAssistDataElement);
    } else {
      return Asn1Sequence.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new GANSSGenericAssistDataElement from encoded stream.
   */
  public static GANSSGenericAssistDataElement fromPerUnaligned(byte[] encodedBytes) {
    GANSSGenericAssistDataElement result = new GANSSGenericAssistDataElement();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new GANSSGenericAssistDataElement from encoded stream.
   */
  public static GANSSGenericAssistDataElement fromPerAligned(byte[] encodedBytes) {
    GANSSGenericAssistDataElement result = new GANSSGenericAssistDataElement();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }



  @Override protected boolean isExtensible() {
    return true;
  }

  @Override public boolean containsExtensionValues() {
    for (SequenceComponent extensionComponent : getExtensionComponents()) {
      if (extensionComponent.isExplicitlySet()) return true;
    }
    return false;
  }

  
  private GANSSGenericAssistDataElement.ganssIDType ganssID_;
  public GANSSGenericAssistDataElement.ganssIDType getGanssID() {
    return ganssID_;
  }
  /**
   * @throws ClassCastException if value is not a GANSSGenericAssistDataElement.ganssIDType
   */
  public void setGanssID(Asn1Object value) {
    this.ganssID_ = (GANSSGenericAssistDataElement.ganssIDType) value;
  }
  public GANSSGenericAssistDataElement.ganssIDType setGanssIDToNewInstance() {
    ganssID_ = new GANSSGenericAssistDataElement.ganssIDType();
    return ganssID_;
  }
  
  private SeqOfGANSSTimeModel ganssTimeModel_;
  public SeqOfGANSSTimeModel getGanssTimeModel() {
    return ganssTimeModel_;
  }
  /**
   * @throws ClassCastException if value is not a SeqOfGANSSTimeModel
   */
  public void setGanssTimeModel(Asn1Object value) {
    this.ganssTimeModel_ = (SeqOfGANSSTimeModel) value;
  }
  public SeqOfGANSSTimeModel setGanssTimeModelToNewInstance() {
    ganssTimeModel_ = new SeqOfGANSSTimeModel();
    return ganssTimeModel_;
  }
  
  private GANSSDiffCorrections ganssDiffCorrections_;
  public GANSSDiffCorrections getGanssDiffCorrections() {
    return ganssDiffCorrections_;
  }
  /**
   * @throws ClassCastException if value is not a GANSSDiffCorrections
   */
  public void setGanssDiffCorrections(Asn1Object value) {
    this.ganssDiffCorrections_ = (GANSSDiffCorrections) value;
  }
  public GANSSDiffCorrections setGanssDiffCorrectionsToNewInstance() {
    ganssDiffCorrections_ = new GANSSDiffCorrections();
    return ganssDiffCorrections_;
  }
  
  private GANSSNavModel ganssNavigationModel_;
  public GANSSNavModel getGanssNavigationModel() {
    return ganssNavigationModel_;
  }
  /**
   * @throws ClassCastException if value is not a GANSSNavModel
   */
  public void setGanssNavigationModel(Asn1Object value) {
    this.ganssNavigationModel_ = (GANSSNavModel) value;
  }
  public GANSSNavModel setGanssNavigationModelToNewInstance() {
    ganssNavigationModel_ = new GANSSNavModel();
    return ganssNavigationModel_;
  }
  
  private GANSSRealTimeIntegrity ganssRealTimeIntegrity_;
  public GANSSRealTimeIntegrity getGanssRealTimeIntegrity() {
    return ganssRealTimeIntegrity_;
  }
  /**
   * @throws ClassCastException if value is not a GANSSRealTimeIntegrity
   */
  public void setGanssRealTimeIntegrity(Asn1Object value) {
    this.ganssRealTimeIntegrity_ = (GANSSRealTimeIntegrity) value;
  }
  public GANSSRealTimeIntegrity setGanssRealTimeIntegrityToNewInstance() {
    ganssRealTimeIntegrity_ = new GANSSRealTimeIntegrity();
    return ganssRealTimeIntegrity_;
  }
  
  private GANSSDataBitAssist ganssDataBitAssist_;
  public GANSSDataBitAssist getGanssDataBitAssist() {
    return ganssDataBitAssist_;
  }
  /**
   * @throws ClassCastException if value is not a GANSSDataBitAssist
   */
  public void setGanssDataBitAssist(Asn1Object value) {
    this.ganssDataBitAssist_ = (GANSSDataBitAssist) value;
  }
  public GANSSDataBitAssist setGanssDataBitAssistToNewInstance() {
    ganssDataBitAssist_ = new GANSSDataBitAssist();
    return ganssDataBitAssist_;
  }
  
  private GANSSRefMeasurementAssist ganssRefMeasurementAssist_;
  public GANSSRefMeasurementAssist getGanssRefMeasurementAssist() {
    return ganssRefMeasurementAssist_;
  }
  /**
   * @throws ClassCastException if value is not a GANSSRefMeasurementAssist
   */
  public void setGanssRefMeasurementAssist(Asn1Object value) {
    this.ganssRefMeasurementAssist_ = (GANSSRefMeasurementAssist) value;
  }
  public GANSSRefMeasurementAssist setGanssRefMeasurementAssistToNewInstance() {
    ganssRefMeasurementAssist_ = new GANSSRefMeasurementAssist();
    return ganssRefMeasurementAssist_;
  }
  
  private GANSSAlmanacModel ganssAlmanacModel_;
  public GANSSAlmanacModel getGanssAlmanacModel() {
    return ganssAlmanacModel_;
  }
  /**
   * @throws ClassCastException if value is not a GANSSAlmanacModel
   */
  public void setGanssAlmanacModel(Asn1Object value) {
    this.ganssAlmanacModel_ = (GANSSAlmanacModel) value;
  }
  public GANSSAlmanacModel setGanssAlmanacModelToNewInstance() {
    ganssAlmanacModel_ = new GANSSAlmanacModel();
    return ganssAlmanacModel_;
  }
  
  private GANSSUTCModel ganssUTCModel_;
  public GANSSUTCModel getGanssUTCModel() {
    return ganssUTCModel_;
  }
  /**
   * @throws ClassCastException if value is not a GANSSUTCModel
   */
  public void setGanssUTCModel(Asn1Object value) {
    this.ganssUTCModel_ = (GANSSUTCModel) value;
  }
  public GANSSUTCModel setGanssUTCModelToNewInstance() {
    ganssUTCModel_ = new GANSSUTCModel();
    return ganssUTCModel_;
  }
  
  private GANSSEphemerisExtension ganssEphemerisExtension_;
  public GANSSEphemerisExtension getGanssEphemerisExtension() {
    return ganssEphemerisExtension_;
  }
  /**
   * @throws ClassCastException if value is not a GANSSEphemerisExtension
   */
  public void setGanssEphemerisExtension(Asn1Object value) {
    this.ganssEphemerisExtension_ = (GANSSEphemerisExtension) value;
  }
  public GANSSEphemerisExtension setGanssEphemerisExtensionToNewInstance() {
    ganssEphemerisExtension_ = new GANSSEphemerisExtension();
    return ganssEphemerisExtension_;
  }
  
  private GANSSEphemerisExtensionCheck ganssEphemerisExtCheck_;
  public GANSSEphemerisExtensionCheck getGanssEphemerisExtCheck() {
    return ganssEphemerisExtCheck_;
  }
  /**
   * @throws ClassCastException if value is not a GANSSEphemerisExtensionCheck
   */
  public void setGanssEphemerisExtCheck(Asn1Object value) {
    this.ganssEphemerisExtCheck_ = (GANSSEphemerisExtensionCheck) value;
  }
  public GANSSEphemerisExtensionCheck setGanssEphemerisExtCheckToNewInstance() {
    ganssEphemerisExtCheck_ = new GANSSEphemerisExtensionCheck();
    return ganssEphemerisExtCheck_;
  }
  

  
  private GANSSGenericAssistDataElement.sbasIDType  extensionSbasID;
  public GANSSGenericAssistDataElement.sbasIDType getExtensionSbasID() {
    return extensionSbasID;
  }
  /**
   * @throws ClassCastException if value is not a GANSSGenericAssistDataElement.sbasIDType
   */
  public void setExtensionSbasID(Asn1Object value) {
    extensionSbasID = (GANSSGenericAssistDataElement.sbasIDType) value;
  }
  public void setExtensionSbasIDToNewInstance() {
    extensionSbasID = new GANSSGenericAssistDataElement.sbasIDType();
  }
    
  private GANSSAddUTCModel  extensionGanssAddUTCModel;
  public GANSSAddUTCModel getExtensionGanssAddUTCModel() {
    return extensionGanssAddUTCModel;
  }
  /**
   * @throws ClassCastException if value is not a GANSSAddUTCModel
   */
  public void setExtensionGanssAddUTCModel(Asn1Object value) {
    extensionGanssAddUTCModel = (GANSSAddUTCModel) value;
  }
  public void setExtensionGanssAddUTCModelToNewInstance() {
    extensionGanssAddUTCModel = new GANSSAddUTCModel();
  }
    
  private GANSSAuxiliaryInformation  extensionGanssAuxiliaryInfo;
  public GANSSAuxiliaryInformation getExtensionGanssAuxiliaryInfo() {
    return extensionGanssAuxiliaryInfo;
  }
  /**
   * @throws ClassCastException if value is not a GANSSAuxiliaryInformation
   */
  public void setExtensionGanssAuxiliaryInfo(Asn1Object value) {
    extensionGanssAuxiliaryInfo = (GANSSAuxiliaryInformation) value;
  }
  public void setExtensionGanssAuxiliaryInfoToNewInstance() {
    extensionGanssAuxiliaryInfo = new GANSSAuxiliaryInformation();
  }
    
  private GANSSDiffCorrectionsValidityPeriod  extensionGanssDiffCorrectionsValidityPeriod;
  public GANSSDiffCorrectionsValidityPeriod getExtensionGanssDiffCorrectionsValidityPeriod() {
    return extensionGanssDiffCorrectionsValidityPeriod;
  }
  /**
   * @throws ClassCastException if value is not a GANSSDiffCorrectionsValidityPeriod
   */
  public void setExtensionGanssDiffCorrectionsValidityPeriod(Asn1Object value) {
    extensionGanssDiffCorrectionsValidityPeriod = (GANSSDiffCorrectionsValidityPeriod) value;
  }
  public void setExtensionGanssDiffCorrectionsValidityPeriodToNewInstance() {
    extensionGanssDiffCorrectionsValidityPeriod = new GANSSDiffCorrectionsValidityPeriod();
  }
    

  

  @Override public Iterable<? extends SequenceComponent> getComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 0);

          @Override public boolean isExplicitlySet() {
            return getGanssID() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return true;
          }

          @Override public Asn1Object getComponentValue() {
            return getGanssID();
          }

          @Override public void setToNewInstance() {
            setGanssIDToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? GANSSGenericAssistDataElement.ganssIDType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""ganssID : ""
                    + getGanssID().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 1);

          @Override public boolean isExplicitlySet() {
            return getGanssTimeModel() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return true;
          }

          @Override public Asn1Object getComponentValue() {
            return getGanssTimeModel();
          }

          @Override public void setToNewInstance() {
            setGanssTimeModelToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? SeqOfGANSSTimeModel.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""ganssTimeModel : ""
                    + getGanssTimeModel().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 2);

          @Override public boolean isExplicitlySet() {
            return getGanssDiffCorrections() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return true;
          }

          @Override public Asn1Object getComponentValue() {
            return getGanssDiffCorrections();
          }

          @Override public void setToNewInstance() {
            setGanssDiffCorrectionsToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? GANSSDiffCorrections.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""ganssDiffCorrections : ""
                    + getGanssDiffCorrections().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 3);

          @Override public boolean isExplicitlySet() {
            return getGanssNavigationModel() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return true;
          }

          @Override public Asn1Object getComponentValue() {
            return getGanssNavigationModel();
          }

          @Override public void setToNewInstance() {
            setGanssNavigationModelToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? GANSSNavModel.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""ganssNavigationModel : ""
                    + getGanssNavigationModel().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 4);

          @Override public boolean isExplicitlySet() {
            return getGanssRealTimeIntegrity() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return true;
          }

          @Override public Asn1Object getComponentValue() {
            return getGanssRealTimeIntegrity();
          }

          @Override public void setToNewInstance() {
            setGanssRealTimeIntegrityToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? GANSSRealTimeIntegrity.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""ganssRealTimeIntegrity : ""
                    + getGanssRealTimeIntegrity().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 5);

          @Override public boolean isExplicitlySet() {
            return getGanssDataBitAssist() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return true;
          }

          @Override public Asn1Object getComponentValue() {
            return getGanssDataBitAssist();
          }

          @Override public void setToNewInstance() {
            setGanssDataBitAssistToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? GANSSDataBitAssist.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""ganssDataBitAssist : ""
                    + getGanssDataBitAssist().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 6);

          @Override public boolean isExplicitlySet() {
            return getGanssRefMeasurementAssist() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return true;
          }

          @Override public Asn1Object getComponentValue() {
            return getGanssRefMeasurementAssist();
          }

          @Override public void setToNewInstance() {
            setGanssRefMeasurementAssistToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? GANSSRefMeasurementAssist.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""ganssRefMeasurementAssist : ""
                    + getGanssRefMeasurementAssist().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 7);

          @Override public boolean isExplicitlySet() {
            return getGanssAlmanacModel() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return true;
          }

          @Override public Asn1Object getComponentValue() {
            return getGanssAlmanacModel();
          }

          @Override public void setToNewInstance() {
            setGanssAlmanacModelToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? GANSSAlmanacModel.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""ganssAlmanacModel : ""
                    + getGanssAlmanacModel().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 8);

          @Override public boolean isExplicitlySet() {
            return getGanssUTCModel() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return true;
          }

          @Override public Asn1Object getComponentValue() {
            return getGanssUTCModel();
          }

          @Override public void setToNewInstance() {
            setGanssUTCModelToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? GANSSUTCModel.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""ganssUTCModel : ""
                    + getGanssUTCModel().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 9);

          @Override public boolean isExplicitlySet() {
            return getGanssEphemerisExtension() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return true;
          }

          @Override public Asn1Object getComponentValue() {
            return getGanssEphemerisExtension();
          }

          @Override public void setToNewInstance() {
            setGanssEphemerisExtensionToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? GANSSEphemerisExtension.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""ganssEphemerisExtension : ""
                    + getGanssEphemerisExtension().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 10);

          @Override public boolean isExplicitlySet() {
            return getGanssEphemerisExtCheck() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return true;
          }

          @Override public Asn1Object getComponentValue() {
            return getGanssEphemerisExtCheck();
          }

          @Override public void setToNewInstance() {
            setGanssEphemerisExtCheckToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? GANSSEphemerisExtensionCheck.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""ganssEphemerisExtCheck : ""
                    + getGanssEphemerisExtCheck().toIndentedString(indent);
              }
        });
    
    return builder.build();
  }

  @Override public Iterable<? extends SequenceComponent>
                                                    getExtensionComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
      
      builder.add(new SequenceComponent() {
            @Override public boolean isExplicitlySet() {
              return getExtensionSbasID() != null;
            }

            @Override public boolean hasDefaultValue() {
              return false;
            }

            @Override public boolean isOptional() {
              return true;
            }

            @Override public Asn1Object getComponentValue() {
              return getExtensionSbasID();
            }

            @Override public void setToNewInstance() {
              setExtensionSbasIDToNewInstance();
            }

            @Override public Collection<Asn1Tag> getPossibleFirstTags() {
              throw new UnsupportedOperationException(
                  ""BER decoding not supported for extension elements"");
            }

            @Override
            public Asn1Tag getTag() {
              throw new UnsupportedOperationException(
                  ""BER is not supported for extension elements"");
            }

            @Override
            public boolean isImplicitTagging() {
              throw new UnsupportedOperationException(
                  ""BER is not supported for extension elements"");
            }

            @Override public String toIndentedString(String indent) {
              return ""sbasID : ""
                  + getExtensionSbasID().toIndentedString(indent);
            }
      });
      
      builder.add(new SequenceComponent() {
            @Override public boolean isExplicitlySet() {
              return getExtensionGanssAddUTCModel() != null;
            }

            @Override public boolean hasDefaultValue() {
              return false;
            }

            @Override public boolean isOptional() {
              return true;
            }

            @Override public Asn1Object getComponentValue() {
              return getExtensionGanssAddUTCModel();
            }

            @Override public void setToNewInstance() {
              setExtensionGanssAddUTCModelToNewInstance();
            }

            @Override public Collection<Asn1Tag> getPossibleFirstTags() {
              throw new UnsupportedOperationException(
                  ""BER decoding not supported for extension elements"");
            }

            @Override
            public Asn1Tag getTag() {
              throw new UnsupportedOperationException(
                  ""BER is not supported for extension elements"");
            }

            @Override
            public boolean isImplicitTagging() {
              throw new UnsupportedOperationException(
                  ""BER is not supported for extension elements"");
            }

            @Override public String toIndentedString(String indent) {
              return ""ganssAddUTCModel : ""
                  + getExtensionGanssAddUTCModel().toIndentedString(indent);
            }
      });
      
      builder.add(new SequenceComponent() {
            @Override public boolean isExplicitlySet() {
              return getExtensionGanssAuxiliaryInfo() != null;
            }

            @Override public boolean hasDefaultValue() {
              return false;
            }

            @Override public boolean isOptional() {
              return true;
            }

            @Override public Asn1Object getComponentValue() {
              return getExtensionGanssAuxiliaryInfo();
            }

            @Override public void setToNewInstance() {
              setExtensionGanssAuxiliaryInfoToNewInstance();
            }

            @Override public Collection<Asn1Tag> getPossibleFirstTags() {
              throw new UnsupportedOperationException(
                  ""BER decoding not supported for extension elements"");
            }

            @Override
            public Asn1Tag getTag() {
              throw new UnsupportedOperationException(
                  ""BER is not supported for extension elements"");
            }

            @Override
            public boolean isImplicitTagging() {
              throw new UnsupportedOperationException(
                  ""BER is not supported for extension elements"");
            }

            @Override public String toIndentedString(String indent) {
              return ""ganssAuxiliaryInfo : ""
                  + getExtensionGanssAuxiliaryInfo().toIndentedString(indent);
            }
      });
      
      builder.add(new SequenceComponent() {
            @Override public boolean isExplicitlySet() {
              return getExtensionGanssDiffCorrectionsValidityPeriod() != null;
            }

            @Override public boolean hasDefaultValue() {
              return false;
            }

            @Override public boolean isOptional() {
              return true;
            }

            @Override public Asn1Object getComponentValue() {
              return getExtensionGanssDiffCorrectionsValidityPeriod();
            }

            @Override public void setToNewInstance() {
              setExtensionGanssDiffCorrectionsValidityPeriodToNewInstance();
            }

            @Override public Collection<Asn1Tag> getPossibleFirstTags() {
              throw new UnsupportedOperationException(
                  ""BER decoding not supported for extension elements"");
            }

            @Override
            public Asn1Tag getTag() {
              throw new UnsupportedOperationException(
                  ""BER is not supported for extension elements"");
            }

            @Override
            public boolean isImplicitTagging() {
              throw new UnsupportedOperationException(
                  ""BER is not supported for extension elements"");
            }

            @Override public String toIndentedString(String indent) {
              return ""ganssDiffCorrectionsValidityPeriod : ""
                  + getExtensionGanssDiffCorrectionsValidityPeriod().toIndentedString(indent);
            }
      });
      
      return builder.build();
    }

  
/*
 */


//

/**
 */
public static class ganssIDType extends Asn1Integer {
  //

  private static final Asn1Tag TAG_ganssIDType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public ganssIDType() {
    super();
    setValueRange(""0"", ""7"");

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_ganssIDType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_ganssIDType != null) {
      return ImmutableList.of(TAG_ganssIDType);
    } else {
      return Asn1Integer.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new ganssIDType from encoded stream.
   */
  public static ganssIDType fromPerUnaligned(byte[] encodedBytes) {
    ganssIDType result = new ganssIDType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new ganssIDType from encoded stream.
   */
  public static ganssIDType fromPerAligned(byte[] encodedBytes) {
    ganssIDType result = new ganssIDType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""ganssIDType = "" + getInteger() + "";\n"";
  }
}

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

    
/*
 */


//

/**
 */
public static class sbasIDType extends Asn1Integer {
  //

  private static final Asn1Tag TAG_sbasIDType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public sbasIDType() {
    super();
    setValueRange(""0"", ""7"");

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_sbasIDType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_sbasIDType != null) {
      return ImmutableList.of(TAG_sbasIDType);
    } else {
      return Asn1Integer.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new sbasIDType from encoded stream.
   */
  public static sbasIDType fromPerUnaligned(byte[] encodedBytes) {
    sbasIDType result = new sbasIDType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new sbasIDType from encoded stream.
   */
  public static sbasIDType fromPerAligned(byte[] encodedBytes) {
    sbasIDType result = new sbasIDType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""sbasIDType = "" + getInteger() + "";\n"";
  }
}

    
    
    
    
    
    
    

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    StringBuilder builder = new StringBuilder();
    builder.append(""GANSSGenericAssistDataElement = {\n"");
    final String internalIndent = indent + ""  "";
    for (SequenceComponent component : getComponents()) {
      if (component.isExplicitlySet()) {
        builder.append(internalIndent)
            .append(component.toIndentedString(internalIndent));
      }
    }
    if (isExtensible()) {
      builder.append(internalIndent).append(""...\n"");
      for (SequenceComponent component : getExtensionComponents()) {
        if (component.isExplicitlySet()) {
          builder.append(internalIndent)
              .append(component.toIndentedString(internalIndent));
        }
      }
    }
    builder.append(indent).append(""};\n"");
    return builder.toString();
  }
}"	"/home/gpoor/cts-12-source/cts/tests/location/location_gnss/src/android/location/cts/gnss/asn1/supl2/rrlp_components/GANSSGenericAssistDataElement.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.view.cts.FocusFinderTest"	"testFindNextFocus"	"CtsViewTestCases"	"2: direct ui"	"public void testFindNextFocus() throws Throwable {
        /*
         * Go clockwise around the buttons from the top left searching for focus.
         *
         * +---+---+
         * | 1 | 2 |
         * +---+---+
         * | 3 | 4 |
         * +---+---+
         */
        verifyNextFocus(mTopLeft, View.FOCUS_RIGHT, mTopRight);
        verifyNextFocus(mTopRight, View.FOCUS_DOWN, mBottomRight);
        verifyNextFocus(mBottomRight, View.FOCUS_LEFT, mBottomLeft);
        verifyNextFocus(mBottomLeft, View.FOCUS_UP, mTopLeft);

        verifyNextFocus(null, View.FOCUS_RIGHT, mTopLeft);
        verifyNextFocus(null, View.FOCUS_DOWN, mTopLeft);
        verifyNextFocus(null, View.FOCUS_LEFT, mBottomRight);
        verifyNextFocus(null, View.FOCUS_UP, mBottomRight);

        // Check that left/right traversal works when top/bottom borders are equal.
        verifyNextFocus(mTopRight, View.FOCUS_LEFT, mTopLeft);
        verifyNextFocus(mBottomLeft, View.FOCUS_RIGHT, mBottomRight);

        // Edge-case where root has focus
        mActivityRule.runOnUiThread(() -> {
            mLayout.setFocusableInTouchMode(true);
            verifyNextFocus(mLayout, View.FOCUS_FORWARD, mTopLeft);
        });
    }

    private void verifyNextFocus(View currentFocus, int direction, View expectedNextFocus) {
        View actualNextFocus = mFocusFinder.findNextFocus(mLayout, currentFocus, direction);
        assertEquals(expectedNextFocus, actualNextFocus);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/FocusFinderTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.view.cts.FocusFinderTest"	"testFindNextFocusFromRect"	"CtsViewTestCases"	"1: direct"	"public void testFindNextFocusFromRect() {
        /*
         * Create a small rectangle on the border between the top left and top right buttons.
         *
         * +---+---+
         * |  [ ]  |
         * +---+---+
         * |   |   |
         * +---+---+
         */
        int buttonHalfWidth = mTopLeft.getWidth() / 2;
        Rect topRect = new Rect(mTopLeft.getLeft() + buttonHalfWidth,
                mTopLeft.getTop(),
                mTopLeft.getRight() + buttonHalfWidth,
                mTopLeft.getBottom());

        verifytNextFocusFromRect(topRect, View.FOCUS_LEFT, mTopLeft);
        verifytNextFocusFromRect(topRect, View.FOCUS_RIGHT, mTopRight);

        /*
         * Create a small rectangle on the border between the top left and bottom left buttons.
         *
         * +---+---+
         * |   |   |
         * +[ ]+---+
         * |   |   |
         * +---+---+
         */
        int buttonHalfHeight = mTopLeft.getHeight() / 2;
        Rect leftRect = new Rect(mTopLeft.getLeft(),
                 mTopLeft.getTop() + buttonHalfHeight,
                 mTopLeft.getRight(),
                 mTopLeft.getBottom() + buttonHalfHeight);

        verifytNextFocusFromRect(leftRect, View.FOCUS_UP, mTopLeft);
        verifytNextFocusFromRect(leftRect, View.FOCUS_DOWN, mBottomLeft);
    }

    private void verifytNextFocusFromRect(Rect rect, int direction, View expectedNextFocus) {
        View actualNextFocus = mFocusFinder.findNextFocusFromRect(mLayout, rect, direction);
        assertEquals(expectedNextFocus, actualNextFocus);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/FocusFinderTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.view.cts.FocusFinderTest"	"testChainVisibility"	"CtsViewTestCases"	"2: direct ui"	"(timeout = 500)
    public void testChainVisibility() {
        mBottomRight.setNextFocusForwardId(mBottomLeft.getId());
        mBottomLeft.setNextFocusForwardId(mTopRight.getId());
        mBottomLeft.setVisibility(View.INVISIBLE);
        View next = mFocusFinder.findNextFocus(mLayout, mBottomRight, View.FOCUS_FORWARD);
        assertSame(mTopRight, next);

        mBottomLeft.setNextFocusForwardId(View.NO_ID);
        next = mFocusFinder.findNextFocus(mLayout, mBottomRight, View.FOCUS_FORWARD);
        assertSame(mTopLeft, next);

        // This shouldn't go into an infinite loop
        mBottomRight.setNextFocusForwardId(mTopRight.getId());
        mTopLeft.setNextFocusForwardId(mTopRight.getId());
        mTopRight.setNextFocusForwardId(mBottomLeft.getId());
        mBottomLeft.setNextFocusForwardId(mTopLeft.getId());
        mActivityRule.getActivity().runOnUiThread(() -> {
            mTopLeft.setVisibility(View.INVISIBLE);
            mTopRight.setVisibility(View.INVISIBLE);
            mBottomLeft.setVisibility(View.INVISIBLE);
            mBottomRight.setVisibility(View.INVISIBLE);
        });
        InstrumentationRegistry.getInstrumentation().waitForIdleSync();
        mFocusFinder.findNextFocus(mLayout, mBottomRight, View.FOCUS_FORWARD);
    }

    private void verifyNextCluster(View currentCluster, int direction, View expectedNextCluster) {
        View actualNextCluster = mFocusFinder.findNextKeyboardNavigationCluster(
                mLayout, currentCluster, direction);
        assertEquals(expectedNextCluster, actualNextCluster);
    }

    private void verifyNextClusterView(View currentCluster, int direction, View expectedNextView) {
        View actualNextView = mFocusFinder.findNextKeyboardNavigationCluster(
                mLayout, currentCluster, direction);
        if (actualNextView == mLayout) {
            actualNextView =
                    mFocusFinder.findNextKeyboardNavigationCluster(mLayout, null, direction);
        }
        assertEquals(expectedNextView, actualNextView);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/FocusFinderTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.view.cts.FocusFinderTest"	"testFindNextCluster"	"CtsViewTestCases"	"1: direct"	"public void testFindNextCluster() {
        // Cluster navigation from all possible starting points in all directions.
        mTopLeft.setKeyboardNavigationCluster(true);
        mTopRight.setKeyboardNavigationCluster(true);
        mBottomLeft.setKeyboardNavigationCluster(true);

        verifyNextCluster(null, View.FOCUS_FORWARD, mTopLeft);
        verifyNextCluster(mTopLeft, View.FOCUS_FORWARD, mTopRight);
        verifyNextCluster(mTopRight, View.FOCUS_FORWARD, mBottomLeft);
        verifyNextCluster(mBottomLeft, View.FOCUS_FORWARD, mLayout);
        verifyNextCluster(mBottomRight, View.FOCUS_FORWARD, mLayout);

        verifyNextCluster(null, View.FOCUS_BACKWARD, mBottomLeft);
        verifyNextCluster(mTopLeft, View.FOCUS_BACKWARD, mLayout);
        verifyNextCluster(mTopRight, View.FOCUS_BACKWARD, mTopLeft);
        verifyNextCluster(mBottomLeft, View.FOCUS_BACKWARD, mTopRight);
        verifyNextCluster(mBottomRight, View.FOCUS_BACKWARD, mLayout);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/FocusFinderTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.view.cts.FocusFinderTest"	"testBasicFocusOrder"	"CtsViewTestCases"	"2: direct ui"	"public void testBasicFocusOrder() {
        // Sanity check to make sure sorter is behaving
        FrameLayout layout = new FrameLayout(mLayout.getContext());
        Button button1 = new Button(mLayout.getContext());
        Button button2 = new Button(mLayout.getContext());
        setViewBox(button1, 0, 0, 10, 10);
        setViewBox(button2, 0, 0, 10, 10);
        layout.addView(button1);
        layout.addView(button2);
        View[] views = new View[]{button2, button1};
        // empty shouldn't crash or anything
        FocusFinder.sort(views, 0, 0, layout, false);
        // one view should work
        FocusFinder.sort(views, 0, 1, layout, false);
        assertEquals(button2, views[0]);
        // exactly overlapping views should remain in original order
        FocusFinder.sort(views, 0, 2, layout, false);
        assertEquals(button2, views[0]);
        assertEquals(button1, views[1]);
        // make sure it will actually mutate input array.
        setViewBox(button2, 20, 0, 30, 10);
        FocusFinder.sort(views, 0, 2, layout, false);
        assertEquals(button1, views[0]);
        assertEquals(button2, views[1]);

        // While we don't want to test details, we should at least verify basic correctness
        // like ""left-to-right"" ordering in well-behaved layouts
        verifyNextFocus(mTopLeft, View.FOCUS_FORWARD, mTopRight);
        verifyNextFocus(mTopRight, View.FOCUS_FORWARD, mBottomLeft);
        verifyNextFocus(mBottomLeft, View.FOCUS_FORWARD, mBottomRight);

        // Should still work intuitively even if some views are slightly shorter.
        mBottomLeft.setBottom(mBottomLeft.getBottom() - 3);
        mBottomLeft.offsetTopAndBottom(3);
        verifyNextFocus(mTopLeft, View.FOCUS_FORWARD, mTopRight);
        verifyNextFocus(mTopRight, View.FOCUS_FORWARD, mBottomLeft);
        verifyNextFocus(mBottomLeft, View.FOCUS_FORWARD, mBottomRight);

        // RTL layout should work right-to-left
        mActivityRule.getActivity().runOnUiThread(
                () -> mLayout.setLayoutDirection(View.LAYOUT_DIRECTION_RTL));
        InstrumentationRegistry.getInstrumentation().waitForIdleSync();
        verifyNextFocus(mTopLeft, View.FOCUS_FORWARD, mTopRight);
        verifyNextFocus(mTopRight, View.FOCUS_FORWARD, mBottomLeft);
        verifyNextFocus(mBottomLeft, View.FOCUS_FORWARD, mBottomRight);
    }

    private void setViewBox(View view, int left, int top, int right, int bottom) {
        view.setLeft(left);
        view.setTop(top);
        view.setRight(right);
        view.setBottom(bottom);
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/FocusFinderTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.view.cts.FocusFinderTest"	"testDuplicateId"	"CtsViewTestCases"	"1: ui"	"public void testDuplicateId() throws Throwable {
        LayoutInflater inflater = mActivityRule.getActivity().getLayoutInflater();
        mLayout = (ViewGroup) mActivityRule.getActivity().findViewById(R.id.inflate_layout);
        View[] buttons = new View[3];
        View[] boxes = new View[3];
        mActivityRule.runOnUiThread(() -> {
            for (int i = 0; i < 3; ++i) {
                View item = inflater.inflate(R.layout.focus_finder_sublayout, mLayout, false);
                buttons[i] = item.findViewById(R.id.itembutton);
                boxes[i] = item.findViewById(R.id.itembox);
                mLayout.addView(item);
            }
        });
        InstrumentationRegistry.getInstrumentation().waitForIdleSync();

        verifyNextFocus(buttons[0], View.FOCUS_FORWARD, boxes[0]);
        verifyNextFocus(boxes[0], View.FOCUS_FORWARD, buttons[1]);
        verifyNextFocus(buttons[1], View.FOCUS_FORWARD, boxes[1]);
        verifyNextFocus(boxes[1], View.FOCUS_FORWARD, buttons[2]);
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/FocusFinderTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.net.wifi.cts.app.RetrieveConnectionInfoAndReturnStatusActivity"	"finish"	""	"1: system"	"public void test/*
 *.
 */

package android.net.wifi.cts.app;

import android.app.Activity;
import android.content.Intent;
import android.net.wifi.WifiManager;
import android.os.Bundle;
import android.util.Log;

/**
 * An activity that retrieves connection info and returns status.
 */
public class RetrieveConnectionInfoAndReturnStatusActivity extends Activity {
    private static final String TAG = ""RetrieveConnectionInfoAndReturnStatusActivity"";
    private static final String SCAN_STATUS_EXTRA = ""android.net.wifi.cts.app.extra.STATUS"";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        WifiManager wifiManager = getSystemService(WifiManager.class);
        boolean succeeded;
        try {
            succeeded = !wifiManager.getConnectionInfo().getSSID().equals(WifiManager.UNKNOWN_SSID);
        } catch (SecurityException e) {
            succeeded = false;
        }
        if (succeeded) {
            Log.v(TAG, ""SSID from connection info retrieval succeeded"");
        } else {
            Log.v(TAG, ""Failed to retrieve SSID from connection info"");
        }
        setResult(RESULT_OK, new Intent().putExtra(SCAN_STATUS_EXTRA, succeeded));
        finish();
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/CtsWifiLocationTestApp/src/android/net/wifi/cts/app/RetrieveConnectionInfoAndReturnStatusActivity.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.server.wm.ConfigChangeTests"	"testRotation180_NoRelaunchActivity"	"CtsWindowManagerDeviceTestCases"	"1: apps"	"public void testRotation180_NoRelaunchActivity() {
        assumeTrue(""Skipping test: no rotation support"", supportsRotation());
        assumeFalse(""Skipping test: display cutout present, can't predict exact lifecycle"",
                hasDisplayCutout());

        // Should receive nothing
        testRotation(NO_RELAUNCH_ACTIVITY, 2, 0, 0);
    }

    /**
     * Test activity configuration changes for devices with cutout(s). Landscape and
     * reverse-landscape rotations should result in same screen space available for apps.
     */"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/ConfigChangeTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.server.wm.ConfigChangeTests"	"testChangeFontScaleNoRelaunch"	"CtsWindowManagerDeviceTestCases"	"2: ui user"	"public void testChangeFontScaleNoRelaunch() {
        // Should receive onConfigurationChanged() and no relaunch
        testChangeFontScale(FONT_SCALE_NO_RELAUNCH_ACTIVITY, false /* relaunch */);
    }

    private void testRotation(ComponentName activityName, int rotationStep, int numRelaunch,
            int numConfigChange) {
        launchActivity(activityName, WINDOWING_MODE_FULLSCREEN);
        mWmState.computeState(activityName);

        final int initialRotation = 4 - rotationStep;
        final RotationSession rotationSession = createManagedRotationSession();
        prepareRotation(activityName, rotationSession, mWmState.getRotation(), initialRotation,
                numConfigChange > 0);
        final int actualStackId =
                mWmState.getTaskByActivity(activityName).mRootTaskId;
        final int displayId = mWmState.getRootTask(actualStackId).mDisplayId;
        final int newDeviceRotation = getDeviceRotation(displayId);
        if (newDeviceRotation == INVALID_DEVICE_ROTATION) {
            logE(""Got an invalid device rotation value. ""
                    + ""Continuing the test despite of that, but it is likely to fail."");
        } else if (newDeviceRotation != initialRotation) {
            log(""This device doesn't support user rotation ""
                    + ""mode. Not continuing the rotation checks."");
            return;
        }

        for (int rotation = 0; rotation < 4; rotation += rotationStep) {
            separateTestJournal();
            rotationSession.set(rotation);
            mWmState.computeState(activityName);
            assertRelaunchOrConfigChanged(activityName, numRelaunch, numConfigChange);
        }
    }

    private void testChangeFontScale(ComponentName activityName, boolean relaunch) {
        final FontScaleSession fontScaleSession = createManagedFontScaleSession();
        fontScaleSession.set(1.0f);
        separateTestJournal();
        launchActivity(activityName);
        mWmState.computeState(activityName);

        final Bundle extras = TestJournalContainer.get(activityName).extras;
        if (!extras.containsKey(EXTRA_FONT_ACTIVITY_DPI)) {
            fail(""No fontActivityDpi reported from activity "" + activityName);
        }
        final int densityDpi = extras.getInt(EXTRA_FONT_ACTIVITY_DPI);

        for (float fontScale = 0.85f; fontScale <= 1.3f; fontScale += 0.15f) {
            separateTestJournal();
            fontScaleSession.set(fontScale);
            mWmState.computeState(activityName);
            assertRelaunchOrConfigChanged(activityName, relaunch ? 1 : 0, relaunch ? 0 : 1);

            // Verify that the display metrics are updated, and therefore the text size is also
            // updated accordingly.
            final Bundle changedExtras = TestJournalContainer.get(activityName).extras;
            waitForOrFail(""reported fontPixelSize from "" + activityName,
                    () -> changedExtras.containsKey(EXTRA_FONT_PIXEL_SIZE));
            final int expectedFontPixelSize =
                    scaledPixelsToPixels(EXPECTED_FONT_SIZE_SP, fontScale, densityDpi);
            assertEquals(""Expected font pixel size should match"", expectedFontPixelSize,
                    changedExtras.getInt(EXTRA_FONT_PIXEL_SIZE));
        }
    }

    /**
     * Test updating application info when app is running. An activity with matching package name
     * must be recreated and its asset sequence number must be incremented.
     */"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/ConfigChangeTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.server.wm.ConfigChangeTests"	"testUpdateApplicationInfo"	"CtsWindowManagerDeviceTestCases"	"2: system user"	"public void testUpdateApplicationInfo() throws Exception {
        separateTestJournal();

        // Launch an activity that prints applied config.
        launchActivity(TEST_ACTIVITY);
        final int assetSeq = getAssetSeqNumber(TEST_ACTIVITY);

        separateTestJournal();
        // Update package info.
        updateApplicationInfo(Arrays.asList(TEST_ACTIVITY.getPackageName()));
        mWmState.waitForWithAmState((amState) -> {
            // Wait for activity to be resumed and asset seq number to be updated.
            try {
                return getAssetSeqNumber(TEST_ACTIVITY) == assetSeq + 1
                        && amState.hasActivityState(TEST_ACTIVITY, STATE_RESUMED);
            } catch (Exception e) {
                logE(""Error waiting for valid state: "" + e.getMessage());
                return false;
            }
        }, ""asset sequence number to be updated and for activity to be resumed."");

        // Check if activity is relaunched and asset seq is updated.
        assertRelaunchOrConfigChanged(TEST_ACTIVITY, 1 /* numRelaunch */,
                0 /* numConfigChange */);
        final int newAssetSeq = getAssetSeqNumber(TEST_ACTIVITY);
        assertTrue(""Asset sequence number must be incremented."", assetSeq < newAssetSeq);
    }

    private static int getAssetSeqNumber(ComponentName activityName) {
        return TestJournalContainer.get(activityName).extras.getInt(EXTRA_CONFIG_ASSETS_SEQ);
    }

    // Calculate the scaled pixel size just like the device is supposed to.
    private static int scaledPixelsToPixels(float sp, float fontScale, int densityDpi) {
        final int DEFAULT_DENSITY = 160;
        float f = densityDpi * (1.0f / DEFAULT_DENSITY) * fontScale * sp;
        return (int) ((f >= 0) ? (f + 0.5f) : (f - 0.5f));
    }

    private void updateApplicationInfo(List<String> packages) {
        SystemUtil.runWithShellPermissionIdentity(
                () -> mAm.scheduleApplicationInfoChanged(packages,
                        android.os.Process.myUserHandle().getIdentifier())
        );
    }
}"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/src/android/server/wm/ConfigChangeTests.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.server.cts.device.batterystats.BatteryStatsAlarmTest"	"testAlarms"	""	"1: system"	"public void testAlarms() throws Exception {
        final int NUM_ALARMS = 3;

        final Context context = InstrumentationRegistry.getContext();

        final Intent intent = new Intent(""com.android.server.cts.device.batterystats.ALARM"");
        final IntentFilter inf = new IntentFilter(intent.getAction());

        final CountDownLatch latch = new CountDownLatch(NUM_ALARMS);

        context.registerReceiver(new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                Log.i(TAG, ""Received: "" + intent);
                latch.countDown();
            }}, inf);

        final AlarmManager alm = context.getSystemService(AlarmManager.class);
        for (int i = 0; i < NUM_ALARMS; i++) {
            alm.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP,
                    SystemClock.elapsedRealtime() + (i + 1) * 1000,
                    PendingIntent.getBroadcast(context, i, intent, PendingIntent.FLAG_MUTABLE_UNAUDITED));
        }
        assertTrue(""Didn't receive all broadcasts."", latch.await(60 * 1000, TimeUnit.SECONDS));
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/incident/apps/batterystatsapp/src/com/android/server/cts/device/batterystats/BatteryStatsAlarmTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.media.cts.AudioRecordSharedAudioTest"	"adoptShellPermissionIdentity"	"CtsMediaTestCases"	"4: mic ui system microphone"	"/*
 *.
 */

package android.media.cts;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.testng.Assert.assertThrows;

import android.content.Context;
import android.content.pm.PackageManager;
import android.media.AudioFormat;
import android.media.AudioRecord;
import android.media.MediaSyncEvent;
import android.util.Log;

import androidx.test.InstrumentationRegistry;
import androidx.test.filters.SdkSuppress;
import androidx.test.runner.AndroidJUnit4;

import com.android.compatibility.common.util.SystemUtil;

import java.io.IOException;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;



@NonMediaMainlineTest
@RunWith(AndroidJUnit4.class)
@SdkSuppress(minSdkVersion = 31, codeName = ""S"")
public class AudioRecordSharedAudioTest {
    private static final String TAG = ""AudioRecordSharedAudioTest"";
    private static final int SAMPLING_RATE_HZ = 16000;

    @Before
    public void setUp() throws Exception {
        if (!hasMicrophone()) {
            return;
        }
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .adoptShellPermissionIdentity();
        clearAudioserverPermissionCache();
    }

    @After
    public void tearDown() throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .dropShellPermissionIdentity();
        clearAudioserverPermissionCache();
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/AudioRecordSharedAudioTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.media.cts.AudioRecordSharedAudioTest"	"testCapturesMatch"	"CtsMediaTestCases"	"4: mic ui system microphone"	"public void testCapturesMatch() throws Exception {
        AudioRecord record1 = null;
        AudioRecord record2 = null;
        try {
            record1 = new AudioRecord.Builder().setAudioFormat(new AudioFormat.Builder()
                                .setSampleRate(SAMPLING_RATE_HZ)
                                .setEncoding(AudioFormat.ENCODING_PCM_16BIT)
                                .setChannelMask(AudioFormat.CHANNEL_IN_MONO).build())
                            .setBufferSizeInBytes(SAMPLING_RATE_HZ
                                * AudioFormat.getBytesPerSample(AudioFormat.ENCODING_PCM_16BIT))
                            .setMaxSharedAudioHistoryMillis(
                                    AudioRecord.getMaxSharedAudioHistoryMillis() - 1)
                            .build();
            assertEquals(AudioRecord.STATE_INITIALIZED, record1.getState());

            record1.startRecording();

            final int RECORD1_NUM_SAMPLES = SAMPLING_RATE_HZ / 2;
            short[] buffer1 = new short[RECORD1_NUM_SAMPLES];

            // blocking read should allow for at least 500ms of audio in buffer
            int samplesRead = record1.read(buffer1, 0, RECORD1_NUM_SAMPLES);
            assertTrue(samplesRead >= RECORD1_NUM_SAMPLES);


            final int RECORD2_START_TIME_MS = 100;
            MediaSyncEvent event = record1.shareAudioHistory(
                    InstrumentationRegistry.getTargetContext().getPackageName(),
                    (long) RECORD2_START_TIME_MS /* startFromMillis */);
            assertEquals(event.getAudioSessionId(), record1.getAudioSessionId());

            record2 = new AudioRecord.Builder().setAudioFormat(new AudioFormat.Builder()
                                .setSampleRate(SAMPLING_RATE_HZ)
                                .setEncoding(AudioFormat.ENCODING_PCM_16BIT)
                                .setChannelMask(AudioFormat.CHANNEL_IN_MONO).build())
                            .setBufferSizeInBytes(SAMPLING_RATE_HZ
                                * AudioFormat.getBytesPerSample(AudioFormat.ENCODING_PCM_16BIT))
                            .setSharedAudioEvent(event)
                            .build();
            assertEquals(AudioRecord.STATE_INITIALIZED, record2.getState());

            record2.startRecording();

            final int RECORD2_NUM_SAMPLES = SAMPLING_RATE_HZ / 5;
            short[] buffer2 = new short[RECORD2_NUM_SAMPLES];

            samplesRead = record2.read(buffer2, 0, RECORD2_NUM_SAMPLES);
            assertTrue(samplesRead >= RECORD2_NUM_SAMPLES);

            record2.stop();
            record1.stop();


            // verify that the audio read by 2nd AudioRecord exactly matches the audio read
            // by 1st AudioRecord starting from the expected start time with a certain tolerance.
            final int FIRST_EXPECTED_SAMPLE = RECORD2_START_TIME_MS * SAMPLING_RATE_HZ / 1000;
            // NOTE: START_TIME_TOLERANCE_MS must always be smaller than RECORD2_START_TIME_MS
            final int START_TIME_TOLERANCE_MS = 1;
            final int START_SAMPLE_TOLERANCE = START_TIME_TOLERANCE_MS * SAMPLING_RATE_HZ / 1000;
            // let time for a resampler to converge by skipping samples at the beginning of the
            // record2 buffer before comparing to record1 buffer
            final int RESAMPLER_CONVERGENCE_MS = 5;
            final int RESAMPLER_CONVERGENCE_SAMPLE =
                    RESAMPLER_CONVERGENCE_MS * SAMPLING_RATE_HZ / 1000;


            boolean buffersMatch = false;
            for (int i = -START_SAMPLE_TOLERANCE;
                    i < START_SAMPLE_TOLERANCE && !buffersMatch; i++) {
                int offset1 = i + FIRST_EXPECTED_SAMPLE;
                if (offset1 < 0) {
                    continue;
                }
                // unlikely: programming error
                if (RECORD1_NUM_SAMPLES - offset1 < RECORD2_NUM_SAMPLES) {
                    Log.w(TAG, ""testCapturesMatch: "" +
                            ""invalid buffer1 size/buffer2 size/start ms combination!"");
                    break;
                }

                buffersMatch = true;
                for (int j = RESAMPLER_CONVERGENCE_SAMPLE; j < RECORD2_NUM_SAMPLES; j++) {
                    if (buffer2[j] != buffer1[j + offset1]) {
                         buffersMatch = false;
                         break;
                     }
                }
            }
            assertTrue(buffersMatch);
        } finally {
            if (record1 != null) {
                record1.release();
            }
            if (record2 != null) {
                record2.release();
            }
        }
    }

    private boolean hasMicrophone() {
        return InstrumentationRegistry.getTargetContext().getPackageManager().hasSystemFeature(
                PackageManager.FEATURE_MICROPHONE);
    }

    private void clearAudioserverPermissionCache() {
        try {
            SystemUtil.runShellCommand(InstrumentationRegistry.getInstrumentation(),
                    ""cmd media.audio_policy purge_permission-cache"");
        } catch (IOException e) {
            fail(""cannot purge audio server permission cache"");
        }
    }

}"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/AudioRecordSharedAudioTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.media.cts.AudioRecordSharedAudioTest"	"testPermissionFailure"	"CtsMediaTestCases"	"1: ui"	"public void testPermissionFailure() throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation()
                .dropShellPermissionIdentity();
        clearAudioserverPermissionCache();

        assertThrows(UnsupportedOperationException.class, () -> {
                    AudioRecord record = new AudioRecord.Builder().setMaxSharedAudioHistoryMillis(
                            AudioRecord.getMaxSharedAudioHistoryMillis() - 1).build();
                });

        final AudioRecord record =
                new AudioRecord.Builder()
                        .setAudioFormat(new AudioFormat.Builder()
                            .setSampleRate(SAMPLING_RATE_HZ)
                            .setEncoding(AudioFormat.ENCODING_PCM_16BIT)
                            .setChannelMask(AudioFormat.CHANNEL_IN_MONO).build())
                        .setBufferSizeInBytes(SAMPLING_RATE_HZ
                                * AudioFormat.getBytesPerSample(AudioFormat.ENCODING_PCM_16BIT))
                        .build();
        assertEquals(AudioRecord.STATE_INITIALIZED, record.getState());
        record.startRecording();
        Thread.sleep(500);

        assertThrows(SecurityException.class, () -> {
                    record.shareAudioHistory(
                            InstrumentationRegistry.getTargetContext().getPackageName(), 100);
                });

        record.stop();
        record.release();
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/AudioRecordSharedAudioTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.media.cts.AudioRecordSharedAudioTest"	"testPermissionSuccess"	"CtsMediaTestCases"	"1: ui"	"public void testPermissionSuccess() throws Exception {
        AudioRecord record = new AudioRecord.Builder().setAudioFormat(new AudioFormat.Builder()
                    .setSampleRate(SAMPLING_RATE_HZ)
                    .setEncoding(AudioFormat.ENCODING_PCM_16BIT)
                    .setChannelMask(AudioFormat.CHANNEL_IN_MONO).build())
                .setBufferSizeInBytes(SAMPLING_RATE_HZ
                        * AudioFormat.getBytesPerSample(AudioFormat.ENCODING_PCM_16BIT))
                .setMaxSharedAudioHistoryMillis(
                    AudioRecord.getMaxSharedAudioHistoryMillis()-1)
                .build();

        assertEquals(AudioRecord.STATE_INITIALIZED, record.getState());

        record.startRecording();
        Thread.sleep(500);
        try {
            record.shareAudioHistory(
                    InstrumentationRegistry.getTargetContext().getPackageName(), 100);
        } catch (SecurityException e) {
            fail(""testPermissionSuccess shareAudioHistory be allowed"");
        } finally {
            record.stop();
            record.release();
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/AudioRecordSharedAudioTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.media.cts.AudioRecordSharedAudioTest"	"testBadValues"	"CtsMediaTestCases"	"1: ui"	"public void testBadValues() throws Exception {
        assertThrows(IllegalArgumentException.class, () -> {
                    AudioRecord.Builder builder = new AudioRecord.Builder()
                            .setMaxSharedAudioHistoryMillis(
                                    AudioRecord.getMaxSharedAudioHistoryMillis() + 1);
                });

        assertThrows(IllegalArgumentException.class, () -> {
                    AudioRecord.Builder builder = new AudioRecord.Builder()
                            .setMaxSharedAudioHistoryMillis(-1);
                });

        final AudioRecord record =
                new AudioRecord.Builder().setAudioFormat(new AudioFormat.Builder()
                        .setSampleRate(SAMPLING_RATE_HZ)
                        .setEncoding(AudioFormat.ENCODING_PCM_16BIT)
                        .setChannelMask(AudioFormat.CHANNEL_IN_MONO).build())
                    .setBufferSizeInBytes(SAMPLING_RATE_HZ
                            * AudioFormat.getBytesPerSample(AudioFormat.ENCODING_PCM_16BIT))
                    .setMaxSharedAudioHistoryMillis(
                            AudioRecord.getMaxSharedAudioHistoryMillis()-1)
                    .build();

        assertEquals(AudioRecord.STATE_INITIALIZED, record.getState());

        record.startRecording();
        Thread.sleep(500);

        assertThrows(NullPointerException.class, () -> {
                    record.shareAudioHistory(null /* sharedPackage */, 100 /* startFromMillis */);
                });

        assertThrows(IllegalArgumentException.class, () -> {
                    record.shareAudioHistory(
                            InstrumentationRegistry.getTargetContext().getPackageName(),
                            -1 /* startFromMillis */);
                });

        record.stop();
        record.release();
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/media/src/android/media/cts/AudioRecordSharedAudioTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.deviceandprofileowner.MeteredDataRestrictionTest"	"testSetMeteredDataDisabledPackages"	""	"2: system user"	"public void testSetMeteredDataDisabledPackages() {
        final List<String> restrictedPkgs = new ArrayList<>();
        restrictedPkgs.add(METERED_DATA_APP_PKG);
        final List<String> excludedPkgs = mDevicePolicyManager.setMeteredDataDisabledPackages(
                ADMIN_RECEIVER_COMPONENT, restrictedPkgs);
        assertTrue(""Packages not restricted: "" + excludedPkgs, excludedPkgs.isEmpty());

        List<String> actualRestrictedPkgs = mDevicePolicyManager.getMeteredDataDisabledPackages(
                ADMIN_RECEIVER_COMPONENT);
        assertEquals(""Actual restricted pkgs: "" + actualRestrictedPkgs,
                1, actualRestrictedPkgs.size());
        assertTrue(""Actual restricted pkgs: "" + actualRestrictedPkgs,
                actualRestrictedPkgs.contains(METERED_DATA_APP_PKG));
        verifyAppNetworkState(true);

        restrictedPkgs.clear();
        mDevicePolicyManager.setMeteredDataDisabledPackages(ADMIN_RECEIVER_COMPONENT,
                restrictedPkgs);
        actualRestrictedPkgs = mDevicePolicyManager.getMeteredDataDisabledPackages(
                ADMIN_RECEIVER_COMPONENT);
        assertTrue(""Actual restricted pkgs: "" + actualRestrictedPkgs,
                actualRestrictedPkgs.isEmpty());
        verifyAppNetworkState(false);
    }

    private void verifyAppNetworkState(boolean blocked) {
        final Bundle extras = new Bundle();
        extras.putBinder(EXTRA_MESSENGER, mCallbackMessenger.getBinder());
        mNetworkInfos.clear();
        final Intent launchIntent = new Intent()
                .setClassName(METERED_DATA_APP_PKG, METERED_DATA_APP_MAIN_ACTIVITY)
                .putExtras(extras)
                .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        mContext.startActivity(launchIntent);

        try {
            final NetworkInfo networkInfo = mNetworkInfos.poll(WAIT_FOR_NETWORK_INFO_TIMEOUT_SEC,
                    TimeUnit.SECONDS);
            if (networkInfo == null) {
                fail(""Timed out waiting for the network info"");
            }

            final String expectedState = (blocked ? State.DISCONNECTED : State.CONNECTED).name();
            final String expectedDetailedState = (blocked ? DetailedState.BLOCKED
                    : DetailedState.CONNECTED).name();
            assertEquals(""Wrong state: "" + networkInfo,
                    expectedState, networkInfo.getState().name());
            assertEquals(""Wrong detailed state: "" + networkInfo,
                    expectedDetailedState, networkInfo.getDetailedState().name());
        } catch (InterruptedException e) {
            fail(""Waiting for networkinfo got interrupted: "" + e);
        }
    }

    private class CallbackHandler extends Handler {
        public CallbackHandler() {
            super(Looper.getMainLooper());
        }

        @Override
        public void handleMessage(Message msg) {
            if (msg.what == MSG_NOTIFY_NETWORK_STATE) {
                final NetworkInfo networkInfo = (NetworkInfo) msg.obj;
                if (!mNetworkInfos.offer(networkInfo)) {
                    Log.e(TAG, ""Error while adding networkinfo"");
                }
            } else {
                Log.e(TAG, ""Unknown msg type: "" + msg.what);
            }
        }
    }

    private void setMeteredNetwork() throws Exception {
        final int oldNetId = getActiveNetworkNetId();
        final boolean oldMeteredState = mCm.isActiveNetworkMetered();
        final NetworkInfo networkInfo = mCm.getActiveNetworkInfo();
        Log.d(TAG, ""setMeteredNetwork(): oldNetId="" + oldNetId
                + "", oldMeteredState="" + oldMeteredState + "", activeNetworkInfo="" + networkInfo);
        if (networkInfo == null) {
            fail(""Active network is not available"");
        } else if (networkInfo.getType() != ConnectivityManager.TYPE_WIFI) {
            fail(""Active network doesn't support setting metered status: "" + networkInfo);
        }
        final String ssid = setWifiMeteredStatus(true);

        // Set flag so status is reverted on resetMeteredNetwork();
        mMeteredWifi = ssid;

        // When transitioning from unmetered to metered, the network stack will discconect
        // the current WiFi connection and reconnect it. In this case we need to wait for
        // the new network to come up.
        if (!oldMeteredState) {
            waitForReconnection(oldNetId);
        }
        assertWifiMeteredStatus(ssid, true);
        assertActiveNetworkMetered(true);
    }

    private void resetMeteredNetwork() throws Exception {
        if (mMeteredWifi != null) {
            Log.i(TAG, ""Resetting metered status for netId="" + mMeteredWifi);
            setWifiMeteredStatus(mMeteredWifi, /* metered= */ null);
            assertWifiMeteredStatus(mMeteredWifi, /* metered= */ null);
            assertActiveNetworkMetered(false);
        }
    }

    private String setWifiMeteredStatus(Boolean metered) throws Exception {
        // Must use Shell permissions to get the connection info because on headless system user
        // mode the method would be called by the device owner on system user, which have location
        // disabled (and hence the returned connectionInfo would have the SSID redacted).
        WifiInfo connectionInfo = invokeStaticMethodWithShellPermissions(
                () -> mWm.getConnectionInfo());

        String ssid = connectionInfo.getSSID();
        assertNotNull(""null SSID"", ssid);
        assertNotEquals(""unknown SSID"", WifiManager.UNKNOWN_SSID, ssid);

        final String netId = ssid.trim().replaceAll(""\"""", """"); // remove quotes, if any.
        assertFalse(""empty SSID"", ssid.isEmpty());

        Log.d(TAG, ""setWifiMeteredStatus("" + metered + ""): setting "" + connectionInfo);
        setWifiMeteredStatus(netId, metered);
        return netId;
    }

    private void setWifiMeteredStatus(String ssid, Boolean metered) throws Exception {
        Log.i(TAG, ""Setting wi-fi network "" + ssid + "" metered status to "" + metered);
        executeCmd(""cmd netpolicy set metered-network "" + ssid + "" "" +
                (metered != null ? metered.toString() : ""undefined""));
    }

    private void assertWifiMeteredStatus(String ssid, Boolean metered) throws Exception {
        final String cmd = ""cmd netpolicy list wifi-networks"";
        final String expectedResult = ssid + "";"" + (metered != null ? metered.toString() : ""none"");
        String cmdResult = null;
        for (int i = 0; i < NUM_TRIES_METERED_STATUS_CHECK; ++i) {
            cmdResult = executeCmd(cmd);
            if (cmdResult.contains(expectedResult)) {
                return;
            }
            SystemClock.sleep(INTERVAL_METERED_STATUS_CHECK_MS);
        }
        fail(""Timed out waiting for wifi metered status to change. expected="" + expectedResult
                + "", actual status="" + cmdResult);
    }

    private void assertActiveNetworkMetered(boolean metered) {
        boolean actualMeteredStatus = !metered;
        for (int i = 0; i < NUM_TRIES_METERED_STATUS_CHECK; ++i) {
            actualMeteredStatus = mCm.isActiveNetworkMetered();
            if (actualMeteredStatus == metered) {
                return;
            }
            SystemClock.sleep(INTERVAL_METERED_STATUS_CHECK_MS);
        }
        fail(""Timed out waiting for active network metered status to change. expected=""
                + metered + ""; actual="" + actualMeteredStatus
                + ""; networkInfo="" + mCm.getActiveNetwork());
    }

    private String executeCmd(String cmd) throws Exception {
        final String result = SystemUtil.runShellCommand(getInstrumentation(), cmd);
        Log.i(TAG, ""Cmd '"" + cmd + ""' result: "" + result);
        return result;
    }

    private int getActiveNetworkNetId() {
        Network network = mCm.getActiveNetwork();
        if (network == null) {
            return 0;
        }
        return network.getNetId();
    }

    private void waitForReconnection(int oldNetId) throws InterruptedException {
        long pollingDeadline = System.currentTimeMillis()
                + WAIT_FOR_NETWORK_RECONNECTION_TIMEOUT_SEC * 1000;
        int latestNetId;
        do {
            Thread.sleep(1000);
            if (System.currentTimeMillis() >= pollingDeadline) {
                fail(""Timeout waiting for network reconnection"");
            }
            latestNetId = getActiveNetworkNetId();
            // NetId will be 0 while old network is disconnected but new network
            // has not come up yet.
        } while (latestNetId == 0 || latestNetId == oldNetId);
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/DeviceAndProfileOwner/src/com/android/cts/deviceandprofileowner/MeteredDataRestrictionTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.usespermissiondiffcertapp.UriGrantsResultTest"	"testGrantableToResult"	""	"1: ui"	"public void testGrantableToResult() throws Exception {
        for (Uri uri : GRANTABLE) {
            for (int mode : GRANTABLE_MODES) {
                Log.d(TAG, ""Testing "" + uri + "" "" + mode);
                assertGrantableToResult(uri, mode, UriGrantsTest::makeSingleClipData);
                assertGrantableToResult(uri, mode, UriGrantsTest::makeMultiClipData);
            }
        }
    }

    private void assertGrantableToResult(Uri uri, int mode,
            Function<Uri, ClipData> clipper) throws Exception {
        try {
            createActivity();
            assertGrantableToResultInternal(uri, mode, clipper);
        } finally {
            destroyActivity();
        }
    }

    private void assertGrantableToResultInternal(Uri uri, int mode,
            Function<Uri, ClipData> clipper) {
        final Uri subUri = Uri.withAppendedPath(uri, ""foo"");
        final Uri subSubUri = Uri.withAppendedPath(subUri, ""bar"");
        final ClipData subClip = clipper.apply(subUri);

        assertAccess(uri, 0);
        assertAccess(subClip, 0);
        assertAccess(subUri, 0);
        assertAccess(subSubUri, 0);

        // --------------------------------

        final Intent intent = buildIntent(subClip, mode);
        mActivity.startActivityForResult(intent, REQUEST_CODE);
        mActivity.getResult();

        assertAccess(uri, 0);
        assertAccess(subClip, mode);
        assertAccess(subUri, mode);
        assertAccess(subSubUri, 0);

        // --------------------------------

        // Dispose of activity.
        mActivity.finish();
        mActivity.getDestroyed();

        assertAccess(uri, 0);
        assertAccess(subClip, 0);
        assertAccess(subUri, 0);
        assertAccess(subSubUri, 0);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/UsePermissionDiffCert/src/com/android/cts/usespermissiondiffcertapp/UriGrantsResultTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.usespermissiondiffcertapp.UriGrantsResultTest"	"testNotGrantableToResult"	""	"1: ui"	"public void testNotGrantableToResult() throws Exception {
        for (Uri uri : NOT_GRANTABLE) {
            for (int mode : NOT_GRANTABLE_MODES) {
                Log.d(TAG, ""Testing "" + uri + "" "" + mode);
                assertNotGrantableToResult(uri, mode, UriGrantsTest::makeSingleClipData);
                assertNotGrantableToResult(uri, mode, UriGrantsTest::makeMultiClipData);
            }
        }
    }

    private void assertNotGrantableToResult(Uri uri, int mode,
            Function<Uri, ClipData> clipper) throws Exception {
        try {
            createActivity();
            assertNotGrantableToResultInternal(uri, mode, clipper);
        } finally {
            destroyActivity();
        }
    }

    private void assertNotGrantableToResultInternal(Uri uri, int mode,
            Function<Uri, ClipData> clipper) {
        final Uri subUri = Uri.withAppendedPath(uri, ""foo"");
        final Uri subSubUri = Uri.withAppendedPath(subUri, ""bar"");
        final ClipData subClip = clipper.apply(subUri);

        final Intent intent = buildIntent(subClip, mode);
        mActivity.startActivityForResult(intent, REQUEST_CODE);
        mActivity.getResult();

        assertAccess(uri, 0);
        assertAccess(subClip, 0);
        assertAccess(subUri, 0);
        assertAccess(subSubUri, 0);
    }

    private Intent buildIntent(ClipData clip, int mode) {
        final Intent intent = new Intent();
        intent.setComponent(new ComponentName(""com.android.cts.permissiondeclareapp"",
                ""com.android.cts.permissiondeclareapp.SendResultActivity""));
        intent.putExtra(Intent.EXTRA_TEXT, clip);
        intent.putExtra(Intent.EXTRA_INDEX, mode);
        return intent;
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/test-apps/UsePermissionDiffCert/src/com/android/cts/usespermissiondiffcertapp/UriGrantsResultTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.mediadrm.cts.MediaDrmExtractorTest"	"testGetDrmInitData"	"CtsMediaDrmTestCases"	"1: ui"	"public void testGetDrmInitData() throws Exception {
        if (!MediaUtils.check(mIsAtLeastR, ""test needs Android 11"")) return;
        Preconditions.assertTestFileExists(mInpPrefix + ""psshtest.mp4"");
        setDataSource(""psshtest.mp4"");
        DrmInitData drmInitData = mExtractor.getDrmInitData();
        assertEquals(drmInitData.getSchemeInitDataCount(), 2);
        assertEquals(drmInitData.getSchemeInitDataAt(0).uuid, UUID_WIDEVINE);
        assertEquals(drmInitData.get(UUID_WIDEVINE), drmInitData.getSchemeInitDataAt(0));
        assertEquals(drmInitData.getSchemeInitDataAt(1).uuid, UUID_PLAYREADY);
        assertEquals(drmInitData.get(UUID_PLAYREADY), drmInitData.getSchemeInitDataAt(1));
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/mediadrm/src/android/mediadrm/cts/MediaDrmExtractorTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.intent.sender.CopyPasteTest"	"finish"	""	"1: system"	"public void test/*
 *.
 */

package com.android.cts.intent.sender;

import android.content.ClipboardManager;
import android.content.ClipData;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.test.InstrumentationTestCase;
import android.util.Log;

import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

public class CopyPasteTest extends InstrumentationTestCase
        implements ClipboardManager.OnPrimaryClipChangedListener {

    private IntentSenderActivity mActivity;
    private ClipboardManager mClipboard;
    private Semaphore mNotified;

    private static String ACTION_COPY_TO_CLIPBOARD = ""com.android.cts.action.COPY_TO_CLIPBOARD"";

    private static String INITIAL_TEXT = ""initial text"";
    private static String NEW_TEXT = ""sample text"";

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        Context context = getInstrumentation().getTargetContext();
        mActivity = launchActivity(context.getPackageName(), IntentSenderActivity.class, null);
        mClipboard = (ClipboardManager) mActivity.getSystemService(Context.CLIPBOARD_SERVICE);
    }

    @Override
    public void tearDown() throws Exception {
        mActivity.finish();
        super.tearDown();
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/devicepolicy/app/IntentSender/src/com/android/cts/intent/sender/CopyPasteTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.location.cts.gnss.asn1.supl2.rrlp_components.UTCmodelSet2"	"isTagImplicit"	"CtsLocationGnssTestCases"	"1: ui"	"public void test/*
 *.
 */

package android.location.cts.asn1.supl2.rrlp_components;

/*
 */


//
//
import android.location.cts.asn1.base.Asn1BitString;
import android.location.cts.asn1.base.Asn1Integer;
import android.location.cts.asn1.base.Asn1Null;
import android.location.cts.asn1.base.Asn1Object;
import android.location.cts.asn1.base.Asn1Sequence;
import android.location.cts.asn1.base.Asn1Tag;
import android.location.cts.asn1.base.BitStream;
import android.location.cts.asn1.base.BitStreamReader;
import android.location.cts.asn1.base.SequenceComponent;
import com.google.common.collect.ImmutableList;
import java.util.Collection;
import javax.annotation.Nullable;


/**
*/
public  class UTCmodelSet2 extends Asn1Sequence {
  //

  private static final Asn1Tag TAG_UTCmodelSet2
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public UTCmodelSet2() {
    super();
  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_UTCmodelSet2;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_UTCmodelSet2 != null) {
      return ImmutableList.of(TAG_UTCmodelSet2);
    } else {
      return Asn1Sequence.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new UTCmodelSet2 from encoded stream.
   */
  public static UTCmodelSet2 fromPerUnaligned(byte[] encodedBytes) {
    UTCmodelSet2 result = new UTCmodelSet2();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new UTCmodelSet2 from encoded stream.
   */
  public static UTCmodelSet2 fromPerAligned(byte[] encodedBytes) {
    UTCmodelSet2 result = new UTCmodelSet2();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }



  @Override protected boolean isExtensible() {
    return false;
  }

  @Override public boolean containsExtensionValues() {
    for (SequenceComponent extensionComponent : getExtensionComponents()) {
      if (extensionComponent.isExplicitlySet()) return true;
    }
    return false;
  }

  
  private UTCmodelSet2.utcA0Type utcA0_;
  public UTCmodelSet2.utcA0Type getUtcA0() {
    return utcA0_;
  }
  /**
   * @throws ClassCastException if value is not a UTCmodelSet2.utcA0Type
   */
  public void setUtcA0(Asn1Object value) {
    this.utcA0_ = (UTCmodelSet2.utcA0Type) value;
  }
  public UTCmodelSet2.utcA0Type setUtcA0ToNewInstance() {
    utcA0_ = new UTCmodelSet2.utcA0Type();
    return utcA0_;
  }
  
  private UTCmodelSet2.utcA1Type utcA1_;
  public UTCmodelSet2.utcA1Type getUtcA1() {
    return utcA1_;
  }
  /**
   * @throws ClassCastException if value is not a UTCmodelSet2.utcA1Type
   */
  public void setUtcA1(Asn1Object value) {
    this.utcA1_ = (UTCmodelSet2.utcA1Type) value;
  }
  public UTCmodelSet2.utcA1Type setUtcA1ToNewInstance() {
    utcA1_ = new UTCmodelSet2.utcA1Type();
    return utcA1_;
  }
  
  private UTCmodelSet2.utcA2Type utcA2_;
  public UTCmodelSet2.utcA2Type getUtcA2() {
    return utcA2_;
  }
  /**
   * @throws ClassCastException if value is not a UTCmodelSet2.utcA2Type
   */
  public void setUtcA2(Asn1Object value) {
    this.utcA2_ = (UTCmodelSet2.utcA2Type) value;
  }
  public UTCmodelSet2.utcA2Type setUtcA2ToNewInstance() {
    utcA2_ = new UTCmodelSet2.utcA2Type();
    return utcA2_;
  }
  
  private UTCmodelSet2.utcDeltaTlsType utcDeltaTls_;
  public UTCmodelSet2.utcDeltaTlsType getUtcDeltaTls() {
    return utcDeltaTls_;
  }
  /**
   * @throws ClassCastException if value is not a UTCmodelSet2.utcDeltaTlsType
   */
  public void setUtcDeltaTls(Asn1Object value) {
    this.utcDeltaTls_ = (UTCmodelSet2.utcDeltaTlsType) value;
  }
  public UTCmodelSet2.utcDeltaTlsType setUtcDeltaTlsToNewInstance() {
    utcDeltaTls_ = new UTCmodelSet2.utcDeltaTlsType();
    return utcDeltaTls_;
  }
  
  private UTCmodelSet2.utcTotType utcTot_;
  public UTCmodelSet2.utcTotType getUtcTot() {
    return utcTot_;
  }
  /**
   * @throws ClassCastException if value is not a UTCmodelSet2.utcTotType
   */
  public void setUtcTot(Asn1Object value) {
    this.utcTot_ = (UTCmodelSet2.utcTotType) value;
  }
  public UTCmodelSet2.utcTotType setUtcTotToNewInstance() {
    utcTot_ = new UTCmodelSet2.utcTotType();
    return utcTot_;
  }
  
  private UTCmodelSet2.utcWNotType utcWNot_;
  public UTCmodelSet2.utcWNotType getUtcWNot() {
    return utcWNot_;
  }
  /**
   * @throws ClassCastException if value is not a UTCmodelSet2.utcWNotType
   */
  public void setUtcWNot(Asn1Object value) {
    this.utcWNot_ = (UTCmodelSet2.utcWNotType) value;
  }
  public UTCmodelSet2.utcWNotType setUtcWNotToNewInstance() {
    utcWNot_ = new UTCmodelSet2.utcWNotType();
    return utcWNot_;
  }
  
  private UTCmodelSet2.utcWNlsfType utcWNlsf_;
  public UTCmodelSet2.utcWNlsfType getUtcWNlsf() {
    return utcWNlsf_;
  }
  /**
   * @throws ClassCastException if value is not a UTCmodelSet2.utcWNlsfType
   */
  public void setUtcWNlsf(Asn1Object value) {
    this.utcWNlsf_ = (UTCmodelSet2.utcWNlsfType) value;
  }
  public UTCmodelSet2.utcWNlsfType setUtcWNlsfToNewInstance() {
    utcWNlsf_ = new UTCmodelSet2.utcWNlsfType();
    return utcWNlsf_;
  }
  
  private UTCmodelSet2.utcDNType utcDN_;
  public UTCmodelSet2.utcDNType getUtcDN() {
    return utcDN_;
  }
  /**
   * @throws ClassCastException if value is not a UTCmodelSet2.utcDNType
   */
  public void setUtcDN(Asn1Object value) {
    this.utcDN_ = (UTCmodelSet2.utcDNType) value;
  }
  public UTCmodelSet2.utcDNType setUtcDNToNewInstance() {
    utcDN_ = new UTCmodelSet2.utcDNType();
    return utcDN_;
  }
  
  private UTCmodelSet2.utcDeltaTlsfType utcDeltaTlsf_;
  public UTCmodelSet2.utcDeltaTlsfType getUtcDeltaTlsf() {
    return utcDeltaTlsf_;
  }
  /**
   * @throws ClassCastException if value is not a UTCmodelSet2.utcDeltaTlsfType
   */
  public void setUtcDeltaTlsf(Asn1Object value) {
    this.utcDeltaTlsf_ = (UTCmodelSet2.utcDeltaTlsfType) value;
  }
  public UTCmodelSet2.utcDeltaTlsfType setUtcDeltaTlsfToNewInstance() {
    utcDeltaTlsf_ = new UTCmodelSet2.utcDeltaTlsfType();
    return utcDeltaTlsf_;
  }
  

  

  

  @Override public Iterable<? extends SequenceComponent> getComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 0);

          @Override public boolean isExplicitlySet() {
            return getUtcA0() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getUtcA0();
          }

          @Override public void setToNewInstance() {
            setUtcA0ToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? UTCmodelSet2.utcA0Type.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""utcA0 : ""
                    + getUtcA0().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 1);

          @Override public boolean isExplicitlySet() {
            return getUtcA1() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getUtcA1();
          }

          @Override public void setToNewInstance() {
            setUtcA1ToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? UTCmodelSet2.utcA1Type.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""utcA1 : ""
                    + getUtcA1().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 2);

          @Override public boolean isExplicitlySet() {
            return getUtcA2() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getUtcA2();
          }

          @Override public void setToNewInstance() {
            setUtcA2ToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? UTCmodelSet2.utcA2Type.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""utcA2 : ""
                    + getUtcA2().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 3);

          @Override public boolean isExplicitlySet() {
            return getUtcDeltaTls() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getUtcDeltaTls();
          }

          @Override public void setToNewInstance() {
            setUtcDeltaTlsToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? UTCmodelSet2.utcDeltaTlsType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""utcDeltaTls : ""
                    + getUtcDeltaTls().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 4);

          @Override public boolean isExplicitlySet() {
            return getUtcTot() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getUtcTot();
          }

          @Override public void setToNewInstance() {
            setUtcTotToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? UTCmodelSet2.utcTotType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""utcTot : ""
                    + getUtcTot().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 5);

          @Override public boolean isExplicitlySet() {
            return getUtcWNot() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getUtcWNot();
          }

          @Override public void setToNewInstance() {
            setUtcWNotToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? UTCmodelSet2.utcWNotType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""utcWNot : ""
                    + getUtcWNot().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 6);

          @Override public boolean isExplicitlySet() {
            return getUtcWNlsf() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getUtcWNlsf();
          }

          @Override public void setToNewInstance() {
            setUtcWNlsfToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? UTCmodelSet2.utcWNlsfType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""utcWNlsf : ""
                    + getUtcWNlsf().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 7);

          @Override public boolean isExplicitlySet() {
            return getUtcDN() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getUtcDN();
          }

          @Override public void setToNewInstance() {
            setUtcDNToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? UTCmodelSet2.utcDNType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""utcDN : ""
                    + getUtcDN().toIndentedString(indent);
              }
        });
    
    builder.add(new SequenceComponent() {
          Asn1Tag tag = Asn1Tag.fromClassAndNumber(2, 8);

          @Override public boolean isExplicitlySet() {
            return getUtcDeltaTlsf() != null;
          }

          @Override public boolean hasDefaultValue() {
            return false;
          }

          @Override public boolean isOptional() {
            return false;
          }

          @Override public Asn1Object getComponentValue() {
            return getUtcDeltaTlsf();
          }

          @Override public void setToNewInstance() {
            setUtcDeltaTlsfToNewInstance();
          }

          @Override public Collection<Asn1Tag> getPossibleFirstTags() {
            return tag == null ? UTCmodelSet2.utcDeltaTlsfType.getPossibleFirstTags() : ImmutableList.of(tag);
          }

          @Override
          public Asn1Tag getTag() {
            return tag;
          }

          @Override
          public boolean isImplicitTagging() {
            return true;
          }

          @Override public String toIndentedString(String indent) {
                return ""utcDeltaTlsf : ""
                    + getUtcDeltaTlsf().toIndentedString(indent);
              }
        });
    
    return builder.build();
  }

  @Override public Iterable<? extends SequenceComponent>
                                                    getExtensionComponents() {
    ImmutableList.Builder<SequenceComponent> builder = ImmutableList.builder();
      
      return builder.build();
    }

  
/*
 */


//

/**
 */
public static class utcA0Type extends Asn1Integer {
  //

  private static final Asn1Tag TAG_utcA0Type
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public utcA0Type() {
    super();
    setValueRange(""-32768"", ""32767"");

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_utcA0Type;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_utcA0Type != null) {
      return ImmutableList.of(TAG_utcA0Type);
    } else {
      return Asn1Integer.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new utcA0Type from encoded stream.
   */
  public static utcA0Type fromPerUnaligned(byte[] encodedBytes) {
    utcA0Type result = new utcA0Type();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new utcA0Type from encoded stream.
   */
  public static utcA0Type fromPerAligned(byte[] encodedBytes) {
    utcA0Type result = new utcA0Type();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""utcA0Type = "" + getInteger() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class utcA1Type extends Asn1Integer {
  //

  private static final Asn1Tag TAG_utcA1Type
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public utcA1Type() {
    super();
    setValueRange(""-4096"", ""4095"");

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_utcA1Type;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_utcA1Type != null) {
      return ImmutableList.of(TAG_utcA1Type);
    } else {
      return Asn1Integer.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new utcA1Type from encoded stream.
   */
  public static utcA1Type fromPerUnaligned(byte[] encodedBytes) {
    utcA1Type result = new utcA1Type();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new utcA1Type from encoded stream.
   */
  public static utcA1Type fromPerAligned(byte[] encodedBytes) {
    utcA1Type result = new utcA1Type();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""utcA1Type = "" + getInteger() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class utcA2Type extends Asn1Integer {
  //

  private static final Asn1Tag TAG_utcA2Type
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public utcA2Type() {
    super();
    setValueRange(""-64"", ""63"");

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_utcA2Type;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_utcA2Type != null) {
      return ImmutableList.of(TAG_utcA2Type);
    } else {
      return Asn1Integer.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new utcA2Type from encoded stream.
   */
  public static utcA2Type fromPerUnaligned(byte[] encodedBytes) {
    utcA2Type result = new utcA2Type();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new utcA2Type from encoded stream.
   */
  public static utcA2Type fromPerAligned(byte[] encodedBytes) {
    utcA2Type result = new utcA2Type();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""utcA2Type = "" + getInteger() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class utcDeltaTlsType extends Asn1Integer {
  //

  private static final Asn1Tag TAG_utcDeltaTlsType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public utcDeltaTlsType() {
    super();
    setValueRange(""-128"", ""127"");

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_utcDeltaTlsType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_utcDeltaTlsType != null) {
      return ImmutableList.of(TAG_utcDeltaTlsType);
    } else {
      return Asn1Integer.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new utcDeltaTlsType from encoded stream.
   */
  public static utcDeltaTlsType fromPerUnaligned(byte[] encodedBytes) {
    utcDeltaTlsType result = new utcDeltaTlsType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new utcDeltaTlsType from encoded stream.
   */
  public static utcDeltaTlsType fromPerAligned(byte[] encodedBytes) {
    utcDeltaTlsType result = new utcDeltaTlsType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""utcDeltaTlsType = "" + getInteger() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class utcTotType extends Asn1Integer {
  //

  private static final Asn1Tag TAG_utcTotType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public utcTotType() {
    super();
    setValueRange(""0"", ""65535"");

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_utcTotType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_utcTotType != null) {
      return ImmutableList.of(TAG_utcTotType);
    } else {
      return Asn1Integer.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new utcTotType from encoded stream.
   */
  public static utcTotType fromPerUnaligned(byte[] encodedBytes) {
    utcTotType result = new utcTotType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new utcTotType from encoded stream.
   */
  public static utcTotType fromPerAligned(byte[] encodedBytes) {
    utcTotType result = new utcTotType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""utcTotType = "" + getInteger() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class utcWNotType extends Asn1Integer {
  //

  private static final Asn1Tag TAG_utcWNotType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public utcWNotType() {
    super();
    setValueRange(""0"", ""8191"");

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_utcWNotType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_utcWNotType != null) {
      return ImmutableList.of(TAG_utcWNotType);
    } else {
      return Asn1Integer.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new utcWNotType from encoded stream.
   */
  public static utcWNotType fromPerUnaligned(byte[] encodedBytes) {
    utcWNotType result = new utcWNotType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new utcWNotType from encoded stream.
   */
  public static utcWNotType fromPerAligned(byte[] encodedBytes) {
    utcWNotType result = new utcWNotType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""utcWNotType = "" + getInteger() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class utcWNlsfType extends Asn1Integer {
  //

  private static final Asn1Tag TAG_utcWNlsfType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public utcWNlsfType() {
    super();
    setValueRange(""0"", ""255"");

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_utcWNlsfType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_utcWNlsfType != null) {
      return ImmutableList.of(TAG_utcWNlsfType);
    } else {
      return Asn1Integer.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new utcWNlsfType from encoded stream.
   */
  public static utcWNlsfType fromPerUnaligned(byte[] encodedBytes) {
    utcWNlsfType result = new utcWNlsfType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new utcWNlsfType from encoded stream.
   */
  public static utcWNlsfType fromPerAligned(byte[] encodedBytes) {
    utcWNlsfType result = new utcWNlsfType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""utcWNlsfType = "" + getInteger() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class utcDNType extends Asn1BitString {
  //

  private static final Asn1Tag TAG_utcDNType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public utcDNType() {
    super();
    setMinSize(4);
setMaxSize(4);

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_utcDNType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_utcDNType != null) {
      return ImmutableList.of(TAG_utcDNType);
    } else {
      return Asn1BitString.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new utcDNType from encoded stream.
   */
  public static utcDNType fromPerUnaligned(byte[] encodedBytes) {
    utcDNType result = new utcDNType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new utcDNType from encoded stream.
   */
  public static utcDNType fromPerAligned(byte[] encodedBytes) {
    utcDNType result = new utcDNType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""utcDNType = "" + getValue() + "";\n"";
  }
}

  
/*
 */


//

/**
 */
public static class utcDeltaTlsfType extends Asn1Integer {
  //

  private static final Asn1Tag TAG_utcDeltaTlsfType
      = Asn1Tag.fromClassAndNumber(-1, -1);

  public utcDeltaTlsfType() {
    super();
    setValueRange(""-128"", ""127"");

  }

  @Override
  @Nullable
  protected Asn1Tag getTag() {
    return TAG_utcDeltaTlsfType;
  }

  @Override
  protected boolean isTagImplicit() {
    return true;
  }

  public static Collection<Asn1Tag> getPossibleFirstTags() {
    if (TAG_utcDeltaTlsfType != null) {
      return ImmutableList.of(TAG_utcDeltaTlsfType);
    } else {
      return Asn1Integer.getPossibleFirstTags();
    }
  }

  /**
   * Creates a new utcDeltaTlsfType from encoded stream.
   */
  public static utcDeltaTlsfType fromPerUnaligned(byte[] encodedBytes) {
    utcDeltaTlsfType result = new utcDeltaTlsfType();
    result.decodePerUnaligned(new BitStreamReader(encodedBytes));
    return result;
  }

  /**
   * Creates a new utcDeltaTlsfType from encoded stream.
   */
  public static utcDeltaTlsfType fromPerAligned(byte[] encodedBytes) {
    utcDeltaTlsfType result = new utcDeltaTlsfType();
    result.decodePerAligned(new BitStreamReader(encodedBytes));
    return result;
  }

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    return ""utcDeltaTlsfType = "" + getInteger() + "";\n"";
  }
}

  

    

  @Override public Iterable<BitStream> encodePerUnaligned() {
    return super.encodePerUnaligned();
  }

  @Override public Iterable<BitStream> encodePerAligned() {
    return super.encodePerAligned();
  }

  @Override public void decodePerUnaligned(BitStreamReader reader) {
    super.decodePerUnaligned(reader);
  }

  @Override public void decodePerAligned(BitStreamReader reader) {
    super.decodePerAligned(reader);
  }

  @Override public String toString() {
    return toIndentedString("""");
  }

  public String toIndentedString(String indent) {
    StringBuilder builder = new StringBuilder();
    builder.append(""UTCmodelSet2 = {\n"");
    final String internalIndent = indent + ""  "";
    for (SequenceComponent component : getComponents()) {
      if (component.isExplicitlySet()) {
        builder.append(internalIndent)
            .append(component.toIndentedString(internalIndent));
      }
    }
    if (isExtensible()) {
      builder.append(internalIndent).append(""...\n"");
      for (SequenceComponent component : getExtensionComponents()) {
        if (component.isExplicitlySet()) {
          builder.append(internalIndent)
              .append(component.toIndentedString(internalIndent));
        }
      }
    }
    builder.append(indent).append(""};\n"");
    return builder.toString();
  }
}"	"/home/gpoor/cts-12-source/cts/tests/location/location_gnss/src/android/location/cts/gnss/asn1/supl2/rrlp_components/UTCmodelSet2.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.scopedstorage.cts.host.AppCloningHostTest"	"isHeadlessSystemUserMode"	""	"3: direct system user"	"/*
 *.
 */

package android.scopedstorage.cts.host;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assume.assumeFalse;
import static org.junit.Assume.assumeTrue;

import android.platform.test.annotations.AppModeFull;

import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.device.contentprovider.ContentProviderHandler;
import com.android.tradefed.targetprep.TargetSetupError;
import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;
import com.android.tradefed.util.CommandResult;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Runs the AppCloning tests.
 */
@RunWith(DeviceJUnit4ClassRunner.class)
@AppModeFull
public class AppCloningHostTest extends BaseHostTestCase {
    private static final String APP_A = ""CtsScopedStorageTestAppA.apk"";
    private static final String APP_A_PACKAGE = ""android.scopedstorage.cts.testapp.A.withres"";
    private static final String CONTENT_PROVIDER_URL = ""content://android.tradefed.contentprovider"";
    private static final int CLONE_PROFILE_DIRECTORY_CREATION_TIMEOUT_MS = 20000;
    private String mCloneUserId;
    private ContentProviderHandler mContentProviderHandler;


    @Before
    public void setup() throws Exception {
        assumeFalse(""Device is in headless system user mode"", isHeadlessSystemUserMode());
        assumeTrue(isAtLeastS());

        String output = executeShellCommand(
                ""pm create-user --profileOf 0 --user-type android.os.usertype.profile.CLONE ""
                        + ""testUser"");
        mCloneUserId = output.substring(output.lastIndexOf(' ') + 1).replaceAll(""[^0-9]"", """");
        assertThat(mCloneUserId).isNotEmpty();
        CommandResult out = executeShellV2Command(""am start-user -w %s"", mCloneUserId);
        assertThat(out.getStderr()).isEmpty();
        mContentProviderHandler = new ContentProviderHandler(getDevice());
        mContentProviderHandler.setUp();
    }

    @After
    public void tearDown() throws Exception {
        if (isHeadlessSystemUserMode() || !isAtLeastS()) return;
        mContentProviderHandler.tearDown();
        executeShellCommand(""pm remove-user %s"", mCloneUserId);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/AppCloningHostTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.scopedstorage.cts.host.AppCloningHostTest"	"testCreateCloneUserFile"	""	"2: direct user"	"public void testCreateCloneUserFile() throws Exception {
        CommandResult out;

        // Check that the clone user directories exist
        eventually(() -> {
            // Wait for finish.
            assertThat(isSuccessful(
                    runContentProviderCommand(""query"", mCloneUserId, ""/sdcard"", """"))).isTrue();
        }, CLONE_PROFILE_DIRECTORY_CREATION_TIMEOUT_MS);

        // Create a file on the clone user storage
        out = executeShellV2Command(""touch /sdcard/testFile.txt"");
        assertThat(isSuccessful(out)).isTrue();
        eventually(() -> {
            // Wait for finish.
            assertThat(isSuccessful(
                    runContentProviderCommand(""write"", mCloneUserId, ""/sdcard/testFile.txt"",
                            ""< /sdcard/testFile.txt""))).isTrue();
        }, CLONE_PROFILE_DIRECTORY_CREATION_TIMEOUT_MS);

        // Check that the above created file exists on the clone user storage
        out = runContentProviderCommand(""query"", mCloneUserId, ""/sdcard/testFile.txt"", """");
        assertThat(isSuccessful(out)).isTrue();

        // Cleanup the created file
        out = runContentProviderCommand(""delete"", mCloneUserId, ""/sdcard/testFile.txt"", """");
        assertThat(isSuccessful(out)).isTrue();
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/AppCloningHostTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.scopedstorage.cts.host.AppCloningHostTest"	"testPrivateAppDataDirectoryForCloneUser"	""	"2: direct user"	"public void testPrivateAppDataDirectoryForCloneUser() throws Exception {
        installAppAsUser(APP_A, Integer.valueOf(mCloneUserId));
        eventually(() -> {
            // Wait for finish.
            assertThat(isPackageInstalled(APP_A_PACKAGE, mCloneUserId)).isTrue();
        }, CLONE_PROFILE_DIRECTORY_CREATION_TIMEOUT_MS);
    }

    private void installAppAsUser(String packageFile, int userId)
            throws TargetSetupError, DeviceNotAvailableException {
        installPackageAsUser(packageFile, false, userId, ""-t"");
    }

    private CommandResult runContentProviderCommand(String commandType, String userId,
            String relativePath, String args) throws Exception {
        String fullUri = CONTENT_PROVIDER_URL + relativePath;
        return executeShellV2Command(""content %s --user %s --uri %s %s"",
                commandType, userId, fullUri, args);
    }

}"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/AppCloningHostTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.scopedstorage.cts.host.AppCloningHostTest"	"testInstallAppTwice"	""	"1: user"	"public void testInstallAppTwice() throws Exception {
        installAppAsUser(APP_A, getCurrentUserId());
        installAppAsUser(APP_A, Integer.valueOf(mCloneUserId));
        uninstallPackage(APP_A_PACKAGE);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/scopedstorage/host/src/android/scopedstorage/cts/host/AppCloningHostTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.telecom.cts.MockConnectionService"	"testVideoCallDelayProvider"	"CtsTelecomTestCases"	"3: direct ui interaction"	"public void test/*
 *.
 */

package android.telecom.cts;

import static android.telecom.cts.ThirdPartyCallScreeningServiceTest.EXTRA_NETWORK_IDENTIFIED_EMERGENCY_CALL;

import android.net.Uri;
import android.os.Bundle;
import android.telecom.Conference;
import android.telecom.Connection;
import android.telecom.ConnectionRequest;
import android.telecom.ConnectionService;
import android.telecom.DisconnectCause;
import android.telecom.PhoneAccountHandle;
import android.telecom.RemoteConference;
import android.telecom.RemoteConnection;
import android.telecom.TelecomManager;
import android.util.Log;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

/**
 * Default implementation of a {@link CtsConnectionService}. This is used for the majority
 * of Telecom CTS tests that simply require that a outgoing call is placed, or incoming call is
 * received.
 */
public class MockConnectionService extends ConnectionService {
    public static final Uri VERSTAT_NOT_VERIFIED_NUMBER = Uri.fromParts(""tel"", ""777"", null);
    public static final Uri VERSTAT_PASSED_NUMBER = Uri.fromParts(""tel"", ""555"", null);
    public static final Uri VERSTAT_FAILED_NUMBER = Uri.fromParts(""tel"", ""333"", null);
    public static final String EXTRA_TEST = ""com.android.telecom.extra.TEST"";
    public static final String TEST_VALUE = ""we've got it"";
    public static final int CONNECTION_PRESENTATION =  TelecomManager.PRESENTATION_ALLOWED;

    public static final int EVENT_CONNECTION_SERVICE_FOCUS_GAINED = 0;
    public static final int EVENT_CONNECTION_SERVICE_FOCUS_LOST = 1;
    public static final int EVENT_CONNECTION_SERVICE_CREATE_CONNECTION = 2;
    public static final int EVENT_CONNECTION_SERVICE_CREATE_CONNECTION_FAILED = 3;
    // Update TOTAL_EVENT below with last event.
    private static final int TOTAL_EVENT = EVENT_CONNECTION_SERVICE_CREATE_CONNECTION_FAILED + 1;

    private static final int DEFAULT_EVENT_TIMEOUT_MS = 2000;

    private final Semaphore[] mEventLock = initializeSemaphore(TOTAL_EVENT);

    /**
     * Used to control whether the {@link MockVideoProvider} will be created when connections are
     * created.  Used by {@link VideoCallTest#testVideoCallDelayProvider()} to test scenario where
     * the {@link MockVideoProvider} is not created immediately when the Connection is created.
     */
    private boolean mCreateVideoProvider = true;

    public Semaphore lock = new Semaphore(0);
    public List<MockConnection> outgoingConnections = new ArrayList<MockConnection>();
    public List<MockConnection> incomingConnections = new ArrayList<MockConnection>();
    public List<RemoteConnection> remoteConnections = new ArrayList<RemoteConnection>();
    public List<MockConference> conferences = new ArrayList<MockConference>();
    public List<RemoteConference> remoteConferences = new ArrayList<RemoteConference>();
    public List<MockConnection> failedConnections = new ArrayList<>();
    public ConnectionRequest connectionRequest = null;

    @Override
    public Connection onCreateOutgoingConnection(PhoneAccountHandle connectionManagerPhoneAccount,
            ConnectionRequest request) {
        final MockConnection connection = new MockConnection();
        connection.setAddress(request.getAddress(), CONNECTION_PRESENTATION);
        connection.setMockPhoneAccountHandle(connectionManagerPhoneAccount);
        connection.setConnectionCapabilities(Connection.CAPABILITY_SUPPORT_HOLD |
                Connection.CAPABILITY_HOLD
                | Connection.CAPABILITY_SUPPORTS_VT_LOCAL_BIDIRECTIONAL
                | Connection.CAPABILITY_SUPPORTS_VT_REMOTE_BIDIRECTIONAL);
        if (mCreateVideoProvider) {
            connection.createMockVideoProvider();
        } else {
            mCreateVideoProvider = true;
        }
        connection.setVideoState(request.getVideoState());
        connection.setInitializing();
        if (request.isRequestingRtt()) {
            connection.setRttTextStream(request.getRttTextStream());
            connection.setConnectionProperties(connection.getConnectionProperties() |
                    Connection.PROPERTY_IS_RTT);
        }
        // Emit an extra into the connection.  We'll see if it makes it through.
        Bundle testExtra = new Bundle();
        testExtra.putString(EXTRA_TEST, TEST_VALUE);
        connection.putExtras(testExtra);
        outgoingConnections.add(connection);
        lock.release();
        mEventLock[EVENT_CONNECTION_SERVICE_CREATE_CONNECTION].release();
        return connection;
    }

    @Override
    public Connection onCreateIncomingConnection(PhoneAccountHandle connectionManagerPhoneAccount,
            ConnectionRequest request) {
        final MockConnection connection = new MockConnection();
        connection.setAddress(request.getAddress(), CONNECTION_PRESENTATION);
        connection.setConnectionCapabilities(connection.getConnectionCapabilities()
                | Connection.CAPABILITY_CAN_SEND_RESPONSE_VIA_CONNECTION
                | Connection.CAPABILITY_SUPPORT_HOLD
                | Connection.CAPABILITY_HOLD);
        connection.createMockVideoProvider();
        ((Connection) connection).setVideoState(request.getVideoState());
        if (request.isRequestingRtt()) {
            connection.setRttTextStream(request.getRttTextStream());
            connection.setConnectionProperties(connection.getConnectionProperties() |
                    Connection.PROPERTY_IS_RTT);
        }
        connection.setRinging();
        // Emit an extra into the connection.  We'll see if it makes it through.
        Bundle testExtra = new Bundle();
        testExtra.putString(EXTRA_TEST, TEST_VALUE);
        connection.putExtras(testExtra);
        if (VERSTAT_NOT_VERIFIED_NUMBER.equals(request.getAddress())) {
            connection.setCallerNumberVerificationStatus(
                    Connection.VERIFICATION_STATUS_NOT_VERIFIED);
        } else if (VERSTAT_PASSED_NUMBER.equals(request.getAddress())) {
            connection.setCallerNumberVerificationStatus(
                    Connection.VERIFICATION_STATUS_PASSED);
        } else if (VERSTAT_FAILED_NUMBER.equals(request.getAddress())) {
            connection.setCallerNumberVerificationStatus(
                    Connection.VERIFICATION_STATUS_FAILED);
        }

        Bundle requestExtra = request.getExtras();
        if (requestExtra.getBoolean(EXTRA_NETWORK_IDENTIFIED_EMERGENCY_CALL, false)) {
            connection.setConnectionProperties(
                    Connection.PROPERTY_NETWORK_IDENTIFIED_EMERGENCY_CALL);
        }
        incomingConnections.add(connection);
        lock.release();
        mEventLock[EVENT_CONNECTION_SERVICE_CREATE_CONNECTION].release();
        return connection;
    }

    @Override
    public void onCreateIncomingConnectionFailed(PhoneAccountHandle connectionManagerPhoneAccount,
            ConnectionRequest request) {
        final MockConnection connection = new MockConnection();
        connection.setAddress(request.getAddress(), CONNECTION_PRESENTATION);
        connection.setPhoneAccountHandle(connectionManagerPhoneAccount);
        failedConnections.add(connection);
        lock.release();
        mEventLock[EVENT_CONNECTION_SERVICE_CREATE_CONNECTION_FAILED].release();
    }

    @Override
    public void onConference(Connection connection1, Connection connection2) {
        // Make sure that these connections are already not conferenced.
        if (connection1.getConference() == null && connection2.getConference() == null) {
            MockConference conference = new MockConference(
                    (MockConnection)connection1, (MockConnection)connection2);
            CtsConnectionService.addConferenceToTelecom(conference);
            conferences.add(conference);

            if (connection1.getState() == Connection.STATE_HOLDING){
                connection1.setActive();
            }
            if(connection2.getState() == Connection.STATE_HOLDING){
                connection2.setActive();
            }

            lock.release();
        }
    }
    @Override
    public Conference onCreateOutgoingConference(PhoneAccountHandle connectionManagerPhoneAccount,
            ConnectionRequest request) {
        final Connection connection = onCreateOutgoingConnection(connectionManagerPhoneAccount,
                request);
        final MockConference conference = new MockConference(connectionManagerPhoneAccount);
        conference.addConnection(connection);
        conferences.add(conference);
        connectionRequest = request;
        lock.release();
        return conference;
    }

    @Override
    public void onCreateOutgoingConferenceFailed(PhoneAccountHandle connectionManagerPhoneAccount,
            ConnectionRequest request) {
        final MockConference conference = new MockConference(connectionManagerPhoneAccount);
        conference.setDisconnected(new DisconnectCause(DisconnectCause.CANCELED));
        conferences.add(conference);
        connectionRequest = request;
        lock.release(2);
    }

    @Override
    public Conference onCreateIncomingConference(PhoneAccountHandle connectionManagerPhoneAccount,
            ConnectionRequest request) {
        final Connection connection = onCreateIncomingConnection(connectionManagerPhoneAccount,
                request);
        final MockConference conference = new MockConference(connectionManagerPhoneAccount);
        conference.addConnection(connection);
        connectionRequest = request;
        conferences.add(conference);
        lock.release();
        return conference;
    }

    @Override
    public void onCreateIncomingConferenceFailed(PhoneAccountHandle connectionManagerPhoneAccount,
            ConnectionRequest request) {
        final MockConference conference = new MockConference(connectionManagerPhoneAccount);
        conference.setDisconnected(new DisconnectCause(DisconnectCause.CANCELED));
        conferences.add(conference);
        connectionRequest = request;
        lock.release(2);
    }

    @Override
    public void onRemoteExistingConnectionAdded(RemoteConnection connection) {
        // Keep track of the remote connections added to the service
        remoteConnections.add(connection);
    }

    @Override
    public void onRemoteConferenceAdded(RemoteConference conference) {
        // Keep track of the remote connections added to the service
        remoteConferences.add(conference);
    }

    @Override
    public void onConnectionServiceFocusGained() {
        mEventLock[EVENT_CONNECTION_SERVICE_FOCUS_GAINED].release();
    }

    @Override
    public void onConnectionServiceFocusLost() {
        mEventLock[EVENT_CONNECTION_SERVICE_FOCUS_LOST].release();
        connectionServiceFocusReleased();
    }

    public void setCreateVideoProvider(boolean createVideoProvider) {
        mCreateVideoProvider = createVideoProvider;
    }

    /** Returns true if the given {@code event} is happened before the default timeout. */
    public boolean waitForEvent(int event) {
        if (event < 0 || event >= mEventLock.length) {
            return false;
        }

        try {
            return mEventLock[event].tryAcquire(DEFAULT_EVENT_TIMEOUT_MS, TimeUnit.MILLISECONDS);
        } catch (InterruptedException e) {
            // No interaction for the given event within the given timeout.
            return false;
        }
    }

    private static final Semaphore[] initializeSemaphore(int total) {
        Semaphore[] locks = new Semaphore[total];
        for (int i = 0; i < total; i++) {
            locks[i] = new Semaphore(0);
        }
        return locks;
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/telecom/src/android/telecom/cts/MockConnectionService.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.appsecurity.cts.InstantAppUserTest"	"uninstallTestPackages"	"CtsAppSecurityHostTestCases"	"3: apps ui user"	"/*
 *
 */

package android.appsecurity.cts;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;

import android.platform.test.annotations.AppModeFull;

import com.android.compatibility.common.tradefed.build.CompatibilityBuildHelper;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;
import com.android.tradefed.testtype.junit4.BaseHostJUnit4Test;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

/**
 * Tests for ephemeral packages.
 */
@RunWith(DeviceJUnit4ClassRunner.class)
@AppModeFull(reason = ""Already handles instant installs when needed"")
public class InstantAppUserTest extends BaseHostJUnit4Test {

    // a normally installed application
    private static final String NORMAL_APK = ""CtsEphemeralTestsNormalApp.apk"";
    private static final String NORMAL_PKG = ""com.android.cts.normalapp"";

    // a normally installed application with implicitly exposed components
    private static final String IMPLICIT_APK = ""CtsEphemeralTestsImplicitApp.apk"";
    private static final String IMPLICIT_PKG = ""com.android.cts.implicitapp"";

    // the first ephemerally installed application
    private static final String EPHEMERAL_1_APK = ""CtsEphemeralTestsEphemeralApp1.apk"";
    private static final String EPHEMERAL_1_PKG = ""com.android.cts.ephemeralapp1"";

    // an application to verify instant/full app per user
    private static final String USER_APK = ""CtsEphemeralTestsUserApp.apk"";
    private static final String USER_PKG = ""com.android.cts.userapp"";

    private static final String USER_TEST_APK = ""CtsEphemeralTestsUserAppTest.apk"";
    private static final String USER_TEST_PKG = ""com.android.cts.userapptest"";

    private static final String TEST_CLASS = "".ClientTest"";

    private boolean mSupportsMultiUser;
    private int mPrimaryUserId;
    private int mSecondaryUserId;
    private int mStartingUserId;

    @Before
    public void setUp() throws Exception {
        // This test only runs when we have at least 2 users to work with
        final int[] users = Utils.prepareMultipleUsers(getDevice(), 2);
        mSupportsMultiUser = (users.length == 2);
        if (!mSupportsMultiUser) {
            return;
        }
        mPrimaryUserId = getDevice().getPrimaryUserId();
        mStartingUserId = getDevice().getCurrentUser();
        mSecondaryUserId = users[1];
        getDevice().switchUser(mSecondaryUserId);
        uninstallTestPackages();
        installTestPackages();
    }

    @After
    public void tearDown() throws Exception {
        if (!mSupportsMultiUser) {
            return;
        }
        uninstallTestPackages();
        getDevice().switchUser(mStartingUserId);
    }

    // each connection to an exposed component needs to run in its own test to
    // avoid sharing state. once an instant app is exposed to a component, it's
    // exposed until the device restarts or the instant app is removed."	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/InstantAppUserTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.appsecurity.cts.InstantAppUserTest"	"testReplaceExisting"	"CtsAppSecurityHostTestCases"	"2: ui user"	"public void testReplaceExisting() throws Exception {
        if (!mSupportsMultiUser) {
            return;
        }
        installInstantApp(USER_APK);
        runDeviceTestsAsUser(USER_TEST_PKG, TEST_CLASS, ""testQueryInstant"", mPrimaryUserId);
        runDeviceTestsAsUser(USER_TEST_PKG, TEST_CLASS, ""testQueryInstant"", mSecondaryUserId);

        replaceFullAppAsUser(USER_APK, mSecondaryUserId);
        runDeviceTestsAsUser(USER_TEST_PKG, TEST_CLASS, ""testQueryInstant"", mPrimaryUserId);
        runDeviceTestsAsUser(USER_TEST_PKG, TEST_CLASS, ""testQueryFull"", mSecondaryUserId);
    }

    private void installTestPackages() throws Exception {
        installApp(NORMAL_APK);
        installApp(IMPLICIT_APK);
        installInstantApp(EPHEMERAL_1_APK);
        installApp(USER_TEST_APK);
    }

    private void uninstallTestPackages() throws Exception {
        getDevice().uninstallPackage(NORMAL_PKG);
        getDevice().uninstallPackage(IMPLICIT_PKG);
        getDevice().uninstallPackage(EPHEMERAL_1_PKG);
        getDevice().uninstallPackage(USER_TEST_PKG);
        getDevice().uninstallPackage(USER_PKG);
    }

    private void runDeviceTestsAsUser(String packageName, String testClassName,
            String testMethodName, int userId)
            throws DeviceNotAvailableException {
        Utils.runDeviceTests(getDevice(), packageName, testClassName, testMethodName, userId);
    }

    private void installApp(String apk) throws Exception {
        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(getBuild());
        assertNull(getDevice().installPackage(buildHelper.getTestFile(apk), false));
    }

    private void installInstantApp(String apk) throws Exception {
        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(getBuild());
        assertNull(getDevice().installPackage(buildHelper.getTestFile(apk), false, ""--instant""));
    }

    private void installAppAsUser(String apk, int userId) throws Exception {
        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(getBuild());
        assertNull(getDevice().installPackageForUser(buildHelper.getTestFile(apk), false, userId));
    }

    private void replaceFullAppAsUser(String apk, int userId) throws Exception {
        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(getBuild());
        assertNull(getDevice().installPackageForUser(
                buildHelper.getTestFile(apk), true, userId, ""--full""));
    }

    private void installExistingInstantAppAsUser(String packageName, int userId) throws Exception {
        final String installString =
                ""Package "" + packageName + "" installed for user: "" + userId + ""\n"";
        assertEquals(installString, getDevice().executeShellCommand(
                ""cmd package install-existing --instant""
                        + "" --user "" + Integer.toString(userId)
                        + "" "" + packageName));
    }

    private void installExistingFullAppAsUser(String packageName, int userId) throws Exception {
        final String installString =
                ""Package "" + packageName + "" installed for user: "" + userId + ""\n"";
        assertEquals(installString, getDevice().executeShellCommand(
                ""cmd package install-existing --full""
                        + "" --user "" + Integer.toString(userId)
                        + "" "" + packageName));
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/InstantAppUserTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.appsecurity.cts.InstantAppUserTest"	"testStartExposed01"	"CtsAppSecurityHostTestCases"	"1: user"	"public void testStartExposed01() throws Exception {
        if (!mSupportsMultiUser) {
            return;
        }
        runDeviceTestsAsUser(EPHEMERAL_1_PKG, TEST_CLASS, ""testStartExposed01"", mSecondaryUserId);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/InstantAppUserTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.appsecurity.cts.InstantAppUserTest"	"testStartExposed02"	"CtsAppSecurityHostTestCases"	"1: user"	"public void testStartExposed02() throws Exception {
        if (!mSupportsMultiUser) {
            return;
        }
        runDeviceTestsAsUser(EPHEMERAL_1_PKG, TEST_CLASS, ""testStartExposed02"", mSecondaryUserId);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/InstantAppUserTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.appsecurity.cts.InstantAppUserTest"	"testStartExposed03"	"CtsAppSecurityHostTestCases"	"1: user"	"public void testStartExposed03() throws Exception {
        if (!mSupportsMultiUser) {
            return;
        }
        runDeviceTestsAsUser(EPHEMERAL_1_PKG, TEST_CLASS, ""testStartExposed03"", mSecondaryUserId);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/InstantAppUserTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.appsecurity.cts.InstantAppUserTest"	"testStartExposed04"	"CtsAppSecurityHostTestCases"	"1: user"	"public void testStartExposed04() throws Exception {
        if (!mSupportsMultiUser) {
            return;
        }
        runDeviceTestsAsUser(EPHEMERAL_1_PKG, TEST_CLASS, ""testStartExposed04"", mSecondaryUserId);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/InstantAppUserTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.appsecurity.cts.InstantAppUserTest"	"testStartExposed05"	"CtsAppSecurityHostTestCases"	"1: user"	"public void testStartExposed05() throws Exception {
        if (!mSupportsMultiUser) {
            return;
        }
        runDeviceTestsAsUser(EPHEMERAL_1_PKG, TEST_CLASS, ""testStartExposed05"", mSecondaryUserId);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/InstantAppUserTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.appsecurity.cts.InstantAppUserTest"	"testStartExposed06"	"CtsAppSecurityHostTestCases"	"1: user"	"public void testStartExposed06() throws Exception {
        if (!mSupportsMultiUser) {
            return;
        }
        runDeviceTestsAsUser(EPHEMERAL_1_PKG, TEST_CLASS, ""testStartExposed06"", mSecondaryUserId);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/InstantAppUserTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.appsecurity.cts.InstantAppUserTest"	"testStartExposed07"	"CtsAppSecurityHostTestCases"	"1: user"	"public void testStartExposed07() throws Exception {
        if (!mSupportsMultiUser) {
            return;
        }
        runDeviceTestsAsUser(EPHEMERAL_1_PKG, TEST_CLASS, ""testStartExposed07"", mSecondaryUserId);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/InstantAppUserTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.appsecurity.cts.InstantAppUserTest"	"testStartExposed08"	"CtsAppSecurityHostTestCases"	"1: user"	"public void testStartExposed08() throws Exception {
        if (!mSupportsMultiUser) {
            return;
        }
        runDeviceTestsAsUser(EPHEMERAL_1_PKG, TEST_CLASS, ""testStartExposed08"", mSecondaryUserId);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/InstantAppUserTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.appsecurity.cts.InstantAppUserTest"	"testStartExposed09"	"CtsAppSecurityHostTestCases"	"1: user"	"public void testStartExposed09() throws Exception {
        if (!mSupportsMultiUser) {
            return;
        }
        runDeviceTestsAsUser(EPHEMERAL_1_PKG, TEST_CLASS, ""testStartExposed09"", mSecondaryUserId);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/InstantAppUserTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.appsecurity.cts.InstantAppUserTest"	"testStartExposed10"	"CtsAppSecurityHostTestCases"	"1: user"	"public void testStartExposed10() throws Exception {
        if (!mSupportsMultiUser) {
            return;
        }
        runDeviceTestsAsUser(EPHEMERAL_1_PKG, TEST_CLASS, ""testStartExposed10"", mSecondaryUserId);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/InstantAppUserTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.appsecurity.cts.InstantAppUserTest"	"testInstallInstant"	"CtsAppSecurityHostTestCases"	"1: user"	"public void testInstallInstant() throws Exception {
        if (!mSupportsMultiUser) {
            return;
        }
        installInstantApp(USER_APK);
        runDeviceTestsAsUser(USER_TEST_PKG, TEST_CLASS, ""testQueryInstant"", mPrimaryUserId);
        runDeviceTestsAsUser(USER_TEST_PKG, TEST_CLASS, ""testQueryInstant"", mSecondaryUserId);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/InstantAppUserTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.appsecurity.cts.InstantAppUserTest"	"testInstallFull"	"CtsAppSecurityHostTestCases"	"1: user"	"public void testInstallFull() throws Exception {
        if (!mSupportsMultiUser) {
            return;
        }
        installApp(USER_APK);
        runDeviceTestsAsUser(USER_TEST_PKG, TEST_CLASS, ""testQueryFull"", mPrimaryUserId);
        runDeviceTestsAsUser(USER_TEST_PKG, TEST_CLASS, ""testQueryFull"", mSecondaryUserId);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/InstantAppUserTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.appsecurity.cts.InstantAppUserTest"	"testInstallMultiple"	"CtsAppSecurityHostTestCases"	"1: user"	"public void testInstallMultiple() throws Exception {
        if (!mSupportsMultiUser) {
            return;
        }
        installAppAsUser(USER_APK, mPrimaryUserId);
        installExistingInstantAppAsUser(USER_PKG, mSecondaryUserId);
        runDeviceTestsAsUser(USER_TEST_PKG, TEST_CLASS, ""testQueryFull"", mPrimaryUserId);
        runDeviceTestsAsUser(USER_TEST_PKG, TEST_CLASS, ""testQueryInstant"", mSecondaryUserId);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/InstantAppUserTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.appsecurity.cts.InstantAppUserTest"	"testUpgradeExisting"	"CtsAppSecurityHostTestCases"	"1: user"	"public void testUpgradeExisting() throws Exception {
        if (!mSupportsMultiUser) {
            return;
        }
        installInstantApp(USER_APK);
        runDeviceTestsAsUser(USER_TEST_PKG, TEST_CLASS, ""testQueryInstant"", mPrimaryUserId);
        runDeviceTestsAsUser(USER_TEST_PKG, TEST_CLASS, ""testQueryInstant"", mSecondaryUserId);

        installExistingFullAppAsUser(USER_PKG, mSecondaryUserId);
        runDeviceTestsAsUser(USER_TEST_PKG, TEST_CLASS, ""testQueryInstant"", mPrimaryUserId);
        runDeviceTestsAsUser(USER_TEST_PKG, TEST_CLASS, ""testQueryFull"", mSecondaryUserId);
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/appsecurity/src/android/appsecurity/cts/InstantAppUserTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.server.wm.app.TestActivity"	"finish"	""	"1: ui"	"public void test/*
 *.
 */

package android.server.wm.app;

import static android.server.wm.app.Components.TestActivity.COMMAND_NAVIGATE_UP_TO;
import static android.server.wm.app.Components.TestActivity.COMMAND_START_ACTIVITY;
import static android.server.wm.app.Components.TestActivity.EXTRA_CONFIG_ASSETS_SEQ;
import static android.server.wm.app.Components.TestActivity.EXTRA_FIXED_ORIENTATION;
import static android.server.wm.app.Components.TestActivity.EXTRA_INTENTS;
import static android.server.wm.app.Components.TestActivity.EXTRA_INTENT;
import static android.server.wm.app.Components.TestActivity.EXTRA_NO_IDLE;
import static android.server.wm.app.Components.TestActivity.TEST_ACTIVITY_ACTION_FINISH_SELF;
import static android.server.wm.app.Components.TestActivity.COMMAND_START_ACTIVITIES;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.res.Configuration;
import android.os.Bundle;
import android.os.Looper;
import android.os.Parcelable;
import android.util.Log;
import android.view.animation.Animation;
import android.view.animation.RotateAnimation;
import android.widget.ProgressBar;

import java.util.Arrays;

public class TestActivity extends AbstractLifecycleLogActivity {

    private BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            if (intent != null && TEST_ACTIVITY_ACTION_FINISH_SELF.equals(intent.getAction())) {
                finish();
            }
        }
    };

    @Override
    protected void onCreate(Bundle icicle) {
        super.onCreate(icicle);

        // Set the fixed orientation if requested
        if (getIntent().hasExtra(EXTRA_FIXED_ORIENTATION)) {
            final int ori = Integer.parseInt(getIntent().getStringExtra(EXTRA_FIXED_ORIENTATION));
            setRequestedOrientation(ori);
        }

        if (getIntent().hasExtra(EXTRA_NO_IDLE)) {
            preventActivityIdle();
        }
    }

    /** Starts a repeated animation on main thread to make its message queue non-empty. */
    private void preventActivityIdle() {
        final ProgressBar progressBar = new ProgressBar(this);
        progressBar.setIndeterminate(true);
        setContentView(progressBar);
        final RotateAnimation animation = new RotateAnimation(0, 180, Animation.RELATIVE_TO_SELF,
                0.5f, Animation.RELATIVE_TO_SELF, 0.5f);
        animation.setRepeatCount(Animation.INFINITE);
        progressBar.startAnimation(animation);

        Looper.myLooper().getQueue().addIdleHandler(() -> {
            if (progressBar.isAnimating()) {
                throw new RuntimeException(""Shouldn't receive idle while animating"");
            }
            return false;
        });
    }

    @Override
    protected void onStart() {
        super.onStart();
        registerReceiver(mReceiver, new IntentFilter(TEST_ACTIVITY_ACTION_FINISH_SELF));
    }

    @Override
    protected void onResume() {
        super.onResume();
        final Configuration configuration = getResources().getConfiguration();
        dumpConfiguration(configuration);
        dumpAssetSeqNumber(configuration);
        dumpConfigInfo();
    }

    @Override
    protected void onStop() {
        super.onStop();
        unregisterReceiver(mReceiver);
    }

    @Override
    public void handleCommand(String command, Bundle data) {
        switch (command) {
            case COMMAND_START_ACTIVITY:
                final Intent startIntent = data.getParcelable(EXTRA_INTENT);
                try {
                    startActivity(startIntent);
                } catch (Exception e) {
                    Log.w(getTag(), ""Failed to startActivity: "" + startIntent, e);
                }
                break;
            case COMMAND_START_ACTIVITIES:
                final Parcelable[] intents = data.getParcelableArray(EXTRA_INTENTS);
                startActivities(Arrays.copyOf(intents, intents.length, Intent[].class));
                break;
            case COMMAND_NAVIGATE_UP_TO:
                final Intent intent = data.getParcelable(EXTRA_INTENT);
                try {
                    navigateUpTo(intent);
                } catch (Exception e) {
                    // Expected if the target activity in not exported with different uid.
                    Log.w(getTag(), ""Failed to navigateUpTo: "" + intent, e);
                }
                break;
            default:
                super.handleCommand(command, data);
        }
    }

    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        dumpConfiguration(newConfig);
        dumpAssetSeqNumber(newConfig);
        dumpConfigInfo();
    }

    @Override
    public void onMultiWindowModeChanged(boolean isInMultiWindowMode, Configuration newConfig) {
        super.onMultiWindowModeChanged(isInMultiWindowMode, newConfig);
        dumpConfiguration(newConfig);
        dumpAssetSeqNumber(newConfig);
        dumpConfigInfo();
    }

    private void dumpAssetSeqNumber(Configuration newConfig) {
        withTestJournalClient(client -> {
            final Bundle extras = new Bundle();
            extras.putInt(EXTRA_CONFIG_ASSETS_SEQ, newConfig.assetsSeq);
            client.putExtras(extras);
        });
    }
}"	"/home/gpoor/cts-12-source/cts/tests/framework/base/windowmanager/app_base/src/android/server/wm/app/TestActivity.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.provider.cts.contacts.CallLogTest"	"testLocationStorageAndRetrieval"	"CtsProviderTestCases"	"3: ui system user"	"public void testLocationStorageAndRetrieval() {
        Context context = getInstrumentation().getContext();

        if (!context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_TELEPHONY)) {
            // This is tied to default-dialer, so don't test if the device doesn't have telephony.
            return;
        }

        UserHandle currentUser = UserHandle.of(
                ShellIdentityUtils.invokeStaticMethodWithShellPermissions(
                        () -> ActivityManager.getCurrentUser()));
        CallLog.AddCallParams.AddCallParametersBuilder builder =
                new CallLog.AddCallParams.AddCallParametersBuilder();
        builder.setAddForAllUsers(false);
        builder.setUserToBeInsertedTo(currentUser);
        // Some random spot in the North Atlantic
        double lat = 24.877323;
        double lon = -68.952545;
        builder.setLatitude(lat);
        builder.setLongitude(lon);
        ShellUtils.runShellCommand(""telecom set-default-dialer %s"",
                getInstrumentation().getContext().getPackageName());

        try {
            Uri uri;
            getInstrumentation().getUiAutomation()
                    .adoptShellPermissionIdentity(Manifest.permission.INTERACT_ACROSS_USERS,
                            Manifest.permission.READ_VOICEMAIL);
            try {
                uri = CallLog.Calls.addCall(context, builder.build());
            } finally {
                getInstrumentation().getUiAutomation().dropShellPermissionIdentity();
            }
            assertNotNull(uri);

            Cursor cursor = context.getContentResolver().query(
                    uri, new String[]{CallLog.Calls.LOCATION}, null, null);
            assertEquals(1, cursor.getCount());
            cursor.moveToFirst();
            String locationUriString = cursor.getString(
                    cursor.getColumnIndex(CallLog.Calls.LOCATION));
            assertNotNull(locationUriString);

            Uri locationUri = Uri.parse(locationUriString);
            Cursor locationCursor = context.getContentResolver().query(locationUri,
                    new String[]{CallLog.Locations.LATITUDE, CallLog.Locations.LONGITUDE}, null,
                    null);
            assertEquals(1, locationCursor.getCount());
            locationCursor.moveToFirst();
            double storedLat = locationCursor.getDouble(
                    locationCursor.getColumnIndex(CallLog.Locations.LATITUDE));
            double storedLon = locationCursor.getDouble(
                    locationCursor.getColumnIndex(CallLog.Locations.LONGITUDE));
            assertEquals(lat, storedLat);
            assertEquals(lon, storedLon);
        } finally {
            ShellUtils.runShellCommand(""telecom set-default-dialer default"");
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/contacts/CallLogTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.provider.cts.contacts.CallLogTest"	"testCallComposerLoggingException"	"CtsProviderTestCases"	"1: system"	"public void testCallComposerLoggingException() {
        CallLog.CallComposerLoggingException e =
                new CallLog.CallComposerLoggingException(
                        CallLog.CallComposerLoggingException.ERROR_STORAGE_FULL);
        assertEquals(CallLog.CallComposerLoggingException.ERROR_STORAGE_FULL,
                e.getErrorCode());
    }

    private byte[] readResourceDrawable(Context context, int id) throws Exception {
        InputStream inputStream = context.getResources().openRawResource(id);
        return readBytes(inputStream);
    }

    private byte[] readBytes(InputStream inputStream) throws Exception {
        byte[] buffer = new byte[1024];
        ByteArrayOutputStream output = new ByteArrayOutputStream();
        int numRead;
        do {
            numRead = inputStream.read(buffer);
            if (numRead > 0) output.write(buffer, 0, numRead);
        } while (numRead > 0);
        return output.toByteArray();
    }

    private void waitUntilConditionIsTrueOrTimeout(Condition condition, long timeout,
            String description) {
        final long start = System.currentTimeMillis();
        while (!condition.expected().equals(condition.actual())
                && System.currentTimeMillis() - start < timeout) {
            sleep(50);
        }
        assertEquals(description, condition.expected(), condition.actual());
    }

    protected interface Condition {
        Object expected();
        Object actual();
    }

    private void sleep(long ms) {
        try {
            Thread.sleep(ms);
        } catch (InterruptedException e) {
        }
    }
}"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/contacts/CallLogTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.provider.cts.contacts.CallLogTest"	"testCallComposerImageStorage"	"CtsProviderTestCases"	"1: user"	"public void testCallComposerImageStorage() throws Exception {
        Context context = getInstrumentation().getContext();
        byte[] expected = readResourceDrawable(context, R.drawable.testimage);

        CompletableFuture<Pair<Uri, CallLog.CallComposerLoggingException>> resultFuture =
                new CompletableFuture<>();
        Pair<Uri, CallLog.CallComposerLoggingException> result;
        try (InputStream inputStream =
                     context.getResources().openRawResource(R.drawable.testimage)) {
            CallLog.storeCallComposerPicture(
                    context.createContextAsUser(android.os.Process.myUserHandle(), 0),
                    inputStream,
                    Executors.newSingleThreadExecutor(),
                    new OutcomeReceiver<Uri, CallLog.CallComposerLoggingException>() {
                        @Override
                        public void onResult(@NonNull Uri result) {
                            resultFuture.complete(Pair.create(result, null));
                        }

                        @Override
                        public void onError(CallLog.CallComposerLoggingException error) {
                            resultFuture.complete(Pair.create(null, error));
                        }
                    });
           result = resultFuture.get(CONTENT_RESOLVER_TIMEOUT_MS, TimeUnit.MILLISECONDS);
        }
        if (result.second != null) {
            fail(""Got error "" + result.second.getErrorCode() + "" when storing image"");
        }
        Uri imageLocation = result.first;

        try (ParcelFileDescriptor pfd =
                context.getContentResolver().openFileDescriptor(imageLocation, ""r"")) {
            byte[] remoteBytes = readBytes(new FileInputStream(pfd.getFileDescriptor()));
            assertArrayEquals(expected, remoteBytes);
        }
    }"	"/home/gpoor/cts-12-source/cts/tests/tests/provider/src/android/provider/cts/contacts/CallLogTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"android.view.cts.SurfaceViewSyncTest"	"TestName"	"CtsViewTestCases"	"1: ui"	"/*
 *.
 */
package android.view.cts;

import static android.server.wm.WindowManagerState.getLogicalDisplaySize;

import android.animation.ObjectAnimator;
import android.animation.PropertyValuesHolder;
import android.animation.ValueAnimator;
import android.annotation.SuppressLint;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.media.MediaPlayer;
import android.support.test.uiautomator.UiObjectNotFoundException;
import android.view.Gravity;
import android.view.SurfaceHolder;
import android.view.SurfaceView;
import android.view.View;
import android.view.ViewGroup;
import android.view.animation.LinearInterpolator;
import android.view.cts.surfacevalidator.AnimationFactory;
import android.view.cts.surfacevalidator.AnimationTestCase;
import android.view.cts.surfacevalidator.CapturedActivityWithResource;
import android.view.cts.surfacevalidator.PixelChecker;
import android.view.cts.surfacevalidator.ViewFactory;
import android.widget.FrameLayout;

import androidx.test.filters.LargeTest;
import androidx.test.filters.RequiresDevice;
import androidx.test.rule.ActivityTestRule;
import androidx.test.runner.AndroidJUnit4;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TestName;
import org.junit.runner.RunWith;

@RunWith(AndroidJUnit4.class)
@LargeTest
@SuppressLint(""RtlHardcoded"")
@RequiresDevice
public class SurfaceViewSyncTest {
    private static final String TAG = ""SurfaceViewSyncTests"";

    @Rule
    public ActivityTestRule<CapturedActivityWithResource> mActivityRule =
            new ActivityTestRule<>(CapturedActivityWithResource.class);

    @Rule
    public TestName mName = new TestName();

    private CapturedActivityWithResource mActivity;
    private MediaPlayer mMediaPlayer;

    @Before
    public void setup() {
        mActivity = mActivityRule.getActivity();
        mMediaPlayer = mActivity.getMediaPlayer();
        mActivity.setLogicalDisplaySize(getLogicalDisplaySize());
    }

    /**
     * Want to be especially sure we don't leave up the permission dialog, so try and dismiss
     * after test.
     */
    @After
    public void tearDown() throws UiObjectNotFoundException {
        mActivity.dismissPermissionDialog();
    }

    private static ValueAnimator makeInfinite(ValueAnimator a) {
        a.setRepeatMode(ObjectAnimator.REVERSE);
        a.setRepeatCount(ObjectAnimator.INFINITE);
        a.setDuration(200);
        a.setInterpolator(new LinearInterpolator());
        return a;
    }

    ///////////////////////////////////////////////////////////////////////////
    // ViewFactories
    ///////////////////////////////////////////////////////////////////////////

    private ViewFactory sEmptySurfaceViewFactory = context -> {
        SurfaceView surfaceView = new SurfaceView(context);

        // prevent transparent region optimization, which is invalid for a SurfaceView moving around
        surfaceView.setWillNotDraw(false);

        return surfaceView;
    };

    private ViewFactory sGreenSurfaceViewFactory = context -> {
        SurfaceView surfaceView = new SurfaceView(context);

        // prevent transparent region optimization, which is invalid for a SurfaceView moving around
        surfaceView.setWillNotDraw(false);

        surfaceView.getHolder().setFixedSize(640, 480);
        surfaceView.getHolder().addCallback(new SurfaceHolder.Callback() {
            @Override
            public void surfaceCreated(SurfaceHolder holder) {}

            @Override
            public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
                Canvas canvas = holder.lockCanvas();
                canvas.drawColor(Color.GREEN);
                holder.unlockCanvasAndPost(canvas);
            }

            @Override
            public void surfaceDestroyed(SurfaceHolder holder) {}
        });
        return surfaceView;
    };

    private ViewFactory sVideoViewFactory = context -> {
        SurfaceView surfaceView = new SurfaceView(context);

        // prevent transparent region optimization, which is invalid for a SurfaceView moving around
        surfaceView.setWillNotDraw(false);

        surfaceView.getHolder().setFixedSize(640, 480);
        surfaceView.getHolder().addCallback(new SurfaceHolder.Callback() {
            @Override
            public void surfaceCreated(SurfaceHolder holder) {
                mMediaPlayer.setSurface(holder.getSurface());
                mMediaPlayer.start();
            }

            @Override
            public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {}

            @Override
            public void surfaceDestroyed(SurfaceHolder holder) {
                mMediaPlayer.pause();
                mMediaPlayer.setSurface(null);
            }
        });
        return surfaceView;
    };

    ///////////////////////////////////////////////////////////////////////////
    // AnimationFactories
    ///////////////////////////////////////////////////////////////////////////

    private AnimationFactory sSmallScaleAnimationFactory = view -> {
        view.setPivotX(0);
        view.setPivotY(0);
        PropertyValuesHolder pvhX = PropertyValuesHolder.ofFloat(View.SCALE_X, 0.01f, 1f);
        PropertyValuesHolder pvhY = PropertyValuesHolder.ofFloat(View.SCALE_Y, 0.01f, 1f);
        return makeInfinite(ObjectAnimator.ofPropertyValuesHolder(view, pvhX, pvhY));
    };

    private AnimationFactory sBigScaleAnimationFactory = view -> {
        view.setTranslationX(10);
        view.setTranslationY(10);
        view.setPivotX(0);
        view.setPivotY(0);
        PropertyValuesHolder pvhX = PropertyValuesHolder.ofFloat(View.SCALE_X, 1f, 3f);
        PropertyValuesHolder pvhY = PropertyValuesHolder.ofFloat(View.SCALE_Y, 1f, 3f);
        return makeInfinite(ObjectAnimator.ofPropertyValuesHolder(view, pvhX, pvhY));
    };

    private AnimationFactory sTranslateAnimationFactory = view -> {
        PropertyValuesHolder pvhX = PropertyValuesHolder.ofFloat(View.TRANSLATION_X, 10f, 30f);
        PropertyValuesHolder pvhY = PropertyValuesHolder.ofFloat(View.TRANSLATION_Y, 10f, 30f);
        return makeInfinite(ObjectAnimator.ofPropertyValuesHolder(view, pvhX, pvhY));
    };

    ///////////////////////////////////////////////////////////////////////////
    // Tests
    ///////////////////////////////////////////////////////////////////////////

    /** Draws a moving 10x10 black rectangle, validates 100 pixels of black are seen each frame */"	"/home/gpoor/cts-12-source/cts/tests/tests/view/src/android/view/cts/SurfaceViewSyncTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.signedconfig.SignedConfigHostTest"	"uninstallTestApps"	"CtsSignedConfigHostTestCases"	"2: apps ui"	"/*
 *.
 */
package com.android.cts.signedconfig;

import static com.google.common.truth.Truth.assertThat;

import static org.hamcrest.Matchers.is;
import static org.hamcrest.Matchers.not;

import com.android.compatibility.common.tradefed.build.CompatibilityBuildHelper;
import com.android.tradefed.build.IBuildInfo;
import com.android.tradefed.device.DeviceNotAvailableException;
import com.android.tradefed.device.ITestDevice;
import com.android.tradefed.testtype.DeviceJUnit4ClassRunner;
import com.android.tradefed.testtype.IBuildReceiver;
import com.android.tradefed.testtype.IDeviceTest;

import org.junit.After;
import org.junit.Assume;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Objects;

@RunWith(DeviceJUnit4ClassRunner.class)
public class SignedConfigHostTest implements IDeviceTest, IBuildReceiver {

    private static final String TEST_APP_PACKAGE_NAME = ""android.cts.signedconfig.app"";
    private static final String TEST_APP_PACKAGE2_NAME = ""android.cts.signedconfig.app2"";
    private static final String TEST_APP_APK_NAME_V1 = ""CtsSignedConfigTestAppV1.apk"";
    private static final String TEST_APP_APK_NAME_V1_INSTANT =
            ""CtsSignedConfigTestAppV1_instant.apk"";
    private static final String TEST_APP_APK_NAME_V2 = ""CtsSignedConfigTestAppV2.apk"";
    private static final String TEST_APP_APK_NAME_V2_INSTANT =
            ""CtsSignedConfigTestAppV2_instant.apk"";
    private static final String TEST_APP_APK_NAME_PACKAGE2_V1 = ""CtsSignedConfigTestApp2V1.apk"";
    private static final String TEST_APP_APK_NAME_PACKAGE2_V2 = ""CtsSignedConfigTestApp2V2.apk"";
    private static final String TEST_APP_APK_NAME_V1_BAD_SIGNATURE =
            ""CtsSignedConfigTestAppV1_badsignature.apk"";
    private static final String TEST_APP_APK_NAME_V1_BAD_B64_CONFIG =
            ""CtsSignedConfigTestAppV1_badb64_config.apk"";
    private static final String TEST_APP_APK_NAME_V1_BAD_B64_SIGNATURE =
            ""CtsSignedConfigTestAppV1_badb64_signature.apk"";
    private static final String TEST_APP_APK_NAME_V3_CONFIGV1 =
            ""CtsSignedConfigTestAppV3_configv1.apk"";
    private static final String TEST_APP_APK_NAME_V1_DEBUG_KEY =
            ""CtsSignedConfigTestAppV1_debug_key.apk"";

    private static final String SETTING_BLACKLIST_EXEMPTIONS = ""hidden_api_blacklist_exemptions"";
    private static final String SETTING_SIGNED_CONFIG_VERSION = ""signed_config_version"";

    private static final String ARG_INSTANT = ""--instant"";

    private IBuildInfo mCtsBuild;
    private ITestDevice mDevice;

    @Override
    public void setBuild(IBuildInfo buildInfo) {
        mCtsBuild = buildInfo;
    }


    @Override
    public void setDevice(ITestDevice device) {
        mDevice = device;
    }

    @Override
    public ITestDevice getDevice() {
        return mDevice;
    }

    private File getTestApk(String name) throws FileNotFoundException {
        CompatibilityBuildHelper buildHelper = new CompatibilityBuildHelper(mCtsBuild);
        return buildHelper.getTestFile(name);
    }

    private void deleteSetting(String name) throws DeviceNotAvailableException {
        String output = getDevice().executeShellCommand(""settings delete global "" + name);
        assertThat(output).containsMatch(""Deleted (0|1) rows"");
    }

    private void deleteConfig() throws DeviceNotAvailableException {
        deleteSetting(SETTING_BLACKLIST_EXEMPTIONS);
        deleteSetting(SETTING_SIGNED_CONFIG_VERSION);
    }

    private void uninstallTestApps() throws DeviceNotAvailableException {
        getDevice().uninstallPackage(TEST_APP_PACKAGE_NAME);
        getDevice().uninstallPackage(TEST_APP_PACKAGE2_NAME);
    }

    private void waitUntilSettingMatches(String setting, String value) throws Exception {
        int tries = 0;
        String v;
        do {
            Thread.sleep(500);
            v = getDevice().getSetting(""global"", setting);
            tries++;
        } while (tries < 10 && !Objects.equals(value, v));
        assertThat(v).isEqualTo(value);
    }

    @Before
    public void setUp() throws Exception {
        deleteConfig();
        waitForDevice();
    }

    @After
    public void tearDown() throws Exception {
        uninstallTestApps();
        deleteConfig();
    }

    private void waitForDevice(int seconds) throws Exception {
        Thread.sleep(seconds * 1000);
    }

    private void waitForDevice() throws Exception {
        waitForDevice(1);
    }

    private void installPackage(String apkName, String... extraArgs)
            throws FileNotFoundException, DeviceNotAvailableException {
        assertThat(getDevice().installPackage(getTestApk(apkName), false, extraArgs)).isNull();
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/signedconfig/hostside/src/com/android/cts/signedconfig/SignedConfigHostTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.signedconfig.SignedConfigHostTest"	"testDebugKeyValidOnDebuggableBuild"	"CtsSignedConfigHostTestCases"	"1: ui"	"public void testDebugKeyValidOnDebuggableBuild() throws Exception {
        Assume.assumeThat(getDevice().getProperty(""ro.debuggable""), is(""1""));
        installPackage(TEST_APP_APK_NAME_V1_DEBUG_KEY);
        waitUntilSettingMatches(SETTING_SIGNED_CONFIG_VERSION, ""1"");
        assertThat(getDevice().getSetting(""global"", SETTING_BLACKLIST_EXEMPTIONS)).isEqualTo(
                ""LClass1;->method1(,LClass1;->field1:"");
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/signedconfig/hostside/src/com/android/cts/signedconfig/SignedConfigHostTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.signedconfig.SignedConfigHostTest"	"testDebugKeyNotValidOnNonDebuggableBuild"	"CtsSignedConfigHostTestCases"	"1: ui"	"public void testDebugKeyNotValidOnNonDebuggableBuild() throws Exception {
        Assume.assumeThat(getDevice().getProperty(""ro.debuggable""), not(is(""1"")));
        installPackage(TEST_APP_APK_NAME_V1_DEBUG_KEY);
        waitForDevice(5);
        assertThat(getDevice().getSetting(""global"", SETTING_SIGNED_CONFIG_VERSION))
                .isEqualTo(""null"");
        assertThat(getDevice().getSetting(""global"", SETTING_BLACKLIST_EXEMPTIONS))
                .isEqualTo(""null"");
    }
}"	"/home/gpoor/cts-12-source/cts/hostsidetests/signedconfig/hostside/src/com/android/cts/signedconfig/SignedConfigHostTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.signedconfig.SignedConfigHostTest"	"testBadBase64Config"	"CtsSignedConfigHostTestCases"	"1: system"	"public void testBadBase64Config() throws Exception {
        installPackage(TEST_APP_APK_NAME_V1_BAD_B64_CONFIG);
        waitForDevice(5);
        // This test is really testing that the system server doesn't crash, but
        // this check should still do the trick.
        assertThat(getDevice().getSetting(""global"", SETTING_SIGNED_CONFIG_VERSION))
                .isEqualTo(""null"");
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/signedconfig/hostside/src/com/android/cts/signedconfig/SignedConfigHostTest.java"	""	""	""
"2.2.5  . Security Model"	"9.8.2"	"H-4-3"	"9.8.2/H-4-3"	"hide mic ui microphone indicator  system apps  interfaces  direct user interaction"	"""[9.8.2/H-4-3] MUST not hide the microphone indicator for system apps that have visible user interfaces or direct user interaction. """	""	"com.android.cts.signedconfig.SignedConfigHostTest"	"testBadBase64Signature"	"CtsSignedConfigHostTestCases"	"1: system system"	"public void testBadBase64Signature() throws Exception {
        installPackage(TEST_APP_APK_NAME_V1_BAD_B64_SIGNATURE);
        waitForDevice(5);
        // This test is really testing that the system server doesn't crash, but
        // this check should still do the trick.
        assertThat(getDevice().getSetting(""global"", SETTING_SIGNED_CONFIG_VERSION))
                .isEqualTo(""null"");
    }"	"/home/gpoor/cts-12-source/cts/hostsidetests/signedconfig/hostside/src/com/android/cts/signedconfig/SignedConfigHostTest.java"	""	""	""
