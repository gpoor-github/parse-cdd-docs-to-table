"Section"	"section_id"	"req_id"	"Test Availability"	"class_def"	"method"	"module"	"method_text"	"full_key"	"requirement"	"key_as_number"	"search_terms"	"manual_search_terms"	"not_search_terms"	"not_files"	"matched_terms"	"search_roots"	"qualified_method"	"max_matches"	"file_name"	"matched_files"	"methods_string"	"urls"	"protected"	"Area"	"Shortened"	"Test Level"
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-2"	""	"android.hardware.cts.SensorTest"	"testSensorOperations"	"CtsSensorTestCases"	""	"7.3.13/C-1-2"	"""C-1-2] MUST support at least two readings between 0 and 360 degrees (inclusive i.e including 0 and 360 degrees). """	""	"360 readings between degrees"	""	""	""	"360"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testSensorOperations() {         // Because we can't know every sensors unit details, so we can't assert         // get values with specified values.         Sensor sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);         boolean hasAccelerometer = getContext().getPackageManager().hasSystemFeature(                 PackageManager.FEATURE_SENSOR_ACCELEROMETER);         // accelerometer sensor is optional         if (hasAccelerometer) {             assertEquals(Sensor.TYPE_ACCELEROMETER, sensor.getType());             assertSensorValues(sensor);         } else {             assertNull(sensor);         }          sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_STEP_COUNTER);         boolean hasStepCounter = getContext().getPackageManager().hasSystemFeature(                 PackageManager.FEATURE_SENSOR_STEP_COUNTER);         // stepcounter sensor is optional         if (hasStepCounter) {             assertEquals(Sensor.TYPE_STEP_COUNTER, sensor.getType());             assertSensorValues(sensor);         } else {             assertNull(sensor);         }          sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_STEP_DETECTOR);         boolean hasStepDetector = getContext().getPackageManager().hasSystemFeature(                 PackageManager.FEATURE_SENSOR_STEP_DETECTOR);         // stepdetector sensor is optional         if (hasStepDetector) {             assertEquals(Sensor.TYPE_STEP_DETECTOR, sensor.getType());             assertSensorValues(sensor);         } else {             assertNull(sensor);         }          sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);         boolean hasCompass = getContext().getPackageManager().hasSystemFeature(                 PackageManager.FEATURE_SENSOR_COMPASS);         // compass sensor is optional         if (hasCompass) {             assertEquals(Sensor.TYPE_MAGNETIC_FIELD, sensor.getType());             assertSensorValues(sensor);         } else {             assertNull(sensor);         }          sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE);         boolean hasGyroscope = getContext().getPackageManager().hasSystemFeature(                 PackageManager.FEATURE_SENSOR_GYROSCOPE);         // gyroscope sensor is optional         if (hasGyroscope) {             assertEquals(Sensor.TYPE_GYROSCOPE, sensor.getType());             assertSensorValues(sensor);         } else {             assertNull(sensor);         }          sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_PRESSURE);         boolean hasPressure = getContext().getPackageManager().hasSystemFeature(                 PackageManager.FEATURE_SENSOR_BAROMETER);         // pressure sensor is optional         if (hasPressure) {             assertEquals(Sensor.TYPE_PRESSURE, sensor.getType());             assertSensorValues(sensor);         } else {             assertNull(sensor);         }          sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ORIENTATION);         // Note: orientation sensor is deprecated.         if (sensor != null) {             assertEquals(Sensor.TYPE_ORIENTATION, sensor.getType());             assertSensorValues(sensor);         }          sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_TEMPERATURE);         // temperature sensor is optional         if (sensor != null) {             assertEquals(Sensor.TYPE_TEMPERATURE, sensor.getType());             assertSensorValues(sensor);         }          sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_HINGE_ANGLE);         boolean hasHingeAngle = getContext().getPackageManager().hasSystemFeature(                 PackageManager.FEATURE_SENSOR_HINGE_ANGLE);          if (hasHingeAngle) {             assertEquals(Sensor.TYPE_HINGE_ANGLE, sensor.getType());             assertSensorValues(sensor);             assertTrue(""Max range must not be larger than 360. Range="" + sensor.getMaximumRange()                 + "" "" + sensor.getName(), sensor.getMaximumRange() <= 360);         } else {             assertNull(sensor);         }     }      @AppModeFull(reason = ""Instant apps cannot access body sensors"")"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-2"	""	"android.hardware.cts.helpers.sensorverification.TimestampClockSourceVerificationTest"	"uptimeMillis"	"CtsSensorTestCases"	""	"7.3.13/C-1-2"	"""C-1-2] MUST support at least two readings between 0 and 360 degrees (inclusive i.e including 0 and 360 degrees). """	""	"360 readings between degrees"	""	""	""	"between"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/helpers/sensorverification/TimestampClockSourceVerificationTest.java"	""	"public void test/*  *.  */  package android.hardware.cts.helpers.sensorverification;  import junit.framework.TestCase;  import android.hardware.cts.helpers.SensorStats; import android.hardware.cts.helpers.TestSensorEnvironment; import android.hardware.cts.helpers.TestSensorEvent; import android.os.SystemClock;  import java.util.ArrayList; import java.util.Collection;  import android.util.Log;  /**  * Tests for {@link TimestampClockSourceVerification}.  */ public class TimestampClockSourceVerificationTest extends TestCase {     private final String TAG = ""TimestampClockSourceVerificationTest"";      private final int MIN_DELTA_BETWEEN_CLOCKS_MS = 2000;     private boolean mAdjustUptime = false;      private long getValidTimestamp() {         return SystemClock.elapsedRealtimeNanos();     }      private long getInvalidTimestamp() {         long ms = SystemClock.uptimeMillis();         if (mAdjustUptime == true) {             ms -= MIN_DELTA_BETWEEN_CLOCKS_MS;         }         return (ms * 1000000);     }      private void verifyClockDelta() throws Throwable {         long uptimeMs = SystemClock.uptimeMillis();         long realtimeNs = SystemClock.elapsedRealtimeNanos();         long deltaMs = (realtimeNs/1000000 - uptimeMs);         if (deltaMs < MIN_DELTA_BETWEEN_CLOCKS_MS) {             Log.i(TAG, ""Device has not slept, will use different clock source for test purposes"");             mAdjustUptime = true;         } else {             mAdjustUptime = false;             Log.i(TAG, ""CLOCK_MONOTONIC=""+uptimeMs*1000000+"", CLOCK_BOOTTIME=""+realtimeNs+"", delta="" + deltaMs + "" mS"");         }     }       /**      * Test that the verification passes when there are not missing events.      */"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-2"	""	"android.hardware.cts.helpers.sensorverification.TimestampClockSourceVerificationTest"	"testVerify_pass"	"CtsSensorTestCases"	""	"7.3.13/C-1-2"	"""C-1-2] MUST support at least two readings between 0 and 360 degrees (inclusive i.e including 0 and 360 degrees). """	""	"360 readings between degrees"	""	""	""	"between"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/helpers/sensorverification/TimestampClockSourceVerificationTest.java"	""	"public void testVerify_pass() throws Throwable {         try {             verifyClockDelta();             long ts = getValidTimestamp();             long[] timestamps = {ts-4000000, ts-3000000, ts-2000000, ts-1000000, ts};             // Timestamps in ns, expected in us             runVerification(MIN_DELTA_BETWEEN_CLOCKS_MS*1000, timestamps, true, new int[]{});         } finally {         }     }      /**      * Test that the verification fails when there are not missing events,      * but wrong clock source is used.      */"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-2"	""	"android.hardware.cts.helpers.sensorverification.TimestampClockSourceVerificationTest"	"testVerify_fail"	"CtsSensorTestCases"	""	"7.3.13/C-1-2"	"""C-1-2] MUST support at least two readings between 0 and 360 degrees (inclusive i.e including 0 and 360 degrees). """	""	"360 readings between degrees"	""	""	""	"between"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/helpers/sensorverification/TimestampClockSourceVerificationTest.java"	""	"public void testVerify_fail() throws Throwable {         try {             verifyClockDelta();             long ts = getInvalidTimestamp();             long[] timestamps = {ts-4000000, ts-3000000, ts-2000000, ts-1000000, ts};             // Timestamps in ns, expected in us             runVerification(MIN_DELTA_BETWEEN_CLOCKS_MS*1000, timestamps, false, new int[]{0,1,2,3,4});         } finally {         }     }      /**      * Test that the verification passes when there are not missing events but some jitter.      */"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-2"	""	"android.hardware.cts.helpers.sensorverification.TimestampClockSourceVerificationTest"	"testVerify_jitter_pass"	"CtsSensorTestCases"	""	"7.3.13/C-1-2"	"""C-1-2] MUST support at least two readings between 0 and 360 degrees (inclusive i.e including 0 and 360 degrees). """	""	"360 readings between degrees"	""	""	""	"between"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/helpers/sensorverification/TimestampClockSourceVerificationTest.java"	""	"public void testVerify_jitter_pass() throws Throwable {         try {             verifyClockDelta();             long ts = getValidTimestamp();             long[] timestamps = {ts-3900000, ts-2950000, ts-2050000, ts-1000000, ts-50000};             // Timestamps in ns, expected in us             runVerification(MIN_DELTA_BETWEEN_CLOCKS_MS*1000, timestamps, true, new int[]{});         } finally {         }     }      /**      * Test that the verification passes when there are not missing events but some jitter.      */"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-2"	""	"android.hardware.cts.helpers.sensorverification.TimestampClockSourceVerificationTest"	"testVerify_jitter_fail"	"CtsSensorTestCases"	""	"7.3.13/C-1-2"	"""C-1-2] MUST support at least two readings between 0 and 360 degrees (inclusive i.e including 0 and 360 degrees). """	""	"360 readings between degrees"	""	""	""	"between"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/helpers/sensorverification/TimestampClockSourceVerificationTest.java"	""	"public void testVerify_jitter_fail() throws Throwable {         try {             verifyClockDelta();             long ts = getInvalidTimestamp();             long[] timestamps = {ts-3900000, ts-2950000, ts-2050000, ts-1000000, ts-50000};             // Timestamps in ns, expected in us             runVerification(MIN_DELTA_BETWEEN_CLOCKS_MS*1000, timestamps, false, new int[]{0,1,2,3,4});         } finally {         }     }      /**      * Test that the verification does not fail when there are missing events.      */"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-2"	""	"android.hardware.cts.helpers.sensorverification.TimestampClockSourceVerificationTest"	"testVerify_missing_events_pass"	"CtsSensorTestCases"	""	"7.3.13/C-1-2"	"""C-1-2] MUST support at least two readings between 0 and 360 degrees (inclusive i.e including 0 and 360 degrees). """	""	"360 readings between degrees"	""	""	""	"between"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/helpers/sensorverification/TimestampClockSourceVerificationTest.java"	""	"public void testVerify_missing_events_pass() throws Throwable {         try {             verifyClockDelta();             long ts = getValidTimestamp();             long[] timestamps = {ts-4000000, ts-3000000, ts-1000000, ts};             // Timestamps in ns, expected in us             runVerification(MIN_DELTA_BETWEEN_CLOCKS_MS*1000, timestamps, true, new int[]{});         } finally {         }     }      /**      * Test that the verification fails when there are missing events, but wrong      * timestamp      */"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-2"	""	"android.hardware.cts.helpers.sensorverification.TimestampClockSourceVerificationTest"	"testVerify_missing_events_fail"	"CtsSensorTestCases"	""	"7.3.13/C-1-2"	"""C-1-2] MUST support at least two readings between 0 and 360 degrees (inclusive i.e including 0 and 360 degrees). """	""	"360 readings between degrees"	""	""	""	"between"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/helpers/sensorverification/TimestampClockSourceVerificationTest.java"	""	"public void testVerify_missing_events_fail() throws Throwable {         try {             verifyClockDelta();             long ts = getInvalidTimestamp();             long[] timestamps = {ts-4000000, ts-3000000, ts-1000000, ts};             // Timestamps in ns, expected in us             runVerification(MIN_DELTA_BETWEEN_CLOCKS_MS*1000, timestamps, false, new int[]{0,1,2,3});         } finally {         }     }      /**      * Test that the verification fails when there are no results.      */"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-2"	""	"android.hardware.cts.helpers.sensorverification.TimestampClockSourceVerificationTest"	"testVerify_no_events_fail"	"CtsSensorTestCases"	""	"7.3.13/C-1-2"	"""C-1-2] MUST support at least two readings between 0 and 360 degrees (inclusive i.e including 0 and 360 degrees). """	""	"360 readings between degrees"	""	""	""	"between"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/helpers/sensorverification/TimestampClockSourceVerificationTest.java"	""	"public void testVerify_no_events_fail() throws Throwable {         try {             verifyClockDelta();             // Timestamps in ns, expected in us             runVerification(MIN_DELTA_BETWEEN_CLOCKS_MS*1000, new long[]{}, false, new int[]{});         } finally {         }     }      private void runVerification(int expectedUs, long[] timestamps, boolean pass,             int[] indices) {         SensorStats stats = new SensorStats();         ISensorVerification verification = getVerification(expectedUs, timestamps);         TestSensorEnvironment environment = new TestSensorEnvironment(null, null, false, 0, 0);         if (pass) {             verification.verify(environment, stats);         } else {             boolean failed = false;             try {                 verification.verify(environment, stats);             } catch (AssertionError e) {                 // Expected;                 failed = true;             }             assertTrue(""Expected an AssertionError"", failed);         }          assertEquals(pass, stats.getValue(TimestampClockSourceVerification.PASSED_KEY));         assertEquals(indices.length, stats.getValue(SensorStats.EVENT_TIME_WRONG_CLOCKSOURCE_COUNT_KEY));         if (0 != (Integer) stats.getValue(SensorStats.EVENT_TIME_WRONG_CLOCKSOURCE_COUNT_KEY)) {             assertNotNull(stats.getValue(SensorStats.EVENT_TIME_WRONG_CLOCKSOURCE_POSITIONS_KEY));         }         try {             int[] actualIndices = (int[]) stats.getValue(SensorStats.EVENT_TIME_WRONG_CLOCKSOURCE_POSITIONS_KEY);             assertEquals(indices.length, actualIndices.length);              for (int i = 0; i < indices.length; i++) {                 assertEquals(indices[i], actualIndices[i]);             }         } catch (Exception t) {         }     }      private static TimestampClockSourceVerification getVerification(int expectedUs, long ... timestamps) {         Collection<TestSensorEvent> events = new ArrayList<>(timestamps.length);         long expectedNs = expectedUs * 1000;         long now = SystemClock.elapsedRealtimeNanos();         long receiveTime;         for (long timestamp : timestamps) {             //receiveTime = now - (expectedNs * count);             receiveTime = SystemClock.elapsedRealtimeNanos();             events.add(new TestSensorEvent(null, timestamp, receiveTime, 0, null));         }         TimestampClockSourceVerification verification = new TimestampClockSourceVerification(expectedUs);         verification.addSensorEvents(events);         return verification;     } }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-2"	""	"android.hardware.cts.SensorDirectReportTest"	"testCloseWithoutConfigStop"	"CtsSensorTestCases"	""	"7.3.13/C-1-2"	"""C-1-2] MUST support at least two readings between 0 and 360 degrees (inclusive i.e including 0 and 360 degrees). """	""	"360 readings between degrees"	""	""	""	"between"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testCloseWithoutConfigStop() {         for (int type : POSSIBLE_SENSOR_TYPES) {             for (int memType : POSSIBLE_CHANNEL_TYPES) {                 Sensor s = mSensorManager.getDefaultSensor(type);                 if (s == null                         || s.getHighestDirectReportRateLevel() == SensorDirectChannel.RATE_STOP                         || !s.isDirectChannelTypeSupported(memType)) {                     continue;                 }                  mChannel = prepareDirectChannel(memType, false /* secondary */);                 assertTrue(""createDirectChannel failed"", mChannel != null);                  try {                     waitBeforeStartSensor();                     mChannel.configure(s, s.getHighestDirectReportRateLevel());                      // wait for a while                     waitBeforeStartSensor();                      // The following line is commented out intentionally.                     // mChannel.configure(s, SensorDirectChannel.RATE_STOP);                 } finally {                     mChannel.close();                     mChannel = null;                 }                 waitBeforeStartSensor();             }         }     }      private void runSingleChannelRateIndependencyTestGroup(int type1, int type2) {         if (type1 == type2) {             throw new IllegalArgumentException(""Cannot run single channel rate independency test ""                     + ""on type "" + type1 + "" and "" + type2);         }         String stype1 = SensorCtsHelper.sensorTypeShortString(type1);         String stype2 = SensorCtsHelper.sensorTypeShortString(type2);          TestResultCollector c =                 new TestResultCollector(                     ""testRateIndependency"" + stype1 + stype2 + ""SingleChannel"", TAG);          for (int rate1 : POSSIBLE_RATE_LEVELS) {             for (int rate2 : POSSIBLE_RATE_LEVELS) {                 for (int memType : POSSIBLE_CHANNEL_TYPES) {                     c.perform(                         () -> {                             runSingleChannelRateIndependencyTest(                                     type1, rate1, type2, rate2,                                     SensorDirectChannel.TYPE_MEMORY_FILE);                         },                         String.format(""(%s rate %d, %s rate %d, mem %d)"",                                       stype1, rate1, stype2, rate2, memType));                 }             }         }         c.judge();     }      public void runMultiChannelRateIndependencyTestGroup(int sensorType) {         TestResultCollector c = new TestResultCollector(                 ""testRateIndependency"" + SensorCtsHelper.sensorTypeShortString(sensorType)                     + ""MultiChannel"", TAG);          for (int rate1 : POSSIBLE_RATE_LEVELS) {             for (int rate2 : POSSIBLE_RATE_LEVELS) {                 for (int type1 : POSSIBLE_CHANNEL_TYPES) {                     for (int type2 : POSSIBLE_CHANNEL_TYPES) {                         // only test upper triangle                         if (rate1 > rate2 || type1 > type2) {                             continue;                         }                         c.perform(() -> {                                 runMultiChannelRateIndependencyTest(                                         sensorType, rate1, rate2, type1, type2);},                                 String.format(""rate1 %d, rate2 %d, type1 %d, type2 %d"",                                               rate1, rate2, type1, type2));                     }                 }             }         }         c.judge();     }      public void runMultiModeRateIndependencyTestGroup(int sensorType) {         TestResultCollector c = new TestResultCollector(                 ""testRateIndependency"" + SensorCtsHelper.sensorTypeShortString(sensorType)                     + ""MultiMode"", TAG);          for (int rate : POSSIBLE_RATE_LEVELS) {             for (int type : POSSIBLE_CHANNEL_TYPES) {                 for (int samplingPeriodUs : POSSIBLE_SAMPLE_PERIOD_US) {                     c.perform(() -> {runMultiModeRateIndependencyTest(                                         sensorType, rate, type, samplingPeriodUs);},                               String.format(""rateLevel %d, memType %d, period %d"",                                             rate, type, samplingPeriodUs));                 }             }         }         c.judge();     }      private void runTimestampTestGroup(int sensorType) {         String stype = SensorCtsHelper.sensorTypeShortString(sensorType);          TestResultCollector c =                 new TestResultCollector(""testTimestamp"" + stype, TAG);          for (int rateLevel : POSSIBLE_RATE_LEVELS) {             for (int memType : POSSIBLE_CHANNEL_TYPES) {                 c.perform(                         () -> {                             runTimestampTest(sensorType, rateLevel, memType);                         },                         String.format(""(%s, rate %d, memtype %d)"", stype, rateLevel, memType));             }         }         c.judge();     }      private void runSensorDirectReportTest(int sensorType, int memType, int rateLevel)             throws AssertionError {         Sensor s = mSensorManager.getDefaultSensor(sensorType);         if (s == null                 || s.getHighestDirectReportRateLevel() < rateLevel                 || !s.isDirectChannelTypeSupported(memType)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);          try {             assertTrue(""Shared memory is not formatted"", isSharedMemoryFormatted(memType));             waitBeforeStartSensor();              int token = mChannel.configure(s, rateLevel);             assertTrue(""configure direct mChannel failed"", token > 0);              waitSensorCollection();              //stop sensor and analyze content             mChannel.configure(s, SensorDirectChannel.RATE_STOP);             checkSharedMemoryContent(s, memType, rateLevel, token);         } finally {             mChannel.close();             mChannel = null;         }     }      private void runSensorDirectReportUidIdleTest(int sensorType, int memType, int rateLevel) {         Sensor s = mSensorManager.getDefaultSensor(sensorType);         if (s == null                 || s.getHighestDirectReportRateLevel() < rateLevel                 || !s.isDirectChannelTypeSupported(memType)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);          try {             assertTrue(""Shared memory is not formatted"", isSharedMemoryFormatted(memType));             waitBeforeStartSensor();              int token = mChannel.configure(s, rateLevel);             assertTrue(""configure direct mChannel failed"", token > 0);              // Make package idle and ensure no sensor events are received             try {                 SensorCtsHelper.makeMyPackageIdle();             } catch (IOException e) {                 fail(""IOException while making package idle"");             }              int originalEventSize = mBuffer.length;             waitSensorCollection();              assertEquals(mBuffer.length, originalEventSize);              try {                 SensorCtsHelper.makeMyPackageActive();             } catch (IOException e) {                 fail(""IOException while making package active"");             }              // Also verify sensor events can be received after becoming active.             resetEvent();              waitSensorCollection();              //stop sensor and analyze content             mChannel.configure(s, SensorDirectChannel.RATE_STOP);             checkSharedMemoryContent(s, memType, rateLevel, token);         } finally {             mChannel.close();             mChannel = null;         }     }      private void runSingleChannelRateIndependencyTest(             int type1, int rateLevel1, int type2, int rateLevel2, int memType)                 throws AssertionError {         Sensor s1 = mSensorManager.getDefaultSensor(type1);         Sensor s2 = mSensorManager.getDefaultSensor(type2);         if (s1 == null                 || s1.getHighestDirectReportRateLevel() < rateLevel1                 || !s1.isDirectChannelTypeSupported(memType)) {             return;         }          if (s2 == null                 || s2.getHighestDirectReportRateLevel() < rateLevel2                 || !s2.isDirectChannelTypeSupported(memType)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);          try {             assertTrue(""Shared memory is not formatted"", isSharedMemoryFormatted(memType));             waitBeforeStartSensor();              int token1 = mChannel.configure(s1, rateLevel1);             int token2 = mChannel.configure(s2, rateLevel2);             assertTrue(""configure direct mChannel failed, token1 = "" + token1, token1 > 0);             assertTrue(""configure direct mChannel failed, token2 = "" + token2, token2 > 0);              // run half amount of time so buffer is enough for both sensors             try {                 SensorCtsHelper.sleep(TEST_RUN_TIME_PERIOD_MILLISEC / 2, TimeUnit.MILLISECONDS);             } catch (InterruptedException e) {                 Thread.currentThread().interrupt();             }              //stop sensor and analyze content             mChannel.configure(s1, SensorDirectChannel.RATE_STOP);             mChannel.configure(s2, SensorDirectChannel.RATE_STOP);              readSharedMemory(memType, false /*secondary*/);             checkEventRate(TEST_RUN_TIME_PERIOD_MILLISEC / 2, parseEntireBuffer(mBuffer, token1),                            type1, rateLevel1);             checkEventRate(TEST_RUN_TIME_PERIOD_MILLISEC / 2, parseEntireBuffer(mBuffer, token2),                            type2, rateLevel2);         } finally {             mChannel.close();             mChannel = null;         }     }      private void runMultiChannelRateIndependencyTest(             int type, int rateLevel1, int rateLevel2, int memType1, int memType2)                 throws AssertionError {         Sensor s = mSensorManager.getDefaultSensor(type);         if (s == null                 || s.getHighestDirectReportRateLevel() < Math.max(rateLevel1, rateLevel2)                 || !s.isDirectChannelTypeSupported(memType1)                 || !s.isDirectChannelTypeSupported(memType2)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType1, false /* secondary */);         mChannelSecondary = prepareDirectChannel(memType2, true /* secondary */);          try {             assertTrue(""createDirectChannel failed"", mChannel != null);             assertTrue(""Shared memory is not formatted"",                        isSharedMemoryFormatted(memType1));              assertTrue(""createDirectChannel(secondary) failed"", mChannelSecondary != null);             assertTrue(""Shared memory(secondary) is not formatted"",                        isSharedMemoryFormatted(memType2, true));              waitBeforeStartSensor();              int token1 = mChannel.configure(s, rateLevel1);             int token2 = mChannelSecondary.configure(s, rateLevel2);             assertTrue(""configure direct mChannel failed"", token1 > 0);             assertTrue(""configure direct mChannelSecondary failed"", token2 > 0);              waitSensorCollection();              //stop sensor and analyze content             mChannel.configure(s, SensorDirectChannel.RATE_STOP);             mChannelSecondary.configure(s, SensorDirectChannel.RATE_STOP);              // check rate             readSharedMemory(memType1, false /*secondary*/);             checkEventRate(TEST_RUN_TIME_PERIOD_MILLISEC, parseEntireBuffer(mBuffer, token1),                            type, rateLevel1);              readSharedMemory(memType2, true /*secondary*/);             checkEventRate(TEST_RUN_TIME_PERIOD_MILLISEC, parseEntireBuffer(mBuffer, token2),                            type, rateLevel2);         } finally {             if (mChannel != null) {                 mChannel.close();                 mChannel = null;             }             if (mChannelSecondary != null) {                 mChannelSecondary.close();                 mChannelSecondary = null;             }         }     }      private void runMultiModeRateIndependencyTest(             int type , int rateLevel, int memType, int samplingPeriodUs)                 throws AssertionError {         final Sensor s = mSensorManager.getDefaultSensor(type);         if (s == null                 || s.getHighestDirectReportRateLevel() < rateLevel                 || !s.isDirectChannelTypeSupported(memType)) {             return;         }          if (samplingPeriodUs == 0) {             samplingPeriodUs = s.getMinDelay();         }          if (samplingPeriodUs < s.getMinDelay()) {             return;         }          if (samplingPeriodUs > s.getMaxDelay()) {             samplingPeriodUs = s.getMaxDelay();         }          resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);         SensorEventCollection listener = new SensorEventCollection(s);          try {             waitBeforeStartSensor();             int token = mChannel.configure(s, rateLevel);             boolean registerRet = mSensorManager.registerListener(listener, s, samplingPeriodUs);             assertTrue(""Register listener failed"", registerRet);              waitSensorCollection();              mChannel.configure(s, SensorDirectChannel.RATE_STOP);             mSensorManager.unregisterListener(listener);              // check direct report rate             readSharedMemory(memType, false /*secondary*/);             List<DirectReportSensorEvent> events = parseEntireBuffer(mBuffer, token);             checkEventRate(TEST_RUN_TIME_PERIOD_MILLISEC, events, type, rateLevel);              // check callback interface rate             checkEventRateUs(TEST_RUN_TIME_PERIOD_MILLISEC, listener.getEvents(), type,                              samplingPeriodUs);         } finally {             mChannel.close();             mChannel = null;             mSensorManager.unregisterListener(listener);         }     }      private void runTimestampTest(int type, int rateLevel, int memType) {         Sensor s = mSensorManager.getDefaultSensor(type);         if (s == null                 || s.getHighestDirectReportRateLevel() < rateLevel                 || !s.isDirectChannelTypeSupported(memType)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);          SensorEventCollection listener = new SensorEventCollection(s);          try {             float nominalFreq = getNominalFreq(rateLevel);             int samplingPeriodUs = Math.max((int) (1e6f / nominalFreq), s.getMinDelay());              assertTrue(""Shared memory is not formatted"",                        isSharedMemoryFormatted(memType));              int token = mChannel.configure(s, rateLevel);             assertTrue(""configure direct mChannel failed"", token > 0);              boolean registerRet = mSensorManager.registerListener(listener, s, samplingPeriodUs);             assertTrue(""Register listener failed"", registerRet);              List<DirectReportSensorEvent> events = collectSensorEventsRealtime(                     memType, false /*secondary*/, TEST_RUN_TIME_PERIOD_MILLISEC);             assertTrue(""Realtime event collection failed"", events != null);             assertTrue(""Realtime event collection got no data"", events.size() > 0);              //stop sensor and analyze content             mChannel.configure(s, SensorDirectChannel.RATE_STOP);             mSensorManager.unregisterListener(listener);              // check rate             checkTimestampRelative(events, listener.getEvents());             checkTimestampAbsolute(events);         } finally {             mChannel.close();             mChannel = null;         }     }      private void runAtomicCounterTest(int sensorType, int memType) throws AssertionError {         Sensor s = mSensorManager.getDefaultSensor(sensorType);         if (s == null                 || s.getHighestDirectReportRateLevel() == SensorDirectChannel.RATE_STOP                 || !s.isDirectChannelTypeSupported(memType)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);          try {             assertTrue(""Shared memory is not formatted"", isSharedMemoryFormatted(memType));             waitBeforeStartSensor();              //int token = mChannel.configure(s, SensorDirectChannel.RATE_FAST);             int token = mChannel.configure(s, s.getHighestDirectReportRateLevel());             assertTrue(""configure direct mChannel failed"", token > 0);              checkAtomicCounterUpdate(memType, 30 * 1000); // half min              //stop sensor and analyze content             mChannel.configure(s, SensorDirectChannel.RATE_STOP);         } finally {             mChannel.close();             mChannel = null;         }     }      private void runReconfigureTest(int type, int memType) {         Sensor s = mSensorManager.getDefaultSensor(type);         if (s == null                 || s.getHighestDirectReportRateLevel() == SensorDirectChannel.RATE_STOP                 || !s.isDirectChannelTypeSupported(memType)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);          try {             assertTrue(""Shared memory is not formatted"", isSharedMemoryFormatted(memType));             waitBeforeStartSensor();              int offset = 0;             long counter = 1;             List<Integer> rateLevels = new ArrayList<>();             List<DirectReportSensorEvent> events;              rateLevels.add(s.getHighestDirectReportRateLevel());             rateLevels.add(s.getHighestDirectReportRateLevel());             if (s.getHighestDirectReportRateLevel() != SensorDirectChannel.RATE_NORMAL) {                 rateLevels.add(SensorDirectChannel.RATE_NORMAL);             }              for (int rateLevel : rateLevels) {                 int token = mChannel.configure(s, rateLevel);                 assertTrue(""configure direct mChannel failed"", token > 0);                  events = collectSensorEventsRealtime(memType, false /*secondary*/,                                                      TEST_RUN_TIME_PERIOD_MILLISEC,                                                      offset, counter);                 // stop sensor                 mChannel.configure(s, SensorDirectChannel.RATE_STOP);                 checkEventRate(TEST_RUN_TIME_PERIOD_MILLISEC, events, type, rateLevel);                  // collect all events after stop                 events = collectSensorEventsRealtime(memType, false /*secondary*/,                                                      REST_PERIOD_BEFORE_TEST_MILLISEC,                                                      offset, counter);                 if (events.size() > 0) {                     offset += (events.size() * SENSORS_EVENT_SIZE ) % SHARED_MEMORY_SIZE;                     counter = events.get(events.size() - 1).serial;                 }             }              // finally stop the report             mChannel.configure(s, SensorDirectChannel.RATE_STOP);         } finally {             mChannel.close();             mChannel = null;         }     }      private void waitBeforeStartSensor() {         // wait for sensor system to come to a rest after previous test to avoid flakiness.         try {             SensorCtsHelper.sleep(REST_PERIOD_BEFORE_TEST_MILLISEC, TimeUnit.MILLISECONDS);         } catch (InterruptedException e) {             Thread.currentThread().interrupt();         }     }      private void waitSensorCollection() {         // wait for sensor collection to finish         try {             SensorCtsHelper.sleep(TEST_RUN_TIME_PERIOD_MILLISEC, TimeUnit.MILLISECONDS);         } catch (InterruptedException e) {             Thread.currentThread().interrupt();         }     }      private List<DirectReportSensorEvent> collectSensorEventsRealtime(             int memType, boolean secondary, int timeoutMs) {         return collectSensorEventsRealtime(memType, secondary, timeoutMs,                                           0 /*initialOffset*/, 1l /*initialCounter*/);     }      private List<DirectReportSensorEvent> collectSensorEventsRealtime(             int memType, boolean secondary, int timeoutMs, int initialOffset, long initialCounter) {         List<DirectReportSensorEvent> events = new ArrayList<>();         long endTime = SystemClock.elapsedRealtime() + timeoutMs;          long atomicCounter = initialCounter;         int offset = initialOffset;          long timeA = SystemClock.elapsedRealtimeNanos();         boolean synced = false;         int filtered = 0;          while (SystemClock.elapsedRealtime() < endTime) {             if (!readSharedMemory(                     memType, secondary, offset + ATOMIC_COUNTER_OFFSET, ATOMIC_COUNTER_SIZE)) {                 return null;             }              long timeB = SystemClock.elapsedRealtimeNanos();             if (timeB - timeA > 1_000_000L ) { // > 1ms                 synced = false;             }             timeA = timeB;              if (readAtomicCounter(offset) == atomicCounter) {                 // read entire event again and parse                 if (!readSharedMemory(memType, secondary, offset, SENSORS_EVENT_SIZE)) {                     return null;                 }                 DirectReportSensorEvent e = mEventPool.get();                 assertNotNull(""cannot get event from reserve"", e);                 parseSensorEvent(offset, e);                  atomicCounter += 1;                 if (synced) {                     events.add(e);                 } else {                     ++filtered;                 }                  offset += SENSORS_EVENT_SIZE;                 if (offset + SENSORS_EVENT_SIZE > SHARED_MEMORY_SIZE) {                     offset = 0;                 }             } else {                 synced = true;             }         }         Log.d(TAG, ""filtered "" + filtered + "" events, remain "" + events.size() + "" events"");         return events;     }      private void checkAtomicCounterUpdate(int memType, int timeoutMs) {         List<DirectReportSensorEvent> events = new ArrayList<>();         long endTime = SystemClock.elapsedRealtime() + timeoutMs;          boolean lastValid = false;         long atomicCounter = 1;         int lastOffset = 0;         int offset = 0;          byte[] lastArray = new byte[SENSORS_EVENT_SIZE];         DirectReportSensorEvent e = getEvent();          while (SystemClock.elapsedRealtime() < endTime) {             if (!readSharedMemory(memType, false/*secondary*/, lastOffset, SENSORS_EVENT_SIZE)                     || !readSharedMemory(memType, false/*secondary*/,                                          offset + ATOMIC_COUNTER_OFFSET, ATOMIC_COUNTER_SIZE)) {                 throw new IllegalStateException(""cannot read shared memory, type "" + memType);             }              if (lastValid) {                 boolean failed = false;                 int i;                 for (i = 0; i < SENSORS_EVENT_SIZE; ++i) {                     if (lastArray[i] != mBuffer[lastOffset + i]) {                         failed = true;                         break;                     }                 }                  if (failed) {                     byte[] currentArray = new byte[SENSORS_EVENT_SIZE];                     System.arraycopy(mBuffer, lastOffset, currentArray, 0, SENSORS_EVENT_SIZE);                      // wait for 100ms and read again to see if the change settle                     try {                         SensorCtsHelper.sleep(100, TimeUnit.MILLISECONDS);                     } catch (InterruptedException ex) {                         Thread.currentThread().interrupt();                     }                      byte[] delayedRead = new byte[SENSORS_EVENT_SIZE];                     if (!readSharedMemory(                                 memType, false/*secondary*/, lastOffset, SENSORS_EVENT_SIZE)) {                         throw new IllegalStateException(                                 ""cannot read shared memory, type "" + memType);                     }                     System.arraycopy(mBuffer, lastOffset, delayedRead, 0, SENSORS_EVENT_SIZE);                      fail(String.format(                             ""At offset %d(0x%x), byte %d(0x%x) changed after atomicCounter""                                 + ""(expecting %d, 0x%x) update, old = [%s], new = [%s], ""                                 + ""delayed = [%s]"",                             lastOffset, lastOffset, i, i, atomicCounter, atomicCounter,                             SensorCtsHelper.bytesToHex(lastArray, -1, -1),                             SensorCtsHelper.bytesToHex(currentArray, -1, -1),                             SensorCtsHelper.bytesToHex(delayedRead, -1, -1)));                 }             }              if (readAtomicCounter(offset) == atomicCounter) {                 // read entire event again and parse                 if (!readSharedMemory(memType, false/*secondary*/, offset, SENSORS_EVENT_SIZE)) {                     throw new IllegalStateException(""cannot read shared memory, type "" + memType);                 }                 parseSensorEvent(offset, e);                  atomicCounter += 1;                  lastOffset = offset;                 System.arraycopy(mBuffer, lastOffset, lastArray, 0, SENSORS_EVENT_SIZE);                 lastValid = true;                  offset += SENSORS_EVENT_SIZE;                 if (offset + SENSORS_EVENT_SIZE > SHARED_MEMORY_SIZE) {                     offset = 0;                 }             }         }         Log.d(TAG, ""at finish checkAtomicCounterUpdate has atomic counter = "" + atomicCounter);         // atomicCounter will not wrap back in reasonable amount of time         assertTrue(""Realtime event collection got no data"", atomicCounter != 1);     }      private MemoryFile allocateMemoryFile() {         MemoryFile memFile = null;         try {             memFile = new MemoryFile(""Sensor Channel"", SHARED_MEMORY_SIZE);         } catch (IOException e) {             Log.e(TAG, ""IOException when allocating MemoryFile"");         }         return memFile;     }      private HardwareBuffer allocateHardwareBuffer() {         HardwareBuffer hardwareBuffer;          hardwareBuffer = HardwareBuffer.create(                 SHARED_MEMORY_SIZE, 1 /* height */, HardwareBuffer.BLOB, 1 /* layer */,                 HardwareBuffer.USAGE_CPU_READ_OFTEN | HardwareBuffer.USAGE_GPU_DATA_BUFFER                     | HardwareBuffer.USAGE_SENSOR_DIRECT_DATA);         return hardwareBuffer;     }      private SensorDirectChannel prepareDirectChannel(int memType, boolean secondary) {         SensorDirectChannel channel = null;          try {             switch(memType) {                 case SensorDirectChannel.TYPE_MEMORY_FILE: {                     MemoryFile memoryFile = secondary ? mMemoryFileSecondary : mMemoryFile;                     assertTrue(""MemoryFile"" + (secondary ? ""(secondary)"" : """") + "" is null"",                                memoryFile != null);                     channel = mSensorManager.createDirectChannel(memoryFile);                     break;                 }                 case SensorDirectChannel.TYPE_HARDWARE_BUFFER: {                     HardwareBuffer hardwareBuffer                             = secondary ? mHardwareBufferSecondary : mHardwareBuffer;                     assertTrue(""HardwareBuffer"" + (secondary ? ""(secondary)"" : """") + "" is null"",                                hardwareBuffer != null);                     channel = mSensorManager.createDirectChannel(hardwareBuffer);                     break;                 }                 default:                     Log.e(TAG, ""Specified illegal memory type "" + memType);             }         } catch (IllegalStateException | UncheckedIOException e) {             Log.e(TAG, ""Cannot initialize channel for memory type "" + memType                     + "", details:"" + e);             channel = null;         }         return channel;     }      private boolean readSharedMemory(int memType, boolean secondary, int offset, int length) {         switch(memType) {             case SensorDirectChannel.TYPE_MEMORY_FILE:                 try {                     MemoryFile f = secondary ? mMemoryFileSecondary : mMemoryFile;                     if (f.readBytes(mBuffer, offset, offset, length) != length) {                         Log.e(TAG, ""cannot read entire MemoryFile"");                         return false;                     }                 } catch (IOException e) {                     Log.e(TAG, ""accessing MemoryFile causes IOException"");                     return false;                 }                 return true;             case SensorDirectChannel.TYPE_HARDWARE_BUFFER:                 return nativeReadHardwareBuffer(                         secondary ? mHardwareBufferSecondary : mHardwareBuffer,                         mBuffer, offset, offset, length);             default:                 return false;         }     }      private boolean readSharedMemory(int memType, boolean secondary) {         return readSharedMemory(memType, secondary, 0, SHARED_MEMORY_SIZE);     }      private boolean readSharedMemory(int memType) {         return readSharedMemory(memType, false /*secondary*/);     }      private boolean isMemoryTypeNeeded(int memType) {         List<Sensor> sensorList = mSensorManager.getSensorList(Sensor.TYPE_ALL);         for (Sensor s : sensorList) {             if (s.isDirectChannelTypeSupported(memType)) {                 return true;             }         }         return false;     }      private boolean isSharedMemoryFormatted(int memType) {         return isSharedMemoryFormatted(memType, false /* secondary */);     }      private boolean isSharedMemoryFormatted(int memType, boolean secondary) {         readSharedMemory(memType, secondary);          for (byte b : mBuffer) {             if (b != 0) {                 return false;             }         }         return true;     }      private void checkSharedMemoryContent(Sensor s, int memType, int rateLevel, int token) {         assertTrue(""read mem type "" + memType + "" content failed"", readSharedMemory(memType));          int offset = 0;         int nextSerial = 1;         DirectReportSensorEvent e = getEvent();         while (offset <= SHARED_MEMORY_SIZE - SENSORS_EVENT_SIZE) {             parseSensorEvent(offset, e);              if (e.serial == 0) {                 // reaches end of events                 break;             }              assertTrue(""incorrect size "" + e.size + ""  at offset "" + offset,                     e.size == SENSORS_EVENT_SIZE);             assertTrue(""incorrect token "" + e.token + "" at offset "" + offset,                     e.token == token);             assertTrue(""incorrect serial "" + e.serial + "" at offset "" + offset,                     e.serial == nextSerial);             assertTrue(""incorrect type "" + e.type + "" offset "" + offset,                     e.type == s.getType());              switch(s.getType()) {                 case Sensor.TYPE_ACCELEROMETER:                     double accNorm = Math.sqrt(e.x * e.x + e.y * e.y + e.z * e.z);                     assertTrue(""incorrect gravity norm "" + accNorm + "" at offset "" + offset,                             accNorm < GRAVITY_MAX && accNorm > GRAVITY_MIN);                     break;                 case Sensor.TYPE_GYROSCOPE:                     double gyroNorm = Math.sqrt(e.x * e.x + e.y * e.y + e.z * e.z);                     assertTrue(""gyro norm too large ("" + gyroNorm + "") at offset "" + offset,                             gyroNorm < GYRO_NORM_MAX);                     break;             }              ++nextSerial;             offset += SENSORS_EVENT_SIZE;         }          int nEvents = nextSerial - 1;         float nominalFreq = 0;          switch (rateLevel) {             case SensorDirectChannel.RATE_NORMAL:                 nominalFreq = RATE_NORMAL_NOMINAL;                 break;             case SensorDirectChannel.RATE_FAST:                 nominalFreq = RATE_FAST_NOMINAL;                 break;             case SensorDirectChannel.RATE_VERY_FAST:                 nominalFreq = RATE_VERY_FAST_NOMINAL;                 break;         }          if (nominalFreq != 0) {             int minEvents;             int maxEvents;             minEvents = (int) Math.floor(                     nominalFreq                     * FREQ_LOWER_BOUND                     * (TEST_RUN_TIME_PERIOD_MILLISEC - ALLOWED_SENSOR_INIT_TIME_MILLISEC)                     * (1 - MERCY_FACTOR)                     / 1000);             maxEvents = (int) Math.ceil(                     nominalFreq                     * FREQ_UPPER_BOUND                     * TEST_RUN_TIME_PERIOD_MILLISEC                     * (1 + MERCY_FACTOR)                     / 1000);              assertTrue(""nEvent is "" + nEvents + "" not between "" + minEvents + "" and "" + maxEvents,                     nEvents >= minEvents && nEvents <=maxEvents);         }     }      private void checkEventRate(int testTimeMs, List<DirectReportSensorEvent> events,                                 int type, int rateLevel) {         assertTrue(""insufficient events of type "" + type, events.size() > 1);         for (DirectReportSensorEvent e : events) {             assertTrue(""incorrect type "" + e.type + "" expecting "" + type, e.type == type);         }          // check number of events         int[] minMax = calculateExpectedNEvents(testTimeMs, rateLevel);         assertTrue(                 ""Number of event of type "" + type + "" is "" + events.size()                     + "", which is not in range ["" + minMax[0] + "", "" + minMax[1] + ""]."",                 minMax[0] <= events.size() && events.size() <= minMax[1]);          // intervals         List<Long> intervals = new ArrayList<>(events.size() - 1);         long minInterval = Long.MAX_VALUE;         long maxInterval = Long.MIN_VALUE;         long averageInterval = 0;         for (int i = 1; i < events.size(); ++i) {             long d = events.get(i).ts - events.get(i-1).ts;             averageInterval += d;             minInterval = Math.min(d, minInterval);             maxInterval = Math.max(d, maxInterval);             intervals.add(d);         }         averageInterval /= (events.size() - 1);          // average rate         float averageFreq = 1e9f / averageInterval;         float nominalFreq = getNominalFreq(rateLevel);         Log.d(TAG, String.format(                 ""checkEventRate type %d: averageFreq %f, nominalFreq %f, lbound %f, ubound %f"",                 type, averageFreq, nominalFreq,                 nominalFreq * FREQ_LOWER_BOUND,                 nominalFreq * FREQ_UPPER_BOUND));         assertTrue(""Average frequency of type "" + type + "" rateLevel "" + rateLevel                         + "" is "" + averageFreq,                    nominalFreq * FREQ_LOWER_BOUND * (1 - MERCY_FACTOR) <= averageFreq &&                        averageFreq <= nominalFreq * FREQ_UPPER_BOUND * (1 + MERCY_FACTOR));          // jitter variance         List<Long> percentileValues =                 SensorCtsHelper.getPercentileValue(intervals, 0.025f, (1 - 0.025f));         assertTrue(""Timestamp jitter of type "" + type + "" rateLevel "" + rateLevel + "" is ""                         + (percentileValues.get(1) - percentileValues.get(0) / 1000) + "" us, ""                         + ""while average interval is "" + (averageInterval / 1000) + ""us, over-range"",                    (percentileValues.get(1) - percentileValues.get(0)) / averageInterval < 0.05);         Log.d(TAG, String.format(                 ""checkEventRate type %d, timestamp interval range %f - %f ms, "" +                     ""span %f ms, %.2f%% of averageInterval"",                     type, percentileValues.get(0)/1e6f, percentileValues.get(1)/1e6f,                     (percentileValues.get(1) - percentileValues.get(0))/1e6f,                     (percentileValues.get(1) - percentileValues.get(0)) / averageInterval * 100.f));      }      private void checkEventRateUs(int testTimeMs, List<DirectReportSensorEvent> events,                                   int type, int samplingPeriodUs) {         // samplingPeriodUs must be a valid one advertised by sensor         assertTrue(""insufficient events of type "" + type, events.size() > 1);         for (DirectReportSensorEvent e : events) {             assertTrue(""incorrect type "" + e.type + "" expecting "" + type, e.type == type);         }          // check number of events         int[] minMax = calculateExpectedNEventsUs(testTimeMs, samplingPeriodUs);         assertTrue(                 ""Number of event of type "" + type + "" is "" + events.size()                     + "", which is not in range ["" + minMax[0] + "", "" + minMax[1] + ""]."",                 minMax[0] <= events.size() && events.size() <= minMax[1]);          // intervals         List<Long> intervals = new ArrayList<>(events.size() - 1);         long minInterval = Long.MAX_VALUE;         long maxInterval = Long.MIN_VALUE;         long averageInterval = 0;         for (int i = 1; i < events.size(); ++i) {             long d = events.get(i).ts - events.get(i-1).ts;             averageInterval += d;             minInterval = Math.min(d, minInterval);             maxInterval = Math.max(d, maxInterval);             intervals.add(d);         }         averageInterval /= (events.size() - 1);          // average rate         float averageFreq = 1e9f / averageInterval;         float nominalFreq = 1e6f / samplingPeriodUs;         Log.d(TAG, String.format(                 ""checkEventRateUs type %d: averageFreq %f, nominalFreq %f, lbound %f, ubound %f"",                 type, averageFreq, nominalFreq,                 nominalFreq * FREQ_LOWER_BOUND_POLL,                 nominalFreq * FREQ_UPPER_BOUND_POLL));         assertTrue(""Average frequency of type "" + type                         + "" is "" + averageFreq,                    nominalFreq * FREQ_LOWER_BOUND_POLL * (1 - MERCY_FACTOR) <= averageFreq &&                        averageFreq <= nominalFreq * FREQ_UPPER_BOUND_POLL * (1 + MERCY_FACTOR));          // jitter variance         List<Long> percentileValues =                 SensorCtsHelper.getPercentileValue(intervals, 0.025f, (1 - 0.025f));         assertTrue(""Timestamp jitter of type "" + type + "" is ""                         + (percentileValues.get(1) - percentileValues.get(0) / 1000) + "" us, ""                         + ""while average interval is "" + (averageInterval / 1000) + ""us, over-range"",                    (percentileValues.get(1) - percentileValues.get(0)) / averageInterval < 0.05);         Log.d(TAG, String.format(                 ""checkEventRateUs type %d, timestamp interval range %f - %f ms, "" +                     ""span %f ms, %.2f%% of averageInterval"",                     type, percentileValues.get(0)/1e6f, percentileValues.get(1)/1e6f,                     (percentileValues.get(1) - percentileValues.get(0)) / 1e6f,                     (percentileValues.get(1) - percentileValues.get(0)) / averageInterval * 100.f));     }      private void allocateSharedMemory() {         if (mNeedMemoryFile) {             mMemoryFile = allocateMemoryFile();             mMemoryFileSecondary = allocateMemoryFile();         }          if (mNeedHardwareBuffer) {             mHardwareBuffer = allocateHardwareBuffer();             mHardwareBufferSecondary = allocateHardwareBuffer();         }     }      private void freeSharedMemory() {         if (mMemoryFile != null) {             mMemoryFile.close();             mMemoryFile = null;         }          if (mMemoryFileSecondary != null) {             mMemoryFileSecondary.close();             mMemoryFileSecondary = null;         }          if (mHardwareBuffer != null) {             mHardwareBuffer.close();             mHardwareBuffer = null;         }          if (mHardwareBufferSecondary != null) {             mHardwareBufferSecondary.close();             mHardwareBufferSecondary = null;         }     }      private float getNominalFreq(int rateLevel) {         float nominalFreq = 0;         switch (rateLevel) {             case SensorDirectChannel.RATE_NORMAL:                 nominalFreq = RATE_NORMAL_NOMINAL;                 break;             case SensorDirectChannel.RATE_FAST:                 nominalFreq = RATE_FAST_NOMINAL;                 break;             case SensorDirectChannel.RATE_VERY_FAST:                 nominalFreq = RATE_VERY_FAST_NOMINAL;                 break;         }         return nominalFreq;     }      private int[] calculateExpectedNEvents(int timeMs, int rateLevel) {         int[] minMax = new int[] { -1, Integer.MAX_VALUE };         float nominalFreq = getNominalFreq(rateLevel);         if (nominalFreq != 0) {             // min             if (timeMs > ALLOWED_SENSOR_INIT_TIME_MILLISEC) {                 minMax[0] = (int) Math.floor(                         nominalFreq                         * FREQ_LOWER_BOUND                         * (timeMs - ALLOWED_SENSOR_INIT_TIME_MILLISEC)                         * (1 - MERCY_FACTOR)                         / 1000);             }             // max             minMax[1] = (int) Math.ceil(                     nominalFreq                     * FREQ_UPPER_BOUND                     * timeMs                     * (1 + MERCY_FACTOR)                     / 1000);         }         return minMax;     }      private void checkTimestampAbsolute(List<DirectReportSensorEvent> events) {         final int MAX_DETAIL_ITEM = 10;          StringBuffer buf = new StringBuffer();         int oneMsEarlyCount = 0;         int fiveMsLateCount = 0;         int tenMsLateCount = 0;         int errorCount = 0;          for (int i = 0; i < events.size(); ++i) {             DirectReportSensorEvent e = events.get(i);             long d = e.arrivalTs - e.ts;             boolean oneMsEarly = d < -1000_000;             boolean fiveMsLate = d > 5000_000;             boolean tenMsLate = d > 10_000_000;              if (oneMsEarly || fiveMsLate || tenMsLate) {                 oneMsEarlyCount += oneMsEarly ? 1 : 0;                 fiveMsLateCount += fiveMsLate ? 1 : 0;                 tenMsLateCount += tenMsLate ? 1 : 0;                  if (errorCount++ < MAX_DETAIL_ITEM) {                     buf.append(""["").append(i).append(""] diff = "").append(d / 1e6f).append("" ms; "");                 }             }         }          Log.d(TAG, String.format(""Irregular timestamp, %d, %d, %d out of %d"",                     oneMsEarlyCount, fiveMsLateCount, tenMsLateCount, events.size()));          if (CHECK_ABSOLUTE_LATENCY) {             assertTrue(String.format(                     ""Timestamp error, out of %d events, %d is >1ms early, %d is >5ms late, ""                         + ""%d is >10ms late, details: %s%s"",                         events.size(), oneMsEarlyCount, fiveMsLateCount, tenMsLateCount,                         buf.toString(), errorCount > MAX_DETAIL_ITEM ? ""..."" : """"),                     oneMsEarlyCount == 0                         && fiveMsLateCount <= events.size() / 20                         && tenMsLateCount <= events.size() / 100);         }     }      private void checkTimestampRelative(List<DirectReportSensorEvent> directEvents,                                         List<DirectReportSensorEvent> pollEvents) {         if (directEvents.size() < 10 || pollEvents.size() < 10) {             // cannot check with so few data points             return;         }          long directAverageLatency = 0;         for (DirectReportSensorEvent e : directEvents) {             directAverageLatency += e.arrivalTs - e.ts;         }         directAverageLatency /= directEvents.size();          long pollAverageLatency = 0;         for (DirectReportSensorEvent e : pollEvents) {             pollAverageLatency += e.arrivalTs - e.ts;         }         pollAverageLatency /= pollEvents.size();          Log.d(TAG, String.format(""Direct, poll latency = %f, %f ms"",                 directAverageLatency / 1e6f, pollAverageLatency / 1e6f));         assertTrue(                 String.format(""Direct, poll latency = %f, %f ms, expect direct < poll"",                     directAverageLatency / 1e6f,                     pollAverageLatency / 1e6f),                 directAverageLatency < pollAverageLatency + 1000_000);     }      private int[] calculateExpectedNEventsUs(int timeMs, int samplingPeriodUs) {         int[] minMax = new int[2];         minMax[0] = Math.max((int) Math.floor(                 (timeMs - ALLOWED_SENSOR_INIT_TIME_MILLISEC) * 1000/ samplingPeriodUs), 0);         minMax[1] = (int) Math.ceil(timeMs * 1000 * 2 / samplingPeriodUs);         return minMax;     }      private static class DirectReportSensorEvent {         public int size;         public int token;         public int type;         public long serial;         public long ts;         public float x;         public float y;         public float z;         public long arrivalTs;     };      // EventPool to avoid allocating too many event objects and hitting GC during test     private static class EventPool {         public EventPool(int n) {             mEvents = Arrays.asList(new DirectReportSensorEvent[n]);             for (int i = 0; i < n; ++i) {                 mEvents.set(i, new DirectReportSensorEvent());             }             reset();         }          public synchronized void reset() {             Log.d(TAG, ""Reset EventPool ("" + mIndex + "" events used)"");             mIndex = 0;         }          public synchronized DirectReportSensorEvent get() {             if (mIndex < mEvents.size()) {                 return mEvents.get(mIndex++);             } else {                 throw new IllegalStateException(""EventPool depleted"");             }         }          private List<DirectReportSensorEvent> mEvents;         private int mIndex;     };      private DirectReportSensorEvent getEvent() {         return mEventPool.get();     }      private DirectReportSensorEvent getEvent(DirectReportSensorEvent e) {         DirectReportSensorEvent event = mEventPool.get();         event.size = e.size;         event.token = e.token;         event.type = e.type;         event.serial = e.serial;         event.ts = e.ts;         event.x = e.x;         event.y = e.y;         event.z = e.z;         event.arrivalTs = e.arrivalTs;         return event;     }      private void resetEvent() {         mEventPool.reset();     }      private class SensorEventCollection implements SensorEventListener {         List<DirectReportSensorEvent> mEvents = new ArrayList<>();         Sensor mSensor;          public SensorEventCollection(Sensor s) {             mSensor = s;         }          List<DirectReportSensorEvent> getEvents() {             return mEvents;         }          @Override         public void onSensorChanged(SensorEvent event) {             if (mSensor == null || event.sensor == mSensor) {                 DirectReportSensorEvent e = mEventPool.get();                 e.size = SENSORS_EVENT_SIZE;                 e.token = event.sensor.getType();                 e.type = e.token;                 e.serial = -1;                 e.ts = event.timestamp;                 e.arrivalTs = SystemClock.elapsedRealtimeNanos();                  e.x = event.values[0];                 if (event.values.length > 1) {                     e.y = event.values[1];                 }                 if (event.values.length > 2) {                     e.z = event.values[2];                 }                 mEvents.add(e);             }         }          @Override         public void onAccuracyChanged(Sensor s, int accuracy) {             // do nothing         }     };      private List<DirectReportSensorEvent> parseEntireBuffer(byte[] buffer, int token) {         int offset = 0;         int nextSerial = 1;         List<DirectReportSensorEvent> events = new ArrayList<>();          while (offset <= SHARED_MEMORY_SIZE - SENSORS_EVENT_SIZE) {             DirectReportSensorEvent e = getEvent();             parseSensorEvent(offset, e);              if (e.serial == 0) {                 // reaches end of events                 break;             }              assertTrue(""incorrect size "" + e.size + ""  at offset "" + offset,                     e.size == SENSORS_EVENT_SIZE);             assertTrue(""incorrect serial "" + e.serial + "" at offset "" + offset,                     e.serial == nextSerial);              if (e.token == token) {                 events.add(e);             }              ++nextSerial;             offset += SENSORS_EVENT_SIZE;         }          return events;     }      // parse sensors_event_t from mBuffer and fill information into DirectReportSensorEvent     private void parseSensorEvent(int offset, DirectReportSensorEvent ev) {         mByteBuffer.position(offset);          ev.size = mByteBuffer.getInt();         ev.token = mByteBuffer.getInt();         ev.type = mByteBuffer.getInt();         ev.serial = ((long) mByteBuffer.getInt()) & 0xFFFFFFFFl; // signed=>unsigned         ev.ts = mByteBuffer.getLong();         ev.arrivalTs = SystemClock.elapsedRealtimeNanos();         ev.x = mByteBuffer.getFloat();         ev.y = mByteBuffer.getFloat();         ev.z = mByteBuffer.getFloat();     }      // parse sensors_event_t and fill information into DirectReportSensorEvent     private static void parseSensorEvent(byte [] buf, int offset, DirectReportSensorEvent ev) {         ByteBuffer b = ByteBuffer.wrap(buf, offset, SENSORS_EVENT_SIZE);         b.order(NATIVE_BYTE_ORDER);          ev.size = b.getInt();         ev.token = b.getInt();         ev.type = b.getInt();         ev.serial = ((long) b.getInt()) & 0xFFFFFFFFl; // signed=>unsigned         ev.ts = b.getLong();         ev.arrivalTs = SystemClock.elapsedRealtimeNanos();         ev.x = b.getFloat();         ev.y = b.getFloat();         ev.z = b.getFloat();     }      private long readAtomicCounter(int offset) {         mByteBuffer.position(offset + ATOMIC_COUNTER_OFFSET);         return ((long) mByteBuffer.getInt()) & 0xFFFFFFFFl; // signed => unsigned     }      private static long readAtomicCounter(byte [] buf, int offset) {         ByteBuffer b = ByteBuffer.wrap(buf, offset + ATOMIC_COUNTER_OFFSET, ATOMIC_COUNTER_SIZE);         b.order(ByteOrder.nativeOrder());          return ((long) b.getInt()) & 0xFFFFFFFFl; // signed => unsigned     } }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-2"	""	"android.hardware.cts.SensorManagerStaticTest"	"testGetRotationMatrix"	"CtsSensorTestCases"	""	"7.3.13/C-1-2"	"""C-1-2] MUST support at least two readings between 0 and 360 degrees (inclusive i.e including 0 and 360 degrees). """	""	"360 readings between degrees"	""	""	""	"degrees"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorManagerStaticTest.java"	""	"public void testGetRotationMatrix() throws Exception {         TestDataGenerator data = new TestDataGenerator();         final float gravity = 9.81f;         final float magStrength = 50.f;          int i;         float [] gm = new float[9];         float [] rotv = new float[3];         float [] gI = null;         float [] mI = null;         float [] Rr = new float[9];         float [] Ir = new float[9];          gm[6] = gravity; // m/s^2, first column gravity          // test many instances         for (i=0; i<100; ++i) {             float [] Rt;             float incline;             // yaw pitch roll             data.nextRotationAngles(rotv);             Rt = mat9T(mat9VRot(rotv)); // from world frame to phone frame             //Rt = mat9I();              incline = -0.9f * (data.nextFloat() - 0.5f) * FLOAT_PI; // ~ +-80 degrees             //incline = 0.f;             gm[4] = magStrength * (float) Math.cos(-incline); // positive means rotate downwards             gm[7] = magStrength * (float) Math.sin(-incline);              float [] gmb = mat9Mul(Rt, gm); // do not care about right most column             gI = mat9Axis(gmb, SensorManager.AXIS_X);             mI = mat9Axis(gmb, SensorManager.AXIS_Y);              assertTrue(""getRotationMatrix returns false on valid inputs"",                 SensorManager.getRotationMatrix(Rr, Ir, gI, mI));              float [] n = mat9Mul(Rr, Rt);             assertRoughlyEqual(                 String.format(""getRotationMatrix returns incorrect R matrix. "" +                     ""Details: case %d, truth R = %s, result R = %s."",                     i, mat9ToStr(mat9T(Rt)), mat9ToStr(Rr)),                 n[0] + n[4] + n[8], 3.f, 1e-4f);               // Magnetic incline is defined so that it means the magnetic field lines is formed             // by rotate local y axis around -x axis by incline angle. However, I matrix is             // defined as (according to document):             //     [0 m 0] = I * R * geomagnetic,             // which means,             //     I' * [0 m 0] = R * geomagnetic.             // Thus, I' = Rot(-x, incline) and I = Rot(-x, incline)' = Rot(x, incline)             float [] Ix = mat9Rot(SensorManager.AXIS_X, incline);             assertVectorRoughlyEqual(                 String.format(""getRotationMatrix returns incorrect I matrix. "" +                     ""Details: case %d, truth I = %s, result I = %s."",                     i, mat9ToStr(Ix), mat9ToStr(Ir)),                 Ix, Ir, 1e-4f);         }          // test 16 element inputs         float [] Rr2 = new float[16];         float [] Ir2 = new float[16];          assertTrue(""getRotationMatrix returns false on valid inputs"",             SensorManager.getRotationMatrix(Rr2, Ir2, gI, mI));          assertVectorRoughlyEqual(             ""getRotationMatrix acts inconsistent with 9- and 16- elements matrix buffer"",             mat16to9(Rr2), Rr, 1e-4f);          assertVectorRoughlyEqual(             ""getRotationMatrix acts inconsistent with 9- and 16- elements matrix buffer"",             mat16to9(Ir2), Ir, 1e-4f);          // test null inputs         assertTrue(""getRotationMatrix does not handle null inputs"",             SensorManager.getRotationMatrix(Rr, null, gI, mI));          assertTrue(""getRotationMatrix does not handle null inputs"",             SensorManager.getRotationMatrix(null, Ir, gI, mI));          assertTrue(""getRotationMatrix does not handle null inputs"",             SensorManager.getRotationMatrix(null, null, gI, mI));          // test fail cases         // free fall, if the acc reading is less than 10% of gravity         gI[0] = gI[1] = gI[2] = data.nextFloat() * gravity * 0.05f; // sqrt(3) * 0.05 < 0.1          assertFalse(""getRotationMatrix does not fail when it supposed to fail (gravity too small)"",             SensorManager.getRotationMatrix(Rr, Ir, gI, mI));          // wrong input         assertFalse(""getRotationMatrix does not fail when it supposed to fail (singular axis)"",             SensorManager.getRotationMatrix(Rr, Ir, gI, gI));     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-2"	""	"com.android.cts.verifier.sensors.MotionIndicatorView"	"testUI"	""	""	"7.3.13/C-1-2"	"""C-1-2] MUST support at least two readings between 0 and 360 degrees (inclusive i.e including 0 and 360 degrees). """	""	"360 readings between degrees"	""	""	""	"360"	""	""	""	"/home/gpoor/cts-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/sensors/MotionIndicatorView.java"	""	"public void testUI()  {  *     final int MAX_TILT_ANGLE = 70; // +/- 70  *  *     final int TILT_ANGLE_STEP = 5; // 5 degree(s) per step  *     final int YAW_ANGLE_STEP = 10; // 10 degree(s) per step  *  *     RangeCoveredRegister xCovered, yCovered, zCovered;  *     xCovered = new RangeCoveredRegister(-MAX_TILT_ANGLE, +MAX_TILT_ANGLE, TILT_ANGLE_STEP);  *  *     yCovered = new RangeCoveredRegister(-MAX_TILT_ANGLE, +MAX_TILT_ANGLE, TILT_ANGLE_STEP);  *     zCovered = new RangeCoveredRegister(YAW_ANGLE_STEP);  *  *     xCovered.update(40);  *     xCovered.update(-40);  *     xCovered.update(12);  *  *     yCovered.update(50);  *     yCovered.update(-51);  *  *     zCovered.update(150);  *     zCovered.update(42);  *  *     setDataProvider(xCovered, yCovered, zCovered);  *     enableAxis(RVCVRecordActivity.AXIS_ALL); //debug mode, show all three axis  * }  */ public class MotionIndicatorView extends View {     private final String TAG = ""MotionIndicatorView"";     private final boolean LOCAL_LOGV = false;      private Paint mCursorPaint;     private Paint mLimitPaint;     private Paint mCoveredPaint;     private Paint mRangePaint;     private Paint mEraserPaint;      // UI settings     private final int XBAR_WIDTH = 50;     private final int XBAR_MARGIN = 50;     private final int XBAR_CURSOR_ADD = 20;      private final int YBAR_WIDTH = 50;     private final int YBAR_MARGIN = 50;     private final int YBAR_CURSOR_ADD = 20;      private final int ZRING_WIDTH = 50;     private final int ZRING_CURSOR_ADD = 30;       private int mXSize, mYSize;     private RectF mZBoundOut, mZBoundOut2, mZBoundIn, mZBoundIn2;      private RangeCoveredRegister mXCovered, mYCovered, mZCovered;      private boolean mXEnabled, mYEnabled, mZEnabled;      private boolean mIsDeviceRotated = false;      /**      * Constructor      * @param context      */     public MotionIndicatorView(Context context) {         super(context);         init();     }      /**      * Constructor      * @param context Application context      * @param attrs      */     public MotionIndicatorView(Context context, AttributeSet attrs) {         super(context, attrs);         init();     }      /**      * Initialize the Paint objects      */     private void init() {          mCursorPaint = new Paint();         mCursorPaint.setColor(Color.BLUE);          mLimitPaint = new Paint();         mLimitPaint.setColor(Color.YELLOW);          mCoveredPaint = new Paint();         mCoveredPaint.setColor(Color.CYAN);          mRangePaint = new Paint();         mRangePaint.setColor(Color.DKGRAY);          mEraserPaint = new Paint();         mEraserPaint.setColor(Color.TRANSPARENT);         // ensure the erasing effect         mEraserPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC));     }      /**      * Connect the view to certain data provider objects      * @param x Data provider for x direction tilt angle      * @param y Data provider for y direction tilt angle      * @param z Data provider for z rotation      */     public void setDataProvider(RangeCoveredRegister x,                                 RangeCoveredRegister y,                                 RangeCoveredRegister z)    {         mXCovered = x;         mYCovered = y;         mZCovered = z;     }      /**      * Set the device's current rotation      * @param rotation Surface.ROTATION_0, Surface.ROTATION_90, Surface.ROTATION_180, or      *                 Surface.ROTATION_270      */     public void setDeviceRotation(int rotation) {         mIsDeviceRotated = (rotation == Surface.ROTATION_90 || rotation == Surface.ROTATION_270);     }      /**      * Set the active axis for display      *      * @param axis AXIS_X, AXIS_Y, AXIS_Z for x, y, z axis indicators, or AXIS_ALL for all three.      */     public void enableAxis(int axis)  {         mXEnabled = mYEnabled = mZEnabled = false;          switch(axis)         {             case SensorManager.AXIS_X:                 mXEnabled = true;                 break;             case SensorManager.AXIS_Y:                 mYEnabled = true;                 break;             case SensorManager.AXIS_Z:                 mZEnabled = true;                 break;             case RVCVRecordActivity.AXIS_ALL:                 mXEnabled = mYEnabled = mZEnabled = true;         }     }      /**      * Doing some pre-calculation that only changes when view dimensions are changed.      * @param w      * @param h      * @param oldw      * @param oldh      */     @Override     protected void onSizeChanged (int w, int h, int oldw, int oldh) {         mXSize = w;         mYSize = h;          float halfSideLength = 0.4f * Math.min(w, h);         float leftSide = w/2 - halfSideLength;         float topSide = h/2 - halfSideLength;         float rightSide = w/2 + halfSideLength;         float bottomSide = h/2 + halfSideLength;          mZBoundOut = new RectF(leftSide, topSide, rightSide, bottomSide);         mZBoundOut2 = new RectF(                 leftSide-ZRING_CURSOR_ADD, topSide-ZRING_CURSOR_ADD,                 rightSide+ZRING_CURSOR_ADD, bottomSide+ZRING_CURSOR_ADD);         mZBoundIn = new RectF(                 leftSide+ZRING_WIDTH, topSide+ZRING_WIDTH,                 rightSide-ZRING_WIDTH, bottomSide-ZRING_WIDTH);         mZBoundIn2 = new RectF(                 leftSide+ZRING_WIDTH+ZRING_CURSOR_ADD, topSide+ZRING_WIDTH+ZRING_CURSOR_ADD,                 rightSide-ZRING_WIDTH-ZRING_CURSOR_ADD, bottomSide-ZRING_WIDTH-ZRING_CURSOR_ADD);          if (LOCAL_LOGV) Log.v(TAG, ""New view size = (""+w+"", ""+h+"")"");     }      /**      * Draw UI depends on the selected axis and registered value      *      * @param canvas the canvas to draw on      */     @Override     protected void onDraw(Canvas canvas) {         super.onDraw(canvas);         int i,t;          Paint p = new Paint();         p.setColor(Color.YELLOW);         canvas.drawRect(10,10, 50, 50, p);          // In order to determine which progress bar to draw, the device's rotation must be accounted         // for since the accelerometer rotates with the display.         boolean drawX = (mXEnabled && !mIsDeviceRotated) || (mYEnabled && mIsDeviceRotated);         boolean drawY = (mYEnabled && !mIsDeviceRotated) || (mXEnabled && mIsDeviceRotated);          if (drawX && mXCovered != null) {             RangeCoveredRegister covered = mIsDeviceRotated ? mYCovered : mXCovered;             int xNStep = covered.getNSteps() + 4; // two on each side as a buffer             int xStepSize = mXSize * 3/4 / xNStep;             int xLeft = mXSize * 1/8 + (mXSize * 3/4 % xNStep)/2;              // base bar             canvas.drawRect(xLeft, XBAR_MARGIN,                     xLeft+xStepSize*xNStep-1, XBAR_WIDTH+XBAR_MARGIN, mRangePaint);              // covered range             for (i=0; i<covered.getNSteps(); ++i) {                 if (covered.isCovered(i)) {                     canvas.drawRect(                             xLeft+xStepSize*(i+2), XBAR_MARGIN,                             xLeft+xStepSize*(i+3)-1, XBAR_WIDTH + XBAR_MARGIN,                             mCoveredPaint);                 }             }              // limit             canvas.drawRect(xLeft+xStepSize*2-4, XBAR_MARGIN,                     xLeft+xStepSize*2+3, XBAR_WIDTH+XBAR_MARGIN, mLimitPaint);             canvas.drawRect(xLeft+xStepSize*(xNStep-2)-4, XBAR_MARGIN,                     xLeft+xStepSize*(xNStep-2)+3, XBAR_WIDTH+XBAR_MARGIN, mLimitPaint);              // cursor             t = (int)(xLeft+xStepSize*(covered.getLastValue()+2));             canvas.drawRect(t-4, XBAR_MARGIN-XBAR_CURSOR_ADD, t+3,                     XBAR_WIDTH+XBAR_MARGIN+XBAR_CURSOR_ADD, mCursorPaint);         }          if (drawY && mYCovered != null) {             RangeCoveredRegister covered = mIsDeviceRotated ? mXCovered : mYCovered;             int yNStep = covered.getNSteps() + 4; // two on each side as a buffer             int yStepSize = mYSize * 3/4 / yNStep;             int yLeft = mYSize * 1/8 + (mYSize * 3/4 % yNStep)/2;              // base bar             canvas.drawRect(YBAR_MARGIN, yLeft,                     YBAR_WIDTH+YBAR_MARGIN, yLeft+yStepSize*yNStep-1, mRangePaint);              // covered range             for (i=0; i<covered.getNSteps(); ++i) {                 if (covered.isCovered(i)) {                     canvas.drawRect(                             YBAR_MARGIN, yLeft+yStepSize*(i+2),                             YBAR_WIDTH + YBAR_MARGIN, yLeft+yStepSize*(i+3)-1,                             mCoveredPaint);                 }             }              // limit             canvas.drawRect(YBAR_MARGIN, yLeft + yStepSize * 2 - 4,                     YBAR_WIDTH + YBAR_MARGIN, yLeft + yStepSize * 2 + 3, mLimitPaint);             canvas.drawRect(YBAR_MARGIN, yLeft + yStepSize * (yNStep - 2) - 4,                     YBAR_WIDTH + YBAR_MARGIN, yLeft + yStepSize * (yNStep - 2) + 3, mLimitPaint);              // cursor             t = (int)(yLeft+yStepSize*(covered.getLastValue()+2));             canvas.drawRect( YBAR_MARGIN-YBAR_CURSOR_ADD, t-4,                     YBAR_WIDTH+YBAR_MARGIN+YBAR_CURSOR_ADD, t+3, mCursorPaint);         }          if (mZEnabled && mZCovered != null) {             float stepSize  = 360.0f/mZCovered.getNSteps();              // base bar             canvas.drawArc(mZBoundOut,0, 360, true, mRangePaint);              // covered range             for (i=0; i<mZCovered.getNSteps(); ++i) {                 if (mZCovered.isCovered(i)) {                     canvas.drawArc(mZBoundOut,i*stepSize-0.2f, stepSize+0.4f,                             true, mCoveredPaint);                 }             }             // clear center             canvas.drawArc(mZBoundIn, 0, 360, true, mEraserPaint);             // cursor             canvas.drawArc(mZBoundOut2, mZCovered.getLastValue()*stepSize- 1, 2,                     true, mCursorPaint);             canvas.drawArc(mZBoundIn2, mZCovered.getLastValue()*stepSize-1.5f, 3,                     true, mEraserPaint);         }     } }  /**  *  A range register class for the RVCVRecord Activity  */ class RangeCoveredRegister {     enum MODE {         LINEAR,         ROTATE2D     }      private boolean[] mCovered;     private MODE mMode;     private int mStep;     private int mLow, mHigh;     private int mLastData;      // high is not inclusive     RangeCoveredRegister(int low, int high, int step) {         mMode = MODE.LINEAR;         mStep = step;         mLow = low;         mHigh = high;         init();     }      RangeCoveredRegister(int step) {         mMode = MODE.ROTATE2D;         mStep = step;         mLow = 0;         mHigh = 360;         init();     }      private void init() {         if (mMode == MODE.LINEAR) {             mCovered = new boolean[(mHigh-mLow)/mStep];         }else {             mCovered = new boolean[360/mStep];         }     }      /**      * Test if the range specified by (low, high) is covered.      *      * If it is LINEAR mode, the range will be quantized to nearest step boundary. If it is the      * ROTATE2D mode, it is the same as isFullyCovered().      *      * @param low The low end of the range.      * @param high The high end of the range.      * @return if the specified range is covered, return true; otherwise false.      */     public boolean isRangeCovered(int low, int high) {         if (mMode == MODE.LINEAR) {             int iLow = Math.max(Math.round((low - mLow) / mStep), 0);             int iHigh = Math.min(Math.round((high - mLow) / mStep), mCovered.length-1);              for (int i = iLow; i <= iHigh; ++i) {                 if (!mCovered[i]) {                     return false;                 }             }             return true;          } else {             return isFullyCovered();         }     }      /**      * Test if the range defined is fully covered.      *      * @return if the range is fully covered, return true; otherwise false.      */     public boolean isFullyCovered() {         for (boolean i : mCovered) {             if (!i) return false;         }         return true;     }      /**      * Test if a specific step is covered.      *      * @param i the step number      * @return if the step specified is covered, return true; otherwise false.      */     public boolean isCovered(int i) {         return mCovered[i];     }      /**      *      *      * @param data      * @return if this update changes the status of      */     public boolean update(int data) {         mLastData = data;          if (mMode == MODE.ROTATE2D) {             data %= 360;         }          int iStep = (data - mLow)/mStep;          if (iStep>=0 && iStep<getNSteps()) {             // only record valid data             mLastData = data;              if (mCovered[iStep]) {                 return false;             } else {                 mCovered[iStep] = true;                 return true;             }         }         return false;     }      /**      * Get the number of steps in this register      *      * @return The number of steps in this register      */     public int getNSteps() {         //if (mCovered == null) {         //return 0;         //}         return mCovered.length;     }      /**      * Get the last value updated      *      * @return The last value updated      */     public float getLastValue() {         // ensure float division         return ((float)(mLastData - mLow))/mStep;     } }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorBatchingFifoTest"	"testGameRotationVectorFifoLength"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorBatchingFifoTest.java"	""	"public void testGameRotationVectorFifoLength() throws Throwable {         if (!mHasHifiSensors) return;         runBatchingSensorFifoTest(                 Sensor.TYPE_GAME_ROTATION_VECTOR,                 getReservedFifoLength(Sensor.TYPE_GAME_ROTATION_VECTOR));     }      private int getReservedFifoLength(int sensorType) {         Sensor sensor = mSensorManager.getDefaultSensor(sensorType);         assertTrue(String.format(""sensor of type=%d (null)"", sensorType), sensor != null);         return sensor.getFifoReservedEventCount();     }      private void runBatchingSensorFifoTest(int sensorType, int fifoLength) throws Throwable {         if (fifoLength == 0) {             return;         }         Sensor sensor = mSensorManager.getDefaultSensor(sensorType);         TestSensorEnvironment environment =  new TestSensorEnvironment(getContext(),                 sensor,                 false, /* sensorMightHaveMoreListeners */                 sensor.getMinDelay(),                 Integer.MAX_VALUE /*maxReportLatencyUs*/);          int preFlushMs = 2000;  // 2 sec to make sure there is sample at the time of flush         int postFlushMs = environment.getExpectedSamplingPeriodUs() * 100 /1000;         int testFlushMs =                 environment.getSensor().getFifoReservedEventCount() *                 environment.getExpectedSamplingPeriodUs() / (int)(1000 / 1.2); // 120%          TestSensorOperation op = TestSensorOperation.createFlushOperation(                 environment, new int [] { preFlushMs, testFlushMs, postFlushMs }, -1);          op.addVerification(FifoLengthVerification.getDefault(environment));         op.execute(getCurrentTestNode());         op.getStats().log(TAG);     } }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorBatchingTests"	"testGeomagneticRotationVector_50hz_flush"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorBatchingTests.java"	""	"public void testGeomagneticRotationVector_50hz_flush() throws Throwable {         runFlushSensorTest(Sensor.TYPE_GEOMAGNETIC_ROTATION_VECTOR, RATE_50HZ, BATCHING_PERIOD);     }      private void runBatchingSensorTest(int sensorType, int rateUs, int maxBatchReportLatencySec)             throws Throwable {         int maxBatchReportLatencyUs = (int) TimeUnit.SECONDS.toMicros(maxBatchReportLatencySec);         int testDurationSec = maxBatchReportLatencySec + BATCHING_PADDING_TIME_S;          TestSensorEnvironment environment = new TestSensorEnvironment(                 getContext(),                 sensorType,                 shouldEmulateSensorUnderLoad(),                 rateUs,                 maxBatchReportLatencyUs);         TestSensorOperation operation =                 TestSensorOperation.createOperation(environment, testDurationSec, TimeUnit.SECONDS);          operation.addVerification(                 EventBasicVerification.getDefault(                         environment, TimeUnit.SECONDS.toMicros(testDurationSec)                 )         );          executeTest(environment, operation, false /* flushExpected */);     }      private void runFlushSensorTest(int sensorType, int rateUs, int maxBatchReportLatencySec)             throws Throwable {         int maxBatchReportLatencyUs = (int) TimeUnit.SECONDS.toMicros(maxBatchReportLatencySec);         int flushDurationSec = maxBatchReportLatencySec / 2;          TestSensorEnvironment environment = new TestSensorEnvironment(                 getContext(),                 sensorType,                 shouldEmulateSensorUnderLoad(),                 rateUs,                 maxBatchReportLatencyUs);         TestSensorOperation operation = TestSensorOperation                 .createFlushOperation(environment, flushDurationSec, TimeUnit.SECONDS);          executeTest(environment, operation, true /* flushExpected */);     }      private void executeTest(             TestSensorEnvironment environment,             TestSensorOperation operation,             boolean flushExpected) throws Throwable {         SensorCtsHelper.sleep(3, TimeUnit.SECONDS);         operation.addDefaultVerifications();          try {             operation.execute(getCurrentTestNode());         } finally {             SensorStats stats = operation.getStats();             stats.log(TAG);              String sensorRate;             if (environment.getRequestedSamplingPeriodUs() == SensorManager.SENSOR_DELAY_FASTEST) {                 sensorRate = ""fastest"";             } else {                 sensorRate = String.format(""%.0fhz"", environment.getFrequencyHz());             }             String batching = environment.getMaxReportLatencyUs() > 0 ? ""_batching"" : """";             String flush = flushExpected ? ""_flush"" : """";             String fileName = String.format(                     ""batching_%s_%s%s%s.txt"",                     SensorStats.getSanitizedSensorName(environment.getSensor()),                     sensorRate,                     batching,                     flush);             stats.logToFile(environment.getContext(), fileName);         }     } }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorTest"	"testRegisterTwiceWithSameSensor"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testRegisterTwiceWithSameSensor() {         Sensor sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);         if (sensor == null) {             throw new SensorNotSupportedException(Sensor.TYPE_ACCELEROMETER);         }          boolean result = mSensorManager.registerListener(mNullSensorEventListener, sensor,                 SensorManager.SENSOR_DELAY_NORMAL);         assertTrue(result);          result = mSensorManager.registerListener(mNullSensorEventListener, sensor,                 SensorManager.SENSOR_DELAY_NORMAL);         assertFalse(result);     }      /**      * Verifies that if the UID is idle the continuous events are being reported      * but sanitized - all events are the same as the first one delivered except      * for their timestamps. From the point of view of an idle app these events are      * being properly generated but the sensor reading does not change - privacy.      */     // TODO: remove when parametrized tests are supported and EventTimestampSynchronization"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorTest"	"testSanitizedContinuousEventsUidIdle"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testSanitizedContinuousEventsUidIdle() throws Exception {         ArrayList<Throwable> errorsFound = new ArrayList<>();         for (Sensor sensor : mAndroidSensorList) {             // If the UID is active no sanitization should be performed             verifyLongActivation(sensor, 0 /* maxReportLatencyUs */,                     5 /* duration */, TimeUnit.SECONDS, ""continuous event"",                     false /* sanitized */, errorsFound);             verifyLongActivation(sensor, (int) TimeUnit.SECONDS.toMicros(10),                     5 /* duration */, TimeUnit.SECONDS, ""continuous event"",                     false /* sanitized */, errorsFound);              // If the UID is idle sanitization should be performed              SensorCtsHelper.makeMyPackageIdle();             try {                 verifyLongActivation(sensor, 0 /* maxReportLatencyUs */,                         5 /* duration */, TimeUnit.SECONDS, ""continuous event"",                         true /* sanitized */, errorsFound);                 verifyLongActivation(sensor, (int) TimeUnit.SECONDS.toMicros(10),                         5 /* duration */, TimeUnit.SECONDS, ""continuous event"",                         true /* sanitized */, errorsFound);             } finally {                 SensorCtsHelper.makeMyPackageActive();             }              // If the UID is active no sanitization should be performed             verifyLongActivation(sensor, 0 /* maxReportLatencyUs */,                     5 /* duration */, TimeUnit.SECONDS, ""continuous event"",                     false /* sanitized */, errorsFound);             verifyLongActivation(sensor, (int) TimeUnit.SECONDS.toMicros(10),                     5 /* duration */, TimeUnit.SECONDS, ""continuous event"",                     false /* sanitized */, errorsFound);         }         assertOnErrors(errorsFound);     }      // TODO: remove when parametrized tests are supported and EventTimestampSynchronization     //       verification is added to default verifications"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorTest"	"testSensorTimeStamps"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testSensorTimeStamps() throws Exception {         ArrayList<Throwable> errorsFound = new ArrayList<>();         for (Sensor sensor : mAndroidSensorList) {             // test both continuous and batching mode sensors             verifyLongActivation(sensor, 0 /* maxReportLatencyUs */,                     20 /* duration */, TimeUnit.SECONDS, ""timestamp"", false                     /* sanitized */, errorsFound);             verifyLongActivation(sensor, (int) TimeUnit.SECONDS.toMicros(10),                     20 /* duration */, TimeUnit.SECONDS, ""timestamp"",                     false /* sanitized */, errorsFound);         }         assertOnErrors(errorsFound);     }      // TODO: remove when parameterized tests are supported (see SensorBatchingTests.java)"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorTest"	"testBatchAndFlush"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testBatchAndFlush() throws Exception {         SensorCtsHelper.sleep(3, TimeUnit.SECONDS);         ArrayList<Throwable> errorsFound = new ArrayList<>();         for (Sensor sensor : mAndroidSensorList) {             verifyRegisterListenerCallFlush(sensor, null /* handler */, errorsFound,                     false /* flushWhileIdle */);         }         assertOnErrors(errorsFound);     }      /**      * Verifies that if the UID is idle flush events are reported. Since      * these events have no payload with private data they are working as      * for a non-idle UID.      */     // TODO: remove when parametized tests are supported and EventTimestampSynchronization"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorTest"	"testBatchAndFlushWithHandler"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testBatchAndFlushWithHandler() throws Exception {         SensorCtsHelper.sleep(3, TimeUnit.SECONDS);         Sensor sensor = null;         for (Sensor s : mAndroidSensorList) {             if (s.getReportingMode() == Sensor.REPORTING_MODE_CONTINUOUS) {                 sensor = s;                 break;             }         }         if (sensor == null) {             throw new SensorTestStateNotSupportedException(                     ""There are no Continuous sensors in the device."");         }          TestSensorEnvironment environment = new TestSensorEnvironment(                 getContext(),                 sensor,                 SensorManager.SENSOR_DELAY_FASTEST,                 (int) TimeUnit.SECONDS.toMicros(5));         mTestSensorManager = new TestSensorManager(environment);          HandlerThread handlerThread = new HandlerThread(""sensorThread"");         handlerThread.start();         Handler handler = new Handler(handlerThread.getLooper());         TestSensorEventListener listener = new TestSensorEventListener(environment, handler);          CountDownLatch eventLatch = mTestSensorManager.registerListener(listener, 1);         listener.waitForEvents(eventLatch, 1, true);         CountDownLatch flushLatch = mTestSensorManager.requestFlush();         listener.waitForFlushComplete(flushLatch, true);         listener.assertEventsReceivedInHandler();     }      /**      *  Explicit testing the SensorManager.registerListener(SensorEventListener, Sensor, int, int).      */"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorTest"	"testBatchAndFlushUseDefaultHandler"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testBatchAndFlushUseDefaultHandler() throws Exception {         SensorCtsHelper.sleep(3, TimeUnit.SECONDS);         Sensor sensor = null;         for (Sensor s : mAndroidSensorList) {             if (s.getReportingMode() == Sensor.REPORTING_MODE_CONTINUOUS) {                 sensor = s;                 break;             }         }         if (sensor == null) {             throw new SensorTestStateNotSupportedException(                     ""There are no Continuous sensors in the device."");         }          TestSensorEnvironment environment = new TestSensorEnvironment(                 getContext(),                 sensor,                 SensorManager.SENSOR_DELAY_FASTEST,                 (int) TimeUnit.SECONDS.toMicros(5));         mTestSensorManager = new TestSensorManager(environment);          TestSensorEventListener listener = new TestSensorEventListener(environment, null);          // specifyHandler <= false, use the SensorManager API without Handler parameter         CountDownLatch eventLatch = mTestSensorManager.registerListener(listener, 1, false);         listener.waitForEvents(eventLatch, 1, true);         CountDownLatch flushLatch = mTestSensorManager.requestFlush();         listener.waitForFlushComplete(flushLatch, true);         listener.assertEventsReceivedInHandler();     }      // TODO: after L release move to SensorBatchingTests and run in all sensors with default     //       verifications enabled"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorTest"	"testBatchAndFlushWithMultipleSensors"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testBatchAndFlushWithMultipleSensors() throws Exception {         SensorCtsHelper.sleep(3, TimeUnit.SECONDS);         final int maxSensors = 3;         final int maxReportLatencyUs = (int) TimeUnit.SECONDS.toMicros(10);         List<Sensor> sensorsToTest = new ArrayList<Sensor>();         for (Sensor sensor : mAndroidSensorList) {             if (sensor.getReportingMode() == Sensor.REPORTING_MODE_CONTINUOUS) {                 sensorsToTest.add(sensor);                 if (sensorsToTest.size()  == maxSensors) break;             }         }         final int numSensorsToTest = sensorsToTest.size();         if (numSensorsToTest == 0) {             return;         }          StringBuilder builder = new StringBuilder();         ParallelSensorOperation parallelSensorOperation = new ParallelSensorOperation();         for (Sensor sensor : sensorsToTest) {             TestSensorEnvironment environment = new TestSensorEnvironment(                     getContext(),                     sensor,                     shouldEmulateSensorUnderLoad(),                     SensorManager.SENSOR_DELAY_FASTEST,                     maxReportLatencyUs);             FlushExecutor executor = new FlushExecutor(environment, 500 /* eventCount */,                     false /* flushWhileIdle */);             parallelSensorOperation.add(new TestSensorOperation(environment, executor));             builder.append(sensor.getName()).append("", "");         }          Log.i(TAG, ""Testing batch/flush for sensors: "" + builder);         parallelSensorOperation.execute(getCurrentTestNode());     }      private void assertSensorValues(Sensor sensor) {         assertTrue(""Max range must be positive. Range="" + sensor.getMaximumRange()                 + "" "" + sensor.getName(), sensor.getMaximumRange() >= 0);         assertTrue(""Max power must be positive. Power="" + sensor.getPower() + "" "" +                 sensor.getName(), sensor.getPower() >= 0);          // Only assert sensor resolution is non-zero for official sensor types since that's what's         // required by the CDD.         if (sensor.getType() < MAX_OFFICIAL_ANDROID_SENSOR_TYPE) {             assertTrue(""Max resolution must be non-zero and positive. Resolution="" + sensor.getResolution() +                     "" "" + sensor.getName(), sensor.getResolution() > 0);         } else {             assertTrue(""Max resolution must be positive. Resolution="" + sensor.getResolution() +                     "" "" + sensor.getName(), sensor.getResolution() >= 0);         }          boolean hasHifiSensors = getContext().getPackageManager().hasSystemFeature(                 PackageManager.FEATURE_HIFI_SENSORS);         if (SensorCtsHelper.hasMaxResolutionRequirement(sensor, hasHifiSensors)) {             float maxResolution = SensorCtsHelper.getRequiredMaxResolutionForSensor(sensor);             assertTrue(""Resolution must be <= "" + maxResolution + "". Resolution="" +                     sensor.getResolution() + "" "" + sensor.getName(),                     sensor.getResolution() <= maxResolution);         }          // The minimum resolution requirement was introduced to the CDD in R so         // it's only possible to assert compliance for devices that release with         // R or later.         if (PropertyUtil.getFirstApiLevel() >= VERSION_CODES.R &&                 SensorCtsHelper.hasMinResolutionRequirement(sensor)) {             float minResolution = SensorCtsHelper.getRequiredMinResolutionForSensor(sensor);             assertTrue(""Resolution must be >= "" + minResolution + "". Resolution ="" +                     sensor.getResolution() + "" "" + sensor.getName(),                     sensor.getResolution() >= minResolution);         }          assertNotNull(""Vendor name must not be null "" + sensor.getName(), sensor.getVendor());         assertTrue(""Version must be positive version="" + sensor.getVersion() + "" "" +                 sensor.getName(), sensor.getVersion() > 0);         int fifoMaxEventCount = sensor.getFifoMaxEventCount();         int fifoReservedEventCount = sensor.getFifoReservedEventCount();         assertTrue(fifoMaxEventCount >= 0);         assertTrue(fifoReservedEventCount >= 0);         assertTrue(fifoReservedEventCount <= fifoMaxEventCount);         if (sensor.getReportingMode() == Sensor.REPORTING_MODE_ONE_SHOT) {             assertTrue(""One shot sensors should have zero FIFO Size "" + sensor.getName(),                     sensor.getFifoMaxEventCount() == 0);             assertTrue(""One shot sensors should have zero FIFO Size ""  + sensor.getName(),                     sensor.getFifoReservedEventCount() == 0);         }     }      @SuppressWarnings(""deprecation"")"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorTest"	"testLegacySensorOperations"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testLegacySensorOperations() {         final SensorManager mSensorManager =                 (SensorManager) getContext().getSystemService(Context.SENSOR_SERVICE);          // We expect the set of sensors reported by the new and legacy APIs to be consistent.         int sensors = 0;         if (mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER) != null) {             sensors |= SensorManager.SENSOR_ACCELEROMETER;         }         if (mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD) != null) {             sensors |= SensorManager.SENSOR_MAGNETIC_FIELD;         }         if (mSensorManager.getDefaultSensor(Sensor.TYPE_ORIENTATION) != null) {             sensors |= SensorManager.SENSOR_ORIENTATION | SensorManager.SENSOR_ORIENTATION_RAW;         }         assertEquals(sensors, mSensorManager.getSensors());     }      /**      * Verifies that a continuous sensor produces events that have timestamps synchronized with      * {@link SystemClock#elapsedRealtimeNanos()} and that the events are sanitized/non-sanitized.      */     private void verifyLongActivation(             Sensor sensor,             int maxReportLatencyUs,             long duration,             TimeUnit durationTimeUnit,             String testType,             boolean sanitized,             ArrayList<Throwable> errorsFound) throws InterruptedException {         if (sensor.getReportingMode() != Sensor.REPORTING_MODE_CONTINUOUS) {             return;         }          try {             TestSensorEnvironment environment = new TestSensorEnvironment(                     getContext(),                     sensor,                     shouldEmulateSensorUnderLoad(),                     SensorManager.SENSOR_DELAY_FASTEST,                     maxReportLatencyUs);             TestSensorOperation operation = TestSensorOperation.createOperation(                     environment, duration, durationTimeUnit);             if (sanitized) {                 final long verificationDelayNano = TimeUnit.NANOSECONDS.convert(                         maxReportLatencyUs, TimeUnit.MICROSECONDS) * 2;                 operation.addVerification(ContinuousEventSanitizedVerification                         .getDefault(environment, verificationDelayNano));             } else {                 operation.addVerification(EventGapVerification.getDefault(environment));                 operation.addVerification(EventOrderingVerification.getDefault(environment));                 operation.addVerification(EventTimestampSynchronizationVerification                         .getDefault(environment));             }             Log.i(TAG, ""Running "" + testType + "" test on: "" + sensor.getName());             operation.execute(getCurrentTestNode());         } catch (InterruptedException e) {             // propagate so the test can stop             throw e;         } catch (Throwable e) {             errorsFound.add(e);             Log.e(TAG, e.getMessage());         }     }      /**      * Verifies that a client can listen for events, and that      * {@link SensorManager#flush(SensorEventListener)} will trigger the appropriate notification      * for {@link SensorEventListener2#onFlushCompleted(Sensor)}.      */     private void verifyRegisterListenerCallFlush(             Sensor sensor,             Handler handler,             ArrayList<Throwable> errorsFound,             boolean flushWhileIdle)             throws InterruptedException {         if (sensor.getReportingMode() == Sensor.REPORTING_MODE_ONE_SHOT) {             return;         }          try {             TestSensorEnvironment environment = new TestSensorEnvironment(                     getContext(),                     sensor,                     shouldEmulateSensorUnderLoad(),                     SensorManager.SENSOR_DELAY_FASTEST,                     (int) TimeUnit.SECONDS.toMicros(10));             FlushExecutor executor = new FlushExecutor(environment, 500 /* eventCount */,                     flushWhileIdle);             TestSensorOperation operation = new TestSensorOperation(environment, executor, handler);              Log.i(TAG, ""Running flush test on: "" + sensor.getName());             operation.execute(getCurrentTestNode());         } catch (InterruptedException e) {             // propagate so the test can stop             throw e;         } catch (Throwable e) {             errorsFound.add(e);             Log.e(TAG, e.getMessage());         }     }      private void assertOnErrors(List<Throwable> errorsFound) {         if (!errorsFound.isEmpty()) {             StringBuilder builder = new StringBuilder();             for (Throwable error : errorsFound) {                 builder.append(error.getMessage()).append(""\n"");             }             Assert.fail(builder.toString());         }     }      /**      * A delegate that drives the execution of Batch/Flush tests.      * It performs several operations in order:      * - registration      * - for continuous sensors it first ensures that the FIFO is filled      *      - if events do not arrive on time, an assert will be triggered      * - requests flush of sensor data      * - waits for {@link SensorEventListener2#onFlushCompleted(Sensor)}      *      - if the event does not arrive, an assert will be triggered      */     private class FlushExecutor implements TestSensorOperation.Executor {         private final TestSensorEnvironment mEnvironment;         private final int mEventCount;         private final boolean mFlushWhileIdle;          public FlushExecutor(TestSensorEnvironment environment, int eventCount,                 boolean flushWhileIdle) {             mEnvironment = environment;             mEventCount = eventCount;             mFlushWhileIdle = flushWhileIdle;         }          /**          * Consider only continuous mode sensors for testing register listener.          *          * For on-change sensors, we only use          * {@link TestSensorManager#registerListener(TestSensorEventListener)} to associate the          * listener with the sensor. So that {@link TestSensorManager#requestFlush()} can be          * invoked on it.          */         @Override         public void execute(TestSensorManager sensorManager, TestSensorEventListener listener)                 throws Exception {             int sensorReportingMode = mEnvironment.getSensor().getReportingMode();             try {                 CountDownLatch eventLatch = sensorManager.registerListener(listener, mEventCount);                 if (sensorReportingMode == Sensor.REPORTING_MODE_CONTINUOUS) {                     listener.waitForEvents(eventLatch, mEventCount, true);                 }                 if (mFlushWhileIdle) {                     SensorCtsHelper.makeMyPackageIdle();                     sensorManager.assertFlushFail();                 } else {                     CountDownLatch flushLatch = sensorManager.requestFlush();                     listener.waitForFlushComplete(flushLatch, true);                 }             } finally {                 sensorManager.unregisterListener();                 if (mFlushWhileIdle) {                     SensorCtsHelper.makeMyPackageActive();                 }             }         }     }      private class NullTriggerEventListener extends TriggerEventListener {         @Override         public void onTrigger(TriggerEvent event) {}     }      private class NullSensorEventListener implements SensorEventListener {         @Override         public void onSensorChanged(SensorEvent event) {}          @Override         public void onAccuracyChanged(Sensor sensor, int accuracy) {}     }  }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorTest"	"testLegacySensorOperations"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"implement"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testLegacySensorOperations() {         final SensorManager mSensorManager =                 (SensorManager) getContext().getSystemService(Context.SENSOR_SERVICE);          // We expect the set of sensors reported by the new and legacy APIs to be consistent.         int sensors = 0;         if (mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER) != null) {             sensors |= SensorManager.SENSOR_ACCELEROMETER;         }         if (mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD) != null) {             sensors |= SensorManager.SENSOR_MAGNETIC_FIELD;         }         if (mSensorManager.getDefaultSensor(Sensor.TYPE_ORIENTATION) != null) {             sensors |= SensorManager.SENSOR_ORIENTATION | SensorManager.SENSOR_ORIENTATION_RAW;         }         assertEquals(sensors, mSensorManager.getSensors());     }      /**      * Verifies that a continuous sensor produces events that have timestamps synchronized with      * {@link SystemClock#elapsedRealtimeNanos()} and that the events are sanitized/non-sanitized.      */     private void verifyLongActivation(             Sensor sensor,             int maxReportLatencyUs,             long duration,             TimeUnit durationTimeUnit,             String testType,             boolean sanitized,             ArrayList<Throwable> errorsFound) throws InterruptedException {         if (sensor.getReportingMode() != Sensor.REPORTING_MODE_CONTINUOUS) {             return;         }          try {             TestSensorEnvironment environment = new TestSensorEnvironment(                     getContext(),                     sensor,                     shouldEmulateSensorUnderLoad(),                     SensorManager.SENSOR_DELAY_FASTEST,                     maxReportLatencyUs);             TestSensorOperation operation = TestSensorOperation.createOperation(                     environment, duration, durationTimeUnit);             if (sanitized) {                 final long verificationDelayNano = TimeUnit.NANOSECONDS.convert(                         maxReportLatencyUs, TimeUnit.MICROSECONDS) * 2;                 operation.addVerification(ContinuousEventSanitizedVerification                         .getDefault(environment, verificationDelayNano));             } else {                 operation.addVerification(EventGapVerification.getDefault(environment));                 operation.addVerification(EventOrderingVerification.getDefault(environment));                 operation.addVerification(EventTimestampSynchronizationVerification                         .getDefault(environment));             }             Log.i(TAG, ""Running "" + testType + "" test on: "" + sensor.getName());             operation.execute(getCurrentTestNode());         } catch (InterruptedException e) {             // propagate so the test can stop             throw e;         } catch (Throwable e) {             errorsFound.add(e);             Log.e(TAG, e.getMessage());         }     }      /**      * Verifies that a client can listen for events, and that      * {@link SensorManager#flush(SensorEventListener)} will trigger the appropriate notification      * for {@link SensorEventListener2#onFlushCompleted(Sensor)}.      */     private void verifyRegisterListenerCallFlush(             Sensor sensor,             Handler handler,             ArrayList<Throwable> errorsFound,             boolean flushWhileIdle)             throws InterruptedException {         if (sensor.getReportingMode() == Sensor.REPORTING_MODE_ONE_SHOT) {             return;         }          try {             TestSensorEnvironment environment = new TestSensorEnvironment(                     getContext(),                     sensor,                     shouldEmulateSensorUnderLoad(),                     SensorManager.SENSOR_DELAY_FASTEST,                     (int) TimeUnit.SECONDS.toMicros(10));             FlushExecutor executor = new FlushExecutor(environment, 500 /* eventCount */,                     flushWhileIdle);             TestSensorOperation operation = new TestSensorOperation(environment, executor, handler);              Log.i(TAG, ""Running flush test on: "" + sensor.getName());             operation.execute(getCurrentTestNode());         } catch (InterruptedException e) {             // propagate so the test can stop             throw e;         } catch (Throwable e) {             errorsFound.add(e);             Log.e(TAG, e.getMessage());         }     }      private void assertOnErrors(List<Throwable> errorsFound) {         if (!errorsFound.isEmpty()) {             StringBuilder builder = new StringBuilder();             for (Throwable error : errorsFound) {                 builder.append(error.getMessage()).append(""\n"");             }             Assert.fail(builder.toString());         }     }      /**      * A delegate that drives the execution of Batch/Flush tests.      * It performs several operations in order:      * - registration      * - for continuous sensors it first ensures that the FIFO is filled      *      - if events do not arrive on time, an assert will be triggered      * - requests flush of sensor data      * - waits for {@link SensorEventListener2#onFlushCompleted(Sensor)}      *      - if the event does not arrive, an assert will be triggered      */     private class FlushExecutor implements TestSensorOperation.Executor {         private final TestSensorEnvironment mEnvironment;         private final int mEventCount;         private final boolean mFlushWhileIdle;          public FlushExecutor(TestSensorEnvironment environment, int eventCount,                 boolean flushWhileIdle) {             mEnvironment = environment;             mEventCount = eventCount;             mFlushWhileIdle = flushWhileIdle;         }          /**          * Consider only continuous mode sensors for testing register listener.          *          * For on-change sensors, we only use          * {@link TestSensorManager#registerListener(TestSensorEventListener)} to associate the          * listener with the sensor. So that {@link TestSensorManager#requestFlush()} can be          * invoked on it.          */         @Override         public void execute(TestSensorManager sensorManager, TestSensorEventListener listener)                 throws Exception {             int sensorReportingMode = mEnvironment.getSensor().getReportingMode();             try {                 CountDownLatch eventLatch = sensorManager.registerListener(listener, mEventCount);                 if (sensorReportingMode == Sensor.REPORTING_MODE_CONTINUOUS) {                     listener.waitForEvents(eventLatch, mEventCount, true);                 }                 if (mFlushWhileIdle) {                     SensorCtsHelper.makeMyPackageIdle();                     sensorManager.assertFlushFail();                 } else {                     CountDownLatch flushLatch = sensorManager.requestFlush();                     listener.waitForFlushComplete(flushLatch, true);                 }             } finally {                 sensorManager.unregisterListener();                 if (mFlushWhileIdle) {                     SensorCtsHelper.makeMyPackageActive();                 }             }         }     }      private class NullTriggerEventListener extends TriggerEventListener {         @Override         public void onTrigger(TriggerEvent event) {}     }      private class NullSensorEventListener implements SensorEventListener {         @Override         public void onSensorChanged(SensorEvent event) {}          @Override         public void onAccuracyChanged(Sensor sensor, int accuracy) {}     }  }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.helpers.sensorverification.JitterVerificationTest"	"testVerify"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/helpers/sensorverification/JitterVerificationTest.java"	""	"public void testVerify() {         final int SAMPLE_SIZE = 100;         // for unit testing the verification, only the parameter 'sensorMightHaveMoreListeners' is         // required         TestSensorEnvironment environment = new TestSensorEnvironment(                 null /* context */,                 null /* sensor */,                 false /* sensorMightHaveMoreListeners */,                 0 /*samplingPeriodUs */,                 0 /* maxReportLatencyUs */);          // 100 samples at 1000Hz         long[] timestamps = new long[SAMPLE_SIZE];         for (int i = 0; i < SAMPLE_SIZE; i++) {             timestamps[i] = i * 100000;         }         SensorStats stats = new SensorStats();         ISensorVerification verification = getVerification(1, timestamps);         verification.verify(environment, stats);         verifyStats(stats, true, 0.0);          // 90 samples at 1000Hz, 10 samples at 2000Hz         long timestamp = 0;         for (int i = 0; i < SAMPLE_SIZE; i++) {             timestamps[i] = timestamp;             timestamp += (i % 10 == 0) ? 500000 : 1000000;         }         stats = new SensorStats();         verification = getVerification(1, timestamps);         try {             verification.verify(environment, stats);             throw new Error(""Expected an AssertionError"");         } catch (AssertionError e) {             // Expected;         }         verifyStats(stats, false, 25); // 500 us range (250 us in single-sided sense)                                        // divide by 1ms requested sample time x 100%     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"isDirectChannelTypeSupported"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void test/*  *.  */  package android.hardware.cts;  import android.content.Context; import android.hardware.HardwareBuffer; import android.hardware.Sensor; import android.hardware.SensorDirectChannel; import android.hardware.SensorEvent; import android.hardware.SensorEventListener; import android.hardware.SensorManager; import android.hardware.cts.helpers.SensorCtsHelper; import android.hardware.cts.helpers.SensorCtsHelper.TestResultCollector; import android.os.MemoryFile; import android.os.SystemClock; import android.util.Log;  import java.io.IOException; import java.io.UncheckedIOException; import java.nio.ByteBuffer; import java.nio.ByteOrder; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.concurrent.TimeUnit;  /**  * Checks Sensor Direct Report functionality  *  * This testcase tests operation of:  *   - SensorManager.createDirectChannel()  *   - SensorDirectChannel.*  *   - Sensor.getHighestDirectReportRateLevel()  *   - Sensor.isDirectChannelTypeSupported()  *  * Tests:  *   - test<Sensor><SharedMemoryType><RateLevel>  *     tests basic operation of sensor in direct report mode at various rate level specification.  *   - testRateIndependency<Sensor1><Sensor2>SingleChannel  *     tests if two sensors in the same direct channel are able to run at different rates.  *   - testRateIndependency<Sensor>MultiChannel  *     tests if a sensor is able to be configured to different rate levels for multiple channels.  *   - testRateIndependency<Sensor>MultiMode  *     tests if a sensor is able to report at different rates in direct report mode and traditional  *     report mode (polling).  *   - testTimestamp<Sensor>  *     tests if the timestamp is correct both in absolute sense and relative to traditional report.  *   - testAtomicCounter<Sensor>  *     test if atomic counter is increased as specified and if sensor event content is fully updated  *     before update of atomic counter.  *   - testRegisterMultipleChannels  *     test scenarios when multiple channels are registered simultaneously.  *   - testReconfigure  *     test channel reconfiguration (configure to a rate level; configure to stop; configure to  *     another rate level)  *   - testRegisterMultipleChannelsUsingSameMemory  *     test a negative case when the same memory is being used twice for registering sensor direct  *     channel  *   - testCloseWithoutConfigStop  *     test a common mistake in API usage and make sure no negative effect is made to system.  */ public class SensorDirectReportTest extends SensorTestCase {     private static final String TAG = ""SensorDirectReportTest"";     // nominal rates of each rate level supported     private static final float RATE_NORMAL_NOMINAL = 50;     private static final float RATE_FAST_NOMINAL = 200;     private static final float RATE_VERY_FAST_NOMINAL = 800;      // actuall value is allowed to be 55% to 220% of nominal value     private static final float FREQ_LOWER_BOUND = 0.55f;     private static final float FREQ_UPPER_BOUND = 2.2f;      // actuall value is allowed to be 90% to 200% of nominal value in poll() interface     private static final float FREQ_LOWER_BOUND_POLL = 0.90f;     private static final float FREQ_UPPER_BOUND_POLL = 2.00f;      // sensor reading assumption     private static final float GRAVITY_MIN = 9.81f - 1.0f;     private static final float GRAVITY_MAX = 9.81f + 1.0f;     private static final float GYRO_NORM_MAX = 0.1f;      // test constants     private static final int REST_PERIOD_BEFORE_TEST_MILLISEC = 3000;     private static final int TEST_RUN_TIME_PERIOD_MILLISEC = 5000;     private static final int ALLOWED_SENSOR_INIT_TIME_MILLISEC = 500;     private static final int SENSORS_EVENT_SIZE = 104;     private static final int ATOMIC_COUNTER_OFFSET = 12;     private static final int ATOMIC_COUNTER_SIZE = 4;     private static final int SENSORS_EVENT_COUNT = 10240; // 800Hz * 2.2 * 5 sec + extra     private static final int SHARED_MEMORY_SIZE = SENSORS_EVENT_COUNT * SENSORS_EVENT_SIZE;     private static final float MERCY_FACTOR = 0.1f;     private static final boolean CHECK_ABSOLUTE_LATENCY = false;      // list of rate levels being tested     private static final int[] POSSIBLE_RATE_LEVELS = new int[] {             SensorDirectChannel.RATE_NORMAL,             SensorDirectChannel.RATE_FAST,             SensorDirectChannel.RATE_VERY_FAST         };      // list of channel types being tested     private static final int[] POSSIBLE_CHANNEL_TYPES = new int [] {             SensorDirectChannel.TYPE_MEMORY_FILE,             SensorDirectChannel.TYPE_HARDWARE_BUFFER         };      // list of sensor types being tested     private static final int[] POSSIBLE_SENSOR_TYPES = new int [] {             Sensor.TYPE_ACCELEROMETER,             Sensor.TYPE_GYROSCOPE,             Sensor.TYPE_MAGNETIC_FIELD         };      // list of sampling period being tested     private static final int[] POSSIBLE_SAMPLE_PERIOD_US = new int [] {             200_000, // Normal 5 Hz             66_667,  // UI    15 Hz             20_000,  // Game  50 Hz             5_000,   // 200Hz             0        // fastest         };      private static final ByteOrder NATIVE_BYTE_ORDER = ByteOrder.nativeOrder();      private static native boolean nativeReadHardwareBuffer(HardwareBuffer hardwareBuffer,             byte[] buffer, int srcOffset, int destOffset, int count);      private boolean mNeedMemoryFile;     private MemoryFile mMemoryFile;     private MemoryFile mMemoryFileSecondary;     private boolean mNeedHardwareBuffer;     private HardwareBuffer mHardwareBuffer;     private HardwareBuffer mHardwareBufferSecondary;     private ByteBuffer mByteBuffer;     private byte[] mBuffer;      private SensorManager mSensorManager;     private SensorDirectChannel mChannel;     private SensorDirectChannel mChannelSecondary;      private EventPool mEventPool;      static {         System.loadLibrary(""cts-sensors-ndk-jni"");     }      @Override     protected void setUp() throws Exception {         super.setUp();          mByteBuffer = ByteBuffer.allocate(SHARED_MEMORY_SIZE);         mBuffer = mByteBuffer.array();         mByteBuffer.order(ByteOrder.nativeOrder());          mEventPool = new EventPool(10 * SENSORS_EVENT_COUNT);         mSensorManager = (SensorManager) getContext().getSystemService(Context.SENSOR_SERVICE);          mNeedMemoryFile = isMemoryTypeNeeded(SensorDirectChannel.TYPE_MEMORY_FILE);         mNeedHardwareBuffer = isMemoryTypeNeeded(SensorDirectChannel.TYPE_HARDWARE_BUFFER);          allocateSharedMemory();     }      @Override     protected void tearDown() throws Exception {         if (mChannel != null) {             mChannel.close();             mChannel = null;         }          if (mChannelSecondary != null) {             mChannelSecondary.close();             mChannelSecondary = null;         }          freeSharedMemory();         super.tearDown();     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testAccelerometerAshmemNormal"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testAccelerometerAshmemNormal() {         runSensorDirectReportTest(                 Sensor.TYPE_ACCELEROMETER,                 SensorDirectChannel.TYPE_MEMORY_FILE,                 SensorDirectChannel.RATE_NORMAL);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testAccelerometerAshmemNormalUidIdle"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testAccelerometerAshmemNormalUidIdle() {         runSensorDirectReportUidIdleTest(                 Sensor.TYPE_ACCELEROMETER,                 SensorDirectChannel.TYPE_MEMORY_FILE,                 SensorDirectChannel.RATE_NORMAL);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testGyroscopeAshmemNormal"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testGyroscopeAshmemNormal() {         runSensorDirectReportTest(                 Sensor.TYPE_GYROSCOPE,                 SensorDirectChannel.TYPE_MEMORY_FILE,                 SensorDirectChannel.RATE_NORMAL);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testGyroscopeAshmemNormalUidIdle"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testGyroscopeAshmemNormalUidIdle() {         runSensorDirectReportUidIdleTest(                 Sensor.TYPE_GYROSCOPE,                 SensorDirectChannel.TYPE_MEMORY_FILE,                 SensorDirectChannel.RATE_NORMAL);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testMagneticFieldAshmemNormal"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testMagneticFieldAshmemNormal() {         runSensorDirectReportTest(                 Sensor.TYPE_MAGNETIC_FIELD,                 SensorDirectChannel.TYPE_MEMORY_FILE,                 SensorDirectChannel.RATE_NORMAL);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testMagneticFieldAshmemNormalUidIdle"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testMagneticFieldAshmemNormalUidIdle() {         runSensorDirectReportUidIdleTest(                 Sensor.TYPE_MAGNETIC_FIELD,                 SensorDirectChannel.TYPE_MEMORY_FILE,                 SensorDirectChannel.RATE_NORMAL);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testAccelerometerAshmemFast"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testAccelerometerAshmemFast() {         runSensorDirectReportTest(                 Sensor.TYPE_ACCELEROMETER,                 SensorDirectChannel.TYPE_MEMORY_FILE,                 SensorDirectChannel.RATE_FAST);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testAccelerometerAshmemFastUidIdle"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testAccelerometerAshmemFastUidIdle() {         runSensorDirectReportUidIdleTest(                 Sensor.TYPE_ACCELEROMETER,                 SensorDirectChannel.TYPE_MEMORY_FILE,                 SensorDirectChannel.RATE_FAST);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testGyroscopeAshmemFast"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testGyroscopeAshmemFast() {         runSensorDirectReportTest(                 Sensor.TYPE_GYROSCOPE,                 SensorDirectChannel.TYPE_MEMORY_FILE,                 SensorDirectChannel.RATE_FAST);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testGyroscopeAshmemFastUidIdle"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testGyroscopeAshmemFastUidIdle() {         runSensorDirectReportUidIdleTest(                 Sensor.TYPE_GYROSCOPE,                 SensorDirectChannel.TYPE_MEMORY_FILE,                 SensorDirectChannel.RATE_FAST);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testMagneticFieldAshmemFast"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testMagneticFieldAshmemFast() {         runSensorDirectReportTest(                 Sensor.TYPE_MAGNETIC_FIELD,                 SensorDirectChannel.TYPE_MEMORY_FILE,                 SensorDirectChannel.RATE_FAST);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testMagneticFieldAshmemFastUidIdle"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testMagneticFieldAshmemFastUidIdle() {         runSensorDirectReportUidIdleTest(                 Sensor.TYPE_MAGNETIC_FIELD,                 SensorDirectChannel.TYPE_MEMORY_FILE,                 SensorDirectChannel.RATE_FAST);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testAccelerometerAshmemVeryFast"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testAccelerometerAshmemVeryFast() {         runSensorDirectReportTest(                 Sensor.TYPE_ACCELEROMETER,                 SensorDirectChannel.TYPE_MEMORY_FILE,                 SensorDirectChannel.RATE_VERY_FAST);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testAccelerometerAshmemVeryFastUidIdle"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testAccelerometerAshmemVeryFastUidIdle() {         runSensorDirectReportUidIdleTest(                 Sensor.TYPE_ACCELEROMETER,                 SensorDirectChannel.TYPE_MEMORY_FILE,                 SensorDirectChannel.RATE_VERY_FAST);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testGyroscopeAshmemVeryFast"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testGyroscopeAshmemVeryFast() {         runSensorDirectReportTest(                 Sensor.TYPE_GYROSCOPE,                 SensorDirectChannel.TYPE_MEMORY_FILE,                 SensorDirectChannel.RATE_VERY_FAST);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testGyroscopeAshmemVeryFastUidIdle"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testGyroscopeAshmemVeryFastUidIdle() {         runSensorDirectReportUidIdleTest(                 Sensor.TYPE_GYROSCOPE,                 SensorDirectChannel.TYPE_MEMORY_FILE,                 SensorDirectChannel.RATE_VERY_FAST);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testMagneticFieldAshmemVeryFast"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testMagneticFieldAshmemVeryFast() {         runSensorDirectReportTest(                 Sensor.TYPE_MAGNETIC_FIELD,                 SensorDirectChannel.TYPE_MEMORY_FILE,                 SensorDirectChannel.RATE_VERY_FAST);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testMagneticFieldAshmemVeryFastUidIdle"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testMagneticFieldAshmemVeryFastUidIdle() {         runSensorDirectReportUidIdleTest(                 Sensor.TYPE_MAGNETIC_FIELD,                 SensorDirectChannel.TYPE_MEMORY_FILE,                 SensorDirectChannel.RATE_VERY_FAST);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testAccelerometerHardwareBufferNormal"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testAccelerometerHardwareBufferNormal() {         runSensorDirectReportTest(                 Sensor.TYPE_ACCELEROMETER,                 SensorDirectChannel.TYPE_HARDWARE_BUFFER,                 SensorDirectChannel.RATE_NORMAL);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testAccelerometerHardwareBufferNormalUidIdle"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testAccelerometerHardwareBufferNormalUidIdle() {         runSensorDirectReportUidIdleTest(                 Sensor.TYPE_ACCELEROMETER,                 SensorDirectChannel.TYPE_HARDWARE_BUFFER,                 SensorDirectChannel.RATE_NORMAL);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testGyroscopeHardwareBufferNormal"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testGyroscopeHardwareBufferNormal() {         runSensorDirectReportTest(                 Sensor.TYPE_GYROSCOPE,                 SensorDirectChannel.TYPE_HARDWARE_BUFFER,                 SensorDirectChannel.RATE_NORMAL);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testGyroscopeHardwareBufferNormalUidIdle"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testGyroscopeHardwareBufferNormalUidIdle() {         runSensorDirectReportUidIdleTest(                 Sensor.TYPE_GYROSCOPE,                 SensorDirectChannel.TYPE_HARDWARE_BUFFER,                 SensorDirectChannel.RATE_NORMAL);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testMagneticFieldHardwareBufferNormal"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testMagneticFieldHardwareBufferNormal() {         runSensorDirectReportTest(                 Sensor.TYPE_MAGNETIC_FIELD,                 SensorDirectChannel.TYPE_HARDWARE_BUFFER,                 SensorDirectChannel.RATE_NORMAL);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testMagneticFieldHardwareBufferNormalUidIdle"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testMagneticFieldHardwareBufferNormalUidIdle() {         runSensorDirectReportUidIdleTest(                 Sensor.TYPE_MAGNETIC_FIELD,                 SensorDirectChannel.TYPE_HARDWARE_BUFFER,                 SensorDirectChannel.RATE_NORMAL);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testAccelerometerHardwareBufferFast"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testAccelerometerHardwareBufferFast() {         runSensorDirectReportTest(                 Sensor.TYPE_ACCELEROMETER,                 SensorDirectChannel.TYPE_HARDWARE_BUFFER,                 SensorDirectChannel.RATE_FAST);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testAccelerometerHardwareBufferFastUidIdle"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testAccelerometerHardwareBufferFastUidIdle() {         runSensorDirectReportUidIdleTest(                 Sensor.TYPE_ACCELEROMETER,                 SensorDirectChannel.TYPE_HARDWARE_BUFFER,                 SensorDirectChannel.RATE_FAST);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testGyroscopeHardwareBufferFast"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testGyroscopeHardwareBufferFast() {         runSensorDirectReportTest(                 Sensor.TYPE_GYROSCOPE,                 SensorDirectChannel.TYPE_HARDWARE_BUFFER,                 SensorDirectChannel.RATE_FAST);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testGyroscopeHardwareBufferFastUidIdle"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testGyroscopeHardwareBufferFastUidIdle() {         runSensorDirectReportUidIdleTest(                 Sensor.TYPE_GYROSCOPE,                 SensorDirectChannel.TYPE_HARDWARE_BUFFER,                 SensorDirectChannel.RATE_FAST);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testMagneticFieldHardwareBufferFast"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testMagneticFieldHardwareBufferFast() {         runSensorDirectReportTest(                 Sensor.TYPE_MAGNETIC_FIELD,                 SensorDirectChannel.TYPE_HARDWARE_BUFFER,                 SensorDirectChannel.RATE_FAST);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testMagneticFieldHardwareBufferFastUidIdle"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testMagneticFieldHardwareBufferFastUidIdle() {         runSensorDirectReportUidIdleTest(                 Sensor.TYPE_MAGNETIC_FIELD,                 SensorDirectChannel.TYPE_HARDWARE_BUFFER,                 SensorDirectChannel.RATE_FAST);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testAccelerometerHardwareBufferVeryFast"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testAccelerometerHardwareBufferVeryFast() {         runSensorDirectReportTest(                 Sensor.TYPE_ACCELEROMETER,                 SensorDirectChannel.TYPE_HARDWARE_BUFFER,                 SensorDirectChannel.RATE_VERY_FAST);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testAccelerometerHardwareBufferVeryFastUidIdle"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testAccelerometerHardwareBufferVeryFastUidIdle() {         runSensorDirectReportUidIdleTest(                 Sensor.TYPE_ACCELEROMETER,                 SensorDirectChannel.TYPE_HARDWARE_BUFFER,                 SensorDirectChannel.RATE_VERY_FAST);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testGyroscopeHardwareBufferVeryFast"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testGyroscopeHardwareBufferVeryFast() {         runSensorDirectReportTest(                 Sensor.TYPE_GYROSCOPE,                 SensorDirectChannel.TYPE_HARDWARE_BUFFER,                 SensorDirectChannel.RATE_VERY_FAST);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testGyroscopeHardwareBufferVeryFastUidIdle"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testGyroscopeHardwareBufferVeryFastUidIdle() {         runSensorDirectReportUidIdleTest(                 Sensor.TYPE_GYROSCOPE,                 SensorDirectChannel.TYPE_HARDWARE_BUFFER,                 SensorDirectChannel.RATE_VERY_FAST);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testMagneticFieldHardwareBufferVeryFast"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testMagneticFieldHardwareBufferVeryFast() {         runSensorDirectReportTest(                 Sensor.TYPE_MAGNETIC_FIELD,                 SensorDirectChannel.TYPE_HARDWARE_BUFFER,                 SensorDirectChannel.RATE_VERY_FAST);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testMagneticFieldHardwareBufferVeryFastUidIdle"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testMagneticFieldHardwareBufferVeryFastUidIdle() {         runSensorDirectReportUidIdleTest(                 Sensor.TYPE_MAGNETIC_FIELD,                 SensorDirectChannel.TYPE_HARDWARE_BUFFER,                 SensorDirectChannel.RATE_VERY_FAST);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testCloseWithoutConfigStop"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testCloseWithoutConfigStop() {         for (int type : POSSIBLE_SENSOR_TYPES) {             for (int memType : POSSIBLE_CHANNEL_TYPES) {                 Sensor s = mSensorManager.getDefaultSensor(type);                 if (s == null                         || s.getHighestDirectReportRateLevel() == SensorDirectChannel.RATE_STOP                         || !s.isDirectChannelTypeSupported(memType)) {                     continue;                 }                  mChannel = prepareDirectChannel(memType, false /* secondary */);                 assertTrue(""createDirectChannel failed"", mChannel != null);                  try {                     waitBeforeStartSensor();                     mChannel.configure(s, s.getHighestDirectReportRateLevel());                      // wait for a while                     waitBeforeStartSensor();                      // The following line is commented out intentionally.                     // mChannel.configure(s, SensorDirectChannel.RATE_STOP);                 } finally {                     mChannel.close();                     mChannel = null;                 }                 waitBeforeStartSensor();             }         }     }      private void runSingleChannelRateIndependencyTestGroup(int type1, int type2) {         if (type1 == type2) {             throw new IllegalArgumentException(""Cannot run single channel rate independency test ""                     + ""on type "" + type1 + "" and "" + type2);         }         String stype1 = SensorCtsHelper.sensorTypeShortString(type1);         String stype2 = SensorCtsHelper.sensorTypeShortString(type2);          TestResultCollector c =                 new TestResultCollector(                     ""testRateIndependency"" + stype1 + stype2 + ""SingleChannel"", TAG);          for (int rate1 : POSSIBLE_RATE_LEVELS) {             for (int rate2 : POSSIBLE_RATE_LEVELS) {                 for (int memType : POSSIBLE_CHANNEL_TYPES) {                     c.perform(                         () -> {                             runSingleChannelRateIndependencyTest(                                     type1, rate1, type2, rate2,                                     SensorDirectChannel.TYPE_MEMORY_FILE);                         },                         String.format(""(%s rate %d, %s rate %d, mem %d)"",                                       stype1, rate1, stype2, rate2, memType));                 }             }         }         c.judge();     }      public void runMultiChannelRateIndependencyTestGroup(int sensorType) {         TestResultCollector c = new TestResultCollector(                 ""testRateIndependency"" + SensorCtsHelper.sensorTypeShortString(sensorType)                     + ""MultiChannel"", TAG);          for (int rate1 : POSSIBLE_RATE_LEVELS) {             for (int rate2 : POSSIBLE_RATE_LEVELS) {                 for (int type1 : POSSIBLE_CHANNEL_TYPES) {                     for (int type2 : POSSIBLE_CHANNEL_TYPES) {                         // only test upper triangle                         if (rate1 > rate2 || type1 > type2) {                             continue;                         }                         c.perform(() -> {                                 runMultiChannelRateIndependencyTest(                                         sensorType, rate1, rate2, type1, type2);},                                 String.format(""rate1 %d, rate2 %d, type1 %d, type2 %d"",                                               rate1, rate2, type1, type2));                     }                 }             }         }         c.judge();     }      public void runMultiModeRateIndependencyTestGroup(int sensorType) {         TestResultCollector c = new TestResultCollector(                 ""testRateIndependency"" + SensorCtsHelper.sensorTypeShortString(sensorType)                     + ""MultiMode"", TAG);          for (int rate : POSSIBLE_RATE_LEVELS) {             for (int type : POSSIBLE_CHANNEL_TYPES) {                 for (int samplingPeriodUs : POSSIBLE_SAMPLE_PERIOD_US) {                     c.perform(() -> {runMultiModeRateIndependencyTest(                                         sensorType, rate, type, samplingPeriodUs);},                               String.format(""rateLevel %d, memType %d, period %d"",                                             rate, type, samplingPeriodUs));                 }             }         }         c.judge();     }      private void runTimestampTestGroup(int sensorType) {         String stype = SensorCtsHelper.sensorTypeShortString(sensorType);          TestResultCollector c =                 new TestResultCollector(""testTimestamp"" + stype, TAG);          for (int rateLevel : POSSIBLE_RATE_LEVELS) {             for (int memType : POSSIBLE_CHANNEL_TYPES) {                 c.perform(                         () -> {                             runTimestampTest(sensorType, rateLevel, memType);                         },                         String.format(""(%s, rate %d, memtype %d)"", stype, rateLevel, memType));             }         }         c.judge();     }      private void runSensorDirectReportTest(int sensorType, int memType, int rateLevel)             throws AssertionError {         Sensor s = mSensorManager.getDefaultSensor(sensorType);         if (s == null                 || s.getHighestDirectReportRateLevel() < rateLevel                 || !s.isDirectChannelTypeSupported(memType)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);          try {             assertTrue(""Shared memory is not formatted"", isSharedMemoryFormatted(memType));             waitBeforeStartSensor();              int token = mChannel.configure(s, rateLevel);             assertTrue(""configure direct mChannel failed"", token > 0);              waitSensorCollection();              //stop sensor and analyze content             mChannel.configure(s, SensorDirectChannel.RATE_STOP);             checkSharedMemoryContent(s, memType, rateLevel, token);         } finally {             mChannel.close();             mChannel = null;         }     }      private void runSensorDirectReportUidIdleTest(int sensorType, int memType, int rateLevel) {         Sensor s = mSensorManager.getDefaultSensor(sensorType);         if (s == null                 || s.getHighestDirectReportRateLevel() < rateLevel                 || !s.isDirectChannelTypeSupported(memType)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);          try {             assertTrue(""Shared memory is not formatted"", isSharedMemoryFormatted(memType));             waitBeforeStartSensor();              int token = mChannel.configure(s, rateLevel);             assertTrue(""configure direct mChannel failed"", token > 0);              // Make package idle and ensure no sensor events are received             try {                 SensorCtsHelper.makeMyPackageIdle();             } catch (IOException e) {                 fail(""IOException while making package idle"");             }              int originalEventSize = mBuffer.length;             waitSensorCollection();              assertEquals(mBuffer.length, originalEventSize);              try {                 SensorCtsHelper.makeMyPackageActive();             } catch (IOException e) {                 fail(""IOException while making package active"");             }              // Also verify sensor events can be received after becoming active.             resetEvent();              waitSensorCollection();              //stop sensor and analyze content             mChannel.configure(s, SensorDirectChannel.RATE_STOP);             checkSharedMemoryContent(s, memType, rateLevel, token);         } finally {             mChannel.close();             mChannel = null;         }     }      private void runSingleChannelRateIndependencyTest(             int type1, int rateLevel1, int type2, int rateLevel2, int memType)                 throws AssertionError {         Sensor s1 = mSensorManager.getDefaultSensor(type1);         Sensor s2 = mSensorManager.getDefaultSensor(type2);         if (s1 == null                 || s1.getHighestDirectReportRateLevel() < rateLevel1                 || !s1.isDirectChannelTypeSupported(memType)) {             return;         }          if (s2 == null                 || s2.getHighestDirectReportRateLevel() < rateLevel2                 || !s2.isDirectChannelTypeSupported(memType)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);          try {             assertTrue(""Shared memory is not formatted"", isSharedMemoryFormatted(memType));             waitBeforeStartSensor();              int token1 = mChannel.configure(s1, rateLevel1);             int token2 = mChannel.configure(s2, rateLevel2);             assertTrue(""configure direct mChannel failed, token1 = "" + token1, token1 > 0);             assertTrue(""configure direct mChannel failed, token2 = "" + token2, token2 > 0);              // run half amount of time so buffer is enough for both sensors             try {                 SensorCtsHelper.sleep(TEST_RUN_TIME_PERIOD_MILLISEC / 2, TimeUnit.MILLISECONDS);             } catch (InterruptedException e) {                 Thread.currentThread().interrupt();             }              //stop sensor and analyze content             mChannel.configure(s1, SensorDirectChannel.RATE_STOP);             mChannel.configure(s2, SensorDirectChannel.RATE_STOP);              readSharedMemory(memType, false /*secondary*/);             checkEventRate(TEST_RUN_TIME_PERIOD_MILLISEC / 2, parseEntireBuffer(mBuffer, token1),                            type1, rateLevel1);             checkEventRate(TEST_RUN_TIME_PERIOD_MILLISEC / 2, parseEntireBuffer(mBuffer, token2),                            type2, rateLevel2);         } finally {             mChannel.close();             mChannel = null;         }     }      private void runMultiChannelRateIndependencyTest(             int type, int rateLevel1, int rateLevel2, int memType1, int memType2)                 throws AssertionError {         Sensor s = mSensorManager.getDefaultSensor(type);         if (s == null                 || s.getHighestDirectReportRateLevel() < Math.max(rateLevel1, rateLevel2)                 || !s.isDirectChannelTypeSupported(memType1)                 || !s.isDirectChannelTypeSupported(memType2)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType1, false /* secondary */);         mChannelSecondary = prepareDirectChannel(memType2, true /* secondary */);          try {             assertTrue(""createDirectChannel failed"", mChannel != null);             assertTrue(""Shared memory is not formatted"",                        isSharedMemoryFormatted(memType1));              assertTrue(""createDirectChannel(secondary) failed"", mChannelSecondary != null);             assertTrue(""Shared memory(secondary) is not formatted"",                        isSharedMemoryFormatted(memType2, true));              waitBeforeStartSensor();              int token1 = mChannel.configure(s, rateLevel1);             int token2 = mChannelSecondary.configure(s, rateLevel2);             assertTrue(""configure direct mChannel failed"", token1 > 0);             assertTrue(""configure direct mChannelSecondary failed"", token2 > 0);              waitSensorCollection();              //stop sensor and analyze content             mChannel.configure(s, SensorDirectChannel.RATE_STOP);             mChannelSecondary.configure(s, SensorDirectChannel.RATE_STOP);              // check rate             readSharedMemory(memType1, false /*secondary*/);             checkEventRate(TEST_RUN_TIME_PERIOD_MILLISEC, parseEntireBuffer(mBuffer, token1),                            type, rateLevel1);              readSharedMemory(memType2, true /*secondary*/);             checkEventRate(TEST_RUN_TIME_PERIOD_MILLISEC, parseEntireBuffer(mBuffer, token2),                            type, rateLevel2);         } finally {             if (mChannel != null) {                 mChannel.close();                 mChannel = null;             }             if (mChannelSecondary != null) {                 mChannelSecondary.close();                 mChannelSecondary = null;             }         }     }      private void runMultiModeRateIndependencyTest(             int type , int rateLevel, int memType, int samplingPeriodUs)                 throws AssertionError {         final Sensor s = mSensorManager.getDefaultSensor(type);         if (s == null                 || s.getHighestDirectReportRateLevel() < rateLevel                 || !s.isDirectChannelTypeSupported(memType)) {             return;         }          if (samplingPeriodUs == 0) {             samplingPeriodUs = s.getMinDelay();         }          if (samplingPeriodUs < s.getMinDelay()) {             return;         }          if (samplingPeriodUs > s.getMaxDelay()) {             samplingPeriodUs = s.getMaxDelay();         }          resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);         SensorEventCollection listener = new SensorEventCollection(s);          try {             waitBeforeStartSensor();             int token = mChannel.configure(s, rateLevel);             boolean registerRet = mSensorManager.registerListener(listener, s, samplingPeriodUs);             assertTrue(""Register listener failed"", registerRet);              waitSensorCollection();              mChannel.configure(s, SensorDirectChannel.RATE_STOP);             mSensorManager.unregisterListener(listener);              // check direct report rate             readSharedMemory(memType, false /*secondary*/);             List<DirectReportSensorEvent> events = parseEntireBuffer(mBuffer, token);             checkEventRate(TEST_RUN_TIME_PERIOD_MILLISEC, events, type, rateLevel);              // check callback interface rate             checkEventRateUs(TEST_RUN_TIME_PERIOD_MILLISEC, listener.getEvents(), type,                              samplingPeriodUs);         } finally {             mChannel.close();             mChannel = null;             mSensorManager.unregisterListener(listener);         }     }      private void runTimestampTest(int type, int rateLevel, int memType) {         Sensor s = mSensorManager.getDefaultSensor(type);         if (s == null                 || s.getHighestDirectReportRateLevel() < rateLevel                 || !s.isDirectChannelTypeSupported(memType)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);          SensorEventCollection listener = new SensorEventCollection(s);          try {             float nominalFreq = getNominalFreq(rateLevel);             int samplingPeriodUs = Math.max((int) (1e6f / nominalFreq), s.getMinDelay());              assertTrue(""Shared memory is not formatted"",                        isSharedMemoryFormatted(memType));              int token = mChannel.configure(s, rateLevel);             assertTrue(""configure direct mChannel failed"", token > 0);              boolean registerRet = mSensorManager.registerListener(listener, s, samplingPeriodUs);             assertTrue(""Register listener failed"", registerRet);              List<DirectReportSensorEvent> events = collectSensorEventsRealtime(                     memType, false /*secondary*/, TEST_RUN_TIME_PERIOD_MILLISEC);             assertTrue(""Realtime event collection failed"", events != null);             assertTrue(""Realtime event collection got no data"", events.size() > 0);              //stop sensor and analyze content             mChannel.configure(s, SensorDirectChannel.RATE_STOP);             mSensorManager.unregisterListener(listener);              // check rate             checkTimestampRelative(events, listener.getEvents());             checkTimestampAbsolute(events);         } finally {             mChannel.close();             mChannel = null;         }     }      private void runAtomicCounterTest(int sensorType, int memType) throws AssertionError {         Sensor s = mSensorManager.getDefaultSensor(sensorType);         if (s == null                 || s.getHighestDirectReportRateLevel() == SensorDirectChannel.RATE_STOP                 || !s.isDirectChannelTypeSupported(memType)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);          try {             assertTrue(""Shared memory is not formatted"", isSharedMemoryFormatted(memType));             waitBeforeStartSensor();              //int token = mChannel.configure(s, SensorDirectChannel.RATE_FAST);             int token = mChannel.configure(s, s.getHighestDirectReportRateLevel());             assertTrue(""configure direct mChannel failed"", token > 0);              checkAtomicCounterUpdate(memType, 30 * 1000); // half min              //stop sensor and analyze content             mChannel.configure(s, SensorDirectChannel.RATE_STOP);         } finally {             mChannel.close();             mChannel = null;         }     }      private void runReconfigureTest(int type, int memType) {         Sensor s = mSensorManager.getDefaultSensor(type);         if (s == null                 || s.getHighestDirectReportRateLevel() == SensorDirectChannel.RATE_STOP                 || !s.isDirectChannelTypeSupported(memType)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);          try {             assertTrue(""Shared memory is not formatted"", isSharedMemoryFormatted(memType));             waitBeforeStartSensor();              int offset = 0;             long counter = 1;             List<Integer> rateLevels = new ArrayList<>();             List<DirectReportSensorEvent> events;              rateLevels.add(s.getHighestDirectReportRateLevel());             rateLevels.add(s.getHighestDirectReportRateLevel());             if (s.getHighestDirectReportRateLevel() != SensorDirectChannel.RATE_NORMAL) {                 rateLevels.add(SensorDirectChannel.RATE_NORMAL);             }              for (int rateLevel : rateLevels) {                 int token = mChannel.configure(s, rateLevel);                 assertTrue(""configure direct mChannel failed"", token > 0);                  events = collectSensorEventsRealtime(memType, false /*secondary*/,                                                      TEST_RUN_TIME_PERIOD_MILLISEC,                                                      offset, counter);                 // stop sensor                 mChannel.configure(s, SensorDirectChannel.RATE_STOP);                 checkEventRate(TEST_RUN_TIME_PERIOD_MILLISEC, events, type, rateLevel);                  // collect all events after stop                 events = collectSensorEventsRealtime(memType, false /*secondary*/,                                                      REST_PERIOD_BEFORE_TEST_MILLISEC,                                                      offset, counter);                 if (events.size() > 0) {                     offset += (events.size() * SENSORS_EVENT_SIZE ) % SHARED_MEMORY_SIZE;                     counter = events.get(events.size() - 1).serial;                 }             }              // finally stop the report             mChannel.configure(s, SensorDirectChannel.RATE_STOP);         } finally {             mChannel.close();             mChannel = null;         }     }      private void waitBeforeStartSensor() {         // wait for sensor system to come to a rest after previous test to avoid flakiness.         try {             SensorCtsHelper.sleep(REST_PERIOD_BEFORE_TEST_MILLISEC, TimeUnit.MILLISECONDS);         } catch (InterruptedException e) {             Thread.currentThread().interrupt();         }     }      private void waitSensorCollection() {         // wait for sensor collection to finish         try {             SensorCtsHelper.sleep(TEST_RUN_TIME_PERIOD_MILLISEC, TimeUnit.MILLISECONDS);         } catch (InterruptedException e) {             Thread.currentThread().interrupt();         }     }      private List<DirectReportSensorEvent> collectSensorEventsRealtime(             int memType, boolean secondary, int timeoutMs) {         return collectSensorEventsRealtime(memType, secondary, timeoutMs,                                           0 /*initialOffset*/, 1l /*initialCounter*/);     }      private List<DirectReportSensorEvent> collectSensorEventsRealtime(             int memType, boolean secondary, int timeoutMs, int initialOffset, long initialCounter) {         List<DirectReportSensorEvent> events = new ArrayList<>();         long endTime = SystemClock.elapsedRealtime() + timeoutMs;          long atomicCounter = initialCounter;         int offset = initialOffset;          long timeA = SystemClock.elapsedRealtimeNanos();         boolean synced = false;         int filtered = 0;          while (SystemClock.elapsedRealtime() < endTime) {             if (!readSharedMemory(                     memType, secondary, offset + ATOMIC_COUNTER_OFFSET, ATOMIC_COUNTER_SIZE)) {                 return null;             }              long timeB = SystemClock.elapsedRealtimeNanos();             if (timeB - timeA > 1_000_000L ) { // > 1ms                 synced = false;             }             timeA = timeB;              if (readAtomicCounter(offset) == atomicCounter) {                 // read entire event again and parse                 if (!readSharedMemory(memType, secondary, offset, SENSORS_EVENT_SIZE)) {                     return null;                 }                 DirectReportSensorEvent e = mEventPool.get();                 assertNotNull(""cannot get event from reserve"", e);                 parseSensorEvent(offset, e);                  atomicCounter += 1;                 if (synced) {                     events.add(e);                 } else {                     ++filtered;                 }                  offset += SENSORS_EVENT_SIZE;                 if (offset + SENSORS_EVENT_SIZE > SHARED_MEMORY_SIZE) {                     offset = 0;                 }             } else {                 synced = true;             }         }         Log.d(TAG, ""filtered "" + filtered + "" events, remain "" + events.size() + "" events"");         return events;     }      private void checkAtomicCounterUpdate(int memType, int timeoutMs) {         List<DirectReportSensorEvent> events = new ArrayList<>();         long endTime = SystemClock.elapsedRealtime() + timeoutMs;          boolean lastValid = false;         long atomicCounter = 1;         int lastOffset = 0;         int offset = 0;          byte[] lastArray = new byte[SENSORS_EVENT_SIZE];         DirectReportSensorEvent e = getEvent();          while (SystemClock.elapsedRealtime() < endTime) {             if (!readSharedMemory(memType, false/*secondary*/, lastOffset, SENSORS_EVENT_SIZE)                     || !readSharedMemory(memType, false/*secondary*/,                                          offset + ATOMIC_COUNTER_OFFSET, ATOMIC_COUNTER_SIZE)) {                 throw new IllegalStateException(""cannot read shared memory, type "" + memType);             }              if (lastValid) {                 boolean failed = false;                 int i;                 for (i = 0; i < SENSORS_EVENT_SIZE; ++i) {                     if (lastArray[i] != mBuffer[lastOffset + i]) {                         failed = true;                         break;                     }                 }                  if (failed) {                     byte[] currentArray = new byte[SENSORS_EVENT_SIZE];                     System.arraycopy(mBuffer, lastOffset, currentArray, 0, SENSORS_EVENT_SIZE);                      // wait for 100ms and read again to see if the change settle                     try {                         SensorCtsHelper.sleep(100, TimeUnit.MILLISECONDS);                     } catch (InterruptedException ex) {                         Thread.currentThread().interrupt();                     }                      byte[] delayedRead = new byte[SENSORS_EVENT_SIZE];                     if (!readSharedMemory(                                 memType, false/*secondary*/, lastOffset, SENSORS_EVENT_SIZE)) {                         throw new IllegalStateException(                                 ""cannot read shared memory, type "" + memType);                     }                     System.arraycopy(mBuffer, lastOffset, delayedRead, 0, SENSORS_EVENT_SIZE);                      fail(String.format(                             ""At offset %d(0x%x), byte %d(0x%x) changed after atomicCounter""                                 + ""(expecting %d, 0x%x) update, old = [%s], new = [%s], ""                                 + ""delayed = [%s]"",                             lastOffset, lastOffset, i, i, atomicCounter, atomicCounter,                             SensorCtsHelper.bytesToHex(lastArray, -1, -1),                             SensorCtsHelper.bytesToHex(currentArray, -1, -1),                             SensorCtsHelper.bytesToHex(delayedRead, -1, -1)));                 }             }              if (readAtomicCounter(offset) == atomicCounter) {                 // read entire event again and parse                 if (!readSharedMemory(memType, false/*secondary*/, offset, SENSORS_EVENT_SIZE)) {                     throw new IllegalStateException(""cannot read shared memory, type "" + memType);                 }                 parseSensorEvent(offset, e);                  atomicCounter += 1;                  lastOffset = offset;                 System.arraycopy(mBuffer, lastOffset, lastArray, 0, SENSORS_EVENT_SIZE);                 lastValid = true;                  offset += SENSORS_EVENT_SIZE;                 if (offset + SENSORS_EVENT_SIZE > SHARED_MEMORY_SIZE) {                     offset = 0;                 }             }         }         Log.d(TAG, ""at finish checkAtomicCounterUpdate has atomic counter = "" + atomicCounter);         // atomicCounter will not wrap back in reasonable amount of time         assertTrue(""Realtime event collection got no data"", atomicCounter != 1);     }      private MemoryFile allocateMemoryFile() {         MemoryFile memFile = null;         try {             memFile = new MemoryFile(""Sensor Channel"", SHARED_MEMORY_SIZE);         } catch (IOException e) {             Log.e(TAG, ""IOException when allocating MemoryFile"");         }         return memFile;     }      private HardwareBuffer allocateHardwareBuffer() {         HardwareBuffer hardwareBuffer;          hardwareBuffer = HardwareBuffer.create(                 SHARED_MEMORY_SIZE, 1 /* height */, HardwareBuffer.BLOB, 1 /* layer */,                 HardwareBuffer.USAGE_CPU_READ_OFTEN | HardwareBuffer.USAGE_GPU_DATA_BUFFER                     | HardwareBuffer.USAGE_SENSOR_DIRECT_DATA);         return hardwareBuffer;     }      private SensorDirectChannel prepareDirectChannel(int memType, boolean secondary) {         SensorDirectChannel channel = null;          try {             switch(memType) {                 case SensorDirectChannel.TYPE_MEMORY_FILE: {                     MemoryFile memoryFile = secondary ? mMemoryFileSecondary : mMemoryFile;                     assertTrue(""MemoryFile"" + (secondary ? ""(secondary)"" : """") + "" is null"",                                memoryFile != null);                     channel = mSensorManager.createDirectChannel(memoryFile);                     break;                 }                 case SensorDirectChannel.TYPE_HARDWARE_BUFFER: {                     HardwareBuffer hardwareBuffer                             = secondary ? mHardwareBufferSecondary : mHardwareBuffer;                     assertTrue(""HardwareBuffer"" + (secondary ? ""(secondary)"" : """") + "" is null"",                                hardwareBuffer != null);                     channel = mSensorManager.createDirectChannel(hardwareBuffer);                     break;                 }                 default:                     Log.e(TAG, ""Specified illegal memory type "" + memType);             }         } catch (IllegalStateException | UncheckedIOException e) {             Log.e(TAG, ""Cannot initialize channel for memory type "" + memType                     + "", details:"" + e);             channel = null;         }         return channel;     }      private boolean readSharedMemory(int memType, boolean secondary, int offset, int length) {         switch(memType) {             case SensorDirectChannel.TYPE_MEMORY_FILE:                 try {                     MemoryFile f = secondary ? mMemoryFileSecondary : mMemoryFile;                     if (f.readBytes(mBuffer, offset, offset, length) != length) {                         Log.e(TAG, ""cannot read entire MemoryFile"");                         return false;                     }                 } catch (IOException e) {                     Log.e(TAG, ""accessing MemoryFile causes IOException"");                     return false;                 }                 return true;             case SensorDirectChannel.TYPE_HARDWARE_BUFFER:                 return nativeReadHardwareBuffer(                         secondary ? mHardwareBufferSecondary : mHardwareBuffer,                         mBuffer, offset, offset, length);             default:                 return false;         }     }      private boolean readSharedMemory(int memType, boolean secondary) {         return readSharedMemory(memType, secondary, 0, SHARED_MEMORY_SIZE);     }      private boolean readSharedMemory(int memType) {         return readSharedMemory(memType, false /*secondary*/);     }      private boolean isMemoryTypeNeeded(int memType) {         List<Sensor> sensorList = mSensorManager.getSensorList(Sensor.TYPE_ALL);         for (Sensor s : sensorList) {             if (s.isDirectChannelTypeSupported(memType)) {                 return true;             }         }         return false;     }      private boolean isSharedMemoryFormatted(int memType) {         return isSharedMemoryFormatted(memType, false /* secondary */);     }      private boolean isSharedMemoryFormatted(int memType, boolean secondary) {         readSharedMemory(memType, secondary);          for (byte b : mBuffer) {             if (b != 0) {                 return false;             }         }         return true;     }      private void checkSharedMemoryContent(Sensor s, int memType, int rateLevel, int token) {         assertTrue(""read mem type "" + memType + "" content failed"", readSharedMemory(memType));          int offset = 0;         int nextSerial = 1;         DirectReportSensorEvent e = getEvent();         while (offset <= SHARED_MEMORY_SIZE - SENSORS_EVENT_SIZE) {             parseSensorEvent(offset, e);              if (e.serial == 0) {                 // reaches end of events                 break;             }              assertTrue(""incorrect size "" + e.size + ""  at offset "" + offset,                     e.size == SENSORS_EVENT_SIZE);             assertTrue(""incorrect token "" + e.token + "" at offset "" + offset,                     e.token == token);             assertTrue(""incorrect serial "" + e.serial + "" at offset "" + offset,                     e.serial == nextSerial);             assertTrue(""incorrect type "" + e.type + "" offset "" + offset,                     e.type == s.getType());              switch(s.getType()) {                 case Sensor.TYPE_ACCELEROMETER:                     double accNorm = Math.sqrt(e.x * e.x + e.y * e.y + e.z * e.z);                     assertTrue(""incorrect gravity norm "" + accNorm + "" at offset "" + offset,                             accNorm < GRAVITY_MAX && accNorm > GRAVITY_MIN);                     break;                 case Sensor.TYPE_GYROSCOPE:                     double gyroNorm = Math.sqrt(e.x * e.x + e.y * e.y + e.z * e.z);                     assertTrue(""gyro norm too large ("" + gyroNorm + "") at offset "" + offset,                             gyroNorm < GYRO_NORM_MAX);                     break;             }              ++nextSerial;             offset += SENSORS_EVENT_SIZE;         }          int nEvents = nextSerial - 1;         float nominalFreq = 0;          switch (rateLevel) {             case SensorDirectChannel.RATE_NORMAL:                 nominalFreq = RATE_NORMAL_NOMINAL;                 break;             case SensorDirectChannel.RATE_FAST:                 nominalFreq = RATE_FAST_NOMINAL;                 break;             case SensorDirectChannel.RATE_VERY_FAST:                 nominalFreq = RATE_VERY_FAST_NOMINAL;                 break;         }          if (nominalFreq != 0) {             int minEvents;             int maxEvents;             minEvents = (int) Math.floor(                     nominalFreq                     * FREQ_LOWER_BOUND                     * (TEST_RUN_TIME_PERIOD_MILLISEC - ALLOWED_SENSOR_INIT_TIME_MILLISEC)                     * (1 - MERCY_FACTOR)                     / 1000);             maxEvents = (int) Math.ceil(                     nominalFreq                     * FREQ_UPPER_BOUND                     * TEST_RUN_TIME_PERIOD_MILLISEC                     * (1 + MERCY_FACTOR)                     / 1000);              assertTrue(""nEvent is "" + nEvents + "" not between "" + minEvents + "" and "" + maxEvents,                     nEvents >= minEvents && nEvents <=maxEvents);         }     }      private void checkEventRate(int testTimeMs, List<DirectReportSensorEvent> events,                                 int type, int rateLevel) {         assertTrue(""insufficient events of type "" + type, events.size() > 1);         for (DirectReportSensorEvent e : events) {             assertTrue(""incorrect type "" + e.type + "" expecting "" + type, e.type == type);         }          // check number of events         int[] minMax = calculateExpectedNEvents(testTimeMs, rateLevel);         assertTrue(                 ""Number of event of type "" + type + "" is "" + events.size()                     + "", which is not in range ["" + minMax[0] + "", "" + minMax[1] + ""]."",                 minMax[0] <= events.size() && events.size() <= minMax[1]);          // intervals         List<Long> intervals = new ArrayList<>(events.size() - 1);         long minInterval = Long.MAX_VALUE;         long maxInterval = Long.MIN_VALUE;         long averageInterval = 0;         for (int i = 1; i < events.size(); ++i) {             long d = events.get(i).ts - events.get(i-1).ts;             averageInterval += d;             minInterval = Math.min(d, minInterval);             maxInterval = Math.max(d, maxInterval);             intervals.add(d);         }         averageInterval /= (events.size() - 1);          // average rate         float averageFreq = 1e9f / averageInterval;         float nominalFreq = getNominalFreq(rateLevel);         Log.d(TAG, String.format(                 ""checkEventRate type %d: averageFreq %f, nominalFreq %f, lbound %f, ubound %f"",                 type, averageFreq, nominalFreq,                 nominalFreq * FREQ_LOWER_BOUND,                 nominalFreq * FREQ_UPPER_BOUND));         assertTrue(""Average frequency of type "" + type + "" rateLevel "" + rateLevel                         + "" is "" + averageFreq,                    nominalFreq * FREQ_LOWER_BOUND * (1 - MERCY_FACTOR) <= averageFreq &&                        averageFreq <= nominalFreq * FREQ_UPPER_BOUND * (1 + MERCY_FACTOR));          // jitter variance         List<Long> percentileValues =                 SensorCtsHelper.getPercentileValue(intervals, 0.025f, (1 - 0.025f));         assertTrue(""Timestamp jitter of type "" + type + "" rateLevel "" + rateLevel + "" is ""                         + (percentileValues.get(1) - percentileValues.get(0) / 1000) + "" us, ""                         + ""while average interval is "" + (averageInterval / 1000) + ""us, over-range"",                    (percentileValues.get(1) - percentileValues.get(0)) / averageInterval < 0.05);         Log.d(TAG, String.format(                 ""checkEventRate type %d, timestamp interval range %f - %f ms, "" +                     ""span %f ms, %.2f%% of averageInterval"",                     type, percentileValues.get(0)/1e6f, percentileValues.get(1)/1e6f,                     (percentileValues.get(1) - percentileValues.get(0))/1e6f,                     (percentileValues.get(1) - percentileValues.get(0)) / averageInterval * 100.f));      }      private void checkEventRateUs(int testTimeMs, List<DirectReportSensorEvent> events,                                   int type, int samplingPeriodUs) {         // samplingPeriodUs must be a valid one advertised by sensor         assertTrue(""insufficient events of type "" + type, events.size() > 1);         for (DirectReportSensorEvent e : events) {             assertTrue(""incorrect type "" + e.type + "" expecting "" + type, e.type == type);         }          // check number of events         int[] minMax = calculateExpectedNEventsUs(testTimeMs, samplingPeriodUs);         assertTrue(                 ""Number of event of type "" + type + "" is "" + events.size()                     + "", which is not in range ["" + minMax[0] + "", "" + minMax[1] + ""]."",                 minMax[0] <= events.size() && events.size() <= minMax[1]);          // intervals         List<Long> intervals = new ArrayList<>(events.size() - 1);         long minInterval = Long.MAX_VALUE;         long maxInterval = Long.MIN_VALUE;         long averageInterval = 0;         for (int i = 1; i < events.size(); ++i) {             long d = events.get(i).ts - events.get(i-1).ts;             averageInterval += d;             minInterval = Math.min(d, minInterval);             maxInterval = Math.max(d, maxInterval);             intervals.add(d);         }         averageInterval /= (events.size() - 1);          // average rate         float averageFreq = 1e9f / averageInterval;         float nominalFreq = 1e6f / samplingPeriodUs;         Log.d(TAG, String.format(                 ""checkEventRateUs type %d: averageFreq %f, nominalFreq %f, lbound %f, ubound %f"",                 type, averageFreq, nominalFreq,                 nominalFreq * FREQ_LOWER_BOUND_POLL,                 nominalFreq * FREQ_UPPER_BOUND_POLL));         assertTrue(""Average frequency of type "" + type                         + "" is "" + averageFreq,                    nominalFreq * FREQ_LOWER_BOUND_POLL * (1 - MERCY_FACTOR) <= averageFreq &&                        averageFreq <= nominalFreq * FREQ_UPPER_BOUND_POLL * (1 + MERCY_FACTOR));          // jitter variance         List<Long> percentileValues =                 SensorCtsHelper.getPercentileValue(intervals, 0.025f, (1 - 0.025f));         assertTrue(""Timestamp jitter of type "" + type + "" is ""                         + (percentileValues.get(1) - percentileValues.get(0) / 1000) + "" us, ""                         + ""while average interval is "" + (averageInterval / 1000) + ""us, over-range"",                    (percentileValues.get(1) - percentileValues.get(0)) / averageInterval < 0.05);         Log.d(TAG, String.format(                 ""checkEventRateUs type %d, timestamp interval range %f - %f ms, "" +                     ""span %f ms, %.2f%% of averageInterval"",                     type, percentileValues.get(0)/1e6f, percentileValues.get(1)/1e6f,                     (percentileValues.get(1) - percentileValues.get(0)) / 1e6f,                     (percentileValues.get(1) - percentileValues.get(0)) / averageInterval * 100.f));     }      private void allocateSharedMemory() {         if (mNeedMemoryFile) {             mMemoryFile = allocateMemoryFile();             mMemoryFileSecondary = allocateMemoryFile();         }          if (mNeedHardwareBuffer) {             mHardwareBuffer = allocateHardwareBuffer();             mHardwareBufferSecondary = allocateHardwareBuffer();         }     }      private void freeSharedMemory() {         if (mMemoryFile != null) {             mMemoryFile.close();             mMemoryFile = null;         }          if (mMemoryFileSecondary != null) {             mMemoryFileSecondary.close();             mMemoryFileSecondary = null;         }          if (mHardwareBuffer != null) {             mHardwareBuffer.close();             mHardwareBuffer = null;         }          if (mHardwareBufferSecondary != null) {             mHardwareBufferSecondary.close();             mHardwareBufferSecondary = null;         }     }      private float getNominalFreq(int rateLevel) {         float nominalFreq = 0;         switch (rateLevel) {             case SensorDirectChannel.RATE_NORMAL:                 nominalFreq = RATE_NORMAL_NOMINAL;                 break;             case SensorDirectChannel.RATE_FAST:                 nominalFreq = RATE_FAST_NOMINAL;                 break;             case SensorDirectChannel.RATE_VERY_FAST:                 nominalFreq = RATE_VERY_FAST_NOMINAL;                 break;         }         return nominalFreq;     }      private int[] calculateExpectedNEvents(int timeMs, int rateLevel) {         int[] minMax = new int[] { -1, Integer.MAX_VALUE };         float nominalFreq = getNominalFreq(rateLevel);         if (nominalFreq != 0) {             // min             if (timeMs > ALLOWED_SENSOR_INIT_TIME_MILLISEC) {                 minMax[0] = (int) Math.floor(                         nominalFreq                         * FREQ_LOWER_BOUND                         * (timeMs - ALLOWED_SENSOR_INIT_TIME_MILLISEC)                         * (1 - MERCY_FACTOR)                         / 1000);             }             // max             minMax[1] = (int) Math.ceil(                     nominalFreq                     * FREQ_UPPER_BOUND                     * timeMs                     * (1 + MERCY_FACTOR)                     / 1000);         }         return minMax;     }      private void checkTimestampAbsolute(List<DirectReportSensorEvent> events) {         final int MAX_DETAIL_ITEM = 10;          StringBuffer buf = new StringBuffer();         int oneMsEarlyCount = 0;         int fiveMsLateCount = 0;         int tenMsLateCount = 0;         int errorCount = 0;          for (int i = 0; i < events.size(); ++i) {             DirectReportSensorEvent e = events.get(i);             long d = e.arrivalTs - e.ts;             boolean oneMsEarly = d < -1000_000;             boolean fiveMsLate = d > 5000_000;             boolean tenMsLate = d > 10_000_000;              if (oneMsEarly || fiveMsLate || tenMsLate) {                 oneMsEarlyCount += oneMsEarly ? 1 : 0;                 fiveMsLateCount += fiveMsLate ? 1 : 0;                 tenMsLateCount += tenMsLate ? 1 : 0;                  if (errorCount++ < MAX_DETAIL_ITEM) {                     buf.append(""["").append(i).append(""] diff = "").append(d / 1e6f).append("" ms; "");                 }             }         }          Log.d(TAG, String.format(""Irregular timestamp, %d, %d, %d out of %d"",                     oneMsEarlyCount, fiveMsLateCount, tenMsLateCount, events.size()));          if (CHECK_ABSOLUTE_LATENCY) {             assertTrue(String.format(                     ""Timestamp error, out of %d events, %d is >1ms early, %d is >5ms late, ""                         + ""%d is >10ms late, details: %s%s"",                         events.size(), oneMsEarlyCount, fiveMsLateCount, tenMsLateCount,                         buf.toString(), errorCount > MAX_DETAIL_ITEM ? ""..."" : """"),                     oneMsEarlyCount == 0                         && fiveMsLateCount <= events.size() / 20                         && tenMsLateCount <= events.size() / 100);         }     }      private void checkTimestampRelative(List<DirectReportSensorEvent> directEvents,                                         List<DirectReportSensorEvent> pollEvents) {         if (directEvents.size() < 10 || pollEvents.size() < 10) {             // cannot check with so few data points             return;         }          long directAverageLatency = 0;         for (DirectReportSensorEvent e : directEvents) {             directAverageLatency += e.arrivalTs - e.ts;         }         directAverageLatency /= directEvents.size();          long pollAverageLatency = 0;         for (DirectReportSensorEvent e : pollEvents) {             pollAverageLatency += e.arrivalTs - e.ts;         }         pollAverageLatency /= pollEvents.size();          Log.d(TAG, String.format(""Direct, poll latency = %f, %f ms"",                 directAverageLatency / 1e6f, pollAverageLatency / 1e6f));         assertTrue(                 String.format(""Direct, poll latency = %f, %f ms, expect direct < poll"",                     directAverageLatency / 1e6f,                     pollAverageLatency / 1e6f),                 directAverageLatency < pollAverageLatency + 1000_000);     }      private int[] calculateExpectedNEventsUs(int timeMs, int samplingPeriodUs) {         int[] minMax = new int[2];         minMax[0] = Math.max((int) Math.floor(                 (timeMs - ALLOWED_SENSOR_INIT_TIME_MILLISEC) * 1000/ samplingPeriodUs), 0);         minMax[1] = (int) Math.ceil(timeMs * 1000 * 2 / samplingPeriodUs);         return minMax;     }      private static class DirectReportSensorEvent {         public int size;         public int token;         public int type;         public long serial;         public long ts;         public float x;         public float y;         public float z;         public long arrivalTs;     };      // EventPool to avoid allocating too many event objects and hitting GC during test     private static class EventPool {         public EventPool(int n) {             mEvents = Arrays.asList(new DirectReportSensorEvent[n]);             for (int i = 0; i < n; ++i) {                 mEvents.set(i, new DirectReportSensorEvent());             }             reset();         }          public synchronized void reset() {             Log.d(TAG, ""Reset EventPool ("" + mIndex + "" events used)"");             mIndex = 0;         }          public synchronized DirectReportSensorEvent get() {             if (mIndex < mEvents.size()) {                 return mEvents.get(mIndex++);             } else {                 throw new IllegalStateException(""EventPool depleted"");             }         }          private List<DirectReportSensorEvent> mEvents;         private int mIndex;     };      private DirectReportSensorEvent getEvent() {         return mEventPool.get();     }      private DirectReportSensorEvent getEvent(DirectReportSensorEvent e) {         DirectReportSensorEvent event = mEventPool.get();         event.size = e.size;         event.token = e.token;         event.type = e.type;         event.serial = e.serial;         event.ts = e.ts;         event.x = e.x;         event.y = e.y;         event.z = e.z;         event.arrivalTs = e.arrivalTs;         return event;     }      private void resetEvent() {         mEventPool.reset();     }      private class SensorEventCollection implements SensorEventListener {         List<DirectReportSensorEvent> mEvents = new ArrayList<>();         Sensor mSensor;          public SensorEventCollection(Sensor s) {             mSensor = s;         }          List<DirectReportSensorEvent> getEvents() {             return mEvents;         }          @Override         public void onSensorChanged(SensorEvent event) {             if (mSensor == null || event.sensor == mSensor) {                 DirectReportSensorEvent e = mEventPool.get();                 e.size = SENSORS_EVENT_SIZE;                 e.token = event.sensor.getType();                 e.type = e.token;                 e.serial = -1;                 e.ts = event.timestamp;                 e.arrivalTs = SystemClock.elapsedRealtimeNanos();                  e.x = event.values[0];                 if (event.values.length > 1) {                     e.y = event.values[1];                 }                 if (event.values.length > 2) {                     e.z = event.values[2];                 }                 mEvents.add(e);             }         }          @Override         public void onAccuracyChanged(Sensor s, int accuracy) {             // do nothing         }     };      private List<DirectReportSensorEvent> parseEntireBuffer(byte[] buffer, int token) {         int offset = 0;         int nextSerial = 1;         List<DirectReportSensorEvent> events = new ArrayList<>();          while (offset <= SHARED_MEMORY_SIZE - SENSORS_EVENT_SIZE) {             DirectReportSensorEvent e = getEvent();             parseSensorEvent(offset, e);              if (e.serial == 0) {                 // reaches end of events                 break;             }              assertTrue(""incorrect size "" + e.size + ""  at offset "" + offset,                     e.size == SENSORS_EVENT_SIZE);             assertTrue(""incorrect serial "" + e.serial + "" at offset "" + offset,                     e.serial == nextSerial);              if (e.token == token) {                 events.add(e);             }              ++nextSerial;             offset += SENSORS_EVENT_SIZE;         }          return events;     }      // parse sensors_event_t from mBuffer and fill information into DirectReportSensorEvent     private void parseSensorEvent(int offset, DirectReportSensorEvent ev) {         mByteBuffer.position(offset);          ev.size = mByteBuffer.getInt();         ev.token = mByteBuffer.getInt();         ev.type = mByteBuffer.getInt();         ev.serial = ((long) mByteBuffer.getInt()) & 0xFFFFFFFFl; // signed=>unsigned         ev.ts = mByteBuffer.getLong();         ev.arrivalTs = SystemClock.elapsedRealtimeNanos();         ev.x = mByteBuffer.getFloat();         ev.y = mByteBuffer.getFloat();         ev.z = mByteBuffer.getFloat();     }      // parse sensors_event_t and fill information into DirectReportSensorEvent     private static void parseSensorEvent(byte [] buf, int offset, DirectReportSensorEvent ev) {         ByteBuffer b = ByteBuffer.wrap(buf, offset, SENSORS_EVENT_SIZE);         b.order(NATIVE_BYTE_ORDER);          ev.size = b.getInt();         ev.token = b.getInt();         ev.type = b.getInt();         ev.serial = ((long) b.getInt()) & 0xFFFFFFFFl; // signed=>unsigned         ev.ts = b.getLong();         ev.arrivalTs = SystemClock.elapsedRealtimeNanos();         ev.x = b.getFloat();         ev.y = b.getFloat();         ev.z = b.getFloat();     }      private long readAtomicCounter(int offset) {         mByteBuffer.position(offset + ATOMIC_COUNTER_OFFSET);         return ((long) mByteBuffer.getInt()) & 0xFFFFFFFFl; // signed => unsigned     }      private static long readAtomicCounter(byte [] buf, int offset) {         ByteBuffer b = ByteBuffer.wrap(buf, offset + ATOMIC_COUNTER_OFFSET, ATOMIC_COUNTER_SIZE);         b.order(ByteOrder.nativeOrder());          return ((long) b.getInt()) & 0xFFFFFFFFl; // signed => unsigned     } }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorDirectReportTest"	"testCloseWithoutConfigStop"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"implement"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testCloseWithoutConfigStop() {         for (int type : POSSIBLE_SENSOR_TYPES) {             for (int memType : POSSIBLE_CHANNEL_TYPES) {                 Sensor s = mSensorManager.getDefaultSensor(type);                 if (s == null                         || s.getHighestDirectReportRateLevel() == SensorDirectChannel.RATE_STOP                         || !s.isDirectChannelTypeSupported(memType)) {                     continue;                 }                  mChannel = prepareDirectChannel(memType, false /* secondary */);                 assertTrue(""createDirectChannel failed"", mChannel != null);                  try {                     waitBeforeStartSensor();                     mChannel.configure(s, s.getHighestDirectReportRateLevel());                      // wait for a while                     waitBeforeStartSensor();                      // The following line is commented out intentionally.                     // mChannel.configure(s, SensorDirectChannel.RATE_STOP);                 } finally {                     mChannel.close();                     mChannel = null;                 }                 waitBeforeStartSensor();             }         }     }      private void runSingleChannelRateIndependencyTestGroup(int type1, int type2) {         if (type1 == type2) {             throw new IllegalArgumentException(""Cannot run single channel rate independency test ""                     + ""on type "" + type1 + "" and "" + type2);         }         String stype1 = SensorCtsHelper.sensorTypeShortString(type1);         String stype2 = SensorCtsHelper.sensorTypeShortString(type2);          TestResultCollector c =                 new TestResultCollector(                     ""testRateIndependency"" + stype1 + stype2 + ""SingleChannel"", TAG);          for (int rate1 : POSSIBLE_RATE_LEVELS) {             for (int rate2 : POSSIBLE_RATE_LEVELS) {                 for (int memType : POSSIBLE_CHANNEL_TYPES) {                     c.perform(                         () -> {                             runSingleChannelRateIndependencyTest(                                     type1, rate1, type2, rate2,                                     SensorDirectChannel.TYPE_MEMORY_FILE);                         },                         String.format(""(%s rate %d, %s rate %d, mem %d)"",                                       stype1, rate1, stype2, rate2, memType));                 }             }         }         c.judge();     }      public void runMultiChannelRateIndependencyTestGroup(int sensorType) {         TestResultCollector c = new TestResultCollector(                 ""testRateIndependency"" + SensorCtsHelper.sensorTypeShortString(sensorType)                     + ""MultiChannel"", TAG);          for (int rate1 : POSSIBLE_RATE_LEVELS) {             for (int rate2 : POSSIBLE_RATE_LEVELS) {                 for (int type1 : POSSIBLE_CHANNEL_TYPES) {                     for (int type2 : POSSIBLE_CHANNEL_TYPES) {                         // only test upper triangle                         if (rate1 > rate2 || type1 > type2) {                             continue;                         }                         c.perform(() -> {                                 runMultiChannelRateIndependencyTest(                                         sensorType, rate1, rate2, type1, type2);},                                 String.format(""rate1 %d, rate2 %d, type1 %d, type2 %d"",                                               rate1, rate2, type1, type2));                     }                 }             }         }         c.judge();     }      public void runMultiModeRateIndependencyTestGroup(int sensorType) {         TestResultCollector c = new TestResultCollector(                 ""testRateIndependency"" + SensorCtsHelper.sensorTypeShortString(sensorType)                     + ""MultiMode"", TAG);          for (int rate : POSSIBLE_RATE_LEVELS) {             for (int type : POSSIBLE_CHANNEL_TYPES) {                 for (int samplingPeriodUs : POSSIBLE_SAMPLE_PERIOD_US) {                     c.perform(() -> {runMultiModeRateIndependencyTest(                                         sensorType, rate, type, samplingPeriodUs);},                               String.format(""rateLevel %d, memType %d, period %d"",                                             rate, type, samplingPeriodUs));                 }             }         }         c.judge();     }      private void runTimestampTestGroup(int sensorType) {         String stype = SensorCtsHelper.sensorTypeShortString(sensorType);          TestResultCollector c =                 new TestResultCollector(""testTimestamp"" + stype, TAG);          for (int rateLevel : POSSIBLE_RATE_LEVELS) {             for (int memType : POSSIBLE_CHANNEL_TYPES) {                 c.perform(                         () -> {                             runTimestampTest(sensorType, rateLevel, memType);                         },                         String.format(""(%s, rate %d, memtype %d)"", stype, rateLevel, memType));             }         }         c.judge();     }      private void runSensorDirectReportTest(int sensorType, int memType, int rateLevel)             throws AssertionError {         Sensor s = mSensorManager.getDefaultSensor(sensorType);         if (s == null                 || s.getHighestDirectReportRateLevel() < rateLevel                 || !s.isDirectChannelTypeSupported(memType)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);          try {             assertTrue(""Shared memory is not formatted"", isSharedMemoryFormatted(memType));             waitBeforeStartSensor();              int token = mChannel.configure(s, rateLevel);             assertTrue(""configure direct mChannel failed"", token > 0);              waitSensorCollection();              //stop sensor and analyze content             mChannel.configure(s, SensorDirectChannel.RATE_STOP);             checkSharedMemoryContent(s, memType, rateLevel, token);         } finally {             mChannel.close();             mChannel = null;         }     }      private void runSensorDirectReportUidIdleTest(int sensorType, int memType, int rateLevel) {         Sensor s = mSensorManager.getDefaultSensor(sensorType);         if (s == null                 || s.getHighestDirectReportRateLevel() < rateLevel                 || !s.isDirectChannelTypeSupported(memType)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);          try {             assertTrue(""Shared memory is not formatted"", isSharedMemoryFormatted(memType));             waitBeforeStartSensor();              int token = mChannel.configure(s, rateLevel);             assertTrue(""configure direct mChannel failed"", token > 0);              // Make package idle and ensure no sensor events are received             try {                 SensorCtsHelper.makeMyPackageIdle();             } catch (IOException e) {                 fail(""IOException while making package idle"");             }              int originalEventSize = mBuffer.length;             waitSensorCollection();              assertEquals(mBuffer.length, originalEventSize);              try {                 SensorCtsHelper.makeMyPackageActive();             } catch (IOException e) {                 fail(""IOException while making package active"");             }              // Also verify sensor events can be received after becoming active.             resetEvent();              waitSensorCollection();              //stop sensor and analyze content             mChannel.configure(s, SensorDirectChannel.RATE_STOP);             checkSharedMemoryContent(s, memType, rateLevel, token);         } finally {             mChannel.close();             mChannel = null;         }     }      private void runSingleChannelRateIndependencyTest(             int type1, int rateLevel1, int type2, int rateLevel2, int memType)                 throws AssertionError {         Sensor s1 = mSensorManager.getDefaultSensor(type1);         Sensor s2 = mSensorManager.getDefaultSensor(type2);         if (s1 == null                 || s1.getHighestDirectReportRateLevel() < rateLevel1                 || !s1.isDirectChannelTypeSupported(memType)) {             return;         }          if (s2 == null                 || s2.getHighestDirectReportRateLevel() < rateLevel2                 || !s2.isDirectChannelTypeSupported(memType)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);          try {             assertTrue(""Shared memory is not formatted"", isSharedMemoryFormatted(memType));             waitBeforeStartSensor();              int token1 = mChannel.configure(s1, rateLevel1);             int token2 = mChannel.configure(s2, rateLevel2);             assertTrue(""configure direct mChannel failed, token1 = "" + token1, token1 > 0);             assertTrue(""configure direct mChannel failed, token2 = "" + token2, token2 > 0);              // run half amount of time so buffer is enough for both sensors             try {                 SensorCtsHelper.sleep(TEST_RUN_TIME_PERIOD_MILLISEC / 2, TimeUnit.MILLISECONDS);             } catch (InterruptedException e) {                 Thread.currentThread().interrupt();             }              //stop sensor and analyze content             mChannel.configure(s1, SensorDirectChannel.RATE_STOP);             mChannel.configure(s2, SensorDirectChannel.RATE_STOP);              readSharedMemory(memType, false /*secondary*/);             checkEventRate(TEST_RUN_TIME_PERIOD_MILLISEC / 2, parseEntireBuffer(mBuffer, token1),                            type1, rateLevel1);             checkEventRate(TEST_RUN_TIME_PERIOD_MILLISEC / 2, parseEntireBuffer(mBuffer, token2),                            type2, rateLevel2);         } finally {             mChannel.close();             mChannel = null;         }     }      private void runMultiChannelRateIndependencyTest(             int type, int rateLevel1, int rateLevel2, int memType1, int memType2)                 throws AssertionError {         Sensor s = mSensorManager.getDefaultSensor(type);         if (s == null                 || s.getHighestDirectReportRateLevel() < Math.max(rateLevel1, rateLevel2)                 || !s.isDirectChannelTypeSupported(memType1)                 || !s.isDirectChannelTypeSupported(memType2)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType1, false /* secondary */);         mChannelSecondary = prepareDirectChannel(memType2, true /* secondary */);          try {             assertTrue(""createDirectChannel failed"", mChannel != null);             assertTrue(""Shared memory is not formatted"",                        isSharedMemoryFormatted(memType1));              assertTrue(""createDirectChannel(secondary) failed"", mChannelSecondary != null);             assertTrue(""Shared memory(secondary) is not formatted"",                        isSharedMemoryFormatted(memType2, true));              waitBeforeStartSensor();              int token1 = mChannel.configure(s, rateLevel1);             int token2 = mChannelSecondary.configure(s, rateLevel2);             assertTrue(""configure direct mChannel failed"", token1 > 0);             assertTrue(""configure direct mChannelSecondary failed"", token2 > 0);              waitSensorCollection();              //stop sensor and analyze content             mChannel.configure(s, SensorDirectChannel.RATE_STOP);             mChannelSecondary.configure(s, SensorDirectChannel.RATE_STOP);              // check rate             readSharedMemory(memType1, false /*secondary*/);             checkEventRate(TEST_RUN_TIME_PERIOD_MILLISEC, parseEntireBuffer(mBuffer, token1),                            type, rateLevel1);              readSharedMemory(memType2, true /*secondary*/);             checkEventRate(TEST_RUN_TIME_PERIOD_MILLISEC, parseEntireBuffer(mBuffer, token2),                            type, rateLevel2);         } finally {             if (mChannel != null) {                 mChannel.close();                 mChannel = null;             }             if (mChannelSecondary != null) {                 mChannelSecondary.close();                 mChannelSecondary = null;             }         }     }      private void runMultiModeRateIndependencyTest(             int type , int rateLevel, int memType, int samplingPeriodUs)                 throws AssertionError {         final Sensor s = mSensorManager.getDefaultSensor(type);         if (s == null                 || s.getHighestDirectReportRateLevel() < rateLevel                 || !s.isDirectChannelTypeSupported(memType)) {             return;         }          if (samplingPeriodUs == 0) {             samplingPeriodUs = s.getMinDelay();         }          if (samplingPeriodUs < s.getMinDelay()) {             return;         }          if (samplingPeriodUs > s.getMaxDelay()) {             samplingPeriodUs = s.getMaxDelay();         }          resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);         SensorEventCollection listener = new SensorEventCollection(s);          try {             waitBeforeStartSensor();             int token = mChannel.configure(s, rateLevel);             boolean registerRet = mSensorManager.registerListener(listener, s, samplingPeriodUs);             assertTrue(""Register listener failed"", registerRet);              waitSensorCollection();              mChannel.configure(s, SensorDirectChannel.RATE_STOP);             mSensorManager.unregisterListener(listener);              // check direct report rate             readSharedMemory(memType, false /*secondary*/);             List<DirectReportSensorEvent> events = parseEntireBuffer(mBuffer, token);             checkEventRate(TEST_RUN_TIME_PERIOD_MILLISEC, events, type, rateLevel);              // check callback interface rate             checkEventRateUs(TEST_RUN_TIME_PERIOD_MILLISEC, listener.getEvents(), type,                              samplingPeriodUs);         } finally {             mChannel.close();             mChannel = null;             mSensorManager.unregisterListener(listener);         }     }      private void runTimestampTest(int type, int rateLevel, int memType) {         Sensor s = mSensorManager.getDefaultSensor(type);         if (s == null                 || s.getHighestDirectReportRateLevel() < rateLevel                 || !s.isDirectChannelTypeSupported(memType)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);          SensorEventCollection listener = new SensorEventCollection(s);          try {             float nominalFreq = getNominalFreq(rateLevel);             int samplingPeriodUs = Math.max((int) (1e6f / nominalFreq), s.getMinDelay());              assertTrue(""Shared memory is not formatted"",                        isSharedMemoryFormatted(memType));              int token = mChannel.configure(s, rateLevel);             assertTrue(""configure direct mChannel failed"", token > 0);              boolean registerRet = mSensorManager.registerListener(listener, s, samplingPeriodUs);             assertTrue(""Register listener failed"", registerRet);              List<DirectReportSensorEvent> events = collectSensorEventsRealtime(                     memType, false /*secondary*/, TEST_RUN_TIME_PERIOD_MILLISEC);             assertTrue(""Realtime event collection failed"", events != null);             assertTrue(""Realtime event collection got no data"", events.size() > 0);              //stop sensor and analyze content             mChannel.configure(s, SensorDirectChannel.RATE_STOP);             mSensorManager.unregisterListener(listener);              // check rate             checkTimestampRelative(events, listener.getEvents());             checkTimestampAbsolute(events);         } finally {             mChannel.close();             mChannel = null;         }     }      private void runAtomicCounterTest(int sensorType, int memType) throws AssertionError {         Sensor s = mSensorManager.getDefaultSensor(sensorType);         if (s == null                 || s.getHighestDirectReportRateLevel() == SensorDirectChannel.RATE_STOP                 || !s.isDirectChannelTypeSupported(memType)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);          try {             assertTrue(""Shared memory is not formatted"", isSharedMemoryFormatted(memType));             waitBeforeStartSensor();              //int token = mChannel.configure(s, SensorDirectChannel.RATE_FAST);             int token = mChannel.configure(s, s.getHighestDirectReportRateLevel());             assertTrue(""configure direct mChannel failed"", token > 0);              checkAtomicCounterUpdate(memType, 30 * 1000); // half min              //stop sensor and analyze content             mChannel.configure(s, SensorDirectChannel.RATE_STOP);         } finally {             mChannel.close();             mChannel = null;         }     }      private void runReconfigureTest(int type, int memType) {         Sensor s = mSensorManager.getDefaultSensor(type);         if (s == null                 || s.getHighestDirectReportRateLevel() == SensorDirectChannel.RATE_STOP                 || !s.isDirectChannelTypeSupported(memType)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);          try {             assertTrue(""Shared memory is not formatted"", isSharedMemoryFormatted(memType));             waitBeforeStartSensor();              int offset = 0;             long counter = 1;             List<Integer> rateLevels = new ArrayList<>();             List<DirectReportSensorEvent> events;              rateLevels.add(s.getHighestDirectReportRateLevel());             rateLevels.add(s.getHighestDirectReportRateLevel());             if (s.getHighestDirectReportRateLevel() != SensorDirectChannel.RATE_NORMAL) {                 rateLevels.add(SensorDirectChannel.RATE_NORMAL);             }              for (int rateLevel : rateLevels) {                 int token = mChannel.configure(s, rateLevel);                 assertTrue(""configure direct mChannel failed"", token > 0);                  events = collectSensorEventsRealtime(memType, false /*secondary*/,                                                      TEST_RUN_TIME_PERIOD_MILLISEC,                                                      offset, counter);                 // stop sensor                 mChannel.configure(s, SensorDirectChannel.RATE_STOP);                 checkEventRate(TEST_RUN_TIME_PERIOD_MILLISEC, events, type, rateLevel);                  // collect all events after stop                 events = collectSensorEventsRealtime(memType, false /*secondary*/,                                                      REST_PERIOD_BEFORE_TEST_MILLISEC,                                                      offset, counter);                 if (events.size() > 0) {                     offset += (events.size() * SENSORS_EVENT_SIZE ) % SHARED_MEMORY_SIZE;                     counter = events.get(events.size() - 1).serial;                 }             }              // finally stop the report             mChannel.configure(s, SensorDirectChannel.RATE_STOP);         } finally {             mChannel.close();             mChannel = null;         }     }      private void waitBeforeStartSensor() {         // wait for sensor system to come to a rest after previous test to avoid flakiness.         try {             SensorCtsHelper.sleep(REST_PERIOD_BEFORE_TEST_MILLISEC, TimeUnit.MILLISECONDS);         } catch (InterruptedException e) {             Thread.currentThread().interrupt();         }     }      private void waitSensorCollection() {         // wait for sensor collection to finish         try {             SensorCtsHelper.sleep(TEST_RUN_TIME_PERIOD_MILLISEC, TimeUnit.MILLISECONDS);         } catch (InterruptedException e) {             Thread.currentThread().interrupt();         }     }      private List<DirectReportSensorEvent> collectSensorEventsRealtime(             int memType, boolean secondary, int timeoutMs) {         return collectSensorEventsRealtime(memType, secondary, timeoutMs,                                           0 /*initialOffset*/, 1l /*initialCounter*/);     }      private List<DirectReportSensorEvent> collectSensorEventsRealtime(             int memType, boolean secondary, int timeoutMs, int initialOffset, long initialCounter) {         List<DirectReportSensorEvent> events = new ArrayList<>();         long endTime = SystemClock.elapsedRealtime() + timeoutMs;          long atomicCounter = initialCounter;         int offset = initialOffset;          long timeA = SystemClock.elapsedRealtimeNanos();         boolean synced = false;         int filtered = 0;          while (SystemClock.elapsedRealtime() < endTime) {             if (!readSharedMemory(                     memType, secondary, offset + ATOMIC_COUNTER_OFFSET, ATOMIC_COUNTER_SIZE)) {                 return null;             }              long timeB = SystemClock.elapsedRealtimeNanos();             if (timeB - timeA > 1_000_000L ) { // > 1ms                 synced = false;             }             timeA = timeB;              if (readAtomicCounter(offset) == atomicCounter) {                 // read entire event again and parse                 if (!readSharedMemory(memType, secondary, offset, SENSORS_EVENT_SIZE)) {                     return null;                 }                 DirectReportSensorEvent e = mEventPool.get();                 assertNotNull(""cannot get event from reserve"", e);                 parseSensorEvent(offset, e);                  atomicCounter += 1;                 if (synced) {                     events.add(e);                 } else {                     ++filtered;                 }                  offset += SENSORS_EVENT_SIZE;                 if (offset + SENSORS_EVENT_SIZE > SHARED_MEMORY_SIZE) {                     offset = 0;                 }             } else {                 synced = true;             }         }         Log.d(TAG, ""filtered "" + filtered + "" events, remain "" + events.size() + "" events"");         return events;     }      private void checkAtomicCounterUpdate(int memType, int timeoutMs) {         List<DirectReportSensorEvent> events = new ArrayList<>();         long endTime = SystemClock.elapsedRealtime() + timeoutMs;          boolean lastValid = false;         long atomicCounter = 1;         int lastOffset = 0;         int offset = 0;          byte[] lastArray = new byte[SENSORS_EVENT_SIZE];         DirectReportSensorEvent e = getEvent();          while (SystemClock.elapsedRealtime() < endTime) {             if (!readSharedMemory(memType, false/*secondary*/, lastOffset, SENSORS_EVENT_SIZE)                     || !readSharedMemory(memType, false/*secondary*/,                                          offset + ATOMIC_COUNTER_OFFSET, ATOMIC_COUNTER_SIZE)) {                 throw new IllegalStateException(""cannot read shared memory, type "" + memType);             }              if (lastValid) {                 boolean failed = false;                 int i;                 for (i = 0; i < SENSORS_EVENT_SIZE; ++i) {                     if (lastArray[i] != mBuffer[lastOffset + i]) {                         failed = true;                         break;                     }                 }                  if (failed) {                     byte[] currentArray = new byte[SENSORS_EVENT_SIZE];                     System.arraycopy(mBuffer, lastOffset, currentArray, 0, SENSORS_EVENT_SIZE);                      // wait for 100ms and read again to see if the change settle                     try {                         SensorCtsHelper.sleep(100, TimeUnit.MILLISECONDS);                     } catch (InterruptedException ex) {                         Thread.currentThread().interrupt();                     }                      byte[] delayedRead = new byte[SENSORS_EVENT_SIZE];                     if (!readSharedMemory(                                 memType, false/*secondary*/, lastOffset, SENSORS_EVENT_SIZE)) {                         throw new IllegalStateException(                                 ""cannot read shared memory, type "" + memType);                     }                     System.arraycopy(mBuffer, lastOffset, delayedRead, 0, SENSORS_EVENT_SIZE);                      fail(String.format(                             ""At offset %d(0x%x), byte %d(0x%x) changed after atomicCounter""                                 + ""(expecting %d, 0x%x) update, old = [%s], new = [%s], ""                                 + ""delayed = [%s]"",                             lastOffset, lastOffset, i, i, atomicCounter, atomicCounter,                             SensorCtsHelper.bytesToHex(lastArray, -1, -1),                             SensorCtsHelper.bytesToHex(currentArray, -1, -1),                             SensorCtsHelper.bytesToHex(delayedRead, -1, -1)));                 }             }              if (readAtomicCounter(offset) == atomicCounter) {                 // read entire event again and parse                 if (!readSharedMemory(memType, false/*secondary*/, offset, SENSORS_EVENT_SIZE)) {                     throw new IllegalStateException(""cannot read shared memory, type "" + memType);                 }                 parseSensorEvent(offset, e);                  atomicCounter += 1;                  lastOffset = offset;                 System.arraycopy(mBuffer, lastOffset, lastArray, 0, SENSORS_EVENT_SIZE);                 lastValid = true;                  offset += SENSORS_EVENT_SIZE;                 if (offset + SENSORS_EVENT_SIZE > SHARED_MEMORY_SIZE) {                     offset = 0;                 }             }         }         Log.d(TAG, ""at finish checkAtomicCounterUpdate has atomic counter = "" + atomicCounter);         // atomicCounter will not wrap back in reasonable amount of time         assertTrue(""Realtime event collection got no data"", atomicCounter != 1);     }      private MemoryFile allocateMemoryFile() {         MemoryFile memFile = null;         try {             memFile = new MemoryFile(""Sensor Channel"", SHARED_MEMORY_SIZE);         } catch (IOException e) {             Log.e(TAG, ""IOException when allocating MemoryFile"");         }         return memFile;     }      private HardwareBuffer allocateHardwareBuffer() {         HardwareBuffer hardwareBuffer;          hardwareBuffer = HardwareBuffer.create(                 SHARED_MEMORY_SIZE, 1 /* height */, HardwareBuffer.BLOB, 1 /* layer */,                 HardwareBuffer.USAGE_CPU_READ_OFTEN | HardwareBuffer.USAGE_GPU_DATA_BUFFER                     | HardwareBuffer.USAGE_SENSOR_DIRECT_DATA);         return hardwareBuffer;     }      private SensorDirectChannel prepareDirectChannel(int memType, boolean secondary) {         SensorDirectChannel channel = null;          try {             switch(memType) {                 case SensorDirectChannel.TYPE_MEMORY_FILE: {                     MemoryFile memoryFile = secondary ? mMemoryFileSecondary : mMemoryFile;                     assertTrue(""MemoryFile"" + (secondary ? ""(secondary)"" : """") + "" is null"",                                memoryFile != null);                     channel = mSensorManager.createDirectChannel(memoryFile);                     break;                 }                 case SensorDirectChannel.TYPE_HARDWARE_BUFFER: {                     HardwareBuffer hardwareBuffer                             = secondary ? mHardwareBufferSecondary : mHardwareBuffer;                     assertTrue(""HardwareBuffer"" + (secondary ? ""(secondary)"" : """") + "" is null"",                                hardwareBuffer != null);                     channel = mSensorManager.createDirectChannel(hardwareBuffer);                     break;                 }                 default:                     Log.e(TAG, ""Specified illegal memory type "" + memType);             }         } catch (IllegalStateException | UncheckedIOException e) {             Log.e(TAG, ""Cannot initialize channel for memory type "" + memType                     + "", details:"" + e);             channel = null;         }         return channel;     }      private boolean readSharedMemory(int memType, boolean secondary, int offset, int length) {         switch(memType) {             case SensorDirectChannel.TYPE_MEMORY_FILE:                 try {                     MemoryFile f = secondary ? mMemoryFileSecondary : mMemoryFile;                     if (f.readBytes(mBuffer, offset, offset, length) != length) {                         Log.e(TAG, ""cannot read entire MemoryFile"");                         return false;                     }                 } catch (IOException e) {                     Log.e(TAG, ""accessing MemoryFile causes IOException"");                     return false;                 }                 return true;             case SensorDirectChannel.TYPE_HARDWARE_BUFFER:                 return nativeReadHardwareBuffer(                         secondary ? mHardwareBufferSecondary : mHardwareBuffer,                         mBuffer, offset, offset, length);             default:                 return false;         }     }      private boolean readSharedMemory(int memType, boolean secondary) {         return readSharedMemory(memType, secondary, 0, SHARED_MEMORY_SIZE);     }      private boolean readSharedMemory(int memType) {         return readSharedMemory(memType, false /*secondary*/);     }      private boolean isMemoryTypeNeeded(int memType) {         List<Sensor> sensorList = mSensorManager.getSensorList(Sensor.TYPE_ALL);         for (Sensor s : sensorList) {             if (s.isDirectChannelTypeSupported(memType)) {                 return true;             }         }         return false;     }      private boolean isSharedMemoryFormatted(int memType) {         return isSharedMemoryFormatted(memType, false /* secondary */);     }      private boolean isSharedMemoryFormatted(int memType, boolean secondary) {         readSharedMemory(memType, secondary);          for (byte b : mBuffer) {             if (b != 0) {                 return false;             }         }         return true;     }      private void checkSharedMemoryContent(Sensor s, int memType, int rateLevel, int token) {         assertTrue(""read mem type "" + memType + "" content failed"", readSharedMemory(memType));          int offset = 0;         int nextSerial = 1;         DirectReportSensorEvent e = getEvent();         while (offset <= SHARED_MEMORY_SIZE - SENSORS_EVENT_SIZE) {             parseSensorEvent(offset, e);              if (e.serial == 0) {                 // reaches end of events                 break;             }              assertTrue(""incorrect size "" + e.size + ""  at offset "" + offset,                     e.size == SENSORS_EVENT_SIZE);             assertTrue(""incorrect token "" + e.token + "" at offset "" + offset,                     e.token == token);             assertTrue(""incorrect serial "" + e.serial + "" at offset "" + offset,                     e.serial == nextSerial);             assertTrue(""incorrect type "" + e.type + "" offset "" + offset,                     e.type == s.getType());              switch(s.getType()) {                 case Sensor.TYPE_ACCELEROMETER:                     double accNorm = Math.sqrt(e.x * e.x + e.y * e.y + e.z * e.z);                     assertTrue(""incorrect gravity norm "" + accNorm + "" at offset "" + offset,                             accNorm < GRAVITY_MAX && accNorm > GRAVITY_MIN);                     break;                 case Sensor.TYPE_GYROSCOPE:                     double gyroNorm = Math.sqrt(e.x * e.x + e.y * e.y + e.z * e.z);                     assertTrue(""gyro norm too large ("" + gyroNorm + "") at offset "" + offset,                             gyroNorm < GYRO_NORM_MAX);                     break;             }              ++nextSerial;             offset += SENSORS_EVENT_SIZE;         }          int nEvents = nextSerial - 1;         float nominalFreq = 0;          switch (rateLevel) {             case SensorDirectChannel.RATE_NORMAL:                 nominalFreq = RATE_NORMAL_NOMINAL;                 break;             case SensorDirectChannel.RATE_FAST:                 nominalFreq = RATE_FAST_NOMINAL;                 break;             case SensorDirectChannel.RATE_VERY_FAST:                 nominalFreq = RATE_VERY_FAST_NOMINAL;                 break;         }          if (nominalFreq != 0) {             int minEvents;             int maxEvents;             minEvents = (int) Math.floor(                     nominalFreq                     * FREQ_LOWER_BOUND                     * (TEST_RUN_TIME_PERIOD_MILLISEC - ALLOWED_SENSOR_INIT_TIME_MILLISEC)                     * (1 - MERCY_FACTOR)                     / 1000);             maxEvents = (int) Math.ceil(                     nominalFreq                     * FREQ_UPPER_BOUND                     * TEST_RUN_TIME_PERIOD_MILLISEC                     * (1 + MERCY_FACTOR)                     / 1000);              assertTrue(""nEvent is "" + nEvents + "" not between "" + minEvents + "" and "" + maxEvents,                     nEvents >= minEvents && nEvents <=maxEvents);         }     }      private void checkEventRate(int testTimeMs, List<DirectReportSensorEvent> events,                                 int type, int rateLevel) {         assertTrue(""insufficient events of type "" + type, events.size() > 1);         for (DirectReportSensorEvent e : events) {             assertTrue(""incorrect type "" + e.type + "" expecting "" + type, e.type == type);         }          // check number of events         int[] minMax = calculateExpectedNEvents(testTimeMs, rateLevel);         assertTrue(                 ""Number of event of type "" + type + "" is "" + events.size()                     + "", which is not in range ["" + minMax[0] + "", "" + minMax[1] + ""]."",                 minMax[0] <= events.size() && events.size() <= minMax[1]);          // intervals         List<Long> intervals = new ArrayList<>(events.size() - 1);         long minInterval = Long.MAX_VALUE;         long maxInterval = Long.MIN_VALUE;         long averageInterval = 0;         for (int i = 1; i < events.size(); ++i) {             long d = events.get(i).ts - events.get(i-1).ts;             averageInterval += d;             minInterval = Math.min(d, minInterval);             maxInterval = Math.max(d, maxInterval);             intervals.add(d);         }         averageInterval /= (events.size() - 1);          // average rate         float averageFreq = 1e9f / averageInterval;         float nominalFreq = getNominalFreq(rateLevel);         Log.d(TAG, String.format(                 ""checkEventRate type %d: averageFreq %f, nominalFreq %f, lbound %f, ubound %f"",                 type, averageFreq, nominalFreq,                 nominalFreq * FREQ_LOWER_BOUND,                 nominalFreq * FREQ_UPPER_BOUND));         assertTrue(""Average frequency of type "" + type + "" rateLevel "" + rateLevel                         + "" is "" + averageFreq,                    nominalFreq * FREQ_LOWER_BOUND * (1 - MERCY_FACTOR) <= averageFreq &&                        averageFreq <= nominalFreq * FREQ_UPPER_BOUND * (1 + MERCY_FACTOR));          // jitter variance         List<Long> percentileValues =                 SensorCtsHelper.getPercentileValue(intervals, 0.025f, (1 - 0.025f));         assertTrue(""Timestamp jitter of type "" + type + "" rateLevel "" + rateLevel + "" is ""                         + (percentileValues.get(1) - percentileValues.get(0) / 1000) + "" us, ""                         + ""while average interval is "" + (averageInterval / 1000) + ""us, over-range"",                    (percentileValues.get(1) - percentileValues.get(0)) / averageInterval < 0.05);         Log.d(TAG, String.format(                 ""checkEventRate type %d, timestamp interval range %f - %f ms, "" +                     ""span %f ms, %.2f%% of averageInterval"",                     type, percentileValues.get(0)/1e6f, percentileValues.get(1)/1e6f,                     (percentileValues.get(1) - percentileValues.get(0))/1e6f,                     (percentileValues.get(1) - percentileValues.get(0)) / averageInterval * 100.f));      }      private void checkEventRateUs(int testTimeMs, List<DirectReportSensorEvent> events,                                   int type, int samplingPeriodUs) {         // samplingPeriodUs must be a valid one advertised by sensor         assertTrue(""insufficient events of type "" + type, events.size() > 1);         for (DirectReportSensorEvent e : events) {             assertTrue(""incorrect type "" + e.type + "" expecting "" + type, e.type == type);         }          // check number of events         int[] minMax = calculateExpectedNEventsUs(testTimeMs, samplingPeriodUs);         assertTrue(                 ""Number of event of type "" + type + "" is "" + events.size()                     + "", which is not in range ["" + minMax[0] + "", "" + minMax[1] + ""]."",                 minMax[0] <= events.size() && events.size() <= minMax[1]);          // intervals         List<Long> intervals = new ArrayList<>(events.size() - 1);         long minInterval = Long.MAX_VALUE;         long maxInterval = Long.MIN_VALUE;         long averageInterval = 0;         for (int i = 1; i < events.size(); ++i) {             long d = events.get(i).ts - events.get(i-1).ts;             averageInterval += d;             minInterval = Math.min(d, minInterval);             maxInterval = Math.max(d, maxInterval);             intervals.add(d);         }         averageInterval /= (events.size() - 1);          // average rate         float averageFreq = 1e9f / averageInterval;         float nominalFreq = 1e6f / samplingPeriodUs;         Log.d(TAG, String.format(                 ""checkEventRateUs type %d: averageFreq %f, nominalFreq %f, lbound %f, ubound %f"",                 type, averageFreq, nominalFreq,                 nominalFreq * FREQ_LOWER_BOUND_POLL,                 nominalFreq * FREQ_UPPER_BOUND_POLL));         assertTrue(""Average frequency of type "" + type                         + "" is "" + averageFreq,                    nominalFreq * FREQ_LOWER_BOUND_POLL * (1 - MERCY_FACTOR) <= averageFreq &&                        averageFreq <= nominalFreq * FREQ_UPPER_BOUND_POLL * (1 + MERCY_FACTOR));          // jitter variance         List<Long> percentileValues =                 SensorCtsHelper.getPercentileValue(intervals, 0.025f, (1 - 0.025f));         assertTrue(""Timestamp jitter of type "" + type + "" is ""                         + (percentileValues.get(1) - percentileValues.get(0) / 1000) + "" us, ""                         + ""while average interval is "" + (averageInterval / 1000) + ""us, over-range"",                    (percentileValues.get(1) - percentileValues.get(0)) / averageInterval < 0.05);         Log.d(TAG, String.format(                 ""checkEventRateUs type %d, timestamp interval range %f - %f ms, "" +                     ""span %f ms, %.2f%% of averageInterval"",                     type, percentileValues.get(0)/1e6f, percentileValues.get(1)/1e6f,                     (percentileValues.get(1) - percentileValues.get(0)) / 1e6f,                     (percentileValues.get(1) - percentileValues.get(0)) / averageInterval * 100.f));     }      private void allocateSharedMemory() {         if (mNeedMemoryFile) {             mMemoryFile = allocateMemoryFile();             mMemoryFileSecondary = allocateMemoryFile();         }          if (mNeedHardwareBuffer) {             mHardwareBuffer = allocateHardwareBuffer();             mHardwareBufferSecondary = allocateHardwareBuffer();         }     }      private void freeSharedMemory() {         if (mMemoryFile != null) {             mMemoryFile.close();             mMemoryFile = null;         }          if (mMemoryFileSecondary != null) {             mMemoryFileSecondary.close();             mMemoryFileSecondary = null;         }          if (mHardwareBuffer != null) {             mHardwareBuffer.close();             mHardwareBuffer = null;         }          if (mHardwareBufferSecondary != null) {             mHardwareBufferSecondary.close();             mHardwareBufferSecondary = null;         }     }      private float getNominalFreq(int rateLevel) {         float nominalFreq = 0;         switch (rateLevel) {             case SensorDirectChannel.RATE_NORMAL:                 nominalFreq = RATE_NORMAL_NOMINAL;                 break;             case SensorDirectChannel.RATE_FAST:                 nominalFreq = RATE_FAST_NOMINAL;                 break;             case SensorDirectChannel.RATE_VERY_FAST:                 nominalFreq = RATE_VERY_FAST_NOMINAL;                 break;         }         return nominalFreq;     }      private int[] calculateExpectedNEvents(int timeMs, int rateLevel) {         int[] minMax = new int[] { -1, Integer.MAX_VALUE };         float nominalFreq = getNominalFreq(rateLevel);         if (nominalFreq != 0) {             // min             if (timeMs > ALLOWED_SENSOR_INIT_TIME_MILLISEC) {                 minMax[0] = (int) Math.floor(                         nominalFreq                         * FREQ_LOWER_BOUND                         * (timeMs - ALLOWED_SENSOR_INIT_TIME_MILLISEC)                         * (1 - MERCY_FACTOR)                         / 1000);             }             // max             minMax[1] = (int) Math.ceil(                     nominalFreq                     * FREQ_UPPER_BOUND                     * timeMs                     * (1 + MERCY_FACTOR)                     / 1000);         }         return minMax;     }      private void checkTimestampAbsolute(List<DirectReportSensorEvent> events) {         final int MAX_DETAIL_ITEM = 10;          StringBuffer buf = new StringBuffer();         int oneMsEarlyCount = 0;         int fiveMsLateCount = 0;         int tenMsLateCount = 0;         int errorCount = 0;          for (int i = 0; i < events.size(); ++i) {             DirectReportSensorEvent e = events.get(i);             long d = e.arrivalTs - e.ts;             boolean oneMsEarly = d < -1000_000;             boolean fiveMsLate = d > 5000_000;             boolean tenMsLate = d > 10_000_000;              if (oneMsEarly || fiveMsLate || tenMsLate) {                 oneMsEarlyCount += oneMsEarly ? 1 : 0;                 fiveMsLateCount += fiveMsLate ? 1 : 0;                 tenMsLateCount += tenMsLate ? 1 : 0;                  if (errorCount++ < MAX_DETAIL_ITEM) {                     buf.append(""["").append(i).append(""] diff = "").append(d / 1e6f).append("" ms; "");                 }             }         }          Log.d(TAG, String.format(""Irregular timestamp, %d, %d, %d out of %d"",                     oneMsEarlyCount, fiveMsLateCount, tenMsLateCount, events.size()));          if (CHECK_ABSOLUTE_LATENCY) {             assertTrue(String.format(                     ""Timestamp error, out of %d events, %d is >1ms early, %d is >5ms late, ""                         + ""%d is >10ms late, details: %s%s"",                         events.size(), oneMsEarlyCount, fiveMsLateCount, tenMsLateCount,                         buf.toString(), errorCount > MAX_DETAIL_ITEM ? ""..."" : """"),                     oneMsEarlyCount == 0                         && fiveMsLateCount <= events.size() / 20                         && tenMsLateCount <= events.size() / 100);         }     }      private void checkTimestampRelative(List<DirectReportSensorEvent> directEvents,                                         List<DirectReportSensorEvent> pollEvents) {         if (directEvents.size() < 10 || pollEvents.size() < 10) {             // cannot check with so few data points             return;         }          long directAverageLatency = 0;         for (DirectReportSensorEvent e : directEvents) {             directAverageLatency += e.arrivalTs - e.ts;         }         directAverageLatency /= directEvents.size();          long pollAverageLatency = 0;         for (DirectReportSensorEvent e : pollEvents) {             pollAverageLatency += e.arrivalTs - e.ts;         }         pollAverageLatency /= pollEvents.size();          Log.d(TAG, String.format(""Direct, poll latency = %f, %f ms"",                 directAverageLatency / 1e6f, pollAverageLatency / 1e6f));         assertTrue(                 String.format(""Direct, poll latency = %f, %f ms, expect direct < poll"",                     directAverageLatency / 1e6f,                     pollAverageLatency / 1e6f),                 directAverageLatency < pollAverageLatency + 1000_000);     }      private int[] calculateExpectedNEventsUs(int timeMs, int samplingPeriodUs) {         int[] minMax = new int[2];         minMax[0] = Math.max((int) Math.floor(                 (timeMs - ALLOWED_SENSOR_INIT_TIME_MILLISEC) * 1000/ samplingPeriodUs), 0);         minMax[1] = (int) Math.ceil(timeMs * 1000 * 2 / samplingPeriodUs);         return minMax;     }      private static class DirectReportSensorEvent {         public int size;         public int token;         public int type;         public long serial;         public long ts;         public float x;         public float y;         public float z;         public long arrivalTs;     };      // EventPool to avoid allocating too many event objects and hitting GC during test     private static class EventPool {         public EventPool(int n) {             mEvents = Arrays.asList(new DirectReportSensorEvent[n]);             for (int i = 0; i < n; ++i) {                 mEvents.set(i, new DirectReportSensorEvent());             }             reset();         }          public synchronized void reset() {             Log.d(TAG, ""Reset EventPool ("" + mIndex + "" events used)"");             mIndex = 0;         }          public synchronized DirectReportSensorEvent get() {             if (mIndex < mEvents.size()) {                 return mEvents.get(mIndex++);             } else {                 throw new IllegalStateException(""EventPool depleted"");             }         }          private List<DirectReportSensorEvent> mEvents;         private int mIndex;     };      private DirectReportSensorEvent getEvent() {         return mEventPool.get();     }      private DirectReportSensorEvent getEvent(DirectReportSensorEvent e) {         DirectReportSensorEvent event = mEventPool.get();         event.size = e.size;         event.token = e.token;         event.type = e.type;         event.serial = e.serial;         event.ts = e.ts;         event.x = e.x;         event.y = e.y;         event.z = e.z;         event.arrivalTs = e.arrivalTs;         return event;     }      private void resetEvent() {         mEventPool.reset();     }      private class SensorEventCollection implements SensorEventListener {         List<DirectReportSensorEvent> mEvents = new ArrayList<>();         Sensor mSensor;          public SensorEventCollection(Sensor s) {             mSensor = s;         }          List<DirectReportSensorEvent> getEvents() {             return mEvents;         }          @Override         public void onSensorChanged(SensorEvent event) {             if (mSensor == null || event.sensor == mSensor) {                 DirectReportSensorEvent e = mEventPool.get();                 e.size = SENSORS_EVENT_SIZE;                 e.token = event.sensor.getType();                 e.type = e.token;                 e.serial = -1;                 e.ts = event.timestamp;                 e.arrivalTs = SystemClock.elapsedRealtimeNanos();                  e.x = event.values[0];                 if (event.values.length > 1) {                     e.y = event.values[1];                 }                 if (event.values.length > 2) {                     e.z = event.values[2];                 }                 mEvents.add(e);             }         }          @Override         public void onAccuracyChanged(Sensor s, int accuracy) {             // do nothing         }     };      private List<DirectReportSensorEvent> parseEntireBuffer(byte[] buffer, int token) {         int offset = 0;         int nextSerial = 1;         List<DirectReportSensorEvent> events = new ArrayList<>();          while (offset <= SHARED_MEMORY_SIZE - SENSORS_EVENT_SIZE) {             DirectReportSensorEvent e = getEvent();             parseSensorEvent(offset, e);              if (e.serial == 0) {                 // reaches end of events                 break;             }              assertTrue(""incorrect size "" + e.size + ""  at offset "" + offset,                     e.size == SENSORS_EVENT_SIZE);             assertTrue(""incorrect serial "" + e.serial + "" at offset "" + offset,                     e.serial == nextSerial);              if (e.token == token) {                 events.add(e);             }              ++nextSerial;             offset += SENSORS_EVENT_SIZE;         }          return events;     }      // parse sensors_event_t from mBuffer and fill information into DirectReportSensorEvent     private void parseSensorEvent(int offset, DirectReportSensorEvent ev) {         mByteBuffer.position(offset);          ev.size = mByteBuffer.getInt();         ev.token = mByteBuffer.getInt();         ev.type = mByteBuffer.getInt();         ev.serial = ((long) mByteBuffer.getInt()) & 0xFFFFFFFFl; // signed=>unsigned         ev.ts = mByteBuffer.getLong();         ev.arrivalTs = SystemClock.elapsedRealtimeNanos();         ev.x = mByteBuffer.getFloat();         ev.y = mByteBuffer.getFloat();         ev.z = mByteBuffer.getFloat();     }      // parse sensors_event_t and fill information into DirectReportSensorEvent     private static void parseSensorEvent(byte [] buf, int offset, DirectReportSensorEvent ev) {         ByteBuffer b = ByteBuffer.wrap(buf, offset, SENSORS_EVENT_SIZE);         b.order(NATIVE_BYTE_ORDER);          ev.size = b.getInt();         ev.token = b.getInt();         ev.type = b.getInt();         ev.serial = ((long) b.getInt()) & 0xFFFFFFFFl; // signed=>unsigned         ev.ts = b.getLong();         ev.arrivalTs = SystemClock.elapsedRealtimeNanos();         ev.x = b.getFloat();         ev.y = b.getFloat();         ev.z = b.getFloat();     }      private long readAtomicCounter(int offset) {         mByteBuffer.position(offset + ATOMIC_COUNTER_OFFSET);         return ((long) mByteBuffer.getInt()) & 0xFFFFFFFFl; // signed => unsigned     }      private static long readAtomicCounter(byte [] buf, int offset) {         ByteBuffer b = ByteBuffer.wrap(buf, offset + ATOMIC_COUNTER_OFFSET, ATOMIC_COUNTER_SIZE);         b.order(ByteOrder.nativeOrder());          return ((long) b.getInt()) & 0xFFFFFFFFl; // signed => unsigned     } }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.helpers.sensoroperations.SensorOperationTest"	"ISensorTestNode"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/helpers/sensoroperations/SensorOperationTest.java"	""	"public void test/*  *.  */  package android.hardware.cts.helpers.sensoroperations;  import junit.framework.TestCase;  import android.hardware.cts.helpers.SensorStats; import android.hardware.cts.helpers.SensorTestPlatformException; import android.hardware.cts.helpers.reporting.ISensorTestNode;  import java.util.Set; import java.util.concurrent.TimeUnit;  /**  * Tests for the primitive {@link SensorOperation}s including {@link DelaySensorOperation},  * {@link ParallelSensorOperation}, {@link RepeatingSensorOperation} and  * {@link SequentialSensorOperation}.  */ public class SensorOperationTest extends TestCase {     private static final long TEST_DURATION_THRESHOLD_MS = TimeUnit.SECONDS.toMillis(5);      private final ISensorTestNode mTestNode = new ISensorTestNode() {         @Override         public String getName() throws SensorTestPlatformException {             return ""SensorOperationUnitTest"";         }     };      /**      * Test that the {@link FakeSensorOperation} functions correctly. Other tests in this class      * rely on this operation.      */"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorIntegrationTests"	"testSensorsWithSeveralClients"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorIntegrationTests.java"	""	"public void testSensorsWithSeveralClients() throws Throwable {         SensorCtsHelper.sleep(3, TimeUnit.SECONDS);         final int ITERATIONS = 50;         final int MAX_REPORTING_LATENCY_US = (int) TimeUnit.SECONDS.toMicros(5);         final Context context = getContext();          int sensorTypes[] = {                 Sensor.TYPE_ACCELEROMETER,                 Sensor.TYPE_MAGNETIC_FIELD,                 Sensor.TYPE_GYROSCOPE };          ParallelSensorOperation operation = new ParallelSensorOperation();         for(int sensorType : sensorTypes) {             TestSensorEnvironment environment = new TestSensorEnvironment(                     context,                     sensorType,                     shouldEmulateSensorUnderLoad(),                     SensorManager.SENSOR_DELAY_FASTEST);             TestSensorOperation continuousOperation =                     TestSensorOperation.createOperation(environment, 100 /* eventCount */);             continuousOperation.addVerification(new EventOrderingVerification());             operation.add(new RepeatingSensorOperation(continuousOperation, ITERATIONS));              Sensor sensor = TestSensorEnvironment.getSensor(context, sensorType);             TestSensorEnvironment batchingEnvironment = new TestSensorEnvironment(                     context,                     sensorType,                     shouldEmulateSensorUnderLoad(),                     true, /* isIntegrationTest */                     sensor.getMinDelay(),                     MAX_REPORTING_LATENCY_US);             TestSensorOperation batchingOperation =                     TestSensorOperation.createOperation(batchingEnvironment, 100 /* eventCount */);             batchingOperation.addVerification(new EventOrderingVerification());             operation.add(new RepeatingSensorOperation(batchingOperation, ITERATIONS));         }         operation.execute(getCurrentTestNode());         operation.getStats().log(TAG);     }      /**      * This test focuses in the interaction of several sensor Clients. The test characterizes by      * using clients for different Sensors under Test that vary the sampling rates and report      * latencies for the requests.      * The verification ensures that the sensor clients can vary the parameters of their requests      * without affecting other clients.      *      * The test verifies for each client that a set of sampled data arrives in order. However each      * client in the test has different set of parameters that represent different types of clients      * in the real world.      *      * The test can be susceptible to issues when several clients interacting with the system      * actually affect the operation of other clients.      *      * The assertion associated with the test failure provides:      * - the thread id on which the failure occurred      * - the sensor type and sensor handle that caused the failure      * - the event that caused the issue      * It is important to look at the internals of the Sensor HAL to identify how the interaction      * of several clients can lead to the failing state.      */"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorIntegrationTests"	"testSensorsMovingRates"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorIntegrationTests.java"	""	"public void testSensorsMovingRates() throws Throwable {         SensorCtsHelper.sleep(3, TimeUnit.SECONDS);         // use at least two instances to ensure more than one client of any given sensor is in play         final int INSTANCES_TO_USE = 5;         final int ITERATIONS_TO_EXECUTE = 100;          ParallelSensorOperation operation = new ParallelSensorOperation();         int sensorTypes[] = {                 Sensor.TYPE_ACCELEROMETER,                 Sensor.TYPE_MAGNETIC_FIELD,                 Sensor.TYPE_GYROSCOPE };          Context context = getContext();         for(int sensorType : sensorTypes) {             for(int instance = 0; instance < INSTANCES_TO_USE; ++instance) {                 SequentialSensorOperation sequentialOperation = new SequentialSensorOperation();                 for(int iteration = 0; iteration < ITERATIONS_TO_EXECUTE; ++iteration) {                     TestSensorEnvironment environment = new TestSensorEnvironment(                             context,                             sensorType,                             shouldEmulateSensorUnderLoad(),                             true, /* isIntegrationTest */                             generateSamplingRateInUs(sensorType),                             generateReportLatencyInUs());                     TestSensorOperation sensorOperation =                             TestSensorOperation.createOperation(environment, 100 /* eventCount */);                     sensorOperation.addVerification(new EventOrderingVerification());                     sequentialOperation.add(sensorOperation);                 }                 operation.add(sequentialOperation);             }         }          operation.execute(getCurrentTestNode());         operation.getStats().log(TAG);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorIntegrationTests"	"testGeomagneticRotationVectorReconfigureWhileActive"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorIntegrationTests.java"	""	"public void testGeomagneticRotationVectorReconfigureWhileActive() throws Throwable {         verifySensorReconfigureWhileActive(Sensor.TYPE_GEOMAGNETIC_ROTATION_VECTOR);     }      /**      * This test focuses on ensuring that an active sensor is able to be reconfigured when a new      * client requests a different sampling rate.      *      * The test verifies that if a sensor is active with a slow sampling rate and a new client      * requests a faster sampling rate, the sensor begins returning data at the faster sampling      * rate.      *      * The assertion associated with the test failure provides:      * - the thread id on which the failure occurred      * - the sensor type and sensor handle that caused the failure      * - the event that caused the issue      * It is important to look at the internals of the Sensor HAL to identify how the interaction      * of several clients can lead to the failing state.      */     public void verifySensorReconfigureWhileActive(int sensorType) throws Throwable {         SensorCtsHelper.sleep(3, TimeUnit.SECONDS);          final int DELAY_BEFORE_CHANGING_RATE_SEC = 2;         final int EVENTS_FOR_VERIFICATION = 200;         Context context = getContext();         SensorManager sensorManager =                 (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);         assertNotNull(""SensorService is not present in the system"", sensorManager);          Sensor sensor = sensorManager.getDefaultSensor(sensorType);         if(sensor == null) {             throw new SensorNotSupportedException(sensorType);         }          // Request for the sensor rate to be set to the slowest rate.         ParallelSensorOperation operation = new ParallelSensorOperation();         TestSensorEnvironment environmentSlow = new TestSensorEnvironment(                 context,                 sensor,                 shouldEmulateSensorUnderLoad(),                 true, /* isIntegrationTest */                 sensor.getMaxDelay(),                 (int)TimeUnit.SECONDS.toMicros(20));         TestSensorOperation sensorOperationSlow = TestSensorOperation.createOperation(                 environmentSlow, 2 * DELAY_BEFORE_CHANGING_RATE_SEC, TimeUnit.SECONDS);         operation.add(sensorOperationSlow);          // Create a second operation that will run in parallel and request the fastest rate after         // an initial delay. The delay is to ensure that the first operation has enabled the sensor.         // The sensor should begin reporting at the newly requested rate. Execute a flush prior to         // the reconfiguration to ensure that the lower frequency events are not received after the         // reconfiguration of the sensor.         SequentialSensorOperation sequentialSensorOperation = new SequentialSensorOperation();         TestSensorEnvironment environmentFast = new TestSensorEnvironment(                 context,                 sensor,                 shouldEmulateSensorUnderLoad(),                 true, /* isIntegrationTest */                 sensor.getMinDelay(),                 0 /* max reporting latency */);          // Create the flush operation with a delay to ensure the low frequency configuration was         // handled and executed. Use the original environment since the flush operation will         // register a new listener and reconfigure the sensor.         TestSensorOperation flushOperation = TestSensorOperation.createFlushOperation(                 environmentSlow, DELAY_BEFORE_CHANGING_RATE_SEC, TimeUnit.SECONDS);         sequentialSensorOperation.add(flushOperation);          // Create the reconfiguration request and add it after the flush         TestSensorOperation sensorOperationFast = TestSensorOperation.createOperation(                 environmentFast, EVENTS_FOR_VERIFICATION);         sensorOperationFast.addVerification(FrequencyVerification.getDefault(environmentFast));         sequentialSensorOperation.add(sensorOperationFast);          // Add the sequential operation containing the flush and high frequency request to the         // existing parallel operation that already contains the low frequency request.         operation.add(sequentialSensorOperation);         operation.execute(getCurrentTestNode());         operation.getStats().log(TAG);     }      /**      * Regress:      * - b/10641388      */"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"android.hardware.cts.SensorIntegrationTests"	"testMagneticFieldMagneticFieldStopping"	"CtsSensorTestCases"	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorIntegrationTests.java"	""	"public void testMagneticFieldMagneticFieldStopping()  throws Throwable {         verifySensorStoppingInteraction(Sensor.TYPE_MAGNETIC_FIELD, Sensor.TYPE_MAGNETIC_FIELD);     }      /**      * This test verifies that starting/stopping a particular Sensor client in the System does not      * affect other sensor clients.      * the test is used to validate that starting/stopping operations are independent on several      * sensor clients.      *      * The test verifies for each client that the a set of sampled data arrives in order. However      * each client in the test has different set of parameters that represent different types of      * clients in the real world.      *      * The test can be susceptible to issues when several clients interacting with the system      * actually affect the operation of other clients.      *      * The assertion associated with the test failure provides:      * - the thread id on which the failure occurred      * - the sensor type and sensor handle that caused the failure      * - the event that caused the issue      * It is important to look at the internals of the Sensor HAL to identify how the interaction      * of several clients can lead to the failing state.      */     public void verifySensorStoppingInteraction(             int sensorTypeTestee,             int sensorTypeTester) throws Throwable {         SensorCtsHelper.sleep(3, TimeUnit.SECONDS);         Context context = getContext();          TestSensorEnvironment testerEnvironment = new TestSensorEnvironment(                 context,                 sensorTypeTester,                 shouldEmulateSensorUnderLoad(),                 SensorManager.SENSOR_DELAY_FASTEST);         TestSensorOperation tester =                 TestSensorOperation.createOperation(testerEnvironment, 100 /* event count */);         tester.addVerification(new EventOrderingVerification());          TestSensorEnvironment testeeEnvironment = new TestSensorEnvironment(                 context,                 sensorTypeTestee,                 shouldEmulateSensorUnderLoad(),                 SensorManager.SENSOR_DELAY_FASTEST);         TestSensorOperation testee =                 TestSensorOperation.createOperation(testeeEnvironment, 100 /* event count */);         testee.addVerification(new EventOrderingVerification());          ParallelSensorOperation operation = new ParallelSensorOperation();         operation.add(tester, testee);         operation.execute(getCurrentTestNode());         operation.getStats().log(TAG);          testee = testee.clone();         testee.execute(getCurrentTestNode());         testee.getStats().log(TAG);     }      /**      * Private helpers.      */     private final Random mGenerator = new Random();      private int generateSamplingRateInUs(int sensorType) {         int rate;         switch(mGenerator.nextInt(5)) {             case 0:                 rate = SensorManager.SENSOR_DELAY_FASTEST;                 break;             default:                 Sensor sensor = TestSensorEnvironment.getSensor(getContext(), sensorType);                 int maxSamplingRate = sensor.getMinDelay();                 rate = maxSamplingRate * mGenerator.nextInt(10);         }         return rate;     }      private int generateReportLatencyInUs() {         long reportLatencyUs = TimeUnit.SECONDS.toMicros(mGenerator.nextInt(5) + 1);         return (int) reportLatencyUs;     } }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"com.android.cts.verifier.sensors.sixdof.Fragments.DataFragment"	"stopListening"	""	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/sensors/sixdof/Fragments/DataFragment.java"	""	"public void test/*  *.  */ package com.android.cts.verifier.sensors.sixdof.Fragments;   import com.android.cts.verifier.sensors.sixdof.Activities.TestActivity; import com.android.cts.verifier.sensors.sixdof.Utils.Manager; import com.android.cts.verifier.sensors.sixdof.Utils.TestReport; import com.android.cts.verifier.sensors.sixdof.Utils.Exceptions.WaypointAreaCoveredException; import com.android.cts.verifier.sensors.sixdof.Utils.Exceptions.WaypointDistanceException; import com.android.cts.verifier.sensors.sixdof.Utils.Exceptions.WaypointRingNotEnteredException; import com.android.cts.verifier.sensors.sixdof.Utils.Exceptions.WaypointStartPointException; import com.android.cts.verifier.sensors.sixdof.Utils.Path.PathUtilityClasses.Ring; import com.android.cts.verifier.sensors.sixdof.Utils.Path.PathUtilityClasses.Waypoint; import com.android.cts.verifier.sensors.sixdof.Utils.PoseProvider.AndroidPoseProvider; import com.android.cts.verifier.sensors.sixdof.Utils.PoseProvider.PoseData; import com.android.cts.verifier.sensors.sixdof.Utils.PoseProvider.PoseProvider;  import android.app.Activity; import android.content.Context; import android.app.Fragment;  import java.util.ArrayList;  /**  * This currently deals with the pose data and what to do with it.  */ public class DataFragment extends Fragment implements PoseProvider.PoseProviderListener {     private final static String TAG = ""DataFragment"";      private TestReport mTestReport;     private Manager mManager;      private PoseProvider mPoseProvider;     protected boolean mIsPoseProviderReady = false;      @Override     public void onStart() {         super.onStart();         mPoseProvider = new AndroidPoseProvider(getActivity(), this);         mPoseProvider.setup();     }      @Override     public void onDestroy() {         super.onDestroy();         mPoseProvider = null;     }      @Override     public void onPause() {         super.onPause();         mPoseProvider.onStopPoseProviding();         mIsPoseProviderReady = false;     }      /**      * Start PoseProvider.      */     @Override     public void onSetupComplete() {         mPoseProvider.onStartPoseProviding();     }      @Override     public void onNewPoseData(PoseData newPoseData) {         if (!mIsPoseProviderReady) {             mIsPoseProviderReady = true;             mManager.onPoseProviderReady();         }          mManager.onNewPoseData(newPoseData);     }      /**      * Assign the listener when this fragment is attached to an activity.      *      * @param activity the activity that this fragment is attached to.      */     @Override     public void onAttach(Activity activity) {         super.onAttach(activity);         initManager(activity);     }      private void initManager(Context context) {         mTestReport = new TestReport(getActivity());         mManager = new Manager(mTestReport);         mManager.setupListeners(context);     }      /**      * Nullify the listener to avoid leaking the activity.      */     @Override     public void onDetach() {         super.onDetach();         mManager.stopListening();     }      /**      * @return PoseProvider object associated with these tests.      */     public PoseProvider getPoseProvider() {         return mPoseProvider;     }      /**      * @return true if we are connected to the pose provider.      */     public boolean isPoseProviderReady() {         return mIsPoseProviderReady;     }      /**      * Gets all the markers (user generated waypoints) for the specified phase.      *      * @param lap the lap of the test to get the markers from      * @return a list of the markers      */     public ArrayList<Waypoint> getUserGeneratedWaypoints(Manager.Lap lap) {         switch (lap) {             case LAP_1:                 return mManager.getReferencePathMarkers();             case LAP_2:                 return mManager.getTestPathMarkers();             case LAP_3:                 return mManager.getRobustnessMarker();             case LAP_4:                 return mManager.getComplexMovementTestMarkers();             default:                 throw new AssertionError(""Unrecognised Lap!"", null);         }     }      /**      * Returns a reference to the mTestReport object.      */     public TestReport getTestReport() {         return mTestReport;     }      /**      * Initiates the adding of a waypoint and checks if the state of the current test need to be      * changed.      *      * @throws WaypointDistanceException    if the location is too close to another      * @throws WaypointAreaCoveredException if the area covered by the user is too little      * @throws WaypointStartPointException  if the location is not close enough to the start      */     public void onWaypointPlacementAttempt()             throws WaypointStartPointException, WaypointDistanceException,             WaypointAreaCoveredException, WaypointRingNotEnteredException {         synchronized (TestActivity.POSE_LOCK) {             mManager.addPoseDataToPath(                     mPoseProvider.getLatestPoseData().getTranslationAsFloats(), true);         }     }      /**      * Removes the last marker added in the current test phase.      */     public void undoWaypointPlacement() {         mManager.removeLastAddedMarker();     }      /**      * Returns the current phase of the test.      */     public Manager.Lap getLap() {         return mManager.getLap();     }      /**      * Sets the test status to executed.      */"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"com.android.cts.verifier.sensors.sixdof.Fragments.DataFragment"	"testStarted"	""	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/sensors/sixdof/Fragments/DataFragment.java"	""	"public void testStarted() {         mTestReport.setTestState(TestReport.TestStatus.EXECUTED);     }      public void startTest(TestActivity.CTSTest newTest) {         switch (newTest) {             case ACCURACY:                 mManager.startAccuracyTest();                 break;             case ROBUSTNESS:                 mManager.startRobustnessTest();                 break;             case COMPLEX_MOVEMENT:                 mManager.startComplexMovementTest();                 break;             default:                 throw new AssertionError(""Test not recognised!"");         }     }      public float getLatestDistanceData() {         return mManager.getRemainingPath();     }      public float getTimeRemaining() {         return mManager.getTimeRemaining();     }      public ArrayList<Ring> getRings() {         return mManager.getRings();     } }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"com.android.cts.verifier.sensors.sixdof.Fragments.DataFragment"	"stopListening"	""	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"implement"	""	""	""	"/home/gpoor/cts-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/sensors/sixdof/Fragments/DataFragment.java"	""	"public void test/*  *.  */ package com.android.cts.verifier.sensors.sixdof.Fragments;   import com.android.cts.verifier.sensors.sixdof.Activities.TestActivity; import com.android.cts.verifier.sensors.sixdof.Utils.Manager; import com.android.cts.verifier.sensors.sixdof.Utils.TestReport; import com.android.cts.verifier.sensors.sixdof.Utils.Exceptions.WaypointAreaCoveredException; import com.android.cts.verifier.sensors.sixdof.Utils.Exceptions.WaypointDistanceException; import com.android.cts.verifier.sensors.sixdof.Utils.Exceptions.WaypointRingNotEnteredException; import com.android.cts.verifier.sensors.sixdof.Utils.Exceptions.WaypointStartPointException; import com.android.cts.verifier.sensors.sixdof.Utils.Path.PathUtilityClasses.Ring; import com.android.cts.verifier.sensors.sixdof.Utils.Path.PathUtilityClasses.Waypoint; import com.android.cts.verifier.sensors.sixdof.Utils.PoseProvider.AndroidPoseProvider; import com.android.cts.verifier.sensors.sixdof.Utils.PoseProvider.PoseData; import com.android.cts.verifier.sensors.sixdof.Utils.PoseProvider.PoseProvider;  import android.app.Activity; import android.content.Context; import android.app.Fragment;  import java.util.ArrayList;  /**  * This currently deals with the pose data and what to do with it.  */ public class DataFragment extends Fragment implements PoseProvider.PoseProviderListener {     private final static String TAG = ""DataFragment"";      private TestReport mTestReport;     private Manager mManager;      private PoseProvider mPoseProvider;     protected boolean mIsPoseProviderReady = false;      @Override     public void onStart() {         super.onStart();         mPoseProvider = new AndroidPoseProvider(getActivity(), this);         mPoseProvider.setup();     }      @Override     public void onDestroy() {         super.onDestroy();         mPoseProvider = null;     }      @Override     public void onPause() {         super.onPause();         mPoseProvider.onStopPoseProviding();         mIsPoseProviderReady = false;     }      /**      * Start PoseProvider.      */     @Override     public void onSetupComplete() {         mPoseProvider.onStartPoseProviding();     }      @Override     public void onNewPoseData(PoseData newPoseData) {         if (!mIsPoseProviderReady) {             mIsPoseProviderReady = true;             mManager.onPoseProviderReady();         }          mManager.onNewPoseData(newPoseData);     }      /**      * Assign the listener when this fragment is attached to an activity.      *      * @param activity the activity that this fragment is attached to.      */     @Override     public void onAttach(Activity activity) {         super.onAttach(activity);         initManager(activity);     }      private void initManager(Context context) {         mTestReport = new TestReport(getActivity());         mManager = new Manager(mTestReport);         mManager.setupListeners(context);     }      /**      * Nullify the listener to avoid leaking the activity.      */     @Override     public void onDetach() {         super.onDetach();         mManager.stopListening();     }      /**      * @return PoseProvider object associated with these tests.      */     public PoseProvider getPoseProvider() {         return mPoseProvider;     }      /**      * @return true if we are connected to the pose provider.      */     public boolean isPoseProviderReady() {         return mIsPoseProviderReady;     }      /**      * Gets all the markers (user generated waypoints) for the specified phase.      *      * @param lap the lap of the test to get the markers from      * @return a list of the markers      */     public ArrayList<Waypoint> getUserGeneratedWaypoints(Manager.Lap lap) {         switch (lap) {             case LAP_1:                 return mManager.getReferencePathMarkers();             case LAP_2:                 return mManager.getTestPathMarkers();             case LAP_3:                 return mManager.getRobustnessMarker();             case LAP_4:                 return mManager.getComplexMovementTestMarkers();             default:                 throw new AssertionError(""Unrecognised Lap!"", null);         }     }      /**      * Returns a reference to the mTestReport object.      */     public TestReport getTestReport() {         return mTestReport;     }      /**      * Initiates the adding of a waypoint and checks if the state of the current test need to be      * changed.      *      * @throws WaypointDistanceException    if the location is too close to another      * @throws WaypointAreaCoveredException if the area covered by the user is too little      * @throws WaypointStartPointException  if the location is not close enough to the start      */     public void onWaypointPlacementAttempt()             throws WaypointStartPointException, WaypointDistanceException,             WaypointAreaCoveredException, WaypointRingNotEnteredException {         synchronized (TestActivity.POSE_LOCK) {             mManager.addPoseDataToPath(                     mPoseProvider.getLatestPoseData().getTranslationAsFloats(), true);         }     }      /**      * Removes the last marker added in the current test phase.      */     public void undoWaypointPlacement() {         mManager.removeLastAddedMarker();     }      /**      * Returns the current phase of the test.      */     public Manager.Lap getLap() {         return mManager.getLap();     }      /**      * Sets the test status to executed.      */"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"com.android.cts.verifier.sensors.base.SensorCtsTestActivity"	"getTestLogger"	""	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/sensors/base/SensorCtsTestActivity.java"	""	"public void test/*   *.  */  package com.android.cts.verifier.sensors.base;  import android.content.Context; import android.hardware.cts.SensorTestCase; import android.os.PowerManager; import android.view.WindowManager;  import com.android.cts.verifier.R; import com.android.cts.verifier.sensors.helpers.SensorTestScreenManipulator; import com.android.cts.verifier.sensors.reporting.SensorTestDetails;  import junit.framework.Test; import junit.framework.TestSuite;  import org.junit.internal.runners.JUnit38ClassRunner; import org.junit.internal.runners.SuiteMethod; import org.junit.runner.Computer; import org.junit.runner.Description; import org.junit.runner.JUnitCore; import org.junit.runner.Request; import org.junit.runner.Result; import org.junit.runner.Runner; import org.junit.runner.notification.Failure; import org.junit.runner.notification.RunListener; import org.junit.runners.model.InitializationError; import org.junit.runners.model.RunnerBuilder;  import java.util.concurrent.TimeUnit;  /**  * An Activity that allows Sensor CTS tests to be executed inside CtsVerifier.  *  * Sub-classes pass the test class as part of construction.  * One JUnit test class is executed per Activity, the test class can still be executed outside  * CtsVerifier.  */ public abstract class SensorCtsTestActivity extends BaseSensorTestActivity {      private SensorTestScreenManipulator mScreenManipulator;     private PowerManager.WakeLock mWakeLock;      /**      * Constructor for a CTS test executor. It will execute a standalone CTS test class.      *      * @param testClass The test class to execute, it must be a subclass of {@link SensorTestCase}.      */     protected SensorCtsTestActivity(Class<? extends SensorTestCase> testClass) {         super(testClass);     }      @Override     protected void activitySetUp() throws InterruptedException {         PowerManager powerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);         mWakeLock =  powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""SensorCtsTests"");         mScreenManipulator = new SensorTestScreenManipulator(this);         mScreenManipulator.initialize(this);          SensorTestLogger logger = getTestLogger();         logger.logInstructions(R.string.snsr_no_interaction);         logger.logInstructions(R.string.snsr_run_automated_tests);         waitForUserToBegin();          // automated CTS tests run with the USB connected, so the AP doesn't go to sleep         // here we are not connected to USB, so we need to hold a wake-lock to avoid going to sleep         mWakeLock.acquire();          mScreenManipulator.turnScreenOff();     }      @Override     protected void activityCleanUp() {         runOnUiThread(new Runnable() {             @Override             public void run() {                 getWindow().addFlags(WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD);             }         });         mScreenManipulator.turnScreenOn();         if (mWakeLock.isHeld()) {             mWakeLock.release();         }     }      @Override     protected void onDestroy() {         super.onDestroy();         if (mScreenManipulator != null) {             mScreenManipulator.releaseScreenOn();             mScreenManipulator.close();         }     }      /**      * For reference on the implementation of this test executor see:      *      androidx.test.runner.AndroidJUnitRunner      */     @Override     protected SensorTestDetails executeTests() {         JUnitCore testRunner = new JUnitCore();         testRunner.addListener(new SensorRunListener());          Computer computer = new Computer();         RunnerBuilder runnerBuilder = new SensorRunnerBuilder();          Runner runner;         try {             runner = computer.getSuite(runnerBuilder, new Class[]{ mTestClass });         } catch (InitializationError e) {             return new SensorTestDetails(                     getTestClassName(),                     SensorTestDetails.ResultCode.FAIL,                     ""[JUnit Initialization]"" + e.getMessage());         }          Request request = Request.runner(runner);         Result result = testRunner.run(request);         return new SensorTestDetails(getApplicationContext(), getClass().getName(), result);     }      /**      * A {@link RunnerBuilder} that is used to inject during execution a {@link SensorCtsTestSuite}.      */     private class SensorRunnerBuilder extends RunnerBuilder {         @Override         public Runner runnerForClass(Class<?> testClass) throws Throwable {             TestSuite testSuite;             if (hasSuiteMethod(testClass)) {                 Test test = SuiteMethod.testFromSuiteMethod(testClass);                 if (test instanceof TestSuite) {                     testSuite = (TestSuite) test;                 } else {                     throw new IllegalArgumentException(                             testClass.getName() + ""#suite() did not return a TestSuite."");                 }             } else {                 testSuite = new TestSuite(testClass);             }             SensorCtsTestSuite sensorTestSuite =                     new SensorCtsTestSuite(getApplicationContext(), testSuite);             return new JUnit38ClassRunner(sensorTestSuite);         }          private boolean hasSuiteMethod(Class<?> testClass) {             try {                 testClass.getMethod(""suite"");                 return true;             } catch (NoSuchMethodException e) {                 return false;             }         }     }      /**      * Dummy {@link RunListener}.      * It is only used to handle logging into the UI.      */     private class SensorRunListener extends RunListener {         private volatile boolean mCurrentTestReported;"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"com.android.cts.verifier.sensors.base.SensorCtsTestActivity"	"getTestLogger"	""	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/sensors/base/SensorCtsTestActivity.java"	""	"public void testStarted(Description description) throws Exception {             mCurrentTestReported = false;             getTestLogger().logTestStart(description.getMethodName());         }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"com.android.cts.verifier.sensors.base.SensorCtsTestActivity"	"getTestLogger"	""	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/sensors/base/SensorCtsTestActivity.java"	""	"public void testFinished(Description description) throws Exception {             if (!mCurrentTestReported) {                 getTestLogger().logTestPass(description.getMethodName(), null /* testSummary */);             }         }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"com.android.cts.verifier.sensors.base.SensorCtsTestActivity"	"getTestLogger"	""	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/sensors/base/SensorCtsTestActivity.java"	""	"public void testFailure(Failure failure) throws Exception {             mCurrentTestReported = true;             getTestLogger()                     .logTestFail(failure.getDescription().getMethodName(), failure.toString());         }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"com.android.cts.verifier.sensors.base.SensorCtsTestActivity"	"getTestLogger"	""	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/sensors/base/SensorCtsTestActivity.java"	""	"public void testAssumptionFailure(Failure failure) {             mCurrentTestReported = true;             getTestLogger()                     .logTestFail(failure.getDescription().getMethodName(), failure.toString());         }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"com.android.cts.verifier.sensors.base.SensorCtsTestActivity"	"getTestLogger"	""	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"report"	""	""	""	"/home/gpoor/cts-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/sensors/base/SensorCtsTestActivity.java"	""	"public void testIgnored(Description description) throws Exception {             mCurrentTestReported = true;             getTestLogger().logTestSkip(description.getMethodName(), description.toString());         }     } }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-1"	""	"com.android.cts.verifier.sensors.base.SensorCtsTestActivity"	"getTestLogger"	""	""	"7.3.13/C-1-1"	"C-1-1] MUST implement and report ."	""	"report implement"	""	""	""	"implement"	""	""	""	"/home/gpoor/cts-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/sensors/base/SensorCtsTestActivity.java"	""	"public void test/*   *.  */  package com.android.cts.verifier.sensors.base;  import android.content.Context; import android.hardware.cts.SensorTestCase; import android.os.PowerManager; import android.view.WindowManager;  import com.android.cts.verifier.R; import com.android.cts.verifier.sensors.helpers.SensorTestScreenManipulator; import com.android.cts.verifier.sensors.reporting.SensorTestDetails;  import junit.framework.Test; import junit.framework.TestSuite;  import org.junit.internal.runners.JUnit38ClassRunner; import org.junit.internal.runners.SuiteMethod; import org.junit.runner.Computer; import org.junit.runner.Description; import org.junit.runner.JUnitCore; import org.junit.runner.Request; import org.junit.runner.Result; import org.junit.runner.Runner; import org.junit.runner.notification.Failure; import org.junit.runner.notification.RunListener; import org.junit.runners.model.InitializationError; import org.junit.runners.model.RunnerBuilder;  import java.util.concurrent.TimeUnit;  /**  * An Activity that allows Sensor CTS tests to be executed inside CtsVerifier.  *  * Sub-classes pass the test class as part of construction.  * One JUnit test class is executed per Activity, the test class can still be executed outside  * CtsVerifier.  */ public abstract class SensorCtsTestActivity extends BaseSensorTestActivity {      private SensorTestScreenManipulator mScreenManipulator;     private PowerManager.WakeLock mWakeLock;      /**      * Constructor for a CTS test executor. It will execute a standalone CTS test class.      *      * @param testClass The test class to execute, it must be a subclass of {@link SensorTestCase}.      */     protected SensorCtsTestActivity(Class<? extends SensorTestCase> testClass) {         super(testClass);     }      @Override     protected void activitySetUp() throws InterruptedException {         PowerManager powerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);         mWakeLock =  powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, ""SensorCtsTests"");         mScreenManipulator = new SensorTestScreenManipulator(this);         mScreenManipulator.initialize(this);          SensorTestLogger logger = getTestLogger();         logger.logInstructions(R.string.snsr_no_interaction);         logger.logInstructions(R.string.snsr_run_automated_tests);         waitForUserToBegin();          // automated CTS tests run with the USB connected, so the AP doesn't go to sleep         // here we are not connected to USB, so we need to hold a wake-lock to avoid going to sleep         mWakeLock.acquire();          mScreenManipulator.turnScreenOff();     }      @Override     protected void activityCleanUp() {         runOnUiThread(new Runnable() {             @Override             public void run() {                 getWindow().addFlags(WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD);             }         });         mScreenManipulator.turnScreenOn();         if (mWakeLock.isHeld()) {             mWakeLock.release();         }     }      @Override     protected void onDestroy() {         super.onDestroy();         if (mScreenManipulator != null) {             mScreenManipulator.releaseScreenOn();             mScreenManipulator.close();         }     }      /**      * For reference on the implementation of this test executor see:      *      androidx.test.runner.AndroidJUnitRunner      */     @Override     protected SensorTestDetails executeTests() {         JUnitCore testRunner = new JUnitCore();         testRunner.addListener(new SensorRunListener());          Computer computer = new Computer();         RunnerBuilder runnerBuilder = new SensorRunnerBuilder();          Runner runner;         try {             runner = computer.getSuite(runnerBuilder, new Class[]{ mTestClass });         } catch (InitializationError e) {             return new SensorTestDetails(                     getTestClassName(),                     SensorTestDetails.ResultCode.FAIL,                     ""[JUnit Initialization]"" + e.getMessage());         }          Request request = Request.runner(runner);         Result result = testRunner.run(request);         return new SensorTestDetails(getApplicationContext(), getClass().getName(), result);     }      /**      * A {@link RunnerBuilder} that is used to inject during execution a {@link SensorCtsTestSuite}.      */     private class SensorRunnerBuilder extends RunnerBuilder {         @Override         public Runner runnerForClass(Class<?> testClass) throws Throwable {             TestSuite testSuite;             if (hasSuiteMethod(testClass)) {                 Test test = SuiteMethod.testFromSuiteMethod(testClass);                 if (test instanceof TestSuite) {                     testSuite = (TestSuite) test;                 } else {                     throw new IllegalArgumentException(                             testClass.getName() + ""#suite() did not return a TestSuite."");                 }             } else {                 testSuite = new TestSuite(testClass);             }             SensorCtsTestSuite sensorTestSuite =                     new SensorCtsTestSuite(getApplicationContext(), testSuite);             return new JUnit38ClassRunner(sensorTestSuite);         }          private boolean hasSuiteMethod(Class<?> testClass) {             try {                 testClass.getMethod(""suite"");                 return true;             } catch (NoSuchMethodException e) {                 return false;             }         }     }      /**      * Dummy {@link RunListener}.      * It is only used to handle logging into the UI.      */     private class SensorRunListener extends RunListener {         private volatile boolean mCurrentTestReported;"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorBatchingFifoTest"	"testGameRotationVectorFifoLength"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorBatchingFifoTest.java"	""	"public void testGameRotationVectorFifoLength() throws Throwable {         if (!mHasHifiSensors) return;         runBatchingSensorFifoTest(                 Sensor.TYPE_GAME_ROTATION_VECTOR,                 getReservedFifoLength(Sensor.TYPE_GAME_ROTATION_VECTOR));     }      private int getReservedFifoLength(int sensorType) {         Sensor sensor = mSensorManager.getDefaultSensor(sensorType);         assertTrue(String.format(""sensor of type=%d (null)"", sensorType), sensor != null);         return sensor.getFifoReservedEventCount();     }      private void runBatchingSensorFifoTest(int sensorType, int fifoLength) throws Throwable {         if (fifoLength == 0) {             return;         }         Sensor sensor = mSensorManager.getDefaultSensor(sensorType);         TestSensorEnvironment environment =  new TestSensorEnvironment(getContext(),                 sensor,                 false, /* sensorMightHaveMoreListeners */                 sensor.getMinDelay(),                 Integer.MAX_VALUE /*maxReportLatencyUs*/);          int preFlushMs = 2000;  // 2 sec to make sure there is sample at the time of flush         int postFlushMs = environment.getExpectedSamplingPeriodUs() * 100 /1000;         int testFlushMs =                 environment.getSensor().getFifoReservedEventCount() *                 environment.getExpectedSamplingPeriodUs() / (int)(1000 / 1.2); // 120%          TestSensorOperation op = TestSensorOperation.createFlushOperation(                 environment, new int [] { preFlushMs, testFlushMs, postFlushMs }, -1);          op.addVerification(FifoLengthVerification.getDefault(environment));         op.execute(getCurrentTestNode());         op.getStats().log(TAG);     } }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.helpers.sensorverification.EventBasicVerificationTest"	"testVerify"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/helpers/sensorverification/EventBasicVerificationTest.java"	""	"public void testVerify() {          /* Sensor contents is not used in this verification, use Object as mock */         SensorManager mgr = (SensorManager) mContext.getSystemService(Context.SENSOR_SERVICE);          Sensor sensor1 = null;          // accelerometer is the most likely sensor to exist         Sensor sensor2 = mgr.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);          SensorStats stats;          EventBasicVerification verification;          // case 1         verification = getVerification(10, sensor1, sensor1, new float[20][3]);         stats = new SensorStats();          verification.verify(stats);         assertEquals(true, stats.getValue(EventBasicVerification.PASSED_KEY));         assertEquals(20, (long) stats.getValue(SensorStats.EVENT_COUNT_KEY));         assertEquals(false, stats.getValue(SensorStats.WRONG_SENSOR_KEY));          // case 2         verification = getVerification(10, sensor1, sensor1, new float[5][3]);         stats = new SensorStats();          try {             verification.verify(stats);             throw new Error(""Expect an AssertionError due to insufficient samples"");         } catch (AssertionError e) {             //Expected         }         assertEquals(false, stats.getValue(EventBasicVerification.PASSED_KEY));         assertEquals(5, (long) stats.getValue(SensorStats.EVENT_COUNT_KEY));         assertEquals(false, stats.getValue(SensorStats.WRONG_SENSOR_KEY));          // case 3         if (sensor1 != sensor2) {             // if we cannot even get a second sensor then do not bother this test.             verification = getVerification(10, sensor1, sensor2, new float[15][3]);             stats = new SensorStats();              try {                 verification.verify(stats);                 throw new Error(""Expect an AssertionError due to wrong sensor event"");             } catch (AssertionError e) {                 //Expected             }             assertEquals(false, stats.getValue(EventBasicVerification.PASSED_KEY));             // zero here because wrong sensor is used.             assertEquals(0, (long) stats.getValue(SensorStats.EVENT_COUNT_KEY));             assertEquals(true, stats.getValue(SensorStats.WRONG_SENSOR_KEY));         }     }      private static EventBasicVerification getVerification(             int expectedMinNumEvent, Sensor sensor, Sensor eventSensor, float[] ... values) {          Collection<TestSensorEvent> events = new ArrayList<>(values.length);         for (float[] value : values) {             events.add(new TestSensorEvent(eventSensor, 0, 0, value));         }         EventBasicVerification verification =                 new EventBasicVerification(expectedMinNumEvent, sensor);         verification.addSensorEvents(events);         return verification;     } }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorTest"	"testSensorOperations"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testSensorOperations() {         // Because we can't know every sensors unit details, so we can't assert         // get values with specified values.         Sensor sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);         boolean hasAccelerometer = getContext().getPackageManager().hasSystemFeature(                 PackageManager.FEATURE_SENSOR_ACCELEROMETER);         // accelerometer sensor is optional         if (hasAccelerometer) {             assertEquals(Sensor.TYPE_ACCELEROMETER, sensor.getType());             assertSensorValues(sensor);         } else {             assertNull(sensor);         }          sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_STEP_COUNTER);         boolean hasStepCounter = getContext().getPackageManager().hasSystemFeature(                 PackageManager.FEATURE_SENSOR_STEP_COUNTER);         // stepcounter sensor is optional         if (hasStepCounter) {             assertEquals(Sensor.TYPE_STEP_COUNTER, sensor.getType());             assertSensorValues(sensor);         } else {             assertNull(sensor);         }          sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_STEP_DETECTOR);         boolean hasStepDetector = getContext().getPackageManager().hasSystemFeature(                 PackageManager.FEATURE_SENSOR_STEP_DETECTOR);         // stepdetector sensor is optional         if (hasStepDetector) {             assertEquals(Sensor.TYPE_STEP_DETECTOR, sensor.getType());             assertSensorValues(sensor);         } else {             assertNull(sensor);         }          sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);         boolean hasCompass = getContext().getPackageManager().hasSystemFeature(                 PackageManager.FEATURE_SENSOR_COMPASS);         // compass sensor is optional         if (hasCompass) {             assertEquals(Sensor.TYPE_MAGNETIC_FIELD, sensor.getType());             assertSensorValues(sensor);         } else {             assertNull(sensor);         }          sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE);         boolean hasGyroscope = getContext().getPackageManager().hasSystemFeature(                 PackageManager.FEATURE_SENSOR_GYROSCOPE);         // gyroscope sensor is optional         if (hasGyroscope) {             assertEquals(Sensor.TYPE_GYROSCOPE, sensor.getType());             assertSensorValues(sensor);         } else {             assertNull(sensor);         }          sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_PRESSURE);         boolean hasPressure = getContext().getPackageManager().hasSystemFeature(                 PackageManager.FEATURE_SENSOR_BAROMETER);         // pressure sensor is optional         if (hasPressure) {             assertEquals(Sensor.TYPE_PRESSURE, sensor.getType());             assertSensorValues(sensor);         } else {             assertNull(sensor);         }          sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ORIENTATION);         // Note: orientation sensor is deprecated.         if (sensor != null) {             assertEquals(Sensor.TYPE_ORIENTATION, sensor.getType());             assertSensorValues(sensor);         }          sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_TEMPERATURE);         // temperature sensor is optional         if (sensor != null) {             assertEquals(Sensor.TYPE_TEMPERATURE, sensor.getType());             assertSensorValues(sensor);         }          sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_HINGE_ANGLE);         boolean hasHingeAngle = getContext().getPackageManager().hasSystemFeature(                 PackageManager.FEATURE_SENSOR_HINGE_ANGLE);          if (hasHingeAngle) {             assertEquals(Sensor.TYPE_HINGE_ANGLE, sensor.getType());             assertSensorValues(sensor);             assertTrue(""Max range must not be larger than 360. Range="" + sensor.getMaximumRange()                 + "" "" + sensor.getName(), sensor.getMaximumRange() <= 360);         } else {             assertNull(sensor);         }     }      @AppModeFull(reason = ""Instant apps cannot access body sensors"")"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorTest"	"testBodySensorOperations"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testBodySensorOperations() {         Sensor sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_HEART_RATE);         boolean hasHeartRate = getContext().getPackageManager().hasSystemFeature(                 PackageManager.FEATURE_SENSOR_HEART_RATE);         // heartrate sensor is optional         if (hasHeartRate) {             assertEquals(Sensor.TYPE_HEART_RATE, sensor.getType());             assertSensorValues(sensor);         } else {             assertNull(sensor);         }     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorTest"	"testValuesForAllSensors"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testValuesForAllSensors() {         for (Sensor sensor : mSensorList) {             assertSensorValues(sensor);         }     }      private void hasOnlyOneWakeUpSensorOrEmpty(List<Sensor> sensors) {         if (sensors == null || sensors.isEmpty()) return;         if (sensors.size() > 1) {             fail(""More than one "" + sensors.get(0).getName() + "" defined."");             return;         }         assertTrue(sensors.get(0).getName() + "" defined as non-wake-up sensor"",                 sensors.get(0).isWakeUpSensor());     }      private void hasDefaultWakeupSensorOrEmpty(int sensorType, String sensorName) {         Sensor sensor = mSensorManager.getDefaultSensor(sensorType);         if (sensor == null) return;          assertTrue(""Default "" + sensorName + "" sensor is not a wake-up sensor"", sensor.isWakeUpSensor());     }      // Some sensors like proximity, significant motion etc. are defined as wake-up sensors by     // default. Check if the wake-up flag is set correctly.     @Presubmit"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorTest"	"testGetDefaultSensorWithWakeUpFlag"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testGetDefaultSensorWithWakeUpFlag() {         // With wake-up flags set to false, the sensor returned should be a non wake-up sensor.         for (Sensor sensor : mSensorList) {             Sensor curr_sensor = mSensorManager.getDefaultSensor(sensor.getType(), false);             if (curr_sensor != null) {                 assertFalse(""getDefaultSensor wakeup=false returns a wake-up sensor"" +                         curr_sensor.getName(),                         curr_sensor.isWakeUpSensor());             }              curr_sensor = mSensorManager.getDefaultSensor(sensor.getType(), true);             if (curr_sensor != null) {                 assertTrue(""getDefaultSensor wake-up returns non wake sensor"" +                         curr_sensor.getName(),                         curr_sensor.isWakeUpSensor());             }         }     }      @Presubmit"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorTest"	"testRequestTriggerWithNonTriggerSensor"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testRequestTriggerWithNonTriggerSensor() {         mTriggerSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);         if (mTriggerSensor == null) {             throw new SensorNotSupportedException(Sensor.TYPE_ACCELEROMETER);         }         boolean  result =             mSensorManager.requestTriggerSensor(mNullTriggerEventListener, mTriggerSensor);         assertFalse(result);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorTest"	"testCancelTriggerWithNonTriggerSensor"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testCancelTriggerWithNonTriggerSensor() {         mTriggerSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);         if (mTriggerSensor == null) {             throw new SensorNotSupportedException(Sensor.TYPE_ACCELEROMETER);         }         boolean result =             mSensorManager.cancelTriggerSensor(mNullTriggerEventListener, mTriggerSensor);         assertFalse(result);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorTest"	"testRegisterWithTriggerSensor"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testRegisterWithTriggerSensor() {         Sensor sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_SIGNIFICANT_MOTION);         if (sensor == null) {             throw new SensorNotSupportedException(Sensor.TYPE_SIGNIFICANT_MOTION);         }         boolean result = mSensorManager.registerListener(                 mNullSensorEventListener,                 sensor,                 SensorManager.SENSOR_DELAY_NORMAL);         assertFalse(result);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorTest"	"testRegisterTwiceWithSameSensor"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testRegisterTwiceWithSameSensor() {         Sensor sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);         if (sensor == null) {             throw new SensorNotSupportedException(Sensor.TYPE_ACCELEROMETER);         }          boolean result = mSensorManager.registerListener(mNullSensorEventListener, sensor,                 SensorManager.SENSOR_DELAY_NORMAL);         assertTrue(result);          result = mSensorManager.registerListener(mNullSensorEventListener, sensor,                 SensorManager.SENSOR_DELAY_NORMAL);         assertFalse(result);     }      /**      * Verifies that if the UID is idle the continuous events are being reported      * but sanitized - all events are the same as the first one delivered except      * for their timestamps. From the point of view of an idle app these events are      * being properly generated but the sensor reading does not change - privacy.      */     // TODO: remove when parametrized tests are supported and EventTimestampSynchronization"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorTest"	"testLegacySensorOperations"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testLegacySensorOperations() {         final SensorManager mSensorManager =                 (SensorManager) getContext().getSystemService(Context.SENSOR_SERVICE);          // We expect the set of sensors reported by the new and legacy APIs to be consistent.         int sensors = 0;         if (mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER) != null) {             sensors |= SensorManager.SENSOR_ACCELEROMETER;         }         if (mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD) != null) {             sensors |= SensorManager.SENSOR_MAGNETIC_FIELD;         }         if (mSensorManager.getDefaultSensor(Sensor.TYPE_ORIENTATION) != null) {             sensors |= SensorManager.SENSOR_ORIENTATION | SensorManager.SENSOR_ORIENTATION_RAW;         }         assertEquals(sensors, mSensorManager.getSensors());     }      /**      * Verifies that a continuous sensor produces events that have timestamps synchronized with      * {@link SystemClock#elapsedRealtimeNanos()} and that the events are sanitized/non-sanitized.      */     private void verifyLongActivation(             Sensor sensor,             int maxReportLatencyUs,             long duration,             TimeUnit durationTimeUnit,             String testType,             boolean sanitized,             ArrayList<Throwable> errorsFound) throws InterruptedException {         if (sensor.getReportingMode() != Sensor.REPORTING_MODE_CONTINUOUS) {             return;         }          try {             TestSensorEnvironment environment = new TestSensorEnvironment(                     getContext(),                     sensor,                     shouldEmulateSensorUnderLoad(),                     SensorManager.SENSOR_DELAY_FASTEST,                     maxReportLatencyUs);             TestSensorOperation operation = TestSensorOperation.createOperation(                     environment, duration, durationTimeUnit);             if (sanitized) {                 final long verificationDelayNano = TimeUnit.NANOSECONDS.convert(                         maxReportLatencyUs, TimeUnit.MICROSECONDS) * 2;                 operation.addVerification(ContinuousEventSanitizedVerification                         .getDefault(environment, verificationDelayNano));             } else {                 operation.addVerification(EventGapVerification.getDefault(environment));                 operation.addVerification(EventOrderingVerification.getDefault(environment));                 operation.addVerification(EventTimestampSynchronizationVerification                         .getDefault(environment));             }             Log.i(TAG, ""Running "" + testType + "" test on: "" + sensor.getName());             operation.execute(getCurrentTestNode());         } catch (InterruptedException e) {             // propagate so the test can stop             throw e;         } catch (Throwable e) {             errorsFound.add(e);             Log.e(TAG, e.getMessage());         }     }      /**      * Verifies that a client can listen for events, and that      * {@link SensorManager#flush(SensorEventListener)} will trigger the appropriate notification      * for {@link SensorEventListener2#onFlushCompleted(Sensor)}.      */     private void verifyRegisterListenerCallFlush(             Sensor sensor,             Handler handler,             ArrayList<Throwable> errorsFound,             boolean flushWhileIdle)             throws InterruptedException {         if (sensor.getReportingMode() == Sensor.REPORTING_MODE_ONE_SHOT) {             return;         }          try {             TestSensorEnvironment environment = new TestSensorEnvironment(                     getContext(),                     sensor,                     shouldEmulateSensorUnderLoad(),                     SensorManager.SENSOR_DELAY_FASTEST,                     (int) TimeUnit.SECONDS.toMicros(10));             FlushExecutor executor = new FlushExecutor(environment, 500 /* eventCount */,                     flushWhileIdle);             TestSensorOperation operation = new TestSensorOperation(environment, executor, handler);              Log.i(TAG, ""Running flush test on: "" + sensor.getName());             operation.execute(getCurrentTestNode());         } catch (InterruptedException e) {             // propagate so the test can stop             throw e;         } catch (Throwable e) {             errorsFound.add(e);             Log.e(TAG, e.getMessage());         }     }      private void assertOnErrors(List<Throwable> errorsFound) {         if (!errorsFound.isEmpty()) {             StringBuilder builder = new StringBuilder();             for (Throwable error : errorsFound) {                 builder.append(error.getMessage()).append(""\n"");             }             Assert.fail(builder.toString());         }     }      /**      * A delegate that drives the execution of Batch/Flush tests.      * It performs several operations in order:      * - registration      * - for continuous sensors it first ensures that the FIFO is filled      *      - if events do not arrive on time, an assert will be triggered      * - requests flush of sensor data      * - waits for {@link SensorEventListener2#onFlushCompleted(Sensor)}      *      - if the event does not arrive, an assert will be triggered      */     private class FlushExecutor implements TestSensorOperation.Executor {         private final TestSensorEnvironment mEnvironment;         private final int mEventCount;         private final boolean mFlushWhileIdle;          public FlushExecutor(TestSensorEnvironment environment, int eventCount,                 boolean flushWhileIdle) {             mEnvironment = environment;             mEventCount = eventCount;             mFlushWhileIdle = flushWhileIdle;         }          /**          * Consider only continuous mode sensors for testing register listener.          *          * For on-change sensors, we only use          * {@link TestSensorManager#registerListener(TestSensorEventListener)} to associate the          * listener with the sensor. So that {@link TestSensorManager#requestFlush()} can be          * invoked on it.          */         @Override         public void execute(TestSensorManager sensorManager, TestSensorEventListener listener)                 throws Exception {             int sensorReportingMode = mEnvironment.getSensor().getReportingMode();             try {                 CountDownLatch eventLatch = sensorManager.registerListener(listener, mEventCount);                 if (sensorReportingMode == Sensor.REPORTING_MODE_CONTINUOUS) {                     listener.waitForEvents(eventLatch, mEventCount, true);                 }                 if (mFlushWhileIdle) {                     SensorCtsHelper.makeMyPackageIdle();                     sensorManager.assertFlushFail();                 } else {                     CountDownLatch flushLatch = sensorManager.requestFlush();                     listener.waitForFlushComplete(flushLatch, true);                 }             } finally {                 sensorManager.unregisterListener();                 if (mFlushWhileIdle) {                     SensorCtsHelper.makeMyPackageActive();                 }             }         }     }      private class NullTriggerEventListener extends TriggerEventListener {         @Override         public void onTrigger(TriggerEvent event) {}     }      private class NullSensorEventListener implements SensorEventListener {         @Override         public void onSensorChanged(SensorEvent event) {}          @Override         public void onAccuracyChanged(Sensor sensor, int accuracy) {}     }  }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorTest"	"testValuesForAllSensors"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"wakeup"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testValuesForAllSensors() {         for (Sensor sensor : mSensorList) {             assertSensorValues(sensor);         }     }      private void hasOnlyOneWakeUpSensorOrEmpty(List<Sensor> sensors) {         if (sensors == null || sensors.isEmpty()) return;         if (sensors.size() > 1) {             fail(""More than one "" + sensors.get(0).getName() + "" defined."");             return;         }         assertTrue(sensors.get(0).getName() + "" defined as non-wake-up sensor"",                 sensors.get(0).isWakeUpSensor());     }      private void hasDefaultWakeupSensorOrEmpty(int sensorType, String sensorName) {         Sensor sensor = mSensorManager.getDefaultSensor(sensorType);         if (sensor == null) return;          assertTrue(""Default "" + sensorName + "" sensor is not a wake-up sensor"", sensor.isWakeUpSensor());     }      // Some sensors like proximity, significant motion etc. are defined as wake-up sensors by     // default. Check if the wake-up flag is set correctly.     @Presubmit"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorTest"	"testWakeUpFlags"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"wakeup"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testWakeUpFlags() {         final int TYPE_WAKE_GESTURE = 23;         final int TYPE_GLANCE_GESTURE = 24;         final int TYPE_PICK_UP_GESTURE = 25;          hasOnlyOneWakeUpSensorOrEmpty(mSensorManager.getSensorList(Sensor.TYPE_SIGNIFICANT_MOTION));         hasOnlyOneWakeUpSensorOrEmpty(mSensorManager.getSensorList(TYPE_WAKE_GESTURE));         hasOnlyOneWakeUpSensorOrEmpty(mSensorManager.getSensorList(TYPE_GLANCE_GESTURE));         hasOnlyOneWakeUpSensorOrEmpty(mSensorManager.getSensorList(TYPE_PICK_UP_GESTURE));          hasDefaultWakeupSensorOrEmpty(Sensor.TYPE_PROXIMITY, ""proximity"");         hasDefaultWakeupSensorOrEmpty(Sensor.TYPE_HINGE_ANGLE, ""hinge"");     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorTest"	"testGetDefaultSensorWithWakeUpFlag"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"wakeup"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testGetDefaultSensorWithWakeUpFlag() {         // With wake-up flags set to false, the sensor returned should be a non wake-up sensor.         for (Sensor sensor : mSensorList) {             Sensor curr_sensor = mSensorManager.getDefaultSensor(sensor.getType(), false);             if (curr_sensor != null) {                 assertFalse(""getDefaultSensor wakeup=false returns a wake-up sensor"" +                         curr_sensor.getName(),                         curr_sensor.isWakeUpSensor());             }              curr_sensor = mSensorManager.getDefaultSensor(sensor.getType(), true);             if (curr_sensor != null) {                 assertTrue(""getDefaultSensor wake-up returns non wake sensor"" +                         curr_sensor.getName(),                         curr_sensor.isWakeUpSensor());             }         }     }      @Presubmit"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorSupportTest"	"testSupportsRotationVectorIfHasAGM"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorSupportTest.java"	""	"public void testSupportsRotationVectorIfHasAGM() {         if (mHasAccel && mHasGyro && mHasMag) {             assertTrue(hasSensorType(Sensor.TYPE_ROTATION_VECTOR));         }     }      private boolean sensorRequiredForVrHighPerformanceMode(int sensorType) {         if (sensorType == Sensor.TYPE_ACCELEROMETER ||             sensorType == Sensor.TYPE_ACCELEROMETER_UNCALIBRATED ||             sensorType == Sensor.TYPE_GYROSCOPE ||             sensorType == Sensor.TYPE_GYROSCOPE_UNCALIBRATED ||             sensorType == Sensor.TYPE_MAGNETIC_FIELD ||             sensorType == Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED) {             return true;         } else {             return false;         }     }      private void checkHifiVrSensorSupport(int sensorType) {         boolean isVrSensor = mVrHighPerformanceModeSupported &&             sensorRequiredForVrHighPerformanceMode(sensorType);         if (mAreHifiSensorsSupported || isVrSensor) {             Sensor sensor = mSensorManager.getDefaultSensor(sensorType);             assertTrue(sensor != null);             if (isVrSensor && mIsVrHeadset) {                 assertTrue(sensor.isDirectChannelTypeSupported(SensorDirectChannel.TYPE_HARDWARE_BUFFER));             }         }     }      private boolean hasSensorType(int sensorType) {         return (mSensorManager != null && mSensorManager.getDefaultSensor(sensorType) != null);     } }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorParameterRangeTest"	"testPressureRange"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorParameterRangeTest.java"	""	"public void testPressureRange() {         checkSensorRangeAndFrequency(                 Sensor.TYPE_PRESSURE,                 PRESSURE_MAX_RANGE,                 PRESSURE_MAX_FREQUENCY,                 PRESSURE_HIFI_MAX_RANGE,                 PRESSURE_HIFI_MIN_FREQUENCY,                 PRESSURE_HIFI_MAX_FREQUENCY);     }      private void checkSensorRangeAndFrequency(             int sensorType, double maxRange, double maxFrequency, double hifiMaxRange,             double hifiMinFrequency, double hifiMaxFrequency) {         boolean mustMeetHiFi = mHasHifiSensors;          // CDD 7.9.2/C-1-21: High Performance VR must meet accel, gyro, and mag HiFi requirements         if (mVrModeHighPerformance && (sensorType == Sensor.TYPE_ACCELEROMETER ||                 sensorType == Sensor.TYPE_GYROSCOPE || sensorType == Sensor.TYPE_MAGNETIC_FIELD)) {             mustMeetHiFi = true;         }          Sensor sensor = mSensorManager.getDefaultSensor(sensorType);         if (sensor == null) {             if (mustMeetHiFi) {                 fail(String.format(""Must support sensor type %d"", sensorType));             } else {                 // Sensor is not required                 return;             }         }          double range = mustMeetHiFi ? hifiMaxRange : maxRange;         double frequency = mustMeetHiFi ? hifiMaxFrequency : maxFrequency;          assertTrue(String.format(""%s Range actual=%.2f expected=%.2f %s"",                     sensor.getName(), sensor.getMaximumRange(), range,                     SensorCtsHelper.getUnitsForSensor(sensor)),                 sensor.getMaximumRange() >= (range - 0.1));          double actualMaxFrequency = SensorCtsHelper.getFrequency(sensor.getMinDelay(),                 TimeUnit.MICROSECONDS);         assertTrue(String.format(""%s Max Frequency actual=%.2f expected=%.2fHz"",                     sensor.getName(), actualMaxFrequency, frequency), actualMaxFrequency >=                 frequency - 0.1);          if (mustMeetHiFi) {             double actualMinFrequency = SensorCtsHelper.getFrequency(sensor.getMaxDelay(),                     TimeUnit.MICROSECONDS);             assertTrue(String.format(""%s Min Frequency actual=%.2f expected=%.2fHz"",                         sensor.getName(), actualMinFrequency, hifiMinFrequency),                     actualMinFrequency <=  hifiMinFrequency + 0.1);         }     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorParameterRangeTest"	"testStepDetectorFifoLength"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorParameterRangeTest.java"	""	"public void testStepDetectorFifoLength() throws Throwable {         if (!mHasHifiSensors) return;         checkMinFifoLength(Sensor.TYPE_STEP_DETECTOR, STEP_DETECTOR_MIN_FIFO_LENGTH);     }      private void checkMinFifoLength(int sensorType, int minRequiredLength) {         Sensor sensor = mSensorManager.getDefaultSensor(sensorType);         assertTrue(String.format(""sensor of type=%d (null)"", sensorType), sensor != null);         int reservedLength = sensor.getFifoReservedEventCount();         assertTrue(String.format(""Sensor=%s, min required fifo length=%d actual=%d"",                     sensor.getName(), minRequiredLength, reservedLength),                     reservedLength >= minRequiredLength);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SingleSensorTests"	"testSensorProperties"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SingleSensorTests.java"	""	"public void testSensorProperties() {         // sensor type: [getMinDelay()]         Map<Integer, Object[]> expectedProperties = new HashMap<>(3);         if(getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) {                 expectedProperties.put(Sensor.TYPE_ACCELEROMETER, new Object[]{20000});                 expectedProperties.put(Sensor.TYPE_GYROSCOPE, new Object[]{20000});         }else {                 expectedProperties.put(Sensor.TYPE_ACCELEROMETER, new Object[]{10000});                 expectedProperties.put(Sensor.TYPE_GYROSCOPE, new Object[]{10000});         }         expectedProperties.put(Sensor.TYPE_MAGNETIC_FIELD, new Object[]{100000});          SensorManager sensorManager =                 (SensorManager) getContext().getSystemService(Context.SENSOR_SERVICE);         assertNotNull(""SensorManager not present in the system."", sensorManager);         for (Entry<Integer, Object[]> entry : expectedProperties.entrySet()) {             Sensor sensor = sensorManager.getDefaultSensor(entry.getKey());             if (sensor != null) {                 if (entry.getValue()[0] != null) {                     int expected = (Integer) entry.getValue()[0];                     String msg = String.format(                             ""%s: min delay %dus expected to be less than or equal to %dus"",                             sensor.getName(),                             sensor.getMinDelay(),                             expected);                     assertTrue(msg, sensor.getMinDelay() <= expected);                 }             }         }     }      // TODO: Figure out if a better way to enumerate test cases programmatically exists that works     // with CTS framework."	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorDirectReportTest"	"testCloseWithoutConfigStop"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testCloseWithoutConfigStop() {         for (int type : POSSIBLE_SENSOR_TYPES) {             for (int memType : POSSIBLE_CHANNEL_TYPES) {                 Sensor s = mSensorManager.getDefaultSensor(type);                 if (s == null                         || s.getHighestDirectReportRateLevel() == SensorDirectChannel.RATE_STOP                         || !s.isDirectChannelTypeSupported(memType)) {                     continue;                 }                  mChannel = prepareDirectChannel(memType, false /* secondary */);                 assertTrue(""createDirectChannel failed"", mChannel != null);                  try {                     waitBeforeStartSensor();                     mChannel.configure(s, s.getHighestDirectReportRateLevel());                      // wait for a while                     waitBeforeStartSensor();                      // The following line is commented out intentionally.                     // mChannel.configure(s, SensorDirectChannel.RATE_STOP);                 } finally {                     mChannel.close();                     mChannel = null;                 }                 waitBeforeStartSensor();             }         }     }      private void runSingleChannelRateIndependencyTestGroup(int type1, int type2) {         if (type1 == type2) {             throw new IllegalArgumentException(""Cannot run single channel rate independency test ""                     + ""on type "" + type1 + "" and "" + type2);         }         String stype1 = SensorCtsHelper.sensorTypeShortString(type1);         String stype2 = SensorCtsHelper.sensorTypeShortString(type2);          TestResultCollector c =                 new TestResultCollector(                     ""testRateIndependency"" + stype1 + stype2 + ""SingleChannel"", TAG);          for (int rate1 : POSSIBLE_RATE_LEVELS) {             for (int rate2 : POSSIBLE_RATE_LEVELS) {                 for (int memType : POSSIBLE_CHANNEL_TYPES) {                     c.perform(                         () -> {                             runSingleChannelRateIndependencyTest(                                     type1, rate1, type2, rate2,                                     SensorDirectChannel.TYPE_MEMORY_FILE);                         },                         String.format(""(%s rate %d, %s rate %d, mem %d)"",                                       stype1, rate1, stype2, rate2, memType));                 }             }         }         c.judge();     }      public void runMultiChannelRateIndependencyTestGroup(int sensorType) {         TestResultCollector c = new TestResultCollector(                 ""testRateIndependency"" + SensorCtsHelper.sensorTypeShortString(sensorType)                     + ""MultiChannel"", TAG);          for (int rate1 : POSSIBLE_RATE_LEVELS) {             for (int rate2 : POSSIBLE_RATE_LEVELS) {                 for (int type1 : POSSIBLE_CHANNEL_TYPES) {                     for (int type2 : POSSIBLE_CHANNEL_TYPES) {                         // only test upper triangle                         if (rate1 > rate2 || type1 > type2) {                             continue;                         }                         c.perform(() -> {                                 runMultiChannelRateIndependencyTest(                                         sensorType, rate1, rate2, type1, type2);},                                 String.format(""rate1 %d, rate2 %d, type1 %d, type2 %d"",                                               rate1, rate2, type1, type2));                     }                 }             }         }         c.judge();     }      public void runMultiModeRateIndependencyTestGroup(int sensorType) {         TestResultCollector c = new TestResultCollector(                 ""testRateIndependency"" + SensorCtsHelper.sensorTypeShortString(sensorType)                     + ""MultiMode"", TAG);          for (int rate : POSSIBLE_RATE_LEVELS) {             for (int type : POSSIBLE_CHANNEL_TYPES) {                 for (int samplingPeriodUs : POSSIBLE_SAMPLE_PERIOD_US) {                     c.perform(() -> {runMultiModeRateIndependencyTest(                                         sensorType, rate, type, samplingPeriodUs);},                               String.format(""rateLevel %d, memType %d, period %d"",                                             rate, type, samplingPeriodUs));                 }             }         }         c.judge();     }      private void runTimestampTestGroup(int sensorType) {         String stype = SensorCtsHelper.sensorTypeShortString(sensorType);          TestResultCollector c =                 new TestResultCollector(""testTimestamp"" + stype, TAG);          for (int rateLevel : POSSIBLE_RATE_LEVELS) {             for (int memType : POSSIBLE_CHANNEL_TYPES) {                 c.perform(                         () -> {                             runTimestampTest(sensorType, rateLevel, memType);                         },                         String.format(""(%s, rate %d, memtype %d)"", stype, rateLevel, memType));             }         }         c.judge();     }      private void runSensorDirectReportTest(int sensorType, int memType, int rateLevel)             throws AssertionError {         Sensor s = mSensorManager.getDefaultSensor(sensorType);         if (s == null                 || s.getHighestDirectReportRateLevel() < rateLevel                 || !s.isDirectChannelTypeSupported(memType)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);          try {             assertTrue(""Shared memory is not formatted"", isSharedMemoryFormatted(memType));             waitBeforeStartSensor();              int token = mChannel.configure(s, rateLevel);             assertTrue(""configure direct mChannel failed"", token > 0);              waitSensorCollection();              //stop sensor and analyze content             mChannel.configure(s, SensorDirectChannel.RATE_STOP);             checkSharedMemoryContent(s, memType, rateLevel, token);         } finally {             mChannel.close();             mChannel = null;         }     }      private void runSensorDirectReportUidIdleTest(int sensorType, int memType, int rateLevel) {         Sensor s = mSensorManager.getDefaultSensor(sensorType);         if (s == null                 || s.getHighestDirectReportRateLevel() < rateLevel                 || !s.isDirectChannelTypeSupported(memType)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);          try {             assertTrue(""Shared memory is not formatted"", isSharedMemoryFormatted(memType));             waitBeforeStartSensor();              int token = mChannel.configure(s, rateLevel);             assertTrue(""configure direct mChannel failed"", token > 0);              // Make package idle and ensure no sensor events are received             try {                 SensorCtsHelper.makeMyPackageIdle();             } catch (IOException e) {                 fail(""IOException while making package idle"");             }              int originalEventSize = mBuffer.length;             waitSensorCollection();              assertEquals(mBuffer.length, originalEventSize);              try {                 SensorCtsHelper.makeMyPackageActive();             } catch (IOException e) {                 fail(""IOException while making package active"");             }              // Also verify sensor events can be received after becoming active.             resetEvent();              waitSensorCollection();              //stop sensor and analyze content             mChannel.configure(s, SensorDirectChannel.RATE_STOP);             checkSharedMemoryContent(s, memType, rateLevel, token);         } finally {             mChannel.close();             mChannel = null;         }     }      private void runSingleChannelRateIndependencyTest(             int type1, int rateLevel1, int type2, int rateLevel2, int memType)                 throws AssertionError {         Sensor s1 = mSensorManager.getDefaultSensor(type1);         Sensor s2 = mSensorManager.getDefaultSensor(type2);         if (s1 == null                 || s1.getHighestDirectReportRateLevel() < rateLevel1                 || !s1.isDirectChannelTypeSupported(memType)) {             return;         }          if (s2 == null                 || s2.getHighestDirectReportRateLevel() < rateLevel2                 || !s2.isDirectChannelTypeSupported(memType)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);          try {             assertTrue(""Shared memory is not formatted"", isSharedMemoryFormatted(memType));             waitBeforeStartSensor();              int token1 = mChannel.configure(s1, rateLevel1);             int token2 = mChannel.configure(s2, rateLevel2);             assertTrue(""configure direct mChannel failed, token1 = "" + token1, token1 > 0);             assertTrue(""configure direct mChannel failed, token2 = "" + token2, token2 > 0);              // run half amount of time so buffer is enough for both sensors             try {                 SensorCtsHelper.sleep(TEST_RUN_TIME_PERIOD_MILLISEC / 2, TimeUnit.MILLISECONDS);             } catch (InterruptedException e) {                 Thread.currentThread().interrupt();             }              //stop sensor and analyze content             mChannel.configure(s1, SensorDirectChannel.RATE_STOP);             mChannel.configure(s2, SensorDirectChannel.RATE_STOP);              readSharedMemory(memType, false /*secondary*/);             checkEventRate(TEST_RUN_TIME_PERIOD_MILLISEC / 2, parseEntireBuffer(mBuffer, token1),                            type1, rateLevel1);             checkEventRate(TEST_RUN_TIME_PERIOD_MILLISEC / 2, parseEntireBuffer(mBuffer, token2),                            type2, rateLevel2);         } finally {             mChannel.close();             mChannel = null;         }     }      private void runMultiChannelRateIndependencyTest(             int type, int rateLevel1, int rateLevel2, int memType1, int memType2)                 throws AssertionError {         Sensor s = mSensorManager.getDefaultSensor(type);         if (s == null                 || s.getHighestDirectReportRateLevel() < Math.max(rateLevel1, rateLevel2)                 || !s.isDirectChannelTypeSupported(memType1)                 || !s.isDirectChannelTypeSupported(memType2)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType1, false /* secondary */);         mChannelSecondary = prepareDirectChannel(memType2, true /* secondary */);          try {             assertTrue(""createDirectChannel failed"", mChannel != null);             assertTrue(""Shared memory is not formatted"",                        isSharedMemoryFormatted(memType1));              assertTrue(""createDirectChannel(secondary) failed"", mChannelSecondary != null);             assertTrue(""Shared memory(secondary) is not formatted"",                        isSharedMemoryFormatted(memType2, true));              waitBeforeStartSensor();              int token1 = mChannel.configure(s, rateLevel1);             int token2 = mChannelSecondary.configure(s, rateLevel2);             assertTrue(""configure direct mChannel failed"", token1 > 0);             assertTrue(""configure direct mChannelSecondary failed"", token2 > 0);              waitSensorCollection();              //stop sensor and analyze content             mChannel.configure(s, SensorDirectChannel.RATE_STOP);             mChannelSecondary.configure(s, SensorDirectChannel.RATE_STOP);              // check rate             readSharedMemory(memType1, false /*secondary*/);             checkEventRate(TEST_RUN_TIME_PERIOD_MILLISEC, parseEntireBuffer(mBuffer, token1),                            type, rateLevel1);              readSharedMemory(memType2, true /*secondary*/);             checkEventRate(TEST_RUN_TIME_PERIOD_MILLISEC, parseEntireBuffer(mBuffer, token2),                            type, rateLevel2);         } finally {             if (mChannel != null) {                 mChannel.close();                 mChannel = null;             }             if (mChannelSecondary != null) {                 mChannelSecondary.close();                 mChannelSecondary = null;             }         }     }      private void runMultiModeRateIndependencyTest(             int type , int rateLevel, int memType, int samplingPeriodUs)                 throws AssertionError {         final Sensor s = mSensorManager.getDefaultSensor(type);         if (s == null                 || s.getHighestDirectReportRateLevel() < rateLevel                 || !s.isDirectChannelTypeSupported(memType)) {             return;         }          if (samplingPeriodUs == 0) {             samplingPeriodUs = s.getMinDelay();         }          if (samplingPeriodUs < s.getMinDelay()) {             return;         }          if (samplingPeriodUs > s.getMaxDelay()) {             samplingPeriodUs = s.getMaxDelay();         }          resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);         SensorEventCollection listener = new SensorEventCollection(s);          try {             waitBeforeStartSensor();             int token = mChannel.configure(s, rateLevel);             boolean registerRet = mSensorManager.registerListener(listener, s, samplingPeriodUs);             assertTrue(""Register listener failed"", registerRet);              waitSensorCollection();              mChannel.configure(s, SensorDirectChannel.RATE_STOP);             mSensorManager.unregisterListener(listener);              // check direct report rate             readSharedMemory(memType, false /*secondary*/);             List<DirectReportSensorEvent> events = parseEntireBuffer(mBuffer, token);             checkEventRate(TEST_RUN_TIME_PERIOD_MILLISEC, events, type, rateLevel);              // check callback interface rate             checkEventRateUs(TEST_RUN_TIME_PERIOD_MILLISEC, listener.getEvents(), type,                              samplingPeriodUs);         } finally {             mChannel.close();             mChannel = null;             mSensorManager.unregisterListener(listener);         }     }      private void runTimestampTest(int type, int rateLevel, int memType) {         Sensor s = mSensorManager.getDefaultSensor(type);         if (s == null                 || s.getHighestDirectReportRateLevel() < rateLevel                 || !s.isDirectChannelTypeSupported(memType)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);          SensorEventCollection listener = new SensorEventCollection(s);          try {             float nominalFreq = getNominalFreq(rateLevel);             int samplingPeriodUs = Math.max((int) (1e6f / nominalFreq), s.getMinDelay());              assertTrue(""Shared memory is not formatted"",                        isSharedMemoryFormatted(memType));              int token = mChannel.configure(s, rateLevel);             assertTrue(""configure direct mChannel failed"", token > 0);              boolean registerRet = mSensorManager.registerListener(listener, s, samplingPeriodUs);             assertTrue(""Register listener failed"", registerRet);              List<DirectReportSensorEvent> events = collectSensorEventsRealtime(                     memType, false /*secondary*/, TEST_RUN_TIME_PERIOD_MILLISEC);             assertTrue(""Realtime event collection failed"", events != null);             assertTrue(""Realtime event collection got no data"", events.size() > 0);              //stop sensor and analyze content             mChannel.configure(s, SensorDirectChannel.RATE_STOP);             mSensorManager.unregisterListener(listener);              // check rate             checkTimestampRelative(events, listener.getEvents());             checkTimestampAbsolute(events);         } finally {             mChannel.close();             mChannel = null;         }     }      private void runAtomicCounterTest(int sensorType, int memType) throws AssertionError {         Sensor s = mSensorManager.getDefaultSensor(sensorType);         if (s == null                 || s.getHighestDirectReportRateLevel() == SensorDirectChannel.RATE_STOP                 || !s.isDirectChannelTypeSupported(memType)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);          try {             assertTrue(""Shared memory is not formatted"", isSharedMemoryFormatted(memType));             waitBeforeStartSensor();              //int token = mChannel.configure(s, SensorDirectChannel.RATE_FAST);             int token = mChannel.configure(s, s.getHighestDirectReportRateLevel());             assertTrue(""configure direct mChannel failed"", token > 0);              checkAtomicCounterUpdate(memType, 30 * 1000); // half min              //stop sensor and analyze content             mChannel.configure(s, SensorDirectChannel.RATE_STOP);         } finally {             mChannel.close();             mChannel = null;         }     }      private void runReconfigureTest(int type, int memType) {         Sensor s = mSensorManager.getDefaultSensor(type);         if (s == null                 || s.getHighestDirectReportRateLevel() == SensorDirectChannel.RATE_STOP                 || !s.isDirectChannelTypeSupported(memType)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);          try {             assertTrue(""Shared memory is not formatted"", isSharedMemoryFormatted(memType));             waitBeforeStartSensor();              int offset = 0;             long counter = 1;             List<Integer> rateLevels = new ArrayList<>();             List<DirectReportSensorEvent> events;              rateLevels.add(s.getHighestDirectReportRateLevel());             rateLevels.add(s.getHighestDirectReportRateLevel());             if (s.getHighestDirectReportRateLevel() != SensorDirectChannel.RATE_NORMAL) {                 rateLevels.add(SensorDirectChannel.RATE_NORMAL);             }              for (int rateLevel : rateLevels) {                 int token = mChannel.configure(s, rateLevel);                 assertTrue(""configure direct mChannel failed"", token > 0);                  events = collectSensorEventsRealtime(memType, false /*secondary*/,                                                      TEST_RUN_TIME_PERIOD_MILLISEC,                                                      offset, counter);                 // stop sensor                 mChannel.configure(s, SensorDirectChannel.RATE_STOP);                 checkEventRate(TEST_RUN_TIME_PERIOD_MILLISEC, events, type, rateLevel);                  // collect all events after stop                 events = collectSensorEventsRealtime(memType, false /*secondary*/,                                                      REST_PERIOD_BEFORE_TEST_MILLISEC,                                                      offset, counter);                 if (events.size() > 0) {                     offset += (events.size() * SENSORS_EVENT_SIZE ) % SHARED_MEMORY_SIZE;                     counter = events.get(events.size() - 1).serial;                 }             }              // finally stop the report             mChannel.configure(s, SensorDirectChannel.RATE_STOP);         } finally {             mChannel.close();             mChannel = null;         }     }      private void waitBeforeStartSensor() {         // wait for sensor system to come to a rest after previous test to avoid flakiness.         try {             SensorCtsHelper.sleep(REST_PERIOD_BEFORE_TEST_MILLISEC, TimeUnit.MILLISECONDS);         } catch (InterruptedException e) {             Thread.currentThread().interrupt();         }     }      private void waitSensorCollection() {         // wait for sensor collection to finish         try {             SensorCtsHelper.sleep(TEST_RUN_TIME_PERIOD_MILLISEC, TimeUnit.MILLISECONDS);         } catch (InterruptedException e) {             Thread.currentThread().interrupt();         }     }      private List<DirectReportSensorEvent> collectSensorEventsRealtime(             int memType, boolean secondary, int timeoutMs) {         return collectSensorEventsRealtime(memType, secondary, timeoutMs,                                           0 /*initialOffset*/, 1l /*initialCounter*/);     }      private List<DirectReportSensorEvent> collectSensorEventsRealtime(             int memType, boolean secondary, int timeoutMs, int initialOffset, long initialCounter) {         List<DirectReportSensorEvent> events = new ArrayList<>();         long endTime = SystemClock.elapsedRealtime() + timeoutMs;          long atomicCounter = initialCounter;         int offset = initialOffset;          long timeA = SystemClock.elapsedRealtimeNanos();         boolean synced = false;         int filtered = 0;          while (SystemClock.elapsedRealtime() < endTime) {             if (!readSharedMemory(                     memType, secondary, offset + ATOMIC_COUNTER_OFFSET, ATOMIC_COUNTER_SIZE)) {                 return null;             }              long timeB = SystemClock.elapsedRealtimeNanos();             if (timeB - timeA > 1_000_000L ) { // > 1ms                 synced = false;             }             timeA = timeB;              if (readAtomicCounter(offset) == atomicCounter) {                 // read entire event again and parse                 if (!readSharedMemory(memType, secondary, offset, SENSORS_EVENT_SIZE)) {                     return null;                 }                 DirectReportSensorEvent e = mEventPool.get();                 assertNotNull(""cannot get event from reserve"", e);                 parseSensorEvent(offset, e);                  atomicCounter += 1;                 if (synced) {                     events.add(e);                 } else {                     ++filtered;                 }                  offset += SENSORS_EVENT_SIZE;                 if (offset + SENSORS_EVENT_SIZE > SHARED_MEMORY_SIZE) {                     offset = 0;                 }             } else {                 synced = true;             }         }         Log.d(TAG, ""filtered "" + filtered + "" events, remain "" + events.size() + "" events"");         return events;     }      private void checkAtomicCounterUpdate(int memType, int timeoutMs) {         List<DirectReportSensorEvent> events = new ArrayList<>();         long endTime = SystemClock.elapsedRealtime() + timeoutMs;          boolean lastValid = false;         long atomicCounter = 1;         int lastOffset = 0;         int offset = 0;          byte[] lastArray = new byte[SENSORS_EVENT_SIZE];         DirectReportSensorEvent e = getEvent();          while (SystemClock.elapsedRealtime() < endTime) {             if (!readSharedMemory(memType, false/*secondary*/, lastOffset, SENSORS_EVENT_SIZE)                     || !readSharedMemory(memType, false/*secondary*/,                                          offset + ATOMIC_COUNTER_OFFSET, ATOMIC_COUNTER_SIZE)) {                 throw new IllegalStateException(""cannot read shared memory, type "" + memType);             }              if (lastValid) {                 boolean failed = false;                 int i;                 for (i = 0; i < SENSORS_EVENT_SIZE; ++i) {                     if (lastArray[i] != mBuffer[lastOffset + i]) {                         failed = true;                         break;                     }                 }                  if (failed) {                     byte[] currentArray = new byte[SENSORS_EVENT_SIZE];                     System.arraycopy(mBuffer, lastOffset, currentArray, 0, SENSORS_EVENT_SIZE);                      // wait for 100ms and read again to see if the change settle                     try {                         SensorCtsHelper.sleep(100, TimeUnit.MILLISECONDS);                     } catch (InterruptedException ex) {                         Thread.currentThread().interrupt();                     }                      byte[] delayedRead = new byte[SENSORS_EVENT_SIZE];                     if (!readSharedMemory(                                 memType, false/*secondary*/, lastOffset, SENSORS_EVENT_SIZE)) {                         throw new IllegalStateException(                                 ""cannot read shared memory, type "" + memType);                     }                     System.arraycopy(mBuffer, lastOffset, delayedRead, 0, SENSORS_EVENT_SIZE);                      fail(String.format(                             ""At offset %d(0x%x), byte %d(0x%x) changed after atomicCounter""                                 + ""(expecting %d, 0x%x) update, old = [%s], new = [%s], ""                                 + ""delayed = [%s]"",                             lastOffset, lastOffset, i, i, atomicCounter, atomicCounter,                             SensorCtsHelper.bytesToHex(lastArray, -1, -1),                             SensorCtsHelper.bytesToHex(currentArray, -1, -1),                             SensorCtsHelper.bytesToHex(delayedRead, -1, -1)));                 }             }              if (readAtomicCounter(offset) == atomicCounter) {                 // read entire event again and parse                 if (!readSharedMemory(memType, false/*secondary*/, offset, SENSORS_EVENT_SIZE)) {                     throw new IllegalStateException(""cannot read shared memory, type "" + memType);                 }                 parseSensorEvent(offset, e);                  atomicCounter += 1;                  lastOffset = offset;                 System.arraycopy(mBuffer, lastOffset, lastArray, 0, SENSORS_EVENT_SIZE);                 lastValid = true;                  offset += SENSORS_EVENT_SIZE;                 if (offset + SENSORS_EVENT_SIZE > SHARED_MEMORY_SIZE) {                     offset = 0;                 }             }         }         Log.d(TAG, ""at finish checkAtomicCounterUpdate has atomic counter = "" + atomicCounter);         // atomicCounter will not wrap back in reasonable amount of time         assertTrue(""Realtime event collection got no data"", atomicCounter != 1);     }      private MemoryFile allocateMemoryFile() {         MemoryFile memFile = null;         try {             memFile = new MemoryFile(""Sensor Channel"", SHARED_MEMORY_SIZE);         } catch (IOException e) {             Log.e(TAG, ""IOException when allocating MemoryFile"");         }         return memFile;     }      private HardwareBuffer allocateHardwareBuffer() {         HardwareBuffer hardwareBuffer;          hardwareBuffer = HardwareBuffer.create(                 SHARED_MEMORY_SIZE, 1 /* height */, HardwareBuffer.BLOB, 1 /* layer */,                 HardwareBuffer.USAGE_CPU_READ_OFTEN | HardwareBuffer.USAGE_GPU_DATA_BUFFER                     | HardwareBuffer.USAGE_SENSOR_DIRECT_DATA);         return hardwareBuffer;     }      private SensorDirectChannel prepareDirectChannel(int memType, boolean secondary) {         SensorDirectChannel channel = null;          try {             switch(memType) {                 case SensorDirectChannel.TYPE_MEMORY_FILE: {                     MemoryFile memoryFile = secondary ? mMemoryFileSecondary : mMemoryFile;                     assertTrue(""MemoryFile"" + (secondary ? ""(secondary)"" : """") + "" is null"",                                memoryFile != null);                     channel = mSensorManager.createDirectChannel(memoryFile);                     break;                 }                 case SensorDirectChannel.TYPE_HARDWARE_BUFFER: {                     HardwareBuffer hardwareBuffer                             = secondary ? mHardwareBufferSecondary : mHardwareBuffer;                     assertTrue(""HardwareBuffer"" + (secondary ? ""(secondary)"" : """") + "" is null"",                                hardwareBuffer != null);                     channel = mSensorManager.createDirectChannel(hardwareBuffer);                     break;                 }                 default:                     Log.e(TAG, ""Specified illegal memory type "" + memType);             }         } catch (IllegalStateException | UncheckedIOException e) {             Log.e(TAG, ""Cannot initialize channel for memory type "" + memType                     + "", details:"" + e);             channel = null;         }         return channel;     }      private boolean readSharedMemory(int memType, boolean secondary, int offset, int length) {         switch(memType) {             case SensorDirectChannel.TYPE_MEMORY_FILE:                 try {                     MemoryFile f = secondary ? mMemoryFileSecondary : mMemoryFile;                     if (f.readBytes(mBuffer, offset, offset, length) != length) {                         Log.e(TAG, ""cannot read entire MemoryFile"");                         return false;                     }                 } catch (IOException e) {                     Log.e(TAG, ""accessing MemoryFile causes IOException"");                     return false;                 }                 return true;             case SensorDirectChannel.TYPE_HARDWARE_BUFFER:                 return nativeReadHardwareBuffer(                         secondary ? mHardwareBufferSecondary : mHardwareBuffer,                         mBuffer, offset, offset, length);             default:                 return false;         }     }      private boolean readSharedMemory(int memType, boolean secondary) {         return readSharedMemory(memType, secondary, 0, SHARED_MEMORY_SIZE);     }      private boolean readSharedMemory(int memType) {         return readSharedMemory(memType, false /*secondary*/);     }      private boolean isMemoryTypeNeeded(int memType) {         List<Sensor> sensorList = mSensorManager.getSensorList(Sensor.TYPE_ALL);         for (Sensor s : sensorList) {             if (s.isDirectChannelTypeSupported(memType)) {                 return true;             }         }         return false;     }      private boolean isSharedMemoryFormatted(int memType) {         return isSharedMemoryFormatted(memType, false /* secondary */);     }      private boolean isSharedMemoryFormatted(int memType, boolean secondary) {         readSharedMemory(memType, secondary);          for (byte b : mBuffer) {             if (b != 0) {                 return false;             }         }         return true;     }      private void checkSharedMemoryContent(Sensor s, int memType, int rateLevel, int token) {         assertTrue(""read mem type "" + memType + "" content failed"", readSharedMemory(memType));          int offset = 0;         int nextSerial = 1;         DirectReportSensorEvent e = getEvent();         while (offset <= SHARED_MEMORY_SIZE - SENSORS_EVENT_SIZE) {             parseSensorEvent(offset, e);              if (e.serial == 0) {                 // reaches end of events                 break;             }              assertTrue(""incorrect size "" + e.size + ""  at offset "" + offset,                     e.size == SENSORS_EVENT_SIZE);             assertTrue(""incorrect token "" + e.token + "" at offset "" + offset,                     e.token == token);             assertTrue(""incorrect serial "" + e.serial + "" at offset "" + offset,                     e.serial == nextSerial);             assertTrue(""incorrect type "" + e.type + "" offset "" + offset,                     e.type == s.getType());              switch(s.getType()) {                 case Sensor.TYPE_ACCELEROMETER:                     double accNorm = Math.sqrt(e.x * e.x + e.y * e.y + e.z * e.z);                     assertTrue(""incorrect gravity norm "" + accNorm + "" at offset "" + offset,                             accNorm < GRAVITY_MAX && accNorm > GRAVITY_MIN);                     break;                 case Sensor.TYPE_GYROSCOPE:                     double gyroNorm = Math.sqrt(e.x * e.x + e.y * e.y + e.z * e.z);                     assertTrue(""gyro norm too large ("" + gyroNorm + "") at offset "" + offset,                             gyroNorm < GYRO_NORM_MAX);                     break;             }              ++nextSerial;             offset += SENSORS_EVENT_SIZE;         }          int nEvents = nextSerial - 1;         float nominalFreq = 0;          switch (rateLevel) {             case SensorDirectChannel.RATE_NORMAL:                 nominalFreq = RATE_NORMAL_NOMINAL;                 break;             case SensorDirectChannel.RATE_FAST:                 nominalFreq = RATE_FAST_NOMINAL;                 break;             case SensorDirectChannel.RATE_VERY_FAST:                 nominalFreq = RATE_VERY_FAST_NOMINAL;                 break;         }          if (nominalFreq != 0) {             int minEvents;             int maxEvents;             minEvents = (int) Math.floor(                     nominalFreq                     * FREQ_LOWER_BOUND                     * (TEST_RUN_TIME_PERIOD_MILLISEC - ALLOWED_SENSOR_INIT_TIME_MILLISEC)                     * (1 - MERCY_FACTOR)                     / 1000);             maxEvents = (int) Math.ceil(                     nominalFreq                     * FREQ_UPPER_BOUND                     * TEST_RUN_TIME_PERIOD_MILLISEC                     * (1 + MERCY_FACTOR)                     / 1000);              assertTrue(""nEvent is "" + nEvents + "" not between "" + minEvents + "" and "" + maxEvents,                     nEvents >= minEvents && nEvents <=maxEvents);         }     }      private void checkEventRate(int testTimeMs, List<DirectReportSensorEvent> events,                                 int type, int rateLevel) {         assertTrue(""insufficient events of type "" + type, events.size() > 1);         for (DirectReportSensorEvent e : events) {             assertTrue(""incorrect type "" + e.type + "" expecting "" + type, e.type == type);         }          // check number of events         int[] minMax = calculateExpectedNEvents(testTimeMs, rateLevel);         assertTrue(                 ""Number of event of type "" + type + "" is "" + events.size()                     + "", which is not in range ["" + minMax[0] + "", "" + minMax[1] + ""]."",                 minMax[0] <= events.size() && events.size() <= minMax[1]);          // intervals         List<Long> intervals = new ArrayList<>(events.size() - 1);         long minInterval = Long.MAX_VALUE;         long maxInterval = Long.MIN_VALUE;         long averageInterval = 0;         for (int i = 1; i < events.size(); ++i) {             long d = events.get(i).ts - events.get(i-1).ts;             averageInterval += d;             minInterval = Math.min(d, minInterval);             maxInterval = Math.max(d, maxInterval);             intervals.add(d);         }         averageInterval /= (events.size() - 1);          // average rate         float averageFreq = 1e9f / averageInterval;         float nominalFreq = getNominalFreq(rateLevel);         Log.d(TAG, String.format(                 ""checkEventRate type %d: averageFreq %f, nominalFreq %f, lbound %f, ubound %f"",                 type, averageFreq, nominalFreq,                 nominalFreq * FREQ_LOWER_BOUND,                 nominalFreq * FREQ_UPPER_BOUND));         assertTrue(""Average frequency of type "" + type + "" rateLevel "" + rateLevel                         + "" is "" + averageFreq,                    nominalFreq * FREQ_LOWER_BOUND * (1 - MERCY_FACTOR) <= averageFreq &&                        averageFreq <= nominalFreq * FREQ_UPPER_BOUND * (1 + MERCY_FACTOR));          // jitter variance         List<Long> percentileValues =                 SensorCtsHelper.getPercentileValue(intervals, 0.025f, (1 - 0.025f));         assertTrue(""Timestamp jitter of type "" + type + "" rateLevel "" + rateLevel + "" is ""                         + (percentileValues.get(1) - percentileValues.get(0) / 1000) + "" us, ""                         + ""while average interval is "" + (averageInterval / 1000) + ""us, over-range"",                    (percentileValues.get(1) - percentileValues.get(0)) / averageInterval < 0.05);         Log.d(TAG, String.format(                 ""checkEventRate type %d, timestamp interval range %f - %f ms, "" +                     ""span %f ms, %.2f%% of averageInterval"",                     type, percentileValues.get(0)/1e6f, percentileValues.get(1)/1e6f,                     (percentileValues.get(1) - percentileValues.get(0))/1e6f,                     (percentileValues.get(1) - percentileValues.get(0)) / averageInterval * 100.f));      }      private void checkEventRateUs(int testTimeMs, List<DirectReportSensorEvent> events,                                   int type, int samplingPeriodUs) {         // samplingPeriodUs must be a valid one advertised by sensor         assertTrue(""insufficient events of type "" + type, events.size() > 1);         for (DirectReportSensorEvent e : events) {             assertTrue(""incorrect type "" + e.type + "" expecting "" + type, e.type == type);         }          // check number of events         int[] minMax = calculateExpectedNEventsUs(testTimeMs, samplingPeriodUs);         assertTrue(                 ""Number of event of type "" + type + "" is "" + events.size()                     + "", which is not in range ["" + minMax[0] + "", "" + minMax[1] + ""]."",                 minMax[0] <= events.size() && events.size() <= minMax[1]);          // intervals         List<Long> intervals = new ArrayList<>(events.size() - 1);         long minInterval = Long.MAX_VALUE;         long maxInterval = Long.MIN_VALUE;         long averageInterval = 0;         for (int i = 1; i < events.size(); ++i) {             long d = events.get(i).ts - events.get(i-1).ts;             averageInterval += d;             minInterval = Math.min(d, minInterval);             maxInterval = Math.max(d, maxInterval);             intervals.add(d);         }         averageInterval /= (events.size() - 1);          // average rate         float averageFreq = 1e9f / averageInterval;         float nominalFreq = 1e6f / samplingPeriodUs;         Log.d(TAG, String.format(                 ""checkEventRateUs type %d: averageFreq %f, nominalFreq %f, lbound %f, ubound %f"",                 type, averageFreq, nominalFreq,                 nominalFreq * FREQ_LOWER_BOUND_POLL,                 nominalFreq * FREQ_UPPER_BOUND_POLL));         assertTrue(""Average frequency of type "" + type                         + "" is "" + averageFreq,                    nominalFreq * FREQ_LOWER_BOUND_POLL * (1 - MERCY_FACTOR) <= averageFreq &&                        averageFreq <= nominalFreq * FREQ_UPPER_BOUND_POLL * (1 + MERCY_FACTOR));          // jitter variance         List<Long> percentileValues =                 SensorCtsHelper.getPercentileValue(intervals, 0.025f, (1 - 0.025f));         assertTrue(""Timestamp jitter of type "" + type + "" is ""                         + (percentileValues.get(1) - percentileValues.get(0) / 1000) + "" us, ""                         + ""while average interval is "" + (averageInterval / 1000) + ""us, over-range"",                    (percentileValues.get(1) - percentileValues.get(0)) / averageInterval < 0.05);         Log.d(TAG, String.format(                 ""checkEventRateUs type %d, timestamp interval range %f - %f ms, "" +                     ""span %f ms, %.2f%% of averageInterval"",                     type, percentileValues.get(0)/1e6f, percentileValues.get(1)/1e6f,                     (percentileValues.get(1) - percentileValues.get(0)) / 1e6f,                     (percentileValues.get(1) - percentileValues.get(0)) / averageInterval * 100.f));     }      private void allocateSharedMemory() {         if (mNeedMemoryFile) {             mMemoryFile = allocateMemoryFile();             mMemoryFileSecondary = allocateMemoryFile();         }          if (mNeedHardwareBuffer) {             mHardwareBuffer = allocateHardwareBuffer();             mHardwareBufferSecondary = allocateHardwareBuffer();         }     }      private void freeSharedMemory() {         if (mMemoryFile != null) {             mMemoryFile.close();             mMemoryFile = null;         }          if (mMemoryFileSecondary != null) {             mMemoryFileSecondary.close();             mMemoryFileSecondary = null;         }          if (mHardwareBuffer != null) {             mHardwareBuffer.close();             mHardwareBuffer = null;         }          if (mHardwareBufferSecondary != null) {             mHardwareBufferSecondary.close();             mHardwareBufferSecondary = null;         }     }      private float getNominalFreq(int rateLevel) {         float nominalFreq = 0;         switch (rateLevel) {             case SensorDirectChannel.RATE_NORMAL:                 nominalFreq = RATE_NORMAL_NOMINAL;                 break;             case SensorDirectChannel.RATE_FAST:                 nominalFreq = RATE_FAST_NOMINAL;                 break;             case SensorDirectChannel.RATE_VERY_FAST:                 nominalFreq = RATE_VERY_FAST_NOMINAL;                 break;         }         return nominalFreq;     }      private int[] calculateExpectedNEvents(int timeMs, int rateLevel) {         int[] minMax = new int[] { -1, Integer.MAX_VALUE };         float nominalFreq = getNominalFreq(rateLevel);         if (nominalFreq != 0) {             // min             if (timeMs > ALLOWED_SENSOR_INIT_TIME_MILLISEC) {                 minMax[0] = (int) Math.floor(                         nominalFreq                         * FREQ_LOWER_BOUND                         * (timeMs - ALLOWED_SENSOR_INIT_TIME_MILLISEC)                         * (1 - MERCY_FACTOR)                         / 1000);             }             // max             minMax[1] = (int) Math.ceil(                     nominalFreq                     * FREQ_UPPER_BOUND                     * timeMs                     * (1 + MERCY_FACTOR)                     / 1000);         }         return minMax;     }      private void checkTimestampAbsolute(List<DirectReportSensorEvent> events) {         final int MAX_DETAIL_ITEM = 10;          StringBuffer buf = new StringBuffer();         int oneMsEarlyCount = 0;         int fiveMsLateCount = 0;         int tenMsLateCount = 0;         int errorCount = 0;          for (int i = 0; i < events.size(); ++i) {             DirectReportSensorEvent e = events.get(i);             long d = e.arrivalTs - e.ts;             boolean oneMsEarly = d < -1000_000;             boolean fiveMsLate = d > 5000_000;             boolean tenMsLate = d > 10_000_000;              if (oneMsEarly || fiveMsLate || tenMsLate) {                 oneMsEarlyCount += oneMsEarly ? 1 : 0;                 fiveMsLateCount += fiveMsLate ? 1 : 0;                 tenMsLateCount += tenMsLate ? 1 : 0;                  if (errorCount++ < MAX_DETAIL_ITEM) {                     buf.append(""["").append(i).append(""] diff = "").append(d / 1e6f).append("" ms; "");                 }             }         }          Log.d(TAG, String.format(""Irregular timestamp, %d, %d, %d out of %d"",                     oneMsEarlyCount, fiveMsLateCount, tenMsLateCount, events.size()));          if (CHECK_ABSOLUTE_LATENCY) {             assertTrue(String.format(                     ""Timestamp error, out of %d events, %d is >1ms early, %d is >5ms late, ""                         + ""%d is >10ms late, details: %s%s"",                         events.size(), oneMsEarlyCount, fiveMsLateCount, tenMsLateCount,                         buf.toString(), errorCount > MAX_DETAIL_ITEM ? ""..."" : """"),                     oneMsEarlyCount == 0                         && fiveMsLateCount <= events.size() / 20                         && tenMsLateCount <= events.size() / 100);         }     }      private void checkTimestampRelative(List<DirectReportSensorEvent> directEvents,                                         List<DirectReportSensorEvent> pollEvents) {         if (directEvents.size() < 10 || pollEvents.size() < 10) {             // cannot check with so few data points             return;         }          long directAverageLatency = 0;         for (DirectReportSensorEvent e : directEvents) {             directAverageLatency += e.arrivalTs - e.ts;         }         directAverageLatency /= directEvents.size();          long pollAverageLatency = 0;         for (DirectReportSensorEvent e : pollEvents) {             pollAverageLatency += e.arrivalTs - e.ts;         }         pollAverageLatency /= pollEvents.size();          Log.d(TAG, String.format(""Direct, poll latency = %f, %f ms"",                 directAverageLatency / 1e6f, pollAverageLatency / 1e6f));         assertTrue(                 String.format(""Direct, poll latency = %f, %f ms, expect direct < poll"",                     directAverageLatency / 1e6f,                     pollAverageLatency / 1e6f),                 directAverageLatency < pollAverageLatency + 1000_000);     }      private int[] calculateExpectedNEventsUs(int timeMs, int samplingPeriodUs) {         int[] minMax = new int[2];         minMax[0] = Math.max((int) Math.floor(                 (timeMs - ALLOWED_SENSOR_INIT_TIME_MILLISEC) * 1000/ samplingPeriodUs), 0);         minMax[1] = (int) Math.ceil(timeMs * 1000 * 2 / samplingPeriodUs);         return minMax;     }      private static class DirectReportSensorEvent {         public int size;         public int token;         public int type;         public long serial;         public long ts;         public float x;         public float y;         public float z;         public long arrivalTs;     };      // EventPool to avoid allocating too many event objects and hitting GC during test     private static class EventPool {         public EventPool(int n) {             mEvents = Arrays.asList(new DirectReportSensorEvent[n]);             for (int i = 0; i < n; ++i) {                 mEvents.set(i, new DirectReportSensorEvent());             }             reset();         }          public synchronized void reset() {             Log.d(TAG, ""Reset EventPool ("" + mIndex + "" events used)"");             mIndex = 0;         }          public synchronized DirectReportSensorEvent get() {             if (mIndex < mEvents.size()) {                 return mEvents.get(mIndex++);             } else {                 throw new IllegalStateException(""EventPool depleted"");             }         }          private List<DirectReportSensorEvent> mEvents;         private int mIndex;     };      private DirectReportSensorEvent getEvent() {         return mEventPool.get();     }      private DirectReportSensorEvent getEvent(DirectReportSensorEvent e) {         DirectReportSensorEvent event = mEventPool.get();         event.size = e.size;         event.token = e.token;         event.type = e.type;         event.serial = e.serial;         event.ts = e.ts;         event.x = e.x;         event.y = e.y;         event.z = e.z;         event.arrivalTs = e.arrivalTs;         return event;     }      private void resetEvent() {         mEventPool.reset();     }      private class SensorEventCollection implements SensorEventListener {         List<DirectReportSensorEvent> mEvents = new ArrayList<>();         Sensor mSensor;          public SensorEventCollection(Sensor s) {             mSensor = s;         }          List<DirectReportSensorEvent> getEvents() {             return mEvents;         }          @Override         public void onSensorChanged(SensorEvent event) {             if (mSensor == null || event.sensor == mSensor) {                 DirectReportSensorEvent e = mEventPool.get();                 e.size = SENSORS_EVENT_SIZE;                 e.token = event.sensor.getType();                 e.type = e.token;                 e.serial = -1;                 e.ts = event.timestamp;                 e.arrivalTs = SystemClock.elapsedRealtimeNanos();                  e.x = event.values[0];                 if (event.values.length > 1) {                     e.y = event.values[1];                 }                 if (event.values.length > 2) {                     e.z = event.values[2];                 }                 mEvents.add(e);             }         }          @Override         public void onAccuracyChanged(Sensor s, int accuracy) {             // do nothing         }     };      private List<DirectReportSensorEvent> parseEntireBuffer(byte[] buffer, int token) {         int offset = 0;         int nextSerial = 1;         List<DirectReportSensorEvent> events = new ArrayList<>();          while (offset <= SHARED_MEMORY_SIZE - SENSORS_EVENT_SIZE) {             DirectReportSensorEvent e = getEvent();             parseSensorEvent(offset, e);              if (e.serial == 0) {                 // reaches end of events                 break;             }              assertTrue(""incorrect size "" + e.size + ""  at offset "" + offset,                     e.size == SENSORS_EVENT_SIZE);             assertTrue(""incorrect serial "" + e.serial + "" at offset "" + offset,                     e.serial == nextSerial);              if (e.token == token) {                 events.add(e);             }              ++nextSerial;             offset += SENSORS_EVENT_SIZE;         }          return events;     }      // parse sensors_event_t from mBuffer and fill information into DirectReportSensorEvent     private void parseSensorEvent(int offset, DirectReportSensorEvent ev) {         mByteBuffer.position(offset);          ev.size = mByteBuffer.getInt();         ev.token = mByteBuffer.getInt();         ev.type = mByteBuffer.getInt();         ev.serial = ((long) mByteBuffer.getInt()) & 0xFFFFFFFFl; // signed=>unsigned         ev.ts = mByteBuffer.getLong();         ev.arrivalTs = SystemClock.elapsedRealtimeNanos();         ev.x = mByteBuffer.getFloat();         ev.y = mByteBuffer.getFloat();         ev.z = mByteBuffer.getFloat();     }      // parse sensors_event_t and fill information into DirectReportSensorEvent     private static void parseSensorEvent(byte [] buf, int offset, DirectReportSensorEvent ev) {         ByteBuffer b = ByteBuffer.wrap(buf, offset, SENSORS_EVENT_SIZE);         b.order(NATIVE_BYTE_ORDER);          ev.size = b.getInt();         ev.token = b.getInt();         ev.type = b.getInt();         ev.serial = ((long) b.getInt()) & 0xFFFFFFFFl; // signed=>unsigned         ev.ts = b.getLong();         ev.arrivalTs = SystemClock.elapsedRealtimeNanos();         ev.x = b.getFloat();         ev.y = b.getFloat();         ev.z = b.getFloat();     }      private long readAtomicCounter(int offset) {         mByteBuffer.position(offset + ATOMIC_COUNTER_OFFSET);         return ((long) mByteBuffer.getInt()) & 0xFFFFFFFFl; // signed => unsigned     }      private static long readAtomicCounter(byte [] buf, int offset) {         ByteBuffer b = ByteBuffer.wrap(buf, offset + ATOMIC_COUNTER_OFFSET, ATOMIC_COUNTER_SIZE);         b.order(ByteOrder.nativeOrder());          return ((long) b.getInt()) & 0xFFFFFFFFl; // signed => unsigned     } }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorIntegrationTests"	"testGeomagneticRotationVectorReconfigureWhileActive"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorIntegrationTests.java"	""	"public void testGeomagneticRotationVectorReconfigureWhileActive() throws Throwable {         verifySensorReconfigureWhileActive(Sensor.TYPE_GEOMAGNETIC_ROTATION_VECTOR);     }      /**      * This test focuses on ensuring that an active sensor is able to be reconfigured when a new      * client requests a different sampling rate.      *      * The test verifies that if a sensor is active with a slow sampling rate and a new client      * requests a faster sampling rate, the sensor begins returning data at the faster sampling      * rate.      *      * The assertion associated with the test failure provides:      * - the thread id on which the failure occurred      * - the sensor type and sensor handle that caused the failure      * - the event that caused the issue      * It is important to look at the internals of the Sensor HAL to identify how the interaction      * of several clients can lead to the failing state.      */     public void verifySensorReconfigureWhileActive(int sensorType) throws Throwable {         SensorCtsHelper.sleep(3, TimeUnit.SECONDS);          final int DELAY_BEFORE_CHANGING_RATE_SEC = 2;         final int EVENTS_FOR_VERIFICATION = 200;         Context context = getContext();         SensorManager sensorManager =                 (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);         assertNotNull(""SensorService is not present in the system"", sensorManager);          Sensor sensor = sensorManager.getDefaultSensor(sensorType);         if(sensor == null) {             throw new SensorNotSupportedException(sensorType);         }          // Request for the sensor rate to be set to the slowest rate.         ParallelSensorOperation operation = new ParallelSensorOperation();         TestSensorEnvironment environmentSlow = new TestSensorEnvironment(                 context,                 sensor,                 shouldEmulateSensorUnderLoad(),                 true, /* isIntegrationTest */                 sensor.getMaxDelay(),                 (int)TimeUnit.SECONDS.toMicros(20));         TestSensorOperation sensorOperationSlow = TestSensorOperation.createOperation(                 environmentSlow, 2 * DELAY_BEFORE_CHANGING_RATE_SEC, TimeUnit.SECONDS);         operation.add(sensorOperationSlow);          // Create a second operation that will run in parallel and request the fastest rate after         // an initial delay. The delay is to ensure that the first operation has enabled the sensor.         // The sensor should begin reporting at the newly requested rate. Execute a flush prior to         // the reconfiguration to ensure that the lower frequency events are not received after the         // reconfiguration of the sensor.         SequentialSensorOperation sequentialSensorOperation = new SequentialSensorOperation();         TestSensorEnvironment environmentFast = new TestSensorEnvironment(                 context,                 sensor,                 shouldEmulateSensorUnderLoad(),                 true, /* isIntegrationTest */                 sensor.getMinDelay(),                 0 /* max reporting latency */);          // Create the flush operation with a delay to ensure the low frequency configuration was         // handled and executed. Use the original environment since the flush operation will         // register a new listener and reconfigure the sensor.         TestSensorOperation flushOperation = TestSensorOperation.createFlushOperation(                 environmentSlow, DELAY_BEFORE_CHANGING_RATE_SEC, TimeUnit.SECONDS);         sequentialSensorOperation.add(flushOperation);          // Create the reconfiguration request and add it after the flush         TestSensorOperation sensorOperationFast = TestSensorOperation.createOperation(                 environmentFast, EVENTS_FOR_VERIFICATION);         sensorOperationFast.addVerification(FrequencyVerification.getDefault(environmentFast));         sequentialSensorOperation.add(sensorOperationFast);          // Add the sequential operation containing the flush and high frequency request to the         // existing parallel operation that already contains the low frequency request.         operation.add(sequentialSensorOperation);         operation.execute(getCurrentTestNode());         operation.getStats().log(TAG);     }      /**      * Regress:      * - b/10641388      */"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorBatchingFifoTest"	"testGameRotationVectorFifoLength"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorBatchingFifoTest.java"	""	"public void testGameRotationVectorFifoLength() throws Throwable {         if (!mHasHifiSensors) return;         runBatchingSensorFifoTest(                 Sensor.TYPE_GAME_ROTATION_VECTOR,                 getReservedFifoLength(Sensor.TYPE_GAME_ROTATION_VECTOR));     }      private int getReservedFifoLength(int sensorType) {         Sensor sensor = mSensorManager.getDefaultSensor(sensorType);         assertTrue(String.format(""sensor of type=%d (null)"", sensorType), sensor != null);         return sensor.getFifoReservedEventCount();     }      private void runBatchingSensorFifoTest(int sensorType, int fifoLength) throws Throwable {         if (fifoLength == 0) {             return;         }         Sensor sensor = mSensorManager.getDefaultSensor(sensorType);         TestSensorEnvironment environment =  new TestSensorEnvironment(getContext(),                 sensor,                 false, /* sensorMightHaveMoreListeners */                 sensor.getMinDelay(),                 Integer.MAX_VALUE /*maxReportLatencyUs*/);          int preFlushMs = 2000;  // 2 sec to make sure there is sample at the time of flush         int postFlushMs = environment.getExpectedSamplingPeriodUs() * 100 /1000;         int testFlushMs =                 environment.getSensor().getFifoReservedEventCount() *                 environment.getExpectedSamplingPeriodUs() / (int)(1000 / 1.2); // 120%          TestSensorOperation op = TestSensorOperation.createFlushOperation(                 environment, new int [] { preFlushMs, testFlushMs, postFlushMs }, -1);          op.addVerification(FifoLengthVerification.getDefault(environment));         op.execute(getCurrentTestNode());         op.getStats().log(TAG);     } }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.helpers.TestSensorEnvironment"	"isSensorSamplingRateOverloaded"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/helpers/TestSensorEnvironment.java"	""	"public void test/*  *  */  package android.hardware.cts.helpers;  import android.content.Context; import android.hardware.Sensor; import android.hardware.SensorManager; import android.hardware.cts.helpers.sensoroperations.SensorOperation;  import java.util.concurrent.TimeUnit;  /* TODO: Refactor constructors into a builder */  /**  * A class that encapsulates base environment information for the {@link SensorOperation}.  * The environment is self contained and carries its state around all the sensor test framework.  */ public class TestSensorEnvironment {      /**      * It represents the fraction of the expected sampling frequency, at which the sensor can      * actually produce events.      */     private static final float MAXIMUM_EXPECTED_SAMPLING_FREQUENCY_MULTIPLIER = 0.9f;      private final Context mContext;     private final Sensor mSensor;     private final boolean mSensorMightHaveMoreListeners;     private final int mSamplingPeriodUs;     private final int mMaxReportLatencyUs;     private final boolean mIsDeviceSuspendTest;     private final boolean mIsIntegrationTest;      /**      * Constructs an environment for sensor testing.      *      * @param context The context for the test      * @param sensorType The type of the sensor under test      * @param samplingPeriodUs The requested collection period for the sensor under test      *      * @deprecated Use variants with {@link Sensor} objects.      */     @Deprecated     public TestSensorEnvironment(Context context, int sensorType, int samplingPeriodUs) {         this(context, sensorType, false /* sensorMightHaveMoreListeners */, samplingPeriodUs);     }      /**      * Constructs an environment for sensor testing.      *      * @param context The context for the test      * @param sensorType The type of the sensor under test      * @param samplingPeriodUs The requested collection period for the sensor under test      * @param maxReportLatencyUs The requested collection report latency for the sensor under test      *      * @deprecated Use variants with {@link Sensor} objects.      */     @Deprecated     public TestSensorEnvironment(             Context context,             int sensorType,             int samplingPeriodUs,             int maxReportLatencyUs) {         this(context,                 sensorType,                 false /* sensorMightHaveMoreListeners */,                 samplingPeriodUs,                 maxReportLatencyUs);     }      /**      * Constructs an environment for sensor testing.      *      * @param context The context for the test      * @param sensorType The type of the sensor under test      * @param sensorMightHaveMoreListeners Whether the sensor under test is acting under load      * @param samplingPeriodUs The requested collection period for the sensor under test      *      * @deprecated Use variants with {@link Sensor} objects.      */     @Deprecated     public TestSensorEnvironment(             Context context,             int sensorType,             boolean sensorMightHaveMoreListeners,             int samplingPeriodUs) {         this(context,                 sensorType,                 sensorMightHaveMoreListeners,                 samplingPeriodUs,                 0 /* maxReportLatencyUs */);     }      /**      * Constructs an environment for sensor testing.      *      * @param context The context for the test      * @param sensorType The type of the sensor under test      * @param sensorMightHaveMoreListeners Whether the sensor under test is acting under load      * @param samplingPeriodUs The requested collection period for the sensor under test      * @param maxReportLatencyUs The requested collection report latency for the sensor under test      *      * @deprecated Use variants with {@link Sensor} objects.      */     @Deprecated     public TestSensorEnvironment(             Context context,             int sensorType,             boolean sensorMightHaveMoreListeners,             int samplingPeriodUs,             int maxReportLatencyUs) {         this(context,                 getSensor(context, sensorType),                 sensorMightHaveMoreListeners,                 samplingPeriodUs,                 maxReportLatencyUs);     }      /**      * Constructs an environment for sensor testing.      *      * @param context The context for the test      * @param sensorType The type of the sensor under test      * @param sensorMightHaveMoreListeners Whether the sensor under test is acting under load      * @param isIntegrationTest Whether this is an integration test (more than one sensor actived)      * @param samplingPeriodUs The requested collection period for the sensor under test      * @param maxReportLatencyUs The requested collection report latency for the sensor under test      *      * @deprecated Use variants with {@link Sensor} objects.      */     @Deprecated     public TestSensorEnvironment(             Context context,             int sensorType,             boolean sensorMightHaveMoreListeners,             boolean isIntegrationTest,             int samplingPeriodUs,             int maxReportLatencyUs) {         this(context,                 getSensor(context, sensorType),                 sensorMightHaveMoreListeners,                 isIntegrationTest,                 samplingPeriodUs,                 maxReportLatencyUs);     }      /**      * Constructs an environment for sensor testing.      *      * @param context The context for the test      * @param sensor The sensor under test      * @param samplingPeriodUs The requested collection period for the sensor under test      * @param maxReportLatencyUs The requested collection report latency for the sensor under test      */     public TestSensorEnvironment(             Context context,             Sensor sensor,             int samplingPeriodUs,             int maxReportLatencyUs) {         this(context,                 sensor,                 false /* sensorMightHaveMoreListeners */,                 samplingPeriodUs,                 maxReportLatencyUs);     }      /**      * Constructs an environment for sensor testing.      *      * @param context The context for the test      * @param sensor The sensor under test      * @param sensorMightHaveMoreListeners Whether the sensor under test is acting under load (this      *                                     usually implies that there are several listeners      *                                     requesting different sampling periods)      * @param samplingPeriodUs The requested collection period for the sensor under test      * @param maxReportLatencyUs The requested collection report latency for the sensor under test      */     public TestSensorEnvironment(             Context context,             Sensor sensor,             boolean sensorMightHaveMoreListeners,             int samplingPeriodUs,             int maxReportLatencyUs) {         this(context,                 sensor,                 sensorMightHaveMoreListeners,                 samplingPeriodUs,                 maxReportLatencyUs,                 false /* isDeviceSuspendTest */);     }      public TestSensorEnvironment(             Context context,             Sensor sensor,             boolean sensorMightHaveMoreListeners,             boolean isIntegrationTest,             int samplingPeriodUs,             int maxReportLatencyUs) {         this(context,                 sensor,                 sensorMightHaveMoreListeners,                 samplingPeriodUs,                 maxReportLatencyUs,                 false /* isDeviceSuspendTest */,                 isIntegrationTest);     }      public TestSensorEnvironment(             Context context,             Sensor sensor,             boolean sensorMightHaveMoreListeners,             int samplingPeriodUs,             int maxReportLatencyUs,             boolean isDeviceSuspendTest) {         this(context, sensor, sensorMightHaveMoreListeners,                 samplingPeriodUs, maxReportLatencyUs,                 isDeviceSuspendTest,                 false /* isIntegrationTest */);     }      public TestSensorEnvironment(             Context context,             Sensor sensor,             boolean sensorMightHaveMoreListeners,             int samplingPeriodUs,             int maxReportLatencyUs,             boolean isDeviceSuspendTest,             boolean isIntegrationTest) {         mContext = context;         mSensor = sensor;         mSensorMightHaveMoreListeners = sensorMightHaveMoreListeners;         mSamplingPeriodUs = samplingPeriodUs;         mMaxReportLatencyUs = maxReportLatencyUs;         mIsDeviceSuspendTest = isDeviceSuspendTest;         mIsIntegrationTest = isIntegrationTest;     }      /**      * @return The context instance associated with the test.      */     public Context getContext() {         return mContext;     }      /**      * @return The sensor under test.      */     public Sensor getSensor() {         return mSensor;     }      /**      * @return The requested collection rate in microseconds.      */     public int getRequestedSamplingPeriodUs() {         return mSamplingPeriodUs;     }      /**      * @return The frequency equivalent to {@link #getRequestedSamplingPeriodUs()}.      */     public double getFrequencyHz() {         return SensorCtsHelper.getFrequency(mSamplingPeriodUs, TimeUnit.MICROSECONDS);     }      /**      * @return A string representing the frequency equivalent to      * {@link #getRequestedSamplingPeriodUs()}.      */     public String getFrequencyString() {         if (mSamplingPeriodUs == SensorManager.SENSOR_DELAY_FASTEST) {             return ""fastest"";         }         return String.format(""%.2fhz"", getFrequencyHz());     }      /**      * @return The requested collection max batch report latency in microseconds.      */     public int getMaxReportLatencyUs() {         return mMaxReportLatencyUs;     }      /**      * Returns {@code true} if there might be other listeners of {@link #getSensor()} requesting      * data at different sampling rates (the rates are unknown); false otherwise.      */     public boolean isSensorSamplingRateOverloaded() {         return mSensorMightHaveMoreListeners                 && mSamplingPeriodUs != SensorManager.SENSOR_DELAY_FASTEST;     }      /**      * Convert the {@link #getRequestedSamplingPeriodUs()} into delay in microseconds.      * <p>      * The flags SensorManager.SENSOR_DELAY_[GAME|UI|NORMAL] are not supported since the CDD does      * not specify values for these flags. The rate is set to the max of      * {@link Sensor#getMinDelay()} and the rate given.      * </p>      */     public int getExpectedSamplingPeriodUs() {         if (!isDelayRateTestable()) {             throw new IllegalArgumentException(""rateUs cannot be SENSOR_DELAY_[GAME|UI|NORMAL]"");         }          int expectedSamplingPeriodUs = mSamplingPeriodUs;         int sensorMaxDelay = mSensor.getMaxDelay();         if (sensorMaxDelay > 0) {             expectedSamplingPeriodUs = Math.min(expectedSamplingPeriodUs, sensorMaxDelay);         }          return Math.max(expectedSamplingPeriodUs, mSensor.getMinDelay());     }      /**      * Calculate the maximum expected sampling period in us.      * @return The maximum acceptable actual sampling period of this sensor.      *         For continuous sensors, this is higher than {@link #getExpectedSamplingPeriodUs()}      *         because sensors are allowed to run up to 10% slower than requested.      *         For sensors with other reporting modes, this is the maximum integer      *         {@link Integer#MAX_VALUE} as they can report no events for long      *         periods of time.      */     public int getMaximumExpectedSamplingPeriodUs() {         int sensorReportingMode = mSensor.getReportingMode();         if (sensorReportingMode != Sensor.REPORTING_MODE_CONTINUOUS) {             return Integer.MAX_VALUE;         }          int expectedSamplingPeriodUs = getExpectedSamplingPeriodUs();         return (int) (expectedSamplingPeriodUs / MAXIMUM_EXPECTED_SAMPLING_FREQUENCY_MULTIPLIER);     }       /**      * Calculate the allowed sensor start delay.      *      * CDD Section 7.3:      * MUST report the first sensor sample within 400 milliseconds + 2 * sample_time of the      * sensor being activated. It is acceptable for this sample to have an accuracy of 0.      *      * [CDD] Keep this updated with CDD.      */     public long getAllowedSensorStartDelay() {         return TimeUnit.MILLISECONDS.toMicros(400) + 2 * getMaximumExpectedSamplingPeriodUs();     }      /**      * @return The number of axes in the coordinate system of the sensor under test.      */     public int getSensorAxesCount() {         switch (mSensor.getType()) {             case Sensor.TYPE_GYROSCOPE:                 return 3;             default:                 throw new IllegalStateException(""Axes count needs to be defined for sensor type: ""                         + mSensor.getStringType());         }     }      /**      * Get the default sensor for a given type.      *      * @deprecated Used for historical reasons, sensor tests must be written around Sensor objects,      * so all sensors of a given type are exercised.      */     @Deprecated     public static Sensor getSensor(Context context, int sensorType) {         SensorManager sensorManager =                 (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);         if (sensorManager == null) {             throw new IllegalStateException(""SensorService is not present in the system."");         }          Sensor sensor = sensorManager.getDefaultSensor(sensorType);         if(sensor == null) {             throw new SensorNotSupportedException(sensorType);         }         return sensor;     }      /**      * @return The maximum latency of a given sensor, on top of {@link #getMaxReportLatencyUs()}.      *      * NOTE: The latency is defined as the time between the event happens and the time the event is      * generated.      *      * - At time event_time (reported in the sensor event), the physical event happens      * - At time event_time + detection_latency, the physical event is detected and the event is      *   saved in the hardware fifo      * - At time event_time + detection_latency + report_latency, the event is reported through the      *   HAL      *      * Soon after that, the event is piped through the framework to the application. This time may      * vary depending on the CPU load. The time 'detection_latency' must be less than      * {@link #getSensorMaxDetectionLatencyNs(Sensor)}, and 'report_latency' must be less than      * {@link #getMaxReportLatencyUs()} passed through batch() at the HAL level.      */     // TODO: when all tests are moved to use the Sensor test framework, make this method non-static     public static long getSensorMaxDetectionLatencyNs(Sensor sensor) {         int reportLatencySec;         switch (sensor.getType()) {             case Sensor.TYPE_STEP_DETECTOR:                 reportLatencySec = 2;                 break;             case Sensor.TYPE_STEP_COUNTER:                 reportLatencySec = 10;                 break;             case Sensor.TYPE_SIGNIFICANT_MOTION:                 reportLatencySec = 10;                 break;             default:                 reportLatencySec = 0;         }         return TimeUnit.SECONDS.toNanos(reportLatencySec);     }      @Override     public String toString() {         return String.format(                 ""Sensor='%s', SamplingRateOverloaded=%s, SamplingPeriod=%sus, ""                         + ""MaxReportLatency=%sus"",                 mSensor,                 isSensorSamplingRateOverloaded(),                 mSamplingPeriodUs,                 mMaxReportLatencyUs);     }      /**      * Return true if {@link #getRequestedSamplingPeriodUs()} is not one of      * {@link SensorManager#SENSOR_DELAY_GAME}, {@link SensorManager#SENSOR_DELAY_UI}, or      * {@link SensorManager#SENSOR_DELAY_NORMAL}.      */     private boolean isDelayRateTestable() {         return (mSamplingPeriodUs >= 0                 && mSamplingPeriodUs != SensorManager.SENSOR_DELAY_GAME                 && mSamplingPeriodUs != SensorManager.SENSOR_DELAY_UI                 && mSamplingPeriodUs != SensorManager.SENSOR_DELAY_NORMAL);     }      public boolean isDeviceSuspendTest() {         return mIsDeviceSuspendTest;     }      public boolean isIntegrationTest() {         return mIsIntegrationTest;     } }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.helpers.sensorverification.TimestampClockSourceVerification"	"isDeviceSuspendTest"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"wakeup"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/helpers/sensorverification/TimestampClockSourceVerification.java"	""	"public void test/*  *  */  package android.hardware.cts.helpers.sensorverification;  import junit.framework.Assert;  import android.hardware.SensorEvent; import android.hardware.cts.helpers.SensorStats; import android.hardware.cts.helpers.TestSensorEnvironment; import android.hardware.cts.helpers.TestSensorEvent; import android.os.SystemClock;  import java.util.ArrayList; import java.util.List; import java.util.concurrent.TimeUnit; import android.util.Log;  /**  * A {@link ISensorVerification} which verifies that the timestamp of the {@link SensorEvent} is  * synchronized with {@link SystemClock#elapsedRealtimeNanos()}, based on a given threshold.  */ public class TimestampClockSourceVerification extends AbstractSensorVerification {     public static final String TAG = ""TimestampClockSourceVerification"";     public static final String PASSED_KEY = ""timestamp_verification_passed"";      // number of indices to print in assertion message before truncating     private static final int TRUNCATE_MESSAGE_LENGTH = 3;      private static final long DEFAULT_THRESHOLD_NS = TimeUnit.MILLISECONDS.toNanos(1000);     private static final float ALLOWED_LATENCY_ERROR = 0.1f; //10%      private final ArrayList<TestSensorEvent> mCollectedEvents = new ArrayList<TestSensorEvent>();      private long mMaximumLatencyNs;      /**      * Constructs an instance of {@link TimestampClockSourceVerification}.      *      * @param maxLatencyNs Maximum allowed timestamp delta between event timestamp and current time      */     public TimestampClockSourceVerification (             long maxLatencyUs) {         mMaximumLatencyNs = maxLatencyUs * 1000;     }      /**      * Gets a default {@link TimestampClockSourceVerification}.      *      * @param environment The test environment      * @return The verification or null if the verification is not supported in the given      *         environment.      */     public static TimestampClockSourceVerification getDefault(             TestSensorEnvironment environment) {         long reportLatencyUs = environment.getMaxReportLatencyUs();         long fifoMaxEventCount = environment.getSensor().getFifoMaxEventCount();         int maximumExpectedSamplingPeriodUs = environment.getMaximumExpectedSamplingPeriodUs();         if (fifoMaxEventCount > 0 && maximumExpectedSamplingPeriodUs != Integer.MAX_VALUE) {             long fifoBasedReportLatencyUs = fifoMaxEventCount * maximumExpectedSamplingPeriodUs;             // If the device goes into suspend mode and the sensor is a non wake-up sensor, the             // FIFO will keep overwriting itself and the reportLatency will be equal to the time             // it takes to fill up the FIFO.             if (environment.isDeviceSuspendTest() && !environment.getSensor().isWakeUpSensor()) {                 reportLatencyUs = fifoBasedReportLatencyUs;             } else {                 // In this case the sensor under test is either a wake-up sensor OR it                 // is a non wake-up sensor but the device does not go into suspend.                 // So the expected delay of a sensor_event is the minimum of the                 // fifoBasedReportLatencyUs and the requested latency by the application.                 reportLatencyUs = Math.min(reportLatencyUs, fifoBasedReportLatencyUs);             }         }         // Add an additional filter delay which is a function of the samplingPeriod.         long filterDelayUs = (long)(2.5 * maximumExpectedSamplingPeriodUs);          long expectedSyncLatencyNs = TimeUnit.MICROSECONDS.toNanos(reportLatencyUs + filterDelayUs);          return new TimestampClockSourceVerification(expectedSyncLatencyNs);     }      @Override     public void verify(TestSensorEnvironment environment, SensorStats stats) {         StringBuilder errorMessageBuilder =                 new StringBuilder("" Incorrect timestamp clock source failures: "");         boolean success = false;         int failuresCount = 0;         List<IndexedEvent> failures;          try {             failures = verifyTimestampClockSource(errorMessageBuilder);             failuresCount = failures.size();             stats.addValue(SensorStats.EVENT_TIME_WRONG_CLOCKSOURCE_COUNT_KEY, failuresCount);             stats.addValue(                     SensorStats.EVENT_TIME_WRONG_CLOCKSOURCE_POSITIONS_KEY,                     getIndexArray(failures));             success = failures.isEmpty();         } catch (Throwable e) {             failuresCount++;             stats.addValue(SensorStats.EVENT_TIME_WRONG_CLOCKSOURCE_COUNT_KEY, 0);         }         stats.addValue(PASSED_KEY, success);         errorMessageBuilder.insert(0, failuresCount);         Assert.assertTrue(errorMessageBuilder.toString(), success);     }      /**      * {@inheritDoc}      */     @Override     public TimestampClockSourceVerification clone() {         return new TimestampClockSourceVerification(                 mMaximumLatencyNs);     }      /**      * {@inheritDoc}      */     @Override     protected void addSensorEventInternal(TestSensorEvent event) {         mCollectedEvents.add(event);     }      /**      * Verifies timestamp clock source for each collected event      *      * @param builder A string builder to store error messaged found in the collected sensor events.      * @return A list of events tha failed the verification.      */     private List<IndexedEvent> verifyTimestampClockSource(StringBuilder builder) throws Throwable {         int collectedEventsCount = mCollectedEvents.size();         ArrayList<IndexedEvent> failures = new ArrayList<IndexedEvent>();          if (collectedEventsCount == 0) {             if (failures.size() < TRUNCATE_MESSAGE_LENGTH) {                 builder.append(""No events received !"");             }             Assert.assertTrue(""No events received !"", false);         }          for (int i = 0; i < collectedEventsCount; ++i) {             TestSensorEvent event = mCollectedEvents.get(i);             long eventTimestampNs = event.timestamp;             long receivedTimestampNs = event.receivedTimestamp;             long upperThresholdNs = receivedTimestampNs;             long lowerThresholdNs = receivedTimestampNs - mMaximumLatencyNs;              if (eventTimestampNs < lowerThresholdNs || eventTimestampNs > upperThresholdNs) {                 if (failures.size() < TRUNCATE_MESSAGE_LENGTH) {                     builder.append(""position="").append(i);                     builder.append("", timestamp="").append(String.format(""%.2fms"",                                 nanosToMillis(eventTimestampNs)));                     builder.append("", expected=["").append(String.format(""%.2fms"",                                 nanosToMillis(lowerThresholdNs)));                     builder.append("", "").append(String.format(""%.2f]ms; "",                                 nanosToMillis(upperThresholdNs)));                 }                 failures.add(new IndexedEvent(i, event));             }         }         if (failures.size() >= TRUNCATE_MESSAGE_LENGTH) {             builder.append(""more; "");         }         return failures;     } }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorSupportTest"	"testSupportsRotationVectorIfHasAGM"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorSupportTest.java"	""	"public void testSupportsRotationVectorIfHasAGM() {         if (mHasAccel && mHasGyro && mHasMag) {             assertTrue(hasSensorType(Sensor.TYPE_ROTATION_VECTOR));         }     }      private boolean sensorRequiredForVrHighPerformanceMode(int sensorType) {         if (sensorType == Sensor.TYPE_ACCELEROMETER ||             sensorType == Sensor.TYPE_ACCELEROMETER_UNCALIBRATED ||             sensorType == Sensor.TYPE_GYROSCOPE ||             sensorType == Sensor.TYPE_GYROSCOPE_UNCALIBRATED ||             sensorType == Sensor.TYPE_MAGNETIC_FIELD ||             sensorType == Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED) {             return true;         } else {             return false;         }     }      private void checkHifiVrSensorSupport(int sensorType) {         boolean isVrSensor = mVrHighPerformanceModeSupported &&             sensorRequiredForVrHighPerformanceMode(sensorType);         if (mAreHifiSensorsSupported || isVrSensor) {             Sensor sensor = mSensorManager.getDefaultSensor(sensorType);             assertTrue(sensor != null);             if (isVrSensor && mIsVrHeadset) {                 assertTrue(sensor.isDirectChannelTypeSupported(SensorDirectChannel.TYPE_HARDWARE_BUFFER));             }         }     }      private boolean hasSensorType(int sensorType) {         return (mSensorManager != null && mSensorManager.getDefaultSensor(sensorType) != null);     } }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SingleSensorTests"	"testSensorProperties"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SingleSensorTests.java"	""	"public void testSensorProperties() {         // sensor type: [getMinDelay()]         Map<Integer, Object[]> expectedProperties = new HashMap<>(3);         if(getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) {                 expectedProperties.put(Sensor.TYPE_ACCELEROMETER, new Object[]{20000});                 expectedProperties.put(Sensor.TYPE_GYROSCOPE, new Object[]{20000});         }else {                 expectedProperties.put(Sensor.TYPE_ACCELEROMETER, new Object[]{10000});                 expectedProperties.put(Sensor.TYPE_GYROSCOPE, new Object[]{10000});         }         expectedProperties.put(Sensor.TYPE_MAGNETIC_FIELD, new Object[]{100000});          SensorManager sensorManager =                 (SensorManager) getContext().getSystemService(Context.SENSOR_SERVICE);         assertNotNull(""SensorManager not present in the system."", sensorManager);         for (Entry<Integer, Object[]> entry : expectedProperties.entrySet()) {             Sensor sensor = sensorManager.getDefaultSensor(entry.getKey());             if (sensor != null) {                 if (entry.getValue()[0] != null) {                     int expected = (Integer) entry.getValue()[0];                     String msg = String.format(                             ""%s: min delay %dus expected to be less than or equal to %dus"",                             sensor.getName(),                             sensor.getMinDelay(),                             expected);                     assertTrue(msg, sensor.getMinDelay() <= expected);                 }             }         }     }      // TODO: Figure out if a better way to enumerate test cases programmatically exists that works     // with CTS framework."	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorTest"	"testSensorOperations"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testSensorOperations() {         // Because we can't know every sensors unit details, so we can't assert         // get values with specified values.         Sensor sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);         boolean hasAccelerometer = getContext().getPackageManager().hasSystemFeature(                 PackageManager.FEATURE_SENSOR_ACCELEROMETER);         // accelerometer sensor is optional         if (hasAccelerometer) {             assertEquals(Sensor.TYPE_ACCELEROMETER, sensor.getType());             assertSensorValues(sensor);         } else {             assertNull(sensor);         }          sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_STEP_COUNTER);         boolean hasStepCounter = getContext().getPackageManager().hasSystemFeature(                 PackageManager.FEATURE_SENSOR_STEP_COUNTER);         // stepcounter sensor is optional         if (hasStepCounter) {             assertEquals(Sensor.TYPE_STEP_COUNTER, sensor.getType());             assertSensorValues(sensor);         } else {             assertNull(sensor);         }          sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_STEP_DETECTOR);         boolean hasStepDetector = getContext().getPackageManager().hasSystemFeature(                 PackageManager.FEATURE_SENSOR_STEP_DETECTOR);         // stepdetector sensor is optional         if (hasStepDetector) {             assertEquals(Sensor.TYPE_STEP_DETECTOR, sensor.getType());             assertSensorValues(sensor);         } else {             assertNull(sensor);         }          sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);         boolean hasCompass = getContext().getPackageManager().hasSystemFeature(                 PackageManager.FEATURE_SENSOR_COMPASS);         // compass sensor is optional         if (hasCompass) {             assertEquals(Sensor.TYPE_MAGNETIC_FIELD, sensor.getType());             assertSensorValues(sensor);         } else {             assertNull(sensor);         }          sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE);         boolean hasGyroscope = getContext().getPackageManager().hasSystemFeature(                 PackageManager.FEATURE_SENSOR_GYROSCOPE);         // gyroscope sensor is optional         if (hasGyroscope) {             assertEquals(Sensor.TYPE_GYROSCOPE, sensor.getType());             assertSensorValues(sensor);         } else {             assertNull(sensor);         }          sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_PRESSURE);         boolean hasPressure = getContext().getPackageManager().hasSystemFeature(                 PackageManager.FEATURE_SENSOR_BAROMETER);         // pressure sensor is optional         if (hasPressure) {             assertEquals(Sensor.TYPE_PRESSURE, sensor.getType());             assertSensorValues(sensor);         } else {             assertNull(sensor);         }          sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ORIENTATION);         // Note: orientation sensor is deprecated.         if (sensor != null) {             assertEquals(Sensor.TYPE_ORIENTATION, sensor.getType());             assertSensorValues(sensor);         }          sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_TEMPERATURE);         // temperature sensor is optional         if (sensor != null) {             assertEquals(Sensor.TYPE_TEMPERATURE, sensor.getType());             assertSensorValues(sensor);         }          sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_HINGE_ANGLE);         boolean hasHingeAngle = getContext().getPackageManager().hasSystemFeature(                 PackageManager.FEATURE_SENSOR_HINGE_ANGLE);          if (hasHingeAngle) {             assertEquals(Sensor.TYPE_HINGE_ANGLE, sensor.getType());             assertSensorValues(sensor);             assertTrue(""Max range must not be larger than 360. Range="" + sensor.getMaximumRange()                 + "" "" + sensor.getName(), sensor.getMaximumRange() <= 360);         } else {             assertNull(sensor);         }     }      @AppModeFull(reason = ""Instant apps cannot access body sensors"")"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorTest"	"testBodySensorOperations"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testBodySensorOperations() {         Sensor sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_HEART_RATE);         boolean hasHeartRate = getContext().getPackageManager().hasSystemFeature(                 PackageManager.FEATURE_SENSOR_HEART_RATE);         // heartrate sensor is optional         if (hasHeartRate) {             assertEquals(Sensor.TYPE_HEART_RATE, sensor.getType());             assertSensorValues(sensor);         } else {             assertNull(sensor);         }     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorTest"	"testValuesForAllSensors"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testValuesForAllSensors() {         for (Sensor sensor : mSensorList) {             assertSensorValues(sensor);         }     }      private void hasOnlyOneWakeUpSensorOrEmpty(List<Sensor> sensors) {         if (sensors == null || sensors.isEmpty()) return;         if (sensors.size() > 1) {             fail(""More than one "" + sensors.get(0).getName() + "" defined."");             return;         }         assertTrue(sensors.get(0).getName() + "" defined as non-wake-up sensor"",                 sensors.get(0).isWakeUpSensor());     }      private void hasDefaultWakeupSensorOrEmpty(int sensorType, String sensorName) {         Sensor sensor = mSensorManager.getDefaultSensor(sensorType);         if (sensor == null) return;          assertTrue(""Default "" + sensorName + "" sensor is not a wake-up sensor"", sensor.isWakeUpSensor());     }      // Some sensors like proximity, significant motion etc. are defined as wake-up sensors by     // default. Check if the wake-up flag is set correctly.     @Presubmit"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorTest"	"testGetDefaultSensorWithWakeUpFlag"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testGetDefaultSensorWithWakeUpFlag() {         // With wake-up flags set to false, the sensor returned should be a non wake-up sensor.         for (Sensor sensor : mSensorList) {             Sensor curr_sensor = mSensorManager.getDefaultSensor(sensor.getType(), false);             if (curr_sensor != null) {                 assertFalse(""getDefaultSensor wakeup=false returns a wake-up sensor"" +                         curr_sensor.getName(),                         curr_sensor.isWakeUpSensor());             }              curr_sensor = mSensorManager.getDefaultSensor(sensor.getType(), true);             if (curr_sensor != null) {                 assertTrue(""getDefaultSensor wake-up returns non wake sensor"" +                         curr_sensor.getName(),                         curr_sensor.isWakeUpSensor());             }         }     }      @Presubmit"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorTest"	"testRequestTriggerWithNonTriggerSensor"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testRequestTriggerWithNonTriggerSensor() {         mTriggerSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);         if (mTriggerSensor == null) {             throw new SensorNotSupportedException(Sensor.TYPE_ACCELEROMETER);         }         boolean  result =             mSensorManager.requestTriggerSensor(mNullTriggerEventListener, mTriggerSensor);         assertFalse(result);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorTest"	"testCancelTriggerWithNonTriggerSensor"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testCancelTriggerWithNonTriggerSensor() {         mTriggerSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);         if (mTriggerSensor == null) {             throw new SensorNotSupportedException(Sensor.TYPE_ACCELEROMETER);         }         boolean result =             mSensorManager.cancelTriggerSensor(mNullTriggerEventListener, mTriggerSensor);         assertFalse(result);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorTest"	"testRegisterWithTriggerSensor"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testRegisterWithTriggerSensor() {         Sensor sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_SIGNIFICANT_MOTION);         if (sensor == null) {             throw new SensorNotSupportedException(Sensor.TYPE_SIGNIFICANT_MOTION);         }         boolean result = mSensorManager.registerListener(                 mNullSensorEventListener,                 sensor,                 SensorManager.SENSOR_DELAY_NORMAL);         assertFalse(result);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorTest"	"testRegisterTwiceWithSameSensor"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testRegisterTwiceWithSameSensor() {         Sensor sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);         if (sensor == null) {             throw new SensorNotSupportedException(Sensor.TYPE_ACCELEROMETER);         }          boolean result = mSensorManager.registerListener(mNullSensorEventListener, sensor,                 SensorManager.SENSOR_DELAY_NORMAL);         assertTrue(result);          result = mSensorManager.registerListener(mNullSensorEventListener, sensor,                 SensorManager.SENSOR_DELAY_NORMAL);         assertFalse(result);     }      /**      * Verifies that if the UID is idle the continuous events are being reported      * but sanitized - all events are the same as the first one delivered except      * for their timestamps. From the point of view of an idle app these events are      * being properly generated but the sensor reading does not change - privacy.      */     // TODO: remove when parametrized tests are supported and EventTimestampSynchronization"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorTest"	"testLegacySensorOperations"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testLegacySensorOperations() {         final SensorManager mSensorManager =                 (SensorManager) getContext().getSystemService(Context.SENSOR_SERVICE);          // We expect the set of sensors reported by the new and legacy APIs to be consistent.         int sensors = 0;         if (mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER) != null) {             sensors |= SensorManager.SENSOR_ACCELEROMETER;         }         if (mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD) != null) {             sensors |= SensorManager.SENSOR_MAGNETIC_FIELD;         }         if (mSensorManager.getDefaultSensor(Sensor.TYPE_ORIENTATION) != null) {             sensors |= SensorManager.SENSOR_ORIENTATION | SensorManager.SENSOR_ORIENTATION_RAW;         }         assertEquals(sensors, mSensorManager.getSensors());     }      /**      * Verifies that a continuous sensor produces events that have timestamps synchronized with      * {@link SystemClock#elapsedRealtimeNanos()} and that the events are sanitized/non-sanitized.      */     private void verifyLongActivation(             Sensor sensor,             int maxReportLatencyUs,             long duration,             TimeUnit durationTimeUnit,             String testType,             boolean sanitized,             ArrayList<Throwable> errorsFound) throws InterruptedException {         if (sensor.getReportingMode() != Sensor.REPORTING_MODE_CONTINUOUS) {             return;         }          try {             TestSensorEnvironment environment = new TestSensorEnvironment(                     getContext(),                     sensor,                     shouldEmulateSensorUnderLoad(),                     SensorManager.SENSOR_DELAY_FASTEST,                     maxReportLatencyUs);             TestSensorOperation operation = TestSensorOperation.createOperation(                     environment, duration, durationTimeUnit);             if (sanitized) {                 final long verificationDelayNano = TimeUnit.NANOSECONDS.convert(                         maxReportLatencyUs, TimeUnit.MICROSECONDS) * 2;                 operation.addVerification(ContinuousEventSanitizedVerification                         .getDefault(environment, verificationDelayNano));             } else {                 operation.addVerification(EventGapVerification.getDefault(environment));                 operation.addVerification(EventOrderingVerification.getDefault(environment));                 operation.addVerification(EventTimestampSynchronizationVerification                         .getDefault(environment));             }             Log.i(TAG, ""Running "" + testType + "" test on: "" + sensor.getName());             operation.execute(getCurrentTestNode());         } catch (InterruptedException e) {             // propagate so the test can stop             throw e;         } catch (Throwable e) {             errorsFound.add(e);             Log.e(TAG, e.getMessage());         }     }      /**      * Verifies that a client can listen for events, and that      * {@link SensorManager#flush(SensorEventListener)} will trigger the appropriate notification      * for {@link SensorEventListener2#onFlushCompleted(Sensor)}.      */     private void verifyRegisterListenerCallFlush(             Sensor sensor,             Handler handler,             ArrayList<Throwable> errorsFound,             boolean flushWhileIdle)             throws InterruptedException {         if (sensor.getReportingMode() == Sensor.REPORTING_MODE_ONE_SHOT) {             return;         }          try {             TestSensorEnvironment environment = new TestSensorEnvironment(                     getContext(),                     sensor,                     shouldEmulateSensorUnderLoad(),                     SensorManager.SENSOR_DELAY_FASTEST,                     (int) TimeUnit.SECONDS.toMicros(10));             FlushExecutor executor = new FlushExecutor(environment, 500 /* eventCount */,                     flushWhileIdle);             TestSensorOperation operation = new TestSensorOperation(environment, executor, handler);              Log.i(TAG, ""Running flush test on: "" + sensor.getName());             operation.execute(getCurrentTestNode());         } catch (InterruptedException e) {             // propagate so the test can stop             throw e;         } catch (Throwable e) {             errorsFound.add(e);             Log.e(TAG, e.getMessage());         }     }      private void assertOnErrors(List<Throwable> errorsFound) {         if (!errorsFound.isEmpty()) {             StringBuilder builder = new StringBuilder();             for (Throwable error : errorsFound) {                 builder.append(error.getMessage()).append(""\n"");             }             Assert.fail(builder.toString());         }     }      /**      * A delegate that drives the execution of Batch/Flush tests.      * It performs several operations in order:      * - registration      * - for continuous sensors it first ensures that the FIFO is filled      *      - if events do not arrive on time, an assert will be triggered      * - requests flush of sensor data      * - waits for {@link SensorEventListener2#onFlushCompleted(Sensor)}      *      - if the event does not arrive, an assert will be triggered      */     private class FlushExecutor implements TestSensorOperation.Executor {         private final TestSensorEnvironment mEnvironment;         private final int mEventCount;         private final boolean mFlushWhileIdle;          public FlushExecutor(TestSensorEnvironment environment, int eventCount,                 boolean flushWhileIdle) {             mEnvironment = environment;             mEventCount = eventCount;             mFlushWhileIdle = flushWhileIdle;         }          /**          * Consider only continuous mode sensors for testing register listener.          *          * For on-change sensors, we only use          * {@link TestSensorManager#registerListener(TestSensorEventListener)} to associate the          * listener with the sensor. So that {@link TestSensorManager#requestFlush()} can be          * invoked on it.          */         @Override         public void execute(TestSensorManager sensorManager, TestSensorEventListener listener)                 throws Exception {             int sensorReportingMode = mEnvironment.getSensor().getReportingMode();             try {                 CountDownLatch eventLatch = sensorManager.registerListener(listener, mEventCount);                 if (sensorReportingMode == Sensor.REPORTING_MODE_CONTINUOUS) {                     listener.waitForEvents(eventLatch, mEventCount, true);                 }                 if (mFlushWhileIdle) {                     SensorCtsHelper.makeMyPackageIdle();                     sensorManager.assertFlushFail();                 } else {                     CountDownLatch flushLatch = sensorManager.requestFlush();                     listener.waitForFlushComplete(flushLatch, true);                 }             } finally {                 sensorManager.unregisterListener();                 if (mFlushWhileIdle) {                     SensorCtsHelper.makeMyPackageActive();                 }             }         }     }      private class NullTriggerEventListener extends TriggerEventListener {         @Override         public void onTrigger(TriggerEvent event) {}     }      private class NullSensorEventListener implements SensorEventListener {         @Override         public void onSensorChanged(SensorEvent event) {}          @Override         public void onAccuracyChanged(Sensor sensor, int accuracy) {}     }  }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorTest"	"testValuesForAllSensors"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"wakeup"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testValuesForAllSensors() {         for (Sensor sensor : mSensorList) {             assertSensorValues(sensor);         }     }      private void hasOnlyOneWakeUpSensorOrEmpty(List<Sensor> sensors) {         if (sensors == null || sensors.isEmpty()) return;         if (sensors.size() > 1) {             fail(""More than one "" + sensors.get(0).getName() + "" defined."");             return;         }         assertTrue(sensors.get(0).getName() + "" defined as non-wake-up sensor"",                 sensors.get(0).isWakeUpSensor());     }      private void hasDefaultWakeupSensorOrEmpty(int sensorType, String sensorName) {         Sensor sensor = mSensorManager.getDefaultSensor(sensorType);         if (sensor == null) return;          assertTrue(""Default "" + sensorName + "" sensor is not a wake-up sensor"", sensor.isWakeUpSensor());     }      // Some sensors like proximity, significant motion etc. are defined as wake-up sensors by     // default. Check if the wake-up flag is set correctly.     @Presubmit"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorTest"	"testWakeUpFlags"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"wakeup"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testWakeUpFlags() {         final int TYPE_WAKE_GESTURE = 23;         final int TYPE_GLANCE_GESTURE = 24;         final int TYPE_PICK_UP_GESTURE = 25;          hasOnlyOneWakeUpSensorOrEmpty(mSensorManager.getSensorList(Sensor.TYPE_SIGNIFICANT_MOTION));         hasOnlyOneWakeUpSensorOrEmpty(mSensorManager.getSensorList(TYPE_WAKE_GESTURE));         hasOnlyOneWakeUpSensorOrEmpty(mSensorManager.getSensorList(TYPE_GLANCE_GESTURE));         hasOnlyOneWakeUpSensorOrEmpty(mSensorManager.getSensorList(TYPE_PICK_UP_GESTURE));          hasDefaultWakeupSensorOrEmpty(Sensor.TYPE_PROXIMITY, ""proximity"");         hasDefaultWakeupSensorOrEmpty(Sensor.TYPE_HINGE_ANGLE, ""hinge"");     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorTest"	"testGetDefaultSensorWithWakeUpFlag"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"wakeup"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorTest.java"	""	"public void testGetDefaultSensorWithWakeUpFlag() {         // With wake-up flags set to false, the sensor returned should be a non wake-up sensor.         for (Sensor sensor : mSensorList) {             Sensor curr_sensor = mSensorManager.getDefaultSensor(sensor.getType(), false);             if (curr_sensor != null) {                 assertFalse(""getDefaultSensor wakeup=false returns a wake-up sensor"" +                         curr_sensor.getName(),                         curr_sensor.isWakeUpSensor());             }              curr_sensor = mSensorManager.getDefaultSensor(sensor.getType(), true);             if (curr_sensor != null) {                 assertTrue(""getDefaultSensor wake-up returns non wake sensor"" +                         curr_sensor.getName(),                         curr_sensor.isWakeUpSensor());             }         }     }      @Presubmit"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"com.android.cts.verifier.sensors.RVCVRecordActivity"	"getDefaultDisplay"	""	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/sensors/RVCVRecordActivity.java"	""	"public void test/*  *.  */  package com.android.cts.verifier.sensors;  import android.app.Activity; import android.content.Context; import android.content.Intent; import android.hardware.Camera; import android.hardware.Sensor; import android.hardware.SensorEvent; import android.hardware.SensorEventListener; import android.hardware.SensorManager; import android.media.AudioManager; import android.media.CamcorderProfile; import android.media.MediaRecorder; import android.media.SoundPool; import android.net.Uri; import android.os.Bundle; import android.os.Environment; import android.util.JsonWriter; import android.util.Log; import android.view.Surface; import android.view.Window; import android.view.WindowManager; import android.widget.ImageView; import android.widget.Toast;  import com.android.cts.verifier.R;  import java.io.File; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStreamWriter; import java.text.SimpleDateFormat; import java.util.Date; import java.util.HashMap; import java.util.List; import java.util.Map;  // ----------------------------------------------------------------------  /**  *  An activity that does recording of the camera video and rotation vector data at the same time.  */ public class RVCVRecordActivity extends Activity {     private static final String TAG = ""RVCVRecordActivity"";     private static final boolean LOCAL_LOGV = false;      private MotionIndicatorView mIndicatorView;      private SoundPool mSoundPool;     private Map<String, Integer> mSoundMap;      private File mRecordDir;     private RecordProcedureController mController;     private VideoRecorder           mVideoRecorder;     private RVSensorLogger          mRVSensorLogger;     private CoverageManager         mCoverManager;     private CameraContext mCameraContext;     private int mDeviceRotation = Surface.ROTATION_0;      public static final int AXIS_NONE = 0;     public static final int AXIS_ALL = SensorManager.AXIS_X +                                        SensorManager.AXIS_Y +                                        SensorManager.AXIS_Z;      // For Rotation Vector algorithm research use     private final static boolean     LOG_RAW_SENSORS = false;     private RawSensorLogger          mRawSensorLogger;      public final RecordProcedureControllerCallback mRecordProcedureControllerCallback =             new RecordProcedureControllerCallback() {         public void startRecordProcedureController() {             startRecordcontroller();         }         public void stopRecordProcedureController() {             stopRecordcontroller();         }     };      public void startRecordcontroller() {         if (mController != null) {             Log.v(TAG, ""startRecordcontroller is working. stop it"");             mController.quit();         }         Log.v(TAG, ""startRecordcontroller"");         mController = new RecordProcedureController(this);     }      public void stopRecordcontroller() {         if (mController != null) {             Log.v(TAG, ""startRecordcontroller is working. stop it"");             mController.quit();         }         Log.v(TAG, ""stopRecordcontroller"");     }      @Override     public void onCreate(Bundle savedInstanceState) {         super.onCreate(savedInstanceState);          // Hide the window title.         requestWindowFeature(Window.FEATURE_NO_TITLE);          // inflate xml         setContentView(R.layout.cam_preview_overlay);          // locate views         mIndicatorView = (MotionIndicatorView) findViewById(R.id.cam_indicator);         WindowManager windowManager =                 (WindowManager)getSystemService(Context.WINDOW_SERVICE);         if (windowManager != null) {             mDeviceRotation = windowManager.getDefaultDisplay().getRotation();             mIndicatorView.setDeviceRotation(mDeviceRotation);         }          initStoragePath();     }      @Override     protected void onPause() {         super.onPause();         if (mController != null) {             mController.quit();         }          mCameraContext.end();         endSoundPool();     }      @Override     protected void onResume() {         super.onResume();         // delay the initialization as much as possible         init();     }      /** display toast message      *      * @param msg Message content      */     private void message(String msg) {          Context context = getApplicationContext();         int duration = Toast.LENGTH_SHORT;          Toast toast = Toast.makeText(context, msg, duration);         toast.show();     }      /**      *  Initialize components      *      */     private void init() {         mCameraContext = new CameraContext();         mCameraContext.init(mRecordProcedureControllerCallback);          mCoverManager = new CoverageManager();         mIndicatorView.setDataProvider(                 mCoverManager.getAxis(SensorManager.AXIS_X),                 mCoverManager.getAxis(SensorManager.AXIS_Y),                 mCoverManager.getAxis(SensorManager.AXIS_Z)  );          initSoundPool();         mRVSensorLogger = new RVSensorLogger(this);          mVideoRecorder = new VideoRecorder(mCameraContext.getCamera(), mCameraContext.getProfile());          if (LOG_RAW_SENSORS) {             mRawSensorLogger = new RawSensorLogger(mRecordDir);         }     }      /**      * Notify recording is completed. This is the successful exit.      */     public void notifyComplete() {         message(""Capture completed!"");          Uri resultUri = Uri.fromFile(mRecordDir);         Intent result = new Intent();         result.setData(resultUri);         setResult(Activity.RESULT_OK, result);          finish();     }      /**      * Notify the user what to do next in text      *      * @param axis SensorManager.AXIS_X or SensorManager.AXIS_Y or SensorManager.AXIS_Z      */     private void notifyPrompt(int axis) {         // It is not XYZ because of earlier design have different definition of         // X and Y         final String axisName = ""YXZ"";          message(""Manipulate the device in "" + axisName.charAt(axis - 1) +                 "" axis (as illustrated) about the pattern."");     }      /**      *  Ask indicator view to redraw      */     private void redrawIndicator() {         mIndicatorView.invalidate();     }      /**      * Switch to a different axis for display and logging      * @param axis      */     private void switchAxis(int axis) {         ImageView imageView = (ImageView) findViewById(R.id.cam_overlay);          final int [] prompts = {R.drawable.prompt_x, R.drawable.prompt_y, R.drawable.prompt_z};          if (axis >=SensorManager.AXIS_X && axis <=SensorManager.AXIS_Z) {             imageView.setImageResource(prompts[axis-1]);             if (mDeviceRotation != Surface.ROTATION_0 && mDeviceRotation != Surface.ROTATION_180) {                 imageView.setRotation(90);             }             mIndicatorView.enableAxis(axis);             mRVSensorLogger.updateRegister(mCoverManager.getAxis(axis), axis);             notifyPrompt(axis);         } else {             imageView.setImageDrawable(null);             mIndicatorView.enableAxis(AXIS_NONE);         }         redrawIndicator();     }      /**      * Asynchronized way to call switchAxis. Use this if caller is not on UI thread.      * @param axis @param axis SensorManager.AXIS_X or SensorManager.AXIS_Y or SensorManager.AXIS_Z      */     public void switchAxisAsync(int axis) {         // intended to be called from a non-UI thread         final int fAxis = axis;         runOnUiThread(new Runnable() {             public void run() {                 // UI code goes here                 switchAxis(fAxis);             }         });     }      /**      * Initialize sound pool for user notification      */     private void initSoundPool() {         mSoundPool = new SoundPool(1 /*maxStreams*/, AudioManager.STREAM_MUSIC, 0);         mSoundMap = new HashMap<>();          // TODO: add different sound into this         mSoundMap.put(""start"", mSoundPool.load(this, R.raw.start_axis, 1));         mSoundMap.put(""end"", mSoundPool.load(this, R.raw.next_axis, 1));         mSoundMap.put(""half-way"", mSoundPool.load(this, R.raw.half_way, 1));     }     private void endSoundPool() {         mSoundPool.release();     }      /**      * Play notify sound to user      * @param name name of the sound to be played      */     public void playNotifySound(String name) {         Integer id = mSoundMap.get(name);         if (id != null) {             mSoundPool.play(id.intValue(), 0.75f/*left vol*/, 0.75f/*right vol*/, 0 /*priority*/,                     0/*loop play*/, 1/*rate*/);         }     }      /**      * Start the sensor recording      */     public void startRecordSensor() {         runOnUiThread(new Runnable() {             public void run() {                 mRVSensorLogger.init();                 if (LOG_RAW_SENSORS) {                     mRawSensorLogger.init();                 }             }         });     }      /**      * Stop the sensor recording      */     public void stopRecordSensor() {         runOnUiThread(new Runnable() {             public void run() {                 mRVSensorLogger.end();                 if (LOG_RAW_SENSORS) {                     mRawSensorLogger.end();                 }             }         });     }      /**      * Start video recording      */     public void startRecordVideo() {         mVideoRecorder.init();     }      /**      * Stop video recording      */     public void stopRecordVideo() {         mVideoRecorder.end();     }      /**      * Wait until a sensor recording for a certain axis is fully covered      * @param axis      */     public void waitUntilCovered(int axis) {         mCoverManager.waitUntilCovered(axis);     }      /**      * Wait until a sensor recording for a certain axis is halfway covered      * @param axis      */     public void waitUntilHalfCovered(int axis) {         mCoverManager.waitUntilHalfCovered(axis);     }      /**      *      */     private void initStoragePath() {         File rxcvRecDataDir = new File(getExternalFilesDir(null),""RVCVRecData"");          // Create the storage directory if it does not exist         if (! rxcvRecDataDir.exists()) {             if (! rxcvRecDataDir.mkdirs()) {                 Log.e(TAG, ""failed to create main data directory"");             }         }          mRecordDir = new File(rxcvRecDataDir, new SimpleDateFormat(""yyMMdd-hhmmss"").format(new Date()));          if (! mRecordDir.mkdirs()) {             Log.e(TAG, ""failed to create rec data directory"");         }     }      /**      * Get the sensor log file path      * @return Path of the sensor log file      */     public String getSensorLogFilePath() {         return new File(mRecordDir, ""sensor.log"").getPath();     }      /**      * Get the video recording file path      * @return Path of the video recording file      */     public String getVideoRecFilePath() {         return new File(mRecordDir, ""video.mp4"").getPath();     }      /**      * Write out important camera/video information to a JSON file      * @param width         width of frame      * @param height        height of frame      * @param frameRate     frame rate in fps      * @param fovW          field of view in width direction      * @param fovH          field of view in height direction      */     public void writeVideoMetaInfo(int width, int height, float frameRate, float fovW, float fovH) {         try {             JsonWriter writer =                     new JsonWriter(                         new OutputStreamWriter(                                 new FileOutputStream(                                         new File(mRecordDir, ""videometa.json"").getPath()                                 )                         )                     );             writer.beginObject();             writer.name(""fovW"").value(fovW);             writer.name(""fovH"").value(fovH);             writer.name(""width"").value(width);             writer.name(""height"").value(height);             writer.name(""frameRate"").value(frameRate);             writer.endObject();              writer.close();         }catch (FileNotFoundException e) {             // Not very likely to happen             e.printStackTrace();         }catch (IOException e) {             // do nothing             e.printStackTrace();             Log.e(TAG, ""Writing video meta data failed."");         }     }      public interface RecordProcedureControllerCallback {         public void startRecordProcedureController();         public void stopRecordProcedureController();     }      /**      * Camera preview control class      */     class CameraContext {         private Camera mCamera;         private CamcorderProfile mProfile;         private Camera.CameraInfo mCameraInfo;         private RVCVCameraPreview mCameraPreview;          private int [] mPreferredProfiles = {                 CamcorderProfile.QUALITY_480P,  // smaller -> faster                 CamcorderProfile.QUALITY_720P,                 CamcorderProfile.QUALITY_1080P,                 CamcorderProfile.QUALITY_HIGH // existence guaranteed         };          private String [] mPreferredFocusMode = {                 Camera.Parameters.FOCUS_MODE_FIXED,                 Camera.Parameters.FOCUS_MODE_INFINITY,                 // the following two modes are more likely to mess up recording                 // but they are still better than FOCUS_MODE_AUTO, which requires                 // calling autoFocus explicitly to focus.                 Camera.Parameters.FOCUS_MODE_CONTINUOUS_VIDEO,                 Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE         };          CameraContext() {             try {                 mCamera = Camera.open(); // attempt to get a default Camera instance (0)                 mProfile = null;                 if (mCamera != null) {                     mCameraInfo = new Camera.CameraInfo();                     Camera.getCameraInfo(0, mCameraInfo);                     setupCamera();                 }             }             catch (Exception e){                 // Camera is not available (in use or does not exist)                 Log.e(TAG, ""Cannot obtain Camera!"");             }         }          /**          * Find a preferred camera profile and set preview and picture size property accordingly.          */         void setupCamera() {             CamcorderProfile profile = null;             boolean isSetNeeded = false;             Camera.Parameters param = mCamera.getParameters();             List<Camera.Size> pre_sz = param.getSupportedPreviewSizes();             List<Camera.Size> pic_sz = param.getSupportedPictureSizes();              for (int i : mPreferredProfiles) {                 if (CamcorderProfile.hasProfile(i)) {                     profile = CamcorderProfile.get(i);                      int valid = 0;                     for (Camera.Size j : pre_sz) {                         if (j.width == profile.videoFrameWidth &&                                 j.height == profile.videoFrameHeight) {                             ++valid;                             break;                         }                     }                     for (Camera.Size j : pic_sz) {                         if (j.width == profile.videoFrameWidth &&                                 j.height == profile.videoFrameHeight) {                             ++valid;                             break;                         }                     }                     if (valid == 2) {                         param.setPreviewSize(profile.videoFrameWidth, profile.videoFrameHeight);                         param.setPictureSize(profile.videoFrameWidth, profile.videoFrameHeight);                         isSetNeeded = true;                         break;                     } else {                         profile = null;                     }                 }             }              for (String i : mPreferredFocusMode) {                 if (param.getSupportedFocusModes().contains(i)){                     param.setFocusMode(i);                     isSetNeeded = true;                     break;                 }             }              if (isSetNeeded) {                 mCamera.setParameters(param);             }              if (profile != null) {                 param = mCamera.getParameters(); //acquire proper fov after change the picture size                 float fovW = param.getHorizontalViewAngle();                 float fovH = param.getVerticalViewAngle();                 writeVideoMetaInfo(profile.videoFrameWidth, profile.videoFrameHeight,                         profile.videoFrameRate, fovW, fovH);             } else {                 Log.e(TAG, ""Cannot find a proper video profile"");             }             mProfile = profile;          }           /**          * Get sensor information of the camera being used          */         public Camera.CameraInfo getCameraInfo() {             return mCameraInfo;         }          /**          * Get the camera to be previewed          * @return Reference to Camera used          */         public Camera getCamera() {             return mCamera;         }          /**          * Get the camera profile to be used          * @return Reference to Camera profile          */         public CamcorderProfile getProfile() {             return mProfile;         }          /**          * Setup the camera          */         public void init(RVCVRecordActivity.RecordProcedureControllerCallback callback) {             if (mCamera != null) {                 double alpha = mCamera.getParameters().getHorizontalViewAngle()*Math.PI/180.0;                 int width = mProfile.videoFrameWidth;                 double fx = width/2/Math.tan(alpha/2.0);                  if (LOCAL_LOGV) Log.v(TAG, ""View angle=""                         + mCamera.getParameters().getHorizontalViewAngle() +""  Estimated fx = ""+fx);                  mCameraPreview =                         (RVCVCameraPreview) findViewById(R.id.cam_preview);                 mCameraPreview.setRecordProcedureControllerCallback(callback);                 mCameraPreview.init(mCamera,                         (float)mProfile.videoFrameWidth/mProfile.videoFrameHeight,                         mCameraInfo.orientation);             } else {                 message(""Cannot open camera!"");                 finish();             }         }          /**          * End the camera preview          */         public void end() {             if (mCamera != null) {                 mCamera.release();        // release the camera for other applications                 mCamera = null;             }         }     }      /**      * Manage a set of RangeCoveredRegister objects      */     class CoverageManager {         // settings         private final int MAX_TILT_ANGLE = 50; // +/- 50         //private final int REQUIRED_TILT_ANGLE = 50; // +/- 50         private final int TILT_ANGLE_STEP = 5; // 5 degree(s) per step         private final int YAW_ANGLE_STEP = 10; // 10 degree(s) per step          RangeCoveredRegister[] mAxisCovered;          CoverageManager() {             mAxisCovered = new RangeCoveredRegister[3];             // X AXIS             mAxisCovered[0] = new RangeCoveredRegister(                     -MAX_TILT_ANGLE, +MAX_TILT_ANGLE, TILT_ANGLE_STEP);             // Y AXIS             mAxisCovered[1] = new RangeCoveredRegister(                     -MAX_TILT_ANGLE, +MAX_TILT_ANGLE, TILT_ANGLE_STEP);             // Z AXIS             mAxisCovered[2] = new RangeCoveredRegister(YAW_ANGLE_STEP);         }          public RangeCoveredRegister getAxis(int axis) {             // SensorManager.AXIS_X = 1, need offset -1 for mAxisCovered array             return mAxisCovered[axis-1];         }          public void waitUntilHalfCovered(int axis) {             if (axis == SensorManager.AXIS_Z) {                 waitUntilCovered(axis);             }              // SensorManager.AXIS_X = 1, need offset -1 for mAxisCovered array             while(!(mAxisCovered[axis-1].isRangeCovered(-MAX_TILT_ANGLE, -MAX_TILT_ANGLE/2) ||                         mAxisCovered[axis-1].isRangeCovered(MAX_TILT_ANGLE/2, MAX_TILT_ANGLE) ) ) {                 try {                     Thread.sleep(500);                 } catch (InterruptedException e) {                     if (LOCAL_LOGV) {                         Log.v(TAG, ""waitUntilHalfCovered axis = ""+ axis + "" is interrupted"");                     }                     Thread.currentThread().interrupt();                 }             }         }          public void waitUntilCovered(int axis) {             // SensorManager.AXIS_X = 1, need offset -1 for mAxisCovered array             while(!mAxisCovered[axis-1].isFullyCovered()) {                 try {                     Thread.sleep(500);                 } catch (InterruptedException e) {                     if (LOCAL_LOGV) {                         Log.v(TAG, ""waitUntilCovered axis = ""+ axis + "" is interrupted"");                     }                     Thread.currentThread().interrupt();                 }             }         }     }     ////////////////////////////////////////////////////////////////////////////////////////////////      /**      * A class controls the video recording      */     class VideoRecorder     {         private MediaRecorder mRecorder;         private CamcorderProfile mProfile;         private Camera mCamera;         private boolean mRunning = false;          VideoRecorder(Camera camera, CamcorderProfile profile){             mCamera = camera;             mProfile = profile;         }          /**          * Initialize and start recording          */         public void init() {             if (mCamera == null  || mProfile ==null){                 return;             }              mRecorder = new MediaRecorder();             try {                 mCamera.unlock();             } catch (RuntimeException e) {                 e.printStackTrace();                 try {                     mRecorder.reset();                     mRecorder.release();                 } catch (RuntimeException ex) {                     e.printStackTrace();                 }                 return;             }              try {                 mRecorder.setCamera(mCamera);                 mRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);                 mRecorder.setAudioSource(MediaRecorder.AudioSource.DEFAULT);                 mRecorder.setProfile(mProfile);             } catch (RuntimeException e) {                 e.printStackTrace();                 return;             }              try {                 mRecorder.setOutputFile(getVideoRecFilePath());                 mRecorder.prepare();             } catch (IOException e) {                 Log.e(TAG, ""Preparation for recording failed."");                 return;             }              try {                 mRecorder.start();             } catch (RuntimeException e) {                 Log.e(TAG, ""Starting recording failed."");                 try {                     mRecorder.reset();                     mRecorder.release();                     mCamera.lock();                 } catch (RuntimeException ex1) {                     e.printStackTrace();                 }                 return;             }             mRunning = true;         }          /**          * Stop recording          */         public void end() {             if (mRunning) {                 try {                     mRecorder.stop();                     mRecorder.reset();                     mRecorder.release();                     mCamera.lock();                 } catch (RuntimeException e) {                     e.printStackTrace();                     Log.e(TAG, ""Runtime error in stopping recording."");                 }             }             mRecorder = null;         }      }      ////////////////////////////////////////////////////////////////////////////////////////////////      /**      *  Log all raw sensor readings, for Rotation Vector sensor algorithms research      */     class RawSensorLogger implements SensorEventListener {         private final String TAG = ""RawSensorLogger"";          private final static int SENSOR_RATE = SensorManager.SENSOR_DELAY_FASTEST;         private File mRecPath;          SensorManager mSensorManager;         Sensor mAccSensor, mGyroSensor, mMagSensor;         OutputStreamWriter mAccLogWriter, mGyroLogWriter, mMagLogWriter;          private float[] mRTemp = new float[16];          RawSensorLogger(File recPath) {             mRecPath = recPath;         }          /**          * Initialize and start recording          */         public void init() {             mSensorManager = (SensorManager)getSystemService(SENSOR_SERVICE);              mAccSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);             mGyroSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE_UNCALIBRATED);             mMagSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED);              mSensorManager.registerListener(this, mAccSensor, SENSOR_RATE);             mSensorManager.registerListener(this, mGyroSensor, SENSOR_RATE);             mSensorManager.registerListener(this, mMagSensor, SENSOR_RATE);              try {                 mAccLogWriter= new OutputStreamWriter(                         new FileOutputStream(new File(mRecPath, ""raw_acc.log"")));                 mGyroLogWriter= new OutputStreamWriter(                         new FileOutputStream(new File(mRecPath, ""raw_uncal_gyro.log"")));                 mMagLogWriter= new OutputStreamWriter(                         new FileOutputStream(new File(mRecPath, ""raw_uncal_mag.log"")));              } catch (FileNotFoundException e) {                 Log.e(TAG, ""Sensor log file open failed: "" + e.toString());             }         }          /**          * Stop recording and clean up          */         public void end() {             mSensorManager.flush(this);             mSensorManager.unregisterListener(this);              try {                 if (mAccLogWriter != null) {                     OutputStreamWriter writer = mAccLogWriter;                     mAccLogWriter = null;                     writer.close();                 }                 if (mGyroLogWriter != null) {                     OutputStreamWriter writer = mGyroLogWriter;                     mGyroLogWriter = null;                     writer.close();                 }                 if (mMagLogWriter != null) {                     OutputStreamWriter writer = mMagLogWriter;                     mMagLogWriter = null;                     writer.close();                 }              } catch (IOException e) {                 Log.e(TAG, ""Sensor log file close failed: "" + e.toString());             }         }          @Override         public void onAccuracyChanged(Sensor sensor, int i) {             // do not care         }          @Override         public void onSensorChanged(SensorEvent event) {             OutputStreamWriter writer=null;             switch(event.sensor.getType()) {                 case Sensor.TYPE_ACCELEROMETER:                     writer = mAccLogWriter;                     break;                 case Sensor.TYPE_GYROSCOPE_UNCALIBRATED:                     writer = mGyroLogWriter;                     break;                 case Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED:                     writer = mMagLogWriter;                     break;              }             if (writer!=null)  {                 float[] data = event.values;                 try {                     if (event.sensor.getType() == Sensor.TYPE_ACCELEROMETER) {                         writer.write(String.format(""%d %f %f %f\r\n"",                                 event.timestamp, data[0], data[1], data[2]));                     }else // TYPE_GYROSCOPE_UNCALIBRATED and TYPE_MAGNETIC_FIELD_UNCALIBRATED                     {                         writer.write(String.format(""%d %f %f %f %f %f %f\r\n"", event.timestamp,                                 data[0], data[1], data[2], data[3], data[4], data[5]));                     }                 }catch (IOException e)                 {                     Log.e(TAG, ""Write to raw sensor log file failed."");                 }              }         }     }      /**      *  Rotation sensor logger class      */     class RVSensorLogger implements SensorEventListener {         private final String TAG = ""RVSensorLogger"";          private final static int SENSOR_RATE = SensorManager.SENSOR_DELAY_FASTEST;         RangeCoveredRegister mRegister;         int mAxis;         RVCVRecordActivity mActivity;          SensorManager mSensorManager;         Sensor mRVSensor;         OutputStreamWriter mLogWriter;          private float[] mRTemp = new float[16];          RVSensorLogger(RVCVRecordActivity activity) {             mActivity = activity;         }          /**          * Initialize and start recording          */         public void init() {             mSensorManager = (SensorManager)getSystemService(SENSOR_SERVICE);             if (mSensorManager == null) {                 Log.e(TAG,""SensorManager is null!"");             }             mRVSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ROTATION_VECTOR);             if (mRVSensor != null) {                 if (LOCAL_LOGV) Log.v(TAG, ""Got RV Sensor"");             }else {                 Log.e(TAG, ""Did not get RV sensor"");             }             if(mSensorManager.registerListener(this, mRVSensor, SENSOR_RATE)) {                 if (LOCAL_LOGV) Log.v(TAG,""Register listener successfull"");             } else {                 Log.e(TAG,""Register listener failed"");             }              try {                 mLogWriter= new OutputStreamWriter(                         new FileOutputStream(mActivity.getSensorLogFilePath()));             } catch (FileNotFoundException e) {                 Log.e(TAG, ""Sensor log file open failed: "" + e.toString());             }         }          /**          * Stop recording and clean up          */         public void end() {             mSensorManager.flush(this);             mSensorManager.unregisterListener(this);              try {                 if (mLogWriter != null) {                     OutputStreamWriter writer = mLogWriter;                     mLogWriter = null;                     writer.close();                 }             } catch (IOException e) {                 Log.e(TAG, ""Sensor log file close failed: "" + e.toString());             }              updateRegister(null, AXIS_NONE);         }          private void onNewData(float[] data, long timestamp) {             // LOG             try {                 if (mLogWriter != null) {                     mLogWriter.write(String.format(""%d %f %f %f %f\r\n"", timestamp,                             data[3], data[0], data[1], data[2]));                 }             } catch (IOException e) {                 Log.e(TAG, ""Sensor log file write failed: "" + e.toString());             }              // Update UI             if (mRegister != null) {                 int d = 0;                 int dx, dy, dz;                 boolean valid = false;                 SensorManager.getRotationMatrixFromVector(mRTemp, data);                  dx = (int)(Math.asin(mRTemp[8])*(180.0/Math.PI));                 dy = (int)(Math.asin(mRTemp[9])*(180.0/Math.PI));                 dz = (int)((Math.atan2(mRTemp[4], mRTemp[0])+Math.PI)*(180.0/Math.PI));                  switch(mAxis) {                     case SensorManager.AXIS_X:                         d = dx;                         valid = (Math.abs(dy) < 30);                         break;                     case SensorManager.AXIS_Y:                         d = dy;                         valid = (Math.abs(dx) < 30);                         break;                     case SensorManager.AXIS_Z:                         d = dz;                         valid = (Math.abs(dx) < 20 && Math.abs(dy) < 20);                         break;                 }                  if (valid) {                     mRegister.update(d);                     mActivity.redrawIndicator();                 }             }          }          public void updateRegister(RangeCoveredRegister reg, int axis) {             mRegister = reg;             mAxis = axis;         }           @Override         public void onAccuracyChanged(Sensor sensor, int i) {             // do not care         }          @Override         public void onSensorChanged(SensorEvent event) {             if (event.sensor.getType() == Sensor.TYPE_ROTATION_VECTOR) {                 onNewData(event.values, event.timestamp);             }         }     }       ////////////////////////////////////////////////////////////////////////////////////////////////      /**      * Controls the over all logic of record procedure: first x-direction, then y-direction and      * then z-direction.      */     class RecordProcedureController implements Runnable {         private static final boolean LOCAL_LOGV = false;          private final RVCVRecordActivity mActivity;         private Thread mThread = null;          RecordProcedureController(RVCVRecordActivity activity) {             mActivity = activity;             mThread = new Thread(this);             mThread.start();         }          /**          * Run the record procedure          */         public void run() {             if (LOCAL_LOGV) Log.v(TAG, ""Controller Thread Started."");             //start recording & logging             delay(2000);              init();             if (LOCAL_LOGV) Log.v(TAG, ""Controller Thread init() finished."");              // test 3 axis             // It is in YXZ order because UI element design use opposite definition             // of XY axis. To ensure the user see X Y Z, it is flipped here.             recordAxis(SensorManager.AXIS_Y);             if (LOCAL_LOGV) Log.v(TAG, ""Controller Thread axis 0 finished."");              recordAxis(SensorManager.AXIS_X);             if (LOCAL_LOGV) Log.v(TAG, ""Controller Thread axis 1 finished."");              recordAxis(SensorManager.AXIS_Z);             if (LOCAL_LOGV) Log.v(TAG, ""Controller Thread axis 2 finished."");              delay(1000);             end();             if (LOCAL_LOGV) Log.v(TAG, ""Controller Thread End."");         }          private void delay(int milli) {             try{                 Thread.sleep(milli);             } catch(InterruptedException e) {                 if (LOCAL_LOGV) Log.v(TAG, ""Controller Thread Interrupted."");             }         }         private void init() {             // start video recording             mActivity.startRecordVideo();              // start sensor logging & listening             mActivity.startRecordSensor();         }          private void end() {             // stop video recording             mActivity.stopRecordVideo();              // stop sensor logging             mActivity.stopRecordSensor();              // notify ui complete             runOnUiThread(new Runnable(){                 public void run() {                     mActivity.notifyComplete();                 }             });         }          private void recordAxis(int axis) {             // delay 2 seconds?             delay(1000);              // change ui             mActivity.switchAxisAsync(axis);              // play start sound             mActivity.playNotifySound(""start"");              if (axis != SensorManager.AXIS_Z) {                 // wait until axis half covered                 mActivity.waitUntilHalfCovered(axis);                  // play half way sound                 mActivity.playNotifySound(""half-way"");             }              // wait until axis covered             mActivity.waitUntilCovered(axis);              // play stop sound             mActivity.playNotifySound(""end"");         }          /**          * Force quit          */         public void quit() {             mThread.interrupt();             try {                 if (LOCAL_LOGV) Log.v(TAG, ""Wait for controller to end"");                  // stop video recording                 mActivity.stopRecordVideo();                  // stop sensor logging                 mActivity.stopRecordSensor();              } catch (Exception e)             {                 e.printStackTrace();             }         }     }  }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorIntegrationTests"	"testGeomagneticRotationVectorReconfigureWhileActive"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorIntegrationTests.java"	""	"public void testGeomagneticRotationVectorReconfigureWhileActive() throws Throwable {         verifySensorReconfigureWhileActive(Sensor.TYPE_GEOMAGNETIC_ROTATION_VECTOR);     }      /**      * This test focuses on ensuring that an active sensor is able to be reconfigured when a new      * client requests a different sampling rate.      *      * The test verifies that if a sensor is active with a slow sampling rate and a new client      * requests a faster sampling rate, the sensor begins returning data at the faster sampling      * rate.      *      * The assertion associated with the test failure provides:      * - the thread id on which the failure occurred      * - the sensor type and sensor handle that caused the failure      * - the event that caused the issue      * It is important to look at the internals of the Sensor HAL to identify how the interaction      * of several clients can lead to the failing state.      */     public void verifySensorReconfigureWhileActive(int sensorType) throws Throwable {         SensorCtsHelper.sleep(3, TimeUnit.SECONDS);          final int DELAY_BEFORE_CHANGING_RATE_SEC = 2;         final int EVENTS_FOR_VERIFICATION = 200;         Context context = getContext();         SensorManager sensorManager =                 (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);         assertNotNull(""SensorService is not present in the system"", sensorManager);          Sensor sensor = sensorManager.getDefaultSensor(sensorType);         if(sensor == null) {             throw new SensorNotSupportedException(sensorType);         }          // Request for the sensor rate to be set to the slowest rate.         ParallelSensorOperation operation = new ParallelSensorOperation();         TestSensorEnvironment environmentSlow = new TestSensorEnvironment(                 context,                 sensor,                 shouldEmulateSensorUnderLoad(),                 true, /* isIntegrationTest */                 sensor.getMaxDelay(),                 (int)TimeUnit.SECONDS.toMicros(20));         TestSensorOperation sensorOperationSlow = TestSensorOperation.createOperation(                 environmentSlow, 2 * DELAY_BEFORE_CHANGING_RATE_SEC, TimeUnit.SECONDS);         operation.add(sensorOperationSlow);          // Create a second operation that will run in parallel and request the fastest rate after         // an initial delay. The delay is to ensure that the first operation has enabled the sensor.         // The sensor should begin reporting at the newly requested rate. Execute a flush prior to         // the reconfiguration to ensure that the lower frequency events are not received after the         // reconfiguration of the sensor.         SequentialSensorOperation sequentialSensorOperation = new SequentialSensorOperation();         TestSensorEnvironment environmentFast = new TestSensorEnvironment(                 context,                 sensor,                 shouldEmulateSensorUnderLoad(),                 true, /* isIntegrationTest */                 sensor.getMinDelay(),                 0 /* max reporting latency */);          // Create the flush operation with a delay to ensure the low frequency configuration was         // handled and executed. Use the original environment since the flush operation will         // register a new listener and reconfigure the sensor.         TestSensorOperation flushOperation = TestSensorOperation.createFlushOperation(                 environmentSlow, DELAY_BEFORE_CHANGING_RATE_SEC, TimeUnit.SECONDS);         sequentialSensorOperation.add(flushOperation);          // Create the reconfiguration request and add it after the flush         TestSensorOperation sensorOperationFast = TestSensorOperation.createOperation(                 environmentFast, EVENTS_FOR_VERIFICATION);         sensorOperationFast.addVerification(FrequencyVerification.getDefault(environmentFast));         sequentialSensorOperation.add(sensorOperationFast);          // Add the sequential operation containing the flush and high frequency request to the         // existing parallel operation that already contains the low frequency request.         operation.add(sequentialSensorOperation);         operation.execute(getCurrentTestNode());         operation.getStats().log(TAG);     }      /**      * Regress:      * - b/10641388      */"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorDirectReportTest"	"testCloseWithoutConfigStop"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testCloseWithoutConfigStop() {         for (int type : POSSIBLE_SENSOR_TYPES) {             for (int memType : POSSIBLE_CHANNEL_TYPES) {                 Sensor s = mSensorManager.getDefaultSensor(type);                 if (s == null                         || s.getHighestDirectReportRateLevel() == SensorDirectChannel.RATE_STOP                         || !s.isDirectChannelTypeSupported(memType)) {                     continue;                 }                  mChannel = prepareDirectChannel(memType, false /* secondary */);                 assertTrue(""createDirectChannel failed"", mChannel != null);                  try {                     waitBeforeStartSensor();                     mChannel.configure(s, s.getHighestDirectReportRateLevel());                      // wait for a while                     waitBeforeStartSensor();                      // The following line is commented out intentionally.                     // mChannel.configure(s, SensorDirectChannel.RATE_STOP);                 } finally {                     mChannel.close();                     mChannel = null;                 }                 waitBeforeStartSensor();             }         }     }      private void runSingleChannelRateIndependencyTestGroup(int type1, int type2) {         if (type1 == type2) {             throw new IllegalArgumentException(""Cannot run single channel rate independency test ""                     + ""on type "" + type1 + "" and "" + type2);         }         String stype1 = SensorCtsHelper.sensorTypeShortString(type1);         String stype2 = SensorCtsHelper.sensorTypeShortString(type2);          TestResultCollector c =                 new TestResultCollector(                     ""testRateIndependency"" + stype1 + stype2 + ""SingleChannel"", TAG);          for (int rate1 : POSSIBLE_RATE_LEVELS) {             for (int rate2 : POSSIBLE_RATE_LEVELS) {                 for (int memType : POSSIBLE_CHANNEL_TYPES) {                     c.perform(                         () -> {                             runSingleChannelRateIndependencyTest(                                     type1, rate1, type2, rate2,                                     SensorDirectChannel.TYPE_MEMORY_FILE);                         },                         String.format(""(%s rate %d, %s rate %d, mem %d)"",                                       stype1, rate1, stype2, rate2, memType));                 }             }         }         c.judge();     }      public void runMultiChannelRateIndependencyTestGroup(int sensorType) {         TestResultCollector c = new TestResultCollector(                 ""testRateIndependency"" + SensorCtsHelper.sensorTypeShortString(sensorType)                     + ""MultiChannel"", TAG);          for (int rate1 : POSSIBLE_RATE_LEVELS) {             for (int rate2 : POSSIBLE_RATE_LEVELS) {                 for (int type1 : POSSIBLE_CHANNEL_TYPES) {                     for (int type2 : POSSIBLE_CHANNEL_TYPES) {                         // only test upper triangle                         if (rate1 > rate2 || type1 > type2) {                             continue;                         }                         c.perform(() -> {                                 runMultiChannelRateIndependencyTest(                                         sensorType, rate1, rate2, type1, type2);},                                 String.format(""rate1 %d, rate2 %d, type1 %d, type2 %d"",                                               rate1, rate2, type1, type2));                     }                 }             }         }         c.judge();     }      public void runMultiModeRateIndependencyTestGroup(int sensorType) {         TestResultCollector c = new TestResultCollector(                 ""testRateIndependency"" + SensorCtsHelper.sensorTypeShortString(sensorType)                     + ""MultiMode"", TAG);          for (int rate : POSSIBLE_RATE_LEVELS) {             for (int type : POSSIBLE_CHANNEL_TYPES) {                 for (int samplingPeriodUs : POSSIBLE_SAMPLE_PERIOD_US) {                     c.perform(() -> {runMultiModeRateIndependencyTest(                                         sensorType, rate, type, samplingPeriodUs);},                               String.format(""rateLevel %d, memType %d, period %d"",                                             rate, type, samplingPeriodUs));                 }             }         }         c.judge();     }      private void runTimestampTestGroup(int sensorType) {         String stype = SensorCtsHelper.sensorTypeShortString(sensorType);          TestResultCollector c =                 new TestResultCollector(""testTimestamp"" + stype, TAG);          for (int rateLevel : POSSIBLE_RATE_LEVELS) {             for (int memType : POSSIBLE_CHANNEL_TYPES) {                 c.perform(                         () -> {                             runTimestampTest(sensorType, rateLevel, memType);                         },                         String.format(""(%s, rate %d, memtype %d)"", stype, rateLevel, memType));             }         }         c.judge();     }      private void runSensorDirectReportTest(int sensorType, int memType, int rateLevel)             throws AssertionError {         Sensor s = mSensorManager.getDefaultSensor(sensorType);         if (s == null                 || s.getHighestDirectReportRateLevel() < rateLevel                 || !s.isDirectChannelTypeSupported(memType)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);          try {             assertTrue(""Shared memory is not formatted"", isSharedMemoryFormatted(memType));             waitBeforeStartSensor();              int token = mChannel.configure(s, rateLevel);             assertTrue(""configure direct mChannel failed"", token > 0);              waitSensorCollection();              //stop sensor and analyze content             mChannel.configure(s, SensorDirectChannel.RATE_STOP);             checkSharedMemoryContent(s, memType, rateLevel, token);         } finally {             mChannel.close();             mChannel = null;         }     }      private void runSensorDirectReportUidIdleTest(int sensorType, int memType, int rateLevel) {         Sensor s = mSensorManager.getDefaultSensor(sensorType);         if (s == null                 || s.getHighestDirectReportRateLevel() < rateLevel                 || !s.isDirectChannelTypeSupported(memType)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);          try {             assertTrue(""Shared memory is not formatted"", isSharedMemoryFormatted(memType));             waitBeforeStartSensor();              int token = mChannel.configure(s, rateLevel);             assertTrue(""configure direct mChannel failed"", token > 0);              // Make package idle and ensure no sensor events are received             try {                 SensorCtsHelper.makeMyPackageIdle();             } catch (IOException e) {                 fail(""IOException while making package idle"");             }              int originalEventSize = mBuffer.length;             waitSensorCollection();              assertEquals(mBuffer.length, originalEventSize);              try {                 SensorCtsHelper.makeMyPackageActive();             } catch (IOException e) {                 fail(""IOException while making package active"");             }              // Also verify sensor events can be received after becoming active.             resetEvent();              waitSensorCollection();              //stop sensor and analyze content             mChannel.configure(s, SensorDirectChannel.RATE_STOP);             checkSharedMemoryContent(s, memType, rateLevel, token);         } finally {             mChannel.close();             mChannel = null;         }     }      private void runSingleChannelRateIndependencyTest(             int type1, int rateLevel1, int type2, int rateLevel2, int memType)                 throws AssertionError {         Sensor s1 = mSensorManager.getDefaultSensor(type1);         Sensor s2 = mSensorManager.getDefaultSensor(type2);         if (s1 == null                 || s1.getHighestDirectReportRateLevel() < rateLevel1                 || !s1.isDirectChannelTypeSupported(memType)) {             return;         }          if (s2 == null                 || s2.getHighestDirectReportRateLevel() < rateLevel2                 || !s2.isDirectChannelTypeSupported(memType)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);          try {             assertTrue(""Shared memory is not formatted"", isSharedMemoryFormatted(memType));             waitBeforeStartSensor();              int token1 = mChannel.configure(s1, rateLevel1);             int token2 = mChannel.configure(s2, rateLevel2);             assertTrue(""configure direct mChannel failed, token1 = "" + token1, token1 > 0);             assertTrue(""configure direct mChannel failed, token2 = "" + token2, token2 > 0);              // run half amount of time so buffer is enough for both sensors             try {                 SensorCtsHelper.sleep(TEST_RUN_TIME_PERIOD_MILLISEC / 2, TimeUnit.MILLISECONDS);             } catch (InterruptedException e) {                 Thread.currentThread().interrupt();             }              //stop sensor and analyze content             mChannel.configure(s1, SensorDirectChannel.RATE_STOP);             mChannel.configure(s2, SensorDirectChannel.RATE_STOP);              readSharedMemory(memType, false /*secondary*/);             checkEventRate(TEST_RUN_TIME_PERIOD_MILLISEC / 2, parseEntireBuffer(mBuffer, token1),                            type1, rateLevel1);             checkEventRate(TEST_RUN_TIME_PERIOD_MILLISEC / 2, parseEntireBuffer(mBuffer, token2),                            type2, rateLevel2);         } finally {             mChannel.close();             mChannel = null;         }     }      private void runMultiChannelRateIndependencyTest(             int type, int rateLevel1, int rateLevel2, int memType1, int memType2)                 throws AssertionError {         Sensor s = mSensorManager.getDefaultSensor(type);         if (s == null                 || s.getHighestDirectReportRateLevel() < Math.max(rateLevel1, rateLevel2)                 || !s.isDirectChannelTypeSupported(memType1)                 || !s.isDirectChannelTypeSupported(memType2)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType1, false /* secondary */);         mChannelSecondary = prepareDirectChannel(memType2, true /* secondary */);          try {             assertTrue(""createDirectChannel failed"", mChannel != null);             assertTrue(""Shared memory is not formatted"",                        isSharedMemoryFormatted(memType1));              assertTrue(""createDirectChannel(secondary) failed"", mChannelSecondary != null);             assertTrue(""Shared memory(secondary) is not formatted"",                        isSharedMemoryFormatted(memType2, true));              waitBeforeStartSensor();              int token1 = mChannel.configure(s, rateLevel1);             int token2 = mChannelSecondary.configure(s, rateLevel2);             assertTrue(""configure direct mChannel failed"", token1 > 0);             assertTrue(""configure direct mChannelSecondary failed"", token2 > 0);              waitSensorCollection();              //stop sensor and analyze content             mChannel.configure(s, SensorDirectChannel.RATE_STOP);             mChannelSecondary.configure(s, SensorDirectChannel.RATE_STOP);              // check rate             readSharedMemory(memType1, false /*secondary*/);             checkEventRate(TEST_RUN_TIME_PERIOD_MILLISEC, parseEntireBuffer(mBuffer, token1),                            type, rateLevel1);              readSharedMemory(memType2, true /*secondary*/);             checkEventRate(TEST_RUN_TIME_PERIOD_MILLISEC, parseEntireBuffer(mBuffer, token2),                            type, rateLevel2);         } finally {             if (mChannel != null) {                 mChannel.close();                 mChannel = null;             }             if (mChannelSecondary != null) {                 mChannelSecondary.close();                 mChannelSecondary = null;             }         }     }      private void runMultiModeRateIndependencyTest(             int type , int rateLevel, int memType, int samplingPeriodUs)                 throws AssertionError {         final Sensor s = mSensorManager.getDefaultSensor(type);         if (s == null                 || s.getHighestDirectReportRateLevel() < rateLevel                 || !s.isDirectChannelTypeSupported(memType)) {             return;         }          if (samplingPeriodUs == 0) {             samplingPeriodUs = s.getMinDelay();         }          if (samplingPeriodUs < s.getMinDelay()) {             return;         }          if (samplingPeriodUs > s.getMaxDelay()) {             samplingPeriodUs = s.getMaxDelay();         }          resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);         SensorEventCollection listener = new SensorEventCollection(s);          try {             waitBeforeStartSensor();             int token = mChannel.configure(s, rateLevel);             boolean registerRet = mSensorManager.registerListener(listener, s, samplingPeriodUs);             assertTrue(""Register listener failed"", registerRet);              waitSensorCollection();              mChannel.configure(s, SensorDirectChannel.RATE_STOP);             mSensorManager.unregisterListener(listener);              // check direct report rate             readSharedMemory(memType, false /*secondary*/);             List<DirectReportSensorEvent> events = parseEntireBuffer(mBuffer, token);             checkEventRate(TEST_RUN_TIME_PERIOD_MILLISEC, events, type, rateLevel);              // check callback interface rate             checkEventRateUs(TEST_RUN_TIME_PERIOD_MILLISEC, listener.getEvents(), type,                              samplingPeriodUs);         } finally {             mChannel.close();             mChannel = null;             mSensorManager.unregisterListener(listener);         }     }      private void runTimestampTest(int type, int rateLevel, int memType) {         Sensor s = mSensorManager.getDefaultSensor(type);         if (s == null                 || s.getHighestDirectReportRateLevel() < rateLevel                 || !s.isDirectChannelTypeSupported(memType)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);          SensorEventCollection listener = new SensorEventCollection(s);          try {             float nominalFreq = getNominalFreq(rateLevel);             int samplingPeriodUs = Math.max((int) (1e6f / nominalFreq), s.getMinDelay());              assertTrue(""Shared memory is not formatted"",                        isSharedMemoryFormatted(memType));              int token = mChannel.configure(s, rateLevel);             assertTrue(""configure direct mChannel failed"", token > 0);              boolean registerRet = mSensorManager.registerListener(listener, s, samplingPeriodUs);             assertTrue(""Register listener failed"", registerRet);              List<DirectReportSensorEvent> events = collectSensorEventsRealtime(                     memType, false /*secondary*/, TEST_RUN_TIME_PERIOD_MILLISEC);             assertTrue(""Realtime event collection failed"", events != null);             assertTrue(""Realtime event collection got no data"", events.size() > 0);              //stop sensor and analyze content             mChannel.configure(s, SensorDirectChannel.RATE_STOP);             mSensorManager.unregisterListener(listener);              // check rate             checkTimestampRelative(events, listener.getEvents());             checkTimestampAbsolute(events);         } finally {             mChannel.close();             mChannel = null;         }     }      private void runAtomicCounterTest(int sensorType, int memType) throws AssertionError {         Sensor s = mSensorManager.getDefaultSensor(sensorType);         if (s == null                 || s.getHighestDirectReportRateLevel() == SensorDirectChannel.RATE_STOP                 || !s.isDirectChannelTypeSupported(memType)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);          try {             assertTrue(""Shared memory is not formatted"", isSharedMemoryFormatted(memType));             waitBeforeStartSensor();              //int token = mChannel.configure(s, SensorDirectChannel.RATE_FAST);             int token = mChannel.configure(s, s.getHighestDirectReportRateLevel());             assertTrue(""configure direct mChannel failed"", token > 0);              checkAtomicCounterUpdate(memType, 30 * 1000); // half min              //stop sensor and analyze content             mChannel.configure(s, SensorDirectChannel.RATE_STOP);         } finally {             mChannel.close();             mChannel = null;         }     }      private void runReconfigureTest(int type, int memType) {         Sensor s = mSensorManager.getDefaultSensor(type);         if (s == null                 || s.getHighestDirectReportRateLevel() == SensorDirectChannel.RATE_STOP                 || !s.isDirectChannelTypeSupported(memType)) {             return;         }         resetEvent();          mChannel = prepareDirectChannel(memType, false /* secondary */);         assertTrue(""createDirectChannel failed"", mChannel != null);          try {             assertTrue(""Shared memory is not formatted"", isSharedMemoryFormatted(memType));             waitBeforeStartSensor();              int offset = 0;             long counter = 1;             List<Integer> rateLevels = new ArrayList<>();             List<DirectReportSensorEvent> events;              rateLevels.add(s.getHighestDirectReportRateLevel());             rateLevels.add(s.getHighestDirectReportRateLevel());             if (s.getHighestDirectReportRateLevel() != SensorDirectChannel.RATE_NORMAL) {                 rateLevels.add(SensorDirectChannel.RATE_NORMAL);             }              for (int rateLevel : rateLevels) {                 int token = mChannel.configure(s, rateLevel);                 assertTrue(""configure direct mChannel failed"", token > 0);                  events = collectSensorEventsRealtime(memType, false /*secondary*/,                                                      TEST_RUN_TIME_PERIOD_MILLISEC,                                                      offset, counter);                 // stop sensor                 mChannel.configure(s, SensorDirectChannel.RATE_STOP);                 checkEventRate(TEST_RUN_TIME_PERIOD_MILLISEC, events, type, rateLevel);                  // collect all events after stop                 events = collectSensorEventsRealtime(memType, false /*secondary*/,                                                      REST_PERIOD_BEFORE_TEST_MILLISEC,                                                      offset, counter);                 if (events.size() > 0) {                     offset += (events.size() * SENSORS_EVENT_SIZE ) % SHARED_MEMORY_SIZE;                     counter = events.get(events.size() - 1).serial;                 }             }              // finally stop the report             mChannel.configure(s, SensorDirectChannel.RATE_STOP);         } finally {             mChannel.close();             mChannel = null;         }     }      private void waitBeforeStartSensor() {         // wait for sensor system to come to a rest after previous test to avoid flakiness.         try {             SensorCtsHelper.sleep(REST_PERIOD_BEFORE_TEST_MILLISEC, TimeUnit.MILLISECONDS);         } catch (InterruptedException e) {             Thread.currentThread().interrupt();         }     }      private void waitSensorCollection() {         // wait for sensor collection to finish         try {             SensorCtsHelper.sleep(TEST_RUN_TIME_PERIOD_MILLISEC, TimeUnit.MILLISECONDS);         } catch (InterruptedException e) {             Thread.currentThread().interrupt();         }     }      private List<DirectReportSensorEvent> collectSensorEventsRealtime(             int memType, boolean secondary, int timeoutMs) {         return collectSensorEventsRealtime(memType, secondary, timeoutMs,                                           0 /*initialOffset*/, 1l /*initialCounter*/);     }      private List<DirectReportSensorEvent> collectSensorEventsRealtime(             int memType, boolean secondary, int timeoutMs, int initialOffset, long initialCounter) {         List<DirectReportSensorEvent> events = new ArrayList<>();         long endTime = SystemClock.elapsedRealtime() + timeoutMs;          long atomicCounter = initialCounter;         int offset = initialOffset;          long timeA = SystemClock.elapsedRealtimeNanos();         boolean synced = false;         int filtered = 0;          while (SystemClock.elapsedRealtime() < endTime) {             if (!readSharedMemory(                     memType, secondary, offset + ATOMIC_COUNTER_OFFSET, ATOMIC_COUNTER_SIZE)) {                 return null;             }              long timeB = SystemClock.elapsedRealtimeNanos();             if (timeB - timeA > 1_000_000L ) { // > 1ms                 synced = false;             }             timeA = timeB;              if (readAtomicCounter(offset) == atomicCounter) {                 // read entire event again and parse                 if (!readSharedMemory(memType, secondary, offset, SENSORS_EVENT_SIZE)) {                     return null;                 }                 DirectReportSensorEvent e = mEventPool.get();                 assertNotNull(""cannot get event from reserve"", e);                 parseSensorEvent(offset, e);                  atomicCounter += 1;                 if (synced) {                     events.add(e);                 } else {                     ++filtered;                 }                  offset += SENSORS_EVENT_SIZE;                 if (offset + SENSORS_EVENT_SIZE > SHARED_MEMORY_SIZE) {                     offset = 0;                 }             } else {                 synced = true;             }         }         Log.d(TAG, ""filtered "" + filtered + "" events, remain "" + events.size() + "" events"");         return events;     }      private void checkAtomicCounterUpdate(int memType, int timeoutMs) {         List<DirectReportSensorEvent> events = new ArrayList<>();         long endTime = SystemClock.elapsedRealtime() + timeoutMs;          boolean lastValid = false;         long atomicCounter = 1;         int lastOffset = 0;         int offset = 0;          byte[] lastArray = new byte[SENSORS_EVENT_SIZE];         DirectReportSensorEvent e = getEvent();          while (SystemClock.elapsedRealtime() < endTime) {             if (!readSharedMemory(memType, false/*secondary*/, lastOffset, SENSORS_EVENT_SIZE)                     || !readSharedMemory(memType, false/*secondary*/,                                          offset + ATOMIC_COUNTER_OFFSET, ATOMIC_COUNTER_SIZE)) {                 throw new IllegalStateException(""cannot read shared memory, type "" + memType);             }              if (lastValid) {                 boolean failed = false;                 int i;                 for (i = 0; i < SENSORS_EVENT_SIZE; ++i) {                     if (lastArray[i] != mBuffer[lastOffset + i]) {                         failed = true;                         break;                     }                 }                  if (failed) {                     byte[] currentArray = new byte[SENSORS_EVENT_SIZE];                     System.arraycopy(mBuffer, lastOffset, currentArray, 0, SENSORS_EVENT_SIZE);                      // wait for 100ms and read again to see if the change settle                     try {                         SensorCtsHelper.sleep(100, TimeUnit.MILLISECONDS);                     } catch (InterruptedException ex) {                         Thread.currentThread().interrupt();                     }                      byte[] delayedRead = new byte[SENSORS_EVENT_SIZE];                     if (!readSharedMemory(                                 memType, false/*secondary*/, lastOffset, SENSORS_EVENT_SIZE)) {                         throw new IllegalStateException(                                 ""cannot read shared memory, type "" + memType);                     }                     System.arraycopy(mBuffer, lastOffset, delayedRead, 0, SENSORS_EVENT_SIZE);                      fail(String.format(                             ""At offset %d(0x%x), byte %d(0x%x) changed after atomicCounter""                                 + ""(expecting %d, 0x%x) update, old = [%s], new = [%s], ""                                 + ""delayed = [%s]"",                             lastOffset, lastOffset, i, i, atomicCounter, atomicCounter,                             SensorCtsHelper.bytesToHex(lastArray, -1, -1),                             SensorCtsHelper.bytesToHex(currentArray, -1, -1),                             SensorCtsHelper.bytesToHex(delayedRead, -1, -1)));                 }             }              if (readAtomicCounter(offset) == atomicCounter) {                 // read entire event again and parse                 if (!readSharedMemory(memType, false/*secondary*/, offset, SENSORS_EVENT_SIZE)) {                     throw new IllegalStateException(""cannot read shared memory, type "" + memType);                 }                 parseSensorEvent(offset, e);                  atomicCounter += 1;                  lastOffset = offset;                 System.arraycopy(mBuffer, lastOffset, lastArray, 0, SENSORS_EVENT_SIZE);                 lastValid = true;                  offset += SENSORS_EVENT_SIZE;                 if (offset + SENSORS_EVENT_SIZE > SHARED_MEMORY_SIZE) {                     offset = 0;                 }             }         }         Log.d(TAG, ""at finish checkAtomicCounterUpdate has atomic counter = "" + atomicCounter);         // atomicCounter will not wrap back in reasonable amount of time         assertTrue(""Realtime event collection got no data"", atomicCounter != 1);     }      private MemoryFile allocateMemoryFile() {         MemoryFile memFile = null;         try {             memFile = new MemoryFile(""Sensor Channel"", SHARED_MEMORY_SIZE);         } catch (IOException e) {             Log.e(TAG, ""IOException when allocating MemoryFile"");         }         return memFile;     }      private HardwareBuffer allocateHardwareBuffer() {         HardwareBuffer hardwareBuffer;          hardwareBuffer = HardwareBuffer.create(                 SHARED_MEMORY_SIZE, 1 /* height */, HardwareBuffer.BLOB, 1 /* layer */,                 HardwareBuffer.USAGE_CPU_READ_OFTEN | HardwareBuffer.USAGE_GPU_DATA_BUFFER                     | HardwareBuffer.USAGE_SENSOR_DIRECT_DATA);         return hardwareBuffer;     }      private SensorDirectChannel prepareDirectChannel(int memType, boolean secondary) {         SensorDirectChannel channel = null;          try {             switch(memType) {                 case SensorDirectChannel.TYPE_MEMORY_FILE: {                     MemoryFile memoryFile = secondary ? mMemoryFileSecondary : mMemoryFile;                     assertTrue(""MemoryFile"" + (secondary ? ""(secondary)"" : """") + "" is null"",                                memoryFile != null);                     channel = mSensorManager.createDirectChannel(memoryFile);                     break;                 }                 case SensorDirectChannel.TYPE_HARDWARE_BUFFER: {                     HardwareBuffer hardwareBuffer                             = secondary ? mHardwareBufferSecondary : mHardwareBuffer;                     assertTrue(""HardwareBuffer"" + (secondary ? ""(secondary)"" : """") + "" is null"",                                hardwareBuffer != null);                     channel = mSensorManager.createDirectChannel(hardwareBuffer);                     break;                 }                 default:                     Log.e(TAG, ""Specified illegal memory type "" + memType);             }         } catch (IllegalStateException | UncheckedIOException e) {             Log.e(TAG, ""Cannot initialize channel for memory type "" + memType                     + "", details:"" + e);             channel = null;         }         return channel;     }      private boolean readSharedMemory(int memType, boolean secondary, int offset, int length) {         switch(memType) {             case SensorDirectChannel.TYPE_MEMORY_FILE:                 try {                     MemoryFile f = secondary ? mMemoryFileSecondary : mMemoryFile;                     if (f.readBytes(mBuffer, offset, offset, length) != length) {                         Log.e(TAG, ""cannot read entire MemoryFile"");                         return false;                     }                 } catch (IOException e) {                     Log.e(TAG, ""accessing MemoryFile causes IOException"");                     return false;                 }                 return true;             case SensorDirectChannel.TYPE_HARDWARE_BUFFER:                 return nativeReadHardwareBuffer(                         secondary ? mHardwareBufferSecondary : mHardwareBuffer,                         mBuffer, offset, offset, length);             default:                 return false;         }     }      private boolean readSharedMemory(int memType, boolean secondary) {         return readSharedMemory(memType, secondary, 0, SHARED_MEMORY_SIZE);     }      private boolean readSharedMemory(int memType) {         return readSharedMemory(memType, false /*secondary*/);     }      private boolean isMemoryTypeNeeded(int memType) {         List<Sensor> sensorList = mSensorManager.getSensorList(Sensor.TYPE_ALL);         for (Sensor s : sensorList) {             if (s.isDirectChannelTypeSupported(memType)) {                 return true;             }         }         return false;     }      private boolean isSharedMemoryFormatted(int memType) {         return isSharedMemoryFormatted(memType, false /* secondary */);     }      private boolean isSharedMemoryFormatted(int memType, boolean secondary) {         readSharedMemory(memType, secondary);          for (byte b : mBuffer) {             if (b != 0) {                 return false;             }         }         return true;     }      private void checkSharedMemoryContent(Sensor s, int memType, int rateLevel, int token) {         assertTrue(""read mem type "" + memType + "" content failed"", readSharedMemory(memType));          int offset = 0;         int nextSerial = 1;         DirectReportSensorEvent e = getEvent();         while (offset <= SHARED_MEMORY_SIZE - SENSORS_EVENT_SIZE) {             parseSensorEvent(offset, e);              if (e.serial == 0) {                 // reaches end of events                 break;             }              assertTrue(""incorrect size "" + e.size + ""  at offset "" + offset,                     e.size == SENSORS_EVENT_SIZE);             assertTrue(""incorrect token "" + e.token + "" at offset "" + offset,                     e.token == token);             assertTrue(""incorrect serial "" + e.serial + "" at offset "" + offset,                     e.serial == nextSerial);             assertTrue(""incorrect type "" + e.type + "" offset "" + offset,                     e.type == s.getType());              switch(s.getType()) {                 case Sensor.TYPE_ACCELEROMETER:                     double accNorm = Math.sqrt(e.x * e.x + e.y * e.y + e.z * e.z);                     assertTrue(""incorrect gravity norm "" + accNorm + "" at offset "" + offset,                             accNorm < GRAVITY_MAX && accNorm > GRAVITY_MIN);                     break;                 case Sensor.TYPE_GYROSCOPE:                     double gyroNorm = Math.sqrt(e.x * e.x + e.y * e.y + e.z * e.z);                     assertTrue(""gyro norm too large ("" + gyroNorm + "") at offset "" + offset,                             gyroNorm < GYRO_NORM_MAX);                     break;             }              ++nextSerial;             offset += SENSORS_EVENT_SIZE;         }          int nEvents = nextSerial - 1;         float nominalFreq = 0;          switch (rateLevel) {             case SensorDirectChannel.RATE_NORMAL:                 nominalFreq = RATE_NORMAL_NOMINAL;                 break;             case SensorDirectChannel.RATE_FAST:                 nominalFreq = RATE_FAST_NOMINAL;                 break;             case SensorDirectChannel.RATE_VERY_FAST:                 nominalFreq = RATE_VERY_FAST_NOMINAL;                 break;         }          if (nominalFreq != 0) {             int minEvents;             int maxEvents;             minEvents = (int) Math.floor(                     nominalFreq                     * FREQ_LOWER_BOUND                     * (TEST_RUN_TIME_PERIOD_MILLISEC - ALLOWED_SENSOR_INIT_TIME_MILLISEC)                     * (1 - MERCY_FACTOR)                     / 1000);             maxEvents = (int) Math.ceil(                     nominalFreq                     * FREQ_UPPER_BOUND                     * TEST_RUN_TIME_PERIOD_MILLISEC                     * (1 + MERCY_FACTOR)                     / 1000);              assertTrue(""nEvent is "" + nEvents + "" not between "" + minEvents + "" and "" + maxEvents,                     nEvents >= minEvents && nEvents <=maxEvents);         }     }      private void checkEventRate(int testTimeMs, List<DirectReportSensorEvent> events,                                 int type, int rateLevel) {         assertTrue(""insufficient events of type "" + type, events.size() > 1);         for (DirectReportSensorEvent e : events) {             assertTrue(""incorrect type "" + e.type + "" expecting "" + type, e.type == type);         }          // check number of events         int[] minMax = calculateExpectedNEvents(testTimeMs, rateLevel);         assertTrue(                 ""Number of event of type "" + type + "" is "" + events.size()                     + "", which is not in range ["" + minMax[0] + "", "" + minMax[1] + ""]."",                 minMax[0] <= events.size() && events.size() <= minMax[1]);          // intervals         List<Long> intervals = new ArrayList<>(events.size() - 1);         long minInterval = Long.MAX_VALUE;         long maxInterval = Long.MIN_VALUE;         long averageInterval = 0;         for (int i = 1; i < events.size(); ++i) {             long d = events.get(i).ts - events.get(i-1).ts;             averageInterval += d;             minInterval = Math.min(d, minInterval);             maxInterval = Math.max(d, maxInterval);             intervals.add(d);         }         averageInterval /= (events.size() - 1);          // average rate         float averageFreq = 1e9f / averageInterval;         float nominalFreq = getNominalFreq(rateLevel);         Log.d(TAG, String.format(                 ""checkEventRate type %d: averageFreq %f, nominalFreq %f, lbound %f, ubound %f"",                 type, averageFreq, nominalFreq,                 nominalFreq * FREQ_LOWER_BOUND,                 nominalFreq * FREQ_UPPER_BOUND));         assertTrue(""Average frequency of type "" + type + "" rateLevel "" + rateLevel                         + "" is "" + averageFreq,                    nominalFreq * FREQ_LOWER_BOUND * (1 - MERCY_FACTOR) <= averageFreq &&                        averageFreq <= nominalFreq * FREQ_UPPER_BOUND * (1 + MERCY_FACTOR));          // jitter variance         List<Long> percentileValues =                 SensorCtsHelper.getPercentileValue(intervals, 0.025f, (1 - 0.025f));         assertTrue(""Timestamp jitter of type "" + type + "" rateLevel "" + rateLevel + "" is ""                         + (percentileValues.get(1) - percentileValues.get(0) / 1000) + "" us, ""                         + ""while average interval is "" + (averageInterval / 1000) + ""us, over-range"",                    (percentileValues.get(1) - percentileValues.get(0)) / averageInterval < 0.05);         Log.d(TAG, String.format(                 ""checkEventRate type %d, timestamp interval range %f - %f ms, "" +                     ""span %f ms, %.2f%% of averageInterval"",                     type, percentileValues.get(0)/1e6f, percentileValues.get(1)/1e6f,                     (percentileValues.get(1) - percentileValues.get(0))/1e6f,                     (percentileValues.get(1) - percentileValues.get(0)) / averageInterval * 100.f));      }      private void checkEventRateUs(int testTimeMs, List<DirectReportSensorEvent> events,                                   int type, int samplingPeriodUs) {         // samplingPeriodUs must be a valid one advertised by sensor         assertTrue(""insufficient events of type "" + type, events.size() > 1);         for (DirectReportSensorEvent e : events) {             assertTrue(""incorrect type "" + e.type + "" expecting "" + type, e.type == type);         }          // check number of events         int[] minMax = calculateExpectedNEventsUs(testTimeMs, samplingPeriodUs);         assertTrue(                 ""Number of event of type "" + type + "" is "" + events.size()                     + "", which is not in range ["" + minMax[0] + "", "" + minMax[1] + ""]."",                 minMax[0] <= events.size() && events.size() <= minMax[1]);          // intervals         List<Long> intervals = new ArrayList<>(events.size() - 1);         long minInterval = Long.MAX_VALUE;         long maxInterval = Long.MIN_VALUE;         long averageInterval = 0;         for (int i = 1; i < events.size(); ++i) {             long d = events.get(i).ts - events.get(i-1).ts;             averageInterval += d;             minInterval = Math.min(d, minInterval);             maxInterval = Math.max(d, maxInterval);             intervals.add(d);         }         averageInterval /= (events.size() - 1);          // average rate         float averageFreq = 1e9f / averageInterval;         float nominalFreq = 1e6f / samplingPeriodUs;         Log.d(TAG, String.format(                 ""checkEventRateUs type %d: averageFreq %f, nominalFreq %f, lbound %f, ubound %f"",                 type, averageFreq, nominalFreq,                 nominalFreq * FREQ_LOWER_BOUND_POLL,                 nominalFreq * FREQ_UPPER_BOUND_POLL));         assertTrue(""Average frequency of type "" + type                         + "" is "" + averageFreq,                    nominalFreq * FREQ_LOWER_BOUND_POLL * (1 - MERCY_FACTOR) <= averageFreq &&                        averageFreq <= nominalFreq * FREQ_UPPER_BOUND_POLL * (1 + MERCY_FACTOR));          // jitter variance         List<Long> percentileValues =                 SensorCtsHelper.getPercentileValue(intervals, 0.025f, (1 - 0.025f));         assertTrue(""Timestamp jitter of type "" + type + "" is ""                         + (percentileValues.get(1) - percentileValues.get(0) / 1000) + "" us, ""                         + ""while average interval is "" + (averageInterval / 1000) + ""us, over-range"",                    (percentileValues.get(1) - percentileValues.get(0)) / averageInterval < 0.05);         Log.d(TAG, String.format(                 ""checkEventRateUs type %d, timestamp interval range %f - %f ms, "" +                     ""span %f ms, %.2f%% of averageInterval"",                     type, percentileValues.get(0)/1e6f, percentileValues.get(1)/1e6f,                     (percentileValues.get(1) - percentileValues.get(0)) / 1e6f,                     (percentileValues.get(1) - percentileValues.get(0)) / averageInterval * 100.f));     }      private void allocateSharedMemory() {         if (mNeedMemoryFile) {             mMemoryFile = allocateMemoryFile();             mMemoryFileSecondary = allocateMemoryFile();         }          if (mNeedHardwareBuffer) {             mHardwareBuffer = allocateHardwareBuffer();             mHardwareBufferSecondary = allocateHardwareBuffer();         }     }      private void freeSharedMemory() {         if (mMemoryFile != null) {             mMemoryFile.close();             mMemoryFile = null;         }          if (mMemoryFileSecondary != null) {             mMemoryFileSecondary.close();             mMemoryFileSecondary = null;         }          if (mHardwareBuffer != null) {             mHardwareBuffer.close();             mHardwareBuffer = null;         }          if (mHardwareBufferSecondary != null) {             mHardwareBufferSecondary.close();             mHardwareBufferSecondary = null;         }     }      private float getNominalFreq(int rateLevel) {         float nominalFreq = 0;         switch (rateLevel) {             case SensorDirectChannel.RATE_NORMAL:                 nominalFreq = RATE_NORMAL_NOMINAL;                 break;             case SensorDirectChannel.RATE_FAST:                 nominalFreq = RATE_FAST_NOMINAL;                 break;             case SensorDirectChannel.RATE_VERY_FAST:                 nominalFreq = RATE_VERY_FAST_NOMINAL;                 break;         }         return nominalFreq;     }      private int[] calculateExpectedNEvents(int timeMs, int rateLevel) {         int[] minMax = new int[] { -1, Integer.MAX_VALUE };         float nominalFreq = getNominalFreq(rateLevel);         if (nominalFreq != 0) {             // min             if (timeMs > ALLOWED_SENSOR_INIT_TIME_MILLISEC) {                 minMax[0] = (int) Math.floor(                         nominalFreq                         * FREQ_LOWER_BOUND                         * (timeMs - ALLOWED_SENSOR_INIT_TIME_MILLISEC)                         * (1 - MERCY_FACTOR)                         / 1000);             }             // max             minMax[1] = (int) Math.ceil(                     nominalFreq                     * FREQ_UPPER_BOUND                     * timeMs                     * (1 + MERCY_FACTOR)                     / 1000);         }         return minMax;     }      private void checkTimestampAbsolute(List<DirectReportSensorEvent> events) {         final int MAX_DETAIL_ITEM = 10;          StringBuffer buf = new StringBuffer();         int oneMsEarlyCount = 0;         int fiveMsLateCount = 0;         int tenMsLateCount = 0;         int errorCount = 0;          for (int i = 0; i < events.size(); ++i) {             DirectReportSensorEvent e = events.get(i);             long d = e.arrivalTs - e.ts;             boolean oneMsEarly = d < -1000_000;             boolean fiveMsLate = d > 5000_000;             boolean tenMsLate = d > 10_000_000;              if (oneMsEarly || fiveMsLate || tenMsLate) {                 oneMsEarlyCount += oneMsEarly ? 1 : 0;                 fiveMsLateCount += fiveMsLate ? 1 : 0;                 tenMsLateCount += tenMsLate ? 1 : 0;                  if (errorCount++ < MAX_DETAIL_ITEM) {                     buf.append(""["").append(i).append(""] diff = "").append(d / 1e6f).append("" ms; "");                 }             }         }          Log.d(TAG, String.format(""Irregular timestamp, %d, %d, %d out of %d"",                     oneMsEarlyCount, fiveMsLateCount, tenMsLateCount, events.size()));          if (CHECK_ABSOLUTE_LATENCY) {             assertTrue(String.format(                     ""Timestamp error, out of %d events, %d is >1ms early, %d is >5ms late, ""                         + ""%d is >10ms late, details: %s%s"",                         events.size(), oneMsEarlyCount, fiveMsLateCount, tenMsLateCount,                         buf.toString(), errorCount > MAX_DETAIL_ITEM ? ""..."" : """"),                     oneMsEarlyCount == 0                         && fiveMsLateCount <= events.size() / 20                         && tenMsLateCount <= events.size() / 100);         }     }      private void checkTimestampRelative(List<DirectReportSensorEvent> directEvents,                                         List<DirectReportSensorEvent> pollEvents) {         if (directEvents.size() < 10 || pollEvents.size() < 10) {             // cannot check with so few data points             return;         }          long directAverageLatency = 0;         for (DirectReportSensorEvent e : directEvents) {             directAverageLatency += e.arrivalTs - e.ts;         }         directAverageLatency /= directEvents.size();          long pollAverageLatency = 0;         for (DirectReportSensorEvent e : pollEvents) {             pollAverageLatency += e.arrivalTs - e.ts;         }         pollAverageLatency /= pollEvents.size();          Log.d(TAG, String.format(""Direct, poll latency = %f, %f ms"",                 directAverageLatency / 1e6f, pollAverageLatency / 1e6f));         assertTrue(                 String.format(""Direct, poll latency = %f, %f ms, expect direct < poll"",                     directAverageLatency / 1e6f,                     pollAverageLatency / 1e6f),                 directAverageLatency < pollAverageLatency + 1000_000);     }      private int[] calculateExpectedNEventsUs(int timeMs, int samplingPeriodUs) {         int[] minMax = new int[2];         minMax[0] = Math.max((int) Math.floor(                 (timeMs - ALLOWED_SENSOR_INIT_TIME_MILLISEC) * 1000/ samplingPeriodUs), 0);         minMax[1] = (int) Math.ceil(timeMs * 1000 * 2 / samplingPeriodUs);         return minMax;     }      private static class DirectReportSensorEvent {         public int size;         public int token;         public int type;         public long serial;         public long ts;         public float x;         public float y;         public float z;         public long arrivalTs;     };      // EventPool to avoid allocating too many event objects and hitting GC during test     private static class EventPool {         public EventPool(int n) {             mEvents = Arrays.asList(new DirectReportSensorEvent[n]);             for (int i = 0; i < n; ++i) {                 mEvents.set(i, new DirectReportSensorEvent());             }             reset();         }          public synchronized void reset() {             Log.d(TAG, ""Reset EventPool ("" + mIndex + "" events used)"");             mIndex = 0;         }          public synchronized DirectReportSensorEvent get() {             if (mIndex < mEvents.size()) {                 return mEvents.get(mIndex++);             } else {                 throw new IllegalStateException(""EventPool depleted"");             }         }          private List<DirectReportSensorEvent> mEvents;         private int mIndex;     };      private DirectReportSensorEvent getEvent() {         return mEventPool.get();     }      private DirectReportSensorEvent getEvent(DirectReportSensorEvent e) {         DirectReportSensorEvent event = mEventPool.get();         event.size = e.size;         event.token = e.token;         event.type = e.type;         event.serial = e.serial;         event.ts = e.ts;         event.x = e.x;         event.y = e.y;         event.z = e.z;         event.arrivalTs = e.arrivalTs;         return event;     }      private void resetEvent() {         mEventPool.reset();     }      private class SensorEventCollection implements SensorEventListener {         List<DirectReportSensorEvent> mEvents = new ArrayList<>();         Sensor mSensor;          public SensorEventCollection(Sensor s) {             mSensor = s;         }          List<DirectReportSensorEvent> getEvents() {             return mEvents;         }          @Override         public void onSensorChanged(SensorEvent event) {             if (mSensor == null || event.sensor == mSensor) {                 DirectReportSensorEvent e = mEventPool.get();                 e.size = SENSORS_EVENT_SIZE;                 e.token = event.sensor.getType();                 e.type = e.token;                 e.serial = -1;                 e.ts = event.timestamp;                 e.arrivalTs = SystemClock.elapsedRealtimeNanos();                  e.x = event.values[0];                 if (event.values.length > 1) {                     e.y = event.values[1];                 }                 if (event.values.length > 2) {                     e.z = event.values[2];                 }                 mEvents.add(e);             }         }          @Override         public void onAccuracyChanged(Sensor s, int accuracy) {             // do nothing         }     };      private List<DirectReportSensorEvent> parseEntireBuffer(byte[] buffer, int token) {         int offset = 0;         int nextSerial = 1;         List<DirectReportSensorEvent> events = new ArrayList<>();          while (offset <= SHARED_MEMORY_SIZE - SENSORS_EVENT_SIZE) {             DirectReportSensorEvent e = getEvent();             parseSensorEvent(offset, e);              if (e.serial == 0) {                 // reaches end of events                 break;             }              assertTrue(""incorrect size "" + e.size + ""  at offset "" + offset,                     e.size == SENSORS_EVENT_SIZE);             assertTrue(""incorrect serial "" + e.serial + "" at offset "" + offset,                     e.serial == nextSerial);              if (e.token == token) {                 events.add(e);             }              ++nextSerial;             offset += SENSORS_EVENT_SIZE;         }          return events;     }      // parse sensors_event_t from mBuffer and fill information into DirectReportSensorEvent     private void parseSensorEvent(int offset, DirectReportSensorEvent ev) {         mByteBuffer.position(offset);          ev.size = mByteBuffer.getInt();         ev.token = mByteBuffer.getInt();         ev.type = mByteBuffer.getInt();         ev.serial = ((long) mByteBuffer.getInt()) & 0xFFFFFFFFl; // signed=>unsigned         ev.ts = mByteBuffer.getLong();         ev.arrivalTs = SystemClock.elapsedRealtimeNanos();         ev.x = mByteBuffer.getFloat();         ev.y = mByteBuffer.getFloat();         ev.z = mByteBuffer.getFloat();     }      // parse sensors_event_t and fill information into DirectReportSensorEvent     private static void parseSensorEvent(byte [] buf, int offset, DirectReportSensorEvent ev) {         ByteBuffer b = ByteBuffer.wrap(buf, offset, SENSORS_EVENT_SIZE);         b.order(NATIVE_BYTE_ORDER);          ev.size = b.getInt();         ev.token = b.getInt();         ev.type = b.getInt();         ev.serial = ((long) b.getInt()) & 0xFFFFFFFFl; // signed=>unsigned         ev.ts = b.getLong();         ev.arrivalTs = SystemClock.elapsedRealtimeNanos();         ev.x = b.getFloat();         ev.y = b.getFloat();         ev.z = b.getFloat();     }      private long readAtomicCounter(int offset) {         mByteBuffer.position(offset + ATOMIC_COUNTER_OFFSET);         return ((long) mByteBuffer.getInt()) & 0xFFFFFFFFl; // signed => unsigned     }      private static long readAtomicCounter(byte [] buf, int offset) {         ByteBuffer b = ByteBuffer.wrap(buf, offset + ATOMIC_COUNTER_OFFSET, ATOMIC_COUNTER_SIZE);         b.order(ByteOrder.nativeOrder());          return ((long) b.getInt()) & 0xFFFFFFFFl; // signed => unsigned     } }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorParameterRangeTest"	"testPressureRange"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorParameterRangeTest.java"	""	"public void testPressureRange() {         checkSensorRangeAndFrequency(                 Sensor.TYPE_PRESSURE,                 PRESSURE_MAX_RANGE,                 PRESSURE_MAX_FREQUENCY,                 PRESSURE_HIFI_MAX_RANGE,                 PRESSURE_HIFI_MIN_FREQUENCY,                 PRESSURE_HIFI_MAX_FREQUENCY);     }      private void checkSensorRangeAndFrequency(             int sensorType, double maxRange, double maxFrequency, double hifiMaxRange,             double hifiMinFrequency, double hifiMaxFrequency) {         boolean mustMeetHiFi = mHasHifiSensors;          // CDD 7.9.2/C-1-21: High Performance VR must meet accel, gyro, and mag HiFi requirements         if (mVrModeHighPerformance && (sensorType == Sensor.TYPE_ACCELEROMETER ||                 sensorType == Sensor.TYPE_GYROSCOPE || sensorType == Sensor.TYPE_MAGNETIC_FIELD)) {             mustMeetHiFi = true;         }          Sensor sensor = mSensorManager.getDefaultSensor(sensorType);         if (sensor == null) {             if (mustMeetHiFi) {                 fail(String.format(""Must support sensor type %d"", sensorType));             } else {                 // Sensor is not required                 return;             }         }          double range = mustMeetHiFi ? hifiMaxRange : maxRange;         double frequency = mustMeetHiFi ? hifiMaxFrequency : maxFrequency;          assertTrue(String.format(""%s Range actual=%.2f expected=%.2f %s"",                     sensor.getName(), sensor.getMaximumRange(), range,                     SensorCtsHelper.getUnitsForSensor(sensor)),                 sensor.getMaximumRange() >= (range - 0.1));          double actualMaxFrequency = SensorCtsHelper.getFrequency(sensor.getMinDelay(),                 TimeUnit.MICROSECONDS);         assertTrue(String.format(""%s Max Frequency actual=%.2f expected=%.2fHz"",                     sensor.getName(), actualMaxFrequency, frequency), actualMaxFrequency >=                 frequency - 0.1);          if (mustMeetHiFi) {             double actualMinFrequency = SensorCtsHelper.getFrequency(sensor.getMaxDelay(),                     TimeUnit.MICROSECONDS);             assertTrue(String.format(""%s Min Frequency actual=%.2f expected=%.2fHz"",                         sensor.getName(), actualMinFrequency, hifiMinFrequency),                     actualMinFrequency <=  hifiMinFrequency + 0.1);         }     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.SensorParameterRangeTest"	"testStepDetectorFifoLength"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/SensorParameterRangeTest.java"	""	"public void testStepDetectorFifoLength() throws Throwable {         if (!mHasHifiSensors) return;         checkMinFifoLength(Sensor.TYPE_STEP_DETECTOR, STEP_DETECTOR_MIN_FIFO_LENGTH);     }      private void checkMinFifoLength(int sensorType, int minRequiredLength) {         Sensor sensor = mSensorManager.getDefaultSensor(sensorType);         assertTrue(String.format(""sensor of type=%d (null)"", sensorType), sensor != null);         int reservedLength = sensor.getFifoReservedEventCount();         assertTrue(String.format(""Sensor=%s, min required fifo length=%d actual=%d"",                     sensor.getName(), minRequiredLength, reservedLength),                     reservedLength >= minRequiredLength);     }"	""	""	""	""	""
"186:594441) 7.3.13  . Hinge Angle Sensor"	"7.3.13"	"C-1-3"	""	"android.hardware.cts.helpers.sensorverification.EventBasicVerificationTest"	"testVerify"	"CtsSensorTestCases"	""	"7.3.13/C-1-3"	"""C-1-3] MUST return a wakeup sensor for getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE). <h3 id="""	""	"getDefaultSensor SENSOR_TYPE_HINGE_ANGLE wakeup getDefaultSensor(SENSOR_TYPE_HINGE_ANGLE)"	""	""	""	"getDefaultSensor"	""	""	""	"/home/gpoor/cts-source/cts/tests/sensor/src/android/hardware/cts/helpers/sensorverification/EventBasicVerificationTest.java"	""	"public void testVerify() {          /* Sensor contents is not used in this verification, use Object as mock */         SensorManager mgr = (SensorManager) mContext.getSystemService(Context.SENSOR_SERVICE);          Sensor sensor1 = null;          // accelerometer is the most likely sensor to exist         Sensor sensor2 = mgr.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);          SensorStats stats;          EventBasicVerification verification;          // case 1         verification = getVerification(10, sensor1, sensor1, new float[20][3]);         stats = new SensorStats();          verification.verify(stats);         assertEquals(true, stats.getValue(EventBasicVerification.PASSED_KEY));         assertEquals(20, (long) stats.getValue(SensorStats.EVENT_COUNT_KEY));         assertEquals(false, stats.getValue(SensorStats.WRONG_SENSOR_KEY));          // case 2         verification = getVerification(10, sensor1, sensor1, new float[5][3]);         stats = new SensorStats();          try {             verification.verify(stats);             throw new Error(""Expect an AssertionError due to insufficient samples"");         } catch (AssertionError e) {             //Expected         }         assertEquals(false, stats.getValue(EventBasicVerification.PASSED_KEY));         assertEquals(5, (long) stats.getValue(SensorStats.EVENT_COUNT_KEY));         assertEquals(false, stats.getValue(SensorStats.WRONG_SENSOR_KEY));          // case 3         if (sensor1 != sensor2) {             // if we cannot even get a second sensor then do not bother this test.             verification = getVerification(10, sensor1, sensor2, new float[15][3]);             stats = new SensorStats();              try {                 verification.verify(stats);                 throw new Error(""Expect an AssertionError due to wrong sensor event"");             } catch (AssertionError e) {                 //Expected             }             assertEquals(false, stats.getValue(EventBasicVerification.PASSED_KEY));             // zero here because wrong sensor is used.             assertEquals(0, (long) stats.getValue(SensorStats.EVENT_COUNT_KEY));             assertEquals(true, stats.getValue(SensorStats.WRONG_SENSOR_KEY));         }     }      private static EventBasicVerification getVerification(             int expectedMinNumEvent, Sensor sensor, Sensor eventSensor, float[] ... values) {          Collection<TestSensorEvent> events = new ArrayList<>(values.length);         for (float[] value : values) {             events.add(new TestSensorEvent(eventSensor, 0, 0, value));         }         EventBasicVerification verification =                 new EventBasicVerification(expectedMinNumEvent, sensor);         verification.addSensorEvents(events);         return verification;     } }"	""	""	""	""	""
