"Section"	"section_id"	"req_id"	"full_key"	"key_as_number"	"requirement"	"Test Availability"	"search_roots"	"search_terms"	"manual_search_terms"	"not_search_terms"	"not_files"	"max_matches"	"class_defs"	"methods"	"modules"	"protected"	"class_def"	"method"	"module"	"file_name"	"matched_files"	"methods_string"	"urls"	"method_text"	"matched_terms"	"qualified_method"	"Annotation?"	"New Req for S?"	"New CTS for S?"	"Comment(internal) e.g. why a test is not possible"	"CTS Bug Id"	"CDD Bug Id"	"Area"	"Shortened"	"Test Level"
"7.3.2  . Magnetometer"	"7.3.2"	"C-1-10"	"7.3.2/C-1-10"	"07030200.670110"	"""C-1-10] MUST implement the TYPE_MAGNETIC_FIELD_UNCALIBRATED sensor. If device implementations include a 3-axis magnetometer, an accelerometer sensor, and a 3-axis gyroscope sensor, they:"""	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	"android.hardware.cts.SensorBatchingFifoTest"	"testUncalMagnetometerFifoLength"	"CtsSensorTestCases"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/SensorBatchingFifoTest.java"	""	"public void testUncalMagnetometerFifoLength() throws Throwable {
        if (!mHasHifiSensors) return;
        runBatchingSensorFifoTest(
                Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED,
                getReservedFifoLength(Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED));
    }"	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	""	""
"7.3.2  . Magnetometer"	"7.3.2"	"C-1-10"	"7.3.2/C-1-10"	"07030200.670110"	"""C-1-10] MUST implement the TYPE_MAGNETIC_FIELD_UNCALIBRATED sensor. If device implementations include a 3-axis magnetometer, an accelerometer sensor, and a 3-axis gyroscope sensor, they:"""	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	"android.hardware.cts.SensorParameterRangeTest"	"testUncalMagnetometerFifoLength"	"CtsSensorTestCases"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/SensorParameterRangeTest.java"	""	"public void testUncalMagnetometerFifoLength() throws Throwable {
        if (!mHasHifiSensors) return;
        checkMinFifoLength(
                Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED,
                UNCAL_MAGNETOMETER_MIN_FIFO_LENGTH);
    }"	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	""	""
"7.3.2  . Magnetometer"	"7.3.2"	"C-1-10"	"7.3.2/C-1-10"	"07030200.670110"	"""C-1-10] MUST implement the TYPE_MAGNETIC_FIELD_UNCALIBRATED sensor. If device implementations include a 3-axis magnetometer, an accelerometer sensor, and a 3-axis gyroscope sensor, they:"""	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	"android.hardware.cts.helpers.SensorRatePermissionDirectReportTestHelper"	"toList"	"CtsSensorTestCases"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/helpers/SensorRatePermissionDirectReportTestHelper.java"	""	"public void test/*
 *.
 */

package android.hardware.cts.helpers;

import android.content.Context;
import android.hardware.HardwareBuffer;
import android.hardware.Sensor;
import android.hardware.SensorDirectChannel;
import android.hardware.SensorManager;
import android.hardware.SensorPrivacyManager;
import android.hardware.cts.SensorDirectReportTest;

import com.android.compatibility.common.util.ShellUtils;
import com.android.compatibility.common.util.SystemUtil;

import com.google.common.collect.ImmutableSet;

import org.junit.Assert;
import org.junit.Assume;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

/**
 * A helper class to test sampling rates of direct sensor channels.
 */
public class SensorRatePermissionDirectReportTestHelper {
    public static final int CAPPED_SAMPLE_RATE_HZ = 200;
    public static final int CAPPED_DIRECT_REPORT_RATE_LEVEL = SensorDirectChannel.RATE_NORMAL;
    // Set of sensors that are throttled
    public static final ImmutableSet<Integer> CAPPED_SENSOR_TYPE_SET = ImmutableSet.of(
            Sensor.TYPE_ACCELEROMETER,
            Sensor.TYPE_ACCELEROMETER_UNCALIBRATED,
            Sensor.TYPE_GYROSCOPE,
            Sensor.TYPE_GYROSCOPE_UNCALIBRATED,
            Sensor.TYPE_MAGNETIC_FIELD,
            Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED
    );
    public static final int TEST_RUN_TIME_PERIOD_MILLISEC = 1000;
    public static final int SENSORS_EVENT_SIZE = 104;

    static {
        System.loadLibrary(""cts-sensors-ndk-jni"");
    }

    private final SensorManager mSensorManager;

    private Sensor mSensor;

    public SensorRatePermissionDirectReportTestHelper(Context context, int sensorType) {
        mSensorManager = context.getSystemService(SensorManager.class);
        mSensor = null;
        for (Sensor sensor : mSensorManager.getSensorList(sensorType)) {
            if (!CAPPED_SENSOR_TYPE_SET.contains(sensor.getType())) {
                continue;
            }
            if (sensor.isDirectChannelTypeSupported(SensorDirectChannel.TYPE_HARDWARE_BUFFER)) {
                mSensor = sensor;
                break;
            }
        }
        Assume.assumeTrue(""Failed to find a sensor!"", mSensor != null);
    }

    private static native boolean nativeReadHardwareBuffer(HardwareBuffer hardwareBuffer,
            byte[] buffer, int srcOffset, int destOffset, int count);

    public static double computeAvgRate(List<SensorDirectReportTest.DirectReportSensorEvent> events,
            long startTimestamp, long endTimestamp) {

        List<SensorDirectReportTest.DirectReportSensorEvent> filteredEvents = events.stream()
                .filter(event -> event.ts > startTimestamp && event.ts < endTimestamp)
                .collect(Collectors.toList());

        double rate = Double.MIN_VALUE;
        int numOfEvents = filteredEvents.size();
        if (numOfEvents >= 2) {
            long lastTimestamp = filteredEvents.get(numOfEvents - 1).ts;
            long firstTimestamp = filteredEvents.get(0).ts;
            rate = SensorCtsHelper.getFrequency(
                    (lastTimestamp - firstTimestamp) / (numOfEvents - 1),
                    TimeUnit.NANOSECONDS);
        }
        return rate;
    }

    public Sensor getSensor() {
        return mSensor;
    }

    /**
     * Error message being shown in Assert statements of unit tests when the sampling rate exceeds
     * the allowed capped rate.
     */
    public String errorWhenExceedCappedRate() {
        return String.format(
                ""%s: Sampling rate is expected to be less than or equal to %d (Hz)"",
                mSensor.getName(),
                CAPPED_SAMPLE_RATE_HZ);
    }

    /**
     * Error message being shown in Assert statements of unit tests when the sampling rate is below
     * its expected rate.
     */
    public String errorWhenBelowExpectedRate() {
        return String.format(
                ""%s: Sampling rate is expected to larger than to %d (Hz)"",
                mSensor.getName(),
                CAPPED_SAMPLE_RATE_HZ);
    }

    /**
     * Flip the microphone toggle to off and assert that it is indeed off.
     */
    public void flipAndAssertMicToggleOff(int userID, SensorPrivacyManager spm) {
        ShellUtils.runShellCommand(""cmd sensor_privacy disable "" + userID + "" microphone"");
        SystemUtil.runWithShellPermissionIdentity(() -> {
            Assert.assertTrue(""Failed to switch the mic toggle off!"",
                    !spm.isSensorPrivacyEnabled(SensorPrivacyManager.Sensors.MICROPHONE));
        });
    }

    /**
     * Flip the microphone toggle to off and assert that it is indeed on.
     */
    public void flipAndAssertMicToggleOn(int userID, SensorPrivacyManager spm) {
        ShellUtils.runShellCommand(""cmd sensor_privacy enable "" + userID + "" microphone"");
        SystemUtil.runWithShellPermissionIdentity(() -> {
            Assert.assertTrue(""Failed to switch the mic toggle on!"",
                    spm.isSensorPrivacyEnabled(SensorPrivacyManager.Sensors.MICROPHONE));
        });
    }

    /**
     * Configure a direct channel and return the sensor data in a DirectReportSensorEvent list.
     */
    public List<SensorDirectReportTest.DirectReportSensorEvent> getSensorEvents(int rateLevel)
            throws InterruptedException {
        int sensorEventCount = 2000; // 800 Hz * 2.2 * 1s + extra
        int sharedMemorySize = sensorEventCount * SENSORS_EVENT_SIZE;
        HardwareBuffer hardwareBuffer = HardwareBuffer.create(
                sharedMemorySize, 1, HardwareBuffer.BLOB, 1,
                HardwareBuffer.USAGE_CPU_READ_OFTEN | HardwareBuffer.USAGE_GPU_DATA_BUFFER
                        | HardwareBuffer.USAGE_SENSOR_DIRECT_DATA);

        SensorDirectChannel channel = mSensorManager.createDirectChannel(hardwareBuffer);
        int token = channel.configure(mSensor, rateLevel);
        SensorCtsHelper.sleep(TEST_RUN_TIME_PERIOD_MILLISEC, TimeUnit.MILLISECONDS);
        channel.configure(mSensor, SensorDirectChannel.RATE_STOP);
        List<SensorDirectReportTest.DirectReportSensorEvent> events =
                readEventsFromHardwareBuffer(token, hardwareBuffer, sensorEventCount);
        channel.close();
        hardwareBuffer.close();
        return events;
    }

    /**
     * Parse HardwareBuffer to return a list of DirectReportSensorEvents
     */
    public List<SensorDirectReportTest.DirectReportSensorEvent> readEventsFromHardwareBuffer(
            int token, HardwareBuffer hardwareBuffer, int sensorEventCount) {
        int sharedMemorySize = sensorEventCount * SENSORS_EVENT_SIZE;
        SensorDirectReportTest.EventPool eventPool = new SensorDirectReportTest.EventPool(
                10 * sensorEventCount);
        ByteBuffer byteBuffer = ByteBuffer.allocate(sharedMemorySize);
        byte[] buffer = byteBuffer.array();
        byteBuffer.order(ByteOrder.nativeOrder());
        nativeReadHardwareBuffer(hardwareBuffer, buffer, 0, 0, sharedMemorySize);
        List<SensorDirectReportTest.DirectReportSensorEvent> events =
                SensorDirectReportTest.parseEntireBuffer(token, eventPool, byteBuffer,
                        sharedMemorySize);
        eventPool.reset();
        byteBuffer.clear();
        return events;
    }
}"	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	""	""
"7.3.2  . Magnetometer"	"7.3.2"	"C-1-10"	"7.3.2/C-1-10"	"07030200.670110"	"""C-1-10] MUST implement the TYPE_MAGNETIC_FIELD_UNCALIBRATED sensor. If device implementations include a 3-axis magnetometer, an accelerometer sensor, and a 3-axis gyroscope sensor, they:"""	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	"android.hardware.cts.SensorSupportTest"	"testSupportsMagneticFieldUncalibrated"	"CtsSensorTestCases"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/SensorSupportTest.java"	""	"public void testSupportsMagneticFieldUncalibrated() {
        checkHifiVrSensorSupport(Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED);
    }

    @CddTest(requirement=""7.3.9/C-2-7"")"	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	""	""
"7.3.2  . Magnetometer"	"7.3.2"	"C-1-10"	"7.3.2/C-1-10"	"07030200.670110"	"""C-1-10] MUST implement the TYPE_MAGNETIC_FIELD_UNCALIBRATED sensor. If device implementations include a 3-axis magnetometer, an accelerometer sensor, and a 3-axis gyroscope sensor, they:"""	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	"android.hardware.cts.SensorSupportTest"	"testSupportsRotationVectorIfHasAGM"	"CtsSensorTestCases"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/SensorSupportTest.java"	""	"public void testSupportsRotationVectorIfHasAGM() {
        if (mHasAccel && mHasGyro && mHasMag) {
            assertTrue(hasSensorType(Sensor.TYPE_ROTATION_VECTOR));
        }
    }

    private boolean sensorRequiredForVrHighPerformanceMode(int sensorType) {
        if (sensorType == Sensor.TYPE_ACCELEROMETER ||
            sensorType == Sensor.TYPE_ACCELEROMETER_UNCALIBRATED ||
            sensorType == Sensor.TYPE_GYROSCOPE ||
            sensorType == Sensor.TYPE_GYROSCOPE_UNCALIBRATED ||
            sensorType == Sensor.TYPE_MAGNETIC_FIELD ||
            sensorType == Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED) {
            return true;
        } else {
            return false;
        }
    }

    private void checkHifiVrSensorSupport(int sensorType) {
        boolean isVrSensor = mVrHighPerformanceModeSupported &&
            sensorRequiredForVrHighPerformanceMode(sensorType);
        if (mAreHifiSensorsSupported || isVrSensor) {
            Sensor sensor = mSensorManager.getDefaultSensor(sensorType);
            assertTrue(sensor != null);
            if (isVrSensor && mIsVrHeadset) {
                assertTrue(sensor.isDirectChannelTypeSupported(SensorDirectChannel.TYPE_HARDWARE_BUFFER));
            }
        }
    }

    private boolean hasSensorType(int sensorType) {
        return (mSensorManager != null && mSensorManager.getDefaultSensor(sensorType) != null);
    }
}"	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	""	""
"7.3.2  . Magnetometer"	"7.3.2"	"C-1-10"	"7.3.2/C-1-10"	"07030200.670110"	"""C-1-10] MUST implement the TYPE_MAGNETIC_FIELD_UNCALIBRATED sensor. If device implementations include a 3-axis magnetometer, an accelerometer sensor, and a 3-axis gyroscope sensor, they:"""	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	"android.hardware.cts.SensorBatchingTests"	"testMagneticFieldUncalibrated_fastest_batching"	"CtsSensorTestCases"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/SensorBatchingTests.java"	""	"public void testMagneticFieldUncalibrated_fastest_batching() throws Throwable {
        runBatchingSensorTest(Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED, RATE_FASTEST, BATCHING_PERIOD);
    }"	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	""	""
"7.3.2  . Magnetometer"	"7.3.2"	"C-1-10"	"7.3.2/C-1-10"	"07030200.670110"	"""C-1-10] MUST implement the TYPE_MAGNETIC_FIELD_UNCALIBRATED sensor. If device implementations include a 3-axis magnetometer, an accelerometer sensor, and a 3-axis gyroscope sensor, they:"""	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	"android.hardware.cts.SensorBatchingTests"	"testMagneticFieldUncalibrated_50hz_batching"	"CtsSensorTestCases"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/SensorBatchingTests.java"	""	"public void testMagneticFieldUncalibrated_50hz_batching() throws Throwable {
        runBatchingSensorTest(Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED, RATE_50HZ, BATCHING_PERIOD);
    }"	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	""	""
"7.3.2  . Magnetometer"	"7.3.2"	"C-1-10"	"7.3.2/C-1-10"	"07030200.670110"	"""C-1-10] MUST implement the TYPE_MAGNETIC_FIELD_UNCALIBRATED sensor. If device implementations include a 3-axis magnetometer, an accelerometer sensor, and a 3-axis gyroscope sensor, they:"""	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	"android.hardware.cts.SensorBatchingTests"	"testMagneticFieldUncalibrated_fastest_flush"	"CtsSensorTestCases"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/SensorBatchingTests.java"	""	"public void testMagneticFieldUncalibrated_fastest_flush() throws Throwable {
        runFlushSensorTest(Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED, RATE_FASTEST, BATCHING_PERIOD);
    }"	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	""	""
"7.3.2  . Magnetometer"	"7.3.2"	"C-1-10"	"7.3.2/C-1-10"	"07030200.670110"	"""C-1-10] MUST implement the TYPE_MAGNETIC_FIELD_UNCALIBRATED sensor. If device implementations include a 3-axis magnetometer, an accelerometer sensor, and a 3-axis gyroscope sensor, they:"""	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	"android.hardware.cts.SensorBatchingTests"	"testMagneticFieldUncalibrated_50hz_flush"	"CtsSensorTestCases"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/SensorBatchingTests.java"	""	"public void testMagneticFieldUncalibrated_50hz_flush() throws Throwable {
        runFlushSensorTest(Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED, RATE_50HZ, BATCHING_PERIOD);
    }"	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	""	""
"7.3.2  . Magnetometer"	"7.3.2"	"C-1-10"	"7.3.2/C-1-10"	"07030200.670110"	"""C-1-10] MUST implement the TYPE_MAGNETIC_FIELD_UNCALIBRATED sensor. If device implementations include a 3-axis magnetometer, an accelerometer sensor, and a 3-axis gyroscope sensor, they:"""	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	"android.hardware.cts.helpers.SensorRatePermissionEventConnectionTestHelper"	"toList"	"CtsSensorTestCases"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/helpers/SensorRatePermissionEventConnectionTestHelper.java"	""	"public void test/*
 *.
 */

package android.hardware.cts.helpers;

import android.hardware.Sensor;
import android.hardware.SensorPrivacyManager;
import android.os.Handler;

import com.android.compatibility.common.util.ShellUtils;
import com.android.compatibility.common.util.SystemUtil;

import com.google.common.collect.ImmutableSet;

import org.junit.Assert;

import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

/**
 * A helper class to test sensor APIs related to sampling rates of SensorEventConnections.
 */
public class SensorRatePermissionEventConnectionTestHelper {
    public static final int CAPPED_SAMPLE_RATE_HZ = 220; // Capped rate 200 Hz + 10% headroom
    // Set of sensors that are throttled
    public static final ImmutableSet<Integer> CAPPED_SENSOR_TYPE_SET = ImmutableSet.of(
            Sensor.TYPE_ACCELEROMETER,
            Sensor.TYPE_ACCELEROMETER_UNCALIBRATED,
            Sensor.TYPE_GYROSCOPE,
            Sensor.TYPE_GYROSCOPE_UNCALIBRATED,
            Sensor.TYPE_MAGNETIC_FIELD,
            Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED
    );

    private final TestSensorEnvironment mTestSensorEnvironment;
    private final TestSensorManager mTestSensorManager;

    public SensorRatePermissionEventConnectionTestHelper(TestSensorEnvironment environment) {
        mTestSensorEnvironment = environment;
        mTestSensorManager = new TestSensorManager(mTestSensorEnvironment);
    }

    public static double computeAvgRate(List<TestSensorEvent> events,
            long startTimestamp, long endTimestamp) {

        List<TestSensorEvent> filteredEvents = events.stream()
                .filter(event -> event.timestamp > startTimestamp && event.timestamp < endTimestamp)
                .collect(Collectors.toList());

        double rate = Double.MIN_VALUE;
        int numOfEvents = filteredEvents.size();
        if (numOfEvents >= 2) {
            long lastTimestamp = filteredEvents.get(numOfEvents - 1).timestamp;
            long firstTimestamp = filteredEvents.get(0).timestamp;
            rate = SensorCtsHelper.getFrequency(
                    (lastTimestamp - firstTimestamp) / (numOfEvents - 1),
                    TimeUnit.NANOSECONDS);
        }
        return rate;
    }

    /**
     * Error message being shown in Assert statements of unit tests when the sampling rate exceeds
     * the allowed capped rate.
     */
    public String errorWhenExceedCappedRate() {
        Sensor sensor = mTestSensorEnvironment.getSensor();
        return String.format(
                ""%s: Sampling rate is expected to be less than or equal to %d (Hz)"",
                sensor.getName(),
                CAPPED_SAMPLE_RATE_HZ);
    }

    /**
     * Error message being shown in Assert statements of unit tests when the sampling rate is below
     * its expected rate.
     */
    public String errorWhenBelowExpectedRate() {
        Sensor sensor = mTestSensorEnvironment.getSensor();
        return String.format(
                ""%s: Sampling rate is expected to larger than to %d (Hz)"",
                sensor.getName(),
                CAPPED_SAMPLE_RATE_HZ);
    }

    /**
     * Flip the microphone toggle to off and assert that it is indeed off.
     */
    public void flipAndAssertMicToggleOff(int userID, SensorPrivacyManager spm) {
        ShellUtils.runShellCommand(""cmd sensor_privacy disable "" + userID + "" microphone"");
        SystemUtil.runWithShellPermissionIdentity(() -> {
            Assert.assertTrue(""Failed to switch the mic toggle off!"",
                    !spm.isSensorPrivacyEnabled(SensorPrivacyManager.Sensors.MICROPHONE));
        });
    }

    /**
     * Flip the microphone toggle to off and assert that it is indeed on.
     */
    public void flipAndAssertMicToggleOn(int userID, SensorPrivacyManager spm) {
        ShellUtils.runShellCommand(""cmd sensor_privacy enable "" + userID + "" microphone"");
        SystemUtil.runWithShellPermissionIdentity(() -> {
            Assert.assertTrue(""Failed to switch the mic toggle on!"",
                    spm.isSensorPrivacyEnabled(SensorPrivacyManager.Sensors.MICROPHONE));
        });
    }

    /**
     * Register a listener and waits until there are numOfEvents events
     *
     * @param specifyHandler true if a {@link Handler} is associated with the instance.
     */
    public List<TestSensorEvent> getSensorEvents(boolean specifyHandler, int numOfEvents)
            throws InterruptedException {
        TestSensorEventListener listener = new TestSensorEventListener(mTestSensorEnvironment);
        CountDownLatch eventLatch = mTestSensorManager.registerListener(
                listener,
                numOfEvents,
                specifyHandler);
        listener.waitForEvents(eventLatch, numOfEvents, false);
        List<TestSensorEvent> testSensorEventList = listener.getCollectedEvents();
        listener.clearEvents();
        mTestSensorManager.unregisterListener();
        return testSensorEventList;
    }
}"	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	""	""
"7.3.2  . Magnetometer"	"7.3.2"	"C-1-10"	"7.3.2/C-1-10"	"07030200.670110"	"""C-1-10] MUST implement the TYPE_MAGNETIC_FIELD_UNCALIBRATED sensor. If device implementations include a 3-axis magnetometer, an accelerometer sensor, and a 3-axis gyroscope sensor, they:"""	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	"android.hardware.cts.SingleSensorTests"	"testMagneticFieldUncalibrated_fastest"	"CtsSensorTestCases"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/SingleSensorTests.java"	""	"public void testMagneticFieldUncalibrated_fastest() throws Throwable {
        runSensorTest(Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED, SensorManager.SENSOR_DELAY_FASTEST);
    }"	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	""	""
"7.3.2  . Magnetometer"	"7.3.2"	"C-1-10"	"7.3.2/C-1-10"	"07030200.670110"	"""C-1-10] MUST implement the TYPE_MAGNETIC_FIELD_UNCALIBRATED sensor. If device implementations include a 3-axis magnetometer, an accelerometer sensor, and a 3-axis gyroscope sensor, they:"""	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	"android.hardware.cts.SingleSensorTests"	"testMagneticFieldUncalibrated_200hz"	"CtsSensorTestCases"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/SingleSensorTests.java"	""	"public void testMagneticFieldUncalibrated_200hz() throws Throwable {
        runSensorTest(Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED, RATE_200HZ);
    }"	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	""	""
"7.3.2  . Magnetometer"	"7.3.2"	"C-1-10"	"7.3.2/C-1-10"	"07030200.670110"	"""C-1-10] MUST implement the TYPE_MAGNETIC_FIELD_UNCALIBRATED sensor. If device implementations include a 3-axis magnetometer, an accelerometer sensor, and a 3-axis gyroscope sensor, they:"""	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	"android.hardware.cts.SingleSensorTests"	"testMagneticFieldUncalibrated_100hz"	"CtsSensorTestCases"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/SingleSensorTests.java"	""	"public void testMagneticFieldUncalibrated_100hz() throws Throwable {
        runSensorTest(Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED, RATE_100HZ);
    }"	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	""	""
"7.3.2  . Magnetometer"	"7.3.2"	"C-1-10"	"7.3.2/C-1-10"	"07030200.670110"	"""C-1-10] MUST implement the TYPE_MAGNETIC_FIELD_UNCALIBRATED sensor. If device implementations include a 3-axis magnetometer, an accelerometer sensor, and a 3-axis gyroscope sensor, they:"""	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	"android.hardware.cts.SingleSensorTests"	"testMagneticFieldUncalibrated_50hz"	"CtsSensorTestCases"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/SingleSensorTests.java"	""	"public void testMagneticFieldUncalibrated_50hz() throws Throwable {
        runSensorTest(Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED, RATE_50HZ);
    }"	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	""	""
"7.3.2  . Magnetometer"	"7.3.2"	"C-1-10"	"7.3.2/C-1-10"	"07030200.670110"	"""C-1-10] MUST implement the TYPE_MAGNETIC_FIELD_UNCALIBRATED sensor. If device implementations include a 3-axis magnetometer, an accelerometer sensor, and a 3-axis gyroscope sensor, they:"""	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	"android.hardware.cts.SingleSensorTests"	"testMagneticFieldUncalibrated_25hz"	"CtsSensorTestCases"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/SingleSensorTests.java"	""	"public void testMagneticFieldUncalibrated_25hz() throws Throwable {
        runSensorTest(Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED, RATE_25HZ);
    }"	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	""	""
"7.3.2  . Magnetometer"	"7.3.2"	"C-1-10"	"7.3.2/C-1-10"	"07030200.670110"	"""C-1-10] MUST implement the TYPE_MAGNETIC_FIELD_UNCALIBRATED sensor. If device implementations include a 3-axis magnetometer, an accelerometer sensor, and a 3-axis gyroscope sensor, they:"""	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	"android.hardware.cts.SingleSensorTests"	"testMagneticFieldUncalibrated_15hz"	"CtsSensorTestCases"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/SingleSensorTests.java"	""	"public void testMagneticFieldUncalibrated_15hz() throws Throwable {
        runSensorTest(Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED, RATE_15HZ);
    }"	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	""	""
"7.3.2  . Magnetometer"	"7.3.2"	"C-1-10"	"7.3.2/C-1-10"	"07030200.670110"	"""C-1-10] MUST implement the TYPE_MAGNETIC_FIELD_UNCALIBRATED sensor. If device implementations include a 3-axis magnetometer, an accelerometer sensor, and a 3-axis gyroscope sensor, they:"""	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	"android.hardware.cts.SingleSensorTests"	"testMagneticFieldUncalibrated_10hz"	"CtsSensorTestCases"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/SingleSensorTests.java"	""	"public void testMagneticFieldUncalibrated_10hz() throws Throwable {
        runSensorTest(Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED, RATE_10HZ);
    }"	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	""	""
"7.3.2  . Magnetometer"	"7.3.2"	"C-1-10"	"7.3.2/C-1-10"	"07030200.670110"	"""C-1-10] MUST implement the TYPE_MAGNETIC_FIELD_UNCALIBRATED sensor. If device implementations include a 3-axis magnetometer, an accelerometer sensor, and a 3-axis gyroscope sensor, they:"""	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	"android.hardware.cts.SingleSensorTests"	"testMagneticFieldUncalibrated_5hz"	"CtsSensorTestCases"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/SingleSensorTests.java"	""	"public void testMagneticFieldUncalibrated_5hz() throws Throwable {
        runSensorTest(Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED, RATE_5HZ);
    }"	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	""	""
"7.3.2  . Magnetometer"	"7.3.2"	"C-1-10"	"7.3.2/C-1-10"	"07030200.670110"	"""C-1-10] MUST implement the TYPE_MAGNETIC_FIELD_UNCALIBRATED sensor. If device implementations include a 3-axis magnetometer, an accelerometer sensor, and a 3-axis gyroscope sensor, they:"""	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	"android.hardware.cts.SingleSensorTests"	"testMagneticFieldUncalibrated_1hz"	"CtsSensorTestCases"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/SingleSensorTests.java"	""	"public void testMagneticFieldUncalibrated_1hz() throws Throwable {
        runSensorTest(Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED, RATE_1HZ);
    }"	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	""	""
"7.3.2  . Magnetometer"	"7.3.2"	"C-1-10"	"7.3.2/C-1-10"	"07030200.670110"	"""C-1-10] MUST implement the TYPE_MAGNETIC_FIELD_UNCALIBRATED sensor. If device implementations include a 3-axis magnetometer, an accelerometer sensor, and a 3-axis gyroscope sensor, they:"""	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.sensors.MagneticFieldMeasurementTestActivity"	"MagneticFieldMeasurementTestActivity"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/sensors/MagneticFieldMeasurementTestActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.sensors;

import android.content.Context;
import android.hardware.GeomagneticField;
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorManager;
import android.hardware.cts.helpers.SensorCalibratedUncalibratedVerifier;
import android.hardware.cts.helpers.SensorCtsHelper;
import android.hardware.cts.helpers.TestSensorEnvironment;
import android.hardware.cts.helpers.TestSensorEventListener;
import android.hardware.cts.helpers.TestSensorManager;
import android.hardware.cts.helpers.sensoroperations.TestSensorOperation;
import android.hardware.cts.helpers.sensorverification.MagnitudeVerification;
import android.hardware.cts.helpers.sensorverification.OffsetVerification;
import android.hardware.cts.helpers.sensorverification.StandardDeviationVerification;
import android.location.Location;
import android.location.LocationManager;

import com.android.cts.verifier.R;
import com.android.cts.verifier.sensors.base.SensorCtsVerifierTestActivity;
import com.android.cts.verifier.sensors.helpers.SensorFeaturesDeactivator;

import java.util.List;

/**
 * Semi-automated test that focuses characteristics associated with Accelerometer measurements.
 * These test cases require calibration of the sensor before performing the verifications.
 * Also, it is recommended to execute these tests outdoors, or at least far from magnetic
 * disturbances.
 */
public class MagneticFieldMeasurementTestActivity extends SensorCtsVerifierTestActivity {
    private static final float THRESHOLD_CALIBRATED_UNCALIBRATED_UT = 3f;
    private static final float NANOTESLA_TO_MICROTESLA = 1.0f / 1000;
    private static final int LOCATION_TRIES = 2;

    public MagneticFieldMeasurementTestActivity() {
        super(MagneticFieldMeasurementTestActivity.class);
    }

    @Override
    public void activitySetUp() throws InterruptedException {
        SensorFeaturesDeactivator sensorFeaturesDeactivator = new SensorFeaturesDeactivator(this);
        sensorFeaturesDeactivator.requestToSetLocationMode(true /* state */);
        calibrateMagnetometer();
    }

    /**
     * This test verifies that the Norm of the sensor data is close to the expected reference value.
     * The units of the reference value are dependent on the type of sensor.
     * This test is used to verify that the data reported by the sensor is close to the expected
     * range and scale.
     *
     * The test takes a sample from the sensor under test and calculates the Euclidean Norm of the
     * vector represented by the sampled data. It then compares it against the test expectations
     * that are represented by a reference value and a threshold.
     *
     * The test is susceptible to errors when the Sensor under test is uncalibrated, or the units in
     * which the data are reported and the expectations are set are different.
     *
     * The assertion associated with the test provides the required data needed to identify any
     * possible issue. It provides:
     * - the thread id on which the failure occurred
     * - the sensor type and sensor handle that caused the failure
     * - the values representing the expectation of the test
     * - the values sampled from the sensor
     */
    @SuppressWarnings(""unused"")
    public String testNorm() throws Throwable {
        getTestLogger().logMessage(R.string.snsr_mag_verify_norm);

        TestSensorEnvironment environment = new TestSensorEnvironment(
                getApplicationContext(),
                Sensor.TYPE_MAGNETIC_FIELD,
                SensorManager.SENSOR_DELAY_FASTEST);
        TestSensorOperation verifyNorm =
                TestSensorOperation.createOperation(environment, 100 /* event count */);

        float expectedMagneticFieldEarth;
        float magneticFieldEarthThreshold = (SensorManager.MAGNETIC_FIELD_EARTH_MAX
                - SensorManager.MAGNETIC_FIELD_EARTH_MIN) / 2;

        Location location = null;
        LocationManager lm = (LocationManager) getApplicationContext().getSystemService(
                Context.LOCATION_SERVICE);

        int tries = LOCATION_TRIES;
        while (lm != null && location == null && tries > 0)  {
            tries--;
            List<String> providers = lm.getProviders(true /* enabledOnly */);
            int providerIndex = providers.size();
            while (providerIndex > 0 && location == null) {
                providerIndex--;
                location = lm.getLastKnownLocation(providers.get(providerIndex));
            }
            if (location == null) {
                getTestLogger().logMessage(R.string.snsr_mag_move_outside);
                waitForUserToContinue();
            }
        }

        if (location == null) {
            expectedMagneticFieldEarth = (SensorManager.MAGNETIC_FIELD_EARTH_MAX
                    + SensorManager.MAGNETIC_FIELD_EARTH_MIN) / 2;
            getTestLogger().logMessage(R.string.snsr_mag_no_location, expectedMagneticFieldEarth);
            waitForUserToContinue();
        } else {
            GeomagneticField geomagneticField = new GeomagneticField((float) location.getLatitude(),
                    (float) location.getLongitude(), (float) location.getAltitude(),
                    location.getTime());
            expectedMagneticFieldEarth =
                    geomagneticField.getFieldStrength() * NANOTESLA_TO_MICROTESLA;
        }

        verifyNorm.addVerification(new MagnitudeVerification(
                expectedMagneticFieldEarth,
                magneticFieldEarthThreshold));
        verifyNorm.execute(getCurrentTestNode());
        return null;
    }

    /**
     * This test verifies that the norm of the sensor offset is less than the reference value.
     * The units of the reference value are dependent on the type of sensor.
     *
     * The test takes a sample from the sensor under test and calculates the Euclidean Norm of the
     * offset represented by the sampled data. It then compares it against the test expectations
     * that are represented by a reference value.
     *
     * The assertion associated with the test provides the required data needed to identify any
     * possible issue. It provides:
     * - the thread id on which the failure occurred
     * - the sensor type and sensor handle that caused the failure
     * - the values representing the expectation of the test
     * - the values sampled from the sensor
     */
    @SuppressWarnings(""unused"")
    public String testOffset() throws Throwable {
        getTestLogger().logMessage(R.string.snsr_mag_verify_offset);

        TestSensorEnvironment environment = new TestSensorEnvironment(
                getApplicationContext(),
                Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED,
                SensorManager.SENSOR_DELAY_FASTEST);
        TestSensorOperation verifyOffset =
                TestSensorOperation.createOperation(environment, 100 /* event count */);

        verifyOffset.addVerification(OffsetVerification.getDefault(environment));
        verifyOffset.execute(getCurrentTestNode());
        return null;
    }

    /**
     * This test verifies that the standard deviation of a set of sampled data from a particular
     * sensor falls into the expectations defined in the CDD. The verification applies to each axis
     * of the sampled data reported by the Sensor under test.
     * This test is used to validate the requirement imposed by the CDD to Sensors in Android. And
     * characterizes how the Sensor behaves while static.
     *
     * The test takes a set of samples from the sensor under test, and calculates the Standard
     * Deviation for each of the axes the Sensor reports data for. The StdDev is compared against
     * the expected value documented in the CDD.
     *
     * The test is susceptible to errors if the device is moving while the test is running, or if
     * the Sensor's sampled data indeed falls into a large StdDev.
     *
     * The assertion associated with the test provides the required data to identify any possible
     * issue. It provides:
     * - the thread id on which the failure occurred
     * - the sensor type and sensor handle that caused the failure
     * - the expectation of the test
     * - the std dev calculated and the axis it applies to
     * Additionally, the device's debug output (adb logcat) dumps the set of values associated with
     * the failure to help track down the issue.
     */
    @SuppressWarnings(""unused"")
    public String testStandardDeviation() throws Throwable {
        getTestLogger().logMessage(R.string.snsr_mag_verify_std_dev);

        TestSensorEnvironment environment = new TestSensorEnvironment(
                getApplicationContext(),
                Sensor.TYPE_MAGNETIC_FIELD,
                SensorManager.SENSOR_DELAY_FASTEST);
        TestSensorOperation verifyStdDev =
                TestSensorOperation.createOperation(environment, 100 /* event count */);

        verifyStdDev.addVerification(new StandardDeviationVerification(
                new float[]{2f, 2f, 2f} /* uT */));
        verifyStdDev.execute(getCurrentTestNode());
        return null;
    }

    /**
     * Verifies that the relationship between readings from calibrated and their corresponding
     * uncalibrated sensors comply to the following equation:
     *      calibrated = uncalibrated - bias
     */
    @SuppressWarnings(""unused"")
    public String testCalibratedAndUncalibrated() throws Throwable {
        getTestLogger().logMessage(R.string.snsr_mag_verify_calibrated_uncalibrated);

        TestSensorEnvironment calibratedEnvironment = new TestSensorEnvironment(
                getApplicationContext(),
                Sensor.TYPE_MAGNETIC_FIELD,
                SensorManager.SENSOR_DELAY_FASTEST);
        TestSensorEnvironment uncalibratedEnvironment = new TestSensorEnvironment(
                getApplicationContext(),
                Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED,
                SensorManager.SENSOR_DELAY_FASTEST);
        SensorCalibratedUncalibratedVerifier verifier = new SensorCalibratedUncalibratedVerifier(
                calibratedEnvironment,
                uncalibratedEnvironment,
                THRESHOLD_CALIBRATED_UNCALIBRATED_UT);

        try {
            verifier.execute();
        } finally {
            playSound();
        }
        return null;
    }

    /**
     * A routine to help operators calibrate the magnetometer.
     */
    private void calibrateMagnetometer() throws InterruptedException {
        TestSensorEnvironment environment = new TestSensorEnvironment(
                getApplicationContext(),
                Sensor.TYPE_MAGNETIC_FIELD,
                SensorManager.SENSOR_DELAY_NORMAL);

        SensorTestLogger logger = getTestLogger();
        logger.logInstructions(R.string.snsr_mag_calibration_description);
        logger.logInstructions(R.string.snsr_mag_calibration_complete);
        waitForUserToContinue();

        TestSensorEventListener listener = new TestSensorEventListener(environment) {
            @Override
            public void onSensorChanged(SensorEvent event) {
                clearText();

                float values[] = event.values;
                logger.logMessage(
                        R.string.snsr_mag_measurement,
                        values[0],
                        values[1],
                        values[2],
                        SensorCtsHelper.getMagnitude(values));
            }
        };

        TestSensorManager magnetometer = new TestSensorManager(environment);
        try {
            magnetometer.registerListener(listener);
            waitForUserToContinue();
        } finally {
            magnetometer.unregisterListener();
        }
    }
}"	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	""	""
"7.3.2  . Magnetometer"	"7.3.2"	"C-1-10"	"7.3.2/C-1-10"	"07030200.670110"	"""C-1-10] MUST implement the TYPE_MAGNETIC_FIELD_UNCALIBRATED sensor. If device implementations include a 3-axis magnetometer, an accelerometer sensor, and a 3-axis gyroscope sensor, they:"""	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	"android.hardware.cts.helpers.SensorCtsHelper"	"getSensorTestDataDirectory"	"CtsSensorTestCases"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/helpers/SensorCtsHelper.java"	""	"public void test/*
 *.
 */
package android.hardware.cts.helpers;

import android.hardware.Sensor;
import android.os.Environment;
import android.os.Process;
import android.util.Log;

import androidx.test.InstrumentationRegistry;

import com.android.compatibility.common.util.SystemUtil;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * Set of static helper methods for CTS tests.
 */
//TODO: Refactor this class into several more well defined helper classes, look at StatisticsUtils
public class SensorCtsHelper {

    private static final long NANOS_PER_MILLI = 1000000;

    /**
     * Private constructor for static class.
     */
    private SensorCtsHelper() {}

    /**
     * Get low and high percentiles values of an array
     *
     * @param lowPercentile Lower boundary percentile, range [0, 1]
     * @param highPercentile Higher boundary percentile, range [0, 1]
     *
     * @throws IllegalArgumentException if the collection or percentiles is null or empty.
     */
    public static <TValue extends Comparable<? super TValue>> List<TValue> getPercentileValue(
            Collection<TValue> collection, float lowPecentile, float highPercentile) {
        validateCollection(collection);
        if (lowPecentile > highPercentile || lowPecentile < 0 || highPercentile > 1) {
            throw new IllegalStateException(""percentile has to be in range [0, 1], and "" +
                    ""lowPecentile has to be less than or equal to highPercentile"");
        }

        List<TValue> arrayCopy = new ArrayList<TValue>(collection);
        Collections.sort(arrayCopy);

        List<TValue> percentileValues = new ArrayList<TValue>();
        // lower percentile: rounding upwards, index range 1 .. size - 1 for percentile > 0
        // for percentile == 0, index will be 0.
        int lowArrayIndex = Math.min(arrayCopy.size() - 1,
                arrayCopy.size() - (int)(arrayCopy.size() * (1 - lowPecentile)));
        percentileValues.add(arrayCopy.get(lowArrayIndex));

        // upper percentile: rounding downwards, index range 0 .. size - 2 for percentile < 1
        // for percentile == 1, index will be size - 1.
        // Also, lower bound by lowerArrayIndex to avoid low percentile value being higher than
        // high percentile value.
        int highArrayIndex = Math.max(lowArrayIndex, (int)(arrayCopy.size() * highPercentile - 1));
        percentileValues.add(arrayCopy.get(highArrayIndex));
        return percentileValues;
    }

    /**
     * Calculate the mean of a collection.
     *
     * @throws IllegalArgumentException if the collection is null or empty
     */
    public static <TValue extends Number> double getMean(Collection<TValue> collection) {
        validateCollection(collection);

        double sum = 0.0;
        for(TValue value : collection) {
            sum += value.doubleValue();
        }
        return sum / collection.size();
    }

    /**
     * Calculate the bias-corrected sample variance of a collection.
     *
     * @throws IllegalArgumentException if the collection is null or empty
     */
    public static <TValue extends Number> double getVariance(Collection<TValue> collection) {
        validateCollection(collection);

        double mean = getMean(collection);
        ArrayList<Double> squaredDiffs = new ArrayList<Double>();
        for(TValue value : collection) {
            double difference = mean - value.doubleValue();
            squaredDiffs.add(Math.pow(difference, 2));
        }

        double sum = 0.0;
        for (Double value : squaredDiffs) {
            sum += value;
        }
        return sum / (squaredDiffs.size() - 1);
    }

    /**
     * @return The (measured) sampling rate of a collection of {@link TestSensorEvent}.
     */
    public static long getSamplingPeriodNs(List<TestSensorEvent> collection) {
        int collectionSize = collection.size();
        if (collectionSize < 2) {
            return 0;
        }
        TestSensorEvent firstEvent = collection.get(0);
        TestSensorEvent lastEvent = collection.get(collectionSize - 1);
        return (lastEvent.timestamp - firstEvent.timestamp) / (collectionSize - 1);
    }

    /**
     * Calculate the bias-corrected standard deviation of a collection.
     *
     * @throws IllegalArgumentException if the collection is null or empty
     */
    public static <TValue extends Number> double getStandardDeviation(
            Collection<TValue> collection) {
        return Math.sqrt(getVariance(collection));
    }

    /**
     * Convert a period to frequency in Hz.
     */
    public static <TValue extends Number> double getFrequency(TValue period, TimeUnit unit) {
        return 1000000000 / (TimeUnit.NANOSECONDS.convert(1, unit) * period.doubleValue());
    }

    /**
     * Convert a frequency in Hz into a period.
     */
    public static <TValue extends Number> double getPeriod(TValue frequency, TimeUnit unit) {
        return 1000000000 / (TimeUnit.NANOSECONDS.convert(1, unit) * frequency.doubleValue());
    }

    /**
     * If value lies outside the boundary limit, then return the nearer bound value.
     * Otherwise, return the value unchanged.
     */
    public static <TValue extends Number> double clamp(TValue val, TValue min, TValue max) {
        return Math.min(max.doubleValue(), Math.max(min.doubleValue(), val.doubleValue()));
    }

    /**
     * @return The magnitude (norm) represented by the given array of values.
     */
    public static double getMagnitude(float[] values) {
        float sumOfSquares = 0.0f;
        for (float value : values) {
            sumOfSquares += value * value;
        }
        double magnitude = Math.sqrt(sumOfSquares);
        return magnitude;
    }

    /**
     * Helper method to sleep for a given duration.
     */
    public static void sleep(long duration, TimeUnit timeUnit) throws InterruptedException {
        long durationNs = TimeUnit.NANOSECONDS.convert(duration, timeUnit);
        Thread.sleep(durationNs / NANOS_PER_MILLI, (int) (durationNs % NANOS_PER_MILLI));
    }

    /**
     * Format an assertion message.
     *
     * @param label the verification name
     * @param environment the environment of the test
     *
     * @return The formatted string
     */
    public static String formatAssertionMessage(String label, TestSensorEnvironment environment) {
        return formatAssertionMessage(label, environment, ""Failed"");
    }

    /**
     * Format an assertion message with a custom message.
     *
     * @param label the verification name
     * @param environment the environment of the test
     * @param format the additional format string
     * @param params the additional format params
     *
     * @return The formatted string
     */
    public static String formatAssertionMessage(
            String label,
            TestSensorEnvironment environment,
            String format,
            Object ... params) {
        return formatAssertionMessage(label, environment, String.format(format, params));
    }

    /**
     * Format an assertion message.
     *
     * @param label the verification name
     * @param environment the environment of the test
     * @param extras the additional information for the assertion
     *
     * @return The formatted string
     */
    public static String formatAssertionMessage(
            String label,
            TestSensorEnvironment environment,
            String extras) {
        return String.format(
                ""%s | sensor='%s', samplingPeriod=%dus, maxReportLatency=%dus | %s"",
                label,
                environment.getSensor().getName(),
                environment.getRequestedSamplingPeriodUs(),
                environment.getMaxReportLatencyUs(),
                extras);
    }

    /**
     * Format an array of floats.
     *
     * @param array the array of floats
     *
     * @return The formatted string
     */
    public static String formatFloatArray(float[] array) {
        StringBuilder sb = new StringBuilder();
        if (array.length > 1) {
            sb.append(""("");
        }
        for (int i = 0; i < array.length; i++) {
            sb.append(String.format(""%.2f"", array[i]));
            if (i != array.length - 1) {
                sb.append("", "");
            }
        }
        if (array.length > 1) {
            sb.append("")"");
        }
        return sb.toString();
    }

    /**
     * @return A {@link File} representing a root directory to store sensor tests data.
     */
    public static File getSensorTestDataDirectory() throws IOException {
        File dataDirectory = new File(Environment.getExternalStorageDirectory(), ""sensorTests/"");
        return createDirectoryStructure(dataDirectory);
    }

    /**
     * Creates the directory structure for the given sensor test data sub-directory.
     *
     * @param subdirectory The sub-directory's name.
     */
    public static File getSensorTestDataDirectory(String subdirectory) throws IOException {
        File subdirectoryFile = new File(getSensorTestDataDirectory(), subdirectory);
        return createDirectoryStructure(subdirectoryFile);
    }

    /**
     * Sanitizes a string so it can be used in file names.
     *
     * @param value The string to sanitize.
     * @return The sanitized string.
     *
     * @throws SensorTestPlatformException If the string cannot be sanitized.
     */
    public static String sanitizeStringForFileName(String value)
            throws SensorTestPlatformException {
        String sanitizedValue = value.replaceAll(""[^a-zA-Z0-9_\\-]"", ""_"");
        if (sanitizedValue.matches(""_*"")) {
            throw new SensorTestPlatformException(
                    ""Unable to sanitize string '%s' for file name."",
                    value);
        }
        return sanitizedValue;
    }

    /**
     * Ensures that the directory structure represented by the given {@link File} is created.
     */
    private static File createDirectoryStructure(File directoryStructure) throws IOException {
        directoryStructure.mkdirs();
        if (!directoryStructure.isDirectory()) {
            throw new IOException(""Unable to create directory structure for ""
                    + directoryStructure.getAbsolutePath());
        }
        return directoryStructure;
    }

    /**
     * Validate that a collection is not null or empty.
     *
     * @throws IllegalStateException if collection is null or empty.
     */
    private static <T> void validateCollection(Collection<T> collection) {
        if(collection == null || collection.size() == 0) {
            throw new IllegalStateException(""Collection cannot be null or empty"");
        }
    }

    public static String getUnitsForSensor(Sensor sensor) {
        switch(sensor.getType()) {
            case Sensor.TYPE_ACCELEROMETER:
                return ""m/s^2"";
            case Sensor.TYPE_MAGNETIC_FIELD:
            case Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED:
                return ""uT"";
            case Sensor.TYPE_GYROSCOPE:
            case Sensor.TYPE_GYROSCOPE_UNCALIBRATED:
                return ""radians/sec"";
            case Sensor.TYPE_PRESSURE:
                return ""hPa"";
        };
        return """";
    }

    public static boolean hasMaxResolutionRequirement(Sensor sensor, boolean hasHifiSensors) {
        switch (sensor.getType()) {
            case Sensor.TYPE_ACCELEROMETER:
            case Sensor.TYPE_ACCELEROMETER_UNCALIBRATED:
            case Sensor.TYPE_GYROSCOPE:
            case Sensor.TYPE_GYROSCOPE_UNCALIBRATED:
            case Sensor.TYPE_MAGNETIC_FIELD:
            case Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED:
            case Sensor.TYPE_HINGE_ANGLE:
            case Sensor.TYPE_PROXIMITY:
            case Sensor.TYPE_SIGNIFICANT_MOTION:
            case Sensor.TYPE_STEP_DETECTOR:
            case Sensor.TYPE_STEP_COUNTER:
            case Sensor.TYPE_HEART_RATE:
            case Sensor.TYPE_STATIONARY_DETECT:
            case Sensor.TYPE_MOTION_DETECT:
            case Sensor.TYPE_LOW_LATENCY_OFFBODY_DETECT:
                return true;

            case Sensor.TYPE_PRESSURE:
                // Pressure sensor only has a resolution requirement when there are HiFi sensors
                return hasHifiSensors;
        }
        return false;
    }

    public static float getRequiredMaxResolutionForSensor(Sensor sensor) {
        switch (sensor.getType()) {
            case Sensor.TYPE_ACCELEROMETER:
            case Sensor.TYPE_ACCELEROMETER_UNCALIBRATED:
            case Sensor.TYPE_GYROSCOPE:
            case Sensor.TYPE_GYROSCOPE_UNCALIBRATED:
                // Accelerometer and gyroscope must have at least 12 bits
                // of resolution. The maximum resolution calculation uses
                // slightly more than twice the maximum range because
                //   1) the sensor must be able to report values from
                //      [-maxRange, maxRange] without saturating
                //   2) to allow for slight rounding errors
                return (float)(2.001f * sensor.getMaximumRange() / Math.pow(2, 12));
            case Sensor.TYPE_MAGNETIC_FIELD:
            case Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED:
                // Magnetometer must have a resolution equal to or denser
                // than 0.6 uT
                return 0.6f;
            case Sensor.TYPE_PRESSURE:
                // Pressure sensor must have at least 80 LSB / hPa which is
                // equivalent to 0.0125 hPa / LSB. Allow for a small margin of
                // error due to rounding errors.
                return 1.01f * (1.0f / 80.0f);
            case Sensor.TYPE_HINGE_ANGLE:
                // Hinge angle sensor must have a resolution the same or smaller
                // than 360 degrees.
                return 360f;
            case Sensor.TYPE_PROXIMITY:
                // Binary prox sensors must have a resolution of 5, but it's not
                // expected / recommended that prox sensors use higher than
                // this.
                return 5f;
        }

        // Any sensor not specified above must use a resolution of 1.
        return 1.0f;
    }

    public static boolean hasMinResolutionRequirement(Sensor sensor) {
        switch (sensor.getType()) {
            case Sensor.TYPE_ACCELEROMETER:
            case Sensor.TYPE_ACCELEROMETER_UNCALIBRATED:
            case Sensor.TYPE_GYROSCOPE:
            case Sensor.TYPE_GYROSCOPE_UNCALIBRATED:
            case Sensor.TYPE_MAGNETIC_FIELD:
            case Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED:
            case Sensor.TYPE_SIGNIFICANT_MOTION:
            case Sensor.TYPE_STEP_DETECTOR:
            case Sensor.TYPE_STEP_COUNTER:
            case Sensor.TYPE_HEART_RATE:
            case Sensor.TYPE_STATIONARY_DETECT:
            case Sensor.TYPE_MOTION_DETECT:
            case Sensor.TYPE_LOW_LATENCY_OFFBODY_DETECT:
                return true;
        }
        return false;
    }

    public static float getRequiredMinResolutionForSensor(Sensor sensor) {
        switch (sensor.getType()) {
            case Sensor.TYPE_ACCELEROMETER:
            case Sensor.TYPE_ACCELEROMETER_UNCALIBRATED:
            case Sensor.TYPE_GYROSCOPE:
            case Sensor.TYPE_GYROSCOPE_UNCALIBRATED:
            case Sensor.TYPE_MAGNETIC_FIELD:
            case Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED:
                // Accelerometer, gyroscope, and mag are expected to have at most 24 bits of
                // resolution. The minimum resolution calculation uses slightly more than twice
                // the maximum range because:
                //   1) the sensor must be able to report values from [-maxRange, maxRange] without
                //      saturating
                //   2) to allow for slight rounding errors
                return (float)(2.001f * sensor.getMaximumRange() / Math.pow(2, 24));
        }

        // Any sensor not specified above must use a resolution of 1.
        return 1.0f;
    }

    public static String sensorTypeShortString(int type) {
        switch (type) {
            case Sensor.TYPE_ACCELEROMETER:
                return ""Accel"";
            case Sensor.TYPE_GYROSCOPE:
                return ""Gyro"";
            case Sensor.TYPE_MAGNETIC_FIELD:
                return ""Mag"";
            case Sensor.TYPE_ACCELEROMETER_UNCALIBRATED:
                return ""UncalAccel"";
            case Sensor.TYPE_GYROSCOPE_UNCALIBRATED:
                return ""UncalGyro"";
            case Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED:
                return ""UncalMag"";
            default:
                return ""Type_"" + type;
        }
    }

    public static class TestResultCollector {
        private List<AssertionError> mErrorList = new ArrayList<>();
        private List<String> mErrorStringList = new ArrayList<>();
        private String mTestName;
        private String mTag;

        public TestResultCollector() {
            this(""Test"");
        }

        public TestResultCollector(String test) {
            this(test, ""SensorCtsTest"");
        }

        public TestResultCollector(String test, String tag) {
            mTestName = test;
            mTag = tag;
        }

        public void perform(Runnable r) {
            perform(r, """");
        }

        public void perform(Runnable r, String s) {
            try {
                Log.d(mTag, mTestName + "" running "" + (s.isEmpty() ? ""..."" : s));
                r.run();
            } catch (AssertionError e) {
                mErrorList.add(e);
                mErrorStringList.add(s);
                Log.e(mTag, mTestName + "" error: "" + e.getMessage());
            }
        }

        public void judge() throws AssertionError {
            if (mErrorList.isEmpty() && mErrorStringList.isEmpty()) {
                return;
            }

            if (mErrorList.size() != mErrorStringList.size()) {
                throw new IllegalStateException(""Mismatch error and error message"");
            }

            StringBuffer buf = new StringBuffer();
            for (int i = 0; i < mErrorList.size(); ++i) {
                buf.append(""Test ("").append(mErrorStringList.get(i)).append("") - Error: "")
                    .append(mErrorList.get(i).getMessage()).append(""; "");
            }
            throw new AssertionError(buf.toString());
        }
    }

    public static String bytesToHex(byte[] bytes, int offset, int length) {
        if (offset == -1) {
            offset = 0;
        }

        if (length == -1) {
            length = bytes.length;
        }

        final char[] hexArray = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
        char[] hexChars = new char[length * 3];
        int v;
        for (int i = 0; i < length; i++) {
            v = bytes[offset + i] & 0xFF;
            hexChars[i * 3] = hexArray[v >>> 4];
            hexChars[i * 3 + 1] = hexArray[v & 0x0F];
            hexChars[i * 3 + 2] = ' ';
        }
        return new String(hexChars);
    }

    public static void makeMyPackageActive() throws IOException {
        final String command = ""cmd sensorservice reset-uid-state ""
                +  InstrumentationRegistry.getTargetContext().getPackageName()
                + "" --user "" + Process.myUserHandle().getIdentifier();
        SystemUtil.runShellCommand(InstrumentationRegistry.getInstrumentation(), command);
    }

    public static void makeMyPackageIdle() throws IOException {
        final String command = ""cmd sensorservice set-uid-state ""
                + InstrumentationRegistry.getTargetContext().getPackageName() + "" idle""
                + "" --user "" + Process.myUserHandle().getIdentifier();
        SystemUtil.runShellCommand(InstrumentationRegistry.getInstrumentation(), command);
    }
}"	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	""	""
"7.3.2  . Magnetometer"	"7.3.2"	"C-1-10"	"7.3.2/C-1-10"	"07030200.670110"	"""C-1-10] MUST implement the TYPE_MAGNETIC_FIELD_UNCALIBRATED sensor. If device implementations include a 3-axis magnetometer, an accelerometer sensor, and a 3-axis gyroscope sensor, they:"""	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	"android.hardware.cts.SensorIntegrationTests"	"testUncalibratedMagneticFieldReconfigureWhileActive"	"CtsSensorTestCases"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/SensorIntegrationTests.java"	""	"public void testUncalibratedMagneticFieldReconfigureWhileActive() throws Throwable {
        verifySensorReconfigureWhileActive(Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED);
    }"	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	""	""
"7.3.2  . Magnetometer"	"7.3.2"	"C-1-10"	"7.3.2/C-1-10"	"07030200.670110"	"""C-1-10] MUST implement the TYPE_MAGNETIC_FIELD_UNCALIBRATED sensor. If device implementations include a 3-axis magnetometer, an accelerometer sensor, and a 3-axis gyroscope sensor, they:"""	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.sensors.RVCVRecordActivity"	"getDefaultDisplay"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/sensors/RVCVRecordActivity.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.sensors;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.hardware.Camera;
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.media.AudioManager;
import android.media.CamcorderProfile;
import android.media.MediaRecorder;
import android.media.SoundPool;
import android.net.Uri;
import android.os.Bundle;
import android.os.Environment;
import android.util.JsonWriter;
import android.util.Log;
import android.view.Surface;
import android.view.Window;
import android.view.WindowManager;
import android.widget.ImageView;
import android.widget.Toast;

import com.android.cts.verifier.R;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

// ----------------------------------------------------------------------

/**
 *  An activity that does recording of the camera video and rotation vector data at the same time.
 */
public class RVCVRecordActivity extends Activity {
    private static final String TAG = ""RVCVRecordActivity"";
    private static final boolean LOCAL_LOGV = false;

    private MotionIndicatorView mIndicatorView;

    private SoundPool mSoundPool;
    private Map<String, Integer> mSoundMap;

    private File mRecordDir;
    private RecordProcedureController mController;
    private VideoRecorder           mVideoRecorder;
    private RVSensorLogger          mRVSensorLogger;
    private CoverageManager         mCoverManager;
    private CameraContext mCameraContext;
    private int mDeviceRotation = Surface.ROTATION_0;

    public static final int AXIS_NONE = 0;
    public static final int AXIS_ALL = SensorManager.AXIS_X +
                                       SensorManager.AXIS_Y +
                                       SensorManager.AXIS_Z;

    // For Rotation Vector algorithm research use
    private final static boolean     LOG_RAW_SENSORS = false;
    private RawSensorLogger          mRawSensorLogger;

    public final RecordProcedureControllerCallback mRecordProcedureControllerCallback =
            new RecordProcedureControllerCallback() {
        public void startRecordProcedureController() {
            startRecordcontroller();
        }
        public void stopRecordProcedureController() {
            stopRecordcontroller();
        }
    };

    public void startRecordcontroller() {
        if (mController != null) {
            Log.v(TAG, ""startRecordcontroller is working. stop it"");
            mController.quit();
        }
        Log.v(TAG, ""startRecordcontroller"");
        mController = new RecordProcedureController(this);
    }

    public void stopRecordcontroller() {
        if (mController != null) {
            Log.v(TAG, ""startRecordcontroller is working. stop it"");
            mController.quit();
        }
        Log.v(TAG, ""stopRecordcontroller"");
    }

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // Hide the window title.
        requestWindowFeature(Window.FEATURE_NO_TITLE);

        // inflate xml
        setContentView(R.layout.cam_preview_overlay);

        // locate views
        mIndicatorView = (MotionIndicatorView) findViewById(R.id.cam_indicator);
        WindowManager windowManager =
                (WindowManager)getSystemService(Context.WINDOW_SERVICE);
        if (windowManager != null) {
            mDeviceRotation = windowManager.getDefaultDisplay().getRotation();
            mIndicatorView.setDeviceRotation(mDeviceRotation);
        }

        initStoragePath();
    }

    @Override
    protected void onPause() {
        super.onPause();
        if (mController != null) {
            mController.quit();
        }

        mCameraContext.end();
        endSoundPool();
    }

    @Override
    protected void onResume() {
        super.onResume();
        // delay the initialization as much as possible
        init();
    }

    /** display toast message
     *
     * @param msg Message content
     */
    private void message(String msg) {

        Context context = getApplicationContext();
        int duration = Toast.LENGTH_SHORT;

        Toast toast = Toast.makeText(context, msg, duration);
        toast.show();
    }

    /**
     *  Initialize components
     *
     */
    private void init() {
        mCameraContext = new CameraContext();
        mCameraContext.init(mRecordProcedureControllerCallback);

        mCoverManager = new CoverageManager();
        mIndicatorView.setDataProvider(
                mCoverManager.getAxis(SensorManager.AXIS_X),
                mCoverManager.getAxis(SensorManager.AXIS_Y),
                mCoverManager.getAxis(SensorManager.AXIS_Z)  );

        initSoundPool();
        mRVSensorLogger = new RVSensorLogger(this);

        mVideoRecorder = new VideoRecorder(mCameraContext.getCamera(), mCameraContext.getProfile());

        if (LOG_RAW_SENSORS) {
            mRawSensorLogger = new RawSensorLogger(mRecordDir);
        }
    }

    /**
     * Notify recording is completed. This is the successful exit.
     */
    public void notifyComplete() {
        message(""Capture completed!"");

        Uri resultUri = Uri.fromFile(mRecordDir);
        Intent result = new Intent();
        result.setData(resultUri);
        setResult(Activity.RESULT_OK, result);

        finish();
    }

    /**
     * Notify the user what to do next in text
     *
     * @param axis SensorManager.AXIS_X or SensorManager.AXIS_Y or SensorManager.AXIS_Z
     */
    private void notifyPrompt(int axis) {
        // It is not XYZ because of earlier design have different definition of
        // X and Y
        final String axisName = ""YXZ"";

        message(""Manipulate the device in "" + axisName.charAt(axis - 1) +
                "" axis (as illustrated) about the pattern."");
    }

    /**
     *  Ask indicator view to redraw
     */
    private void redrawIndicator() {
        mIndicatorView.invalidate();
    }

    /**
     * Switch to a different axis for display and logging
     * @param axis
     */
    private void switchAxis(int axis) {
        ImageView imageView = (ImageView) findViewById(R.id.cam_overlay);

        final int [] prompts = {R.drawable.prompt_x, R.drawable.prompt_y, R.drawable.prompt_z};

        if (axis >=SensorManager.AXIS_X && axis <=SensorManager.AXIS_Z) {
            imageView.setImageResource(prompts[axis-1]);
            if (mDeviceRotation != Surface.ROTATION_0 && mDeviceRotation != Surface.ROTATION_180) {
                imageView.setRotation(90);
            }
            mIndicatorView.enableAxis(axis);
            mRVSensorLogger.updateRegister(mCoverManager.getAxis(axis), axis);
            notifyPrompt(axis);
        } else {
            imageView.setImageDrawable(null);
            mIndicatorView.enableAxis(AXIS_NONE);
        }
        redrawIndicator();
    }

    /**
     * Asynchronized way to call switchAxis. Use this if caller is not on UI thread.
     * @param axis @param axis SensorManager.AXIS_X or SensorManager.AXIS_Y or SensorManager.AXIS_Z
     */
    public void switchAxisAsync(int axis) {
        // intended to be called from a non-UI thread
        final int fAxis = axis;
        runOnUiThread(new Runnable() {
            public void run() {
                // UI code goes here
                switchAxis(fAxis);
            }
        });
    }

    /**
     * Initialize sound pool for user notification
     */
    private void initSoundPool() {
        mSoundPool = new SoundPool(1 /*maxStreams*/, AudioManager.STREAM_MUSIC, 0);
        mSoundMap = new HashMap<>();

        // TODO: add different sound into this
        mSoundMap.put(""start"", mSoundPool.load(this, R.raw.start_axis, 1));
        mSoundMap.put(""end"", mSoundPool.load(this, R.raw.next_axis, 1));
        mSoundMap.put(""half-way"", mSoundPool.load(this, R.raw.half_way, 1));
    }
    private void endSoundPool() {
        mSoundPool.release();
    }

    /**
     * Play notify sound to user
     * @param name name of the sound to be played
     */
    public void playNotifySound(String name) {
        Integer id = mSoundMap.get(name);
        if (id != null) {
            mSoundPool.play(id.intValue(), 0.75f/*left vol*/, 0.75f/*right vol*/, 0 /*priority*/,
                    0/*loop play*/, 1/*rate*/);
        }
    }

    /**
     * Start the sensor recording
     */
    public void startRecordSensor() {
        runOnUiThread(new Runnable() {
            public void run() {
                mRVSensorLogger.init();
                if (LOG_RAW_SENSORS) {
                    mRawSensorLogger.init();
                }
            }
        });
    }

    /**
     * Stop the sensor recording
     */
    public void stopRecordSensor() {
        runOnUiThread(new Runnable() {
            public void run() {
                mRVSensorLogger.end();
                if (LOG_RAW_SENSORS) {
                    mRawSensorLogger.end();
                }
            }
        });
    }

    /**
     * Start video recording
     */
    public void startRecordVideo() {
        mVideoRecorder.init();
    }

    /**
     * Stop video recording
     */
    public void stopRecordVideo() {
        mVideoRecorder.end();
    }

    /**
     * Wait until a sensor recording for a certain axis is fully covered
     * @param axis
     */
    public void waitUntilCovered(int axis) {
        mCoverManager.waitUntilCovered(axis);
    }

    /**
     * Wait until a sensor recording for a certain axis is halfway covered
     * @param axis
     */
    public void waitUntilHalfCovered(int axis) {
        mCoverManager.waitUntilHalfCovered(axis);
    }

    /**
     *
     */
    private void initStoragePath() {
        File rxcvRecDataDir = new File(getExternalFilesDir(null),""RVCVRecData"");

        // Create the storage directory if it does not exist
        if (! rxcvRecDataDir.exists()) {
            if (! rxcvRecDataDir.mkdirs()) {
                Log.e(TAG, ""failed to create main data directory"");
            }
        }

        mRecordDir = new File(rxcvRecDataDir, new SimpleDateFormat(""yyMMdd-hhmmss"").format(new Date()));

        if (! mRecordDir.mkdirs()) {
            Log.e(TAG, ""failed to create rec data directory"");
        }
    }

    /**
     * Get the sensor log file path
     * @return Path of the sensor log file
     */
    public String getSensorLogFilePath() {
        return new File(mRecordDir, ""sensor.log"").getPath();
    }

    /**
     * Get the video recording file path
     * @return Path of the video recording file
     */
    public String getVideoRecFilePath() {
        return new File(mRecordDir, ""video.mp4"").getPath();
    }

    /**
     * Write out important camera/video information to a JSON file
     * @param width         width of frame
     * @param height        height of frame
     * @param frameRate     frame rate in fps
     * @param fovW          field of view in width direction
     * @param fovH          field of view in height direction
     */
    public void writeVideoMetaInfo(int width, int height, float frameRate, float fovW, float fovH) {
        try {
            JsonWriter writer =
                    new JsonWriter(
                        new OutputStreamWriter(
                                new FileOutputStream(
                                        new File(mRecordDir, ""videometa.json"").getPath()
                                )
                        )
                    );
            writer.beginObject();
            writer.name(""fovW"").value(fovW);
            writer.name(""fovH"").value(fovH);
            writer.name(""width"").value(width);
            writer.name(""height"").value(height);
            writer.name(""frameRate"").value(frameRate);
            writer.endObject();

            writer.close();
        }catch (FileNotFoundException e) {
            // Not very likely to happen
            e.printStackTrace();
        }catch (IOException e) {
            // do nothing
            e.printStackTrace();
            Log.e(TAG, ""Writing video meta data failed."");
        }
    }

    public interface RecordProcedureControllerCallback {
        public void startRecordProcedureController();
        public void stopRecordProcedureController();
    }

    /**
     * Camera preview control class
     */
    class CameraContext {
        private Camera mCamera;
        private CamcorderProfile mProfile;
        private Camera.CameraInfo mCameraInfo;
        private RVCVCameraPreview mCameraPreview;

        private int [] mPreferredProfiles = {
                CamcorderProfile.QUALITY_480P,  // smaller -> faster
                CamcorderProfile.QUALITY_720P,
                CamcorderProfile.QUALITY_1080P,
                CamcorderProfile.QUALITY_HIGH // existence guaranteed
        };

        private String [] mPreferredFocusMode = {
                Camera.Parameters.FOCUS_MODE_FIXED,
                Camera.Parameters.FOCUS_MODE_INFINITY,
                // the following two modes are more likely to mess up recording
                // but they are still better than FOCUS_MODE_AUTO, which requires
                // calling autoFocus explicitly to focus.
                Camera.Parameters.FOCUS_MODE_CONTINUOUS_VIDEO,
                Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE
        };

        CameraContext() {
            try {
                mCamera = Camera.open(); // attempt to get a default Camera instance (0)
                mProfile = null;
                if (mCamera != null) {
                    mCameraInfo = new Camera.CameraInfo();
                    Camera.getCameraInfo(0, mCameraInfo);
                    setupCamera();
                }
            }
            catch (Exception e){
                // Camera is not available (in use or does not exist)
                Log.e(TAG, ""Cannot obtain Camera!"");
            }
        }

        /**
         * Find a preferred camera profile and set preview and picture size property accordingly.
         */
        void setupCamera() {
            CamcorderProfile profile = null;
            boolean isSetNeeded = false;
            Camera.Parameters param = mCamera.getParameters();
            List<Camera.Size> pre_sz = param.getSupportedPreviewSizes();
            List<Camera.Size> pic_sz = param.getSupportedPictureSizes();

            for (int i : mPreferredProfiles) {
                if (CamcorderProfile.hasProfile(i)) {
                    profile = CamcorderProfile.get(i);

                    int valid = 0;
                    for (Camera.Size j : pre_sz) {
                        if (j.width == profile.videoFrameWidth &&
                                j.height == profile.videoFrameHeight) {
                            ++valid;
                            break;
                        }
                    }
                    for (Camera.Size j : pic_sz) {
                        if (j.width == profile.videoFrameWidth &&
                                j.height == profile.videoFrameHeight) {
                            ++valid;
                            break;
                        }
                    }
                    if (valid == 2) {
                        param.setPreviewSize(profile.videoFrameWidth, profile.videoFrameHeight);
                        param.setPictureSize(profile.videoFrameWidth, profile.videoFrameHeight);
                        isSetNeeded = true;
                        break;
                    } else {
                        profile = null;
                    }
                }
            }

            for (String i : mPreferredFocusMode) {
                if (param.getSupportedFocusModes().contains(i)){
                    param.setFocusMode(i);
                    isSetNeeded = true;
                    break;
                }
            }

            if (isSetNeeded) {
                mCamera.setParameters(param);
            }

            if (profile != null) {
                param = mCamera.getParameters(); //acquire proper fov after change the picture size
                float fovW = param.getHorizontalViewAngle();
                float fovH = param.getVerticalViewAngle();
                writeVideoMetaInfo(profile.videoFrameWidth, profile.videoFrameHeight,
                        profile.videoFrameRate, fovW, fovH);
            } else {
                Log.e(TAG, ""Cannot find a proper video profile"");
            }
            mProfile = profile;

        }


        /**
         * Get sensor information of the camera being used
         */
        public Camera.CameraInfo getCameraInfo() {
            return mCameraInfo;
        }

        /**
         * Get the camera to be previewed
         * @return Reference to Camera used
         */
        public Camera getCamera() {
            return mCamera;
        }

        /**
         * Get the camera profile to be used
         * @return Reference to Camera profile
         */
        public CamcorderProfile getProfile() {
            return mProfile;
        }

        /**
         * Setup the camera
         */
        public void init(RVCVRecordActivity.RecordProcedureControllerCallback callback) {
            if (mCamera != null) {
                double alpha = mCamera.getParameters().getHorizontalViewAngle()*Math.PI/180.0;
                int width = mProfile.videoFrameWidth;
                double fx = width/2/Math.tan(alpha/2.0);

                if (LOCAL_LOGV) Log.v(TAG, ""View angle=""
                        + mCamera.getParameters().getHorizontalViewAngle() +""  Estimated fx = ""+fx);

                mCameraPreview =
                        (RVCVCameraPreview) findViewById(R.id.cam_preview);
                mCameraPreview.setRecordProcedureControllerCallback(callback);
                mCameraPreview.init(mCamera,
                        (float)mProfile.videoFrameWidth/mProfile.videoFrameHeight,
                        mCameraInfo.orientation);
            } else {
                message(""Cannot open camera!"");
                finish();
            }
        }

        /**
         * End the camera preview
         */
        public void end() {
            if (mCamera != null) {
                mCamera.release();        // release the camera for other applications
                mCamera = null;
            }
        }
    }

    /**
     * Manage a set of RangeCoveredRegister objects
     */
    class CoverageManager {
        // settings
        private final int MAX_TILT_ANGLE = 50; // +/- 50
        //private final int REQUIRED_TILT_ANGLE = 50; // +/- 50
        private final int TILT_ANGLE_STEP = 5; // 5 degree(s) per step
        private final int YAW_ANGLE_STEP = 10; // 10 degree(s) per step

        RangeCoveredRegister[] mAxisCovered;

        CoverageManager() {
            mAxisCovered = new RangeCoveredRegister[3];
            // X AXIS
            mAxisCovered[0] = new RangeCoveredRegister(
                    -MAX_TILT_ANGLE, +MAX_TILT_ANGLE, TILT_ANGLE_STEP);
            // Y AXIS
            mAxisCovered[1] = new RangeCoveredRegister(
                    -MAX_TILT_ANGLE, +MAX_TILT_ANGLE, TILT_ANGLE_STEP);
            // Z AXIS
            mAxisCovered[2] = new RangeCoveredRegister(YAW_ANGLE_STEP);
        }

        public RangeCoveredRegister getAxis(int axis) {
            // SensorManager.AXIS_X = 1, need offset -1 for mAxisCovered array
            return mAxisCovered[axis-1];
        }

        public void waitUntilHalfCovered(int axis) {
            if (axis == SensorManager.AXIS_Z) {
                waitUntilCovered(axis);
            }

            // SensorManager.AXIS_X = 1, need offset -1 for mAxisCovered array
            while(!(mAxisCovered[axis-1].isRangeCovered(-MAX_TILT_ANGLE, -MAX_TILT_ANGLE/2) ||
                        mAxisCovered[axis-1].isRangeCovered(MAX_TILT_ANGLE/2, MAX_TILT_ANGLE) ) ) {
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    if (LOCAL_LOGV) {
                        Log.v(TAG, ""waitUntilHalfCovered axis = ""+ axis + "" is interrupted"");
                    }
                    Thread.currentThread().interrupt();
                }
            }
        }

        public void waitUntilCovered(int axis) {
            // SensorManager.AXIS_X = 1, need offset -1 for mAxisCovered array
            while(!mAxisCovered[axis-1].isFullyCovered()) {
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    if (LOCAL_LOGV) {
                        Log.v(TAG, ""waitUntilCovered axis = ""+ axis + "" is interrupted"");
                    }
                    Thread.currentThread().interrupt();
                }
            }
        }
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////

    /**
     * A class controls the video recording
     */
    class VideoRecorder
    {
        private MediaRecorder mRecorder;
        private CamcorderProfile mProfile;
        private Camera mCamera;
        private boolean mRunning = false;

        VideoRecorder(Camera camera, CamcorderProfile profile){
            mCamera = camera;
            mProfile = profile;
        }

        /**
         * Initialize and start recording
         */
        public void init() {
            if (mCamera == null  || mProfile ==null){
                return;
            }

            mRecorder = new MediaRecorder();
            try {
                mCamera.unlock();
            } catch (RuntimeException e) {
                e.printStackTrace();
                try {
                    mRecorder.reset();
                    mRecorder.release();
                } catch (RuntimeException ex) {
                    e.printStackTrace();
                }
                return;
            }

            try {
                mRecorder.setCamera(mCamera);
                mRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);
                mRecorder.setAudioSource(MediaRecorder.AudioSource.DEFAULT);
                mRecorder.setProfile(mProfile);
            } catch (RuntimeException e) {
                e.printStackTrace();
                return;
            }

            try {
                mRecorder.setOutputFile(getVideoRecFilePath());
                mRecorder.prepare();
            } catch (IOException e) {
                Log.e(TAG, ""Preparation for recording failed."");
                return;
            }

            try {
                mRecorder.start();
            } catch (RuntimeException e) {
                Log.e(TAG, ""Starting recording failed."");
                try {
                    mRecorder.reset();
                    mRecorder.release();
                    mCamera.lock();
                } catch (RuntimeException ex1) {
                    e.printStackTrace();
                }
                return;
            }
            mRunning = true;
        }

        /**
         * Stop recording
         */
        public void end() {
            if (mRunning) {
                try {
                    mRecorder.stop();
                    mRecorder.reset();
                    mRecorder.release();
                    mCamera.lock();
                } catch (RuntimeException e) {
                    e.printStackTrace();
                    Log.e(TAG, ""Runtime error in stopping recording."");
                }
            }
            mRecorder = null;
        }

    }

    ////////////////////////////////////////////////////////////////////////////////////////////////

    /**
     *  Log all raw sensor readings, for Rotation Vector sensor algorithms research
     */
    class RawSensorLogger implements SensorEventListener {
        private final String TAG = ""RawSensorLogger"";

        private final static int SENSOR_RATE = SensorManager.SENSOR_DELAY_FASTEST;
        private File mRecPath;

        SensorManager mSensorManager;
        Sensor mAccSensor, mGyroSensor, mMagSensor;
        OutputStreamWriter mAccLogWriter, mGyroLogWriter, mMagLogWriter;

        private float[] mRTemp = new float[16];

        RawSensorLogger(File recPath) {
            mRecPath = recPath;
        }

        /**
         * Initialize and start recording
         */
        public void init() {
            mSensorManager = (SensorManager)getSystemService(SENSOR_SERVICE);

            mAccSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
            mGyroSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE_UNCALIBRATED);
            mMagSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED);

            mSensorManager.registerListener(this, mAccSensor, SENSOR_RATE);
            mSensorManager.registerListener(this, mGyroSensor, SENSOR_RATE);
            mSensorManager.registerListener(this, mMagSensor, SENSOR_RATE);

            try {
                mAccLogWriter= new OutputStreamWriter(
                        new FileOutputStream(new File(mRecPath, ""raw_acc.log"")));
                mGyroLogWriter= new OutputStreamWriter(
                        new FileOutputStream(new File(mRecPath, ""raw_uncal_gyro.log"")));
                mMagLogWriter= new OutputStreamWriter(
                        new FileOutputStream(new File(mRecPath, ""raw_uncal_mag.log"")));

            } catch (FileNotFoundException e) {
                Log.e(TAG, ""Sensor log file open failed: "" + e.toString());
            }
        }

        /**
         * Stop recording and clean up
         */
        public void end() {
            mSensorManager.flush(this);
            mSensorManager.unregisterListener(this);

            try {
                if (mAccLogWriter != null) {
                    OutputStreamWriter writer = mAccLogWriter;
                    mAccLogWriter = null;
                    writer.close();
                }
                if (mGyroLogWriter != null) {
                    OutputStreamWriter writer = mGyroLogWriter;
                    mGyroLogWriter = null;
                    writer.close();
                }
                if (mMagLogWriter != null) {
                    OutputStreamWriter writer = mMagLogWriter;
                    mMagLogWriter = null;
                    writer.close();
                }

            } catch (IOException e) {
                Log.e(TAG, ""Sensor log file close failed: "" + e.toString());
            }
        }

        @Override
        public void onAccuracyChanged(Sensor sensor, int i) {
            // do not care
        }

        @Override
        public void onSensorChanged(SensorEvent event) {
            OutputStreamWriter writer=null;
            switch(event.sensor.getType()) {
                case Sensor.TYPE_ACCELEROMETER:
                    writer = mAccLogWriter;
                    break;
                case Sensor.TYPE_GYROSCOPE_UNCALIBRATED:
                    writer = mGyroLogWriter;
                    break;
                case Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED:
                    writer = mMagLogWriter;
                    break;

            }
            if (writer!=null)  {
                float[] data = event.values;
                try {
                    if (event.sensor.getType() == Sensor.TYPE_ACCELEROMETER) {
                        writer.write(String.format(""%d %f %f %f\r\n"",
                                event.timestamp, data[0], data[1], data[2]));
                    }else // TYPE_GYROSCOPE_UNCALIBRATED and TYPE_MAGNETIC_FIELD_UNCALIBRATED
                    {
                        writer.write(String.format(""%d %f %f %f %f %f %f\r\n"", event.timestamp,
                                data[0], data[1], data[2], data[3], data[4], data[5]));
                    }
                }catch (IOException e)
                {
                    Log.e(TAG, ""Write to raw sensor log file failed."");
                }

            }
        }
    }

    /**
     *  Rotation sensor logger class
     */
    class RVSensorLogger implements SensorEventListener {
        private final String TAG = ""RVSensorLogger"";

        private final static int SENSOR_RATE = SensorManager.SENSOR_DELAY_FASTEST;
        RangeCoveredRegister mRegister;
        int mAxis;
        RVCVRecordActivity mActivity;

        SensorManager mSensorManager;
        Sensor mRVSensor;
        OutputStreamWriter mLogWriter;

        private float[] mRTemp = new float[16];

        RVSensorLogger(RVCVRecordActivity activity) {
            mActivity = activity;
        }

        /**
         * Initialize and start recording
         */
        public void init() {
            mSensorManager = (SensorManager)getSystemService(SENSOR_SERVICE);
            if (mSensorManager == null) {
                Log.e(TAG,""SensorManager is null!"");
            }
            mRVSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ROTATION_VECTOR);
            if (mRVSensor != null) {
                if (LOCAL_LOGV) Log.v(TAG, ""Got RV Sensor"");
            }else {
                Log.e(TAG, ""Did not get RV sensor"");
            }
            if(mSensorManager.registerListener(this, mRVSensor, SENSOR_RATE)) {
                if (LOCAL_LOGV) Log.v(TAG,""Register listener successfull"");
            } else {
                Log.e(TAG,""Register listener failed"");
            }

            try {
                mLogWriter= new OutputStreamWriter(
                        new FileOutputStream(mActivity.getSensorLogFilePath()));
            } catch (FileNotFoundException e) {
                Log.e(TAG, ""Sensor log file open failed: "" + e.toString());
            }
        }

        /**
         * Stop recording and clean up
         */
        public void end() {
            mSensorManager.flush(this);
            mSensorManager.unregisterListener(this);

            try {
                if (mLogWriter != null) {
                    OutputStreamWriter writer = mLogWriter;
                    mLogWriter = null;
                    writer.close();
                }
            } catch (IOException e) {
                Log.e(TAG, ""Sensor log file close failed: "" + e.toString());
            }

            updateRegister(null, AXIS_NONE);
        }

        private void onNewData(float[] data, long timestamp) {
            // LOG
            try {
                if (mLogWriter != null) {
                    mLogWriter.write(String.format(""%d %f %f %f %f\r\n"", timestamp,
                            data[3], data[0], data[1], data[2]));
                }
            } catch (IOException e) {
                Log.e(TAG, ""Sensor log file write failed: "" + e.toString());
            }

            // Update UI
            if (mRegister != null) {
                int d = 0;
                int dx, dy, dz;
                boolean valid = false;
                SensorManager.getRotationMatrixFromVector(mRTemp, data);

                dx = (int)(Math.asin(mRTemp[8])*(180.0/Math.PI));
                dy = (int)(Math.asin(mRTemp[9])*(180.0/Math.PI));
                dz = (int)((Math.atan2(mRTemp[4], mRTemp[0])+Math.PI)*(180.0/Math.PI));

                switch(mAxis) {
                    case SensorManager.AXIS_X:
                        d = dx;
                        valid = (Math.abs(dy) < 30);
                        break;
                    case SensorManager.AXIS_Y:
                        d = dy;
                        valid = (Math.abs(dx) < 30);
                        break;
                    case SensorManager.AXIS_Z:
                        d = dz;
                        valid = (Math.abs(dx) < 20 && Math.abs(dy) < 20);
                        break;
                }

                if (valid) {
                    mRegister.update(d);
                    mActivity.redrawIndicator();
                }
            }

        }

        public void updateRegister(RangeCoveredRegister reg, int axis) {
            mRegister = reg;
            mAxis = axis;
        }


        @Override
        public void onAccuracyChanged(Sensor sensor, int i) {
            // do not care
        }

        @Override
        public void onSensorChanged(SensorEvent event) {
            if (event.sensor.getType() == Sensor.TYPE_ROTATION_VECTOR) {
                onNewData(event.values, event.timestamp);
            }
        }
    }


    ////////////////////////////////////////////////////////////////////////////////////////////////

    /**
     * Controls the over all logic of record procedure: first x-direction, then y-direction and
     * then z-direction.
     */
    class RecordProcedureController implements Runnable {
        private static final boolean LOCAL_LOGV = false;

        private final RVCVRecordActivity mActivity;
        private Thread mThread = null;

        RecordProcedureController(RVCVRecordActivity activity) {
            mActivity = activity;
            mThread = new Thread(this);
            mThread.start();
        }

        /**
         * Run the record procedure
         */
        public void run() {
            if (LOCAL_LOGV) Log.v(TAG, ""Controller Thread Started."");
            //start recording & logging
            delay(2000);

            init();
            if (LOCAL_LOGV) Log.v(TAG, ""Controller Thread init() finished."");

            // test 3 axis
            // It is in YXZ order because UI element design use opposite definition
            // of XY axis. To ensure the user see X Y Z, it is flipped here.
            recordAxis(SensorManager.AXIS_Y);
            if (LOCAL_LOGV) Log.v(TAG, ""Controller Thread axis 0 finished."");

            recordAxis(SensorManager.AXIS_X);
            if (LOCAL_LOGV) Log.v(TAG, ""Controller Thread axis 1 finished."");

            recordAxis(SensorManager.AXIS_Z);
            if (LOCAL_LOGV) Log.v(TAG, ""Controller Thread axis 2 finished."");

            delay(1000);
            end();
            if (LOCAL_LOGV) Log.v(TAG, ""Controller Thread End."");
        }

        private void delay(int milli) {
            try{
                Thread.sleep(milli);
            } catch(InterruptedException e) {
                if (LOCAL_LOGV) Log.v(TAG, ""Controller Thread Interrupted."");
            }
        }
        private void init() {
            // start video recording
            mActivity.startRecordVideo();

            // start sensor logging & listening
            mActivity.startRecordSensor();
        }

        private void end() {
            // stop video recording
            mActivity.stopRecordVideo();

            // stop sensor logging
            mActivity.stopRecordSensor();

            // notify ui complete
            runOnUiThread(new Runnable(){
                public void run() {
                    mActivity.notifyComplete();
                }
            });
        }

        private void recordAxis(int axis) {
            // delay 2 seconds?
            delay(1000);

            // change ui
            mActivity.switchAxisAsync(axis);

            // play start sound
            mActivity.playNotifySound(""start"");

            if (axis != SensorManager.AXIS_Z) {
                // wait until axis half covered
                mActivity.waitUntilHalfCovered(axis);

                // play half way sound
                mActivity.playNotifySound(""half-way"");
            }

            // wait until axis covered
            mActivity.waitUntilCovered(axis);

            // play stop sound
            mActivity.playNotifySound(""end"");
        }

        /**
         * Force quit
         */
        public void quit() {
            mThread.interrupt();
            try {
                if (LOCAL_LOGV) Log.v(TAG, ""Wait for controller to end"");

                // stop video recording
                mActivity.stopRecordVideo();

                // stop sensor logging
                mActivity.stopRecordSensor();

            } catch (Exception e)
            {
                e.printStackTrace();
            }
        }
    }

}"	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	""	""
"7.3.2  . Magnetometer"	"7.3.2"	"C-1-10"	"7.3.2/C-1-10"	"07030200.670110"	"""C-1-10] MUST implement the TYPE_MAGNETIC_FIELD_UNCALIBRATED sensor. If device implementations include a 3-axis magnetometer, an accelerometer sensor, and a 3-axis gyroscope sensor, they:"""	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	"android.hardware.cts.helpers.sensorverification.JitterVerification"	"isSensorSamplingRateOverloaded"	"CtsSensorTestCases"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/helpers/sensorverification/JitterVerification.java"	""	"public void test/*
 *.
 */

package android.hardware.cts.helpers.sensorverification;

import android.content.Context;
import android.content.pm.PackageManager;

import android.util.Log;
import android.hardware.Sensor;
import android.hardware.cts.helpers.SensorCtsHelper;
import android.hardware.cts.helpers.SensorStats;
import android.hardware.cts.helpers.TestSensorEnvironment;
import android.hardware.cts.helpers.TestSensorEvent;
import android.util.SparseIntArray;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import junit.framework.Assert;

/**
 * A {@link ISensorVerification} which verifies that the sensor jitter is in an acceptable range.
 */
public class JitterVerification extends AbstractSensorVerification {
    public static final String PASSED_KEY = ""jitter_passed"";

    // sensorType: threshold (% of expected period)
    private static final SparseIntArray DEFAULTS = new SparseIntArray(12);
    // Max allowed jitter in +/- sense (in percentage).
    private static final int GRACE_FACTOR = 2;
    private static final int THRESHOLD_PERCENT_FOR_HIFI_SENSORS = 1 * GRACE_FACTOR;

    // Margin sample intervals that considered outliers, lower and higher margin is discarded
    // before verification
    private static final float OUTLIER_MARGIN = 0.025f; //2.5%

    static {
        // Use a method so that the @deprecation warning can be set for that method only
        setDefaults();
    }

    private final float     mOutlierMargin;
    private final long      mThresholdNs;
    private final long      mExpectedPeriodNs; // for error message only
    private final List<Long> mTimestamps = new LinkedList<Long>();

    /**
     * Construct a {@link JitterVerification}
     *
     * @param thresholdAsPercentage the acceptable margin of error as a percentage
     */
    public JitterVerification(float outlierMargin, long thresholdNs, long expectedPeriodNs) {
        mExpectedPeriodNs = expectedPeriodNs;
        mOutlierMargin = outlierMargin;
        mThresholdNs = thresholdNs;
    }

    /**
     * Get the default {@link JitterVerification} for a sensor.
     *
     * @param environment the test environment
     * @return the verification or null if the verification does not apply to the sensor.
     */
    public static JitterVerification getDefault(TestSensorEnvironment environment) {
        int sensorType = environment.getSensor().getType();

        int thresholdPercent = DEFAULTS.get(sensorType, -1);
        if (thresholdPercent == -1) {
            return null;
        }
        boolean hasHifiSensors = environment.getContext().getPackageManager().hasSystemFeature(
                PackageManager.FEATURE_HIFI_SENSORS);
        if (hasHifiSensors) {
           thresholdPercent = THRESHOLD_PERCENT_FOR_HIFI_SENSORS;
        }

        long expectedPeriodNs = (long) environment.getExpectedSamplingPeriodUs() * 1000;
        long jitterThresholdNs = expectedPeriodNs * thresholdPercent * 2 / 100; // *2 is for +/-
        return new JitterVerification(OUTLIER_MARGIN, jitterThresholdNs, expectedPeriodNs);
    }

    /**
     * Verify that the 95th percentile of the jitter is in the acceptable range. Add
     * {@value #PASSED_KEY} and {@value SensorStats#JITTER_95_PERCENTILE_PERCENT_KEY} keys to
     * {@link SensorStats}.
     *
     * @throws AssertionError if the verification failed.
     */
    @Override
    public void verify(TestSensorEnvironment environment, SensorStats stats) {
        int timestampsCount = mTimestamps.size();
        if (timestampsCount < 2 || environment.isSensorSamplingRateOverloaded()) {
            // the verification is not reliable in environments under load
            stats.addValue(PASSED_KEY, true);
            return;
        }

        List<Long> deltas = getDeltaValues();
        List<Long> percentileValues =
                SensorCtsHelper.getPercentileValue(deltas, mOutlierMargin, 1 - mOutlierMargin);

        double normalizedRange =
                (double)(percentileValues.get(1) - percentileValues.get(0)) / mThresholdNs;

        double percentageJitter =
                (double)(percentileValues.get(1) - percentileValues.get(0)) /
                        mExpectedPeriodNs / 2 * 100; //one side variation comparing to sample time

        stats.addValue(SensorStats.JITTER_95_PERCENTILE_PERCENT_KEY, percentageJitter);

        boolean success = normalizedRange <= 1.0;
        stats.addValue(PASSED_KEY, success);

        if (!success) {
            String message = String.format(
                    ""Jitter out of range: requested period = %dns, "" +
                    ""jitter min, max, range (95th percentile) = (%dns, %dns, %dns), "" +
                    ""jitter expected range <= %dns"",
                    mExpectedPeriodNs,
                    percentileValues.get(0), percentileValues.get(1),
                    percentileValues.get(1) - percentileValues.get(0),
                    mThresholdNs);
            Assert.fail(message);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JitterVerification clone() {
        return new JitterVerification(mOutlierMargin, mThresholdNs, mExpectedPeriodNs);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected void addSensorEventInternal(TestSensorEvent event) {
        mTimestamps.add(event.timestamp);
    }

    /**
     * Get the list of delta values. Exposed for unit testing.
     */
    List<Long> getDeltaValues() {
        List<Long> deltas = new ArrayList<Long>(mTimestamps.size() - 1);
        for (int i = 1; i < mTimestamps.size(); i++) {
            deltas.add(mTimestamps.get(i) - mTimestamps.get(i - 1));
        }
        return deltas;
    }

    @SuppressWarnings(""deprecation"")
    private static void setDefaults() {
        DEFAULTS.put(Sensor.TYPE_ACCELEROMETER, Integer.MAX_VALUE);
        DEFAULTS.put(Sensor.TYPE_MAGNETIC_FIELD, Integer.MAX_VALUE);
        DEFAULTS.put(Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED, Integer.MAX_VALUE);
        DEFAULTS.put(Sensor.TYPE_GYROSCOPE, Integer.MAX_VALUE);
        DEFAULTS.put(Sensor.TYPE_GYROSCOPE_UNCALIBRATED, Integer.MAX_VALUE);
        DEFAULTS.put(Sensor.TYPE_ORIENTATION, Integer.MAX_VALUE);
        DEFAULTS.put(Sensor.TYPE_PRESSURE, Integer.MAX_VALUE);
        DEFAULTS.put(Sensor.TYPE_GRAVITY, Integer.MAX_VALUE);
        DEFAULTS.put(Sensor.TYPE_LINEAR_ACCELERATION, Integer.MAX_VALUE);
        DEFAULTS.put(Sensor.TYPE_ROTATION_VECTOR, Integer.MAX_VALUE);
        DEFAULTS.put(Sensor.TYPE_GAME_ROTATION_VECTOR, Integer.MAX_VALUE);
        DEFAULTS.put(Sensor.TYPE_GEOMAGNETIC_ROTATION_VECTOR, Integer.MAX_VALUE);
    }
}"	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	""	""
"7.3.2  . Magnetometer"	"7.3.2"	"C-1-10"	"7.3.2/C-1-10"	"07030200.670110"	"""C-1-10] MUST implement the TYPE_MAGNETIC_FIELD_UNCALIBRATED sensor. If device implementations include a 3-axis magnetometer, an accelerometer sensor, and a 3-axis gyroscope sensor, they:"""	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	"android.hardware.cts.helpers.sensorverification.OffsetVerification"	"isEmpty"	"CtsSensorTestCases"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/helpers/sensorverification/OffsetVerification.java"	""	"public void test/*
 *.
 */

package android.hardware.cts.helpers.sensorverification;

import android.hardware.Sensor;
import android.hardware.cts.helpers.SensorCtsHelper;
import android.hardware.cts.helpers.SensorStats;
import android.hardware.cts.helpers.SensorTestWarningException;
import android.hardware.cts.helpers.TestSensorEnvironment;
import android.hardware.cts.helpers.TestSensorEvent;

import java.util.Arrays;
import java.util.ArrayList;
import java.util.Collections;
import junit.framework.Assert;

/**
 * A {@link ISensorVerification} which verifies that the offset for a sensor event is
 * within range.
 */
public class OffsetVerification extends AbstractSensorVerification {
    public static final String PASSED_KEY = ""offset_passed"";

    // Number of indices to print in assert message before truncating
    private static final int TRUNCATE_MESSAGE_LENGTH = 3;

    // CDD 7.3.2/C1-5: Magnetometer must have a hard iron offset value less than 700uT
    private static final float MAGNETOMETER_MAXIMUM_OFFSET_UT = 700.0f;

    // Threshold to allow for the actual offsets to vary slightly from the CDD limit in order to
    // account for rounding errors.
    private static final float ALLOWED_ERROR_PERCENT = 0.0001f;

    private ArrayList<TestSensorEvent> mInvalidSamples;
    private float mMaximumOffset;

    /**
     * Construct a {@link OffsetVerification}
     *
     * @param maximumOffset the maximum allowed magnitude for the sensor event offset
     *                      in units defined by the CDD
     */
    public OffsetVerification(float maximumOffset) {
        mInvalidSamples = new ArrayList<TestSensorEvent>();
        mMaximumOffset = maximumOffset;
    }

    /**
     * Get the default {@link OffsetVerification}.
     *
     * @param environment the test environment
     * @return the verification or null if there is no offset requirement
     */
    public static OffsetVerification getDefault(TestSensorEnvironment environment) {
        if (environment.getSensor().getType() == Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED) {
            return new OffsetVerification(MAGNETOMETER_MAXIMUM_OFFSET_UT);
        }
        return null;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void verify(TestSensorEnvironment environment, SensorStats stats) {
        verify(stats);
    }

    /**
     * Visible for unit tests only.
     */
    protected void verify(SensorStats stats) {
        boolean pass = mInvalidSamples.isEmpty();

        stats.addValue(PASSED_KEY, pass);

        if (!pass) {
            StringBuilder sb = new StringBuilder();
            sb.append(""Magnetometer must have a hard iron offset value less than "")
                .append(mMaximumOffset).append("" example sample: "").append(mInvalidSamples.get(0));
            // TODO(b/146757096): Make this an assert once OEMs have had enough
            // time to react to seeing the new warning.
            throw new SensorTestWarningException(sb.toString());
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public OffsetVerification clone() {
        return new OffsetVerification(mMaximumOffset);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected void addSensorEventInternal(TestSensorEvent event) {
        // Uncalibrated SensorEvent objects contain the bias in values[3], values[4] and values[5].
        float[] offsets = Arrays.copyOfRange(event.values, 3, 6);
        float maxOffsetWithError = mMaximumOffset * (1.0f + ALLOWED_ERROR_PERCENT);
        for (float offset : offsets) {
            if (offset > maxOffsetWithError) {
                mInvalidSamples.add(event);
            }
        }
    }
}"	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	""	""
"7.3.2  . Magnetometer"	"7.3.2"	"C-1-10"	"7.3.2/C-1-10"	"07030200.670110"	"""C-1-10] MUST implement the TYPE_MAGNETIC_FIELD_UNCALIBRATED sensor. If device implementations include a 3-axis magnetometer, an accelerometer sensor, and a 3-axis gyroscope sensor, they:"""	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	"android.hardware.cts.SensorDirectReportTest"	"testRateIndependencyMagUncalMagSingleChannel"	"CtsSensorTestCases"	"/home/gpoor/cts-12-source/cts/tests/sensor/src/android/hardware/cts/SensorDirectReportTest.java"	""	"public void testRateIndependencyMagUncalMagSingleChannel() {
        runSingleChannelRateIndependencyTestGroup(Sensor.TYPE_MAGNETIC_FIELD,
                                             Sensor.TYPE_MAGNETIC_FIELD_UNCALIBRATED);
    }"	""	""	"TYPE_MAGNETIC_FIELD_UNCALIBRATED TYPE_MAGNETIC_FIELD_UNCALIBRATED"	""	""	""	""	""	""	""	""	""	""
