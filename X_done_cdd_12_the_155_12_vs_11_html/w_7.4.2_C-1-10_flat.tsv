"Section"	"section_id"	"req_id"	"full_key"	"key_as_number"	"requirement"	"Test Availability"	"search_roots"	"search_terms"	"manual_search_terms"	"not_search_terms"	"not_files"	"max_matches"	"class_defs"	"methods"	"modules"	"protected"	"class_def"	"method"	"module"	"file_name"	"matched_files"	"methods_string"	"urls"	"method_text"	"matched_terms"	"qualified_method"	"Annotation?"	"New Req for S?"	"New CTS for S?"	"Comment(internal) e.g. why a test is not possible"	"CTS Bug Id"	"CDD Bug Id"	"Area"	"Shortened"	"Test Level"
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	Test Available	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConnectedNetworkScorerTest"	"testWifiUsabilityStatsEntry"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConnectedNetworkScorerTest.java"	""	"public void testWifiUsabilityStatsEntry() throws Exception {
        // Usability stats collection only supported by vendor version Q and above.
        if (!PropertyUtil.isVendorApiLevelAtLeast(Build.VERSION_CODES.Q)) {
            return;
        }
        CountDownLatch countDownLatch = new CountDownLatch(1);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        TestUsabilityStatsListener usabilityStatsListener =
                new TestUsabilityStatsListener(countDownLatch);
        try {
            uiAutomation.adoptShellPermissionIdentity();
            mWifiManager.addOnWifiUsabilityStatsListener(
                    Executors.newSingleThreadExecutor(), usabilityStatsListener);
            // Wait for new usability stats (while connected & screen on this is triggered
            // by platform periodically).
            assertThat(countDownLatch.await(TIMEOUT, TimeUnit.MILLISECONDS)).isTrue();

            assertThat(usabilityStatsListener.statsEntry).isNotNull();
            WifiUsabilityStatsEntry statsEntry = usabilityStatsListener.statsEntry;

            assertThat(statsEntry.getTimeStampMillis()).isGreaterThan(0L);
            assertThat(statsEntry.getRssi()).isLessThan(0);
            assertThat(statsEntry.getLinkSpeedMbps()).isAtLeast(0);
            assertThat(statsEntry.getTotalTxSuccess()).isAtLeast(0L);
            assertThat(statsEntry.getTotalTxRetries()).isAtLeast(0L);
            assertThat(statsEntry.getTotalTxBad()).isAtLeast(0L);
            assertThat(statsEntry.getTotalRxSuccess()).isAtLeast(0L);
            if (mWifiManager.isEnhancedPowerReportingSupported()) {
                assertThat(statsEntry.getTotalRadioOnTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalRadioTxTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalRadioRxTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalScanTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalNanScanTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalBackgroundScanTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalRoamScanTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalPnoScanTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalHotspot2ScanTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalCcaBusyFreqTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalRadioOnTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalRadioOnFreqTimeMillis()).isAtLeast(0L);
                assertThat(statsEntry.getTotalBeaconRx()).isAtLeast(0L);
                assertThat(statsEntry.getProbeStatusSinceLastUpdate())
                        .isAnyOf(PROBE_STATUS_SUCCESS,
                                PROBE_STATUS_FAILURE,
                                PROBE_STATUS_NO_PROBE,
                                PROBE_STATUS_UNKNOWN);
                // -1 is default value for some of these fields if they're not available.
                assertThat(statsEntry.getProbeElapsedTimeSinceLastUpdateMillis()).isAtLeast(-1);
                assertThat(statsEntry.getProbeMcsRateSinceLastUpdate()).isAtLeast(-1);
                assertThat(statsEntry.getRxLinkSpeedMbps()).isAtLeast(-1);
                if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                    try {
                        assertThat(statsEntry.getTimeSliceDutyCycleInPercent())
                                .isIn(Range.closed(0, 100));
                    } catch (NoSuchElementException e) {
                        // pass - Device does not support the field.
                    }
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_BE).getContentionTimeMinMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_BE).getContentionTimeMaxMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_BE).getContentionTimeAvgMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_BE).getContentionNumSamples()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_BK).getContentionTimeMinMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_BK).getContentionTimeMaxMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_BK).getContentionTimeAvgMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_BK).getContentionNumSamples()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_VI).getContentionTimeMinMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_VI).getContentionTimeMaxMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_VI).getContentionTimeAvgMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_VI).getContentionNumSamples()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_VO).getContentionTimeMinMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_VO).getContentionTimeMaxMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_VO).getContentionTimeAvgMicros()).isAtLeast(0);
                    assertThat(statsEntry.getContentionTimeStats(
                            WME_ACCESS_CATEGORY_VO).getContentionNumSamples()).isAtLeast(0);
                    // This is to add CTS test for the constructor function.
                    ContentionTimeStats contentionStats = new ContentionTimeStats(2, 1, 4, 10);
                    assertEquals(2, contentionStats.getContentionTimeMinMicros());
                    assertEquals(1, contentionStats.getContentionTimeMaxMicros());
                    assertEquals(4, contentionStats.getContentionTimeAvgMicros());
                    assertEquals(10, contentionStats.getContentionNumSamples());
                    assertThat(statsEntry.getChannelUtilizationRatio()).isIn(Range.closed(0, 255));
                    if (mTelephonyManager != null) {
                        boolean isCellularDataAvailable =
                                mTelephonyManager.getDataState() == TelephonyManager.DATA_CONNECTED;
                        assertEquals(isCellularDataAvailable, statsEntry.isCellularDataAvailable());
                    } else {
                        assertFalse(statsEntry.isCellularDataAvailable());
                    }
                    statsEntry.isWifiScoringEnabled();
                    statsEntry.isThroughputSufficient();
                    RateStats rateStats = new RateStats(WifiUsabilityStatsEntry.WIFI_PREAMBLE_VHT,
                            WifiUsabilityStatsEntry.WIFI_SPATIAL_STREAMS_TWO,
                            WifiUsabilityStatsEntry.WIFI_BANDWIDTH_40_MHZ,
                            2, 20, 100, 200, 5, 10);
                    assertThat(statsEntry.getRateStats()).isNotNull();
                    if(statsEntry.getRateStats().size() > 0) {
                        assertThat(statsEntry.getRateStats().get(0).getPreamble()).isAtLeast(0);
                        assertThat(statsEntry.getRateStats().get(0).getNumberOfSpatialStreams())
                                .isAtLeast(1);
                        assertThat(statsEntry.getRateStats().get(0).getBandwidthInMhz())
                                .isAtLeast(0);
                        assertThat(statsEntry.getRateStats().get(0).getRateMcsIdx()).isAtLeast(0);
                        assertThat(statsEntry.getRateStats().get(0).getBitRateInKbps())
                                .isAtLeast(0);
                        assertThat(statsEntry.getRateStats().get(0).getTxMpdu()).isAtLeast(0);
                        assertThat(statsEntry.getRateStats().get(0).getRxMpdu()).isAtLeast(0);
                        assertThat(statsEntry.getRateStats().get(0).getMpduLost()).isAtLeast(0);
                        assertThat(statsEntry.getRateStats().get(0).getRetries()).isAtLeast(0);
                    }
                    RadioStats radioStat = new RadioStats(0, 10, 11, 12, 13, 14, 15, 16, 17, 18);
                    assertThat(statsEntry.getWifiLinkLayerRadioStats()).isNotNull();
                    int numRadios = statsEntry.getWifiLinkLayerRadioStats().size();
                    for (int i = 0; i < numRadios; i++) {
                        RadioStats radioStats = statsEntry.getWifiLinkLayerRadioStats().get(i);
                        assertThat(radioStats.getRadioId()).isAtLeast(0);
                        assertThat(radioStats.getTotalRadioOnTimeMillis()).isAtLeast(0);
                        assertThat(radioStats.getTotalRadioTxTimeMillis()).isAtLeast(0);
                        assertThat(radioStats.getTotalRadioRxTimeMillis()).isAtLeast(0);
                        assertThat(radioStats.getTotalScanTimeMillis()).isAtLeast(0);
                        assertThat(radioStats.getTotalNanScanTimeMillis()).isAtLeast(0);
                        assertThat(radioStats.getTotalBackgroundScanTimeMillis()).isAtLeast(0);
                        assertThat(radioStats.getTotalRoamScanTimeMillis()).isAtLeast(0);
                        assertThat(radioStats.getTotalPnoScanTimeMillis()).isAtLeast(0);
                        assertThat(radioStats.getTotalHotspot2ScanTimeMillis()).isAtLeast(0);
                    }
                }
                // no longer populated, return default value.
                assertThat(statsEntry.getCellularDataNetworkType())
                        .isAnyOf(TelephonyManager.NETWORK_TYPE_UNKNOWN,
                                TelephonyManager.NETWORK_TYPE_GPRS,
                                TelephonyManager.NETWORK_TYPE_EDGE,
                                TelephonyManager.NETWORK_TYPE_UMTS,
                                TelephonyManager.NETWORK_TYPE_CDMA,
                                TelephonyManager.NETWORK_TYPE_EVDO_0,
                                TelephonyManager.NETWORK_TYPE_EVDO_A,
                                TelephonyManager.NETWORK_TYPE_1xRTT,
                                TelephonyManager.NETWORK_TYPE_HSDPA,
                                TelephonyManager.NETWORK_TYPE_HSUPA,
                                TelephonyManager.NETWORK_TYPE_HSPA,
                                TelephonyManager.NETWORK_TYPE_IDEN,
                                TelephonyManager.NETWORK_TYPE_EVDO_B,
                                TelephonyManager.NETWORK_TYPE_LTE,
                                TelephonyManager.NETWORK_TYPE_EHRPD,
                                TelephonyManager.NETWORK_TYPE_HSPAP,
                                TelephonyManager.NETWORK_TYPE_GSM,
                                TelephonyManager.NETWORK_TYPE_TD_SCDMA,
                                TelephonyManager.NETWORK_TYPE_IWLAN,
                                TelephonyManager.NETWORK_TYPE_NR);
                assertThat(statsEntry.getCellularSignalStrengthDbm()).isAtMost(0);
                assertThat(statsEntry.getCellularSignalStrengthDb()).isAtMost(0);
                assertThat(statsEntry.isSameRegisteredCell()).isFalse();
            }
        } finally {
            mWifiManager.removeOnWifiUsabilityStatsListener(usabilityStatsListener);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests the {@link android.net.wifi.WifiManager#updateWifiUsabilityScore(int, int, int)}
     */"	""	""	"scan probe"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	Test Available	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ConnectedNetworkScorerTest"	"isNotNull"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ConnectedNetworkScorerTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.Manifest.permission.CONNECTIVITY_INTERNAL;
import static android.Manifest.permission.NETWORK_SETTINGS;
import static android.Manifest.permission.READ_WIFI_CREDENTIAL;
import static android.Manifest.permission.WIFI_UPDATE_USABILITY_STATS_SCORE;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PAID;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PRIVATE;
import static android.net.wifi.WifiUsabilityStatsEntry.ContentionTimeStats;
import static android.net.wifi.WifiUsabilityStatsEntry.RadioStats;
import static android.net.wifi.WifiUsabilityStatsEntry.RateStats;
import static android.net.wifi.WifiUsabilityStatsEntry.PROBE_STATUS_FAILURE;
import static android.net.wifi.WifiUsabilityStatsEntry.PROBE_STATUS_NO_PROBE;
import static android.net.wifi.WifiUsabilityStatsEntry.PROBE_STATUS_SUCCESS;
import static android.net.wifi.WifiUsabilityStatsEntry.PROBE_STATUS_UNKNOWN;
import static android.net.wifi.WifiUsabilityStatsEntry.WME_ACCESS_CATEGORY_BE;
import static android.net.wifi.WifiUsabilityStatsEntry.WME_ACCESS_CATEGORY_BK;
import static android.net.wifi.WifiUsabilityStatsEntry.WME_ACCESS_CATEGORY_VI;
import static android.net.wifi.WifiUsabilityStatsEntry.WME_ACCESS_CATEGORY_VO;
import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import android.annotation.NonNull;
import android.app.UiAutomation;
import android.content.Context;
import android.net.ConnectivityManager;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSpecifier;
import android.net.wifi.WifiNetworkSuggestion;
import android.net.wifi.WifiUsabilityStatsEntry;
import android.net.wifi.WifiConnectedSessionInfo;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;
import android.telephony.TelephonyManager;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.LargeTest;
import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.PropertyUtil;
import com.android.compatibility.common.util.ShellIdentityUtils;

import com.google.common.collect.Range;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Tests for wifi connected network scorer interface and usability stats.
 */
@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@LargeTest
@RunWith(AndroidJUnit4.class)
public class ConnectedNetworkScorerTest extends WifiJUnit4TestBase {
    private Context mContext;
    private WifiManager mWifiManager;
    private ConnectivityManager mConnectivityManager;
    private UiDevice mUiDevice;
    private TestHelper mTestHelper;
    private TelephonyManager mTelephonyManager;

    private boolean mWasVerboseLoggingEnabled;

    private static final int WIFI_CONNECT_TIMEOUT_MILLIS = 30_000;
    private static final int TIMEOUT = 12_000;
    private static final int WAIT_DURATION = 5_000;

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getContext();

        // skip the test if WiFi is not supported
        assumeTrue(WifiFeature.isWifiSupported(mContext));

        mWifiManager = mContext.getSystemService(WifiManager.class);
        assertThat(mWifiManager).isNotNull();

        mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));

        // enable Wifi
        if (!mWifiManager.isWifiEnabled()) {
            ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.setWifiEnabled(true));
        }
        PollingCheck.check(""Wifi not enabled"", TIMEOUT, () -> mWifiManager.isWifiEnabled());

        // turn screen on
        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());

        mTestHelper = new TestHelper(mContext, mUiDevice);
        mTestHelper.turnScreenOn();

        // Clear any existing app state before each test.
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            ShellIdentityUtils.invokeWithShellPermissions(
                    () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));
        }

        // check we have >= 1 saved network
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.getConfiguredNetworks());
        assertWithMessage(""Need at least one saved network"").that(savedNetworks).isNotEmpty();

        // ensure Wifi is connected
        ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.reconnect());
        PollingCheck.check(
                ""Wifi not connected"",
                WIFI_CONNECT_TIMEOUT_MILLIS,
                () -> mWifiManager.getConnectionInfo().getNetworkId() != -1);
        mTelephonyManager = mContext.getSystemService(TelephonyManager.class);
    }

    @After
    public void tearDown() throws Exception {
        if (!WifiFeature.isWifiSupported(mContext)) return;
        if (!mWifiManager.isWifiEnabled()) {
            ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.setWifiEnabled(true));
        }
        mTestHelper.turnScreenOff();
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));
    }

    private static class TestUsabilityStatsListener implements
            WifiManager.OnWifiUsabilityStatsListener {
        private final CountDownLatch mCountDownLatch;
        public int seqNum;
        public boolean isSameBssidAndFre;
        public WifiUsabilityStatsEntry statsEntry;

        TestUsabilityStatsListener(CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onWifiUsabilityStats(int seqNum, boolean isSameBssidAndFreq,
                WifiUsabilityStatsEntry statsEntry) {
            this.seqNum = seqNum;
            this.isSameBssidAndFre = isSameBssidAndFreq;
            this.statsEntry = statsEntry;
            mCountDownLatch.countDown();
        }
    }

    /**
     * Tests the {@link android.net.wifi.WifiUsabilityStatsEntry} retrieved from
     * {@link WifiManager.OnWifiUsabilityStatsListener}.
     */"	""	""	"probe"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"ProvisioningCallback"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_METERED;
import static android.net.NetworkCapabilities.TRANSPORT_WIFI;
import static android.net.wifi.WifiAvailableChannel.OP_MODE_SAP;
import static android.net.wifi.WifiAvailableChannel.OP_MODE_STA;
import static android.net.wifi.WifiConfiguration.INVALID_NETWORK_ID;
import static android.net.wifi.WifiManager.COEX_RESTRICTION_SOFTAP;
import static android.net.wifi.WifiManager.COEX_RESTRICTION_WIFI_AWARE;
import static android.net.wifi.WifiManager.COEX_RESTRICTION_WIFI_DIRECT;
import static android.net.wifi.WifiScanner.WIFI_BAND_24_GHZ;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.assertNotEquals;

import android.annotation.NonNull;
import android.app.UiAutomation;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.pm.ResolveInfo;
import android.net.ConnectivityManager;
import android.net.MacAddress;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkInfo;
import android.net.NetworkRequest;
import android.net.TetheringManager;
import android.net.Uri;
import android.net.wifi.CoexUnsafeChannel;
import android.net.wifi.ScanResult;
import android.net.wifi.SoftApCapability;
import android.net.wifi.SoftApConfiguration;
import android.net.wifi.SoftApInfo;
import android.net.wifi.WifiAvailableChannel;
import android.net.wifi.WifiClient;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiEnterpriseConfig;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiManager.SubsystemRestartTrackingCallback;
import android.net.wifi.WifiManager.WifiLock;
import android.net.wifi.WifiNetworkConnectionStatistics;
import android.net.wifi.WifiNetworkSuggestion;
import android.net.wifi.hotspot2.ConfigParser;
import android.net.wifi.hotspot2.OsuProvider;
import android.net.wifi.hotspot2.PasspointConfiguration;
import android.net.wifi.hotspot2.ProvisioningCallback;
import android.net.wifi.hotspot2.pps.Credential;
import android.net.wifi.hotspot2.pps.HomeSp;
import android.os.Build;
import android.os.Handler;
import android.os.HandlerExecutor;
import android.os.HandlerThread;
import android.os.Process;
import android.os.SystemClock;
import android.os.UserHandle;
import android.platform.test.annotations.AppModeFull;
import android.platform.test.annotations.AsbSecurityTest;
import android.provider.Settings;
import android.support.test.uiautomator.UiDevice;
import android.telephony.TelephonyManager;
import android.text.TextUtils;
import android.util.ArraySet;
import android.util.Log;
import android.util.SparseArray;
import android.util.SparseIntArray;

import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.FeatureUtil;
import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.PropertyUtil;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;
import com.android.compatibility.common.util.ThrowingRunnable;
import com.android.modules.utils.build.SdkLevel;
import com.android.net.module.util.MacAddressUtils;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Constructor;
import java.net.HttpURLConnection;
import java.net.InetAddress;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
public class WifiManagerTest extends WifiJUnit3TestBase {
    private static class MySync {
        int expectedState = STATE_NULL;
    }

    private WifiManager mWifiManager;
    private ConnectivityManager mConnectivityManager;
    private TetheringManager mTetheringManager;
    private WifiLock mWifiLock;
    private static MySync mMySync;
    private List<ScanResult> mScanResults = null;
    private NetworkInfo mNetworkInfo =
            new NetworkInfo(ConnectivityManager.TYPE_WIFI, TelephonyManager.NETWORK_TYPE_UNKNOWN,
                    ""wifi"", ""unknown"");
    private final Object mLock = new Object();
    private UiDevice mUiDevice;
    private boolean mWasVerboseLoggingEnabled;
    private boolean mWasScanThrottleEnabled;
    private SoftApConfiguration mOriginalSoftApConfig = null;

    // Please refer to WifiManager
    private static final int MIN_RSSI = -100;
    private static final int MAX_RSSI = -55;

    private static final int STATE_NULL = 0;
    private static final int STATE_WIFI_CHANGING = 1;
    private static final int STATE_WIFI_ENABLED = 2;
    private static final int STATE_WIFI_DISABLED = 3;
    private static final int STATE_SCANNING = 4;
    private static final int STATE_SCAN_DONE = 5;

    private static final String TAG = ""WifiManagerTest"";
    private static final String SSID1 = ""\""WifiManagerTest\"""";
    // A full single scan duration is about 6-7 seconds if country code is set
    // to US. If country code is set to world mode (00), we would expect a scan
    // duration of roughly 8 seconds. So we set scan timeout as 9 seconds here.
    private static final int SCAN_TEST_WAIT_DURATION_MS = 9000;
    private static final int TEST_WAIT_DURATION_MS = 10_000;
    private static final int WIFI_CONNECT_TIMEOUT_MILLIS = 30_000;
    private static final int WAIT_MSEC = 60;
    private static final int DURATION_SCREEN_TOGGLE = 2000;
    private static final int DURATION_SETTINGS_TOGGLE = 1_000;
    private static final int WIFI_SCAN_TEST_CACHE_DELAY_MILLIS = 3 * 60 * 1000;

    private static final int ENFORCED_NUM_NETWORK_SUGGESTIONS_PER_APP = 50;

    private static final String TEST_PAC_URL = ""http://www.example.com/proxy.pac"";
    private static final String MANAGED_PROVISIONING_PACKAGE_NAME
            = ""com.android.managedprovisioning"";

    private static final String TEST_SSID_UNQUOTED = ""testSsid1"";
    private static final String TEST_IP_ADDRESS = ""192.168.5.5"";
    private static final String TEST_MAC_ADDRESS = ""aa:bb:cc:dd:ee:ff"";
    private static final MacAddress TEST_MAC = MacAddress.fromString(TEST_MAC_ADDRESS);
    private static final String TEST_PASSPHRASE = ""passphrase"";
    private static final String PASSPOINT_INSTALLATION_FILE_WITH_CA_CERT =
            ""assets/ValidPasspointProfile.base64"";
    private static final String TYPE_WIFI_CONFIG = ""application/x-wifi-config"";
    private static final String TEST_PSK_CAP = ""[RSN-PSK-CCMP]"";
    private static final String TEST_BSSID = ""00:01:02:03:04:05"";
    private static final String TEST_COUNTRY_CODE = ""JP"";
    private static final String TEST_DOM_SUBJECT_MATCH = ""domSubjectMatch"";
    private static final int TEST_SUB_ID = 2;

    private IntentFilter mIntentFilter;
    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            final String action = intent.getAction();
            if (action.equals(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION)) {

                synchronized (mMySync) {
                    if (intent.getBooleanExtra(WifiManager.EXTRA_RESULTS_UPDATED, false)) {
                        mScanResults = mWifiManager.getScanResults();
                    } else {
                        mScanResults = null;
                    }
                    mMySync.expectedState = STATE_SCAN_DONE;
                    mMySync.notifyAll();
                }
            } else if (action.equals(WifiManager.WIFI_STATE_CHANGED_ACTION)) {
                int newState = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE,
                        WifiManager.WIFI_STATE_UNKNOWN);
                synchronized (mMySync) {
                    if (newState == WifiManager.WIFI_STATE_ENABLED) {
                        Log.d(TAG, ""*** New WiFi state is ENABLED ***"");
                        mMySync.expectedState = STATE_WIFI_ENABLED;
                        mMySync.notifyAll();
                    } else if (newState == WifiManager.WIFI_STATE_DISABLED) {
                        Log.d(TAG, ""*** New WiFi state is DISABLED ***"");
                        mMySync.expectedState = STATE_WIFI_DISABLED;
                        mMySync.notifyAll();
                    }
                }
            } else if (action.equals(WifiManager.NETWORK_STATE_CHANGED_ACTION)) {
                synchronized (mMySync) {
                    mNetworkInfo =
                            (NetworkInfo) intent.getParcelableExtra(WifiManager.EXTRA_NETWORK_INFO);
                    if (mNetworkInfo.getState() == NetworkInfo.State.CONNECTED)
                        mMySync.notifyAll();
                }
            }
        }
    };
    // Initialize with an invalid status value (0)
    private int mProvisioningStatus = 0;
    // Initialize with an invalid status value (0)
    private int mProvisioningFailureStatus = 0;
    private boolean mProvisioningComplete = false;
    private ProvisioningCallback mProvisioningCallback = new ProvisioningCallback() {
        @Override
        public void onProvisioningFailure(int status) {
            synchronized (mLock) {
                mProvisioningFailureStatus = status;
                mLock.notify();
            }
        }

        @Override
        public void onProvisioningStatus(int status) {
            synchronized (mLock) {
                mProvisioningStatus = status;
                mLock.notify();
            }
        }

        @Override
        public void onProvisioningComplete() {
            mProvisioningComplete = true;
        }
    };
    private int mSubsystemRestartStatus = 0; // 0: nada, 1: restarting, 2: restarted
    private SubsystemRestartTrackingCallback mSubsystemRestartTrackingCallback =
            new SubsystemRestartTrackingCallback() {
                @Override
                public void onSubsystemRestarting() {
                    synchronized (mLock) {
                        mSubsystemRestartStatus = 1;
                        mLock.notify();
                    }
                }

                @Override
                public void onSubsystemRestarted() {
                    synchronized (mLock) {
                        mSubsystemRestartStatus = 2;
                        mLock.notify();
                    }
                }
            };
    private static final String TEST_SSID = ""TEST SSID"";
    private static final String TEST_FRIENDLY_NAME = ""Friendly Name"";
    private static final Map<String, String> TEST_FRIENDLY_NAMES =
            new HashMap<String, String>() {
                {
                    put(""en"", TEST_FRIENDLY_NAME);
                    put(""kr"", TEST_FRIENDLY_NAME + 2);
                    put(""jp"", TEST_FRIENDLY_NAME + 3);
                }
            };
    private static final String TEST_SERVICE_DESCRIPTION = ""Dummy Service"";
    private static final Uri TEST_SERVER_URI = Uri.parse(""https://test.com"");
    private static final String TEST_NAI = ""test.access.com"";
    private static final List<Integer> TEST_METHOD_LIST =
            Arrays.asList(1 /* METHOD_SOAP_XML_SPP */);
    private final HandlerThread mHandlerThread = new HandlerThread(""WifiManagerTest"");
    protected final Executor mExecutor;
    {
        mHandlerThread.start();
        mExecutor = new HandlerExecutor(new Handler(mHandlerThread.getLooper()));
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mMySync = new MySync();
        mIntentFilter = new IntentFilter();
        mIntentFilter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION);
        mIntentFilter.addAction(WifiManager.SUPPLICANT_CONNECTION_CHANGE_ACTION);
        mIntentFilter.addAction(WifiManager.SUPPLICANT_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.RSSI_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.NETWORK_IDS_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.ACTION_PICK_WIFI_NETWORK);

        mContext.registerReceiver(mReceiver, mIntentFilter);
        mWifiManager = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        mConnectivityManager = getContext().getSystemService(ConnectivityManager.class);
        mTetheringManager = getContext().getSystemService(TetheringManager.class);
        assertNotNull(mWifiManager);
        assertNotNull(mTetheringManager);

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        mWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(false));

        mWifiLock = mWifiManager.createWifiLock(TAG);
        mWifiLock.acquire();
        // enable Wifi
        if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);
        PollingCheck.check(""Wifi not enabled"", TEST_WAIT_DURATION_MS,
                () -> mWifiManager.isWifiEnabled());

        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        turnScreenOnNoDelay();

        synchronized (mMySync) {
            mMySync.expectedState = STATE_NULL;
        }

        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getConfiguredNetworks);
        assertFalse(""Need at least one saved network"", savedNetworks.isEmpty());

        // Get original config for restore
        mOriginalSoftApConfig = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getSoftApConfiguration);
    }

    @Override
    protected void tearDown() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            super.tearDown();
            return;
        }
        if (!mWifiManager.isWifiEnabled())
            setWifiEnabled(true);
        mWifiLock.release();
        mContext.unregisterReceiver(mReceiver);
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(mWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));
        // restore original softap config
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setSoftApConfiguration(mOriginalSoftApConfig));
        Thread.sleep(TEST_WAIT_DURATION_MS);
        super.tearDown();
    }

    private void setWifiEnabled(boolean enable) throws Exception {
        synchronized (mMySync) {
            if (mWifiManager.isWifiEnabled() != enable) {
                // the new state is different, we expect it to change
                mMySync.expectedState = STATE_WIFI_CHANGING;
            } else {
                mMySync.expectedState = (enable ? STATE_WIFI_ENABLED : STATE_WIFI_DISABLED);
            }
            // now trigger the change using shell commands.
            SystemUtil.runShellCommand(""svc wifi "" + (enable ? ""enable"" : ""disable""));
            waitForExpectedWifiState(enable);
        }
    }

    private void waitForExpectedWifiState(boolean enabled) throws InterruptedException {
        synchronized (mMySync) {
            long timeout = System.currentTimeMillis() + TEST_WAIT_DURATION_MS;
            int expected = (enabled ? STATE_WIFI_ENABLED : STATE_WIFI_DISABLED);
            while (System.currentTimeMillis() < timeout
                    && mMySync.expectedState != expected) {
                mMySync.wait(WAIT_MSEC);
            }
        }
    }

    // Get the current scan status from sticky broadcast.
    private boolean isScanCurrentlyAvailable() {
        IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(WifiManager.ACTION_WIFI_SCAN_AVAILABILITY_CHANGED);
        Intent intent = mContext.registerReceiver(null, intentFilter);
        assertNotNull(intent);
        if (intent.getAction().equals(WifiManager.ACTION_WIFI_SCAN_AVAILABILITY_CHANGED)) {
            return intent.getBooleanExtra(WifiManager.EXTRA_SCAN_AVAILABLE, false);
        }
        return false;
    }

    private void startScan() throws Exception {
        synchronized (mMySync) {
            mMySync.expectedState = STATE_SCANNING;
            mScanResults = null;
            assertTrue(mWifiManager.startScan());
            long timeout = System.currentTimeMillis() + SCAN_TEST_WAIT_DURATION_MS;
            while (System.currentTimeMillis() < timeout && mMySync.expectedState == STATE_SCANNING)
                mMySync.wait(WAIT_MSEC);
        }
    }

    private void waitForNetworkInfoState(NetworkInfo.State state, int timeoutMillis)
            throws Exception {
        synchronized (mMySync) {
            if (mNetworkInfo.getState() == state) return;
            long timeout = System.currentTimeMillis() + timeoutMillis;
            while (System.currentTimeMillis() < timeout
                    && mNetworkInfo.getState() != state)
                mMySync.wait(WAIT_MSEC);
            assertEquals(state, mNetworkInfo.getState());
        }
    }

    private void waitForConnection() throws Exception {
        waitForNetworkInfoState(NetworkInfo.State.CONNECTED, WIFI_CONNECT_TIMEOUT_MILLIS);
    }

    private void waitForDisconnection() throws Exception {
        waitForNetworkInfoState(NetworkInfo.State.DISCONNECTED, TEST_WAIT_DURATION_MS);
    }

    private void ensureNotNetworkInfoState(NetworkInfo.State state) throws Exception {
        synchronized (mMySync) {
            long timeout = System.currentTimeMillis() + TEST_WAIT_DURATION_MS + WAIT_MSEC;
            while (System.currentTimeMillis() < timeout) {
                assertNotEquals(state, mNetworkInfo.getState());
                mMySync.wait(WAIT_MSEC);
            }
        }
    }

    private void ensureNotConnected() throws Exception {
        ensureNotNetworkInfoState(NetworkInfo.State.CONNECTED);
    }

    private void ensureNotDisconnected() throws Exception {
        ensureNotNetworkInfoState(NetworkInfo.State.DISCONNECTED);
    }

    private boolean existSSID(String ssid) {
        for (final WifiConfiguration w : mWifiManager.getConfiguredNetworks()) {
            if (w.SSID.equals(ssid))
                return true;
        }
        return false;
    }

    private int findConfiguredNetworks(String SSID, List<WifiConfiguration> networks) {
        for (final WifiConfiguration w : networks) {
            if (w.SSID.equals(SSID))
                return networks.indexOf(w);
        }
        return -1;
    }

    /**
     * Test creation of WifiManager Lock.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testWifiManagerLock"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testWifiManagerLock() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        final String TAG = ""Test"";
        assertNotNull(mWifiManager.createWifiLock(TAG));
        assertNotNull(mWifiManager.createWifiLock(WifiManager.WIFI_MODE_FULL, TAG));
    }

    /**
     * Test wifi scanning when Wifi is off and location scanning is turned on.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testWifiManagerScanWhenWifiOffLocationTurnedOn"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testWifiManagerScanWhenWifiOffLocationTurnedOn() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!hasLocationFeature()) {
            Log.d(TAG, ""Skipping test as location is not supported"");
            return;
        }
        if (!isLocationEnabled()) {
            fail(""Please enable location for this test - since Marshmallow WiFi scan results are""
                    + "" empty when location is disabled!"");
        }
        runWithScanningEnabled(() -> {
            setWifiEnabled(false);
            Thread.sleep(TEST_WAIT_DURATION_MS);
            startScan();
            if (mWifiManager.isScanAlwaysAvailable() && isScanCurrentlyAvailable()) {
                // Make sure at least one AP is found.
                assertNotNull(""mScanResult should not be null!"", mScanResults);
                assertFalse(""empty scan results!"", mScanResults.isEmpty());
            } else {
                // Make sure no scan results are available.
                assertNull(""mScanResult should be null!"", mScanResults);
            }
            final String TAG = ""Test"";
            assertNotNull(mWifiManager.createWifiLock(TAG));
            assertNotNull(mWifiManager.createWifiLock(WifiManager.WIFI_MODE_FULL, TAG));
        });
    }

    /**
     * Restart WiFi subsystem - verify that privileged call fails.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testWifiManagerProperties"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testWifiManagerProperties() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        setWifiEnabled(true);
        assertTrue(mWifiManager.isWifiEnabled());
        assertNotNull(mWifiManager.getDhcpInfo());
        assertEquals(WifiManager.WIFI_STATE_ENABLED, mWifiManager.getWifiState());
        mWifiManager.getConnectionInfo();
        setWifiEnabled(false);
        assertFalse(mWifiManager.isWifiEnabled());
    }

    /**
     * Test WiFi scan timestamp - fails when WiFi scan timestamps are inconsistent with
     * {@link SystemClock#elapsedRealtime()} on device.<p>
     * To run this test in cts-tradefed:
     * run cts --class android.net.wifi.cts.WifiManagerTest --method testWifiScanTimestamp
     */
    @VirtualDeviceNotSupported"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testWifiScanTimestamp"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testWifiScanTimestamp() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            Log.d(TAG, ""Skipping test as WiFi is not supported"");
            return;
        }
        if (!hasLocationFeature()) {
            Log.d(TAG, ""Skipping test as location is not supported"");
            return;
        }
        if (!isLocationEnabled()) {
            fail(""Please enable location for this test - since Marshmallow WiFi scan results are""
                    + "" empty when location is disabled!"");
        }
        if (!mWifiManager.isWifiEnabled()) {
            setWifiEnabled(true);
        }
        // Make sure the scan timestamps are consistent with the device timestamp within the range
        // of WIFI_SCAN_TEST_CACHE_DELAY_MILLIS.
        startScan();
        // Make sure at least one AP is found.
        assertTrue(""mScanResult should not be null. This may be due to a scan timeout"",
                   mScanResults != null);
        assertFalse(""empty scan results!"", mScanResults.isEmpty());
        long nowMillis = SystemClock.elapsedRealtime();
        // Keep track of how many APs are fresh in one scan.
        int numFreshAps = 0;
        for (ScanResult result : mScanResults) {
            long scanTimeMillis = TimeUnit.MICROSECONDS.toMillis(result.timestamp);
            if (Math.abs(nowMillis - scanTimeMillis)  < WIFI_SCAN_TEST_CACHE_DELAY_MILLIS) {
                numFreshAps++;
            }
        }
        // At least half of the APs in the scan should be fresh.
        int numTotalAps = mScanResults.size();
        String msg = ""Stale AP count: "" + (numTotalAps - numFreshAps) + "", fresh AP count: ""
                + numFreshAps;
        assertTrue(msg, numFreshAps * 2 >= mScanResults.size());
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testConvertBetweenChannelFrequencyMhz"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testConvertBetweenChannelFrequencyMhz() throws Exception {
        int[] testFrequency_2G = {2412, 2437, 2462, 2484};
        int[] testFrequency_5G = {5180, 5220, 5540, 5745};
        int[] testFrequency_6G = {5955, 6435, 6535, 7115};
        int[] testFrequency_60G = {58320, 64800};
        SparseArray<int[]> testData = new SparseArray<>() {{
            put(ScanResult.WIFI_BAND_24_GHZ, testFrequency_2G);
            put(ScanResult.WIFI_BAND_5_GHZ, testFrequency_5G);
            put(ScanResult.WIFI_BAND_6_GHZ, testFrequency_6G);
            put(ScanResult.WIFI_BAND_60_GHZ, testFrequency_60G);
        }};

        for (int i = 0; i < testData.size(); i++) {
            for (int frequency : testData.valueAt(i)) {
                assertEquals(frequency, ScanResult.convertChannelToFrequencyMhzIfSupported(
                      ScanResult.convertFrequencyMhzToChannelIfSupported(frequency), testData.keyAt(i)));
            }
        }
    }

    // Return true if location is enabled.
    private boolean isLocationEnabled() {
        return Settings.Secure.getInt(getContext().getContentResolver(),
                Settings.Secure.LOCATION_MODE, Settings.Secure.LOCATION_MODE_OFF) !=
                Settings.Secure.LOCATION_MODE_OFF;
    }

    // Returns true if the device has location feature.
    private boolean hasLocationFeature() {
        return getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOCATION);
    }

    private boolean hasAutomotiveFeature() {
        return getContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_AUTOMOTIVE);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testUpdateWifiUsabilityStatsScorePermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testUpdateWifiUsabilityStatsScorePermission() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        final PackageManager pm = getContext().getPackageManager();

        final List<PackageInfo> holding = pm.getPackagesHoldingPermissions(new String[] {
                android.Manifest.permission.WIFI_UPDATE_USABILITY_STATS_SCORE
        }, PackageManager.MATCH_UNINSTALLED_PACKAGES);

        Set<String> uniqueNonSystemPackageNames = new HashSet<>();
        for (PackageInfo pi : holding) {
            String packageName = pi.packageName;
            // Shell is allowed to hold this permission for testing.
            int uid = -1;
            try {
                uid = pm.getPackageUidAsUser(packageName, UserHandle.USER_SYSTEM);
            } catch (PackageManager.NameNotFoundException e) {
                continue;
            }
            if (uid == Process.SHELL_UID) continue;

            uniqueNonSystemPackageNames.add(packageName);
        }

        if (uniqueNonSystemPackageNames.size() > 1) {
            fail(""The WIFI_UPDATE_USABILITY_STATS_SCORE permission must not be held by more than ""
                + ""one application, but is held by "" + uniqueNonSystemPackageNames.size()
                + "" applications: "" + String.join("", "", uniqueNonSystemPackageNames));
        }
    }

    private void turnScreenOnNoDelay() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_WAKEUP"");
        mUiDevice.executeShellCommand(""wm dismiss-keyguard"");
    }

    private void turnScreenOn() throws Exception {
        turnScreenOnNoDelay();
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE);
    }

    private void turnScreenOffNoDelay() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_SLEEP"");
    }

    private void turnScreenOff() throws Exception {
        turnScreenOffNoDelay();
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE);
    }

    private void assertWifiScanningIsOn() {
        if (!mWifiManager.isScanAlwaysAvailable()) {
            fail(""Wi-Fi scanning should be on."");
        }
    }

    private void runWithScanningEnabled(ThrowingRunnable r) throws Exception {
        boolean wasScanEnabledForTest = false;
        if (!mWifiManager.isScanAlwaysAvailable()) {
            ShellIdentityUtils.invokeWithShellPermissions(
                    () -> mWifiManager.setScanAlwaysAvailable(true));
            wasScanEnabledForTest = true;
        }
        try {
            r.run();
        } finally {
            if (wasScanEnabledForTest) {
                ShellIdentityUtils.invokeWithShellPermissions(
                        () -> mWifiManager.setScanAlwaysAvailable(false));
            }
        }
    }

    /**
     * Verify that Wi-Fi scanning is not turned off when the screen turns off while wifi is disabled
     * but location is on.
     * @throws Exception
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testScreenOffDoesNotTurnOffWifiScanningWhenWifiDisabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testScreenOffDoesNotTurnOffWifiScanningWhenWifiDisabled() throws Exception {
        if (FeatureUtil.isTV() || FeatureUtil.isAutomotive()) {
            // TV and auto do not support the setting options of WIFI scanning and Bluetooth
            // scanning
            return;
        }
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!hasLocationFeature()) {
            // skip the test if location is not supported
            return;
        }
        if (!isLocationEnabled()) {
            fail(""Please enable location for this test - since Marshmallow WiFi scan results are""
                    + "" empty when location is disabled!"");
        }
        runWithScanningEnabled(() -> {
            setWifiEnabled(false);
            turnScreenOn();
            assertWifiScanningIsOn();
            // Toggle screen and verify Wi-Fi scanning is still on.
            turnScreenOff();
            assertWifiScanningIsOn();
            turnScreenOn();
            assertWifiScanningIsOn();
        });
    }

    /**
     * Verify that Wi-Fi scanning is not turned off when the screen turns off while wifi is enabled.
     * @throws Exception
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testScreenOffDoesNotTurnOffWifiScanningWhenWifiEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testScreenOffDoesNotTurnOffWifiScanningWhenWifiEnabled() throws Exception {
        if (FeatureUtil.isTV() || FeatureUtil.isAutomotive()) {
            // TV and auto do not support the setting options of WIFI scanning and Bluetooth
            // scanning
            return;
        }
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!hasLocationFeature()) {
            // skip the test if location is not supported
            return;
        }
        if (!isLocationEnabled()) {
            fail(""Please enable location for this test - since Marshmallow WiFi scan results are""
                    + "" empty when location is disabled!"");
        }
        runWithScanningEnabled(() -> {
            setWifiEnabled(true);
            turnScreenOn();
            assertWifiScanningIsOn();
            // Toggle screen and verify Wi-Fi scanning is still on.
            turnScreenOff();
            assertWifiScanningIsOn();
            turnScreenOn();
            assertWifiScanningIsOn();
        });
    }

    /**
     * Verify that the platform supports a reasonable number of suggestions per app.
     * @throws Exception
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testStartTetheredHotspotWithChannelConfigAndSoftApStateAndInfoCallback"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testStartTetheredHotspotWithChannelConfigAndSoftApStateAndInfoCallback()
            throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // check that softap mode is supported by the device
        if (!mWifiManager.isPortableHotspotSupported()) {
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        TestExecutor executor = new TestExecutor();
        TestSoftApCallback callback = new TestSoftApCallback(mLock);
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // check that tethering is supported by the device
            if (!mTetheringManager.isTetheringSupported()) {
                return;
            }
            turnOffWifiAndTetheredHotspotIfEnabled();
            verifyRegisterSoftApCallback(executor, callback);

            SparseIntArray testBandsAndChannels = getAvailableBandAndChannelForTesting(
                    callback.getCurrentSoftApCapability());

            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                assertNotEquals(0, testBandsAndChannels.size());
            }
            boolean isSupportCustomizedMac = callback.getCurrentSoftApCapability()
                    .areFeaturesSupported(
                    SoftApCapability.SOFTAP_FEATURE_MAC_ADDRESS_CUSTOMIZATION)
                    && PropertyUtil.isVndkApiLevelNewerThan(Build.VERSION_CODES.S);

            SoftApConfiguration.Builder testSoftApConfigBuilder = new SoftApConfiguration.Builder()
                    .setSsid(TEST_SSID_UNQUOTED)
                    .setPassphrase(TEST_PASSPHRASE, SoftApConfiguration.SECURITY_TYPE_WPA2_PSK)
                    .setChannel(testBandsAndChannels.valueAt(0), testBandsAndChannels.keyAt(0));

            if (isSupportCustomizedMac) testSoftApConfigBuilder.setBssid(TEST_MAC);

            SoftApConfiguration testSoftApConfig = testSoftApConfigBuilder.build();

            mWifiManager.setSoftApConfiguration(testSoftApConfig);

            // start tethering which used to verify startTetheredHotspot
            mTetheringManager.startTethering(ConnectivityManager.TETHERING_WIFI, executor,
                new TetheringManager.StartTetheringCallback() {
                    @Override
                    public void onTetheringFailed(final int result) {
                    }
                });

            // Verify state and info callback value as expected
            PollingCheck.check(
                    ""SoftAp channel and state mismatch!!!"", 10_000,
                    () -> {
                        executor.runAll();
                        int sapChannel = ScanResult.convertFrequencyMhzToChannelIfSupported(
                                callback.getCurrentSoftApInfo().getFrequency());
                        boolean isInfoCallbackSupported =
                                callback.getOnSoftapInfoChangedCalledCount() > 1;
                        if (isInfoCallbackSupported) {
                            return WifiManager.WIFI_AP_STATE_ENABLED == callback.getCurrentState()
                                && testBandsAndChannels.valueAt(0) == sapChannel;
                        }
                        return WifiManager.WIFI_AP_STATE_ENABLED == callback.getCurrentState();
                    });
            // After Soft Ap enabled, check SoftAp info if it supported
            if (isSupportCustomizedMac && callback.getOnSoftapInfoChangedCalledCount() > 1) {
                assertEquals(callback.getCurrentSoftApInfo().getBssid(), TEST_MAC);
            }
            if (PropertyUtil.isVndkApiLevelNewerThan(Build.VERSION_CODES.S)
                    && callback.getOnSoftapInfoChangedCalledCount() > 1) {
                assertNotEquals(callback.getCurrentSoftApInfo().getWifiStandard(),
                        ScanResult.WIFI_STANDARD_UNKNOWN);
            }

            if (callback.getOnSoftapInfoChangedCalledCount() > 1) {
                assertTrue(callback.getCurrentSoftApInfo().getAutoShutdownTimeoutMillis() > 0);
            }
        } finally {
            // stop tethering which used to verify stopSoftAp
            mTetheringManager.stopTethering(ConnectivityManager.TETHERING_WIFI);

            // Verify clean up
            PollingCheck.check(
                    ""Stop Softap failed"", 3_000,
                    () -> {
                        executor.runAll();
                        return WifiManager.WIFI_AP_STATE_DISABLED == callback.getCurrentState() &&
                                0 == callback.getCurrentSoftApInfo().getBandwidth() &&
                                0 == callback.getCurrentSoftApInfo().getFrequency();
                    });
            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                assertEquals(callback.getCurrentSoftApInfo().getBssid(), null);
                assertEquals(ScanResult.WIFI_STANDARD_UNKNOWN,
                        callback.getCurrentSoftApInfo().getWifiStandard());
            }
            mWifiManager.unregisterSoftApCallback(callback);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    private static class TestActionListener implements WifiManager.ActionListener {
        private final Object mLock;
        public boolean onSuccessCalled = false;
        public boolean onFailedCalled = false;
        public int failureReason = -1;

        TestActionListener(Object lock) {
            mLock = lock;
        }

        @Override
        public void onSuccess() {
            synchronized (mLock) {
                onSuccessCalled = true;
                mLock.notify();
            }
        }

        @Override
        public void onFailure(int reason) {
            synchronized (mLock) {
                onFailedCalled = true;
                failureReason = reason;
                mLock.notify();
            }
        }
    }

    /**
     * Triggers connection to one of the saved networks using {@link WifiManager#connect(
     * int, WifiManager.ActionListener)} or {@link WifiManager#connect(WifiConfiguration,
     * WifiManager.ActionListener)}
     *
     * @param withNetworkId Use networkId for triggering connection, false for using
     *                      WifiConfiguration.
     * @throws Exception
     */
    private void testConnect(boolean withNetworkId) throws Exception {
        TestActionListener actionListener = new TestActionListener(mLock);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        List<WifiConfiguration> savedNetworks = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // These below API's only work with privileged permissions (obtained via shell identity
            // for test)
            savedNetworks = mWifiManager.getConfiguredNetworks();

            // Disable all the saved networks to trigger disconnect & disable autojoin.
            for (WifiConfiguration network : savedNetworks) {
                assertTrue(mWifiManager.disableNetwork(network.networkId));
            }
            waitForDisconnection();

            // Now trigger connection to the last saved network.
            WifiConfiguration savedNetworkToConnect =
                    savedNetworks.get(savedNetworks.size() - 1);
            synchronized (mLock) {
                try {
                    if (withNetworkId) {
                        mWifiManager.connect(savedNetworkToConnect.networkId, actionListener);
                    } else {
                        mWifiManager.connect(savedNetworkToConnect, actionListener);
                    }
                    // now wait for callback
                    mLock.wait(TEST_WAIT_DURATION_MS);
                } catch (InterruptedException e) {
                }
            }
            // check if we got the success callback
            assertTrue(actionListener.onSuccessCalled);
            // Wait for connection to complete & ensure we are connected to the saved network.
            waitForConnection();
            if (SdkLevel.isAtLeastS()) {
                assertEquals(savedNetworkToConnect.networkId,
                        mWifiManager.getConnectionInfo().getNetworkId());
            } else {
                // In R, auto-upgraded network IDs may be different from the original saved network.
                // Since we may end up selecting the auto-upgraded network ID for connection and end
                // up connected to the original saved network with a different network ID, we should
                // instead match by SSID.
                assertEquals(savedNetworkToConnect.SSID,
                        mWifiManager.getConnectionInfo().getSSID());
            }
        } finally {
            // Re-enable all saved networks before exiting.
            if (savedNetworks != null) {
                for (WifiConfiguration network : savedNetworks) {
                    mWifiManager.enableNetwork(network.networkId, true);
                }
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#connect(int, WifiManager.ActionListener)} to an existing saved
     * network.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testSave"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testSave() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        TestActionListener actionListener = new TestActionListener(mLock);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        List<WifiConfiguration> savedNetworks = null;
        WifiConfiguration currentConfig = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // These below API's only work with privileged permissions (obtained via shell identity
            // for test)

            // Trigger a scan & wait for connection to one of the saved networks.
            mWifiManager.startScan();
            waitForConnection();

            WifiInfo wifiInfo = mWifiManager.getConnectionInfo();

            // find the current network's WifiConfiguration
            currentConfig = mWifiManager.getConfiguredNetworks()
                    .stream()
                    .filter(config -> config.networkId == wifiInfo.getNetworkId())
                    .findAny()
                    .get();

            // Ensure that the current network is not metered.
            assertNotEquals(""Ensure that the saved network is configured as unmetered"",
                    currentConfig.meteredOverride,
                    WifiConfiguration.METERED_OVERRIDE_METERED);

            // Check the network capabilities to ensure that the network is marked not metered.
            waitForNetworkCallbackAndCheckForMeteredness(false);

            // Now mark the network metered and save.
            synchronized (mLock) {
                try {
                    WifiConfiguration modSavedNetwork = new WifiConfiguration(currentConfig);
                    modSavedNetwork.meteredOverride = WifiConfiguration.METERED_OVERRIDE_METERED;
                    mWifiManager.save(modSavedNetwork, actionListener);
                    // now wait for callback
                    mLock.wait(TEST_WAIT_DURATION_MS);
                } catch (InterruptedException e) {
                }
            }
            // check if we got the success callback
            assertTrue(actionListener.onSuccessCalled);
            // Ensure we disconnected on marking the network metered & connect back.
            waitForDisconnection();
            waitForConnection();
            // Check the network capabilities to ensure that the network is marked metered now.
            waitForNetworkCallbackAndCheckForMeteredness(true);

        } finally {
            // Restore original network config (restore the meteredness back);
            if (currentConfig != null) {
                mWifiManager.updateNetwork(currentConfig);
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#forget(int, WifiManager.ActionListener)} by adding/removing a new
     * network.
     */
    @AsbSecurityTest(cveBugId = 159373687)"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsPreferredNetworkOffloadSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsPreferredNetworkOffloadSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mWifiManager.isPreferredNetworkOffloadSupported();
    }

    /** Test that PNO scans reconnects us when the device is disconnected and the screen is off. */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testPnoScan"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testPnoScan() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        if (!mWifiManager.isPreferredNetworkOffloadSupported()) {
            // skip the test if PNO scanning is not supported
            return;
        }

        // make sure we're connected
        waitForConnection();

        WifiInfo currentNetwork = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getConnectionInfo);

        // disable all networks that aren't already disabled
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                mWifiManager::getConfiguredNetworks);
        Set<Integer> disabledNetworkIds = new HashSet<>();
        for (WifiConfiguration config : savedNetworks) {
            if (config.getNetworkSelectionStatus().getNetworkSelectionDisableReason()
                    == WifiConfiguration.NetworkSelectionStatus.DISABLED_NONE) {
                ShellIdentityUtils.invokeWithShellPermissions(
                        () -> mWifiManager.disableNetwork(config.networkId));
                disabledNetworkIds.add(config.networkId);
            }
        }

        try {
            // wait for disconnection from current network
            waitForDisconnection();

            // turn screen off
            turnScreenOffNoDelay();

            // re-enable the current network - this will trigger PNO
            ShellIdentityUtils.invokeWithShellPermissions(
                    () -> mWifiManager.enableNetwork(currentNetwork.getNetworkId(), false));
            disabledNetworkIds.remove(currentNetwork.getNetworkId());

            // PNO should reconnect us back to the network we disconnected from
            waitForConnection();
        } finally {
            // re-enable disabled networks
            for (int disabledNetworkId : disabledNetworkIds) {
                ShellIdentityUtils.invokeWithShellPermissions(
                        () -> mWifiManager.enableNetwork(disabledNetworkId, true));
            }
        }
    }

    /**
     * Tests {@link WifiManager#isTdlsSupported()} does not crash.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testTrafficStateCallback"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testTrafficStateCallback() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        TestTrafficStateCallback callback = new TestTrafficStateCallback();
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // Trigger a scan & wait for connection to one of the saved networks.
            mWifiManager.startScan();
            waitForConnection();

            // Turn screen on for wifi traffic polling.
            turnScreenOn();
            mWifiManager.registerTrafficStateCallback(
                    Executors.newSingleThreadExecutor(), callback);
            // Send some traffic to trigger the traffic state change callbacks.
            sendTraffic();
            // now wait for callback
            boolean success = callback.latch.await(TEST_WAIT_DURATION_MS, TimeUnit.MILLISECONDS);
            // check if we got the state changed callback with both data in and out
            assertTrue(success);
        } finally {
            turnScreenOff();
            mWifiManager.unregisterTrafficStateCallback(callback);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#setScanAlwaysAvailable(boolean)} &
     * {@link WifiManager#isScanAlwaysAvailable()}.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testScanAlwaysAvailable"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testScanAlwaysAvailable() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        Boolean currState = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            currState = mWifiManager.isScanAlwaysAvailable();
            boolean newState = !currState;
            mWifiManager.setScanAlwaysAvailable(newState);
            PollingCheck.check(
                    ""Wifi settings toggle failed!"",
                    DURATION_SETTINGS_TOGGLE,
                    () -> mWifiManager.isScanAlwaysAvailable() == newState);
            assertEquals(newState, mWifiManager.isScanAlwaysAvailable());
        } finally {
            if (currState != null) mWifiManager.setScanAlwaysAvailable(currState);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#setScanThrottleEnabled(boolean)} &
     * {@link WifiManager#isScanThrottleEnabled()}.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testScanThrottleEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testScanThrottleEnabled() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        Boolean currState = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            currState = mWifiManager.isScanThrottleEnabled();
            boolean newState = !currState;
            mWifiManager.setScanThrottleEnabled(newState);
            PollingCheck.check(
                    ""Wifi settings toggle failed!"",
                    DURATION_SETTINGS_TOGGLE,
                    () -> mWifiManager.isScanThrottleEnabled() == newState);
            assertEquals(newState, mWifiManager.isScanThrottleEnabled());
        } finally {
            if (currState != null) mWifiManager.setScanThrottleEnabled(currState);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#setAutoWakeupEnabled(boolean)} &
     * {@link WifiManager#isAutoWakeupEnabled()}.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testStartAndStopRestrictingAutoJoinToSubscriptionId"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testStartAndStopRestrictingAutoJoinToSubscriptionId() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        startScan();
        waitForConnection();
        int fakeSubscriptionId = 5;
        ShellIdentityUtils.invokeWithShellPermissions(() ->
                mWifiManager.startRestrictingAutoJoinToSubscriptionId(fakeSubscriptionId));
        startScan();
        ensureNotConnected();
        ShellIdentityUtils.invokeWithShellPermissions(() ->
                mWifiManager.stopRestrictingAutoJoinToSubscriptionId());
        startScan();
        waitForConnection();
    }

    /**
     * Test that the wifi country code is either null, or a length-2 string.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testIsWifiStandardsSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testIsWifiStandardsSupported() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // Check for WiFi standards support with wifi enabled
        setWifiEnabled(true);
        PollingCheck.check(
                ""Wifi not enabled!"",
                20000,
                () -> mWifiManager.isWifiEnabled());
        boolean isLegacySupportedEnabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_LEGACY);
        boolean is11nSupporedEnabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11N);
        boolean is11acSupportedEnabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11AC);
        boolean is11axSupportedEnabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11AX);

        // Check for WiFi standards support with wifi disabled
        setWifiEnabled(false);
        PollingCheck.check(
                ""Wifi not disabled!"",
                20000,
                () -> !mWifiManager.isWifiEnabled());

        boolean isLegacySupportedDisabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_LEGACY);
        boolean is11nSupportedDisabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11N);
        boolean is11acSupportedDisabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11AC);
        boolean is11axSupportedDisabled =
                mWifiManager.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11AX);

        if (isLegacySupportedDisabled) {
            assertTrue(isLegacySupportedEnabled);
        }

        if (is11nSupportedDisabled) {
            assertTrue(is11nSupporedEnabled);
        }

        if (is11acSupportedDisabled) {
            assertTrue(is11acSupportedEnabled);
        }

        if (is11axSupportedDisabled) {
            assertTrue(is11axSupportedEnabled);
        }
    }

    private static PasspointConfiguration createPasspointConfiguration() {
        PasspointConfiguration config = new PasspointConfiguration();
        HomeSp homeSp = new HomeSp();
        homeSp.setFqdn(""test.com"");
        homeSp.setFriendlyName(""friendly name"");
        homeSp.setRoamingConsortiumOis(new long[]{0x55, 0x66});
        config.setHomeSp(homeSp);
        Credential.SimCredential simCred = new Credential.SimCredential();
        simCred.setImsi(""123456*"");
        simCred.setEapType(23 /* EAP_AKA */);
        Credential cred = new Credential();
        cred.setRealm(""realm"");
        cred.setSimCredential(simCred);
        config.setCredential(cred);

        return config;
    }

    /**
     * Tests {@link WifiManager#addOrUpdatePasspointConfiguration(PasspointConfiguration)}
     * adds a Passpoint configuration correctly by getting it once it is added, and comparing it
     * to the local copy of the configuration.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testSetTdlsEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testSetTdlsEnabled() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // Trigger a scan & wait for connection to one of the saved networks.
        mWifiManager.startScan();
        waitForConnection();

        InetAddress inetAddress = InetAddress.getByName(TEST_IP_ADDRESS);

        mWifiManager.setTdlsEnabled(inetAddress, true);
        Thread.sleep(50);
        mWifiManager.setTdlsEnabled(inetAddress, false);
    }

    /**
     * Tests {@link WifiManager#setTdlsEnabledWithMacAddress(String, boolean)} does not crash.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testSetTdlsEnabledWithMacAddress"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testSetTdlsEnabledWithMacAddress() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // Trigger a scan & wait for connection to one of the saved networks.
        mWifiManager.startScan();
        waitForConnection();

        mWifiManager.setTdlsEnabledWithMacAddress(TEST_MAC_ADDRESS, true);
        Thread.sleep(50);
        mWifiManager.setTdlsEnabledWithMacAddress(TEST_MAC_ADDRESS, false);
    }

    /**
     * Verify WifiNetworkSuggestion.Builder.setMacRandomizationSetting(WifiNetworkSuggestion
     * .RANDOMIZATION_NON_PERSISTENT) creates a
     * WifiConfiguration with macRandomizationSetting == RANDOMIZATION_NON_PERSISTENT.
     * Then verify by default, a WifiConfiguration created by suggestions should have
     * macRandomizationSetting == RANDOMIZATION_PERSISTENT.
     */
    @SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testGetAllWifiConfigForMatchedNetworkSuggestion"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testGetAllWifiConfigForMatchedNetworkSuggestion() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        ScanResult scanResult = new ScanResult();
        scanResult.SSID = TEST_SSID;
        scanResult.capabilities = TEST_PSK_CAP;
        scanResult.BSSID = TEST_BSSID;
        List<ScanResult> testList = Arrays.asList(scanResult);
        WifiNetworkSuggestion suggestion = new WifiNetworkSuggestion.Builder()
                .setSsid(TEST_SSID).setWpa2Passphrase(TEST_PASSPHRASE).build();

        assertEquals(WifiManager.STATUS_NETWORK_SUGGESTIONS_SUCCESS,
                mWifiManager.addNetworkSuggestions(Arrays.asList(suggestion)));
        List<WifiConfiguration> matchedResult;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            matchedResult = mWifiManager
                    .getWifiConfigForMatchedNetworkSuggestionsSharedWithUser(testList);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
        // As suggestion is not approved, will return empty list.
        assertTrue(matchedResult.isEmpty());
    }

    /**
     * Tests {@link WifiManager#getMatchingScanResults(List, List)}
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testGetMatchingScanResults"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testGetMatchingScanResults() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // Create pair of ScanResult and WifiNetworkSuggestion
        ScanResult scanResult = new ScanResult();
        scanResult.SSID = TEST_SSID;
        scanResult.capabilities = TEST_PSK_CAP;
        scanResult.BSSID = TEST_BSSID;

        WifiNetworkSuggestion suggestion = new WifiNetworkSuggestion.Builder()
                .setSsid(TEST_SSID).setWpa2Passphrase(TEST_PASSPHRASE).build();

        Map<WifiNetworkSuggestion, List<ScanResult>> matchedResults = mWifiManager
                .getMatchingScanResults(Arrays.asList(suggestion), Arrays.asList(scanResult));
        // Verify result is matched pair of ScanResult and WifiNetworkSuggestion
        assertEquals(scanResult.SSID, matchedResults.get(suggestion).get(0).SSID);

        // Change ScanResult to unmatched should return empty result.
        scanResult.SSID = TEST_SSID_UNQUOTED;
        matchedResults = mWifiManager
                .getMatchingScanResults(Arrays.asList(suggestion), Arrays.asList(scanResult));
        assertTrue(matchedResults.get(suggestion).isEmpty());
    }

    /**
     * Tests {@link WifiManager#disableEphemeralNetwork(String)}.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testDisableEphemeralNetwork"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testDisableEphemeralNetwork() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // Trigger a scan & wait for connection to one of the saved networks.
        mWifiManager.startScan();
        waitForConnection();

        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        List<WifiConfiguration> savedNetworks = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // Temporarily disable on all networks.
            savedNetworks = mWifiManager.getConfiguredNetworks();
            for (WifiConfiguration network : savedNetworks) {
                mWifiManager.disableEphemeralNetwork(network.SSID);
            }
            // trigger a disconnect and wait for disconnect.
            mWifiManager.disconnect();
            waitForDisconnection();

            // Now trigger scan and ensure that the device does not connect to any networks.
            mWifiManager.startScan();
            ensureNotConnected();
        } finally {
            uiAutomation.dropShellPermissionIdentity();
            setWifiEnabled(false);
        }
    }

    /**
     * Tests {@link WifiManager#allowAutojoin(int, boolean)}.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testAllowAutojoin"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testAllowAutojoin() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // Trigger a scan & wait for connection to one of the saved networks.
        mWifiManager.startScan();
        waitForConnection();

        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        List<WifiConfiguration> savedNetworks = null;
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // disable autojoin on all networks.
            savedNetworks = mWifiManager.getConfiguredNetworks();
            for (WifiConfiguration network : savedNetworks) {
                mWifiManager.allowAutojoin(network.networkId, false);
            }
            // trigger a disconnect and wait for disconnect.
            mWifiManager.disconnect();
            waitForDisconnection();

            // Now trigger scan and ensure that the device does not connect to any networks.
            mWifiManager.startScan();
            ensureNotConnected();

            // Now enable autojoin on all networks.
            for (WifiConfiguration network : savedNetworks) {
                mWifiManager.allowAutojoin(network.networkId, true);
            }

            // Trigger a scan & wait for connection to one of the saved networks.
            mWifiManager.startScan();
            waitForConnection();
        } finally {
            // Restore auto join state.
            if (savedNetworks != null) {
                for (WifiConfiguration network : savedNetworks) {
                    mWifiManager.allowAutojoin(network.networkId, network.allowAutojoin);
                }
            }
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#allowAutojoinPasspoint(String, boolean)}.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiManagerTest"	"testAllowAutojoinGlobal"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiManagerTest.java"	""	"public void testAllowAutojoinGlobal() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // Trigger a scan & wait for connection to one of the saved networks.
        mWifiManager.startScan();
        waitForConnection();

        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // disable autojoin on all networks.
            mWifiManager.allowAutojoinGlobal(false);

            // trigger a disconnect and wait for disconnect.
            mWifiManager.disconnect();
            waitForDisconnection();

            // Now trigger scan and ensure that the device does not connect to any networks.
            mWifiManager.startScan();
            ensureNotConnected();

            // Now enable autojoin on all networks.
            mWifiManager.allowAutojoinGlobal(true);

            // Trigger a scan & wait for connection to one of the saved networks.
            mWifiManager.startScan();
            waitForConnection();
        } finally {
            // Re-enable auto join if the test fails for some reason.
            mWifiManager.allowAutojoinGlobal(true);
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests {@link WifiManager#isWapiSupported()} does not crash.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyWifiNetworkSpecifierTest"	"isStaConcurrencyForLocalOnlyConnectionsSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyWifiNetworkSpecifierTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeTrue;

import android.content.Context;
import android.content.pm.PackageManager;
import android.location.LocationManager;
import android.net.ConnectivityManager;
import android.net.NetworkRequest;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSpecifier;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.LargeTest;
import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;

/**
 * Tests multiple concurrent connection flow on devices that support multi STA concurrency
 * (indicated via {@link WifiManager#isStaConcurrencyForLocalOnlyConnectionsSupported()}.
 *
 * Tests the entire connection flow using {@link WifiNetworkSpecifier} embedded in a
 * {@link NetworkRequest} & passed into {@link ConnectivityManager#requestNetwork(NetworkRequest,
 * ConnectivityManager.NetworkCallback)} along with a concurrent internet connection using
 * {@link WifiManager#connect(int, WifiManager.ActionListener)}.
 *
 * Assumes that all the saved networks is either open/WPA1/WPA2/WPA3 authenticated network.
 *
 * TODO(b/177591382): Refactor some of the utilities to a separate file that are copied over from
 * WifiManagerTest & WifiNetworkSpecifierTest.
 */
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)
@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@LargeTest
@RunWith(AndroidJUnit4.class)
public class MultiStaConcurrencyWifiNetworkSpecifierTest extends WifiJUnit4TestBase {
    private static final String TAG = ""MultiStaConcurrencyWifiNetworkSpecifierTest"";
    private static boolean sWasVerboseLoggingEnabled;
    private static boolean sWasScanThrottleEnabled;
    private static boolean sWasWifiEnabled;

    private Context mContext;
    private WifiManager mWifiManager;
    private ConnectivityManager mConnectivityManager;
    private UiDevice mUiDevice;
    private WifiConfiguration mTestNetworkForPeerToPeer;
    private WifiConfiguration mTestNetworkForInternetConnection;
    private ConnectivityManager.NetworkCallback mNetworkCallback;
    private ConnectivityManager.NetworkCallback mNrNetworkCallback;
    private TestHelper mTestHelper;

    private static final int DURATION = 10_000;
    private static final int DURATION_UI_INTERACTION = 25_000;
    private static final int DURATION_NETWORK_CONNECTION = 60_000;
    private static final int DURATION_SCREEN_TOGGLE = 2000;
    private static final int SCAN_RETRY_CNT_TO_FIND_MATCHING_BSSID = 3;

    @BeforeClass
    public static void setUpClass() throws Exception {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        // skip the test if WiFi is not supported. Don't use assumeTrue in @BeforeClass
        if (!WifiFeature.isWifiSupported(context)) return;

        WifiManager wifiManager = context.getSystemService(WifiManager.class);
        assertThat(wifiManager).isNotNull();

        // turn on verbose logging for tests
        sWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        sWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setScanThrottleEnabled(false));

        // enable Wifi
        sWasWifiEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isWifiEnabled());
        if (!wifiManager.isWifiEnabled()) {
            ShellIdentityUtils.invokeWithShellPermissions(() -> wifiManager.setWifiEnabled(true));
        }
        PollingCheck.check(""Wifi not enabled"", DURATION, () -> wifiManager.isWifiEnabled());
    }

    @AfterClass
    public static void tearDownClass() throws Exception {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        if (!WifiFeature.isWifiSupported(context)) return;

        WifiManager wifiManager = context.getSystemService(WifiManager.class);
        assertThat(wifiManager).isNotNull();

        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setScanThrottleEnabled(sWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setVerboseLoggingEnabled(sWasVerboseLoggingEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setWifiEnabled(sWasWifiEnabled));
    }

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getContext();
        mWifiManager = mContext.getSystemService(WifiManager.class);
        mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);
        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        mTestHelper = new TestHelper(mContext, mUiDevice);

        // skip the test if WiFi is not supported
        assumeTrue(WifiFeature.isWifiSupported(mContext));
        // skip the test if location is not supported
        assumeTrue(mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOCATION));
        // skip if multi STA not supported.
        assumeTrue(mWifiManager.isStaConcurrencyForLocalOnlyConnectionsSupported());

        assertWithMessage(""Please enable location for this test!"")
                .that(mContext.getSystemService(LocationManager.class).isLocationEnabled())
                .isTrue();

        // turn screen on
        mTestHelper.turnScreenOn();

        // Clear any existing app state before each test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));

        // We need 2 AP's for the test. If there are 2 networks saved on the device and in range,
        // use those. Otherwise, check if there are 2 BSSID's in range for the only saved network.
        // This assumes a CTS test environment with at least 2 connectable bssid's (Is that ok?).
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.getPrivilegedConfiguredNetworks());
        List<WifiConfiguration> matchingNetworksWithBssid =
                TestHelper.findMatchingSavedNetworksWithBssid(mWifiManager, savedNetworks);
        assertWithMessage(""Need at least 2 saved network bssids in range"")
                .that(matchingNetworksWithBssid.size()).isAtLeast(2);
        // Pick any 2 bssid for test.
        mTestNetworkForPeerToPeer = matchingNetworksWithBssid.get(0);
        // Try to find a bssid for another saved network in range. If none exists, fallback
        // to using 2 bssid's for the same network.
        mTestNetworkForInternetConnection = matchingNetworksWithBssid.stream()
                .filter(w -> !w.SSID.equals(mTestNetworkForPeerToPeer.SSID))
                .findAny()
                .orElse(matchingNetworksWithBssid.get(1));

        // Disconnect & disable auto-join on the saved network to prevent auto-connect from
        // interfering with the test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : savedNetworks) {
                        mWifiManager.disableNetwork(savedNetwork.networkId);
                    }
                    mWifiManager.disconnect();
                });

        // Wait for Wifi to be disconnected.
        PollingCheck.check(
                ""Wifi not disconnected"",
                20_000,
                () -> mWifiManager.getConnectionInfo().getNetworkId() == -1);
    }

    @After
    public void tearDown() throws Exception {
        // Re-enable networks.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : mWifiManager.getConfiguredNetworks()) {
                        mWifiManager.enableNetwork(savedNetwork.networkId, false);
                    }
                });
        // Release the requests after the test.
        if (mNetworkCallback != null) {
            mConnectivityManager.unregisterNetworkCallback(mNetworkCallback);
        }
        if (mNrNetworkCallback != null) {
            mConnectivityManager.unregisterNetworkCallback(mNrNetworkCallback);
        }
        // Clear any existing app state after each test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));
        mTestHelper.turnScreenOff();
    }

    private void testSuccessfulConnectionWithSpecifier(
            WifiConfiguration network, WifiNetworkSpecifier specifier) throws Exception {
        mNrNetworkCallback = mTestHelper.testConnectionFlowWithSpecifier(
                network, specifier, false);
    }

    private void testUserRejectionWithSpecifier(
            WifiConfiguration network, WifiNetworkSpecifier specifier) throws Exception {
        mNrNetworkCallback = mTestHelper.testConnectionFlowWithSpecifier(
                network, specifier, true);
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using internet connectivity API.
     * 2. Connect to a network using peer to peer API.
     * 3. Verify that both connections are active.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.nl80211.cts.NativeScanResultTest"	"testGetters"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/nl80211/cts/NativeScanResultTest.java"	""	"public void testGetters() {
        NativeScanResult result = new NativeScanResult();
        assertThat(result.isAssociated()).isFalse();
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.app.RetrieveConnectionInfoAndReturnStatusActivity"	"finish"	""	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/CtsWifiLocationTestApp/src/android/net/wifi/cts/app/RetrieveConnectionInfoAndReturnStatusActivity.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts.app;

import android.app.Activity;
import android.content.Intent;
import android.net.wifi.WifiManager;
import android.os.Bundle;
import android.util.Log;

/**
 * An activity that retrieves connection info and returns status.
 */
public class RetrieveConnectionInfoAndReturnStatusActivity extends Activity {
    private static final String TAG = ""RetrieveConnectionInfoAndReturnStatusActivity"";
    private static final String SCAN_STATUS_EXTRA = ""android.net.wifi.cts.app.extra.STATUS"";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        WifiManager wifiManager = getSystemService(WifiManager.class);
        boolean succeeded;
        try {
            succeeded = !wifiManager.getConnectionInfo().getSSID().equals(WifiManager.UNKNOWN_SSID);
        } catch (SecurityException e) {
            succeeded = false;
        }
        if (succeeded) {
            Log.v(TAG, ""SSID from connection info retrieval succeeded"");
        } else {
            Log.v(TAG, ""Failed to retrieve SSID from connection info"");
        }
        setResult(RESULT_OK, new Intent().putExtra(SCAN_STATUS_EXTRA, succeeded));
        finish();
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.app.RetrieveScanResultsAndReturnStatusActivity"	"isEmpty"	""	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/CtsWifiLocationTestApp/src/android/net/wifi/cts/app/RetrieveScanResultsAndReturnStatusActivity.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts.app;

import android.app.Activity;
import android.content.Intent;
import android.net.wifi.WifiManager;
import android.os.Bundle;
import android.util.Log;

/**
 * An activity that retrieves scan results and returns status.
 */
public class RetrieveScanResultsAndReturnStatusActivity extends Activity {
    private static final String TAG = ""RetrieveScanResultsAndReturnStatusActivity"";
    private static final String SCAN_STATUS_EXTRA = ""android.net.wifi.cts.app.extra.STATUS"";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        WifiManager wifiManager = getSystemService(WifiManager.class);
        boolean succeeded;
        try {
            succeeded = !wifiManager.getScanResults().isEmpty();
        } catch (SecurityException e) {
            succeeded = false;
        }
        if (succeeded) {
            Log.v(TAG, ""Scan results retrieval succeeded"");
        } else {
            Log.v(TAG, ""Failed to retrieve scan results"");
        }
        setResult(RESULT_OK, new Intent().putExtra(SCAN_STATUS_EXTRA, succeeded));
        finish();
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.rtt.cts.TestBase"	"isLocationEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/rtt/cts/TestBase.java"	""	"public void test/*
 *.
 */

package android.net.wifi.rtt.cts;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.pm.PackageManager;
import android.location.LocationManager;
import android.net.wifi.ScanResult;
import android.net.wifi.WifiManager;
import android.net.wifi.cts.WifiJUnit3TestBase;
import android.net.wifi.rtt.RangingResult;
import android.net.wifi.rtt.RangingResultCallback;
import android.net.wifi.rtt.WifiRttManager;
import android.os.Handler;
import android.os.HandlerExecutor;
import android.os.HandlerThread;

import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;

/**
 * Base class for Wi-Fi RTT CTS test cases. Provides a uniform configuration and event management
 * facility.
 */
public class TestBase extends WifiJUnit3TestBase {
    protected static final String TAG = ""WifiRttCtsTests"";

    // wait for Wi-Fi RTT to become available
    private static final int WAIT_FOR_RTT_CHANGE_SECS = 10;

    // wait for Wi-Fi scan results to become available
    private static final int WAIT_FOR_SCAN_RESULTS_SECS = 20;

    // wait for network selection and connection finish
    private static final int WAIT_FOR_CONNECTION_FINISH_MS = 30_000;

    // Interval between failure scans
    private static final int INTERVAL_BETWEEN_FAILURE_SCAN_MILLIS = 5_000;

    // 5GHz Frequency band
    private static final int FREQUENCY_OF_5GHZ_BAND_IN_MHZ = 5_000;

    protected WifiRttManager mWifiRttManager;
    protected WifiManager mWifiManager;
    private LocationManager mLocationManager;
    private WifiManager.WifiLock mWifiLock;

    private final HandlerThread mHandlerThread = new HandlerThread(""SingleDeviceTest"");
    protected final Executor mExecutor;
    private Boolean mWasVerboseLoggingEnabled;

    {
        mHandlerThread.start();
        mExecutor = new HandlerExecutor(new Handler(mHandlerThread.getLooper()));
    }

    /**
     * Returns a flag indicating whether or not Wi-Fi RTT should be tested. Wi-Fi RTT
     * should be tested if the feature is supported on the current device.
     */
    static boolean shouldTestWifiRtt(Context context) {
        final PackageManager pm = context.getPackageManager();
        return pm.hasSystemFeature(PackageManager.FEATURE_WIFI_RTT);
    }

    /**
     * Returns a flag indicating whether or not Wi-Fi Aware should be tested. Wi-Fi Aware
     * should be tested if the feature is supported on the current device.
     */
    static boolean shouldTestWifiAware(Context context) {
        final PackageManager pm = context.getPackageManager();
        return pm.hasSystemFeature(PackageManager.FEATURE_WIFI_AWARE);
    }

    @Override
    protected void setUp() throws Exception {
        super.setUp();

        if (!shouldTestWifiRtt(getContext())) {
            return;
        }

        mLocationManager = (LocationManager) getContext().getSystemService(
                Context.LOCATION_SERVICE);
        assertTrue(""RTT testing requires Location to be enabled"",
                mLocationManager.isLocationEnabled());

        mWifiRttManager = (WifiRttManager) getContext().getSystemService(
                Context.WIFI_RTT_RANGING_SERVICE);
        assertNotNull(""Wi-Fi RTT Manager"", mWifiRttManager);

        mWifiManager = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        assertNotNull(""Wi-Fi Manager"", mWifiManager);

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));

        mWifiLock = mWifiManager.createWifiLock(TAG);
        mWifiLock.acquire();
        if (!mWifiManager.isWifiEnabled()) {
            SystemUtil.runShellCommand(""svc wifi enable"");
            // Turn on Wi-Fi may trigger connection. Wait connection state stable.
            scanAps();
            Thread.sleep(WAIT_FOR_CONNECTION_FINISH_MS);
        }
        IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(WifiRttManager.ACTION_WIFI_RTT_STATE_CHANGED);
        WifiRttBroadcastReceiver receiver = new WifiRttBroadcastReceiver();
        mContext.registerReceiver(receiver, intentFilter);
        if (!mWifiRttManager.isAvailable()) {
            assertTrue(""Timeout waiting for Wi-Fi RTT to change status"",
                    receiver.waitForStateChange());
            assertTrue(""Wi-Fi RTT is not available (should be)"", mWifiRttManager.isAvailable());
        }
    }

    @Override
    protected void tearDown() throws Exception {
        if (!shouldTestWifiRtt(getContext())) {
            super.tearDown();
            return;
        }

        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));

        super.tearDown();
    }

    class WifiRttBroadcastReceiver extends BroadcastReceiver {
        private CountDownLatch mBlocker = new CountDownLatch(1);

        @Override
        public void onReceive(Context context, Intent intent) {
            if (WifiRttManager.ACTION_WIFI_RTT_STATE_CHANGED.equals(intent.getAction())) {
                mBlocker.countDown();
            }
        }

        boolean waitForStateChange() throws InterruptedException {
            return mBlocker.await(WAIT_FOR_RTT_CHANGE_SECS, TimeUnit.SECONDS);
        }
    }

    class WifiScansBroadcastReceiver extends BroadcastReceiver {
        private CountDownLatch mBlocker = new CountDownLatch(1);

        @Override
        public void onReceive(Context context, Intent intent) {
            if (WifiManager.SCAN_RESULTS_AVAILABLE_ACTION.equals(intent.getAction())) {
                mBlocker.countDown();
            }
        }

        boolean waitForStateChange() throws InterruptedException {
            return mBlocker.await(WAIT_FOR_SCAN_RESULTS_SECS, TimeUnit.SECONDS);
        }
    }

    class ResultCallback extends RangingResultCallback {
        private CountDownLatch mBlocker = new CountDownLatch(1);
        private int mCode; // 0: success, otherwise RangingResultCallback STATUS_CODE_*.
        private List<RangingResult> mResults;

        @Override
        public void onRangingFailure(int code) {
            mCode = code;
            mResults = null; // not necessary since intialized to null - but for completeness
            mBlocker.countDown();
        }

        @Override
        public void onRangingResults(List<RangingResult> results) {
            mCode = 0; // not necessary since initialized to 0 - but for completeness
            mResults = results;
            mBlocker.countDown();
        }

        /**
         * Waits for the listener callback to be called - or an error (timeout, interruption).
         * Returns true on callback called, false on error (timeout, interruption).
         */
        boolean waitForCallback() throws InterruptedException {
            return mBlocker.await(WAIT_FOR_RTT_CHANGE_SECS, TimeUnit.SECONDS);
        }

        /**
         * Returns the code of the callback operation. Will be 0 for success (onRangingResults
         * called), else (if onRangingFailure called) will be one of the STATUS_CODE_* values.
         */
        int getCode() {
            return mCode;
        }

        /**
         * Returns the list of ranging results. In cases of error (getCode() != 0) will return null.
         */
        List<RangingResult> getResults() {
            return mResults;
        }
    }

    /**
     * Start a scan and return a list of observed ScanResults (APs).
     */
    protected List<ScanResult> scanAps() throws InterruptedException {
        IntentFilter intentFilter = new IntentFilter();
        intentFilter.addAction(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION);
        WifiScansBroadcastReceiver receiver = new WifiScansBroadcastReceiver();
        mContext.registerReceiver(receiver, intentFilter);

        mWifiManager.startScan();
        receiver.waitForStateChange();
        mContext.unregisterReceiver(receiver);
        return mWifiManager.getScanResults();
    }

    /**
     * Start a scan and return a test AP which supports IEEE 802.11mc and which has the highest
     * RSSI. Will perform N (parameterized) scans and get the best AP across both scans.
     *
     * Returns null if test AP is not found in the specified number of scans.
     *
     * @param numScanRetries Maximum number of scans retries (in addition to first scan).
     */
    protected ScanResult scanForTest11mcCapableAp(int numScanRetries)
            throws InterruptedException {
        int scanCount = 0;
        ScanResult bestTestAp = null;
        while (scanCount <= numScanRetries) {
            for (ScanResult scanResult : scanAps()) {
                if (!scanResult.is80211mcResponder()) {
                    continue;
                }
                if (bestTestAp == null || scanResult.level > bestTestAp.level) {
                    bestTestAp = scanResult;
                }
            }
            if (bestTestAp == null) {
                // Ongoing connection may cause scan failure, wait for a while before next scan.
                Thread.sleep(INTERVAL_BETWEEN_FAILURE_SCAN_MILLIS);
            }
            scanCount++;
        }
        return bestTestAp;
    }

    /**
     * Start a scan and return a test AP which does NOT support IEEE 802.11mc, with a BSS in the
     * 5GHz band, and which has the highest RSSI. Will perform N (parameterized) scans and get
     * the best AP across all scan results.
     *
     * Returns null if test AP is not found in the specified number of scans.
     *
     * @param numScanRetries Maximum number of scans retries (in addition to first scan).
     */
    protected ScanResult scanForTestNon11mcCapableAp(int numScanRetries)
            throws InterruptedException {
        int scanCount = 0;
        ScanResult bestTestAp = null;
        while (scanCount <= numScanRetries) {
            for (ScanResult scanResult : scanAps()) {
                // Ensure using a 5GHz or greater channel
                if (scanResult.is80211mcResponder()
                        || scanResult.centerFreq0 < FREQUENCY_OF_5GHZ_BAND_IN_MHZ) {
                    continue;
                }
                if (bestTestAp == null || scanResult.level > bestTestAp.level) {
                    bestTestAp = scanResult;
                }
            }
            if (bestTestAp == null) {
                // Ongoing connection may cause scan failure, wait for a while before next scan.
                Thread.sleep(INTERVAL_BETWEEN_FAILURE_SCAN_MILLIS);
            }
            scanCount++;
        }
        return bestTestAp;
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.TestHelper"	"isEmpty"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/TestHelper.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import static android.Manifest.permission.CONNECTIVITY_INTERNAL;
import static android.Manifest.permission.NETWORK_SETTINGS;
import static android.net.ConnectivityManager.NetworkCallback.FLAG_INCLUDE_LOCATION_INFO;
import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PAID;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PRIVATE;
import static android.net.NetworkCapabilities.TRANSPORT_WIFI;
import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;

import static org.junit.Assert.fail;

import android.annotation.NonNull;
import android.app.UiAutomation;
import android.content.Context;
import android.net.ConnectivityManager;
import android.net.MacAddress;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.wifi.ScanResult;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSpecifier;
import android.net.wifi.WifiNetworkSuggestion;
import android.os.Build;
import android.os.WorkSource;
import android.support.test.uiautomator.UiDevice;
import android.text.TextUtils;
import android.util.Log;

import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ApiLevelUtil;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Class to hold helper methods that are repeated across wifi CTS tests.
 */
public class TestHelper {
    private static final String TAG = ""WifiTestHelper"";

    private final Context mContext;
    private final WifiManager mWifiManager;
    private final ConnectivityManager mConnectivityManager;
    private final UiDevice mUiDevice;

    private static final int DURATION_MILLIS = 10_000;
    private static final int DURATION_NETWORK_CONNECTION_MILLIS = 40_000;
    private static final int DURATION_SCREEN_TOGGLE_MILLIS = 2000;
    private static final int DURATION_UI_INTERACTION_MILLIS = 25_000;
    private static final int SCAN_RETRY_CNT_TO_FIND_MATCHING_BSSID = 3;

    public TestHelper(@NonNull Context context, @NonNull UiDevice uiDevice) {
        mContext = context;
        mWifiManager = context.getSystemService(WifiManager.class);
        mConnectivityManager = context.getSystemService(ConnectivityManager.class);
        mUiDevice = uiDevice;
    }

    public void turnScreenOn() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_WAKEUP"");
        mUiDevice.executeShellCommand(""wm dismiss-keyguard"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE_MILLIS);
    }

    public void turnScreenOff() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_SLEEP"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE_MILLIS);
    }

    private static class TestScanResultsCallback extends WifiManager.ScanResultsCallback {
        private final CountDownLatch mCountDownLatch;
        public boolean onAvailableCalled = false;

        TestScanResultsCallback(CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onScanResultsAvailable() {
            onAvailableCalled = true;
            mCountDownLatch.countDown();
        }
    }

    /**
     * Loops through all the saved networks available in the scan results. Returns a list of
     * WifiConfiguration with the matching bssid filled in {@link WifiConfiguration#BSSID}.
     *
     * Note:
     * a) If there are more than 2 networks with the same SSID, but different credential type, then
     * this matching may pick the wrong one.
     *
     * @param wifiManager WifiManager service
     * @param savedNetworks List of saved networks on the device.
     */
    public static List<WifiConfiguration> findMatchingSavedNetworksWithBssid(
            @NonNull WifiManager wifiManager, @NonNull List<WifiConfiguration> savedNetworks) {
        if (savedNetworks.isEmpty()) return Collections.emptyList();
        List<WifiConfiguration> matchingNetworksWithBssids = new ArrayList<>();
        CountDownLatch countDownLatch = new CountDownLatch(1);
        for (int i = 0; i < SCAN_RETRY_CNT_TO_FIND_MATCHING_BSSID; i++) {
            // Trigger a scan to get fresh scan results.
            TestScanResultsCallback scanResultsCallback =
                    new TestScanResultsCallback(countDownLatch);
            try {
                wifiManager.registerScanResultsCallback(
                        Executors.newSingleThreadExecutor(), scanResultsCallback);
                wifiManager.startScan(new WorkSource(myUid()));
                // now wait for callback
                countDownLatch.await(DURATION_MILLIS, TimeUnit.MILLISECONDS);
            } catch (InterruptedException e) {
            } finally {
                wifiManager.unregisterScanResultsCallback(scanResultsCallback);
            }
            List<ScanResult> scanResults = wifiManager.getScanResults();
            if (scanResults == null || scanResults.isEmpty()) fail(""No scan results available"");
            for (ScanResult scanResult : scanResults) {
                WifiConfiguration matchingNetwork = savedNetworks.stream()
                        .filter(network -> TextUtils.equals(
                                scanResult.SSID, WifiInfo.sanitizeSsid(network.SSID)))
                        .findAny()
                        .orElse(null);
                if (matchingNetwork != null) {
                    // make a copy in case we have 2 bssid's for the same network.
                    WifiConfiguration matchingNetworkCopy = new WifiConfiguration(matchingNetwork);
                    matchingNetworkCopy.BSSID = scanResult.BSSID;
                    matchingNetworksWithBssids.add(matchingNetworkCopy);
                }
            }
            if (!matchingNetworksWithBssids.isEmpty()) break;
        }
        return matchingNetworksWithBssids;
    }

    /**
     * Convert the provided saved network to a corresponding suggestion builder.
     */
    public static WifiNetworkSuggestion.Builder
            createSuggestionBuilderWithCredentialFromSavedNetworkWithBssid(
            @NonNull WifiConfiguration network) {
        WifiNetworkSuggestion.Builder suggestionBuilder = new WifiNetworkSuggestion.Builder()
                .setSsid(WifiInfo.sanitizeSsid(network.SSID))
                .setBssid(MacAddress.fromString(network.BSSID));
        if (network.preSharedKey != null) {
            if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_PSK)) {
                suggestionBuilder.setWpa2Passphrase(WifiInfo.sanitizeSsid(network.preSharedKey));
            } else if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.SAE)) {
                suggestionBuilder.setWpa3Passphrase(WifiInfo.sanitizeSsid(network.preSharedKey));
            } else {
                fail(""Unsupported security type found in saved networks"");
            }
        } else if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.OWE)) {
            suggestionBuilder.setIsEnhancedOpen(true);
        } else if (!network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.NONE)) {
            fail(""Unsupported security type found in saved networks"");
        }
        suggestionBuilder.setIsHiddenSsid(network.hiddenSSID);
        return suggestionBuilder;
    }


    /**
     * Convert the provided saved network to a corresponding specifier builder.
     */
    public static WifiNetworkSpecifier.Builder createSpecifierBuilderWithCredentialFromSavedNetwork(
            @NonNull WifiConfiguration network) {
        WifiNetworkSpecifier.Builder specifierBuilder = new WifiNetworkSpecifier.Builder()
                .setSsid(WifiInfo.sanitizeSsid(network.SSID));
        if (network.preSharedKey != null) {
            if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_PSK)) {
                specifierBuilder.setWpa2Passphrase(WifiInfo.sanitizeSsid(network.preSharedKey));
            } else if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.SAE)) {
                specifierBuilder.setWpa3Passphrase(WifiInfo.sanitizeSsid(network.preSharedKey));
            } else {
                fail(""Unsupported security type found in saved networks"");
            }
        } else if (network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.OWE)) {
            specifierBuilder.setIsEnhancedOpen(true);
        } else if (!network.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.NONE)) {
            fail(""Unsupported security type found in saved networks"");
        }
        specifierBuilder.setIsHiddenSsid(network.hiddenSSID);
        return specifierBuilder;
    }

    /**
     * Convert the provided saved network to a corresponding specifier builder.
     */
    public static WifiNetworkSpecifier.Builder
            createSpecifierBuilderWithCredentialFromSavedNetworkWithBssid(
            @NonNull WifiConfiguration network) {
        return createSpecifierBuilderWithCredentialFromSavedNetwork(network)
                .setBssid(MacAddress.fromString(network.BSSID));
    }

    private static class TestNetworkCallback extends ConnectivityManager.NetworkCallback {
        private final CountDownLatch mCountDownLatch;
        public boolean onAvailableCalled = false;
        public boolean onUnavailableCalled = false;
        public NetworkCapabilities networkCapabilities;

        TestNetworkCallback(@NonNull CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        TestNetworkCallback(@NonNull CountDownLatch countDownLatch, int flags) {
            super(flags);
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onAvailable(Network network) {
            onAvailableCalled = true;
        }

        @Override
        public void onCapabilitiesChanged(Network network,
                NetworkCapabilities networkCapabilities) {
            this.networkCapabilities = networkCapabilities;
            mCountDownLatch.countDown();
        }

        @Override
        public void onUnavailable() {
            onUnavailableCalled = true;
            mCountDownLatch.countDown();
        }
    }

    private static TestNetworkCallback createTestNetworkCallback(
            @NonNull CountDownLatch countDownLatch) {
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            // flags for NetworkCallback only introduced in S.
            return new TestNetworkCallback(countDownLatch, FLAG_INCLUDE_LOCATION_INFO);
        } else {
            return new TestNetworkCallback(countDownLatch);
        }
    }

    @NonNull
    private WifiInfo getWifiInfo(@NonNull NetworkCapabilities networkCapabilities) {
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            // WifiInfo in transport info, only available in S.
            return (WifiInfo) networkCapabilities.getTransportInfo();
        } else {
            return mWifiManager.getConnectionInfo();
        }
    }

    private static void assertConnectionEquals(@NonNull WifiConfiguration network,
            @NonNull WifiInfo wifiInfo) {
        assertThat(network.SSID).isEqualTo(wifiInfo.getSSID());
        assertThat(network.BSSID).isEqualTo(wifiInfo.getBSSID());
    }

    private static class TestActionListener implements WifiManager.ActionListener {
        private final CountDownLatch mCountDownLatch;
        public boolean onSuccessCalled = false;
        public boolean onFailedCalled = false;

        TestActionListener(CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onSuccess() {
            onSuccessCalled = true;
            mCountDownLatch.countDown();
        }

        @Override
        public void onFailure(int reason) {
            onFailedCalled = true;
            mCountDownLatch.countDown();
        }
    }

    /**
     * Triggers connection to one of the saved networks using {@link WifiManager#connect(
     * WifiConfiguration, WifiManager.ActionListener)}
     *
     * @param network saved network from the device to use for the connection.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithConnect(
            @NonNull WifiConfiguration network) throws Exception {
        CountDownLatch countDownLatchAl = new CountDownLatch(1);
        CountDownLatch countDownLatchNr = new CountDownLatch(1);
        TestActionListener actionListener = new TestActionListener(countDownLatchAl);
        TestNetworkCallback testNetworkCallback = createTestNetworkCallback(countDownLatchNr);
        UiAutomation uiAutomation = InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity();
            // File a callback for wifi network.
            mConnectivityManager.registerNetworkCallback(
                    new NetworkRequest.Builder()
                            .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                            .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                            // Needed to ensure that the restricted concurrent connection does not
                            // match this request.
                            .addForbiddenCapability(NET_CAPABILITY_OEM_PAID)
                            .addForbiddenCapability(NET_CAPABILITY_OEM_PRIVATE)
                            .build(),
                    testNetworkCallback);
            // Trigger the connection.
            mWifiManager.connect(network, actionListener);
            // now wait for action listener callback
            assertThat(countDownLatchAl.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
            // check if we got the success callback
            assertThat(actionListener.onSuccessCalled).isTrue();

            // Wait for connection to complete & ensure we are connected to the saved network.
            assertThat(countDownLatchNr.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
            assertThat(testNetworkCallback.onAvailableCalled).isTrue();
            final WifiInfo wifiInfo = getWifiInfo(testNetworkCallback.networkCapabilities);
            assertConnectionEquals(network, wifiInfo);
            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                // User connections should always be primary.
                assertThat(wifiInfo.isPrimary()).isTrue();
            }
        } catch (Throwable e /* catch assertions & exceptions */) {
            // Unregister the network callback in case of any failure (since we don't end up
            // returning the network callback to the caller).
            try {
                mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
            } catch (IllegalArgumentException ie) { }
            throw e;
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
        return testNetworkCallback;
    }

    /**
     * Tests the entire connection success flow using the provided suggestion.
     *
     * Note: The caller needs to invoke this after acquiring shell identity.
     *
     * @param network saved network from the device to use for the connection.
     * @param suggestion suggestion to use for the connection.
     * @param executorService Excutor service to run scan periodically (to trigger connection).
     * @param restrictedNetworkCapabilities Whether this connection should be restricted with
     *                                    the provided capability.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithSuggestionWithShellIdentity(
            WifiConfiguration network, WifiNetworkSuggestion suggestion,
            @NonNull ScheduledExecutorService executorService,
            @NonNull Set<Integer> restrictedNetworkCapabilities) throws Exception {
        return testConnectionFlowWithSuggestionInternal(
                network, suggestion, executorService, restrictedNetworkCapabilities, true);
    }

    /**
     * Tests the entire connection success flow using the provided suggestion.
     *
     * Note: The helper method drops the shell identity, so don't use this if the caller already
     * adopted shell identity.
     *
     * @param network saved network from the device to use for the connection.
     * @param suggestion suggestion to use for the connection.
     * @param executorService Excutor service to run scan periodically (to trigger connection).
     * @param restrictedNetworkCapabilities Whether this connection should be restricted with
     *                                    the provided capability.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithSuggestion(
            WifiConfiguration network, WifiNetworkSuggestion suggestion,
            @NonNull ScheduledExecutorService executorService,
            @NonNull Set<Integer> restrictedNetworkCapabilities) throws Exception {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(NETWORK_SETTINGS, CONNECTIVITY_INTERNAL);
            return testConnectionFlowWithSuggestionWithShellIdentity(
                    network, suggestion, executorService, restrictedNetworkCapabilities);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests the connection failure flow using the provided suggestion.
     *
     * @param network saved network from the device to use for the connection.
     * @param suggestion suggestion to use for the connection.
     * @param executorService Excutor service to run scan periodically (to trigger connection).
     * @param restrictedNetworkCapabilities Whether this connection should be restricted with
     *                                    the provided capability.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFailureFlowWithSuggestion(
            WifiConfiguration network, WifiNetworkSuggestion suggestion,
            @NonNull ScheduledExecutorService executorService,
            @NonNull Set<Integer> restrictedNetworkCapabilities) throws Exception {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(NETWORK_SETTINGS, CONNECTIVITY_INTERNAL);
            return testConnectionFlowWithSuggestionInternal(
                    network, suggestion, executorService, restrictedNetworkCapabilities, false);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Tests the entire connection success/failure flow using the provided suggestion.
     *
     * @param network saved network from the device to use for the connection.
     * @param suggestion suggestion to use for the connection.
     * @param executorService Excutor service to run scan periodically (to trigger connection).
     * @param restrictedNetworkCapabilities Whether this connection should be restricted with
     *                                    the provided capability.
     * @param expectConnectionSuccess Whether to expect connection success or not.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    private ConnectivityManager.NetworkCallback testConnectionFlowWithSuggestionInternal(
            WifiConfiguration network, WifiNetworkSuggestion suggestion,
            @NonNull ScheduledExecutorService executorService,
            @NonNull Set<Integer> restrictedNetworkCapabilities,
            boolean expectConnectionSuccess) throws Exception {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        // File the network request & wait for the callback.
        TestNetworkCallback testNetworkCallback = createTestNetworkCallback(countDownLatch);
        try {
            // File a request for restricted (oem paid) wifi network.
            NetworkRequest.Builder nrBuilder = new NetworkRequest.Builder()
                    .addTransportType(TRANSPORT_WIFI)
                    .addCapability(NET_CAPABILITY_INTERNET);
            if (restrictedNetworkCapabilities.isEmpty()) {
                // If not a restricted connection, a network callback is sufficient.
                mConnectivityManager.registerNetworkCallback(
                        nrBuilder.build(), testNetworkCallback);
            } else {
                for (Integer restrictedNetworkCapability : restrictedNetworkCapabilities) {
                    nrBuilder.addCapability(restrictedNetworkCapability);
                }
                mConnectivityManager.requestNetwork(nrBuilder.build(), testNetworkCallback);
            }
            // Add wifi network suggestion.
            assertThat(mWifiManager.addNetworkSuggestions(Arrays.asList(suggestion)))
                    .isEqualTo(WifiManager.STATUS_NETWORK_SUGGESTIONS_SUCCESS);
            // Wait for the request to reach the wifi stack before kick-start periodic scans.
            Thread.sleep(100);
            // Step: Trigger scans periodically to trigger network selection quicker.
            executorService.scheduleAtFixedRate(() -> {
                if (!mWifiManager.startScan()) {
                    Log.w(TAG, ""Failed to trigger scan"");
                }
            }, 0, DURATION_MILLIS, TimeUnit.MILLISECONDS);
            if (expectConnectionSuccess) {
                // now wait for connection to complete and wait for callback
                assertThat(countDownLatch.await(
                        DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
                assertThat(testNetworkCallback.onAvailableCalled).isTrue();
                final WifiInfo wifiInfo = getWifiInfo(testNetworkCallback.networkCapabilities);
                assertConnectionEquals(network, wifiInfo);
                if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
                    assertThat(wifiInfo.isTrusted()).isTrue();
                    WifiInfo redact = wifiInfo
                            .makeCopy(NetworkCapabilities.REDACT_FOR_ACCESS_FINE_LOCATION);
                    assertThat(wifiInfo.getInformationElements()).isNotNull();
                    assertThat(redact.getInformationElements()).isNull();
                    assertThat(redact.getApplicableRedactions()).isEqualTo(
                            NetworkCapabilities.REDACT_FOR_ACCESS_FINE_LOCATION
                            | NetworkCapabilities.REDACT_FOR_LOCAL_MAC_ADDRESS
                            | NetworkCapabilities.REDACT_FOR_NETWORK_SETTINGS);
                }
                if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                    // If STA concurrency for restricted connection is supported, this should not
                    // be the primary connection.
                    if (!restrictedNetworkCapabilities.isEmpty()
                            && mWifiManager.isStaConcurrencyForRestrictedConnectionsSupported()) {
                        assertThat(wifiInfo.isPrimary()).isFalse();
                    } else {
                        assertThat(wifiInfo.isPrimary()).isTrue();
                    }
                }
            } else {
                // now wait for connection to timeout.
                assertThat(countDownLatch.await(
                        DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isFalse();
            }
        } catch (Throwable e /* catch assertions & exceptions */) {
            try {
                mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
            } catch (IllegalArgumentException ie) { }
            throw e;
        } finally {
            executorService.shutdown();
        }
        return testNetworkCallback;
    }

    private static class TestNetworkRequestMatchCallback implements
            WifiManager.NetworkRequestMatchCallback {
        private final Object mLock;

        public boolean onRegistrationCalled = false;
        public boolean onAbortCalled = false;
        public boolean onMatchCalled = false;
        public boolean onConnectSuccessCalled = false;
        public boolean onConnectFailureCalled = false;
        public WifiManager.NetworkRequestUserSelectionCallback userSelectionCallback = null;
        public List<ScanResult> matchedScanResults = null;

        TestNetworkRequestMatchCallback(Object lock) {
            mLock = lock;
        }

        @Override
        public void onUserSelectionCallbackRegistration(
                WifiManager.NetworkRequestUserSelectionCallback userSelectionCallback) {
            synchronized (mLock) {
                onRegistrationCalled = true;
                this.userSelectionCallback = userSelectionCallback;
                mLock.notify();
            }
        }

        @Override
        public void onAbort() {
            synchronized (mLock) {
                onAbortCalled = true;
                mLock.notify();
            }
        }

        @Override
        public void onMatch(List<ScanResult> scanResults) {
            synchronized (mLock) {
                // This can be invoked multiple times. So, ignore after the first one to avoid
                // disturbing the rest of the test sequence.
                if (onMatchCalled) return;
                onMatchCalled = true;
                matchedScanResults = scanResults;
                mLock.notify();
            }
        }

        @Override
        public void onUserSelectionConnectSuccess(WifiConfiguration config) {
            synchronized (mLock) {
                onConnectSuccessCalled = true;
                mLock.notify();
            }
        }

        @Override
        public void onUserSelectionConnectFailure(WifiConfiguration config) {
            synchronized (mLock) {
                onConnectFailureCalled = true;
                mLock.notify();
            }
        }
    }

    private void handleUiInteractions(WifiConfiguration network, boolean shouldUserReject) {
        // can't use CountDownLatch since there are many callbacks expected and CountDownLatch
        // cannot be reset.
        // TODO(b/177591382): Use ArrayBlockingQueue/LinkedBlockingQueue
        Object uiLock = new Object();
        TestNetworkRequestMatchCallback networkRequestMatchCallback =
                new TestNetworkRequestMatchCallback(uiLock);
        try {
            // 1. Wait for registration callback.
            synchronized (uiLock) {
                try {
                    mWifiManager.registerNetworkRequestMatchCallback(
                            Executors.newSingleThreadExecutor(), networkRequestMatchCallback);
                    uiLock.wait(DURATION_UI_INTERACTION_MILLIS);
                } catch (InterruptedException e) {
                }
            }
            assertThat(networkRequestMatchCallback.onRegistrationCalled).isTrue();
            assertThat(networkRequestMatchCallback.userSelectionCallback).isNotNull();

            // 2. Wait for matching scan results
            synchronized (uiLock) {
                if (!networkRequestMatchCallback.onMatchCalled) {
                    try {
                        uiLock.wait(DURATION_UI_INTERACTION_MILLIS);
                    } catch (InterruptedException e) {
                    }
                }
            }
            assertThat(networkRequestMatchCallback.onMatchCalled).isTrue();
            assertThat(networkRequestMatchCallback.matchedScanResults).isNotNull();
            assertThat(networkRequestMatchCallback.matchedScanResults.size()).isAtLeast(1);

            // 3. Trigger connection to one of the matched networks or reject the request.
            if (shouldUserReject) {
                networkRequestMatchCallback.userSelectionCallback.reject();
            } else {
                networkRequestMatchCallback.userSelectionCallback.select(network);
            }

            // 4. Wait for connection success or abort.
            synchronized (uiLock) {
                try {
                    uiLock.wait(DURATION_UI_INTERACTION_MILLIS);
                } catch (InterruptedException e) {
                }
            }
            if (shouldUserReject) {
                assertThat(networkRequestMatchCallback.onAbortCalled).isTrue();
            } else {
                assertThat(networkRequestMatchCallback.onConnectSuccessCalled).isTrue();
            }
        } finally {
            mWifiManager.unregisterNetworkRequestMatchCallback(networkRequestMatchCallback);
        }
    }

    /**
     * Tests the entire connection flow using the provided specifier,
     *
     * Note: The caller needs to invoke this after acquiring shell identity.
     *
     * @param specifier Specifier to use for network request.
     * @param shouldUserReject Whether to simulate user rejection or not.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithSpecifierWithShellIdentity(
            WifiConfiguration network, WifiNetworkSpecifier specifier, boolean shouldUserReject)
            throws Exception {
        CountDownLatch countDownLatch = new CountDownLatch(1);
        // File the network request & wait for the callback.
        TestNetworkCallback testNetworkCallback = createTestNetworkCallback(countDownLatch);

        // Fork a thread to handle the UI interactions.
        Thread uiThread = new Thread(() -> {
            try {
                handleUiInteractions(network, shouldUserReject);
            } catch (Throwable e /* catch assertions & exceptions */) {
                try {
                    mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
                } catch (IllegalArgumentException ie) { }
                throw e;
            }
        });

        try {
            // File a request for wifi network.
            mConnectivityManager.requestNetwork(
                    new NetworkRequest.Builder()
                            .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                            .removeCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                            .setNetworkSpecifier(specifier)
                            .build(),
                    testNetworkCallback);
            // Wait for the request to reach the wifi stack before kick-starting the UI
            // interactions.
            Thread.sleep(1_000);
            // Start the UI interactions.
            uiThread.run();
            // now wait for callback
            assertThat(countDownLatch.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
            if (shouldUserReject) {
                assertThat(testNetworkCallback.onUnavailableCalled).isTrue();
            } else {
                assertThat(testNetworkCallback.onAvailableCalled).isTrue();
                final WifiInfo wifiInfo = getWifiInfo(testNetworkCallback.networkCapabilities);
                assertConnectionEquals(network, wifiInfo);
                if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                    // If STA concurrency for local only connection is supported, this should not
                    // be the primary connection.
                    if (mWifiManager.isStaConcurrencyForLocalOnlyConnectionsSupported()) {
                        assertThat(wifiInfo.isPrimary()).isFalse();
                    } else {
                        assertThat(wifiInfo.isPrimary()).isTrue();
                    }
                }
            }
        } catch (Throwable e /* catch assertions & exceptions */) {
            try {
                mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
            } catch (IllegalArgumentException ie) { }
            throw e;
        }
        try {
            // Ensure that the UI interaction thread has completed.
            uiThread.join(DURATION_UI_INTERACTION_MILLIS);
        } catch (InterruptedException e) {
            try {
                mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
            } catch (IllegalArgumentException ie) { }
            fail(""UI interaction interrupted"");
        }
        return testNetworkCallback;
    }

    /**
     * Tests the entire connection flow using the provided specifier.
     *
     * Note: The helper method drops the shell identity, so don't use this if the caller already
     * adopted shell identity.
     *
     * @param specifier Specifier to use for network request.
     * @param shouldUserReject Whether to simulate user rejection or not.
     *
     * @return NetworkCallback used for the connection (can be used by client to release the
     * connection.
     */
    public ConnectivityManager.NetworkCallback testConnectionFlowWithSpecifier(
            WifiConfiguration network, WifiNetworkSpecifier specifier, boolean shouldUserReject)
            throws Exception {
        final UiAutomation uiAutomation =
                InstrumentationRegistry.getInstrumentation().getUiAutomation();
        try {
            uiAutomation.adoptShellPermissionIdentity(NETWORK_SETTINGS);
            return testConnectionFlowWithSpecifierWithShellIdentity(
                    network, specifier, shouldUserReject);
        } finally {
            uiAutomation.dropShellPermissionIdentity();
        }
    }

    /**
     * Returns the number of wifi connections visible at the networking layer.
     */
    public long getNumWifiConnections() {
        Network[] networks = mConnectivityManager.getAllNetworks();
        return Arrays.stream(networks)
                .filter(n ->
                        mConnectivityManager.getNetworkCapabilities(n).hasTransport(TRANSPORT_WIFI))
                .count();
    }

    /**
     * Registers a network callback for internet connectivity via wifi and asserts that a network
     * is available within {@link #DURATION_NETWORK_CONNECTION_MILLIS}.
     *
     * @throws Exception
     */
    public void assertWifiInternetConnectionAvailable() throws Exception {
        CountDownLatch countDownLatchNr = new CountDownLatch(1);
        TestNetworkCallback testNetworkCallback = createTestNetworkCallback(countDownLatchNr);
        try {
            // File a callback for wifi network.
            NetworkRequest.Builder builder = new NetworkRequest.Builder()
                    .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                    .addCapability(NET_CAPABILITY_INTERNET);
            if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
                // Needed to ensure that the restricted concurrent connection does not
                // match this request.
                builder.addForbiddenCapability(NET_CAPABILITY_OEM_PAID)
                        .addForbiddenCapability(NET_CAPABILITY_OEM_PRIVATE);
            }
            mConnectivityManager.registerNetworkCallback(builder.build(), testNetworkCallback);
            // Wait for connection to complete & ensure we are connected to some network capable
            // of providing internet access.
            assertThat(countDownLatchNr.await(
                    DURATION_NETWORK_CONNECTION_MILLIS, TimeUnit.MILLISECONDS)).isTrue();
            assertThat(testNetworkCallback.onAvailableCalled).isTrue();
        } finally {
            mConnectivityManager.unregisterNetworkCallback(testNetworkCallback);
        }
    }

    public static int getBandFromFrequency(final int freqMHz) {
        if (freqMHz < 1000) {
            return ScanResult.UNSPECIFIED;
        } else if (freqMHz < 4000) { // getFrequency is in WifiInfo.FREQUENCY_UNITS = MHz
            return ScanResult.WIFI_BAND_24_GHZ;
        } else if (freqMHz < 5900) {
            // 5GHz band stops at 5885MHz, 6GHz band starts at 5955. See android.net.wifi.ScanResult
            return ScanResult.WIFI_BAND_5_GHZ;
        } else if (freqMHz < 10_000) {
            return ScanResult.WIFI_BAND_6_GHZ;
        } else if (freqMHz < 71_000) {
            // 60 GHz band stops at 70_200
            return ScanResult.WIFI_BAND_60_GHZ;
        } else {
            return ScanResult.UNSPECIFIED;
        }
    }

}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.wifibroadcasts.cts.WifiBroadcastsHostJUnit4Test"	"testCleanLogcat"	"CtsWifiBroadcastsHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/wifibroadcasts/src/android/wifibroadcasts/cts/WifiBroadcastsHostJUnit4Test.java"	""	"public void testCleanLogcat() throws Exception {
        ITestDevice device = getDevice();
        assertNotNull(""Device not set"", device);
        if (!device.hasFeature(FEATURE_WIFI)) {
            return;
        }
        // Clear activity
        device.executeShellCommand(CLEAR_COMMAND);
        // No mobile data or wifi to start with
        device.executeShellCommand(""svc data disable; svc wifi disable"");
        // Clear logcat.
        device.executeAdbCommand(""logcat"", ""-c"");
        // Ensure the screen is on, so that rssi polling happens
        device.executeShellCommand(""input keyevent KEYCODE_WAKEUP"");
        // Start the APK
        device.executeShellCommand(START_COMMAND);
        // Bring up wifi
        device.executeShellCommand(""svc wifi enable; sleep 1"");
        // Make sure wifi comes up
        String pingResult = """";
        CommandResult pingCommandResult = null;
        boolean pingSucceeded = false;
        for (int tries = 0; tries < MAXIMUM_PING_TRIES; tries++) {
            if (tries > 0 && tries % MAXIMUM_PING_TRIES_PER_CONNECTION == 0) {
                // if we have been trying for a while, toggle wifi off and then on.
                device.executeShellCommand(""svc wifi disable; sleep 1; svc wifi enable; sleep 3"");
            }
            // We don't require internet connectivity, just a configured address
            pingCommandResult = device.executeShellV2Command(""ping -c 4 -W 2 -t 1 8.8.8.8"");
            pingResult = String.join(""/"", pingCommandResult.getStdout(),
                                          pingCommandResult.getStderr(),
                                          pingCommandResult.getStatus().toString());
            if (pingResult.contains(""4 packets transmitted"")) {
                pingSucceeded = true;
                break;
            }
            Thread.sleep(1000);
        }
        // Stop wifi
        device.executeShellCommand(""svc wifi disable"");

        assertTrue(""Wi-Fi network unavailable - test could not complete "" + pingResult,
                pingSucceeded);

        // Dump logcat.
        String logs = device.executeAdbCommand(""logcat"", ""-v"", ""brief"", ""-d"", CLASS + "":I"", ""*:S"");
        // Search for prohibited string.
        Scanner in = new Scanner(logs);
        try {
            while (in.hasNextLine()) {
                String line = in.nextLine();
                if (line.startsWith(""I/"" + CLASS)) {
                    String payload = line.split("":"")[1].trim();
                    assertFalse(payload, payload.contains(PROHIBITED_STRING));
                }
            }
        } finally {
            in.close();
        }
        //Re-enable Wi-Fi as part of CTS Pre-conditions
        device.executeShellCommand(""svc wifi enable; sleep 1"");
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.nl80211.cts.DeviceWiphyCapabilitiesTest"	"isTrue"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/nl80211/cts/DeviceWiphyCapabilitiesTest.java"	""	"public void canSerializeAndDeserialize() {
        DeviceWiphyCapabilities capa = new DeviceWiphyCapabilities();

        capa.setWifiStandardSupport(ScanResult.WIFI_STANDARD_11N, true);
        capa.setWifiStandardSupport(ScanResult.WIFI_STANDARD_11AC, true);
        capa.setWifiStandardSupport(ScanResult.WIFI_STANDARD_11AX, false);

        Parcel parcel = Parcel.obtain();
        capa.writeToParcel(parcel, 0);
        // Rewind the pointer to the head of the parcel.
        parcel.setDataPosition(0);
        DeviceWiphyCapabilities capaDeserialized =
                DeviceWiphyCapabilities.CREATOR.createFromParcel(parcel);

        assertThat(capaDeserialized.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11N)).isTrue();
        assertThat(capaDeserialized.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11AC))
                .isTrue();
        assertThat(capaDeserialized.isWifiStandardSupported(ScanResult.WIFI_STANDARD_11AX))
                .isFalse();
        assertThat(capaDeserialized).isEqualTo(capa);
        assertThat(capaDeserialized.hashCode()).isEqualTo(capa.hashCode());
    }

    /** Test mapping wifi standard support into channel width support */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.nl80211.cts.DeviceWiphyCapabilitiesTest"	"testMappingWifiStandardIntoChannelWidthSupport"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/nl80211/cts/DeviceWiphyCapabilitiesTest.java"	""	"public void testMappingWifiStandardIntoChannelWidthSupport() {
        DeviceWiphyCapabilities capa = new DeviceWiphyCapabilities();

        capa.setWifiStandardSupport(ScanResult.WIFI_STANDARD_11N, false);
        capa.setWifiStandardSupport(ScanResult.WIFI_STANDARD_11AC, false);
        capa.setWifiStandardSupport(ScanResult.WIFI_STANDARD_11AX, false);
        assertThat(capa.isChannelWidthSupported(ScanResult.CHANNEL_WIDTH_20MHZ)).isTrue();
        assertThat(capa.isChannelWidthSupported(ScanResult.CHANNEL_WIDTH_40MHZ)).isFalse();
        assertThat(capa.isChannelWidthSupported(ScanResult.CHANNEL_WIDTH_80MHZ)).isFalse();

        capa.setWifiStandardSupport(ScanResult.WIFI_STANDARD_11N, true);
        assertThat(capa.isChannelWidthSupported(ScanResult.CHANNEL_WIDTH_20MHZ)).isTrue();
        assertThat(capa.isChannelWidthSupported(ScanResult.CHANNEL_WIDTH_40MHZ)).isTrue();
        assertThat(capa.isChannelWidthSupported(ScanResult.CHANNEL_WIDTH_80MHZ)).isFalse();

        capa.setWifiStandardSupport(ScanResult.WIFI_STANDARD_11AC, true);
        assertThat(capa.isChannelWidthSupported(ScanResult.CHANNEL_WIDTH_20MHZ)).isTrue();
        assertThat(capa.isChannelWidthSupported(ScanResult.CHANNEL_WIDTH_40MHZ)).isTrue();
        assertThat(capa.isChannelWidthSupported(ScanResult.CHANNEL_WIDTH_80MHZ)).isTrue();
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.SupplicantStateTest"	"testIsValidState"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/SupplicantStateTest.java"	""	"public void testIsValidState() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        assertTrue(SupplicantState.isValidState(SupplicantState.DISCONNECTED));
        assertTrue(SupplicantState.isValidState(SupplicantState.INACTIVE));
        assertTrue(SupplicantState.isValidState(SupplicantState.SCANNING));
        assertTrue(SupplicantState.isValidState(SupplicantState.ASSOCIATING));
        assertTrue(SupplicantState.isValidState(SupplicantState.ASSOCIATED));
        assertTrue(SupplicantState.isValidState(SupplicantState.FOUR_WAY_HANDSHAKE));
        assertTrue(SupplicantState.isValidState(SupplicantState.GROUP_HANDSHAKE));
        assertTrue(SupplicantState.isValidState(SupplicantState.COMPLETED));
        assertTrue(SupplicantState.isValidState(SupplicantState.DORMANT));
        assertFalse(SupplicantState.isValidState(SupplicantState.UNINITIALIZED));
        assertFalse(SupplicantState.isValidState(SupplicantState.INVALID));
    }

}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiInfoTest"	"isNotNull"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiInfoTest.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import static com.google.common.truth.Truth.assertThat;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.wifi.ScanResult;
import android.net.wifi.SupplicantState;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiManager.WifiLock;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;
import android.telephony.SubscriptionManager;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

import java.nio.charset.StandardCharsets;

@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
public class WifiInfoTest extends WifiJUnit3TestBase {
    private static class MySync {
        int expectedState = STATE_NULL;
    }

    private WifiManager mWifiManager;
    private WifiLock mWifiLock;
    private static MySync mMySync;

    private static final int STATE_NULL = 0;
    private static final int STATE_WIFI_CHANGING = 1;
    private static final int STATE_WIFI_CHANGED = 2;

    private static final String TEST_SSID = ""Test123"";
    private static final String TEST_BSSID = ""12:12:12:12:12:12"";
    private static final int TEST_RSSI = -60;
    private static final int TEST_NETWORK_ID = 5;
    private static final int TEST_NETWORK_ID2 = 6;

    private static final String TAG = ""WifiInfoTest"";
    private static final int TIMEOUT_MSEC = 6000;
    private static final int WAIT_MSEC = 60;
    private static final int DURATION = 10000;
    private static final int WIFI_CONNECT_TIMEOUT_MILLIS = 30_000;
    private IntentFilter mIntentFilter;
    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            final String action = intent.getAction();
            if (action.equals(WifiManager.WIFI_STATE_CHANGED_ACTION)) {
                synchronized (mMySync) {
                    mMySync.expectedState = STATE_WIFI_CHANGED;
                    mMySync.notify();
                }
            }
        }
    };

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mMySync = new MySync();
        mIntentFilter = new IntentFilter();
        mIntentFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);

        mContext.registerReceiver(mReceiver, mIntentFilter);
        mWifiManager = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        assertThat(mWifiManager).isNotNull();
        mWifiLock = mWifiManager.createWifiLock(TAG);
        mWifiLock.acquire();

        // enable Wifi
        if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);
        PollingCheck.check(""Wifi not enabled"", DURATION, () -> mWifiManager.isWifiEnabled());

        mMySync.expectedState = STATE_NULL;
    }

    @Override
    protected void tearDown() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            super.tearDown();
            return;
        }
        mWifiLock.release();
        mContext.unregisterReceiver(mReceiver);
        if (!mWifiManager.isWifiEnabled())
            setWifiEnabled(true);
        Thread.sleep(DURATION);
        super.tearDown();
    }

    private void setWifiEnabled(boolean enable) throws Exception {
        synchronized (mMySync) {
            mMySync.expectedState = STATE_WIFI_CHANGING;
            if (enable) {
                SystemUtil.runShellCommand(""svc wifi enable"");
            } else {
                SystemUtil.runShellCommand(""svc wifi disable"");
            }
            long timeout = System.currentTimeMillis() + TIMEOUT_MSEC;
            while (System.currentTimeMillis() < timeout
                    && mMySync.expectedState == STATE_WIFI_CHANGING)
                mMySync.wait(WAIT_MSEC);
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiInfoTest"	"testWifiInfoProperties"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiInfoTest.java"	""	"public void testWifiInfoProperties() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // ensure Wifi is connected
        ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.reconnect());
        PollingCheck.check(
                ""Wifi not connected - Please ensure there is a saved network in range of this ""
                        + ""device"",
                WIFI_CONNECT_TIMEOUT_MILLIS,
                () -> mWifiManager.getConnectionInfo().getNetworkId() != -1);

        // this test case should in Wifi environment
        WifiInfo wifiInfo = mWifiManager.getConnectionInfo();

        testWifiInfoPropertiesWhileConnected(wifiInfo);

        setWifiEnabled(false);

        PollingCheck.check(""getNetworkId not -1"", 20000,
                () -> mWifiManager.getConnectionInfo().getNetworkId() == -1);

        PollingCheck.check(""getWifiState not disabled"", 20000,
                () -> mWifiManager.getWifiState() == WifiManager.WIFI_STATE_DISABLED);
    }

    private void testWifiInfoPropertiesWhileConnected(WifiInfo wifiInfo) {
        assertThat(wifiInfo).isNotNull();
        assertThat(wifiInfo.toString()).isNotNull();
        SupplicantState.isValidState(wifiInfo.getSupplicantState());
        WifiInfo.getDetailedStateOf(SupplicantState.DISCONNECTED);
        String ssid = wifiInfo.getSSID();
        if (!ssid.startsWith(""0x"") && !ssid.equals(WifiManager.UNKNOWN_SSID)) {
            // Non-hex string should be quoted
            assertThat(ssid).startsWith(""\"""");
            assertThat(ssid).endsWith(""\"""");
        }

        assertThat(wifiInfo.getBSSID()).isNotNull();
        assertThat(wifiInfo.getFrequency()).isGreaterThan(0);
        assertThat(wifiInfo.getMacAddress()).isNotNull();

        wifiInfo.getRssi();
        wifiInfo.getIpAddress();
        wifiInfo.getHiddenSSID();
        wifiInfo.getScore();

        // null for saved networks
        assertThat(wifiInfo.getRequestingPackageName()).isNull();
        assertThat(wifiInfo.getPasspointFqdn()).isNull();
        assertThat(wifiInfo.getPasspointProviderFriendlyName()).isNull();

        // false for saved networks
        assertThat(wifiInfo.isEphemeral()).isFalse();
        assertThat(wifiInfo.isOsuAp()).isFalse();
        assertThat(wifiInfo.isPasspointAp()).isFalse();

        assertThat(wifiInfo.getWifiStandard()).isAnyOf(
                ScanResult.WIFI_STANDARD_UNKNOWN,
                ScanResult.WIFI_STANDARD_LEGACY,
                ScanResult.WIFI_STANDARD_11N,
                ScanResult.WIFI_STANDARD_11AC,
                ScanResult.WIFI_STANDARD_11AX
        );

        assertThat(wifiInfo.getLostTxPacketsPerSecond()).isAtLeast(0.0);
        assertThat(wifiInfo.getRetriedTxPacketsPerSecond()).isAtLeast(0.0);
        assertThat(wifiInfo.getSuccessfulRxPacketsPerSecond()).isAtLeast(0.0);
        assertThat(wifiInfo.getSuccessfulTxPacketsPerSecond()).isAtLeast(0.0);

        // Can be -1 if link speed is unknown
        assertThat(wifiInfo.getLinkSpeed()).isAtLeast(-1);
        assertThat(wifiInfo.getTxLinkSpeedMbps()).isAtLeast(-1);
        assertThat(wifiInfo.getRxLinkSpeedMbps()).isAtLeast(-1);
        assertThat(wifiInfo.getMaxSupportedTxLinkSpeedMbps()).isAtLeast(-1);
        assertThat(wifiInfo.getMaxSupportedRxLinkSpeedMbps()).isAtLeast(-1);
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            assertThat(wifiInfo.getCurrentSecurityType()).isNotEqualTo(
                    WifiInfo.SECURITY_TYPE_UNKNOWN);
        }
    }

    /**
     * Test that the WifiInfo Builder returns the same values that was set, and that
     * calling build multiple times returns different instances.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ScanResultTest"	"isNotNull"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ScanResultTest.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import java.nio.ByteBuffer;
import java.util.List;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.wifi.ScanResult;
import android.net.wifi.ScanResult.InformationElement;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiManager.WifiLock;
import android.platform.test.annotations.AppModeFull;
import android.test.AndroidTestCase;

import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
public class ScanResultTest extends WifiJUnit3TestBase {
    private static class MySync {
        int expectedState = STATE_NULL;
    }

    private WifiManager mWifiManager;
    private WifiLock mWifiLock;
    private static MySync mMySync;
    private boolean mWasVerboseLoggingEnabled;
    private boolean mWasScanThrottleEnabled;

    private static final int STATE_NULL = 0;
    private static final int STATE_WIFI_CHANGING = 1;
    private static final int STATE_WIFI_CHANGED = 2;
    private static final int STATE_START_SCAN = 3;
    private static final int STATE_SCAN_RESULTS_AVAILABLE = 4;
    private static final int STATE_SCAN_FAILURE = 5;

    private static final String TAG = ""WifiInfoTest"";
    private static final int TIMEOUT_MSEC = 6000;
    private static final int WAIT_MSEC = 60;
    private static final int ENABLE_WAIT_MSEC = 10000;
    private static final int SCAN_WAIT_MSEC = 10000;
    private static final int SCAN_MAX_RETRY_COUNT = 6;
    private static final int SCAN_FIND_BSSID_MAX_RETRY_COUNT = 5;
    private static final long SCAN_FIND_BSSID_WAIT_MSEC = 5_000L;
    private static final int WIFI_CONNECT_TIMEOUT_MILLIS = 30_000;

    private static final String TEST_SSID = ""TEST_SSID"";
    public static final String TEST_BSSID = ""04:ac:fe:45:34:10"";
    public static final String TEST_CAPS = ""CCMP"";
    public static final int TEST_LEVEL = -56;
    public static final int TEST_FREQUENCY = 2412;
    public static final long TEST_TIMESTAMP = 4660L;

    private IntentFilter mIntentFilter;
    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            final String action = intent.getAction();
            if (action.equals(WifiManager.SUPPLICANT_STATE_CHANGED_ACTION)) {
                synchronized (mMySync) {
                    mMySync.expectedState = STATE_WIFI_CHANGED;
                    mMySync.notify();
                }
            } else if (action.equals(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION)) {
                synchronized (mMySync) {
                    if (intent.getBooleanExtra(WifiManager.EXTRA_RESULTS_UPDATED, false)) {
                        mMySync.expectedState = STATE_SCAN_RESULTS_AVAILABLE;
                    } else {
                        mMySync.expectedState = STATE_SCAN_FAILURE;
                    }
                    mMySync.notify();
                }
            }
        }
    };

    @Override
    protected void setUp() throws Exception {
        super.setUp();
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        mMySync = new MySync();
        mIntentFilter = new IntentFilter();
        mIntentFilter.addAction(WifiManager.NETWORK_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION);
        mIntentFilter.addAction(WifiManager.SUPPLICANT_CONNECTION_CHANGE_ACTION);
        mIntentFilter.addAction(WifiManager.SUPPLICANT_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.RSSI_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.NETWORK_IDS_CHANGED_ACTION);
        mIntentFilter.addAction(WifiManager.ACTION_PICK_WIFI_NETWORK);

        mContext.registerReceiver(mReceiver, mIntentFilter);
        mWifiManager = (WifiManager) getContext().getSystemService(Context.WIFI_SERVICE);
        assertThat(mWifiManager).isNotNull();

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        mWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(false));

        mWifiLock = mWifiManager.createWifiLock(TAG);
        mWifiLock.acquire();

        // enable Wifi
        if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);
        PollingCheck.check(""Wifi not enabled"", ENABLE_WAIT_MSEC,
                () -> mWifiManager.isWifiEnabled());

        mMySync.expectedState = STATE_NULL;
    }

    @Override
    protected void tearDown() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            super.tearDown();
            return;
        }
        mWifiLock.release();
        mContext.unregisterReceiver(mReceiver);
        if (!mWifiManager.isWifiEnabled())
            setWifiEnabled(true);
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(mWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));
        Thread.sleep(ENABLE_WAIT_MSEC);
        super.tearDown();
    }

    private void setWifiEnabled(boolean enable) throws Exception {
        synchronized (mMySync) {
            mMySync.expectedState = STATE_WIFI_CHANGING;
            if (enable) {
                SystemUtil.runShellCommand(""svc wifi enable"");
            } else {
                SystemUtil.runShellCommand(""svc wifi disable"");
            }
            waitForBroadcast(TIMEOUT_MSEC, STATE_WIFI_CHANGED);
       }
    }

    private boolean waitForBroadcast(long timeout, int expectedState) throws Exception {
        long waitTime = System.currentTimeMillis() + timeout;
        while (System.currentTimeMillis() < waitTime
                && mMySync.expectedState != expectedState)
            mMySync.wait(WAIT_MSEC);
        return mMySync.expectedState == expectedState;
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ScanResultTest"	"testScanResultProperties"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ScanResultTest.java"	""	"public void testScanResultProperties() {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        // this test case should in Wifi environment
        for (ScanResult scanResult : mWifiManager.getScanResults()) {
            assertThat(scanResult.toString()).isNotNull();

            for (InformationElement ie : scanResult.getInformationElements()) {
                testInformationElementCopyConstructor(ie);
                testInformationElementFields(ie);
            }

            assertThat(scanResult.getWifiStandard()).isAnyOf(
                    ScanResult.WIFI_STANDARD_UNKNOWN,
                    ScanResult.WIFI_STANDARD_LEGACY,
                    ScanResult.WIFI_STANDARD_11N,
                    ScanResult.WIFI_STANDARD_11AC,
                    ScanResult.WIFI_STANDARD_11AX
            );

            scanResult.isPasspointNetwork();
        }
    }

    private void testInformationElementCopyConstructor(InformationElement ie) {
        InformationElement copy = new InformationElement(ie);

        assertThat(copy.getId()).isEqualTo(ie.getId());
        assertThat(copy.getIdExt()).isEqualTo(ie.getIdExt());
        assertThat(copy.getBytes()).isEqualTo(ie.getBytes());
    }

    private void testInformationElementFields(InformationElement ie) {
        // id is 1 octet
        int id = ie.getId();
        assertThat(id).isAtLeast(0);
        assertThat(id).isAtMost(255);

        // idExt is 0 or 1 octet
        int idExt = ie.getIdExt();
        assertThat(idExt).isAtLeast(0);
        assertThat(idExt).isAtMost(255);

        ByteBuffer bytes = ie.getBytes();
        assertThat(bytes).isNotNull();
    }

    /* Multiple scans to ensure bssid is updated */
    private void scanAndWait() throws Exception {
        synchronized (mMySync) {
            for (int retry  = 0; retry < SCAN_MAX_RETRY_COUNT; retry++) {
                mMySync.expectedState = STATE_START_SCAN;
                mWifiManager.startScan();
                if (waitForBroadcast(SCAN_WAIT_MSEC, STATE_SCAN_RESULTS_AVAILABLE)) {
                    break;
                }
            }
        }
   }

    @VirtualDeviceNotSupported"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ScanResultTest"	"testScanResultTimeStamp"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ScanResultTest.java"	""	"public void testScanResultTimeStamp() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        long timestamp = 0;
        String BSSID = null;

        scanAndWait();

        List<ScanResult> scanResults = mWifiManager.getScanResults();
        for (ScanResult result : scanResults) {
            BSSID = result.BSSID;
            timestamp = result.timestamp;
            assertThat(timestamp).isNotEqualTo(0);
            break;
        }

        scanAndWait();

        scanResults = mWifiManager.getScanResults();
        for (ScanResult result : scanResults) {
            if (result.BSSID.equals(BSSID)) {
                long timeDiff = (result.timestamp - timestamp) / 1000;
                assertThat(timeDiff).isGreaterThan(0L);
                assertThat(timeDiff).isLessThan(6L * SCAN_WAIT_MSEC);
            }
        }
    }

    /** Test that the copy constructor copies fields correctly. */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ScanResultTest"	"testScanResultConstructors"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ScanResultTest.java"	""	"public void testScanResultConstructors() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        ScanResult scanResult = new ScanResult();
        scanResult.SSID = TEST_SSID;
        scanResult.BSSID = TEST_BSSID;
        scanResult.capabilities = TEST_CAPS;
        scanResult.level = TEST_LEVEL;
        scanResult.frequency = TEST_FREQUENCY;
        scanResult.timestamp = TEST_TIMESTAMP;

        ScanResult scanResult2 = new ScanResult(scanResult);
        assertThat(scanResult2.SSID).isEqualTo(TEST_SSID);
        assertThat(scanResult2.BSSID).isEqualTo(TEST_BSSID);
        assertThat(scanResult2.capabilities).isEqualTo(TEST_CAPS);
        assertThat(scanResult2.level).isEqualTo(TEST_LEVEL);
        assertThat(scanResult2.frequency).isEqualTo(TEST_FREQUENCY);
        assertThat(scanResult2.timestamp).isEqualTo(TEST_TIMESTAMP);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.ScanResultTest"	"testScanResultMatchesWifiInfo"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/ScanResultTest.java"	""	"public void testScanResultMatchesWifiInfo() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }

        // ensure Wifi is connected
        ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.reconnect());
        PollingCheck.check(
                ""Wifi not connected"",
                WIFI_CONNECT_TIMEOUT_MILLIS,
                () -> mWifiManager.getConnectionInfo().getNetworkId() != -1);

        final WifiInfo wifiInfo = mWifiManager.getConnectionInfo();
        assertThat(wifiInfo).isNotNull();

        ScanResult currentNetwork = null;
        for (int i = 0; i < SCAN_FIND_BSSID_MAX_RETRY_COUNT; i++) {
            scanAndWait();
            final List<ScanResult> scanResults = mWifiManager.getScanResults();
            currentNetwork = scanResults.stream().filter(r -> r.BSSID.equals(wifiInfo.getBSSID()))
                    .findAny().orElse(null);

            if (currentNetwork != null) {
                break;
            }
            Thread.sleep(SCAN_FIND_BSSID_WAIT_MSEC);
        }
        assertWithMessage(""Current network not found in scan results"")
                .that(currentNetwork).isNotNull();

        String wifiInfoSsidQuoted = wifiInfo.getSSID();
        String scanResultSsidUnquoted = currentNetwork.SSID;

        assertWithMessage(
                ""SSID mismatch: make sure this isn't a hidden network or an SSID containing ""
                        + ""non-UTF-8 characters - neither is supported by this CTS test."")
                .that(""\"""" + scanResultSsidUnquoted + ""\"""")
                .isEqualTo(wifiInfoSsidQuoted);
        assertThat(currentNetwork.frequency).isEqualTo(wifiInfo.getFrequency());
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSuggestionTest"	"isLocationEnabled"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSuggestionTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PAID;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PRIVATE;
import static android.net.wifi.WifiEnterpriseConfig.Eap.AKA;
import static android.net.wifi.WifiEnterpriseConfig.Eap.WAPI_CERT;
import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.Assume.assumeTrue;

import android.content.Context;
import android.content.pm.PackageManager;
import android.location.LocationManager;
import android.net.ConnectivityManager;
import android.net.MacAddress;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiEnterpriseConfig;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSuggestion;
import android.net.wifi.hotspot2.PasspointConfiguration;
import android.net.wifi.hotspot2.pps.Credential;
import android.net.wifi.hotspot2.pps.HomeSp;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;
import android.telephony.TelephonyManager;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.LargeTest;
import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.List;
import java.util.Set;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;

@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@LargeTest
@RunWith(AndroidJUnit4.class)
public class WifiNetworkSuggestionTest extends WifiJUnit4TestBase {
    private static final String TAG = ""WifiNetworkSuggestionTest"";

    private static final String TEST_SSID = ""testSsid"";
    private static final String TEST_BSSID = ""00:df:aa:bc:12:23"";
    private static final String TEST_PASSPHRASE = ""testPassword"";
    private static final int TEST_PRIORITY = 5;
    private static final int TEST_PRIORITY_GROUP = 1;
    private static final int TEST_SUB_ID = 1;

    private static boolean sWasVerboseLoggingEnabled;
    private static boolean sWasScanThrottleEnabled;
    private static boolean sWasWifiEnabled;

    private static Context sContext;
    private static WifiManager sWifiManager;
    private static ConnectivityManager sConnectivityManager;
    private static UiDevice sUiDevice;
    private static WifiConfiguration sTestNetwork;
    private static ConnectivityManager.NetworkCallback sNsNetworkCallback;
    private static TestHelper sTestHelper;

    private ScheduledExecutorService mExecutorService;

    private static final int DURATION_MILLIS = 10_000;

    @BeforeClass
    public static void setUpClass() throws Exception {
        sContext = InstrumentationRegistry.getInstrumentation().getContext();
        // skip the test if WiFi is not supported
        // Don't use assumeTrue in @BeforeClass
        if (!WifiFeature.isWifiSupported(sContext)) return;
        // skip the test if location is not supported
        if (!sContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOCATION)) return;
        // skip if the location is disabled
        if (!sContext.getSystemService(LocationManager.class).isLocationEnabled()) return;

        sWifiManager = sContext.getSystemService(WifiManager.class);
        assertThat(sWifiManager).isNotNull();
        sConnectivityManager = sContext.getSystemService(ConnectivityManager.class);
        sUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        sTestHelper = new TestHelper(sContext, sUiDevice);

        // turn on verbose logging for tests
        sWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        sWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.setScanThrottleEnabled(false));

        // enable Wifi
        sWasWifiEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.isWifiEnabled());
        if (!sWifiManager.isWifiEnabled()) {
            ShellIdentityUtils.invokeWithShellPermissions(() -> sWifiManager.setWifiEnabled(true));
        }
        PollingCheck.check(""Wifi not enabled"", DURATION_MILLIS, () -> sWifiManager.isWifiEnabled());

        // check we have >= 1 saved network
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.getPrivilegedConfiguredNetworks());
        if (savedNetworks.isEmpty()) {
            return;
        }
        // Pick any network in range.

        List<WifiConfiguration> networks = TestHelper.findMatchingSavedNetworksWithBssid(
                sWifiManager, savedNetworks);
        if (!networks.isEmpty()) {
            sTestNetwork = networks.get(0);
        }

        // Disable auto-join on the saved network to prevent auto-connect from
        // interfering with the test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : savedNetworks) {
                        sWifiManager.disableNetwork(savedNetwork.networkId);
                    }
                });
    }

    @AfterClass
    public static void tearDownClass() throws Exception {
        if (!WifiFeature.isWifiSupported(sContext)) return;

        ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.setScanThrottleEnabled(sWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.setVerboseLoggingEnabled(sWasVerboseLoggingEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.setWifiEnabled(sWasWifiEnabled));

        // Re-enable networks.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : sWifiManager.getConfiguredNetworks()) {
                        sWifiManager.enableNetwork(savedNetwork.networkId, false);
                    }
                });
    }

    @Before
    public void setUp() throws Exception {
        mExecutorService = Executors.newSingleThreadScheduledExecutor();
        // turn screen on
        sTestHelper.turnScreenOn();

        // Disconnect current network if any.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> sWifiManager.disconnect());

        // Wait for Wifi to be disconnected.
        PollingCheck.check(
                ""Wifi not disconnected"",
                20_000,
                () -> sWifiManager.getConnectionInfo().getNetworkId() == -1);

        // Clear any existing app state before each test.
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(sContext)) {
            ShellIdentityUtils.invokeWithShellPermissions(
                    () -> sWifiManager.removeAppState(myUid(), sContext.getPackageName()));
        }
    }

    @After
    public void tearDown() throws Exception {
        // Release the requests after the test.
        if (sNsNetworkCallback != null) {
            sConnectivityManager.unregisterNetworkCallback(sNsNetworkCallback);
        }
        mExecutorService.shutdownNow();
        // Clear any existing app state after each test.
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(sContext)) {
            ShellIdentityUtils.invokeWithShellPermissions(
                    () -> sWifiManager.removeAppState(myUid(), sContext.getPackageName()));
        }
        sTestHelper.turnScreenOff();
    }

    private static final String CA_SUITE_B_RSA3072_CERT_STRING =
            ""-----BEGIN CERTIFICATE-----\n""
                    + ""MIIEnTCCAwWgAwIBAgIUD87Y8fFLzLr1HQ/64aEnjNq2R/4wDQYJKoZIhvcNAQEM\n""
                    + ""BQAwXjELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQwwCgYDVQQHDANNVFYxEDAO\n""
                    + ""BgNVBAoMB0FuZHJvaWQxDjAMBgNVBAsMBVdpLUZpMRIwEAYDVQQDDAl1bml0ZXN0\n""
                    + ""Q0EwHhcNMjAwNzIxMDIxNzU0WhcNMzAwNTMwMDIxNzU0WjBeMQswCQYDVQQGEwJV\n""
                    + ""UzELMAkGA1UECAwCQ0ExDDAKBgNVBAcMA01UVjEQMA4GA1UECgwHQW5kcm9pZDEO\n""
                    + ""MAwGA1UECwwFV2ktRmkxEjAQBgNVBAMMCXVuaXRlc3RDQTCCAaIwDQYJKoZIhvcN\n""
                    + ""AQEBBQADggGPADCCAYoCggGBAMtrsT0otlxh0QS079KpRRbU1PQjCihSoltXnrxF\n""
                    + ""sTWZs2weVEeYVyYU5LaauCDDgISCMtjtfbfylMBeYjpWB5hYzYQOiTzo0anWhMyb\n""
                    + ""Ngb7gpMVZuIl6lwMYRyVRKwHWnTo2EUg1ZzW5rGe5fs/KHj6//hoNFm+3Oju0TQd\n""
                    + ""nraQULpoERPF5B7p85Cssk8uNbviBfZXvtCuJ4N6w7PNceOY/9bbwc1mC+pPZmzV\n""
                    + ""SOAg0vvbIQRzChm63C3jBC3xmxSOOZVrKN4zKDG2s8P0oCNGt0NlgRMrgbPRekzg\n""
                    + ""4avkbA0vTuc2AyriTEYkdea/Mt4EpRg9XuOb43U/GJ/d/vQv2/9fsxhXmsZrn8kr\n""
                    + ""Qo5MMHJFUd96GgHmvYSU3Mf/5r8gF626lvqHioGuTAuHUSnr02ri1WUxZ15LDRgY\n""
                    + ""quMjDCFZfucjJPDAdtiHcFSej/4SLJlN39z8oKKNPn3aL9Gv49oAKs9S8tfDVzMk\n""
                    + ""fDLROQFHFuW715GnnMgEAoOpRwIDAQABo1MwUTAdBgNVHQ4EFgQUeVuGmSVN4ARs\n""
                    + ""mesUMWSJ2qWLbxUwHwYDVR0jBBgwFoAUeVuGmSVN4ARsmesUMWSJ2qWLbxUwDwYD\n""
                    + ""VR0TAQH/BAUwAwEB/zANBgkqhkiG9w0BAQwFAAOCAYEAit1Lo/hegZpPuT9dlWZJ\n""
                    + ""bC8JvAf95O8lnn6LFb69pgYOHCLgCIlvYXu9rdBUJgZo+V1MzJJljiO6RxWRfKbQ\n""
                    + ""8WBYkoqR1EqriR3Kn8q/SjIZCdFSaznTyU1wQMveBQ6RJWXSUhYVfE9RjyFTp7B4\n""
                    + ""UyH2uCluR/0T06HQNGfH5XpIYQqCk1Zgng5lmEmheLDPoJpa92lKeQFJMC6eYz9g\n""
                    + ""lF1GHxPxkPfbMJ6ZDp5X6Yopu6Q6uEXhVKM/iQVcgzRkx9rid+xTYl+nOKyK/XfC\n""
                    + ""z8P0/TFIoPTW02DLge5wKagdoCpy1B7HdrAXyUjoH4B8MsUkq3kYPFSjPzScuTtV\n""
                    + ""kUuDw5ipCNeXCRnhbYqRDk6PX5GUu2cmN9jtaH3tbgm3fKNOsd/BO1fLIl7qjXlR\n""
                    + ""27HHbC0JXjNvlm2DLp23v4NTxS7WZGYsxyUj5DZrxBxqCsTXu/01w1BrQKWKh9FM\n""
                    + ""aVrlA8omfVODK2CSuw+KhEMHepRv/AUgsLl4L4+RMoa+\n""
                    + ""-----END CERTIFICATE-----\n"";
    private static final X509Certificate CA_SUITE_B_RSA3072_CERT =
            loadCertificate(CA_SUITE_B_RSA3072_CERT_STRING);

    private static final String CA_SUITE_B_ECDSA_CERT_STRING =
            ""-----BEGIN CERTIFICATE-----\n""
                    + ""MIICTzCCAdSgAwIBAgIUdnLttwNPnQzFufplGOr9bTrGCqMwCgYIKoZIzj0EAwMw\n""
                    + ""XjELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQwwCgYDVQQHDANNVFYxEDAOBgNV\n""
                    + ""BAoMB0FuZHJvaWQxDjAMBgNVBAsMBVdpLUZpMRIwEAYDVQQDDAl1bml0ZXN0Q0Ew\n""
                    + ""HhcNMjAwNzIxMDIyNDA1WhcNMzAwNTMwMDIyNDA1WjBeMQswCQYDVQQGEwJVUzEL\n""
                    + ""MAkGA1UECAwCQ0ExDDAKBgNVBAcMA01UVjEQMA4GA1UECgwHQW5kcm9pZDEOMAwG\n""
                    + ""A1UECwwFV2ktRmkxEjAQBgNVBAMMCXVuaXRlc3RDQTB2MBAGByqGSM49AgEGBSuB\n""
                    + ""BAAiA2IABFmntXwk9icqhDQFUP1xy04WyEpaGW4q6Q+8pujlSl/X3iotPZ++GZfp\n""
                    + ""Mfv3YDHDBl6sELPQ2BEjyPXmpsKjOUdiUe69e88oGEdeqT2xXiQ6uzpTfJD4170i\n""
                    + ""O/TwLrQGKKNTMFEwHQYDVR0OBBYEFCjptsX3g4g5W0L4oEP6N3gfyiZXMB8GA1Ud\n""
                    + ""IwQYMBaAFCjptsX3g4g5W0L4oEP6N3gfyiZXMA8GA1UdEwEB/wQFMAMBAf8wCgYI\n""
                    + ""KoZIzj0EAwMDaQAwZgIxAK61brUYRbLmQKiaEboZgrHtnPAcGo7Yzx3MwHecx3Dm\n""
                    + ""5soIeLVYc8bPYN1pbhXW1gIxALdEe2sh03nBHyQH4adYoZungoCwt8mp/7sJFxou\n""
                    + ""9UnRegyBgGzf74ROWdpZHzh+Pg==\n""
                    + ""-----END CERTIFICATE-----\n"";
    private static final X509Certificate CA_SUITE_B_ECDSA_CERT =
            loadCertificate(CA_SUITE_B_ECDSA_CERT_STRING);

    private static final String CLIENT_SUITE_B_RSA3072_CERT_STRING =
            ""-----BEGIN CERTIFICATE-----\n""
                    + ""MIIERzCCAq8CFDopjyNgaj+c2TN2k06h7okEWpHJMA0GCSqGSIb3DQEBDAUAMF4x\n""
                    + ""CzAJBgNVBAYTAlVTMQswCQYDVQQIDAJDQTEMMAoGA1UEBwwDTVRWMRAwDgYDVQQK\n""
                    + ""DAdBbmRyb2lkMQ4wDAYDVQQLDAVXaS1GaTESMBAGA1UEAwwJdW5pdGVzdENBMB4X\n""
                    + ""DTIwMDcyMTAyMjkxMVoXDTMwMDUzMDAyMjkxMVowYjELMAkGA1UEBhMCVVMxCzAJ\n""
                    + ""BgNVBAgMAkNBMQwwCgYDVQQHDANNVFYxEDAOBgNVBAoMB0FuZHJvaWQxDjAMBgNV\n""
                    + ""BAsMBVdpLUZpMRYwFAYDVQQDDA11bml0ZXN0Q2xpZW50MIIBojANBgkqhkiG9w0B\n""
                    + ""AQEFAAOCAY8AMIIBigKCAYEAwSK3C5K5udtCKTnE14e8z2cZvwmB4Xe+a8+7QLud\n""
                    + ""Hooc/lQzClgK4MbVUC0D3FE+U32C78SxKoTaRWtvPmNm+UaFT8KkwyUno/dv+2XD\n""
                    + ""pd/zARQ+3FwAfWopAhEyCVSxwsCa+slQ4juRIMIuUC1Mm0NaptZyM3Tj/ICQEfpk\n""
                    + ""o9qVIbiK6eoJMTkY8EWfAn7RTFdfR1OLuO0mVOjgLW9/+upYv6hZ19nAMAxw4QTJ\n""
                    + ""x7lLwALX7B+tDYNEZHDqYL2zyvQWAj2HClere8QYILxkvktgBg2crEJJe4XbDH7L\n""
                    + ""A3rrXmsiqf1ZbfFFEzK9NFqovL+qGh+zIP+588ShJFO9H/RDnDpiTnAFTWXQdTwg\n""
                    + ""szSS0Vw2PB+JqEABAa9DeMvXT1Oy+NY3ItPHyy63nQZVI2rXANw4NhwS0Z6DF+Qs\n""
                    + ""TNrj+GU7e4SG/EGR8SvldjYfQTWFLg1l/UT1hOOkQZwdsaW1zgKyeuiFB2KdMmbA\n""
                    + ""Sq+Ux1L1KICo0IglwWcB/8nnAgMBAAEwDQYJKoZIhvcNAQEMBQADggGBAMYwJkNw\n""
                    + ""BaCviKFmReDTMwWPRy4AMNViEeqAXgERwDEKwM7efjsaj5gctWfKsxX6UdLzkhgg\n""
                    + ""6S/T6PxVWKzJ6l7SoOuTa6tMQOZp+h3R1mdfEQbw8B5cXBxZ+batzAai6Fiy1FKS\n""
                    + ""/ka3INbcGfYuIYghfTrb4/NJKN06ZaQ1bpPwq0e4gN7800T2nbawvSf7r+8ZLcG3\n""
                    + ""6bGCjRMwDSIipNvOwoj3TG315XC7TccX5difQ4sKOY+d2MkVJ3RiO0Ciw2ZbEW8d\n""
                    + ""1FH5vUQJWnBUfSFznosGzLwH3iWfqlP+27jNE+qB2igEwCRFgVAouURx5ou43xuX\n""
                    + ""qf6JkdI3HTJGLIWxkp7gOeln4dEaYzKjYw+P0VqJvKVqQ0IXiLjHgE0J9p0vgyD6\n""
                    + ""HVVcP7U8RgqrbIjL1QgHU4KBhGi+WSUh/mRplUCNvHgcYdcHi/gHpj/j6ubwqIGV\n""
                    + ""z4iSolAHYTmBWcLyE0NgpzE6ntp+53r2KaUJA99l2iGVzbWTwqPSm0XAVw==\n""
                    + ""-----END CERTIFICATE-----\n"";
    private static final X509Certificate CLIENT_SUITE_B_RSA3072_CERT =
            loadCertificate(CLIENT_SUITE_B_RSA3072_CERT_STRING);

    private static final byte[] CLIENT_SUITE_B_RSA3072_KEY_DATA = new byte[]{
            (byte) 0x30, (byte) 0x82, (byte) 0x06, (byte) 0xfe, (byte) 0x02, (byte) 0x01,
            (byte) 0x00, (byte) 0x30, (byte) 0x0d, (byte) 0x06, (byte) 0x09, (byte) 0x2a,
            (byte) 0x86, (byte) 0x48, (byte) 0x86, (byte) 0xf7, (byte) 0x0d, (byte) 0x01,
            (byte) 0x01, (byte) 0x01, (byte) 0x05, (byte) 0x00, (byte) 0x04, (byte) 0x82,
            (byte) 0x06, (byte) 0xe8, (byte) 0x30, (byte) 0x82, (byte) 0x06, (byte) 0xe4,
            (byte) 0x02, (byte) 0x01, (byte) 0x00, (byte) 0x02, (byte) 0x82, (byte) 0x01,
            (byte) 0x81, (byte) 0x00, (byte) 0xc1, (byte) 0x22, (byte) 0xb7, (byte) 0x0b,
            (byte) 0x92, (byte) 0xb9, (byte) 0xb9, (byte) 0xdb, (byte) 0x42, (byte) 0x29,
            (byte) 0x39, (byte) 0xc4, (byte) 0xd7, (byte) 0x87, (byte) 0xbc, (byte) 0xcf,
            (byte) 0x67, (byte) 0x19, (byte) 0xbf, (byte) 0x09, (byte) 0x81, (byte) 0xe1,
            (byte) 0x77, (byte) 0xbe, (byte) 0x6b, (byte) 0xcf, (byte) 0xbb, (byte) 0x40,
            (byte) 0xbb, (byte) 0x9d, (byte) 0x1e, (byte) 0x8a, (byte) 0x1c, (byte) 0xfe,
            (byte) 0x54, (byte) 0x33, (byte) 0x0a, (byte) 0x58, (byte) 0x0a, (byte) 0xe0,
            (byte) 0xc6, (byte) 0xd5, (byte) 0x50, (byte) 0x2d, (byte) 0x03, (byte) 0xdc,
            (byte) 0x51, (byte) 0x3e, (byte) 0x53, (byte) 0x7d, (byte) 0x82, (byte) 0xef,
            (byte) 0xc4, (byte) 0xb1, (byte) 0x2a, (byte) 0x84, (byte) 0xda, (byte) 0x45,
            (byte) 0x6b, (byte) 0x6f, (byte) 0x3e, (byte) 0x63, (byte) 0x66, (byte) 0xf9,
            (byte) 0x46, (byte) 0x85, (byte) 0x4f, (byte) 0xc2, (byte) 0xa4, (byte) 0xc3,
            (byte) 0x25, (byte) 0x27, (byte) 0xa3, (byte) 0xf7, (byte) 0x6f, (byte) 0xfb,
            (byte) 0x65, (byte) 0xc3, (byte) 0xa5, (byte) 0xdf, (byte) 0xf3, (byte) 0x01,
            (byte) 0x14, (byte) 0x3e, (byte) 0xdc, (byte) 0x5c, (byte) 0x00, (byte) 0x7d,
            (byte) 0x6a, (byte) 0x29, (byte) 0x02, (byte) 0x11, (byte) 0x32, (byte) 0x09,
            (byte) 0x54, (byte) 0xb1, (byte) 0xc2, (byte) 0xc0, (byte) 0x9a, (byte) 0xfa,
            (byte) 0xc9, (byte) 0x50, (byte) 0xe2, (byte) 0x3b, (byte) 0x91, (byte) 0x20,
            (byte) 0xc2, (byte) 0x2e, (byte) 0x50, (byte) 0x2d, (byte) 0x4c, (byte) 0x9b,
            (byte) 0x43, (byte) 0x5a, (byte) 0xa6, (byte) 0xd6, (byte) 0x72, (byte) 0x33,
            (byte) 0x74, (byte) 0xe3, (byte) 0xfc, (byte) 0x80, (byte) 0x90, (byte) 0x11,
            (byte) 0xfa, (byte) 0x64, (byte) 0xa3, (byte) 0xda, (byte) 0x95, (byte) 0x21,
            (byte) 0xb8, (byte) 0x8a, (byte) 0xe9, (byte) 0xea, (byte) 0x09, (byte) 0x31,
            (byte) 0x39, (byte) 0x18, (byte) 0xf0, (byte) 0x45, (byte) 0x9f, (byte) 0x02,
            (byte) 0x7e, (byte) 0xd1, (byte) 0x4c, (byte) 0x57, (byte) 0x5f, (byte) 0x47,
            (byte) 0x53, (byte) 0x8b, (byte) 0xb8, (byte) 0xed, (byte) 0x26, (byte) 0x54,
            (byte) 0xe8, (byte) 0xe0, (byte) 0x2d, (byte) 0x6f, (byte) 0x7f, (byte) 0xfa,
            (byte) 0xea, (byte) 0x58, (byte) 0xbf, (byte) 0xa8, (byte) 0x59, (byte) 0xd7,
            (byte) 0xd9, (byte) 0xc0, (byte) 0x30, (byte) 0x0c, (byte) 0x70, (byte) 0xe1,
            (byte) 0x04, (byte) 0xc9, (byte) 0xc7, (byte) 0xb9, (byte) 0x4b, (byte) 0xc0,
            (byte) 0x02, (byte) 0xd7, (byte) 0xec, (byte) 0x1f, (byte) 0xad, (byte) 0x0d,
            (byte) 0x83, (byte) 0x44, (byte) 0x64, (byte) 0x70, (byte) 0xea, (byte) 0x60,
            (byte) 0xbd, (byte) 0xb3, (byte) 0xca, (byte) 0xf4, (byte) 0x16, (byte) 0x02,
            (byte) 0x3d, (byte) 0x87, (byte) 0x0a, (byte) 0x57, (byte) 0xab, (byte) 0x7b,
            (byte) 0xc4, (byte) 0x18, (byte) 0x20, (byte) 0xbc, (byte) 0x64, (byte) 0xbe,
            (byte) 0x4b, (byte) 0x60, (byte) 0x06, (byte) 0x0d, (byte) 0x9c, (byte) 0xac,
            (byte) 0x42, (byte) 0x49, (byte) 0x7b, (byte) 0x85, (byte) 0xdb, (byte) 0x0c,
            (byte) 0x7e, (byte) 0xcb, (byte) 0x03, (byte) 0x7a, (byte) 0xeb, (byte) 0x5e,
            (byte) 0x6b, (byte) 0x22, (byte) 0xa9, (byte) 0xfd, (byte) 0x59, (byte) 0x6d,
            (byte) 0xf1, (byte) 0x45, (byte) 0x13, (byte) 0x32, (byte) 0xbd, (byte) 0x34,
            (byte) 0x5a, (byte) 0xa8, (byte) 0xbc, (byte) 0xbf, (byte) 0xaa, (byte) 0x1a,
            (byte) 0x1f, (byte) 0xb3, (byte) 0x20, (byte) 0xff, (byte) 0xb9, (byte) 0xf3,
            (byte) 0xc4, (byte) 0xa1, (byte) 0x24, (byte) 0x53, (byte) 0xbd, (byte) 0x1f,
            (byte) 0xf4, (byte) 0x43, (byte) 0x9c, (byte) 0x3a, (byte) 0x62, (byte) 0x4e,
            (byte) 0x70, (byte) 0x05, (byte) 0x4d, (byte) 0x65, (byte) 0xd0, (byte) 0x75,
            (byte) 0x3c, (byte) 0x20, (byte) 0xb3, (byte) 0x34, (byte) 0x92, (byte) 0xd1,
            (byte) 0x5c, (byte) 0x36, (byte) 0x3c, (byte) 0x1f, (byte) 0x89, (byte) 0xa8,
            (byte) 0x40, (byte) 0x01, (byte) 0x01, (byte) 0xaf, (byte) 0x43, (byte) 0x78,
            (byte) 0xcb, (byte) 0xd7, (byte) 0x4f, (byte) 0x53, (byte) 0xb2, (byte) 0xf8,
            (byte) 0xd6, (byte) 0x37, (byte) 0x22, (byte) 0xd3, (byte) 0xc7, (byte) 0xcb,
            (byte) 0x2e, (byte) 0xb7, (byte) 0x9d, (byte) 0x06, (byte) 0x55, (byte) 0x23,
            (byte) 0x6a, (byte) 0xd7, (byte) 0x00, (byte) 0xdc, (byte) 0x38, (byte) 0x36,
            (byte) 0x1c, (byte) 0x12, (byte) 0xd1, (byte) 0x9e, (byte) 0x83, (byte) 0x17,
            (byte) 0xe4, (byte) 0x2c, (byte) 0x4c, (byte) 0xda, (byte) 0xe3, (byte) 0xf8,
            (byte) 0x65, (byte) 0x3b, (byte) 0x7b, (byte) 0x84, (byte) 0x86, (byte) 0xfc,
            (byte) 0x41, (byte) 0x91, (byte) 0xf1, (byte) 0x2b, (byte) 0xe5, (byte) 0x76,
            (byte) 0x36, (byte) 0x1f, (byte) 0x41, (byte) 0x35, (byte) 0x85, (byte) 0x2e,
            (byte) 0x0d, (byte) 0x65, (byte) 0xfd, (byte) 0x44, (byte) 0xf5, (byte) 0x84,
            (byte) 0xe3, (byte) 0xa4, (byte) 0x41, (byte) 0x9c, (byte) 0x1d, (byte) 0xb1,
            (byte) 0xa5, (byte) 0xb5, (byte) 0xce, (byte) 0x02, (byte) 0xb2, (byte) 0x7a,
            (byte) 0xe8, (byte) 0x85, (byte) 0x07, (byte) 0x62, (byte) 0x9d, (byte) 0x32,
            (byte) 0x66, (byte) 0xc0, (byte) 0x4a, (byte) 0xaf, (byte) 0x94, (byte) 0xc7,
            (byte) 0x52, (byte) 0xf5, (byte) 0x28, (byte) 0x80, (byte) 0xa8, (byte) 0xd0,
            (byte) 0x88, (byte) 0x25, (byte) 0xc1, (byte) 0x67, (byte) 0x01, (byte) 0xff,
            (byte) 0xc9, (byte) 0xe7, (byte) 0x02, (byte) 0x03, (byte) 0x01, (byte) 0x00,
            (byte) 0x01, (byte) 0x02, (byte) 0x82, (byte) 0x01, (byte) 0x80, (byte) 0x04,
            (byte) 0xb1, (byte) 0xcc, (byte) 0x53, (byte) 0x3a, (byte) 0xb0, (byte) 0xcb,
            (byte) 0x04, (byte) 0xba, (byte) 0x59, (byte) 0xf8, (byte) 0x2e, (byte) 0x81,
            (byte) 0xb2, (byte) 0xa9, (byte) 0xf3, (byte) 0x3c, (byte) 0xa5, (byte) 0x52,
            (byte) 0x90, (byte) 0x6f, (byte) 0x98, (byte) 0xc4, (byte) 0x69, (byte) 0x5b,
            (byte) 0x83, (byte) 0x84, (byte) 0x20, (byte) 0xb1, (byte) 0xae, (byte) 0xc3,
            (byte) 0x04, (byte) 0x46, (byte) 0x6a, (byte) 0x24, (byte) 0x2f, (byte) 0xcd,
            (byte) 0x6b, (byte) 0x90, (byte) 0x70, (byte) 0x20, (byte) 0x45, (byte) 0x25,
            (byte) 0x1a, (byte) 0xc3, (byte) 0x02, (byte) 0x42, (byte) 0xf3, (byte) 0x49,
            (byte) 0xe2, (byte) 0x3e, (byte) 0x21, (byte) 0x87, (byte) 0xdd, (byte) 0x6a,
            (byte) 0x94, (byte) 0x2a, (byte) 0x1e, (byte) 0x0f, (byte) 0xdb, (byte) 0x77,
            (byte) 0x5f, (byte) 0xc1, (byte) 0x2c, (byte) 0x03, (byte) 0xfb, (byte) 0xcf,
            (byte) 0x91, (byte) 0x82, (byte) 0xa1, (byte) 0xbf, (byte) 0xb0, (byte) 0x73,
            (byte) 0xfa, (byte) 0xda, (byte) 0xbc, (byte) 0xf8, (byte) 0x9f, (byte) 0x45,
            (byte) 0xd3, (byte) 0xe8, (byte) 0xbb, (byte) 0x38, (byte) 0xfb, (byte) 0xc2,
            (byte) 0x2d, (byte) 0x76, (byte) 0x51, (byte) 0x96, (byte) 0x18, (byte) 0x03,
            (byte) 0x15, (byte) 0xd9, (byte) 0xea, (byte) 0x82, (byte) 0x25, (byte) 0x83,
            (byte) 0xff, (byte) 0x5c, (byte) 0x85, (byte) 0x06, (byte) 0x09, (byte) 0xb2,
            (byte) 0x46, (byte) 0x12, (byte) 0x64, (byte) 0x02, (byte) 0x74, (byte) 0x4f,
            (byte) 0xbc, (byte) 0x9a, (byte) 0x25, (byte) 0x18, (byte) 0x01, (byte) 0x07,
            (byte) 0x17, (byte) 0x25, (byte) 0x55, (byte) 0x7c, (byte) 0xdc, (byte) 0xe1,
            (byte) 0xd1, (byte) 0x5a, (byte) 0x2f, (byte) 0x25, (byte) 0xaf, (byte) 0xf6,
            (byte) 0x8f, (byte) 0xa4, (byte) 0x9a, (byte) 0x5a, (byte) 0x3a, (byte) 0xfe,
            (byte) 0x2e, (byte) 0x93, (byte) 0x24, (byte) 0xa0, (byte) 0x27, (byte) 0xac,
            (byte) 0x07, (byte) 0x75, (byte) 0x33, (byte) 0x01, (byte) 0x54, (byte) 0x23,
            (byte) 0x0f, (byte) 0xe8, (byte) 0x9f, (byte) 0xfa, (byte) 0x36, (byte) 0xe6,
            (byte) 0x3a, (byte) 0xd5, (byte) 0x78, (byte) 0xb0, (byte) 0xe4, (byte) 0x6a,
            (byte) 0x16, (byte) 0x50, (byte) 0xbd, (byte) 0x0f, (byte) 0x9f, (byte) 0x32,
            (byte) 0xa1, (byte) 0x6b, (byte) 0xf5, (byte) 0xa4, (byte) 0x34, (byte) 0x58,
            (byte) 0xb6, (byte) 0xa4, (byte) 0xb3, (byte) 0xc3, (byte) 0x83, (byte) 0x08,
            (byte) 0x18, (byte) 0xc7, (byte) 0xef, (byte) 0x95, (byte) 0xe2, (byte) 0x1b,
            (byte) 0xba, (byte) 0x35, (byte) 0x61, (byte) 0xa3, (byte) 0xb4, (byte) 0x30,
            (byte) 0xe0, (byte) 0xd1, (byte) 0xc1, (byte) 0xa2, (byte) 0x3a, (byte) 0xc6,
            (byte) 0xb4, (byte) 0xd2, (byte) 0x80, (byte) 0x5a, (byte) 0xaf, (byte) 0xa4,
            (byte) 0x54, (byte) 0x3c, (byte) 0x66, (byte) 0x5a, (byte) 0x1c, (byte) 0x4d,
            (byte) 0xe1, (byte) 0xd9, (byte) 0x98, (byte) 0x44, (byte) 0x01, (byte) 0x1b,
            (byte) 0x8c, (byte) 0xe9, (byte) 0x80, (byte) 0x54, (byte) 0x83, (byte) 0x3d,
            (byte) 0x96, (byte) 0x25, (byte) 0x41, (byte) 0x1c, (byte) 0xad, (byte) 0xae,
            (byte) 0x3b, (byte) 0x7a, (byte) 0xd7, (byte) 0x9d, (byte) 0x10, (byte) 0x7c,
            (byte) 0xd1, (byte) 0xa7, (byte) 0x96, (byte) 0x39, (byte) 0xa5, (byte) 0x2f,
            (byte) 0xbe, (byte) 0xc3, (byte) 0x2c, (byte) 0x64, (byte) 0x01, (byte) 0xfe,
            (byte) 0xa2, (byte) 0xd1, (byte) 0x6a, (byte) 0xcf, (byte) 0x4c, (byte) 0x76,
            (byte) 0x3b, (byte) 0xc8, (byte) 0x35, (byte) 0x21, (byte) 0xda, (byte) 0x98,
            (byte) 0xcf, (byte) 0xf9, (byte) 0x29, (byte) 0xff, (byte) 0x30, (byte) 0x59,
            (byte) 0x36, (byte) 0x53, (byte) 0x0b, (byte) 0xbb, (byte) 0xfa, (byte) 0xba,
            (byte) 0xc4, (byte) 0x03, (byte) 0x23, (byte) 0xe0, (byte) 0xd3, (byte) 0x33,
            (byte) 0xff, (byte) 0x32, (byte) 0xdb, (byte) 0x30, (byte) 0x64, (byte) 0xc7,
            (byte) 0x56, (byte) 0xca, (byte) 0x55, (byte) 0x14, (byte) 0xee, (byte) 0x58,
            (byte) 0xfe, (byte) 0x96, (byte) 0x7e, (byte) 0x1c, (byte) 0x34, (byte) 0x16,
            (byte) 0xeb, (byte) 0x76, (byte) 0x26, (byte) 0x48, (byte) 0xe2, (byte) 0xe5,
            (byte) 0x5c, (byte) 0xd5, (byte) 0x83, (byte) 0x37, (byte) 0xd9, (byte) 0x09,
            (byte) 0x71, (byte) 0xbc, (byte) 0x54, (byte) 0x25, (byte) 0xca, (byte) 0x2e,
            (byte) 0xdb, (byte) 0x36, (byte) 0x39, (byte) 0xcc, (byte) 0x3a, (byte) 0x81,
            (byte) 0x95, (byte) 0x9e, (byte) 0xf4, (byte) 0x01, (byte) 0xa7, (byte) 0xc0,
            (byte) 0x20, (byte) 0xce, (byte) 0x70, (byte) 0x55, (byte) 0x2c, (byte) 0xe0,
            (byte) 0x93, (byte) 0x72, (byte) 0xa6, (byte) 0x25, (byte) 0xda, (byte) 0x64,
            (byte) 0x19, (byte) 0x18, (byte) 0xd2, (byte) 0x31, (byte) 0xe2, (byte) 0x7c,
            (byte) 0xf2, (byte) 0x30, (byte) 0x9e, (byte) 0x8d, (byte) 0xc6, (byte) 0x14,
            (byte) 0x8a, (byte) 0x38, (byte) 0xf0, (byte) 0x94, (byte) 0xeb, (byte) 0xf4,
            (byte) 0x64, (byte) 0x92, (byte) 0x3d, (byte) 0x67, (byte) 0xa6, (byte) 0x2c,
            (byte) 0x52, (byte) 0xfc, (byte) 0x60, (byte) 0xca, (byte) 0x2a, (byte) 0xcf,
            (byte) 0x24, (byte) 0xd5, (byte) 0x42, (byte) 0x5f, (byte) 0xc7, (byte) 0x9f,
            (byte) 0xf3, (byte) 0xb4, (byte) 0xdf, (byte) 0x76, (byte) 0x6e, (byte) 0x53,
            (byte) 0xa1, (byte) 0x7b, (byte) 0xae, (byte) 0xa5, (byte) 0x84, (byte) 0x1f,
            (byte) 0xfa, (byte) 0xc0, (byte) 0xb4, (byte) 0x6c, (byte) 0xc9, (byte) 0x02,
            (byte) 0x81, (byte) 0xc1, (byte) 0x00, (byte) 0xf3, (byte) 0x17, (byte) 0xd9,
            (byte) 0x48, (byte) 0x17, (byte) 0x87, (byte) 0x84, (byte) 0x16, (byte) 0xea,
            (byte) 0x2d, (byte) 0x31, (byte) 0x1b, (byte) 0xce, (byte) 0xec, (byte) 0xaf,
            (byte) 0xdc, (byte) 0x6b, (byte) 0xaf, (byte) 0xc8, (byte) 0xf1, (byte) 0x40,
            (byte) 0xa7, (byte) 0x4f, (byte) 0xef, (byte) 0x48, (byte) 0x08, (byte) 0x5e,
            (byte) 0x9a, (byte) 0xd1, (byte) 0xc0, (byte) 0xb1, (byte) 0xfe, (byte) 0xe7,
            (byte) 0x03, (byte) 0xd5, (byte) 0x96, (byte) 0x01, (byte) 0xe8, (byte) 0x40,
            (byte) 0xca, (byte) 0x78, (byte) 0xcb, (byte) 0xb3, (byte) 0x28, (byte) 0x1a,
            (byte) 0xf0, (byte) 0xe5, (byte) 0xf6, (byte) 0x46, (byte) 0xef, (byte) 0xcd,
            (byte) 0x1a, (byte) 0x0f, (byte) 0x13, (byte) 0x2d, (byte) 0x38, (byte) 0xf8,
            (byte) 0xf7, (byte) 0x88, (byte) 0x21, (byte) 0x15, (byte) 0xce, (byte) 0x48,
            (byte) 0xf4, (byte) 0x92, (byte) 0x7e, (byte) 0x9b, (byte) 0x2e, (byte) 0x2f,
            (byte) 0x22, (byte) 0x3e, (byte) 0x5c, (byte) 0x67, (byte) 0xd7, (byte) 0x58,
            (byte) 0xf6, (byte) 0xef, (byte) 0x1f, (byte) 0xb4, (byte) 0x04, (byte) 0xc7,
            (byte) 0xfd, (byte) 0x8c, (byte) 0x4e, (byte) 0x27, (byte) 0x9e, (byte) 0xb9,
            (byte) 0xef, (byte) 0x0f, (byte) 0xf7, (byte) 0x4a, (byte) 0xc2, (byte) 0xf4,
            (byte) 0x64, (byte) 0x6b, (byte) 0xe0, (byte) 0xfb, (byte) 0xe3, (byte) 0x45,
            (byte) 0xd5, (byte) 0x37, (byte) 0xa0, (byte) 0x2a, (byte) 0xc6, (byte) 0xf3,
            (byte) 0xf6, (byte) 0xcc, (byte) 0xb5, (byte) 0x94, (byte) 0xbf, (byte) 0x56,
            (byte) 0xa0, (byte) 0x61, (byte) 0x36, (byte) 0x88, (byte) 0x35, (byte) 0xd5,
            (byte) 0xa5, (byte) 0xad, (byte) 0x20, (byte) 0x48, (byte) 0xda, (byte) 0x70,
            (byte) 0x35, (byte) 0xd9, (byte) 0x75, (byte) 0x66, (byte) 0xa5, (byte) 0xac,
            (byte) 0x86, (byte) 0x7a, (byte) 0x75, (byte) 0x49, (byte) 0x88, (byte) 0x40,
            (byte) 0xce, (byte) 0xb0, (byte) 0x6f, (byte) 0x57, (byte) 0x15, (byte) 0x54,
            (byte) 0xd3, (byte) 0x2f, (byte) 0x11, (byte) 0x9b, (byte) 0xe3, (byte) 0x87,
            (byte) 0xc8, (byte) 0x8d, (byte) 0x98, (byte) 0xc6, (byte) 0xe0, (byte) 0xbc,
            (byte) 0x85, (byte) 0xb9, (byte) 0x04, (byte) 0x43, (byte) 0xa9, (byte) 0x41,
            (byte) 0xce, (byte) 0x42, (byte) 0x1a, (byte) 0x57, (byte) 0x10, (byte) 0xd8,
            (byte) 0xe4, (byte) 0x6a, (byte) 0x51, (byte) 0x10, (byte) 0x0a, (byte) 0xec,
            (byte) 0xe4, (byte) 0x57, (byte) 0xc7, (byte) 0xee, (byte) 0xe9, (byte) 0xd6,
            (byte) 0xcb, (byte) 0x3e, (byte) 0xba, (byte) 0xfa, (byte) 0xe9, (byte) 0x0e,
            (byte) 0xed, (byte) 0x87, (byte) 0x04, (byte) 0x9a, (byte) 0x48, (byte) 0xba,
            (byte) 0xaf, (byte) 0x08, (byte) 0xf5, (byte) 0x02, (byte) 0x81, (byte) 0xc1,
            (byte) 0x00, (byte) 0xcb, (byte) 0x63, (byte) 0xd6, (byte) 0x54, (byte) 0xb6,
            (byte) 0xf3, (byte) 0xf3, (byte) 0x8c, (byte) 0xf8, (byte) 0xd0, (byte) 0xd2,
            (byte) 0x84, (byte) 0xc1, (byte) 0xf5, (byte) 0x12, (byte) 0xe0, (byte) 0x02,
            (byte) 0x80, (byte) 0x42, (byte) 0x92, (byte) 0x4e, (byte) 0xa4, (byte) 0x5c,
            (byte) 0xa5, (byte) 0x64, (byte) 0xec, (byte) 0xb7, (byte) 0xdc, (byte) 0xe0,
            (byte) 0x2d, (byte) 0x5d, (byte) 0xac, (byte) 0x0e, (byte) 0x24, (byte) 0x48,
            (byte) 0x13, (byte) 0x05, (byte) 0xe8, (byte) 0xff, (byte) 0x96, (byte) 0x93,
            (byte) 0xba, (byte) 0x3c, (byte) 0x88, (byte) 0xcc, (byte) 0x80, (byte) 0xf9,
            (byte) 0xdb, (byte) 0xa8, (byte) 0x4d, (byte) 0x86, (byte) 0x47, (byte) 0xc8,
            (byte) 0xbf, (byte) 0x34, (byte) 0x2d, (byte) 0xda, (byte) 0xb6, (byte) 0x28,
            (byte) 0xf0, (byte) 0x1e, (byte) 0xd2, (byte) 0x46, (byte) 0x0d, (byte) 0x6f,
            (byte) 0x36, (byte) 0x8e, (byte) 0x84, (byte) 0xd8, (byte) 0xaf, (byte) 0xf7,
            (byte) 0x69, (byte) 0x23, (byte) 0x77, (byte) 0xfb, (byte) 0xc5, (byte) 0x04,
            (byte) 0x08, (byte) 0x18, (byte) 0xac, (byte) 0x85, (byte) 0x80, (byte) 0x87,
            (byte) 0x1c, (byte) 0xfe, (byte) 0x8e, (byte) 0x5d, (byte) 0x00, (byte) 0x7f,
            (byte) 0x5b, (byte) 0x33, (byte) 0xf5, (byte) 0xdf, (byte) 0x70, (byte) 0x81,
            (byte) 0xad, (byte) 0x81, (byte) 0xf4, (byte) 0x5a, (byte) 0x37, (byte) 0x8a,
            (byte) 0x79, (byte) 0x09, (byte) 0xc5, (byte) 0x55, (byte) 0xab, (byte) 0x58,
            (byte) 0x7c, (byte) 0x47, (byte) 0xca, (byte) 0xa5, (byte) 0x80, (byte) 0x49,
            (byte) 0x5f, (byte) 0x71, (byte) 0x83, (byte) 0xfb, (byte) 0x3b, (byte) 0x06,
            (byte) 0xec, (byte) 0x75, (byte) 0x23, (byte) 0xc4, (byte) 0x32, (byte) 0xc7,
            (byte) 0x18, (byte) 0xf6, (byte) 0x82, (byte) 0x95, (byte) 0x98, (byte) 0x39,
            (byte) 0xf7, (byte) 0x92, (byte) 0x31, (byte) 0xc0, (byte) 0x89, (byte) 0xba,
            (byte) 0xd4, (byte) 0xd4, (byte) 0x58, (byte) 0x4e, (byte) 0x38, (byte) 0x35,
            (byte) 0x10, (byte) 0xb9, (byte) 0xf1, (byte) 0x27, (byte) 0xdc, (byte) 0xff,
            (byte) 0xc7, (byte) 0xb2, (byte) 0xba, (byte) 0x1f, (byte) 0x27, (byte) 0xaf,
            (byte) 0x99, (byte) 0xd5, (byte) 0xb0, (byte) 0x39, (byte) 0xe7, (byte) 0x43,
            (byte) 0x88, (byte) 0xd3, (byte) 0xce, (byte) 0x38, (byte) 0xc2, (byte) 0x99,
            (byte) 0x43, (byte) 0xfc, (byte) 0x8a, (byte) 0xe3, (byte) 0x60, (byte) 0x0d,
            (byte) 0x0a, (byte) 0xb8, (byte) 0xc4, (byte) 0x29, (byte) 0xca, (byte) 0x0d,
            (byte) 0x30, (byte) 0xaf, (byte) 0xca, (byte) 0xd0, (byte) 0xaa, (byte) 0x67,
            (byte) 0xb1, (byte) 0xdd, (byte) 0xdb, (byte) 0x7a, (byte) 0x11, (byte) 0xad,
            (byte) 0xeb, (byte) 0x02, (byte) 0x81, (byte) 0xc0, (byte) 0x71, (byte) 0xb8,
            (byte) 0xcf, (byte) 0x72, (byte) 0x35, (byte) 0x67, (byte) 0xb5, (byte) 0x38,
            (byte) 0x8f, (byte) 0x16, (byte) 0xd3, (byte) 0x29, (byte) 0x82, (byte) 0x35,
            (byte) 0x21, (byte) 0xd4, (byte) 0x49, (byte) 0x20, (byte) 0x74, (byte) 0x2d,
            (byte) 0xc0, (byte) 0xa4, (byte) 0x44, (byte) 0xf5, (byte) 0xd8, (byte) 0xc9,
            (byte) 0xe9, (byte) 0x90, (byte) 0x1d, (byte) 0xde, (byte) 0x3a, (byte) 0xa6,
            (byte) 0xd7, (byte) 0xe5, (byte) 0xe8, (byte) 0x4e, (byte) 0x83, (byte) 0xd7,
            (byte) 0xe6, (byte) 0x2f, (byte) 0x92, (byte) 0x31, (byte) 0x21, (byte) 0x3f,
            (byte) 0xfa, (byte) 0xd2, (byte) 0x85, (byte) 0x92, (byte) 0x1f, (byte) 0xff,
            (byte) 0x61, (byte) 0x00, (byte) 0xf6, (byte) 0xda, (byte) 0x6e, (byte) 0xc6,
            (byte) 0x7f, (byte) 0x5a, (byte) 0x35, (byte) 0x79, (byte) 0xdc, (byte) 0xdc,
            (byte) 0xa3, (byte) 0x2e, (byte) 0x9f, (byte) 0x35, (byte) 0xd1, (byte) 0x5c,
            (byte) 0xda, (byte) 0xb9, (byte) 0xf7, (byte) 0x58, (byte) 0x7d, (byte) 0x4f,
            (byte) 0xb6, (byte) 0x13, (byte) 0xd7, (byte) 0x2c, (byte) 0x0a, (byte) 0xa8,
            (byte) 0x4d, (byte) 0xf2, (byte) 0xe4, (byte) 0x67, (byte) 0x4f, (byte) 0x8b,
            (byte) 0xa6, (byte) 0xca, (byte) 0x1a, (byte) 0xbb, (byte) 0x02, (byte) 0x63,
            (byte) 0x8f, (byte) 0xb7, (byte) 0x46, (byte) 0xec, (byte) 0x7a, (byte) 0x8a,
            (byte) 0x09, (byte) 0x0a, (byte) 0x45, (byte) 0x3a, (byte) 0x8d, (byte) 0xa8,
            (byte) 0x83, (byte) 0x4b, (byte) 0x0a, (byte) 0xdb, (byte) 0x4b, (byte) 0x99,
            (byte) 0xf3, (byte) 0x69, (byte) 0x95, (byte) 0xf0, (byte) 0xcf, (byte) 0xe9,
            (byte) 0xf7, (byte) 0x67, (byte) 0xc9, (byte) 0x45, (byte) 0x18, (byte) 0x2f,
            (byte) 0xf0, (byte) 0x5c, (byte) 0x90, (byte) 0xbd, (byte) 0xa6, (byte) 0x66,
            (byte) 0x8c, (byte) 0xfe, (byte) 0x60, (byte) 0x5d, (byte) 0x6c, (byte) 0x27,
            (byte) 0xec, (byte) 0xc1, (byte) 0x84, (byte) 0xb2, (byte) 0xa1, (byte) 0x97,
            (byte) 0x9e, (byte) 0x16, (byte) 0x29, (byte) 0xa7, (byte) 0xe0, (byte) 0x38,
            (byte) 0xa2, (byte) 0x36, (byte) 0x05, (byte) 0x5f, (byte) 0xda, (byte) 0x72,
            (byte) 0x1a, (byte) 0x5f, (byte) 0xa8, (byte) 0x7d, (byte) 0x41, (byte) 0x35,
            (byte) 0xf6, (byte) 0x4e, (byte) 0x0a, (byte) 0x88, (byte) 0x8e, (byte) 0x00,
            (byte) 0x98, (byte) 0xa6, (byte) 0xca, (byte) 0xc1, (byte) 0xdf, (byte) 0x72,
            (byte) 0x6c, (byte) 0xfe, (byte) 0x29, (byte) 0xbe, (byte) 0xa3, (byte) 0x9b,
            (byte) 0x0b, (byte) 0x5c, (byte) 0x0b, (byte) 0x9d, (byte) 0xa7, (byte) 0x71,
            (byte) 0xce, (byte) 0x04, (byte) 0xfa, (byte) 0xac, (byte) 0x01, (byte) 0x8d,
            (byte) 0x52, (byte) 0xa0, (byte) 0x3d, (byte) 0xdd, (byte) 0x02, (byte) 0x81,
            (byte) 0xc1, (byte) 0x00, (byte) 0xc1, (byte) 0xc0, (byte) 0x2e, (byte) 0xa9,
            (byte) 0xee, (byte) 0xca, (byte) 0xff, (byte) 0xe4, (byte) 0xf8, (byte) 0x15,
            (byte) 0xfd, (byte) 0xa5, (byte) 0x68, (byte) 0x1b, (byte) 0x2d, (byte) 0x4a,
            (byte) 0xe6, (byte) 0x37, (byte) 0x06, (byte) 0xb3, (byte) 0xd7, (byte) 0x64,
            (byte) 0xad, (byte) 0xb9, (byte) 0x05, (byte) 0x26, (byte) 0x97, (byte) 0x94,
            (byte) 0x3a, (byte) 0x9e, (byte) 0x1c, (byte) 0xd0, (byte) 0xcd, (byte) 0x7b,
            (byte) 0xf4, (byte) 0x88, (byte) 0xe2, (byte) 0xa5, (byte) 0x6d, (byte) 0xed,
            (byte) 0x24, (byte) 0x77, (byte) 0x52, (byte) 0x39, (byte) 0x43, (byte) 0x0f,
            (byte) 0x4e, (byte) 0x75, (byte) 0xd8, (byte) 0xa3, (byte) 0x59, (byte) 0x5a,
            (byte) 0xc2, (byte) 0xba, (byte) 0x9a, (byte) 0x5b, (byte) 0x60, (byte) 0x31,
            (byte) 0x0d, (byte) 0x58, (byte) 0x89, (byte) 0x13, (byte) 0xe8, (byte) 0x95,
            (byte) 0xdd, (byte) 0xae, (byte) 0xcc, (byte) 0x1f, (byte) 0x73, (byte) 0x48,
            (byte) 0x55, (byte) 0xd8, (byte) 0xfb, (byte) 0x67, (byte) 0xce, (byte) 0x18,
            (byte) 0x85, (byte) 0x59, (byte) 0xad, (byte) 0x1f, (byte) 0x93, (byte) 0xe1,
            (byte) 0xb7, (byte) 0x54, (byte) 0x80, (byte) 0x8e, (byte) 0x5f, (byte) 0xbc,
            (byte) 0x1c, (byte) 0x96, (byte) 0x66, (byte) 0x2e, (byte) 0x40, (byte) 0x17,
            (byte) 0x2e, (byte) 0x01, (byte) 0x7a, (byte) 0x7d, (byte) 0xaa, (byte) 0xff,
            (byte) 0xa3, (byte) 0xd2, (byte) 0xdf, (byte) 0xe2, (byte) 0xf3, (byte) 0x54,
            (byte) 0x51, (byte) 0xeb, (byte) 0xba, (byte) 0x7c, (byte) 0x2a, (byte) 0x22,
            (byte) 0xc6, (byte) 0x42, (byte) 0xbc, (byte) 0xa1, (byte) 0x6c, (byte) 0xcf,
            (byte) 0x73, (byte) 0x2e, (byte) 0x07, (byte) 0xfc, (byte) 0xf5, (byte) 0x67,
            (byte) 0x25, (byte) 0xd0, (byte) 0xfa, (byte) 0xeb, (byte) 0xb4, (byte) 0xd4,
            (byte) 0x19, (byte) 0xcc, (byte) 0x64, (byte) 0xa1, (byte) 0x2e, (byte) 0x78,
            (byte) 0x45, (byte) 0xd9, (byte) 0x7f, (byte) 0x1b, (byte) 0x4c, (byte) 0x10,
            (byte) 0x31, (byte) 0x44, (byte) 0xe8, (byte) 0xcc, (byte) 0xf9, (byte) 0x1b,
            (byte) 0x87, (byte) 0x31, (byte) 0xd6, (byte) 0x69, (byte) 0x85, (byte) 0x4a,
            (byte) 0x49, (byte) 0xf6, (byte) 0xb2, (byte) 0xe0, (byte) 0xb8, (byte) 0x98,
            (byte) 0x3c, (byte) 0xf6, (byte) 0x78, (byte) 0x46, (byte) 0xc8, (byte) 0x3d,
            (byte) 0x60, (byte) 0xc1, (byte) 0xaa, (byte) 0x2f, (byte) 0x28, (byte) 0xa1,
            (byte) 0x14, (byte) 0x6b, (byte) 0x75, (byte) 0x4d, (byte) 0xb1, (byte) 0x3d,
            (byte) 0x80, (byte) 0x49, (byte) 0x33, (byte) 0xfd, (byte) 0x71, (byte) 0xc0,
            (byte) 0x13, (byte) 0x1e, (byte) 0x16, (byte) 0x69, (byte) 0x80, (byte) 0xa4,
            (byte) 0x9c, (byte) 0xd7, (byte) 0x02, (byte) 0x81, (byte) 0xc1, (byte) 0x00,
            (byte) 0x8c, (byte) 0x33, (byte) 0x2d, (byte) 0xd9, (byte) 0xf3, (byte) 0x42,
            (byte) 0x4d, (byte) 0xca, (byte) 0x5e, (byte) 0x60, (byte) 0x14, (byte) 0x10,
            (byte) 0xf6, (byte) 0xf3, (byte) 0x71, (byte) 0x15, (byte) 0x88, (byte) 0x54,
            (byte) 0x84, (byte) 0x21, (byte) 0x04, (byte) 0xb1, (byte) 0xaf, (byte) 0x02,
            (byte) 0x11, (byte) 0x7f, (byte) 0x42, (byte) 0x3e, (byte) 0x86, (byte) 0xcb,
            (byte) 0x6c, (byte) 0xf5, (byte) 0x57, (byte) 0x78, (byte) 0x4a, (byte) 0x03,
            (byte) 0x9b, (byte) 0x80, (byte) 0xc2, (byte) 0x04, (byte) 0x3a, (byte) 0x6b,
            (byte) 0xb3, (byte) 0x30, (byte) 0x31, (byte) 0x7e, (byte) 0xc3, (byte) 0x89,
            (byte) 0x09, (byte) 0x4e, (byte) 0x86, (byte) 0x59, (byte) 0x41, (byte) 0xb5,
            (byte) 0xae, (byte) 0xd5, (byte) 0xc6, (byte) 0x38, (byte) 0xbc, (byte) 0xd7,
            (byte) 0xd7, (byte) 0x8e, (byte) 0xa3, (byte) 0x1a, (byte) 0xde, (byte) 0x32,
            (byte) 0xad, (byte) 0x8d, (byte) 0x15, (byte) 0x81, (byte) 0xfe, (byte) 0xac,
            (byte) 0xbd, (byte) 0xd0, (byte) 0xca, (byte) 0xbc, (byte) 0xd8, (byte) 0x6a,
            (byte) 0xe1, (byte) 0xfe, (byte) 0xda, (byte) 0xc4, (byte) 0xd8, (byte) 0x62,
            (byte) 0x71, (byte) 0x20, (byte) 0xa3, (byte) 0xd3, (byte) 0x06, (byte) 0x11,
            (byte) 0xa9, (byte) 0x53, (byte) 0x7a, (byte) 0x44, (byte) 0x89, (byte) 0x3d,
            (byte) 0x28, (byte) 0x5e, (byte) 0x7d, (byte) 0xf0, (byte) 0x60, (byte) 0xeb,
            (byte) 0xb5, (byte) 0xdf, (byte) 0xed, (byte) 0x4f, (byte) 0x6d, (byte) 0x05,
            (byte) 0x59, (byte) 0x06, (byte) 0xb0, (byte) 0x62, (byte) 0x50, (byte) 0x1c,
            (byte) 0xb7, (byte) 0x2c, (byte) 0x44, (byte) 0xa4, (byte) 0x49, (byte) 0xf8,
            (byte) 0x4f, (byte) 0x4b, (byte) 0xab, (byte) 0x71, (byte) 0x5b, (byte) 0xcb,
            (byte) 0x31, (byte) 0x10, (byte) 0x41, (byte) 0xe0, (byte) 0x1a, (byte) 0x15,
            (byte) 0xdc, (byte) 0x4c, (byte) 0x5d, (byte) 0x4f, (byte) 0x62, (byte) 0x83,
            (byte) 0xa4, (byte) 0x80, (byte) 0x06, (byte) 0x36, (byte) 0xba, (byte) 0xc9,
            (byte) 0xe2, (byte) 0xa4, (byte) 0x11, (byte) 0x98, (byte) 0x6b, (byte) 0x4c,
            (byte) 0xe9, (byte) 0x90, (byte) 0x55, (byte) 0x18, (byte) 0xde, (byte) 0xe1,
            (byte) 0x42, (byte) 0x38, (byte) 0x28, (byte) 0xa3, (byte) 0x54, (byte) 0x56,
            (byte) 0x31, (byte) 0xaf, (byte) 0x5a, (byte) 0xd6, (byte) 0xf0, (byte) 0x26,
            (byte) 0xe0, (byte) 0x7a, (byte) 0xd9, (byte) 0x6c, (byte) 0x64, (byte) 0xca,
            (byte) 0x5d, (byte) 0x6d, (byte) 0x3d, (byte) 0x9a, (byte) 0xfe, (byte) 0x36,
            (byte) 0x93, (byte) 0x9e, (byte) 0x62, (byte) 0x94, (byte) 0xc6, (byte) 0x07,
            (byte) 0x83, (byte) 0x96, (byte) 0xd6, (byte) 0x27, (byte) 0xa6, (byte) 0xd8
    };
    private static final PrivateKey CLIENT_SUITE_B_RSA3072_KEY =
            loadPrivateKey(""RSA"", CLIENT_SUITE_B_RSA3072_KEY_DATA);

    private static final String CLIENT_SUITE_B_ECDSA_CERT_STRING =
            ""-----BEGIN CERTIFICATE-----\n""
                    + ""MIIB9zCCAX4CFDpfSZh3AH07BEfGWuMDa7Ynz6y+MAoGCCqGSM49BAMDMF4xCzAJ\n""
                    + ""BgNVBAYTAlVTMQswCQYDVQQIDAJDQTEMMAoGA1UEBwwDTVRWMRAwDgYDVQQKDAdB\n""
                    + ""bmRyb2lkMQ4wDAYDVQQLDAVXaS1GaTESMBAGA1UEAwwJdW5pdGVzdENBMB4XDTIw\n""
                    + ""MDcyMTAyMjk1MFoXDTMwMDUzMDAyMjk1MFowYjELMAkGA1UEBhMCVVMxCzAJBgNV\n""
                    + ""BAgMAkNBMQwwCgYDVQQHDANNVFYxEDAOBgNVBAoMB0FuZHJvaWQxDjAMBgNVBAsM\n""
                    + ""BVdpLUZpMRYwFAYDVQQDDA11bml0ZXN0Q2xpZW50MHYwEAYHKoZIzj0CAQYFK4EE\n""
                    + ""ACIDYgAEhxhVJ7dcSqrto0X+dgRxtd8BWG8cWmPjBji3MIxDLfpcMDoIB84ae1Ew\n""
                    + ""gJn4YUYHrWsUDiVNihv8j7a/Ol1qcIY2ybH7tbezefLmagqA4vXEUXZXoUyL4ZNC\n""
                    + ""DWcdw6LrMAoGCCqGSM49BAMDA2cAMGQCMH4aP73HrriRUJRguiuRic+X4Cqj/7YQ\n""
                    + ""ueJmP87KF92/thhoQ9OrRo8uJITPmNDswwIwP2Q1AZCSL4BI9dYrqu07Ar+pSkXE\n""
                    + ""R7oOqGdZR+d/MvXcFSrbIaLKEoHXmQamIHLe\n""
                    + ""-----END CERTIFICATE-----\n"";
    private static final X509Certificate CLIENT_SUITE_B_ECDSA_CERT =
            loadCertificate(CLIENT_SUITE_B_ECDSA_CERT_STRING);

    private static final byte[] CLIENT_SUITE_B_ECC_KEY_DATA = new byte[]{
            (byte) 0x30, (byte) 0x81, (byte) 0xb6, (byte) 0x02, (byte) 0x01, (byte) 0x00,
            (byte) 0x30, (byte) 0x10, (byte) 0x06, (byte) 0x07, (byte) 0x2a, (byte) 0x86,
            (byte) 0x48, (byte) 0xce, (byte) 0x3d, (byte) 0x02, (byte) 0x01, (byte) 0x06,
            (byte) 0x05, (byte) 0x2b, (byte) 0x81, (byte) 0x04, (byte) 0x00, (byte) 0x22,
            (byte) 0x04, (byte) 0x81, (byte) 0x9e, (byte) 0x30, (byte) 0x81, (byte) 0x9b,
            (byte) 0x02, (byte) 0x01, (byte) 0x01, (byte) 0x04, (byte) 0x30, (byte) 0xea,
            (byte) 0x6c, (byte) 0x4b, (byte) 0x6d, (byte) 0x43, (byte) 0xf9, (byte) 0x6c,
            (byte) 0x91, (byte) 0xdc, (byte) 0x2d, (byte) 0x6e, (byte) 0x87, (byte) 0x4f,
            (byte) 0x0a, (byte) 0x0b, (byte) 0x97, (byte) 0x25, (byte) 0x1c, (byte) 0x79,
            (byte) 0xa2, (byte) 0x07, (byte) 0xdc, (byte) 0x94, (byte) 0xc2, (byte) 0xee,
            (byte) 0x64, (byte) 0x51, (byte) 0x6d, (byte) 0x4e, (byte) 0x35, (byte) 0x1c,
            (byte) 0x22, (byte) 0x2f, (byte) 0xc0, (byte) 0xea, (byte) 0x09, (byte) 0x47,
            (byte) 0x3e, (byte) 0xb9, (byte) 0xb6, (byte) 0xb8, (byte) 0x83, (byte) 0x9e,
            (byte) 0xed, (byte) 0x59, (byte) 0xe5, (byte) 0xe7, (byte) 0x0f, (byte) 0xa1,
            (byte) 0x64, (byte) 0x03, (byte) 0x62, (byte) 0x00, (byte) 0x04, (byte) 0x87,
            (byte) 0x18, (byte) 0x55, (byte) 0x27, (byte) 0xb7, (byte) 0x5c, (byte) 0x4a,
            (byte) 0xaa, (byte) 0xed, (byte) 0xa3, (byte) 0x45, (byte) 0xfe, (byte) 0x76,
            (byte) 0x04, (byte) 0x71, (byte) 0xb5, (byte) 0xdf, (byte) 0x01, (byte) 0x58,
            (byte) 0x6f, (byte) 0x1c, (byte) 0x5a, (byte) 0x63, (byte) 0xe3, (byte) 0x06,
            (byte) 0x38, (byte) 0xb7, (byte) 0x30, (byte) 0x8c, (byte) 0x43, (byte) 0x2d,
            (byte) 0xfa, (byte) 0x5c, (byte) 0x30, (byte) 0x3a, (byte) 0x08, (byte) 0x07,
            (byte) 0xce, (byte) 0x1a, (byte) 0x7b, (byte) 0x51, (byte) 0x30, (byte) 0x80,
            (byte) 0x99, (byte) 0xf8, (byte) 0x61, (byte) 0x46, (byte) 0x07, (byte) 0xad,
            (byte) 0x6b, (byte) 0x14, (byte) 0x0e, (byte) 0x25, (byte) 0x4d, (byte) 0x8a,
            (byte) 0x1b, (byte) 0xfc, (byte) 0x8f, (byte) 0xb6, (byte) 0xbf, (byte) 0x3a,
            (byte) 0x5d, (byte) 0x6a, (byte) 0x70, (byte) 0x86, (byte) 0x36, (byte) 0xc9,
            (byte) 0xb1, (byte) 0xfb, (byte) 0xb5, (byte) 0xb7, (byte) 0xb3, (byte) 0x79,
            (byte) 0xf2, (byte) 0xe6, (byte) 0x6a, (byte) 0x0a, (byte) 0x80, (byte) 0xe2,
            (byte) 0xf5, (byte) 0xc4, (byte) 0x51, (byte) 0x76, (byte) 0x57, (byte) 0xa1,
            (byte) 0x4c, (byte) 0x8b, (byte) 0xe1, (byte) 0x93, (byte) 0x42, (byte) 0x0d,
            (byte) 0x67, (byte) 0x1d, (byte) 0xc3, (byte) 0xa2, (byte) 0xeb
    };
    private static final PrivateKey CLIENT_SUITE_B_ECC_KEY =
            loadPrivateKey(""EC"", CLIENT_SUITE_B_ECC_KEY_DATA);

    private static X509Certificate loadCertificate(String blob) {
        try {
            final CertificateFactory certFactory = CertificateFactory.getInstance(""X.509"");
            InputStream stream = new ByteArrayInputStream(blob.getBytes(StandardCharsets.UTF_8));

            return (X509Certificate) certFactory.generateCertificate(stream);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    private static PrivateKey loadPrivateKey(String algorithm, byte[] fakeKey) {
        try {
            KeyFactory kf = KeyFactory.getInstance(algorithm);
            return kf.generatePrivate(new PKCS8EncodedKeySpec(fakeKey));
        } catch (InvalidKeySpecException | NoSuchAlgorithmException e) {
            return null;
        }
    }

    private WifiNetworkSuggestion.Builder createBuilderWithCommonParams() {
        return createBuilderWithCommonParams(false);
    }

    private WifiNetworkSuggestion.Builder createBuilderWithCommonParams(boolean isPasspoint) {
        WifiNetworkSuggestion.Builder builder = new WifiNetworkSuggestion.Builder();
        if (!isPasspoint) {
            builder.setSsid(TEST_SSID);
            builder.setBssid(MacAddress.fromString(TEST_BSSID));
            builder.setIsEnhancedOpen(false);
            builder.setIsHiddenSsid(true);
        }
        builder.setPriority(TEST_PRIORITY);
        builder.setIsAppInteractionRequired(true);
        builder.setIsUserInteractionRequired(true);
        builder.setIsMetered(true);
        builder.setCarrierId(TelephonyManager.UNKNOWN_CARRIER_ID);
        builder.setCredentialSharedWithUser(true);
        builder.setIsInitialAutojoinEnabled(true);
        builder.setUntrusted(false);
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            builder.setOemPaid(false);
            builder.setOemPrivate(false);
            builder.setSubscriptionId(TEST_SUB_ID);
        }
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(sContext)) {
            builder.setPriorityGroup(TEST_PRIORITY_GROUP);
        }
        return builder;
    }

    private void validateCommonParams(WifiNetworkSuggestion suggestion) {
        validateCommonParams(suggestion, false);
    }

    private void validateCommonParams(WifiNetworkSuggestion suggestion, boolean isPasspoint) {
        assertNotNull(suggestion);
        assertNotNull(suggestion.getWifiConfiguration());
        if (!isPasspoint) {
            assertEquals(TEST_SSID, suggestion.getSsid());
            assertEquals(TEST_BSSID, suggestion.getBssid().toString());
            assertFalse(suggestion.isEnhancedOpen());
            assertTrue(suggestion.isHiddenSsid());
        }
        assertEquals(TEST_PRIORITY, suggestion.getPriority());
        assertTrue(suggestion.isAppInteractionRequired());
        assertTrue(suggestion.isUserInteractionRequired());
        assertTrue(suggestion.isMetered());
        assertTrue(suggestion.isCredentialSharedWithUser());
        assertTrue(suggestion.isInitialAutojoinEnabled());
        assertFalse(suggestion.isUntrusted());
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            assertFalse(suggestion.isOemPaid());
            assertFalse(suggestion.isOemPrivate());
            assertEquals(TEST_SUB_ID, suggestion.getSubscriptionId());
        }
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(sContext)) {
            assertEquals(TEST_PRIORITY_GROUP, suggestion.getPriorityGroup());
            assertEquals(TelephonyManager.UNKNOWN_CARRIER_ID, suggestion.getCarrierId());
        }
    }

    /**
     * Tests {@link android.net.wifi.WifiNetworkSuggestion.Builder} class.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.wifi.WifiStatsTests"	"testWifiScanLogsScanAtoms"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/wifi/WifiStatsTests.java"	""	"public void testWifiScanLogsScanAtoms() throws Exception {
        if (!DeviceUtils.hasFeature(getDevice(), FEATURE_WIFI)) return;

        ConfigUtils.uploadConfigForPushedAtom(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                AtomsProto.Atom.WIFI_SCAN_REPORTED_FIELD_NUMBER);
        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", ""testWifiScan"");
        Thread.sleep(AtomTestUtils.WAIT_TIME_SHORT);

        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        assertThat(data).hasSize(2);

        AtomsProto.WifiScanReported a0 = data.get(0).getAtom().getWifiScanReported();
        AtomsProto.WifiScanReported a1 = data.get(1).getAtom().getWifiScanReported();

        for (AtomsProto.WifiScanReported a : new AtomsProto.WifiScanReported[]{a0, a1}) {
            assertThat(a.getResult()).isEqualTo(AtomsProto.WifiScanReported.Result.RESULT_SUCCESS);
            assertThat(a.getType()).isEqualTo(AtomsProto.WifiScanReported.Type.TYPE_SINGLE);
            assertThat(a.getSource()).isAnyOf(
                    // If this test is run on a device that has a Settings app open that
                    // continuously performs frequent scans, quite often our scans requests
                    // are bundled together and get attributed to the Settings app.
                    AtomsProto.WifiScanReported.Source.SOURCE_SETTINGS_APP,
                    AtomsProto.WifiScanReported.Source.SOURCE_OTHER_APP);
            assertThat(a.getImportance()).isEqualTo(
                    AtomsProto.WifiScanReported.Importance.IMPORTANCE_FOREGROUND_SERVICE);

            assertThat(a.getScanDurationMillis()).isGreaterThan(0);
        }
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.cts.statsdatom.wifi.WifiStatsTests"	"testWifiScanLogsStateChangedAtoms"	"CtsStatsdAtomHostTestCases"	"/home/gpoor/cts-12-source/cts/hostsidetests/statsdatom/src/android/cts/statsdatom/wifi/WifiStatsTests.java"	""	"public void testWifiScanLogsStateChangedAtoms() throws Exception {
        if (!DeviceUtils.hasFeature(getDevice(), FEATURE_WIFI)) return;


        ConfigUtils.uploadConfigForPushedAtomWithUid(getDevice(), DeviceUtils.STATSD_ATOM_TEST_PKG,
                AtomsProto.Atom.WIFI_SCAN_STATE_CHANGED_FIELD_NUMBER,  true);
        DeviceUtils.runDeviceTestsOnStatsdApp(getDevice(), "".AtomTests"", ""testWifiScan"");
        Thread.sleep(AtomTestUtils.WAIT_TIME_SHORT);

        final int stateOn = AtomsProto.WifiScanStateChanged.State.ON_VALUE;
        final int stateOff = AtomsProto.WifiScanStateChanged.State.OFF_VALUE;
        final int minTimeDiffMillis = 250;
        final int maxTimeDiffMillis = 60_000;

        List<StatsLog.EventMetricData> data = ReportUtils.getEventMetricDataList(getDevice());
        assertThat(data.size()).isIn(Range.closed(2, 4));
        AtomTestUtils.assertTimeDiffBetween(data.get(0), data.get(1), minTimeDiffMillis,
                maxTimeDiffMillis);
        AtomsProto.WifiScanStateChanged a0 = data.get(0).getAtom().getWifiScanStateChanged();
        AtomsProto.WifiScanStateChanged a1 = data.get(1).getAtom().getWifiScanStateChanged();
        assertThat(a0.getState().getNumber()).isEqualTo(stateOn);
        assertThat(a1.getState().getNumber()).isEqualTo(stateOff);
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiBackupRestoreTest"	"isNotNull"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiBackupRestoreTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.content.pm.PackageManager.PERMISSION_GRANTED;
import static android.net.wifi.WifiConfiguration.METERED_OVERRIDE_METERED;
import static android.net.wifi.WifiConfiguration.METERED_OVERRIDE_NONE;
import static android.net.wifi.WifiConfiguration.METERED_OVERRIDE_NOT_METERED;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeTrue;

import android.app.UiAutomation;
import android.content.Context;
import android.net.IpConfiguration;
import android.net.LinkAddress;
import android.net.ProxyInfo;
import android.net.StaticIpConfiguration;
import android.net.Uri;
import android.net.wifi.SoftApConfiguration;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiEnterpriseConfig;
import android.net.wifi.WifiManager;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;
import android.util.Log;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SmallTest;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;
import com.android.compatibility.common.util.ThrowingRunnable;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.DataInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Tests for wifi backup/restore functionality.
 */
@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@SmallTest
@RunWith(AndroidJUnit4.class)
public class WifiBackupRestoreTest extends WifiJUnit4TestBase {
    private static final String TAG = ""WifiBackupRestoreTest"";
    private static final String LEGACY_SUPP_CONF_FILE =
            ""assets/BackupLegacyFormatSupplicantConf.txt"";
    private static final String LEGACY_IP_CONF_FILE =
            ""assets/BackupLegacyFormatIpConf.txt"";
    private static final String V1_0_FILE = ""assets/BackupV1.0Format.xml"";
    private static final String V1_1_FILE = ""assets/BackupV1.1Format.xml"";
    private static final String V1_2_FILE = ""assets/BackupV1.2Format.xml"";

    public static final String EXPECTED_LEGACY_STATIC_IP_LINK_ADDRESS = ""192.168.48.2"";
    public static final int EXPECTED_LEGACY_STATIC_IP_LINK_PREFIX_LENGTH = 8;
    public static final String EXPECTED_LEGACY_STATIC_IP_GATEWAY_ADDRESS = ""192.168.48.1"";
    public static final String[] EXPECTED_LEGACY_STATIC_IP_DNS_SERVER_ADDRESSES =
            new String[]{""192.168.48.1"", ""192.168.48.10""};
    public static final String EXPECTED_LEGACY_STATIC_PROXY_HOST = ""192.168.48.1"";
    public static final int EXPECTED_LEGACY_STATIC_PROXY_PORT = 8000;
    public static final String EXPECTED_LEGACY_STATIC_PROXY_EXCLUSION_LIST = """";
    public static final String EXPECTED_LEGACY_PAC_PROXY_LOCATION = ""http://"";

    private Context mContext;
    private WifiManager mWifiManager;
    private UiDevice mUiDevice;
    private boolean mWasVerboseLoggingEnabled;

    private static final int DURATION = 10_000;
    private static final int DURATION_SCREEN_TOGGLE = 2000;

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getContext();
        // skip the test if WiFi is not supported
        assumeTrue(WifiFeature.isWifiSupported(mContext));

        mWifiManager = mContext.getSystemService(WifiManager.class);
        assertThat(mWifiManager).isNotNull();

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(false));

        if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);
        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        turnScreenOn();
        PollingCheck.check(""Wifi not enabled"", DURATION, () -> mWifiManager.isWifiEnabled());

        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.getPrivilegedConfiguredNetworks());
        assertWithMessage(""Need at least one saved network"").that(savedNetworks).isNotEmpty();
    }

    @After
    public void tearDown() throws Exception {
        if (!WifiFeature.isWifiSupported(mContext)) return;
        if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);
        turnScreenOff();
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));
    }

    private void setWifiEnabled(boolean enable) throws Exception {
        // now trigger the change using shell commands.
        SystemUtil.runShellCommand(""svc wifi "" + (enable ? ""enable"" : ""disable""));
    }

    private void turnScreenOn() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_WAKEUP"");
        mUiDevice.executeShellCommand(""wm dismiss-keyguard"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE);
    }

    private void turnScreenOff() throws Exception {
        mUiDevice.executeShellCommand(""input keyevent KEYCODE_SLEEP"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(DURATION_SCREEN_TOGGLE);
    }

    private void flipMeteredOverride(WifiConfiguration network) {
        if (network.meteredOverride == METERED_OVERRIDE_NONE) {
            network.meteredOverride = METERED_OVERRIDE_METERED;
        } else if (network.meteredOverride == METERED_OVERRIDE_METERED) {
            network.meteredOverride = METERED_OVERRIDE_NOT_METERED;
        } else if (network.meteredOverride == METERED_OVERRIDE_NOT_METERED) {
            network.meteredOverride = METERED_OVERRIDE_NONE;
        }
    }

    /** WifiConfiguration#isEnterprise() is @hide, so copy/paste partial implementation here. */
    private static boolean isEnterprise(WifiConfiguration config) {
        WifiEnterpriseConfig enterpriseConfig = config.enterpriseConfig;
        return enterpriseConfig != null
                && enterpriseConfig.getEapMethod() != WifiEnterpriseConfig.Eap.NONE;
    }

    /**
     * Tests for {@link WifiManager#retrieveBackupData()} &
     * {@link WifiManager#restoreBackupData(byte[])}
     * Note: If the network was not created by an app with OVERRIDE_WIFI_CONFIG permission (held
     * by AOSP settings app for example), then the backup data will not contain that network. If
     * the device does not contain any such pre-existing saved network, then this test will be
     * a no-op, will only ensure that the device does not crash when invoking the API's.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.wifi.testcase.NetworkRequestTestCase"	"isEmpty"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/wifi/testcase/NetworkRequestTestCase.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.wifi.testcase;

import static android.net.NetworkCapabilities.NET_CAPABILITY_INTERNET;
import static android.net.NetworkCapabilities.TRANSPORT_WIFI;

import static com.android.cts.verifier.wifi.TestUtils.SCAN_RESULT_TYPE_OPEN;
import static com.android.cts.verifier.wifi.TestUtils.SCAN_RESULT_TYPE_PSK;

import android.annotation.IntDef;
import android.annotation.NonNull;
import android.content.Context;
import android.net.ConnectivityManager;
import android.net.MacAddress;
import android.net.Network;
import android.net.NetworkRequest;
import android.net.NetworkSpecifier;
import android.net.wifi.ScanResult;
import android.net.wifi.WifiNetworkSpecifier;
import android.os.PatternMatcher;
import android.util.Log;
import android.util.Pair;

import com.android.cts.verifier.R;
import com.android.cts.verifier.wifi.BaseTestCase;
import com.android.cts.verifier.wifi.CallbackUtils;
import com.android.cts.verifier.wifi.TestUtils;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

/**
 * Test case for all {@link NetworkRequest} requests with specifier built using
 * {@link WifiNetworkSpecifier.Builder#build()}.
 */
public class NetworkRequestTestCase extends BaseTestCase {
    private static final String TAG = ""NetworkRequestTestCase"";
    private static final boolean DBG = true;

    private static final String UNAVAILABLE_SSID = ""blahblahblah"";
    private static final String UNAVAILABLE_BSSID = ""02:00:00:00:00:00"";
    private static final int NETWORK_REQUEST_TIMEOUT_MS = 30_000;
    private static final int CALLBACK_TIMEOUT_MS = 40_000;

    public static final int NETWORK_SPECIFIER_SPECIFIC_SSID_BSSID = 0;
    public static final int NETWORK_SPECIFIER_PATTERN_SSID_BSSID = 1;
    public static final int NETWORK_SPECIFIER_UNAVAILABLE_SSID_BSSID = 2;
    public static final int NETWORK_SPECIFIER_INVALID_CREDENTIAL = 3;

    @IntDef(prefix = { ""NETWORK_SPECIFIER_"" }, value = {
            NETWORK_SPECIFIER_SPECIFIC_SSID_BSSID,
            NETWORK_SPECIFIER_PATTERN_SSID_BSSID,
            NETWORK_SPECIFIER_UNAVAILABLE_SSID_BSSID,
            NETWORK_SPECIFIER_INVALID_CREDENTIAL
    })
    @Retention(RetentionPolicy.SOURCE)
    public @interface NetworkSpecifierType{}

    private final Object mLock = new Object();
    private final @NetworkSpecifierType int mNetworkSpecifierType;

    private ConnectivityManager mConnectivityManager;
    private NetworkRequest mNetworkRequest;
    private CallbackUtils.NetworkCallback mNetworkCallback;
    private String mFailureReason;

    public NetworkRequestTestCase(Context context, @NetworkSpecifierType int networkSpecifierType) {
        super(context);
        mNetworkSpecifierType = networkSpecifierType;
    }

    // Create a network specifier based on the test type.
    private NetworkSpecifier createNetworkSpecifier(@NonNull ScanResult scanResult)
            throws InterruptedException {
        WifiNetworkSpecifier.Builder configBuilder = new WifiNetworkSpecifier.Builder();
        switch (mNetworkSpecifierType) {
            case NETWORK_SPECIFIER_SPECIFIC_SSID_BSSID:
                configBuilder.setSsid(scanResult.SSID);
                configBuilder.setBssid(MacAddress.fromString(scanResult.BSSID));
                if (!mPsk.isEmpty()) {
                    if (TestUtils.isScanResultForWpa2Network(scanResult)) {
                        configBuilder.setWpa2Passphrase(mPsk);
                    } else if (TestUtils.isScanResultForWpa3Network(scanResult)) {
                        configBuilder.setWpa3Passphrase(mPsk);
                    }
                }
                break;
            case NETWORK_SPECIFIER_PATTERN_SSID_BSSID:
                String ssidPrefix = scanResult.SSID.substring(0, scanResult.SSID.length() - 1);
                MacAddress bssidMask = MacAddress.fromString(""ff:ff:ff:ff:ff:00"");
                configBuilder.setSsidPattern(
                        new PatternMatcher(ssidPrefix, PatternMatcher.PATTERN_PREFIX));
                configBuilder.setBssidPattern(MacAddress.fromString(scanResult.BSSID), bssidMask);
                if (!mPsk.isEmpty()) {
                    if (TestUtils.isScanResultForWpa2Network(scanResult)) {
                        configBuilder.setWpa2Passphrase(mPsk);
                    } else if (TestUtils.isScanResultForWpa3Network(scanResult)) {
                        configBuilder.setWpa3Passphrase(mPsk);
                    }
                }
                break;
            case NETWORK_SPECIFIER_UNAVAILABLE_SSID_BSSID:
                String ssid = UNAVAILABLE_SSID;
                MacAddress bssid = MacAddress.fromString(UNAVAILABLE_BSSID);
                if (mTestUtils.findNetworkInScanResultsResults(ssid, bssid.toString())) {
                    Log.e(TAG, ""The specifiers chosen match a network in scan results.""
                            + ""Test will fail"");
                    return null;
                }
                configBuilder.setSsid(UNAVAILABLE_SSID);
                configBuilder.setBssid(bssid);
                if (!mPsk.isEmpty()) {
                    if (TestUtils.isScanResultForWpa2Network(scanResult)) {
                        configBuilder.setWpa2Passphrase(mPsk);
                    } else if (TestUtils.isScanResultForWpa3Network(scanResult)) {
                        configBuilder.setWpa3Passphrase(mPsk);
                    }
                }
                break;
            case NETWORK_SPECIFIER_INVALID_CREDENTIAL:
                configBuilder.setSsid(scanResult.SSID);
                configBuilder.setBssid(MacAddress.fromString(scanResult.BSSID));
                // Use a random password to simulate connection failure.
                if (TestUtils.isScanResultForWpa2Network(scanResult)) {
                    configBuilder.setWpa2Passphrase(mTestUtils.generateRandomPassphrase());
                } else if (TestUtils.isScanResultForWpa3Network(scanResult)) {
                    configBuilder.setWpa3Passphrase(mTestUtils.generateRandomPassphrase());
                }
                break;
            default:
                throw new IllegalStateException(""Unknown specifier type specifier"");
        }
        return configBuilder.build();
    }


    private void setFailureReason(String reason) {
        synchronized (mLock) {
            mFailureReason = reason;
        }
    }

    @Override
    protected boolean executeTest() throws InterruptedException {
        if (mNetworkSpecifierType == NETWORK_SPECIFIER_INVALID_CREDENTIAL && mPsk.isEmpty()) {
            setFailureReason(mContext.getString(R.string.wifi_status_need_psk));
            return false;
        }
        // Step: Scan and find the network around.
        if (DBG) Log.v(TAG, ""Scan and find the network: "" + mSsid);
        ScanResult testNetwork = mTestUtils.startScanAndFindAnyMatchingNetworkInResults(
                mSsid, mPsk.isEmpty() ? SCAN_RESULT_TYPE_OPEN : SCAN_RESULT_TYPE_PSK);
        if (testNetwork == null) {
            setFailureReason(mContext.getString(R.string.wifi_status_scan_failure));
            return false;
        }

        // Step: Create a specifier for the chosen open network depending on the type of test.
        NetworkSpecifier wns = createNetworkSpecifier(testNetwork);
        if (wns == null) return false;

        // Step: Create a network request with specifier.
        mNetworkRequest = new NetworkRequest.Builder()
                .addTransportType(TRANSPORT_WIFI)
                .setNetworkSpecifier(wns)
                .removeCapability(NET_CAPABILITY_INTERNET)
                .build();

        // Step: Send the network request
        if (DBG) Log.v(TAG, ""Request network using "" + mNetworkRequest);
        mNetworkCallback = new CallbackUtils.NetworkCallback(CALLBACK_TIMEOUT_MS);
        mListener.onTestMsgReceived(
                mContext.getString(R.string.wifi_status_initiating_network_request));
        mConnectivityManager.requestNetwork(mNetworkRequest, mNetworkCallback,
                NETWORK_REQUEST_TIMEOUT_MS);

        // Step: Wait for the network available/unavailable callback.
        if (mNetworkSpecifierType == NETWORK_SPECIFIER_UNAVAILABLE_SSID_BSSID
                || mNetworkSpecifierType == NETWORK_SPECIFIER_INVALID_CREDENTIAL) {
            if (mNetworkSpecifierType == NETWORK_SPECIFIER_UNAVAILABLE_SSID_BSSID) {
                mListener.onTestMsgReceived(
                        mContext.getString(R.string.wifi_status_network_wait_for_unavailable));
            } else {
                mListener.onTestMsgReceived(
                        mContext.getString(R.string
                                .wifi_status_network_wait_for_unavailable_invalid_credential));
            }
            if (DBG) Log.v(TAG, ""Waiting for network unavailable callback"");
            boolean cbStatusForUnavailable = mNetworkCallback.waitForUnavailable();
            if (!cbStatusForUnavailable) {
                Log.e(TAG, ""Failed to get network unavailable callback"");
                setFailureReason(mContext.getString(R.string.wifi_status_network_cb_timeout));
                return false;
            }
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_network_unavailable));
            // All done!
            return true;
        }
        mListener.onTestMsgReceived(
                mContext.getString(R.string.wifi_status_network_wait_for_available));
        if (DBG) Log.v(TAG, ""Waiting for network available callback"");
        Pair<Boolean, Network> cbStatusForAvailable = mNetworkCallback.waitForAvailable();
        if (!cbStatusForAvailable.first) {
            Log.e(TAG, ""Failed to get network available callback"");
            setFailureReason(mContext.getString(R.string.wifi_status_network_cb_timeout));
            return false;
        }
        mListener.onTestMsgReceived(
                mContext.getString(R.string.wifi_status_network_available));

        mListener.onTestMsgReceived(
                mContext.getString(R.string.wifi_status_network_wait_for_lost));
        // Step 6: Ensure we don't disconnect from the network as long as the request is alive.
        if (DBG) Log.v(TAG, ""Ensuring network lost callback is not invoked"");
        boolean cbStatusForLost = mNetworkCallback.waitForLost();
        if (cbStatusForLost) {
            Log.e(TAG, ""Disconnected from the network even though the request is active"");
            setFailureReason(mContext.getString(R.string.wifi_status_network_lost));
            return false;
        }
        // All done!
        return true;
    }

    @Override
    protected String getFailureReason() {
        synchronized (mLock) {
            return mFailureReason;
        }
    }

    @Override
    protected void setUp() {
        super.setUp();
        mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);
    }

    @Override
    protected void tearDown() {
        if (mNetworkCallback != null) {
            mConnectivityManager.unregisterNetworkCallback(mNetworkCallback);
        }
        super.tearDown();
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.rtt.cts.WifiRttTest"	"testRangingToTest11mcAp"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/rtt/cts/WifiRttTest.java"	""	"public void testRangingToTest11mcAp() throws InterruptedException {
        if (!shouldTestWifiRtt(getContext())) {
            return;
        }

        // Scan for IEEE 802.11mc supporting APs
        ScanResult testAp = scanForTest11mcCapableAp(NUM_SCANS_SEARCHING_FOR_IEEE80211MC_AP);
        assertNotNull(
                ""Cannot find any test APs which support RTT / IEEE 802.11mc - please verify that ""
                        + ""your test setup includes them!"", testAp);

        // Perform RTT operations
        RangingRequest.Builder builder = new RangingRequest.Builder();
        builder.addAccessPoint(testAp);
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            builder.setRttBurstSize(RangingRequest.getMaxRttBurstSize());
            assertTrue(RangingRequest.getDefaultRttBurstSize()
                    >= RangingRequest.getMinRttBurstSize());
            assertTrue(RangingRequest.getDefaultRttBurstSize()
                    <= RangingRequest.getMaxRttBurstSize());
        }
        RangingRequest request = builder.build();
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            assertEquals(1, request.getRttResponders().size());
        }

        List<RangingResult> allResults = new ArrayList<>();
        int numFailures = 0;
        int distanceSum = 0;
        int distanceMin = 0;
        int distanceMax = 0;
        int[] statuses = new int[NUM_OF_RTT_ITERATIONS];
        int[] distanceMms = new int[NUM_OF_RTT_ITERATIONS];
        int[] distanceStdDevMms = new int[NUM_OF_RTT_ITERATIONS];
        int[] rssis = new int[NUM_OF_RTT_ITERATIONS];
        int[] numAttempted = new int[NUM_OF_RTT_ITERATIONS];
        int[] numSuccessful = new int[NUM_OF_RTT_ITERATIONS];
        long[] timestampsMs = new long[NUM_OF_RTT_ITERATIONS];
        byte[] lastLci = null;
        byte[] lastLcr = null;
        for (int i = 0; i < NUM_OF_RTT_ITERATIONS; ++i) {
            ResultCallback callback = new ResultCallback();
            mWifiRttManager.startRanging(request, mExecutor, callback);
            assertTrue(""Wi-Fi RTT results: no callback on iteration "" + i,
                    callback.waitForCallback());

            List<RangingResult> currentResults = callback.getResults();
            assertNotNull(""Wi-Fi RTT results: null results (onRangingFailure) on iteration "" + i,
                    currentResults);
            assertEquals(""Wi-Fi RTT results: unexpected # of results (expect 1) on iteration "" + i,
                    1, currentResults.size());
            RangingResult result = currentResults.get(0);
            assertEquals(""Wi-Fi RTT results: invalid result (wrong BSSID) entry on iteration "" + i,
                    result.getMacAddress().toString(), testAp.BSSID);
            assertNull(""Wi-Fi RTT results: invalid result (non-null PeerHandle) entry on iteration ""
                    + i, result.getPeerHandle());

            allResults.add(result);
            int status = result.getStatus();
            statuses[i] = status;
            if (status == RangingResult.STATUS_SUCCESS) {
                if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
                    assertEquals(
                            ""Wi-Fi RTT results: invalid result (wrong rttBurstSize) entry on ""
                                    + ""iteration ""
                                    + i,
                            result.getNumAttemptedMeasurements(),
                            RangingRequest.getMaxRttBurstSize());
                    assertTrue(""Wi-Fi RTT results: should be a 802.11MC measurement"",
                            result.is80211mcMeasurement());
                }
                distanceSum += result.getDistanceMm();
                if (i == 0) {
                    distanceMin = result.getDistanceMm();
                    distanceMax = result.getDistanceMm();
                } else {
                    distanceMin = Math.min(distanceMin, result.getDistanceMm());
                    distanceMax = Math.max(distanceMax, result.getDistanceMm());
                }

                assertTrue(""Wi-Fi RTT results: invalid RSSI on iteration "" + i,
                        result.getRssi() >= MIN_VALID_RSSI);

                distanceMms[i - numFailures] = result.getDistanceMm();
                distanceStdDevMms[i - numFailures] = result.getDistanceStdDevMm();
                rssis[i - numFailures] = result.getRssi();
                numAttempted[i - numFailures] = result.getNumAttemptedMeasurements();
                numSuccessful[i - numFailures] = result.getNumSuccessfulMeasurements();
                timestampsMs[i - numFailures] = result.getRangingTimestampMillis();

                byte[] currentLci = result.getLci();
                byte[] currentLcr = result.getLcr();
                if (i - numFailures > 0) {
                    assertTrue(""Wi-Fi RTT results: invalid result (LCI mismatch) on iteration "" + i,
                            Arrays.equals(currentLci, lastLci));
                    assertTrue(""Wi-Fi RTT results: invalid result (LCR mismatch) on iteration "" + i,
                            Arrays.equals(currentLcr, lastLcr));
                }
                lastLci = currentLci;
                lastLcr = currentLcr;
            } else {
                numFailures++;
            }
            // Sleep a while to avoid stress AP.
            Thread.sleep(intervalMs);
        }

        // Save results to log
        int numGoodResults = NUM_OF_RTT_ITERATIONS - numFailures;
        DeviceReportLog reportLog = new DeviceReportLog(TAG, ""testRangingToTestAp"");
        reportLog.addValues(""status_codes"", statuses, ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""distance_mm"", Arrays.copyOf(distanceMms, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""distance_stddev_mm"", Arrays.copyOf(distanceStdDevMms, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""rssi_dbm"", Arrays.copyOf(rssis, numGoodResults), ResultType.NEUTRAL,
                ResultUnit.NONE);
        reportLog.addValues(""num_attempted"", Arrays.copyOf(numAttempted, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""num_successful"", Arrays.copyOf(numSuccessful, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""timestamps"", Arrays.copyOf(timestampsMs, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.submit();

        // Analyze results
        assertTrue(""Wi-Fi RTT failure rate exceeds threshold: FAIL="" + numFailures + "", ITERATIONS=""
                        + NUM_OF_RTT_ITERATIONS + "", AP RSSI="" + testAp.level
                        + "", AP SSID="" + testAp.SSID,
                numFailures <= NUM_OF_RTT_ITERATIONS * MAX_FAILURE_RATE_PERCENT / 100);
        if (numFailures != NUM_OF_RTT_ITERATIONS) {
            double distanceAvg = (double) distanceSum / (NUM_OF_RTT_ITERATIONS - numFailures);
            assertTrue(""Wi-Fi RTT: Variation (max direction) exceeds threshold, Variation =""
                            + (distanceMax - distanceAvg),
                    (distanceMax - distanceAvg) <= MAX_VARIATION_FROM_AVERAGE_DISTANCE_MM);
            assertTrue(""Wi-Fi RTT: Variation (min direction) exceeds threshold, Variation =""
                            + (distanceAvg - distanceMin),
                    (distanceAvg - distanceMin) <= MAX_VARIATION_FROM_AVERAGE_DISTANCE_MM);
            for (int i = 0; i < numGoodResults; ++i) {
                assertNotSame(""Number of attempted measurements is 0"", 0, numAttempted[i]);
                assertNotSame(""Number of successful measurements is 0"", 0, numSuccessful[i]);
            }
        }
    }

    /**
     * Validate that when a request contains more range operations than allowed (by API) that we
     * get an exception.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.rtt.cts.WifiRttTest"	"testRequestTooLarge"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/rtt/cts/WifiRttTest.java"	""	"public void testRequestTooLarge() throws InterruptedException {
        if (!shouldTestWifiRtt(getContext())) {
            return;
        }
        ScanResult testAp = scanForTest11mcCapableAp(NUM_SCANS_SEARCHING_FOR_IEEE80211MC_AP);
        assertNotNull(
                ""Cannot find any test APs which support RTT / IEEE 802.11mc - please verify that ""
                        + ""your test setup includes them!"", testAp);

        RangingRequest.Builder builder = new RangingRequest.Builder();
        List<ScanResult> scanResults = new ArrayList<>();
        for (int i = 0; i < RangingRequest.getMaxPeers() - 2; ++i) {
            scanResults.add(testAp);
        }
        builder.addAccessPoints(scanResults);

        ScanResult testApNon80211mc = null;
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            testApNon80211mc = scanForTestNon11mcCapableAp(NUM_SCANS_SEARCHING_FOR_IEEE80211MC_AP);
        }
        if (testApNon80211mc == null) {
            builder.addAccessPoints(List.of(testAp, testAp, testAp));
        } else {
            builder.addNon80211mcCapableAccessPoints(List.of(testApNon80211mc, testApNon80211mc,
                    testApNon80211mc));
        }

        try {
            mWifiRttManager.startRanging(builder.build(), mExecutor, new ResultCallback());
        } catch (IllegalArgumentException e) {
            return;
        }

        fail(""Did not receive expected IllegalArgumentException when tried to range to too ""
                + ""many peers"");
    }

    /**
     * Verify ResponderLocation API
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.rtt.cts.WifiRttTest"	"testRangingToTestApWithResponderLocation"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/rtt/cts/WifiRttTest.java"	""	"public void testRangingToTestApWithResponderLocation() throws InterruptedException {
        if (!shouldTestWifiRtt(getContext())) {
            return;
        }
        // Scan for IEEE 802.11mc supporting APs
        ScanResult testAp = scanForTest11mcCapableAp(NUM_SCANS_SEARCHING_FOR_IEEE80211MC_AP);
        assertNotNull(
                ""Cannot find any test APs which support RTT / IEEE 802.11mc - please verify that ""
                        + ""your test setup includes them!"", testAp);

        // Perform RTT operations
        RangingRequest request = new RangingRequest.Builder().addAccessPoint(testAp).build();
        ResultCallback callback = new ResultCallback();
        mWifiRttManager.startRanging(request, mExecutor, callback);
        assertTrue(""Wi-Fi RTT results: no callback! "",
                callback.waitForCallback());

        RangingResult result = callback.getResults().get(0);
        assertEquals(""Ranging request not success"",
                result.getStatus(), RangingResult.STATUS_SUCCESS);
        ResponderLocation responderLocation = result.getUnverifiedResponderLocation();
        if (responderLocation == null) {
            return;
        }
        assertTrue(""ResponderLocation is not valid"", responderLocation.isLciSubelementValid());

        // Check LCI related APIs
        int exceptionCount = 0;
        int apiCount = 0;
        try {
            apiCount++;
            responderLocation.getLatitudeUncertainty();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getLatitude();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getLongitudeUncertainty();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getLongitude();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getAltitudeType();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getAltitudeUncertainty();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getAltitude();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getDatum();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getRegisteredLocationAgreementIndication();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            responderLocation.getLciVersion();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        try {
            apiCount++;
            assertNotNull(responderLocation.toLocation());
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        // If LCI is not valid, all APIs should throw exception, otherwise no exception.
        assertEquals(""Exception number should equal to API number"",
                responderLocation.isLciSubelementValid()? 0 : apiCount, exceptionCount);

        // Verify ZaxisSubelement APIs
        apiCount = 0;
        exceptionCount = 0;

        try {
            apiCount++;
            responderLocation.getExpectedToMove();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }

        try {
            apiCount++;
            responderLocation.getFloorNumber();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }

        try {
            apiCount++;
            responderLocation.getHeightAboveFloorMeters();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }

        try {
            apiCount++;
            responderLocation.getHeightAboveFloorUncertaintyMeters();
        } catch (IllegalStateException e) {
            exceptionCount++;
        }
        // If Zaxis is not valid, all APIs should throw exception, otherwise no exception.
        assertEquals(""Exception number should equal to API number"",
                responderLocation.isZaxisSubelementValid() ? 0 : apiCount, exceptionCount);
        // Verify civic location
        if (responderLocation.toCivicLocationAddress() == null) {
            assertNull(responderLocation.toCivicLocationSparseArray());
        } else {
            assertNotNull(responderLocation.toCivicLocationSparseArray());
        }
        // Verify map image
        if (responderLocation.getMapImageUri() == null) {
            assertNull(responderLocation.getMapImageMimeType());
        } else {
            assertNotNull(responderLocation.getMapImageMimeType());
        }
        boolean extraInfoOnAssociationIndication =
                responderLocation.getExtraInfoOnAssociationIndication();
        assertNotNull(""ColocatedBSSID list should be nonNull"",
                responderLocation.getColocatedBssids());
    }

    /**
     * Verify ranging request with aware peer Mac address and peer handle.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.rtt.cts.WifiRttTest"	"testAwareRttWithPeerHandle"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/rtt/cts/WifiRttTest.java"	""	"public void testAwareRttWithPeerHandle() throws InterruptedException {
        if (!(shouldTestWifiRtt(getContext()) && shouldTestWifiAware(getContext()))) {
            return;
        }
        PeerHandle peerHandle = mock(PeerHandle.class);
        RangingRequest request = new RangingRequest.Builder()
                .addWifiAwarePeer(peerHandle).build();
        ResultCallback callback = new ResultCallback();
        mWifiRttManager.startRanging(request, mExecutor, callback);
        assertTrue(""Wi-Fi RTT results: no callback"",
                callback.waitForCallback());
        List<RangingResult> rangingResults = callback.getResults();
        assertNotNull(""Wi-Fi RTT results: null results"", rangingResults);
        assertEquals(""Invalid peerHandle should return 0 result"", 0, rangingResults.size());
    }

    /**
     * Test Wi-Fi One-sided RTT ranging operation:
     * - Scan for visible APs for the test AP (which do not support IEEE 802.11mc) and are operating
     * - in the 5GHz band.
     * - Perform N (constant) RTT operations
     * - Remove outliers while insuring greater than 50% of the results still remain
     * - Validate:
     *   - Failure ratio < threshold (constant)
     *   - Result margin < threshold (constant)
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.rtt.cts.WifiRttTest"	"testRangingToTestNon11mcAp"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/rtt/cts/WifiRttTest.java"	""	"public void testRangingToTestNon11mcAp() throws InterruptedException {
        if (!shouldTestWifiRtt(getContext())
                || !WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(getContext())) {
            return;
        }

        // Scan for Non-IEEE 802.11mc supporting APs
        ScanResult testAp = scanForTestNon11mcCapableAp(NUM_SCANS_SEARCHING_FOR_IEEE80211MC_AP);
        assertNotNull(
                ""Cannot find any test APs which are Non-IEEE 802.11mc - please verify that""
                        + "" your test setup includes them!"", testAp);

        // Perform RTT operations
        RangingRequest.Builder builder = new RangingRequest.Builder();
        builder.addNon80211mcCapableAccessPoint(testAp);
        builder.setRttBurstSize(RangingRequest.getMaxRttBurstSize());
        RangingRequest request = builder.build();

        List<RangingResult> allResults = new ArrayList<>();
        int numFailures = 0;
        int distanceSum = 0;
        int distanceMin = 0;
        int distanceMax = 0;
        int[] statuses = new int[NUM_OF_RTT_ITERATIONS];
        int[] distanceMms = new int[NUM_OF_RTT_ITERATIONS];
        boolean[] distanceInclusionMap = new boolean[NUM_OF_RTT_ITERATIONS];
        int[] distanceStdDevMms = new int[NUM_OF_RTT_ITERATIONS];
        int[] rssis = new int[NUM_OF_RTT_ITERATIONS];
        int[] numAttempted = new int[NUM_OF_RTT_ITERATIONS];
        int[] numSuccessful = new int[NUM_OF_RTT_ITERATIONS];
        long[] timestampsMs = new long[NUM_OF_RTT_ITERATIONS];
        byte[] lastLci = null;
        byte[] lastLcr = null;
        for (int i = 0; i < NUM_OF_RTT_ITERATIONS; ++i) {
            ResultCallback callback = new ResultCallback();
            mWifiRttManager.startRanging(request, mExecutor, callback);
            assertTrue(""Wi-Fi RTT results: no callback on iteration "" + i,
                    callback.waitForCallback());

            List<RangingResult> currentResults = callback.getResults();
            assertNotNull(
                    ""Wi-Fi RTT results: null results (onRangingFailure) on iteration "" + i,
                    currentResults);
            assertEquals(
                    ""Wi-Fi RTT results: unexpected # of results (expect 1) on iteration "" + i,
                    1, currentResults.size());
            RangingResult result = currentResults.get(0);
            assertEquals(
                    ""Wi-Fi RTT results: invalid result (wrong BSSID) entry on iteration "" + i,
                    result.getMacAddress().toString(), testAp.BSSID);

            assertNull(
                    ""Wi-Fi RTT results: invalid result (non-null PeerHandle) entry on iteration ""
                            + i, result.getPeerHandle());

            allResults.add(result);
            int status = result.getStatus();
            statuses[i] = status;
            if (status == RangingResult.STATUS_SUCCESS) {
                assertFalse(""Wi-Fi RTT results: should not be a 802.11MC measurement"",
                        result.is80211mcMeasurement());
                distanceSum += result.getDistanceMm();

                assertTrue(""Wi-Fi RTT results: invalid RSSI on iteration "" + i,
                        result.getRssi() >= MIN_VALID_RSSI);

                distanceMms[i - numFailures] = result.getDistanceMm();
                distanceStdDevMms[i - numFailures] = result.getDistanceStdDevMm();
                rssis[i - numFailures] = result.getRssi();
                // For one-sided RTT the number of packets attempted in a burst is not available,
                // So we set the result to be the same as used in the request.
                numAttempted[i - numFailures] = request.getRttBurstSize();
                numSuccessful[i - numFailures] = result.getNumSuccessfulMeasurements();
                timestampsMs[i - numFailures] = result.getRangingTimestampMillis();

                byte[] currentLci = result.getLci();
                byte[] currentLcr = result.getLcr();
                if (i - numFailures > 0) {
                    assertTrue(""Wi-Fi RTT results: invalid result (LCI mismatch) on iteration "" + i,
                            Arrays.equals(currentLci, lastLci));
                    assertTrue(""Wi-Fi RTT results: invalid result (LCR mismatch) on iteration "" + i,
                            Arrays.equals(currentLcr, lastLcr));
                }
                lastLci = currentLci;
                lastLcr = currentLcr;
            } else {
                numFailures++;
            }
            // Sleep a while to avoid stress AP.
            Thread.sleep(intervalMs);
        }
        // Save results to log
        int numGoodResults = NUM_OF_RTT_ITERATIONS - numFailures;
        DeviceReportLog reportLog = new DeviceReportLog(TAG, ""testRangingToTestAp"");
        reportLog.addValues(""status_codes"", statuses, ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""distance_mm"", Arrays.copyOf(distanceMms, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""distance_stddev_mm"",
                Arrays.copyOf(distanceStdDevMms, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""rssi_dbm"", Arrays.copyOf(rssis, numGoodResults),
                ResultType.NEUTRAL,
                ResultUnit.NONE);
        reportLog.addValues(""num_attempted"", Arrays.copyOf(numAttempted, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""num_successful"", Arrays.copyOf(numSuccessful, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.addValues(""timestamps"", Arrays.copyOf(timestampsMs, numGoodResults),
                ResultType.NEUTRAL, ResultUnit.NONE);
        reportLog.submit();

        /** TODO(b/192909380): enable the performance verification after device fix.
            // Analyze results
            assertTrue(""Wi-Fi RTT failure rate exceeds threshold: FAIL="" + numFailures
                            + "", ITERATIONS=""
                            + NUM_OF_RTT_ITERATIONS + "", AP RSSI="" + testAp.level
                            + "", AP SSID="" + testAp.SSID,
                    numFailures <= NUM_OF_RTT_ITERATIONS * MAX_NON11MC_FAILURE_RATE_PERCENT / 100);

            if (numFailures != NUM_OF_RTT_ITERATIONS) {
                // Calculate an initial average using all measurements to determine distance outliers
                double distanceAvg = (double) distanceSum / (NUM_OF_RTT_ITERATIONS - numFailures);
                // Now figure out the distance outliers and mark them in the distance inclusion map
                int validDistances = 0;
                for (int i = 0; i < (NUM_OF_RTT_ITERATIONS - numFailures); i++) {
                    if (distanceMms[i] - MAX_VARIATION_FROM_AVERAGE_DISTANCE_MM < distanceAvg) {
                        // Distances that are in range for the distribution are included in the map
                        distanceInclusionMap[i] = true;
                        validDistances++;
                    } else {
                        // Distances that are out of range for the distribution are excluded in the map
                        distanceInclusionMap[i] = false;
                    }
                }

                assertTrue(""After fails+outlier removal greater that 50% distances must remain: "" +
                        NUM_OF_RTT_ITERATIONS / 2, validDistances > NUM_OF_RTT_ITERATIONS / 2);

                // Remove the distance outliers and find the new average, min and max.
                distanceSum = 0;
                distanceMax = Integer.MIN_VALUE;
                distanceMin = Integer.MAX_VALUE;
                for (int i = 0; i < (NUM_OF_RTT_ITERATIONS - numFailures); i++) {
                    if (distanceInclusionMap[i]) {
                        distanceSum += distanceMms[i];
                        distanceMin = Math.min(distanceMin, distanceMms[i]);
                        distanceMax = Math.max(distanceMax, distanceMms[i]);
                    }
                }
                distanceAvg = (double) distanceSum / validDistances;
                assertTrue(""Wi-Fi RTT: Variation (max direction) exceeds threshold, Variation =""
                                + (distanceMax - distanceAvg),
                        (distanceMax - distanceAvg) <= MAX_VARIATION_FROM_AVERAGE_DISTANCE_MM);
                assertTrue(""Wi-Fi RTT: Variation (min direction) exceeds threshold, Variation =""
                                + (distanceAvg - distanceMin),
                        (distanceAvg - distanceMin) <= MAX_VARIATION_FROM_AVERAGE_DISTANCE_MM);
                for (int i = 0; i < numGoodResults; ++i) {
                    assertNotSame(""Number of attempted measurements is 0"", 0, numAttempted[i]);
                    assertNotSame(""Number of successful measurements is 0"", 0, numSuccessful[i]);
                }
         */
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"com.android.cts.verifier.wifi.testcase.NetworkSuggestionTestCase"	"isEmpty"	""	"/home/gpoor/cts-12-source/cts/apps/CtsVerifier/src/com/android/cts/verifier/wifi/testcase/NetworkSuggestionTestCase.java"	""	"public void test/*
 *.
 */

package com.android.cts.verifier.wifi.testcase;

import static android.net.NetworkCapabilities.NET_CAPABILITY_NOT_METERED;
import static android.net.NetworkCapabilities.TRANSPORT_WIFI;
import static android.net.wifi.WifiManager.STATUS_NETWORK_SUGGESTIONS_SUCCESS;

import static com.android.cts.verifier.wifi.TestUtils.SCAN_RESULT_TYPE_OPEN;
import static com.android.cts.verifier.wifi.TestUtils.SCAN_RESULT_TYPE_PSK;

import android.annotation.NonNull;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.ConnectivityManager;
import android.net.MacAddress;
import android.net.Network;
import android.net.NetworkRequest;
import android.net.wifi.ScanResult;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSuggestion;
import android.os.SystemClock;
import android.util.Log;
import android.util.Pair;

import androidx.core.os.BuildCompat;

import com.android.cts.verifier.R;
import com.android.cts.verifier.wifi.BaseTestCase;
import com.android.cts.verifier.wifi.CallbackUtils;
import com.android.cts.verifier.wifi.TestUtils;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

/**
 * Test cases for network suggestions {@link WifiNetworkSuggestion} added via
 * {@link WifiManager#addNetworkSuggestions(List)}.
 */
public class NetworkSuggestionTestCase extends BaseTestCase {
    private static final String TAG = ""NetworkSuggestionTestCase"";
    private static final boolean DBG = true;

    private static final int PERIODIC_SCAN_INTERVAL_MS = 10_000;
    private static final int CALLBACK_TIMEOUT_MS = 40_000;
    private static final int CAPABILITIES_CHANGED_FOR_METERED_TIMEOUT_MS = 80_000;

    private final Object mLock = new Object();
    private final ScheduledExecutorService mExecutorService;
    private final WifiNetworkSuggestion.Builder mNetworkSuggestionBuilder =
            new WifiNetworkSuggestion.Builder();

    private ConnectivityManager mConnectivityManager;
    private List<WifiNetworkSuggestion> mNetworkSuggestions;
    private NetworkRequest mNetworkRequest;
    private CallbackUtils.NetworkCallback mNetworkCallback;
    private ConnectionStatusListener mConnectionStatusListener;
    private UserApprovalStatusListener mUserApprovalStatusListener;
    private BroadcastReceiver mBroadcastReceiver;
    private String mFailureReason;
    private int mUserApprovedStatus = WifiManager.STATUS_SUGGESTION_APPROVAL_UNKNOWN;

    private final boolean mSetBssid;
    private final boolean mSetRequiresAppInteraction;
    private final boolean mSimulateConnectionFailure;
    private final boolean mSetMeteredPostConnection;

    public NetworkSuggestionTestCase(Context context, boolean setBssid,
            boolean setRequiresAppInteraction) {
        this(context, setBssid, setRequiresAppInteraction, false);
    }

    public NetworkSuggestionTestCase(Context context, boolean setBssid,
            boolean setRequiresAppInteraction, boolean simulateConnectionFailure) {
        this(context, setBssid, setRequiresAppInteraction, simulateConnectionFailure, false);
    }

    public NetworkSuggestionTestCase(Context context, boolean setBssid,
            boolean setRequiresAppInteraction, boolean simulateConnectionFailure,
            boolean setMeteredPostConnection) {
        super(context);
        mExecutorService = Executors.newSingleThreadScheduledExecutor();
        mSetBssid = setBssid;
        mSetRequiresAppInteraction = setRequiresAppInteraction;
        mSimulateConnectionFailure = simulateConnectionFailure;
        mSetMeteredPostConnection = setMeteredPostConnection;
    }

    // Create a network specifier based on the test type.
    private WifiNetworkSuggestion createNetworkSuggestion(@NonNull ScanResult scanResult) {
        mNetworkSuggestionBuilder.setSsid(scanResult.SSID);
        if (mSetBssid) {
            mNetworkSuggestionBuilder.setBssid(MacAddress.fromString(scanResult.BSSID));
        }
        if (mSetRequiresAppInteraction) {
            mNetworkSuggestionBuilder.setIsAppInteractionRequired(true);
        }
        if (mSimulateConnectionFailure) {
            // Use a random password to simulate connection failure.
            if (TestUtils.isScanResultForWpa2Network(scanResult)) {
                mNetworkSuggestionBuilder.setWpa2Passphrase(mTestUtils.generateRandomPassphrase());
            } else if (TestUtils.isScanResultForWpa3Network(scanResult)) {
                mNetworkSuggestionBuilder.setWpa3Passphrase(mTestUtils.generateRandomPassphrase());
            }
        } else if (!mPsk.isEmpty()) {
            if (TestUtils.isScanResultForWpa2Network(scanResult)) {
                mNetworkSuggestionBuilder.setWpa2Passphrase(mPsk);
            } else if (TestUtils.isScanResultForWpa3Network(scanResult)) {
                mNetworkSuggestionBuilder.setWpa3Passphrase(mPsk);
            }
        }
        mNetworkSuggestionBuilder.setIsMetered(false);
        return mNetworkSuggestionBuilder.build();
    }

    private void setFailureReason(String reason) {
        synchronized (mLock) {
            mFailureReason = reason;
        }
    }

    private static class ConnectionStatusListener implements
            WifiManager.SuggestionConnectionStatusListener {
        private final CountDownLatch mCountDownLatch;
        public WifiNetworkSuggestion wifiNetworkSuggestion = null;
        public int failureReason = -1;

        ConnectionStatusListener(CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }

        @Override
        public void onConnectionStatus(
                WifiNetworkSuggestion wifiNetworkSuggestion, int failureReason) {
            this.wifiNetworkSuggestion = wifiNetworkSuggestion;
            this.failureReason = failureReason;
            mCountDownLatch.countDown();
        }
    }

    private class UserApprovalStatusListener implements
            WifiManager.SuggestionUserApprovalStatusListener{
        private final CountDownLatch mCountDownLatch;

        UserApprovalStatusListener(CountDownLatch countDownLatch) {
            mCountDownLatch = countDownLatch;
        }
        @Override
        public void onUserApprovalStatusChange(int status) {
            mUserApprovedStatus = status;
            if (status == WifiManager.STATUS_SUGGESTION_APPROVAL_PENDING
                    || status == WifiManager.STATUS_SUGGESTION_APPROVAL_UNKNOWN) {
                return;
            }
            mCountDownLatch.countDown();
        }
    }

    // TODO(b/150890482): Capabilities changed callback can occur multiple times (for ex: RSSI
    // change) & the sufficiency checks may result in ths change taking longer to take effect.
    // This method accounts for both of these situations.
    private boolean waitForNetworkToBeMetered() throws InterruptedException {
        long startTimeMillis = SystemClock.elapsedRealtime();
        while (SystemClock.elapsedRealtime()
                < startTimeMillis + CAPABILITIES_CHANGED_FOR_METERED_TIMEOUT_MS) {
            // Network marked metered.
            if (!mNetworkCallback.getNetworkCapabilities()
                    .hasCapability(NET_CAPABILITY_NOT_METERED)) {
                return true;
            } else {
                Log.w(TAG, ""Network meteredness check failed. ""
                        + mNetworkCallback.getNetworkCapabilities());
            }
            // Wait for the suggestion to be marked metered now.
            if (!mNetworkCallback.waitForCapabilitiesChanged()) {
                Log.w(TAG, ""Network capabilities did not change"");
            }
        }
        return false;
    }

    @Override
    protected boolean executeTest() throws InterruptedException {
        if (mSimulateConnectionFailure && mPsk.isEmpty()) {
            setFailureReason(mContext.getString(R.string.wifi_status_need_psk));
            return false;
        }
        // Step: Scan and find the network around.
        if (DBG) Log.v(TAG, ""Scan and find the network: "" + mSsid);
        ScanResult testNetwork = mTestUtils.startScanAndFindAnyMatchingNetworkInResults(
                mSsid, mPsk.isEmpty() ? SCAN_RESULT_TYPE_OPEN : SCAN_RESULT_TYPE_PSK);
        if (testNetwork == null) {
            setFailureReason(mContext.getString(R.string.wifi_status_scan_failure));
            return false;
        }

        // Step (Optional): Register for the post connection broadcast.
        final CountDownLatch countDownLatchForPostConnectionBcast = new CountDownLatch(1);
        IntentFilter intentFilter =
                new IntentFilter(WifiManager.ACTION_WIFI_NETWORK_SUGGESTION_POST_CONNECTION);
        // Post connection broadcast receiver.
        mBroadcastReceiver = new BroadcastReceiver() {
            @Override
            public void onReceive(Context context, Intent intent) {
                if (DBG) Log.v(TAG, ""Broadcast onReceive "" + intent);
                if (!intent.getAction().equals(
                        WifiManager.ACTION_WIFI_NETWORK_SUGGESTION_POST_CONNECTION)) {
                    return;
                }
                if (DBG) Log.v(TAG, ""Post connection broadcast received"");
                countDownLatchForPostConnectionBcast.countDown();
            }
        };
        // Register the receiver for post connection broadcast.
        mContext.registerReceiver(mBroadcastReceiver, intentFilter);
        final CountDownLatch countDownLatchForConnectionStatusListener = new CountDownLatch(1);
        mConnectionStatusListener =
                new ConnectionStatusListener(countDownLatchForConnectionStatusListener);
        mWifiManager.addSuggestionConnectionStatusListener(
                Executors.newSingleThreadExecutor(), mConnectionStatusListener);

        final CountDownLatch userApprovalCountDownLatch = new CountDownLatch(1);
        if (BuildCompat.isAtLeastS()) {
            mUserApprovalStatusListener = new UserApprovalStatusListener(
                    userApprovalCountDownLatch);
            mWifiManager.addSuggestionUserApprovalStatusListener(
                    Executors.newSingleThreadExecutor(), mUserApprovalStatusListener);

        }

        // Step: Register network callback to wait for connection state.
        mNetworkRequest = new NetworkRequest.Builder()
                .addTransportType(TRANSPORT_WIFI)
                .build();
        mNetworkCallback = new CallbackUtils.NetworkCallback(CALLBACK_TIMEOUT_MS);
        mConnectivityManager.registerNetworkCallback(mNetworkRequest, mNetworkCallback);

        // Step: Create a suggestion for the chosen open network depending on the type of test.
        WifiNetworkSuggestion networkSuggestion = createNetworkSuggestion(testNetwork);
        mNetworkSuggestions = Arrays.asList(networkSuggestion);

        // Step: Add a network suggestions.
        if (DBG) Log.v(TAG, ""Adding suggestion"");
        mListener.onTestMsgReceived(mContext.getString(R.string.wifi_status_suggestion_add));
        if (mWifiManager.addNetworkSuggestions(mNetworkSuggestions)
                != STATUS_NETWORK_SUGGESTIONS_SUCCESS) {
            setFailureReason(mContext.getString(R.string.wifi_status_suggestion_add_failure));
            return false;
        }
        // Step: Ask user to approval the suggestion.
        if (BuildCompat.isAtLeastS()) {
            if (mUserApprovedStatus != WifiManager.STATUS_SUGGESTION_APPROVAL_APPROVED_BY_USER) {
                mListener.onTestMsgReceived(mContext.getString(
                        R.string.wifi_status_suggestion_wait_for_user_approval));
            }
            if (!userApprovalCountDownLatch.await(CALLBACK_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
                setFailureReason(mContext.getString(
                        R.string.wifi_status_suggestion_user_approval_status_failure));
                return false;
            }
            if (mUserApprovedStatus != WifiManager.STATUS_SUGGESTION_APPROVAL_APPROVED_BY_USER) {
                setFailureReason(mContext.getString(
                        R.string.wifi_status_suggestion_user_approve_failure));
                return false;
            }
        } else {
            mListener.onTestMsgReceived(mContext.getString(
                    R.string.wifi_status_suggestion_wait_for_user_approval));
        }

        if (DBG) Log.v(TAG, ""Getting suggestion"");
        List<WifiNetworkSuggestion> retrievedSuggestions = mWifiManager.getNetworkSuggestions();
        if (!Objects.equals(mNetworkSuggestions, retrievedSuggestions)) {
            setFailureReason(mContext.getString(R.string.wifi_status_suggestion_get_failure));
            return false;
        }

        // Step: Trigger scans periodically to trigger network selection quicker.
        if (DBG) Log.v(TAG, ""Triggering scan periodically"");
        mExecutorService.scheduleAtFixedRate(() -> {
            if (!mWifiManager.startScan()) {
                Log.w(TAG, ""Failed to trigger scan"");
            }
        }, 0, PERIODIC_SCAN_INTERVAL_MS, TimeUnit.MILLISECONDS);

        // Step: Wait for connection/unavailable.
        if (!mSimulateConnectionFailure) {
            if (DBG) Log.v(TAG, ""Waiting for connection"");
            mListener.onTestMsgReceived(mContext.getString(
                    R.string.wifi_status_suggestion_wait_for_connect));
            Pair<Boolean, Network> cbStatusForAvailable = mNetworkCallback.waitForAvailable();
            if (!cbStatusForAvailable.first) {
                Log.e(TAG, ""Failed to get network available callback"");
                setFailureReason(mContext.getString(R.string.wifi_status_network_cb_timeout));
                return false;
            }
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_suggestion_connect));
        } else {
            if (DBG) Log.v(TAG, ""Ensure no connection"");
            mListener.onTestMsgReceived(mContext.getString(
                    R.string.wifi_status_suggestion_ensure_no_connect));
            Pair<Boolean, Network> cbStatusForAvailable = mNetworkCallback.waitForAvailable();
            if (cbStatusForAvailable.first) {
                Log.e(TAG, ""Unexpectedly got network available callback"");
                setFailureReason(mContext.getString(R.string.wifi_status_network_available_error));
                return false;
            }
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_suggestion_not_connected));
        }

        // Step: Ensure that we connected to the suggested network (optionally, the correct BSSID).
        if (!mSimulateConnectionFailure) {
            if (!mTestUtils.isConnected(""\"""" + testNetwork.SSID + ""\"""",
                    // TODO: This might fail if there are other BSSID's for the same network & the
                    //  device decided to connect/roam to a different BSSID. We don't turn off
                    //  roaming for suggestions.
                    mSetBssid ? testNetwork.BSSID : null)) {
                Log.e(TAG, ""Failed to connected to the network"");
                setFailureReason(
                        mContext.getString(R.string.wifi_status_connected_to_other_network));
                return false;
            }
        }

        // Step (Optional): Ensure we received the post connect broadcast.
        if (mSetRequiresAppInteraction) {
            if (DBG) Log.v(TAG, ""Wait for post connection broadcast"");
            mListener.onTestMsgReceived(
                    mContext.getString(
                            R.string.wifi_status_suggestion_wait_for_post_connect_bcast));
            if (!countDownLatchForPostConnectionBcast.await(
                    CALLBACK_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
                Log.e(TAG, ""Failed to get post connection broadcast"");
                setFailureReason(mContext.getString(
                        R.string.wifi_status_suggestion_post_connect_bcast_failure));
                return false;
            }
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_suggestion_post_connect_bcast));
        }
        // Step (Optional): Ensure we received the connection status listener.
        if (mSimulateConnectionFailure) {
            if (DBG) Log.v(TAG, ""Wait for connection status listener"");
            mListener.onTestMsgReceived(
                    mContext.getString(
                            R.string.wifi_status_suggestion_wait_for_connection_status));
            if (!countDownLatchForConnectionStatusListener.await(
                    CALLBACK_TIMEOUT_MS, TimeUnit.MILLISECONDS)) {
                Log.e(TAG, ""Failed to receive connection status"");
                setFailureReason(mContext.getString(
                        R.string.wifi_status_suggestion_connection_status_failure));
                return false;
            }
            if (DBG) Log.v(TAG, ""Received connection status"");
            if (!Objects.equals(mConnectionStatusListener.wifiNetworkSuggestion, networkSuggestion)
                    || mConnectionStatusListener.failureReason
                    != WifiManager.STATUS_SUGGESTION_CONNECTION_FAILURE_AUTHENTICATION) {
                Log.e(TAG, ""Received wrong connection status for ""
                        + mConnectionStatusListener.wifiNetworkSuggestion
                        + "" with reason: "" + mConnectionStatusListener.failureReason);
                setFailureReason(mContext.getString(
                        R.string.wifi_status_suggestion_connection_status_failure));
                return false;
            }
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_suggestion_connection_status));
        }

        if (mSetMeteredPostConnection) {
            // ensure that the network is not metered before change.
            if (!mNetworkCallback.getNetworkCapabilities()
                    .hasCapability(NET_CAPABILITY_NOT_METERED)) {
                Log.e(TAG, ""Network meteredness check failed ""
                        + mNetworkCallback.getNetworkCapabilities());
                setFailureReason(mContext.getString(
                        R.string.wifi_status_suggestion_metered_check_failed));
                return false;
            }
            if (DBG) Log.v(TAG, ""Mark suggestion metered after connection"");
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_suggestion_metered_change));
            WifiNetworkSuggestion modifiedSuggestion = mNetworkSuggestionBuilder
                    .setIsMetered(true)
                    .build();
            if (mWifiManager.addNetworkSuggestions(Arrays.asList(modifiedSuggestion))
                    != STATUS_NETWORK_SUGGESTIONS_SUCCESS) {
                setFailureReason(mContext.getString(R.string.wifi_status_suggestion_add_failure));
                return false;
            }
            if (!waitForNetworkToBeMetered()) {
                Log.e(TAG, ""Network was not marked metered"");
                setFailureReason(mContext.getString(
                        R.string.wifi_status_suggestion_metered_check_failed));
                return false;
            }
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_suggestion_metered_changed));
        }

        // Step: Remove the suggestions from the app.
        if (DBG) Log.v(TAG, ""Removing suggestion"");
        mListener.onTestMsgReceived(mContext.getString(R.string.wifi_status_suggestion_remove));
        if (mWifiManager.removeNetworkSuggestions(mNetworkSuggestions)
                != STATUS_NETWORK_SUGGESTIONS_SUCCESS) {
            setFailureReason(mContext.getString(R.string.wifi_status_suggestion_remove_failure));
            return false;
        }

        // Step: Ensure we disconnect immediately on suggestion removal.
        if (!mSimulateConnectionFailure) {
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_suggestion_wait_for_disconnect));
            if (DBG) Log.v(TAG, ""Ensuring we disconnect immediately"");
            boolean cbStatusForLost = mNetworkCallback.waitForLost();
            if (!cbStatusForLost) {
                setFailureReason(
                        mContext.getString(R.string.wifi_status_suggestion_not_disconnected));
                return false;
            }
            mListener.onTestMsgReceived(
                    mContext.getString(R.string.wifi_status_suggestion_disconnected));
        }

        // All done!
        return true;
    }

    @Override
    protected String getFailureReason() {
        synchronized (mLock) {
            return mFailureReason;
        }
    }

    @Override
    protected void setUp() {
        super.setUp();
        mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);
    }

    @Override
    protected void tearDown() {
        mExecutorService.shutdownNow();
        if (mBroadcastReceiver != null) {
            mContext.unregisterReceiver(mBroadcastReceiver);
        }
        if (mConnectionStatusListener != null) {
            mWifiManager.removeSuggestionConnectionStatusListener(mConnectionStatusListener);
        }
        mWifiManager.removeNetworkSuggestions(new ArrayList<>());
        super.tearDown();
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"isNotNull"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.Manifest.permission.ACCESS_BACKGROUND_LOCATION;
import static android.Manifest.permission.ACCESS_FINE_LOCATION;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeTrue;

import android.content.ComponentName;
import android.content.Context;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.SdkSuppress;
import androidx.test.filters.SmallTest;
import androidx.test.platform.app.InstrumentationRegistry;
import androidx.test.rule.ActivityTestRule;

import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;
import com.android.compatibility.common.util.SystemUtil;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;

/**
 * Tests location sensitive APIs exposed by Wi-Fi.
 * Ensures that permissions on these APIs are properly enforced.
 */
@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@SmallTest
@RunWith(AndroidJUnit4.class)
public class WifiLocationInfoTest extends WifiJUnit4TestBase {
    private static final String TAG = ""WifiLocationInfoTest"";

    private static final String WIFI_LOCATION_TEST_APP_APK_PATH =
            ""/data/local/tmp/cts/wifi/CtsWifiLocationTestApp.apk"";
    private static final String WIFI_LOCATION_TEST_APP_PACKAGE_NAME =
            ""android.net.wifi.cts.app"";
    private static final String WIFI_LOCATION_TEST_APP_TRIGGER_SCAN_ACTIVITY =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".TriggerScanAndReturnStatusActivity"";
    private static final String WIFI_LOCATION_TEST_APP_TRIGGER_SCAN_SERVICE =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".TriggerScanAndReturnStatusService"";
    private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_SCAN_RESULTS_ACTIVITY =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveScanResultsAndReturnStatusActivity"";
    private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_SCAN_RESULTS_SERVICE =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveScanResultsAndReturnStatusService"";
    private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_CONNECTION_INFO_ACTIVITY =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveConnectionInfoAndReturnStatusActivity"";
    private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_CONNECTION_INFO_SERVICE =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveConnectionInfoAndReturnStatusService"";
    private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_TRANSPORT_INFO_ACTIVITY =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveTransportInfoAndReturnStatusActivity"";
    private static final String WIFI_LOCATION_TEST_APP_RETRIEVE_TRANSPORT_INFO_SERVICE =
            WIFI_LOCATION_TEST_APP_PACKAGE_NAME + "".RetrieveTransportInfoAndReturnStatusService"";

    private static final int DURATION_MS = 10_000;
    private static final int WIFI_CONNECT_TIMEOUT_MILLIS = 30_000;

    @Rule
    public final ActivityTestRule<WaitForResultActivity> mActivityRule =
            new ActivityTestRule<>(WaitForResultActivity.class);

    private Context mContext;
    private WifiManager mWifiManager;
    private boolean mWasVerboseLoggingEnabled;
    private boolean mWasScanThrottleEnabled;

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getContext();
        // skip the test if WiFi is not supported
        assumeTrue(WifiFeature.isWifiSupported(mContext));

        mWifiManager = mContext.getSystemService(WifiManager.class);
        assertThat(mWifiManager).isNotNull();

        installApp(WIFI_LOCATION_TEST_APP_APK_PATH);

        // turn on verbose logging for tests
        mWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        mWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(false));

        // enable Wifi
        if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);
        PollingCheck.check(""Wifi not enabled"", DURATION_MS, () -> mWifiManager.isWifiEnabled());

        // check we have >= 1 saved network
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.getConfiguredNetworks());
        assertWithMessage(""Need at least one saved network"").that(savedNetworks).isNotEmpty();

        // ensure Wifi is connected
        ShellIdentityUtils.invokeWithShellPermissions(() -> mWifiManager.reconnect());
        PollingCheck.check(
                ""Wifi not connected"",
                WIFI_CONNECT_TIMEOUT_MILLIS,
                () -> mWifiManager.getConnectionInfo().getNetworkId() != -1);
    }

    @After
    public void tearDown() throws Exception {
        if (!WifiFeature.isWifiSupported(mContext)) return;

        uninstallApp(WIFI_LOCATION_TEST_APP_PACKAGE_NAME);

        if (!mWifiManager.isWifiEnabled()) setWifiEnabled(true);
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setScanThrottleEnabled(mWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.setVerboseLoggingEnabled(mWasVerboseLoggingEnabled));
    }

    private void setWifiEnabled(boolean enable) throws Exception {
        // now trigger the change using shell commands.
        SystemUtil.runShellCommand(""svc wifi "" + (enable ? ""enable"" : ""disable""));
    }

    private void turnScreenOn() throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().executeShellCommand(
                ""input keyevent KEYCODE_WAKEUP"");
        InstrumentationRegistry.getInstrumentation().getUiAutomation().executeShellCommand(""""
                + ""wm dismiss-keyguard"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(2_000);
    }

    private void turnScreenOff() throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().executeShellCommand(
                ""input keyevent KEYCODE_SLEEP"");
        // Since the screen on/off intent is ordered, they will not be sent right now.
        Thread.sleep(2_000);
    }

    private void installApp(String apk) throws InterruptedException {
        String installResult = SystemUtil.runShellCommand(""pm install -r -d "" + apk);
        Thread.sleep(10_000);
        assertThat(installResult.trim()).isEqualTo(""Success"");
    }

    private void uninstallApp(String pkg) throws InterruptedException {
        String uninstallResult = SystemUtil.runShellCommand(
                ""pm uninstall "" + pkg);
        Thread.sleep(10_000);
        assertThat(uninstallResult.trim()).isEqualTo(""Success"");
    }

    private void startFgActivityAndAssertStatusIs(
            ComponentName componentName, boolean status) throws Exception {
        turnScreenOn();

        WaitForResultActivity activity = mActivityRule.getActivity();
        activity.startActivityToWaitForResult(componentName);
        assertThat(activity.waitForActivityResult(DURATION_MS)).isEqualTo(status);
    }

    private void startBgServiceAndAssertStatusIs(
            ComponentName componentName, boolean status) throws Exception {
        turnScreenOff();

        WaitForResultActivity activity = mActivityRule.getActivity();
        activity.startServiceToWaitForResult(componentName);
        assertThat(activity.waitForServiceResult(DURATION_MS)).isEqualTo(status);
    }

    private void triggerScanFgActivityAndAssertStatusIs(boolean status) throws Exception {
        startFgActivityAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_TRIGGER_SCAN_ACTIVITY), status);
    }

    private void triggerScanBgServiceAndAssertStatusIs(boolean status) throws Exception {
        startBgServiceAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_TRIGGER_SCAN_SERVICE), status);
    }

    private void retrieveScanResultsFgActivityAndAssertStatusIs(boolean status) throws Exception {
        startFgActivityAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_RETRIEVE_SCAN_RESULTS_ACTIVITY), status);
    }

    private void retrieveScanResultsBgServiceAndAssertStatusIs(boolean status) throws Exception {
        startBgServiceAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_RETRIEVE_SCAN_RESULTS_SERVICE), status);
    }

    private void retrieveConnectionInfoFgActivityAndAssertStatusIs(boolean status)
            throws Exception {
        startFgActivityAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_RETRIEVE_CONNECTION_INFO_ACTIVITY), status);
    }

    private void retrieveConnectionInfoBgServiceAndAssertStatusIs(boolean status) throws Exception {
        startBgServiceAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_RETRIEVE_CONNECTION_INFO_SERVICE), status);
    }

    private void retrieveTransportInfoFgActivityAndAssertStatusIs(boolean status)
            throws Exception {
        startFgActivityAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_RETRIEVE_TRANSPORT_INFO_ACTIVITY), status);
    }

    private void retrieveTransportInfoBgServiceAndAssertStatusIs(boolean status) throws Exception {
        startBgServiceAndAssertStatusIs(new ComponentName(WIFI_LOCATION_TEST_APP_PACKAGE_NAME,
                WIFI_LOCATION_TEST_APP_RETRIEVE_TRANSPORT_INFO_SERVICE), status);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanTriggerNotAllowedForForegroundActivityWithNoLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void testScanTriggerNotAllowedForForegroundActivityWithNoLocationPermission()
            throws Exception {
        triggerScanFgActivityAndAssertStatusIs(false);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanTriggerAllowedForForegroundActivityWithFineLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void testScanTriggerAllowedForForegroundActivityWithFineLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        triggerScanFgActivityAndAssertStatusIs(true);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanTriggerAllowedForBackgroundServiceWithBackgroundLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void testScanTriggerAllowedForBackgroundServiceWithBackgroundLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_BACKGROUND_LOCATION);
        triggerScanBgServiceAndAssertStatusIs(true);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanTriggerNotAllowedForBackgroundServiceWithFineLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void testScanTriggerNotAllowedForBackgroundServiceWithFineLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        triggerScanBgServiceAndAssertStatusIs(false);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanResultsRetrievalNotAllowedForForegroundActivityWithNoLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void testScanResultsRetrievalNotAllowedForForegroundActivityWithNoLocationPermission()
            throws Exception {
        retrieveScanResultsFgActivityAndAssertStatusIs(false);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanResultsRetrievalAllowedForForegroundActivityWithFineLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void testScanResultsRetrievalAllowedForForegroundActivityWithFineLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        retrieveScanResultsFgActivityAndAssertStatusIs(true);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanResultsRetrievalAllowedForBackgroundServiceWithBackgroundLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void testScanResultsRetrievalAllowedForBackgroundServiceWithBackgroundLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_BACKGROUND_LOCATION);
        retrieveScanResultsBgServiceAndAssertStatusIs(true);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiLocationInfoTest"	"testScanResultsRetrievalNotAllowedForBackgroundServiceWithFineLocationPermission"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiLocationInfoTest.java"	""	"public void testScanResultsRetrievalNotAllowedForBackgroundServiceWithFineLocationPermission()
            throws Exception {
        InstrumentationRegistry.getInstrumentation().getUiAutomation().grantRuntimePermission(
                WIFI_LOCATION_TEST_APP_PACKAGE_NAME, ACCESS_FINE_LOCATION);
        retrieveScanResultsBgServiceAndAssertStatusIs(false);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSpecifierTest"	"isNotNull"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSpecifierTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeTrue;

import android.annotation.NonNull;
import android.content.Context;
import android.net.ConnectivityManager;
import android.net.ConnectivityManager.NetworkCallback;
import android.net.MacAddress;
import android.net.Network;
import android.net.NetworkCapabilities;
import android.net.NetworkRequest;
import android.net.NetworkSpecifier;
import android.net.wifi.ScanResult;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiEnterpriseConfig;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSpecifier;
import android.os.Build;
import android.os.PatternMatcher;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;
import android.util.Pair;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.LargeTest;
import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.ApiLevelUtil;
import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.List;
import java.util.ArrayList;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

/**
 * Tests the entire connection flow using {@link WifiNetworkSpecifier} embedded in a
 * {@link NetworkRequest} & passed into {@link ConnectivityManager#requestNetwork(NetworkRequest,
 * ConnectivityManager.NetworkCallback)}.
 *
 * Assumes that all the saved networks is either open/WPA1/WPA2/WPA3 authenticated network.
 */
@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@LargeTest
@RunWith(AndroidJUnit4.class)
public class WifiNetworkSpecifierTest extends WifiJUnit4TestBase {
    private static final String TAG = ""WifiNetworkSpecifierTest"";

    private static final String CA_SUITE_B_ECDSA_CERT_STRING =
            ""-----BEGIN CERTIFICATE-----\n""
                    + ""MIICTzCCAdSgAwIBAgIUdnLttwNPnQzFufplGOr9bTrGCqMwCgYIKoZIzj0EAwMw\n""
                    + ""XjELMAkGA1UEBhMCVVMxCzAJBgNVBAgMAkNBMQwwCgYDVQQHDANNVFYxEDAOBgNV\n""
                    + ""BAoMB0FuZHJvaWQxDjAMBgNVBAsMBVdpLUZpMRIwEAYDVQQDDAl1bml0ZXN0Q0Ew\n""
                    + ""HhcNMjAwNzIxMDIyNDA1WhcNMzAwNTMwMDIyNDA1WjBeMQswCQYDVQQGEwJVUzEL\n""
                    + ""MAkGA1UECAwCQ0ExDDAKBgNVBAcMA01UVjEQMA4GA1UECgwHQW5kcm9pZDEOMAwG\n""
                    + ""A1UECwwFV2ktRmkxEjAQBgNVBAMMCXVuaXRlc3RDQTB2MBAGByqGSM49AgEGBSuB\n""
                    + ""BAAiA2IABFmntXwk9icqhDQFUP1xy04WyEpaGW4q6Q+8pujlSl/X3iotPZ++GZfp\n""
                    + ""Mfv3YDHDBl6sELPQ2BEjyPXmpsKjOUdiUe69e88oGEdeqT2xXiQ6uzpTfJD4170i\n""
                    + ""O/TwLrQGKKNTMFEwHQYDVR0OBBYEFCjptsX3g4g5W0L4oEP6N3gfyiZXMB8GA1Ud\n""
                    + ""IwQYMBaAFCjptsX3g4g5W0L4oEP6N3gfyiZXMA8GA1UdEwEB/wQFMAMBAf8wCgYI\n""
                    + ""KoZIzj0EAwMDaQAwZgIxAK61brUYRbLmQKiaEboZgrHtnPAcGo7Yzx3MwHecx3Dm\n""
                    + ""5soIeLVYc8bPYN1pbhXW1gIxALdEe2sh03nBHyQH4adYoZungoCwt8mp/7sJFxou\n""
                    + ""9UnRegyBgGzf74ROWdpZHzh+Pg==\n""
                    + ""-----END CERTIFICATE-----\n"";
    public static final X509Certificate CA_SUITE_B_ECDSA_CERT =
            loadCertificate(CA_SUITE_B_ECDSA_CERT_STRING);

    private static final String CLIENT_SUITE_B_ECDSA_CERT_STRING =
            ""-----BEGIN CERTIFICATE-----\n""
                    + ""MIIB9zCCAX4CFDpfSZh3AH07BEfGWuMDa7Ynz6y+MAoGCCqGSM49BAMDMF4xCzAJ\n""
                    + ""BgNVBAYTAlVTMQswCQYDVQQIDAJDQTEMMAoGA1UEBwwDTVRWMRAwDgYDVQQKDAdB\n""
                    + ""bmRyb2lkMQ4wDAYDVQQLDAVXaS1GaTESMBAGA1UEAwwJdW5pdGVzdENBMB4XDTIw\n""
                    + ""MDcyMTAyMjk1MFoXDTMwMDUzMDAyMjk1MFowYjELMAkGA1UEBhMCVVMxCzAJBgNV\n""
                    + ""BAgMAkNBMQwwCgYDVQQHDANNVFYxEDAOBgNVBAoMB0FuZHJvaWQxDjAMBgNVBAsM\n""
                    + ""BVdpLUZpMRYwFAYDVQQDDA11bml0ZXN0Q2xpZW50MHYwEAYHKoZIzj0CAQYFK4EE\n""
                    + ""ACIDYgAEhxhVJ7dcSqrto0X+dgRxtd8BWG8cWmPjBji3MIxDLfpcMDoIB84ae1Ew\n""
                    + ""gJn4YUYHrWsUDiVNihv8j7a/Ol1qcIY2ybH7tbezefLmagqA4vXEUXZXoUyL4ZNC\n""
                    + ""DWcdw6LrMAoGCCqGSM49BAMDA2cAMGQCMH4aP73HrriRUJRguiuRic+X4Cqj/7YQ\n""
                    + ""ueJmP87KF92/thhoQ9OrRo8uJITPmNDswwIwP2Q1AZCSL4BI9dYrqu07Ar+pSkXE\n""
                    + ""R7oOqGdZR+d/MvXcFSrbIaLKEoHXmQamIHLe\n""
                    + ""-----END CERTIFICATE-----\n"";
    public static final X509Certificate CLIENT_SUITE_B_ECDSA_CERT =
            loadCertificate(CLIENT_SUITE_B_ECDSA_CERT_STRING);

    private static final byte[] CLIENT_SUITE_B_ECC_KEY_DATA = new byte[]{
            (byte) 0x30, (byte) 0x81, (byte) 0xb6, (byte) 0x02, (byte) 0x01, (byte) 0x00,
            (byte) 0x30, (byte) 0x10, (byte) 0x06, (byte) 0x07, (byte) 0x2a, (byte) 0x86,
            (byte) 0x48, (byte) 0xce, (byte) 0x3d, (byte) 0x02, (byte) 0x01, (byte) 0x06,
            (byte) 0x05, (byte) 0x2b, (byte) 0x81, (byte) 0x04, (byte) 0x00, (byte) 0x22,
            (byte) 0x04, (byte) 0x81, (byte) 0x9e, (byte) 0x30, (byte) 0x81, (byte) 0x9b,
            (byte) 0x02, (byte) 0x01, (byte) 0x01, (byte) 0x04, (byte) 0x30, (byte) 0xea,
            (byte) 0x6c, (byte) 0x4b, (byte) 0x6d, (byte) 0x43, (byte) 0xf9, (byte) 0x6c,
            (byte) 0x91, (byte) 0xdc, (byte) 0x2d, (byte) 0x6e, (byte) 0x87, (byte) 0x4f,
            (byte) 0x0a, (byte) 0x0b, (byte) 0x97, (byte) 0x25, (byte) 0x1c, (byte) 0x79,
            (byte) 0xa2, (byte) 0x07, (byte) 0xdc, (byte) 0x94, (byte) 0xc2, (byte) 0xee,
            (byte) 0x64, (byte) 0x51, (byte) 0x6d, (byte) 0x4e, (byte) 0x35, (byte) 0x1c,
            (byte) 0x22, (byte) 0x2f, (byte) 0xc0, (byte) 0xea, (byte) 0x09, (byte) 0x47,
            (byte) 0x3e, (byte) 0xb9, (byte) 0xb6, (byte) 0xb8, (byte) 0x83, (byte) 0x9e,
            (byte) 0xed, (byte) 0x59, (byte) 0xe5, (byte) 0xe7, (byte) 0x0f, (byte) 0xa1,
            (byte) 0x64, (byte) 0x03, (byte) 0x62, (byte) 0x00, (byte) 0x04, (byte) 0x87,
            (byte) 0x18, (byte) 0x55, (byte) 0x27, (byte) 0xb7, (byte) 0x5c, (byte) 0x4a,
            (byte) 0xaa, (byte) 0xed, (byte) 0xa3, (byte) 0x45, (byte) 0xfe, (byte) 0x76,
            (byte) 0x04, (byte) 0x71, (byte) 0xb5, (byte) 0xdf, (byte) 0x01, (byte) 0x58,
            (byte) 0x6f, (byte) 0x1c, (byte) 0x5a, (byte) 0x63, (byte) 0xe3, (byte) 0x06,
            (byte) 0x38, (byte) 0xb7, (byte) 0x30, (byte) 0x8c, (byte) 0x43, (byte) 0x2d,
            (byte) 0xfa, (byte) 0x5c, (byte) 0x30, (byte) 0x3a, (byte) 0x08, (byte) 0x07,
            (byte) 0xce, (byte) 0x1a, (byte) 0x7b, (byte) 0x51, (byte) 0x30, (byte) 0x80,
            (byte) 0x99, (byte) 0xf8, (byte) 0x61, (byte) 0x46, (byte) 0x07, (byte) 0xad,
            (byte) 0x6b, (byte) 0x14, (byte) 0x0e, (byte) 0x25, (byte) 0x4d, (byte) 0x8a,
            (byte) 0x1b, (byte) 0xfc, (byte) 0x8f, (byte) 0xb6, (byte) 0xbf, (byte) 0x3a,
            (byte) 0x5d, (byte) 0x6a, (byte) 0x70, (byte) 0x86, (byte) 0x36, (byte) 0xc9,
            (byte) 0xb1, (byte) 0xfb, (byte) 0xb5, (byte) 0xb7, (byte) 0xb3, (byte) 0x79,
            (byte) 0xf2, (byte) 0xe6, (byte) 0x6a, (byte) 0x0a, (byte) 0x80, (byte) 0xe2,
            (byte) 0xf5, (byte) 0xc4, (byte) 0x51, (byte) 0x76, (byte) 0x57, (byte) 0xa1,
            (byte) 0x4c, (byte) 0x8b, (byte) 0xe1, (byte) 0x93, (byte) 0x42, (byte) 0x0d,
            (byte) 0x67, (byte) 0x1d, (byte) 0xc3, (byte) 0xa2, (byte) 0xeb
    };
    public static final PrivateKey CLIENT_SUITE_B_ECC_KEY =
            loadPrivateKey(""EC"", CLIENT_SUITE_B_ECC_KEY_DATA);

    private static X509Certificate loadCertificate(String blob) {
        try {
            final CertificateFactory certFactory = CertificateFactory.getInstance(""X.509"");
            InputStream stream = new ByteArrayInputStream(blob.getBytes(StandardCharsets.UTF_8));

            return (X509Certificate) certFactory.generateCertificate(stream);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    private static PrivateKey loadPrivateKey(String algorithm, byte[] fakeKey) {
        try {
            KeyFactory kf = KeyFactory.getInstance(algorithm);
            return kf.generatePrivate(new PKCS8EncodedKeySpec(fakeKey));
        } catch (InvalidKeySpecException | NoSuchAlgorithmException e) {
            return null;
        }
    }

    private static boolean sWasVerboseLoggingEnabled;
    private static boolean sWasScanThrottleEnabled;
    private static WifiConfiguration sTestNetwork;

    private Context mContext;
    private WifiManager mWifiManager;
    private ConnectivityManager mConnectivityManager;
    private UiDevice mUiDevice;
    private ConnectivityManager.NetworkCallback mNrNetworkCallback;
    private TestHelper mTestHelper;

    private static final int DURATION = 10_000;

    @BeforeClass
    public static void setUpClass() throws Exception {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        // skip the test if WiFi is not supported
        if (!WifiFeature.isWifiSupported(context)) return;

        WifiManager wifiManager = context.getSystemService(WifiManager.class);
        assertThat(wifiManager).isNotNull();

        // turn on verbose logging for tests
        sWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        sWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setScanThrottleEnabled(false));

        // enable Wifi
        if (!wifiManager.isWifiEnabled()) {
            ShellIdentityUtils.invokeWithShellPermissions(() -> wifiManager.setWifiEnabled(true));
        }
        PollingCheck.check(""Wifi not enabled"", DURATION, () -> wifiManager.isWifiEnabled());

        // check we have >= 1 saved network
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.getPrivilegedConfiguredNetworks());
        assertWithMessage(""Need at least one saved network"")
                .that(savedNetworks.isEmpty()).isFalse();

        // Pick any network in range.
        sTestNetwork = TestHelper.findMatchingSavedNetworksWithBssid(wifiManager, savedNetworks)
                .get(0);
    }

    private static void enableAllSavedNetworks(@NonNull WifiManager wifiManager) {
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : wifiManager.getConfiguredNetworks()) {
                        wifiManager.enableNetwork(savedNetwork.networkId, false);
                    }
                });
    }

    private static void disableAllSavedNetworks(@NonNull WifiManager wifiManager) {
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : wifiManager.getConfiguredNetworks()) {
                        wifiManager.disableNetwork(savedNetwork.networkId);
                    }
                });
    }

    @AfterClass
    public static void tearDownClass() throws Exception {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        if (!WifiFeature.isWifiSupported(context)) return;

        WifiManager wifiManager = context.getSystemService(WifiManager.class);
        assertThat(wifiManager).isNotNull();

        if (!wifiManager.isWifiEnabled()) {
            ShellIdentityUtils.invokeWithShellPermissions(() -> wifiManager.setWifiEnabled(true));
        }

        // Re-enable networks.
        enableAllSavedNetworks(wifiManager);

        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setScanThrottleEnabled(sWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setVerboseLoggingEnabled(sWasVerboseLoggingEnabled));
    }

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getContext();
        mWifiManager = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);
        mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);
        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        mTestHelper = new TestHelper(mContext, mUiDevice);

        assumeTrue(WifiFeature.isWifiSupported(mContext));

        // turn screen on
        mTestHelper.turnScreenOn();

        // Clear any existing app state before each test.
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            ShellIdentityUtils.invokeWithShellPermissions(
                    () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));
        }

        // Disconnect & disable auto-join on the saved network to prevent auto-connect from
        // interfering with the test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.allowAutojoinGlobal(false));
        disableAllSavedNetworks(mWifiManager);
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.allowAutojoinGlobal(true));

        // Wait for Wifi to be disconnected.
        PollingCheck.check(
                ""Wifi not disconnected"",
                20000,
                () -> mWifiManager.getConnectionInfo().getNetworkId() == -1);
    }

    @After
    public void tearDown() throws Exception {
        // If there is failure, ensure we unregister the previous request.
        if (mNrNetworkCallback != null) {
            mConnectivityManager.unregisterNetworkCallback(mNrNetworkCallback);
        }
        // Clear any existing app state after each test.
        if (WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            ShellIdentityUtils.invokeWithShellPermissions(
                    () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));
        }
        mTestHelper.turnScreenOff();
    }

    private void testSuccessfulConnectionWithSpecifier(WifiNetworkSpecifier specifier)
            throws Exception {
        mNrNetworkCallback = mTestHelper.testConnectionFlowWithSpecifier(
                sTestNetwork, specifier, false);
    }

    private void testUserRejectionWithSpecifier(WifiNetworkSpecifier specifier)
            throws Exception {
        mNrNetworkCallback = mTestHelper.testConnectionFlowWithSpecifier(
                sTestNetwork, specifier, true);
    }

    /**
     * Tests the entire connection flow using a specific SSID in the specifier.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSpecifierTest"	"testWifiBandInNetworkCallback"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSpecifierTest.java"	""	"public void testWifiBandInNetworkCallback() throws Exception {
        // Enable all networks and wait for Internet connectivity to be restored.
        // The callbacks in this test will match the existing network as soon as they are filed.
        enableAllSavedNetworks(mWifiManager);
        mTestHelper.assertWifiInternetConnectionAvailable();

        final LinkedBlockingQueue<Pair<Integer, Integer>> results = new LinkedBlockingQueue<>();
        final int[] bands = { ScanResult.WIFI_BAND_24_GHZ, ScanResult.WIFI_BAND_5_GHZ,
                ScanResult.WIFI_BAND_6_GHZ, ScanResult.WIFI_BAND_60_GHZ };
        final ArrayList<NetworkCallback> registeredCallbacks = new ArrayList<>();
        for (final int band : bands) {
            final NetworkCallback callback = new NetworkCallback() {
                @Override public void onCapabilitiesChanged(final Network net,
                        final NetworkCapabilities caps) {
                    results.offer(new Pair(band, TestHelper.getBandFromFrequency(
                            ((WifiInfo) caps.getTransportInfo()).getFrequency())));
                }
            };

            final WifiNetworkSpecifier specifier =
                    new WifiNetworkSpecifier.Builder().setBand(band).build();
            assertThat(specifier.getBand()).isEqualTo(band);

            final NetworkRequest request = new NetworkRequest.Builder()
                .addCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)
                .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)
                .setNetworkSpecifier(specifier)
                .build();
            mConnectivityManager.registerNetworkCallback(request, callback);
            registeredCallbacks.add(callback);
        }

        try {
            // There should be at least one network callback about availability of the wifi network
            // on the right band. If the device is currently connected to multiple WiFi networks,
            // there will be several. Wait for a relatively long time for any callback, but only
            // a short time for subsequent ones (as the last timeout will be incurred always).
            Pair<Integer, Integer> result = results.poll(10, TimeUnit.SECONDS);
            assertThat(result).isNotNull();
            while (null != result) {
                assertThat(result.first).isEqualTo(result.second);
                result = results.poll(200, TimeUnit.MILLISECONDS);
            }
        } finally {
            for (final NetworkCallback cb : registeredCallbacks) {
                mConnectivityManager.unregisterNetworkCallback(cb);
            }
        }
    }

    /**
     * Tests the entire connection flow using a specific SSID in the specifier and ensure that the
     * device auto connects back to some saved network or suggestions in range of the device (that
     * can provide internet connectivity) when the request is released.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiNetworkSpecifierTest"	"testRedact"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiNetworkSpecifierTest.java"	""	"public void testRedact() {
        if (!WifiBuildCompat.isPlatformOrWifiModuleAtLeastS(mContext)) {
            // Skip the test if wifi module version is older than S.
            return;
        }
        WifiNetworkSpecifier specifier = TestHelper
                .createSpecifierBuilderWithCredentialFromSavedNetworkWithBssid(sTestNetwork)
                .setBssidPattern(MacAddress.fromString(sTestNetwork.BSSID),
                        MacAddress.fromString(""ff:ff:ff:00:00:00""))
                .setBand(ScanResult.WIFI_BAND_5_GHZ)
                .build();

        final NetworkSpecifier redacted = specifier.redact();
        if (ApiLevelUtil.isAtLeast(Build.VERSION_CODES.S)) {
            assertThat(new WifiNetworkSpecifier.Builder().setBand(ScanResult.WIFI_BAND_5_GHZ)
                    .build().equals(redacted)).isTrue();
        } else {
            assertThat(redacted.equals(specifier)).isTrue();
        }
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.nl80211.cts.WifiNl80211ManagerTest"	"testOemSecurityTypeConstructor"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/nl80211/cts/WifiNl80211ManagerTest.java"	""	"public void testOemSecurityTypeConstructor() {
        OemSecurityType securityType = new OemSecurityType(
                ScanResult.PROTOCOL_WPA,
                Arrays.asList(ScanResult.KEY_MGMT_PSK, ScanResult.KEY_MGMT_SAE),
                Arrays.asList(ScanResult.CIPHER_NONE, ScanResult.CIPHER_TKIP),
                ScanResult.CIPHER_CCMP);

        assertThat(securityType.protocol).isEqualTo(ScanResult.PROTOCOL_WPA);
        assertThat(securityType.keyManagement)
                .isEqualTo(Arrays.asList(ScanResult.KEY_MGMT_PSK, ScanResult.KEY_MGMT_SAE));
        assertThat(securityType.pairwiseCipher)
                .isEqualTo(Arrays.asList(ScanResult.CIPHER_NONE, ScanResult.CIPHER_TKIP));
        assertThat(securityType.groupCipher).isEqualTo(ScanResult.CIPHER_CCMP);
    }"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"	"isStaConcurrencyForRestrictedConnectionsSupported"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest.java"	""	"/*
 *.
 */

package android.net.wifi.cts;

import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PAID;
import static android.net.NetworkCapabilities.NET_CAPABILITY_OEM_PRIVATE;
import static android.os.Process.myUid;

import static com.google.common.truth.Truth.assertThat;
import static com.google.common.truth.Truth.assertWithMessage;

import static org.junit.Assume.assumeTrue;

import android.content.Context;
import android.content.pm.PackageManager;
import android.location.LocationManager;
import android.net.ConnectivityManager;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;
import android.net.wifi.WifiNetworkSuggestion;
import android.os.Build;
import android.platform.test.annotations.AppModeFull;
import android.support.test.uiautomator.UiDevice;

import androidx.test.ext.junit.runners.AndroidJUnit4;
import androidx.test.filters.LargeTest;
import androidx.test.filters.SdkSuppress;
import androidx.test.platform.app.InstrumentationRegistry;

import com.android.compatibility.common.util.PollingCheck;
import com.android.compatibility.common.util.ShellIdentityUtils;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.util.List;
import java.util.Set;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;

/**
 * Tests multiple concurrent connection flow on devices that support multi STA concurrency
 * (indicated via {@link WifiManager#isStaConcurrencyForRestrictedConnectionsSupported()}.
 *
 * Tests the entire connection flow using {@link WifiNetworkSuggestion} which has
 * {@link WifiNetworkSuggestion.Builder#setOemPaid(boolean)} or
 * {@link WifiNetworkSuggestion.Builder#setOemPrivate(boolean)} set along with a concurrent internet
 * connection using {@link WifiManager#connect(int, WifiManager.ActionListener)}.
 *
 * Assumes that all the saved networks is either open/WPA1/WPA2/WPA3 authenticated network.
 */
@SdkSuppress(minSdkVersion = Build.VERSION_CODES.S)
@AppModeFull(reason = ""Cannot get WifiManager in instant app mode"")
@LargeTest
@RunWith(AndroidJUnit4.class)
public class MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest extends WifiJUnit4TestBase {
    private static final String TAG = ""MultiStaConcurrencyRestrictedWifiNetworkSuggestionTest"";
    private static boolean sWasVerboseLoggingEnabled;
    private static boolean sWasScanThrottleEnabled;
    private static boolean sWasWifiEnabled;

    private Context mContext;
    private WifiManager mWifiManager;
    private ConnectivityManager mConnectivityManager;
    private UiDevice mUiDevice;
    private WifiConfiguration mTestNetworkForRestrictedConnection;
    private WifiConfiguration mTestNetworkForInternetConnection;
    private ConnectivityManager.NetworkCallback mNetworkCallback;
    private ConnectivityManager.NetworkCallback mNsNetworkCallback;
    private ScheduledExecutorService mExecutorService;
    private TestHelper mTestHelper;

    private static final int DURATION_MILLIS = 10_000;

    @BeforeClass
    public static void setUpClass() throws Exception {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        // skip the test if WiFi is not supported or not automotive platform.
        // Don't use assumeTrue in @BeforeClass
        if (!WifiFeature.isWifiSupported(context)) return;

        WifiManager wifiManager = context.getSystemService(WifiManager.class);
        assertThat(wifiManager).isNotNull();

        // turn on verbose logging for tests
        sWasVerboseLoggingEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isVerboseLoggingEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setVerboseLoggingEnabled(true));
        // Disable scan throttling for tests.
        sWasScanThrottleEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isScanThrottleEnabled());
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setScanThrottleEnabled(false));

        // enable Wifi
        sWasWifiEnabled = ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.isWifiEnabled());
        if (!wifiManager.isWifiEnabled()) {
            ShellIdentityUtils.invokeWithShellPermissions(() -> wifiManager.setWifiEnabled(true));
        }
        PollingCheck.check(""Wifi not enabled"", DURATION_MILLIS, () -> wifiManager.isWifiEnabled());
    }

    @AfterClass
    public static void tearDownClass() throws Exception {
        Context context = InstrumentationRegistry.getInstrumentation().getContext();
        if (!WifiFeature.isWifiSupported(context)) return;

        WifiManager wifiManager = context.getSystemService(WifiManager.class);
        assertThat(wifiManager).isNotNull();

        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setScanThrottleEnabled(sWasScanThrottleEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setVerboseLoggingEnabled(sWasVerboseLoggingEnabled));
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> wifiManager.setWifiEnabled(sWasWifiEnabled));
    }

    @Before
    public void setUp() throws Exception {
        mContext = InstrumentationRegistry.getInstrumentation().getContext();
        mWifiManager = mContext.getSystemService(WifiManager.class);
        mConnectivityManager = mContext.getSystemService(ConnectivityManager.class);
        mUiDevice = UiDevice.getInstance(InstrumentationRegistry.getInstrumentation());
        mExecutorService = Executors.newSingleThreadScheduledExecutor();
        mTestHelper = new TestHelper(mContext, mUiDevice);

        // skip the test if WiFi is not supported or not automitve platform.
        assumeTrue(WifiFeature.isWifiSupported(mContext));
        // skip the test if location is not supported
        assumeTrue(mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_LOCATION));
        // skip if multi STA not supported.
        assumeTrue(mWifiManager.isStaConcurrencyForRestrictedConnectionsSupported());

        assertWithMessage(""Please enable location for this test!"").that(
                mContext.getSystemService(LocationManager.class).isLocationEnabled()).isTrue();

        // turn screen on
        mTestHelper.turnScreenOn();

        // Clear any existing app state before each test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));

        // We need 2 AP's for the test. If there are 2 networks saved on the device and in range,
        // use those. Otherwise, check if there are 2 BSSID's in range for the only saved network.
        // This assumes a CTS test environment with at least 2 connectable bssid's (Is that ok?).
        List<WifiConfiguration> savedNetworks = ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.getPrivilegedConfiguredNetworks());
        List<WifiConfiguration> matchingNetworksWithBssid =
                TestHelper.findMatchingSavedNetworksWithBssid(mWifiManager, savedNetworks);
        assertWithMessage(""Need at least 2 saved network bssids in range"").that(
                matchingNetworksWithBssid.size()).isAtLeast(2);
        // Pick any 2 bssid for test.
        mTestNetworkForRestrictedConnection = matchingNetworksWithBssid.get(0);
        // Try to find a bssid for another saved network in range. If none exists, fallback
        // to using 2 bssid's for the same network.
        mTestNetworkForInternetConnection = matchingNetworksWithBssid.stream()
                .filter(w -> !w.SSID.equals(mTestNetworkForRestrictedConnection.SSID))
                .findAny()
                .orElse(matchingNetworksWithBssid.get(1));

        // Disconnect & disable auto-join on the saved network to prevent auto-connect from
        // interfering with the test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : savedNetworks) {
                        mWifiManager.disableNetwork(savedNetwork.networkId);
                    }
                    mWifiManager.disconnect();
                });

        // Wait for Wifi to be disconnected.
        PollingCheck.check(
                ""Wifi not disconnected"",
                20_000,
                () -> mWifiManager.getConnectionInfo().getNetworkId() == -1);
    }

    @After
    public void tearDown() throws Exception {
        // Re-enable networks.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> {
                    for (WifiConfiguration savedNetwork : mWifiManager.getConfiguredNetworks()) {
                        mWifiManager.enableNetwork(savedNetwork.networkId, false);
                    }
                });
        // Release the requests after the test.
        if (mNetworkCallback != null) {
            mConnectivityManager.unregisterNetworkCallback(mNetworkCallback);
        }
        if (mNsNetworkCallback != null) {
            mConnectivityManager.unregisterNetworkCallback(mNsNetworkCallback);
        }
        mExecutorService.shutdownNow();
        // Clear any existing app state after each test.
        ShellIdentityUtils.invokeWithShellPermissions(
                () -> mWifiManager.removeAppState(myUid(), mContext.getPackageName()));
        mTestHelper.turnScreenOff();
    }

    /**
     * Tests the concurrent connection flow.
     * 1. Connect to a network using internet connectivity API.
     * 2. Connect to a network using restricted suggestion API.
     * 3. Verify that both connections are active.
     */"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.app.TriggerScanAndReturnStatusActivity"	"finish"	""	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/CtsWifiLocationTestApp/src/android/net/wifi/cts/app/TriggerScanAndReturnStatusActivity.java"	""	"public void test/*
 *.
 */

package android.net.wifi.cts.app;

import android.app.Activity;
import android.content.Intent;
import android.net.wifi.WifiManager;
import android.os.Bundle;
import android.util.Log;

/**
 * An activity that triggers a wifi scan and returns status.
 */
public class TriggerScanAndReturnStatusActivity extends Activity {
    private static final String TAG = ""TriggerScanAndReturnStatusActivity"";
    private static final String SCAN_STATUS_EXTRA = ""android.net.wifi.cts.app.extra.STATUS"";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        WifiManager wifiManager = getSystemService(WifiManager.class);
        boolean succeeded;
        try {
            succeeded = wifiManager.startScan();
        } catch (SecurityException e) {
            succeeded = false;
        }
        if (succeeded) {
            Log.v(TAG, ""Scan trigger succeeded"");
        } else {
            Log.v(TAG, ""Failed to trigger scan"");
        }
        setResult(RESULT_OK, new Intent().putExtra(SCAN_STATUS_EXTRA, succeeded));
        finish();
    }
}"	""	""	"scan"	""	""	""	""	""	""	""	""	""	""
"7.4.2  . IEEE 802.11"	"7.4.2"	"C-1-10"	"7.4.2/C-1-10"	"07040200.670110"	"""C-1-10] MUST randomize Probe request sequence number between the last probe request of a scan and the first probe request of the next scan."""	""	""	"scan probe"	""	""	""	""	""	""	""	""	"android.net.wifi.cts.WifiMigrationTest"	"testWifiMigrationSettingsDataBuilder"	"CtsWifiTestCases"	"/home/gpoor/cts-12-source/cts/tests/tests/wifi/src/android/net/wifi/cts/WifiMigrationTest.java"	""	"public void testWifiMigrationSettingsDataBuilder() throws Exception {
        if (!WifiFeature.isWifiSupported(getContext())) {
            // skip the test if WiFi is not supported
            return;
        }
        WifiMigration.SettingsMigrationData migrationData =
                new WifiMigration.SettingsMigrationData.Builder()
                        .setScanAlwaysAvailable(true)
                        .setP2pFactoryResetPending(true)
                        .setScanThrottleEnabled(true)
                        .setSoftApTimeoutEnabled(true)
                        .setWakeUpEnabled(true)
                        .setVerboseLoggingEnabled(true)
                        .setP2pDeviceName(TEST_SSID_UNQUOTED)
                        .build();

        assertNotNull(migrationData);
        assertTrue(migrationData.isScanAlwaysAvailable());
        assertTrue(migrationData.isP2pFactoryResetPending());
        assertTrue(migrationData.isScanThrottleEnabled());
        assertTrue(migrationData.isSoftApTimeoutEnabled());
        assertTrue(migrationData.isWakeUpEnabled());
        assertTrue(migrationData.isVerboseLoggingEnabled());
        assertEquals(TEST_SSID_UNQUOTED, migrationData.getP2pDeviceName());
    }

    /**
     * Tests {@link android.net.wifi.WifiMigration.SettingsMigrationData} class.
     */"	""	""	"scan scan"	""	""	""	""	""	""	""	""	""	""
